[
  {
    "owner": "zio",
    "repo": "zio",
    "content": "TITLE: Conceptual Representation of a ZIO Effect in Scala\nDESCRIPTION: Shows the conceptual function signature that a `ZIO[R, E, A]` effect resembles. This function requires an environment `R` and might produce either an error `E` (representing failure) or a success value `A`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nR => Either[E, A]\n```\n\n----------------------------------------\n\nTITLE: Implementing Service with Dependencies\nDESCRIPTION: Complete implementation of DocRepo service with MetadataRepo and BlobStorage dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/service-pattern.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfinal class DocRepoLive(\n  metadataRepo: MetadataRepo,\n  blobStorage: BlobStorage\n) extends DocRepo {\n  override def get(id: String): ZIO[Any, Throwable, Doc] =\n    (metadataRepo.get(id) <&> blobStorage.get(id)).map {\n      case (metadata, content) =>\n        Doc(\n          title = metadata.title,\n          description = metadata.description,\n          language = metadata.language,\n          format = metadata.format,\n          content = content\n        )\n    }\n    \n  override def save(document: Doc): ZIO[Any, Throwable, String] =\n    for {\n      id       <- blobStorage.put(document.content)\n      metadata = Metadata(\n        title = document.title,\n        description = document.description,\n        language = document.language,\n        format = document.format\n      )\n      _        <- metadataRepo.put(id, metadata)\n    } yield id\n\n  override def delete(id: String): ZIO[Any, Throwable, Unit] = blobStorage.delete(id) &> metadataRepo.delete(id).unit\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] =\n    for {\n      metadatas <- metadataRepo.findByTitle(title)\n      content   <- ZIO.foreachPar(metadatas) { (id, metadata) =>\n                     blobStorage\n                       .get(id)\n                       .map { content =>\n                         val doc = Doc(\n                           title = metadata.title,\n                           description = metadata.description,\n                           language = metadata.language,\n                           format = metadata.format,\n                           content = content\n                         )\n                    \n                         id -> doc\n                       }\n                   }\n    } yield content.values.toList\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying a Ref Using Atomic Compare-And-Set in ZIO (Scala)\nDESCRIPTION: This Scala code defines the core thread-safe, atomic modification operation for ZIO's Ref concurrency primitive using a lock-free algorithm based on CAS (compare-and-set). It repeatedly attempts to update the Ref's value via a function until the CAS operation succeeds, ensuring atomicity without blocking. The modify method returns an uninterruptible effect, and expects a transformation function f that returns a tuple of result and new state; it requires an AtomicReference dependency and is specialized for use within the ZIO effect system.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  final case class Ref[A](value: AtomicReference[A]) { self =>\\n    def modify[B](f: A => (B, A)): UIO[B] = UIO.effectTotal {\\n      var loop = true\\n      var b: B = null.asInstanceOf[B]\\n      while (loop) {\\n        val current = value.get\\n        val tuple   = f(current)\\n        b = tuple._1\\n        loop = !value.compareAndSet(current, tuple._2)\\n      }\\n      b\\n    }\\n }\n```\n\n----------------------------------------\n\nTITLE: Forking ZIO Fibers in Specific Scopes with forkIn\nDESCRIPTION: This example shows how to use ZIO#forkIn to fork a fiber in a specific scope for more fine-grained control. The fiber is attached to an outer scope, allowing it to continue running even after the inner scope is closed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO.scoped {\n      for {\n        scope <- ZIO.scope\n        _     <-\n          ZIO.scoped {\n            for {\n              _ <- ZIO\n                     .debug(\"Still running ...\")\n                     .repeat(Schedule.fixed(1.second))\n                     .forkIn(scope)\n              _ <- ZIO.sleep(3.seconds)\n              _ <- ZIO.debug(\"The innermost scope is about to be closed.\")\n            } yield ()\n          }\n        _     <- ZIO.sleep(5.seconds)\n        _     <- ZIO.debug(\"The outer scope is about to be closed.\")\n      } yield ()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Resource Control with Custom Semaphore in ZIO (Scala)\nDESCRIPTION: This snippet uses the previously defined S semaphore to control concurrent access to a shared resource (simulated by 100 dancers on a 10-unit dancefloor). It demonstrates ZIO's parallel combinators and random delays, highlighting dependency on zio.Console and zio.Random. Inputs: total dancer count, dancefloor capacity; outputs: effect coordinating resource-acquisition, sleeping, and printing operations in parallel. Assumes prior availability of S and ZIO environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.Console._\n\nval party = for {\n  dancefloor <- S(10)\n  dancers <- ZIO.foreachPar(1 to 100) { i =>\n    dancefloor.P *> Random.nextDouble.map(d => Duration.fromNanos((d * 1000000).round)).flatMap { d =>\n      printLine(s\"${i} checking my boots\") *> ZIO.sleep(d) *> printLine(s\"${i} dancing like it's 99\")\n    } *> dancefloor.V\n  }\n} yield ()\n\n```\n\n----------------------------------------\n\nTITLE: Using For Comprehensions with ZIO Effects\nDESCRIPTION: Shows how to use Scala's for-comprehension syntax for composing sequences of ZIO effects. This provides a more procedural, readable way to express chains of dependent effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval program =\n  for {\n    _    <- Console.printLine(\"Hello! What is your name?\")\n    name <- Console.readLine\n    _    <- Console.printLine(s\"Hello, ${name}, welcome to ZIO!\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Composing Application and Main Entry Point with ZIO Layers - Scala\nDESCRIPTION: Demonstrates the pattern of composing an ApplicationService that internally uses high-level and low-level services, and wiring them for use in a ZIOAppDefault main class. Showcases the environment and dependency injection via ZLayer, and the idiomatic usage of serviceWithZIO for accessing dependencies. The dependency chain is built bottom-up, and run is expected to be a ZIO effect yielding Unit.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zio-environment-use-cases.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait ApplicationService {\n  def run: ZIO[Any, Nothing, Unit]\n}\n\nobject ApplicationService {\n  val live: ZLayer[Any, Nothing, LowLevelService] = ???\n  \n  final case class ApplicationServiceLive(highLevelService: HighLevelService) extends ApplicationService {\n    val run: ZIO[Any, Nothing, Unit] = ??? // business logic implemented in terms of high level services\n  }\n}\n\nobject Main extends ZIOAppDefault {\n  val run =\n    ZIO\n      .serviceWithZIO[ApplicationService](_.run)\n      .provide(\n        ApplicationService.live,\n        HighLevelService.live,\n        LowLevelService.live\n      )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIOAppDefault for Running ZIO Effects in Scala\nDESCRIPTION: This snippet demonstrates how to create a standalone Scala application using ZIOAppDefault. It defines a simple interactive program that asks for the user's name and prints a welcome message.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/running-effects.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Console._\n\nobject MyApp extends ZIOAppDefault {\n\n  def run =\n    for {\n      _    <- printLine(\"Hello! What is your name?\")\n      name <- readLine\n      _    <- printLine(s\"Hello, ${name}, welcome to ZIO!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Route in ZIO HTTP\nDESCRIPTION: This code demonstrates how to define a simple Route in ZIO HTTP. It creates a GET route that responds with 'Hello, world!' when accessed at the '/hello' path.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\n\nval helloRoute: Route[Any, Nothing] =\n  Method.GET / \"hello\" -> handler(Response.text(\"Hello, world!\"))\n```\n\n----------------------------------------\n\nTITLE: Running a Basic ZIO Effect with ZIOAppDefault in Scala\nDESCRIPTION: This snippet demonstrates the basic structure of a ZIO application using `ZIOAppDefault`. The `run` method serves as the entry point and contains the core application logic, implemented as a ZIO effect. In this case, it performs simple console interaction: prompting for a name, reading input, and printing a greeting. It depends on the `zio` library, specifically `ZIOAppDefault`, `ZIO`, and `Console`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zioapp.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MyApp extends ZIOAppDefault {\n  def run = for {\n    _ <- Console.printLine(\"Hello! What is your name?\")\n    n <- Console.readLine\n    _ <- Console.printLine(\"Hello, \" + n + \", good to meet you!\")\n  } yield ()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic ZIO Application using zio.App (Scala)\nDESCRIPTION: Illustrates a complete ZIO application structure by extending `zio.App`. The `run` method defines the entry point, returning the exit code derived from the application logic (`myAppLogic`). The example uses a `for` comprehension with `putStrLn` and `getStrLn` from `zio.console` for basic interactive console I/O. The application logic must result in an effect that resolves to an `ExitCode`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/getting_started.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console._\n\nobject MyApp extends zio.App {\n\n  def run(args: List[String]) =\n    myAppLogic.exitCode\n\n  val myAppLogic =\n    for {\n      _    <- putStrLn(\"Hello! What is your name?\")\n      name <- getStrLn\n      _    <- putStrLn(s\"Hello, ${name}, welcome to ZIO!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: GraphQL Server Implementation\nDESCRIPTION: Complete implementation of the GraphQL server using ZIO and Caliban\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport caliban._\nimport caliban.quick._\n\nobject MainApp extends zio.ZIOAppDefault {\n  import caliban.schema.ArgBuilder.auto._\n  import caliban.schema.Schema.auto._\n\n  private val employees = List(\n    Employee(\"Alex\", Role.DevOps),\n    Employee(\"Maria\", Role.SoftwareDeveloper),\n    Employee(\"James\", Role.SiteReliabilityEngineer),\n    Employee(\"Peter\", Role.SoftwareDeveloper),\n    Employee(\"Julia\", Role.SiteReliabilityEngineer),\n    Employee(\"Roberta\", Role.DevOps)\n  )\n\n  override def run =\n    graphQL(\n      RootResolver(\n        Queries(\n          args => employees.filter(e => args.role == e.role),\n          args => employees.find(e => e.name == args.name)\n        )\n      )\n    ).runServer(\n      port = 8088,\n      apiPath = \"/api/graphql\",\n      graphiqlPath = Some(\"/api/graphiql\"),\n    )\n\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Failing ZIO Effects with ZIO.fail in Scala\nDESCRIPTION: Shows how to use `ZIO.fail` to create a ZIO effect that immediately fails with the specified error value. In this example, the error is a simple `String`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval f1 = ZIO.fail(\"Uh oh!\")\n```\n\n----------------------------------------\n\nTITLE: Composing ZLayers Manually in Scala\nDESCRIPTION: Shows how to manually compose ZLayers for A and B services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval appLayer: ZLayer[Any, Nothing, A with B] = \n  A.layer ++ B.layer\n```\n\n----------------------------------------\n\nTITLE: Using ZState for Stateful ZIO Applications\nDESCRIPTION: Example demonstrating how to use ZState with ZIO to manage application state. The example shows defining a custom state class, updating state, retrieving state, and providing initial state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_84\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject ZStateExample extends zio.ZIOAppDefault {\n  final case class MyState(counter: Int)\n\n  val app = for {\n    _     <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n    count <- ZIO.getStateWith[MyState](_.counter)\n    _     <- Console.printLine(count)\n  } yield count\n\n  def run = app.provide(ZState.initial(MyState(0)))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Semaphore using ZIO Ref\nDESCRIPTION: Demonstrates how to build a basic semaphore concurrency primitive using ZIO Ref, implementing P and V operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait S {\n  def P: UIO[Unit]\n  def V: UIO[Unit]\n}\n\nobject S {\n  def apply(v: Long): UIO[S] =\n    Ref.make(v).map { vref =>\n      new S {\n        def V = vref.update(_ + 1).unit\n\n        def P = (vref.get.flatMap { v =>\n          if (v < 0)\n            IO.fail(())\n          else\n            vref.modify(v0 => if (v0 == v) (true, v - 1) else (false, v)).flatMap {\n              case false => IO.fail(())\n              case true  => IO.unit\n            }\n        } <> P).unit\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Absorb/Resurrect after OrDie in Scala\nDESCRIPTION: Demonstrates converting a ZIO failure to a defect using `orDie`, and then converting it back to a `Throwable` failure using `absorb` or `resurrect`. Finally, `refineToOrDie` is used to narrow the error type back to the original `IllegalArgumentException`. This illustrates the symmetrical nature of `orDie` and `absorb`/`resurrect`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/converting-defects-to-failures.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval effect1 =\n  ZIO.fail(new IllegalArgumentException(\"wrong argument\"))  // ZIO[Any, IllegalArgumentException, Nothing]\n    .orDie                                                  // ZIO[Any, Nothing, Nothing]\n    .absorb                                                 // ZIO[Any, Throwable, Nothing]\n    .refineToOrDie[IllegalArgumentException]                // ZIO[Any, IllegalArgumentException, Nothing]\n\nval effect2 =\n  ZIO.fail(new IllegalArgumentException(\"wrong argument\"))  // ZIO[Any, IllegalArgumentException , Nothing]\n    .orDie                                                  // ZIO[Any, Nothing, Nothing]\n    .resurrect                                              // ZIO[Any, Throwable, Nothing]\n    .refineToOrDie[IllegalArgumentException]                // ZIO[Any, IllegalArgumentException, Nothing]\n```\n\n----------------------------------------\n\nTITLE: File Line Counter Using ZIO AcquireRelease\nDESCRIPTION: Implementation of file line counter using ZIO's acquireRelease pattern for proper resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef lines(file: String): Task[Long] = {\n  def countLines(reader: BufferedReader): Task[Long]    = ZIO.attempt(reader.lines().count())\n  def releaseReader(reader: BufferedReader): UIO[Unit]  = ZIO.succeed(reader.close())\n  def acquireReader(file: String): Task[BufferedReader] = ZIO.attempt(new BufferedReader(new FileReader(file), 2048))\n\n  ZIO.acquireReleaseWith(acquireReader(file))(releaseReader)(countLines)\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple ZIO Aspects for Parallel Download Operations\nDESCRIPTION: Shows how to compose multiple aspects (retry and logging) on a download operation within a parallel execution. The order of aspect composition matters as it affects the behavior of the combined operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef download(url: String): ZIO[Any, Throwable, Chunk[Byte]] = ZIO.succeed(???)\n\nZIO.foreachPar(List(\"zio.dev\", \"google.com\")) { url =>\n  download(url) @@\n    ZIOAspect.retry(Schedule.fibonacci(1.seconds)) @@\n    ZIOAspect.loggedWith[Chunk[Byte]](file => s\"Downloaded $url file with size of ${file.length} bytes\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Polymorphic Service in a ZIO Application\nDESCRIPTION: A complete ZIO application demonstrating how to use the polymorphic KeyValueStore service with its accessor methods. The example shows setting, getting, and removing values, and provides the implementation layer to the ZIO runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[KeyValueStore[String, Int, String, IO], String, Unit] =\n    for {\n      _ <- KeyValueStore.set[String, Int, String](\"key1\", 3).debug\n      _ <- KeyValueStore.get[String, Int, String](\"key1\").debug\n      _ <- KeyValueStore.remove[String, Int, String](\"key1\")\n      _ <- KeyValueStore.get[String, Int, String](\"key1\").either.debug\n    } yield ()\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer)\n  \n}\n\n// Output:\n// 3\n// 3\n// not found\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic ZIO Application in Scala\nDESCRIPTION: This snippet demonstrates how to create a simple ZIO application that prints 'Hello, world!' to the console. It uses ZIO 2.x and extends ZIOAppDefault for easy execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/running-our-first-zio-project-with-intellij-idea.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Main extends ZIOAppDefault {\n  def run = Console.printLine(\"Hello, world!\")\n}\n```\n\n----------------------------------------\n\nTITLE: ZIO Hello World Application Using FlatMap\nDESCRIPTION: An alternative implementation of the interactive Hello World application using flatMap instead of for-comprehension. This demonstrates how for-comprehension is syntactic sugar for nested flatMap operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/hello-world.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    Console.print(\"Please enter your name: \")\n      .flatMap { _ =>\n        Console.readLine\n          .flatMap { name =>\n            Console.printLine(s\"Hello, $name!\")\n          }\n      }\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Service Layers for a ZIO Application (Scala)\nDESCRIPTION: Presents a complete example of ZLayer composition, combining several layers (DatabaseConfig, Database, Analytics, Users, App) into an application. Requires ZIOAppDefault and ZIO libraries. Shows chaining with >>> and parallel combination with ++, culminating in a main object that runs the application logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class DatabaseConfig()\n\nobject DatabaseConfig {\n  val live = ZLayer.succeed(DatabaseConfig())\n}\n\ncase class Database(databaseConfig: DatabaseConfig)\n\nobject Database {\n  val live: ZLayer[DatabaseConfig, Nothing, Database] =\n    ZLayer.fromFunction(Database.apply _)\n}\n\ncase class Analytics()\n\nobject Analytics {\n  val live: ULayer[Analytics] = ZLayer.succeed(Analytics())\n}\n\ncase class Users(database: Database, analytics: Analytics)\n\nobject Users {\n  val live = ZLayer.fromFunction(Users.apply _)\n}\n\ncase class App(users: Users, analytics: Analytics) {\n  def execute: UIO[Unit] =\n    ZIO.debug(s\"This app is made from ${users} and ${analytics}\")\n}\n\nobject App {\n  val live = ZLayer.fromFunction(App.apply _)\n}\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    ZIO\n      .serviceWithZIO[App](_.execute)\n      // Cannot use `provide` due to this dotty bug: https://github.com/lampepfl/dotty/issues/12498\n      .provideLayer(\n        (((DatabaseConfig.live >>> Database.live) ++ Analytics.live >>> Users.live) ++ Analytics.live) >>> App.live\n      )\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Loom-Based Executor in ZIO Runtime via Bootstrap Layer (Scala)\nDESCRIPTION: This snippet demonstrates configuring the ZIO runtime to use Java virtual threads (Project Loom) for its main executor. This is achieved by overriding the `bootstrap` layer in a `ZIOAppDefault` and setting it to `Runtime.enableLoomBasedExecutor`. The example then runs a simple task using `ZIO.attempt` and prints the thread name, showing it's running on a virtual thread. Requires JDK 21+.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  override val bootstrap = \n    Runtime.enableLoomBasedExecutor\n\n  override def run = ZIO.attempt {\n    println(s\"Task running on a virtual-thread: ${Thread.currentThread().getName()}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Incoming Requests in ZIO HTTP\nDESCRIPTION: This snippet demonstrates how to pattern match on incoming requests in ZIO HTTP. It shows how to extract the HTTP method, path, and parameters from a request and use them to generate a response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\n\nval httpApp: Route[Any, Nothing] =\n  Method.GET / \"greet\" / string(\"name\") ->\n    handler { (name: String, _: Request) =>\n      Response.text(s\"Hello $name!\")\n    }\n```\n\n----------------------------------------\n\nTITLE: FiberRef Logger Usage Example\nDESCRIPTION: Example program demonstrating the usage of FiberRef-based logging with parallel request processing and contextual annotations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject FiberRefLoggingExample extends ZIOAppDefault {\n  def run =\n    for {\n      _ <- Logging.log(\"Hello World!\")\n      _ <- ZIO.foreachParDiscard(List(\"Jane\", \"John\")) { name =>\n        Logging.logAnnotate(\"name\", name) {\n          for {\n            _       <- Logging.log(s\"Received request\")\n            fiberId <- ZIO.fiberId.map(_.ids.head)\n            _ <- Logging.logAnnotate(\"fiber_id\", s\"$fiberId\")(\n              Logging.log(\"Processing request\")\n            )\n            _ <- Logging.log(\"Finished processing request\")\n          } yield ()\n        }\n      }\n      _ <- Logging.log(\"All requests processed\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Sidecar Pattern with Compositional Apps in Scala ZIO\nDESCRIPTION: This snippet demonstrates how to implement the sidecar pattern using compositional apps in ZIO. It defines separate apps for user management, document handling, and metrics, then combines them into a main application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/architectural-patterns.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http._\nimport zio.metrics.connectors.prometheus.PrometheusPublisher\nimport zio.metrics.connectors.{MetricsConfig, prometheus}\n\nobject UserApp extends ZIOAppDefault {\n  def run = Server.serve(userHttpApp).provide(Server.defaultWithPort(8080))\n}\n\nobject DocumentApp extends ZIOAppDefault {\n  def run = Server.serve(documentHttpApp).provide(Server.defaultWithPort(8081))\n}\n\nobject Metrics extends ZIOAppDefault {\n  private val metricsConfig = ZLayer.succeed(MetricsConfig(5.seconds))\n\n  def run =\n    Server\n      .serve(\n        Routes(Method.GET / \"metrics\" ->\n          handler(ZIO.serviceWithZIO[PrometheusPublisher](_.get.map(Response.text)))\n        )\n      )\n      .provide(\n        Server.defaultWithPort(8082),\n        metricsConfig,\n        prometheus.publisherLayer,\n        prometheus.prometheusLayer\n      )\n}\n\nobject MainApp extends ZIOApp.Proxy(UserApp <> DocumentApp <> Metrics)\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Effects from Asynchronous Code in Scala\nDESCRIPTION: Demonstrates how to convert asynchronous, callback-based code into ZIO effects using ZIO.async. This allows for easier use of asynchronous APIs and benefits from ZIO features like interruption and error management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/creating-effects.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval login: ZIO[Any, AuthError, User] =\n  ZIO.async[Any, AuthError, User] { callback =>\n    legacy.login(\n      user => callback(ZIO.succeed(user)),\n      err  => callback(ZIO.fail(err))\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Greeting Routes in Scala\nDESCRIPTION: Defines routes for a basic greeting service that doesn't require any environment dependencies and won't fail.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/restful-webservice.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject GreetingRoutes {\n  def apply(): Routes[Any, Nothing] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating ZIO with Legacy Scala Application using Custom Runtime\nDESCRIPTION: This snippet showcases integrating a ZIO workflow into a non-ZIO (legacy) Scala application. It defines placeholders for a logger (`sl4jlogger`), a legacy function, and a ZIO workflow. A custom `Runtime` is created unsafely from a layer that configures logging. A `zioApplication` function uses this custom runtime to unsafely run the `zioWorkflow`. The `main` method orchestrates calling the ZIO part and passing its result to the legacy function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp {\n  val sl4jlogger: ZLogger[String, Any] = ???\n\n  def legacyApplication(input: Int): Unit = ???\n\n  val zioWorkflow: ZIO[Any, Nothing, Int] = ???\n\n  val runtime: Runtime[Unit] =\n    Unsafe.unsafe { implicit unsafe =>\n      Runtime.unsafe\n        .fromLayer(\n          Runtime.removeDefaultLoggers ++ Runtime.addLogger(sl4jlogger)\n        )\n    }\n\n  def zioApplication(): Int =\n    Unsafe.unsafe { implicit unsafe =>\n      runtime.unsafe\n        .run(zioWorkflow)\n        .getOrThrowFiberFailure()\n    }\n\n  def main(args: Array[String]): Unit = {\n    val result = zioApplication()\n    legacyApplication(result)\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Decoupling Services using Traits and Concrete Implementations in Scala\nDESCRIPTION: Introduces traits (`Formatter`, `Compiler`, `Editor`) to define service contracts and concrete classes (`ScalaFormatter`, `ScalaCompiler`, `EditorLive`) that implement these traits. `EditorLive` depends on the `Formatter` and `Compiler` traits, allowing different implementations to be injected. The example then instantiates the concrete implementations and assembles them.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent:nest\ntrait Formatter {\n  def format(code: String): UIO[String]\n}\n\nclass ScalaFormatter extends Formatter {\n  def format(code: String): UIO[String] = \n    ZIO.succeed(code) // dummy implementation\n}\n\ntrait Compiler {\n  def compile(code: String): UIO[String]\n}\n\nclass ScalaCompiler extends Compiler {\n  def compile(code: String): UIO[String] = \n    ZIO.succeed(code) // dummy implementation\n}\n\ntrait Editor {\n  def formatAndCompile(code: String): UIO[String]\n}\n\nclass EditorLive(formatter: Formatter, compiler: Compiler) extends Editor {\n  def formatAndCompile(code: String): UIO[String] =\n    formatter.format(code).flatMap(compiler.compile)\n}\n\nval formatter = new ScalaFormatter() // Creating Formatter\nval compiler  = new ScalaCompiler()  // Creating Compiler\nval editor    = new EditorLive(formatter, compiler) // Assembling formatter and compiler into CodeEditor\n\neditor.formatAndCompile(\"println(\\\"Hello, world!\\\")\")\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Resourceful File Reading Stream in Scala\nDESCRIPTION: This example demonstrates how to use 'acquireReleaseWith' to create a resource-safe stream for reading lines from a file. It handles file opening and closing automatically.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/resourceful-streams.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval lines: ZStream[Any, Throwable, String] =\n  ZStream\n    .acquireReleaseWith(\n      ZIO.attempt(Source.fromFile(\"file.txt\")) <* printLine(\"The file was opened.\")\n    )(x => ZIO.succeed(x.close()) <* printLine(\"The file was closed.\").orDie)\n    .flatMap { is =>\n      ZStream.fromIterator(is.getLines())\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing User Management Routes in Scala\nDESCRIPTION: Creates routes for user management with UserRepo service dependency and Response error type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/restful-webservice.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject UserRoutes {\n  def apply(): Routes[UserRepo, Response] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Effects from Synchronous Code in Scala\nDESCRIPTION: Shows how to convert synchronous code into ZIO effects using ZIO.attempt and ZIO.succeed. It also demonstrates error refinement with refineToOrDie for specific exception types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/creating-effects.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval readLine: ZIO[Any, Throwable, String] =\n  ZIO.attempt(StdIn.readLine())\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef printLine(line: String): UIO[Unit] =\n  ZIO.succeed(println(line))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval readLine2: ZIO[Any, IOException, String] =\n  ZIO.attempt(StdIn.readLine()).refineToOrDie[IOException]\n```\n\n----------------------------------------\n\nTITLE: Basic ZIO Hello World Application\nDESCRIPTION: A simple ZIO application that prints 'Hello, World!' to the console. It extends ZIOAppDefault and implements the run method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/hello-world.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = Console.printLine(\"Hello, World!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Joining a Forked Fiber in Scala using ZIO\nDESCRIPTION: This snippet shows how to join a forked fiber in ZIO. It forks an effect that produces a string message, then joins the fiber to retrieve the result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber   <- ZIO.succeed(\"Hi!\").fork\n  message <- fiber.join\n} yield message\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Domain Model and State Transitions with Edomata (Scala)\nDESCRIPTION: This complex Scala snippet defines the core domain logic for the event-sourced counter, using Edomata with Cats Effect, Fs2, and associated syntax. It provides methods for increment and decrement actions tied to events, enforces non-negative state, and specifies the initial state and transitions using the tagless final style. This section depends on Edomata, Cats Effect, and implicit syntax imports, and it requires a functional effect runtime (e.g., Cats Effect or ZIO via interop). The inputs/outputs involve Counter state and event-driven transitions with rejection scenarios for invalid states.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.data.ValidatedNec\nimport edomata.core.{Decision, DomainModel}\nimport cats.implicits.*\nimport edomata.syntax.all.*\n\ncase class Counter(state: Int) {\n  def inc = this.perform { Decision.accept(Event.Increased) }\n  def dec = this.perform {\n    if (state > 0) Decision.accept(Event.Decreased) else \"decision rejected\".reject\n  }\n}\n\nobject Counter extends DomainModel[Counter, Event, String] {\n  override def initial: Counter = Counter(0)\n\n  override def transition = {\n    case Event.Increased => state => state.copy(state = state.state + 1).validNec\n    case Event.Decreased => state => state.copy(state = state.state - 1).validNec\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel File Transfer Using AcquireRelease\nDESCRIPTION: Improved file transfer implementation using parallel resource acquisition with ZIO's acquireRelease.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(src: String, dst: String): ZIO[Any, Throwable, Unit] =\n  ZIO.acquireReleaseWith {\n    is(src).zipPar(os(dst))\n  } { case (in, out) =>\n    ZIO.succeed(in.close()).zipPar(ZIO.succeed(out.close()))\n  } { case (in, out) =>\n    copy(in, out)\n  }\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO HTTP Dependency in Scala\nDESCRIPTION: This snippet shows how to add the ZIO HTTP library dependency to a Scala project. It specifies the library coordinates and version required for building HTTP applications with ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  \"dev.zio\"  %% \"zio-http\" % \"3.0.0-RC6\"\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing ZIO HTTP Server with Greeting Routes (Scala)\nDESCRIPTION: Shows how to start a ZIO HTTP server serving the defined GreetingRoutes. The MainApp class extends ZIOAppDefault, and in its run method, it serves the GreetingRoutes and provides the default server configuration. Requires zio, zio-http, and assumes that GreetingRoutes is defined. Key parameters involve the composed routes; the output is a running HTTP server on the configured port.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\\nimport zio.http._\\n\\nobject MainApp extends ZIOAppDefault {\\n  def run =\\n    Server.serve(GreetingRoutes()).provide(Server.default)\\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Fibers with orElse in Scala using ZIO\nDESCRIPTION: This code shows how to compose two fibers using the orElse method in ZIO. It demonstrates fallback behavior where the second fiber's result is used if the first fiber fails.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber1 <- ZIO.fail(\"Uh oh!\").fork\n  fiber2 <- ZIO.succeed(\"Hurray!\").fork\n  fiber   = fiber1.orElse(fiber2)\n  message  <- fiber.join\n} yield message\n```\n\n----------------------------------------\n\nTITLE: Improved Compile-time Execution Tracing in ZIO 2.x\nDESCRIPTION: Example demonstrating the improved execution tracing in ZIO 2.x, which provides more descriptive Java-style stacktraces with precise error locations using compile-time tracing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_93\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject TracingExample extends ZIOAppDefault {\n\n  def doSomething(input: Int): ZIO[Any, String, Unit] =\n    for {\n      _ <- Console.printLine(s\"Do something $input\").orDie\n      _ <- ZIO.fail(\"Boom!\") // line number 8\n      _ <- Console.printLine(\"Finished my job\").orDie\n    } yield ()\n\n  def myApp: ZIO[Any, String, Unit] =\n    for {\n      _ <- Console.printLine(\"Hello!\").orDie\n      _ <- doSomething(5)   // line number 15\n      _ <- Console.printLine(\"Bye Bye!\").orDie\n    } yield ()\n\n  def run = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: Zipping Effects in ZIO (Scala)\nDESCRIPTION: Demonstrates how to combine two effects into a single effect using the `zip` method in ZIO. The resulting effect succeeds with a tuple containing the success values of both effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval zipped: UIO[(String, Int)] =\n  ZIO.succeed(\"4\").zip(ZIO.succeed(2))\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Blocking Tasks on ZIO Blocking Thread Pool\nDESCRIPTION: Demonstrates how to execute blocking operations on ZIO's dedicated blocking thread pool using ZIO.blocking. This prevents blocking operations from interfering with the asynchronous operations on the main thread pool.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval program = ZIO.foreachPar((1 to 100).toArray)(t => ZIO.blocking(blockingTask(t)))\n```\n\n----------------------------------------\n\nTITLE: Defining Service Interface with Scala Traits\nDESCRIPTION: Demonstrates the definition of a DocRepo service using a Scala trait with basic document management operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/service-pattern.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfinal case class Doc(\n  title: String,\n  description: String,\n  language: String,\n  format: String,\n  content: Array[Byte]\n)\n\ntrait DocRepo {\n  def get(id: String): ZIO[Any, Throwable, Doc]\n\n  def save(document: Doc): ZIO[Any, Throwable, String]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n\n  def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]]\n}\n```\n\n----------------------------------------\n\nTITLE: Reading File Contents Using ZIO Streams\nDESCRIPTION: This snippet showcases how to read a file, decode its contents, split it into lines, and print each line using ZIO Streams. This approach can handle files of any size efficiently, as it processes the file in chunks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nZStream.fromFileName(\"file.txt\")\n  .via(ZPipeline.utf8Decode >>> ZPipeline.splitLines)\n  .foreach(printLine(_))\n```\n\n----------------------------------------\n\nTITLE: Safe Concurrent State Management with Ref.modify in Scala\nDESCRIPTION: Demonstrates a safe way to manage state in concurrent environments using the modify method, which combines get, set, and get operations atomically.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// Safe in Concurrent Environment\ndef request(counter: Ref[Int]) = {\n  for {\n    rn <- counter.modify(c => (c + 1, c + 1))\n    _  <- Console.printLine(s\"request number received: $rn\")\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Using zipRight in ZIO (Scala)\nDESCRIPTION: Shows how to use the `zipRight` function to combine two effects, discarding the result of the left-hand side. This is useful when the success value of an effect is not needed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval zipRight1 =\n  Console.printLine(\"What is your name?\").zipRight(Console.readLine)\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies with Horizontal Composition in ZLayer\nDESCRIPTION: This example demonstrates how to update a dependency using horizontal composition with the ++ operator. The origin layer with String, Int, and Double components is combined with a new layer providing an Int value of 321, which replaces the original Int component.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval origin: ZLayer[Any, Nothing, String & Int & Double] =\n  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double](\"foo\", 123, 1.3))\n\nval updated = origin ++ ZLayer.succeed(321)\n```\n\n----------------------------------------\n\nTITLE: Serving Routes with ZIO HTTP Server\nDESCRIPTION: This code demonstrates how to serve the defined routes using ZIO HTTP Server. It creates a ZIO application that starts the server with the specified routes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http._\n\nobject MainApp extends ZIOAppDefault {\n  def run = Server.serve(routes).provide(Server.default)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Divide Function with Imperative Error Handling in Scala\nDESCRIPTION: Demonstrates an imperative approach to error handling using exceptions in a division function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef divide(a: Int, b: Int): Int =\n  if (b == 0)\n    throw new IllegalArgumentException(\"Division by zero\")\n  else\n    a / b\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Server with ZIO NIO\nDESCRIPTION: An example demonstrating a simple server implementation using ZIO NIO. It creates an asynchronous server socket that handles multiple concurrent connections, reads client data as UTF-8, and logs the received requests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console._\nimport zio.nio.channels._\nimport zio.nio.core._\nimport zio.stream._\n\nobject ZIONIOServerExample extends zio.App {\n  val myApp =\n    AsynchronousServerSocketChannel()\n      .use(socket =>\n        for {\n          addr <- InetSocketAddress.hostName(\"localhost\", 8080)\n          _ <- socket.bindTo(addr)\n          _ <- putStrLn(s\"Waiting for incoming connections on $addr endpoint\").orDie\n          _ <- ZStream\n            .repeatEffect(socket.accept.preallocate)\n            .map(_.withEarlyRelease)\n            .mapMPar(16) {\n              _.use { case (closeConn, channel) =>\n                for {\n                  _ <- putStrLn(\"Received connection\").orDie\n                  data <- ZStream\n                    .repeatEffectOption(\n                      channel.readChunk(64).eofCheck.orElseFail(None)\n                    )\n                    .flattenChunks\n                    .transduce(ZTransducer.utf8Decode)\n                    .run(Sink.foldLeft(\"\")(_ + _))\n                  _ <- closeConn\n                  _ <- putStrLn(s\"Request Received:\\n${data.mkString}\").orDie\n                } yield ()\n              }\n            }.runDrain\n        } yield ()\n      ).orDie\n   \n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Interface in Scala\nDESCRIPTION: Demonstrates how to create a concrete implementation of a service interface using a Scala class.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass FooServiceImpl extends FooService {\n    \n}\n```\n\n----------------------------------------\n\nTITLE: Lifting Option to ZIO with Failure on None using ZIO.getOrFail Variants in Scala\nDESCRIPTION: Demonstrates using `ZIO.getOrFail`, `ZIO.getOrFailUnit`, and `ZIO.getOrFailWith` to convert an `Option` to a ZIO effect. If the `Option` (derived from `parseInt`) is `Some(a)`, the effect succeeds with `a`. If it's `None`, the effect fails with a `Throwable`, `Unit`, or a custom specified error (`NumberFormatException`), respectively.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef parseInt(input: String): Option[Int] = input.toIntOption\n\n// If the optional value is not defined it fails with Throwable error type:\nval r1: ZIO[Any, Throwable, Int] =\n  ZIO.getOrFail(parseInt(\"1.2\"))\n\n// If the optional value is not defined it fails with Unit error type:\nval r2: ZIO[Any, Unit, Int] =\n  ZIO.getOrFailUnit(parseInt(\"1.2\"))\n\n// If the optional value is not defined it fail with given error type:\nval r3: ZIO[Any, NumberFormatException, Int] =\n  ZIO.getOrFailWith(new NumberFormatException(\"invalid input\"))(parseInt(\"1.2\"))\n```\n\n----------------------------------------\n\nTITLE: Defining catchNonFatalOrDie for ZIO - Scala\nDESCRIPTION: Introduces catchNonFatalOrDie, which handles all non-fatal errors via a handler and dies on fatal ones. The signature requires implicit evidence that the effect can fail and that E is a subtype of Throwable. This is used for broad exception recovery, except for truly fatal errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def catchNonFatalOrDie[R1 <: R, E2, A1 >: A](\n    h: E => ZIO[R1, E2, A1]\n  )(implicit ev1: CanFail[E], ev2: E <:< Throwable): ZIO[R1, E2, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Effects from Values in Scala\nDESCRIPTION: Demonstrates how to create ZIO effects using ZIO.succeed for success values and ZIO.fail for failure values. It shows examples with both primitive and exception types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/creating-effects.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZIO.succeed(42)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval f1 = ZIO.fail(\"Uh oh!\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval f2 = ZIO.fail(new Exception(\"Uh oh!\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Service Interfaces in ZIO\nDESCRIPTION: Defines interfaces for three services A, B, and C which establish the contracts for how the services work together. Each interface contains a single method that returns a ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait A {\n  def foo: ZIO[Any, Nothing, Int]\n}\n\ntrait B {\n  def bar: ZIO[Any, Nothing, String]\n}\n\ntrait C {\n  def baz: ZIO[Any, Nothing, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Console for Input\nDESCRIPTION: This snippet demonstrates how to use ZIO's Console module to read input from the console. It shows a simple echo program that reads a line of input and then prints it back to the console.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval echo = Console.readLine.flatMap(line => Console.printLine(line))\n```\n\n----------------------------------------\n\nTITLE: Creating a Kafka Producer with ZIO\nDESCRIPTION: Scala code to create a Kafka Producer using ZIO and zio-kafka.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.kafka._\nimport zio.kafka.producer._\n\nval producer: ZIO[Scope, Throwable, Producer] =\n  Producer.make(\n    ProducerSettings(List(\"localhost:9092\"))\n  )\n```\n\n----------------------------------------\n\nTITLE: Basic Scoped Resource Creation\nDESCRIPTION: Example of creating a scoped resource using ZIO's Scope pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval scoped = ZIO.acquireRelease(acquire)(release)\n```\n\n----------------------------------------\n\nTITLE: Defining Logging Service with Simple and DateTime Implementations in ZIO Scala\nDESCRIPTION: Defines a `Logging` service trait in Scala using ZIO, along with two concrete implementations: `SimpleLogger` and `DateTimeLogger`. Each implementation provides a `live` ZLayer for dependency injection. `DateTimeLogger` uses `zio.Clock` and `zio.Console`, while `SimpleLogger` uses only `zio.Console`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\ntrait Logging {\n  def log(msg: String): ZIO[Any, IOException, Unit]\n}\n\nobject Logging {\n  def log(msg: String): ZIO[Logging, IOException, Unit] =\n    ZIO.serviceWithZIO[Logging](_.log(msg))\n}\n\ncase class DateTimeLogger() extends Logging {\n  override def log(msg: String): ZIO[Any, IOException, Unit] =\n    for {\n      dt <- Clock.currentDateTime\n      _  <- Console.printLine(s\"$dt: $msg\")\n    } yield ()\n}\n\nobject DateTimeLogger {\n  val live: ULayer[DateTimeLogger] =\n    ZLayer.succeed(DateTimeLogger())\n}\n\ncase class SimpleLogger() extends Logging {\n  override def log(msg: String): ZIO[Any, IOException, Unit] =\n    Console.printLine(msg)\n}\nobjet SimpleLogger {\n  val live: ULayer[SimpleLogger] =\n    ZLayer.succeed(SimpleLogger())\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Input Parsing and Validation with Typed Errors - ZIO/Scala\nDESCRIPTION: A refined ZIO application combining previous strategies: user input is parsed with ZIO.attempt and refined to NumberFormatException, input prompts are retried on parse failure, denominator input is validated to avoid zero, and IO errors are properly channeled. Dependencies include zio, java.io, and Console. Inputs are string user entries, outputs are validated Ints and computed division, or user retry prompts for invalid input.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/examples.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\nimport java.io.IOException\\n\\nobject MainApp extends ZIOAppDefault {\\n  def run =\\n    for {\\n      a <- readNumber(\"Enter the first number  (a): \")\\n      b <- readNumber(\"Enter the second number (b): \").repeatUntil(_ != 0)\\n      r <- divide(a, b)\\n      _ <- Console.printLine(s\"a / b: $r\")\\n    } yield ()\\n\\n  def parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\\n    ZIO.attempt(input.toInt).refineToOrDie[NumberFormatException]\\n\\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\\n    (Console.print(msg) *> Console.readLine.flatMap(parseInput))\\n      .retryUntil(!_.isInstanceOf[NumberFormatException])\\n      .refineToOrDie[IOException]\\n\\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] = ZIO.succeed(a / b)\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a ZIO Effect with Typed Errors and Potential Defects in Scala\nDESCRIPTION: This Scala function `validateNonNegativeNumber` attempts to parse a string input into a non-negative integer within a ZIO effect. It returns `ZIO.succeed` for valid non-negative numbers, `ZIO.fail` with a `String` error for negative numbers, and `ZIO.die` with a `NumberFormatException` for invalid number formats. This illustrates that an effect typed to fail with `String` can still die due to an unhandled exception (defect). Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/typed-errors-guarantees.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef validateNonNegativeNumber(input: String): ZIO[Any, String, Int] =\n  input.toIntOption match {\n    case Some(value) if value >= 0 =>\n      ZIO.succeed(value)\n    case Some(other) =>\n      ZIO.fail(s\"the entered number is negative: $other\")\n    case None =>\n      ZIO.die(\n        new NumberFormatException(\n          s\"the entered input is not in the correct number format: $input\"\n        )\n      )\n  }\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.logAnnotate for Correlation IDs (Scala)\nDESCRIPTION: This code defines a ZIOAppDefault that demonstrates annotating log statements with correlation IDs for contextual logging across parallel operations. The code for each user creates distinct correlation_id annotations used in log messages. Required dependencies: zio, Console, Random. Inputs: a chunk of user identifiers. Outputs: log messages annotated with correlation_id. Typical for microservices or tracing use-cases.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\nobject MainApp extends ZIOAppDefault {\\n  def randomDelay = Random.nextIntBounded(1000).flatMap(t => ZIO.sleep(t.millis))\\n\\n  def run =\\n    ZIO.foreachParDiscard(Chunk(\\\"UserA\\\", \\\"UserB\\\", \\\"UserC\\\")) { user =>\\n      ZIO.logAnnotate(\\\"correlation_id\\\", user) {\\n        for {\\n          _ <- ZIO.log(\\\"fetching user from database\\\") *> randomDelay\\n          _ <- ZIO.log(\\\"downloading user's profile picture\\\") *> randomDelay\\n        } yield ()\\n      }\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Basic ZManaged Creation with make Constructor\nDESCRIPTION: Shows the basic pattern for creating a ZManaged resource using the make constructor which requires acquire and release actions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval managed = ZManaged.make(acquire)(release)\n```\n\n----------------------------------------\n\nTITLE: Implementing Streaming with ZIO\nDESCRIPTION: Demonstrates how to use ZIO Streams for data processing. It creates a stream of numbers, applies factorial transformation, serializes the results, and writes them to a file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nobject ZIOStreamApp extends ZIOAppDefault {\n  val source    = ZStream.fromIterable(1 to 100)\n  val factorial = ZPipeline.scan(BigInt(1))((acc, next: Int) => acc * next)\n  val serialize = ZPipeline.map((num: BigInt) => Chunk.fromArray(s\"$num\".getBytes))\n  val sink      = ZSink.fromFileName(\"factorials.txt\")\n\n  def run = \n    source\n      .via(factorial)\n      .via(serialize).flattenChunks\n      .run(sink)\n}\n```\n\n----------------------------------------\n\nTITLE: Using For Comprehensions for Sequential ZIO Effects in Scala\nDESCRIPTION: Demonstrates building sequential ZIO effects using Scala's for comprehension syntax, which is syntactic sugar for `flatMap` and `map`. The example sequences three effects: printing a prompt (`putStrLn`), reading user input (`getStrLn`), and printing a greeting (`putStrLn`). The final `yield ()` indicates the successful result type is `Unit`. Assumes `putStrLn` and `getStrLn` are defined ZIO effects for console I/O. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_operations.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval program = \n  for {\n    _    <- putStrLn(\"Hello! What is your name?\")\n    name <- getStrLn\n    _    <- putStrLn(s\"Hello, ${name}, welcome to ZIO!\")\n  } yield ()\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZIO gRPC Client\nDESCRIPTION: Implementation of a gRPC client using ZIO gRPC. Creates a client for the Greeter service, connects to the server, sends a request, and handles the response using ZIO's functional effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-grpc.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport io.grpc.ManagedChannelBuilder\nimport io.grpc.examples.helloworld.helloworld.HelloRequest\nimport io.grpc.examples.helloworld.helloworld.ZioHelloworld.GreeterClient\nimport scalapb.zio_grpc.ZManagedChannel\nimport zio.console._\nimport zio.{ExitCode, URIO}\n\nobject HelloWorldClient extends zio.App {\n  def myApp =\n    for {\n      r <- GreeterClient.sayHello(HelloRequest(\"World\"))\n      _ <- putStrLn(r.message)\n    } yield ()\n\n  val clientLayer =\n    GreeterClient.live(\n      ZManagedChannel(\n        ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext()\n      )\n    )\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideCustom(clientLayer).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Task Type Alias in ZIO - Scala\nDESCRIPTION: This snippet defines the Task type alias, mapping Task[A] to ZIO[Any, Throwable, A], establishing Task as a ZIO effect with no requirements and Throwable failures. It does not introduce new functionality but simplifies type signatures, making APIs more expressive and compatible with common effect patterns in Scala. Inputs and outputs correspond directly to the ZIO effect parameters, and there are no runtime constraints introduced by this alias.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/task.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ntype Task[+A] = ZIO[Any, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Application with ZIOAppDefault\nDESCRIPTION: This snippet shows how to create a main application using ZIO by extending ZIOAppDefault. It demonstrates a simple console interaction using ZIO's Console module for input and output operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Console._\n\nobject MyApp extends ZIOAppDefault {\n\n  def run = myAppLogic\n\n  val myAppLogic =\n    for {\n      _    <- printLine(\"Hello! What is your name?\")\n      name <- readLine\n      _    <- printLine(s\"Hello, ${name}, welcome to ZIO!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Try to ZIO Task using ZIO.fromTry in Scala\nDESCRIPTION: Demonstrates using `ZIO.fromTry` to convert a `scala.util.Try[A]` into a `ZIO[Any, Throwable, A]` (which is type-aliased as `Task[A]`). A `Success(a)` becomes a successful effect yielding `a`, and a `Failure(t)` becomes a failing effect with error `t` (a `Throwable`). The example specifically converts a `Try` resulting from division by zero.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.util.Try\n\nval ztry = ZIO.fromTry(Try(42 / 0))\n```\n\n----------------------------------------\n\nTITLE: Refining Exception Types in ZIO Effects\nDESCRIPTION: Shows how to narrow the error type from Throwable to a specific exception type using refineToOrDie. This helps create more precise error types that better reflect possible failure modes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.IOException\n\nval printLine2: IO[IOException, String] =\n  ZIO.attempt(scala.io.StdIn.readLine()).refineToOrDie[IOException]\n```\n\n----------------------------------------\n\nTITLE: Auto-generating Accessor Methods with @accessible Macro\nDESCRIPTION: Example showing how to use the @accessible macro to automatically generate service member accessors for a service trait.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceA {\n  def method(input: Something): UIO[Unit]\n}\n\n// below will be autogenerated\nobject ServiceA {\n  def method(input: Something) =\n    ZIO.serviceWithZIO[ServiceA](_.method(input))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Editor Class with Constructor-based Dependency Injection in Scala\nDESCRIPTION: This snippet demonstrates the Editor class using constructor-based dependency injection, where Formatter and Compiler services are injected through the constructor.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nclass Editor(formatter: Formatter, compiler: Compiler) {\n def formatAndCompile(code: String): UIO[String] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Complete KeyValueStore Example with Accessor Methods\nDESCRIPTION: A complete working example of a KeyValueStore service with accessor methods, including implementation and usage in a ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros.accessible\n\n@accessible\ntrait KeyValueStore {\n  def set(key: String, value: Int): Task[Int]\n\n  def get(key: String): Task[Int]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set(\"key\", 5)\n      key <- KeyValueStore.get(\"key\")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n```\n\n----------------------------------------\n\nTITLE: Awaiting a Promise Result in ZIO (Scala)\nDESCRIPTION: This snippet illustrates waiting for the completion of a ZIO Promise using await. The Promise is created with Exception error type and String success type, and awaiting will suspend the fiber until the Promise is set. It showcases effect-chaining using flatMap. Inputs/outputs are the same types as the Promise; fibers resume once the value or error is available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/promise.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval ioPromise3: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\\nval ioGet: IO[Exception, String] = ioPromise3.flatMap(promise => promise.await)\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Either, Try, and Future to ZIO Effects\nDESCRIPTION: Demonstrates how to convert Scala Either, Try, and Future to ZIO effects using ZIO.fromEither, ZIO.fromTry, and ZIO.fromFuture respectively. It explains the resulting error types for each conversion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/creating-effects.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval zeither: ZIO[Any, Nothing, String] = ZIO.fromEither(Right(\"Success!\"))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval ztry = ZIO.fromTry(Try(42 / 0))\n```\n\nLANGUAGE: scala\nCODE:\n```\nlazy val future = Future.successful(\"Hello!\")\n\nval zfuture: ZIO[Any, Throwable, String] =\n  ZIO.fromFuture { implicit ec =>\n    future.map(_ => \"Goodbye!\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Effectful Fallback Using foldZIO - Scala\nDESCRIPTION: Illustrates using foldZIO to provide an effectful fallback in case of failure. Attempts to read the primary file, and on failure attempts to read a secondary file. On success, the result is simply wrapped with succeed. Demonstrates composition of ZIO effects and error recovery strategies. Requires readFile defined elsewhere.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval primaryOrSecondaryData: IO[IOException, Array[Byte]] =\n  readFile(\"primary.data\").foldZIO(\n    failure = _    => readFile(\"secondary.data\"),\n    success = data => ZIO.succeed(data)\n  )\n```\n\n----------------------------------------\n\nTITLE: Providing Custom TestConsole to ZIO Test Program in Scala\nDESCRIPTION: This example shows how to provide a custom TestConsole implementation to a ZIO Test program using the 'make' method, allowing for specific testing of console-related functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nmyProgram.provideCustom(TestConsole.make(TestConsole.Data()))\n```\n\n----------------------------------------\n\nTITLE: Asserting ZIO Effects with `assertZIO` in ZIO Test (Scala)\nDESCRIPTION: This snippet illustrates how to use the `assertZIO` function to test the result of a ZIO effect. It defines a ZIO effect (`value`) that creates a `Ref`, updates it, and gets the final value using a for-comprehension. `assertZIO` then unwraps the effect and checks if the resulting value is equal to `1`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"updating ref\") {\n  val value = for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield v\n  assertZIO(value)(Assertion.equalTo(1))\n}\n```\n\n----------------------------------------\n\nTITLE: Building a ZIO Producer-Consumer with RabbitMQ\nDESCRIPTION: Complete example of a ZIO application that connects to RabbitMQ, creates a producer that publishes messages to an exchange, and a consumer that reads from a queue. The example demonstrates channel management, message publishing, and consumption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nimport nl.vroste.zio.amqp._\nimport zio._\nimport zio.blocking._\nimport zio.clock.Clock\nimport zio.console._\nimport zio.duration.durationInt\nimport zio.random.Random\n\nimport java.net.URI\n\nobject ZIOAMQPExample extends zio.App {\n\n  val channelM: ZManaged[Blocking, Throwable, Channel] = for {\n    connection <- Amqp.connect(URI.create(\"amqp://localhost:5672\"))\n    channel <- Amqp.createChannel(connection)\n  } yield channel\n\n  val myApp: ZIO[Blocking with Console with Clock with Random, Throwable, Unit] =\n    channelM.use { channel =>\n      val producer: ZIO[Blocking with Random with Clock, Throwable, Long] =\n        zio.random.nextUUID\n          .flatMap(uuid =>\n            channel.publish(\"my_exchange\", uuid.toString.getBytes)\n              .map(_ => ())\n          ).schedule(Schedule.spaced(1.seconds))\n\n      val consumer: ZIO[Blocking with Console, Throwable, Unit] = channel\n        .consume(queue = \"my_queue\", consumerTag = \"my_consumer\")\n        .mapM { record =>\n          val deliveryTag = record.getEnvelope.getDeliveryTag\n          putStrLn(s\"Received $deliveryTag: ${new String(record.getBody)}\") *>\n            channel.ack(deliveryTag)\n        }\n        .runDrain\n\n      for {\n        p <- producer.fork\n        c <- consumer.fork\n        _ <- p.zip(c).join\n      } yield ()\n    }\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Fork and Join Operations in ZIO Fibers\nDESCRIPTION: This example shows how to use fork and join operations with ZIO fibers. It creates a separate fiber to execute a delayed task, and then waits for that fiber to complete using join to retrieve its result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Console._\nfor {\n  fiber <- (ZIO.sleep(3.seconds) *>\n    printLine(\"Hello, after 3 second\") *>\n    ZIO.succeed(10)).fork\n  _ <- printLine(s\"Hello, World!\")\n  res <- fiber.join\n  _ <- printLine(s\"Our fiber succeeded with $res\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Parallel Execution with zipPar in ZIO\nDESCRIPTION: This example shows how to use zipPar to execute two computations in parallel. The zipPar combinator has resource-safe semantics, meaning if one computation fails, the other will be interrupted to prevent wasting resources.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef bigCompute(m1: Matrix, m2: Matrix, v: Matrix): UIO[Matrix] =\n  for {\n    t <- computeInverse(m1).zipPar(computeInverse(m2))\n    (i1, i2) = t\n    r <- applyMatrices(i1, i2, v)\n  } yield r\n```\n\n----------------------------------------\n\nTITLE: Handling All Failure Causes with foldCauseZIO - Scala\nDESCRIPTION: Provides an example of using foldCauseZIO to match on different causes of failure, such as Fail, Die, and Interrupt, and respond appropriately. Also handles the success case. Relies on zio.Console for output. It demonstrates exhaustive (non-total) recovery from all possible error causes, and is instructive for advanced error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval exceptionalEffect: ZIO[Any, Throwable, Unit] = ???\n\nval myApp: ZIO[Any, IOException, Unit] =\n  exceptionalEffect.foldCauseZIO(\n    failure = {\n      case Cause.Fail(value, _)        => Console.printLine(s\"failure: $value\")\n      case Cause.Die(value, _)         => Console.printLine(s\"cause: $value\")\n      case Cause.Interrupt(failure, _) => Console.printLine(s\"${failure.threadName} interrupted!\")\n      case _                           => Console.printLine(\"failed due to other causes\")\n    },\n    success = succeed => Console.printLine(s\"succeeded with $succeed value\")\n  )\n```\n\n----------------------------------------\n\nTITLE: Consuming Kinesis Streams with ZIO\nDESCRIPTION: A complete example of consuming data from an Amazon Kinesis stream using ZIO Kinesis. The example sets up a consumer with configuration for stream name, application name, serialization, and checkpointing behavior.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-kinesis.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport nl.vroste.zio.kinesis.client.serde.Serde\nimport nl.vroste.zio.kinesis.client.zionative.Consumer\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.duration._\nimport zio.logging.Logging\nimport zio.{ExitCode, URIO, _}\n\nobject ZIOKinesisConsumerExample extends zio.App {\n  val loggingLayer: ZLayer[Any, Nothing, Logging] =\n    (Console.live ++ Clock.live) >>>\n      Logging.console() >>>\n      Logging.withRootLoggerName(getClass.getName)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    Consumer\n      .consumeWith(\n        streamName = \"my-stream\",\n        applicationName = \"my-application\",\n        deserializer = Serde.asciiString,\n        workerIdentifier = \"worker1\",\n        checkpointBatchSize = 1000L,\n        checkpointDuration = 5.minutes\n      )(record => putStrLn(s\"Processing record $record\"))\n      .provideCustom(Consumer.defaultEnvironment ++ loggingLayer)\n      .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Primitive Configs in Scala using ZIO\nDESCRIPTION: This snippet demonstrates how to read primitive configuration values (string and int) using ZIO's config system. It uses ZIO.config to load configuration data from environment variables or system properties.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/configuration/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = {\n    for {\n      host <- ZIO.config(Config.string(\"host\"))\n      port <- ZIO.config(Config.int(\"port\"))\n      _    <- Console.printLine(s\"Application started: $host:$port\")\n    } yield ()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending an HTTP Request with a Correlation ID Header in Bash\nDESCRIPTION: Shows how to send an HTTP POST request with a custom X-Correlation-ID header using curl.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -i -H \"X-Correlation-ID: f798d2f2-abf2-46ff-b3f4-ae1888256706\" \\\n      http://localhost:8080/users -d '{\"name\": \"John\", \"age\": 42}'\n```\n\n----------------------------------------\n\nTITLE: Interactive ZIO Hello World Application with User Input\nDESCRIPTION: An enhanced ZIO application that prompts the user for their name and prints a personalized greeting. It demonstrates composing multiple ZIO effects using for-comprehension.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/hello-world.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      _    <- Console.print(\"Please enter your name: \")\n      name <- Console.readLine\n      _    <- Console.printLine(s\"Hello, $name!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: ZIO Logging with Cause\nDESCRIPTION: Shows how to log errors with their cause information using ZIO's logCause functionality\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    ZIO\n      .dieMessage(\"Boom!\")\n      .foldCauseZIO(\n        cause => ZIO.logErrorCause(\"application stopped working due to an unexpected error\", cause),\n        _ => ZIO.unit\n      )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Service Classes in Scala\nDESCRIPTION: Defines two simple service classes A and B with methods that return ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfinal class A {\n  def foo: UIO[String] = ZIO.succeed(\"Hello!\")\n}\n\nfinal class B {\n  def bar: UIO[Int] = ZIO.succeed(42)\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Dependencies to ZIO Environment\nDESCRIPTION: Shows how to provide dependencies to the ZIO environment using provideLayer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval result: ZIO[Any, Nothing, (String, Int)] = myApp.provideLayer(appLayer)\n```\n\n----------------------------------------\n\nTITLE: Implementing a GraphQL API with Caliban and ZIO\nDESCRIPTION: Complete example showing how to implement a GraphQL API with Caliban and ZIO. This example defines data models, queries, and starts a GraphQL server with both API and GraphiQL endpoints.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/caliban.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport caliban._\nimport caliban.quick._\nimport caliban.schema.{Schema, ArgBuilder}\nimport caliban.schema.Annotations.GQLDescription\n\nsealed trait Role\n\nobject Role {\n  case object SoftwareDeveloper       extends Role\n  case object SiteReliabilityEngineer extends Role\n  case object DevOps                  extends Role\n}\n\ncase class Employee(\n    name: String,\n    role: Role\n)\n\ncase class EmployeesArgs(role: Role)\ncase class EmployeeArgs(name: String)\n\ncase class Queries(\n    @GQLDescription(\"Return all employees with specific role\")\n    employees: EmployeesArgs => List[Employee],\n    @GQLDescription(\"Find an employee by its name\")\n    employee: EmployeeArgs => Option[Employee]\n)\n\nobject CalibanExample extends zio.ZIOAppDefault {\n  import ArgBuilder.auto._\n  import Schema.auto._\n\n  val employees = List(\n    Employee(\"Alex\", Role.DevOps),\n    Employee(\"Maria\", Role.SoftwareDeveloper),\n    Employee(\"James\", Role.SiteReliabilityEngineer),\n    Employee(\"Peter\", Role.SoftwareDeveloper),\n    Employee(\"Julia\", Role.SiteReliabilityEngineer),\n    Employee(\"Roberta\", Role.DevOps)\n  )\n\n  override def run =\n    graphQL(\n      RootResolver(\n        Queries(\n          args => employees.filter(e => args.role == e.role),\n          args => employees.find(e => e.name == args.name)\n        )\n      )\n    ).runServer(\n      port = 8088,\n      apiPath = \"/api/graphql\",\n      graphiqlPath = Some(\"/api/graphiql\"),\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Service Dependencies in Scala\nDESCRIPTION: Shows how to define service dependencies using constructor injection pattern with multiple service interfaces.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait ServiceA {\n\n}\n\ntrait ServiceB {\n\n}\n\nclass FooServiceImpl(a: ServiceA, b: ServiceB) extends FooService {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Dependency Graph Construction with ZLayers in Scala\nDESCRIPTION: Demonstrates the construction of a complex dependency graph using ZLayers. This example shows how to build a 'Cake' by composing multiple layers and passing through all requirements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Baker \ntrait Ingredients\ntrait Oven\ntrait Dough\ntrait Cake\n\nlazy val baker      : ZLayer[Any, Nothing, Baker] = ???\nlazy val ingredients: ZLayer[Any, Nothing, Ingredients] = ???\nlazy val oven       : ZLayer[Any, Nothing, Oven] = ???\nlazy val dough      : ZLayer[Baker & Ingredients, Nothing, Dough] = ???\nlazy val cake       : ZLayer[Baker & Oven & Dough, Nothing, Cake] = ???\n\nlazy val all: ZLayer[Any, Nothing, Baker & Ingredients & Oven & Dough & Cake] =\n  baker >+>       // Baker\n  ingredients >+> // Baker & Ingredients\n  oven >+>        // Baker & Ingredients & Oven\n  dough >+>       // Baker & Ingredients & Oven & Dough\n  cake            // Baker & Ingredients & Oven & Dough & Cake\n```\n\n----------------------------------------\n\nTITLE: Implementing Query Batching with ZIO Query in Scala\nDESCRIPTION: Example of optimizing multiple database queries by batching them together using ZIO Query. It demonstrates defining a request type, implementing a batched data source, and composing queries with ZQuery.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console.putStrLn\nimport zio.query.{CompletedRequestMap, DataSource, Request, ZQuery}\nimport zio.{Chunk, ExitCode, Task, URIO, ZIO}\n\nimport scala.collection.immutable.AbstractSeq\n\nobject ZQueryExample extends zio.App {\n  case class GetUserName(id: Int) extends Request[Nothing, String]\n\n  lazy val UserDataSource: DataSource.Batched[Any, GetUserName] =\n    new DataSource.Batched[Any, GetUserName] {\n      val identifier: String = \"UserDataSource\"\n\n      def run(requests: Chunk[GetUserName]): ZIO[Any, Nothing, CompletedRequestMap] = {\n        val resultMap = CompletedRequestMap.empty\n        requests.toList match {\n          case request :: Nil =>\n            val result: Task[String] = {\n              // get user by ID e.g. SELECT name FROM users WHERE id = $id\n              ZIO.succeed(???)\n            }\n\n            result.either.map(resultMap.insert(request))\n\n          case batch: Seq[GetUserName] =>\n            val result: Task[List[(Int, String)]] = {\n              // get multiple users at once e.g. SELECT id, name FROM users WHERE id IN ($ids)\n              ZIO.succeed(???)\n            }\n\n            result.fold(\n              err =>\n                requests.foldLeft(resultMap) { case (map, req) =>\n                  map.insert(req)(Left(err))\n                },\n              _.foldLeft(resultMap) { case (map, (id, name)) =>\n                map.insert(GetUserName(id))(Right(name))\n              }\n            )\n        }\n      }\n    }\n\n  def getUserNameById(id: Int): ZQuery[Any, Nothing, String] =\n    ZQuery.fromRequest(GetUserName(id))(UserDataSource)\n\n  val query: ZQuery[Any, Nothing, List[String]] =\n    for {\n      ids <- ZQuery.succeed(1 to 10)\n      names <- ZQuery.foreachPar(ids)(id => getUserNameById(id)).map(_.toList)\n    } yield (names)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    query.run\n      .tap(usernames => putStrLn(s\"Usernames: $usernames\"))\n      .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Using tapError for Interactive Error Debugging with ZIO - Scala\nDESCRIPTION: This example demonstrates building an interactive console application using ZIO that reads a line, attempts to parse it as Int, and leverages tapError to debug invalid number input errors. It imports ZIO core modules, refines errors to NumberFormatException, and applies ZIO.debug only for number format errors using tapError. Expected input is a string, and outputs are debug traces on bad input, showing practical application of error tapping. Requires ZIO libraries, ZIOAppDefault, and Console; ensures errors of type NumberFormatException are handled with additional debugging output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/tapping-errors.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, NumberFormatException, Int] =\n    Console.readLine\n      .mapAttempt(_.toInt)\n      .refineToOrDie[NumberFormatException]\n      .tapError { e =>\n        ZIO.debug(s\"user entered an invalid input: ${e}\").when(e.isInstanceOf[NumberFormatException])\n      }\n\n  def run = myApp\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Greeting HTTP Routes with ZIO HTTP (Scala)\nDESCRIPTION: Implements a set of HTTP routes handling greeting requests with various path and query parameters using zio-http in Scala. The routes include: responding to GET /greet?name= queries by extracting 'name' from query parameters, a simple /greet route returning 'Hello World!', and a /greet/:name route extracting the name from the URL path. Dependencies: zio, zio-http; expects requests to '/greet' with or without query/path params; returns plain text responses and validates required parameters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\\nimport zio.http._\\n\\nobject GreetingRoutes {\\n  def apply(): Routes[Any, Response] =\\n    Routes(\\n      // GET /greet?name=:name\\n      Method.GET / \"greet\" -> handler { (req: Request) =>\\n        if (req.url.queryParams.nonEmpty)\\n          ZIO.succeed(\\n            Response.text(\\n              s\"Hello ${req.url.queryParams(\"name\").map(_.mkString(\" and \"))}!\"\\n            )\\n          )\\n        else\\n          ZIO.fail(Response.badRequest(\"The name query parameter is missing!\"))\\n      },\\n\\n      // GET /greet\\n      Method.GET / \"greet\" -> handler(Response.text(s\"Hello World!\")),\\n\\n      // GET /greet/:name\\n      Method.GET / \"greet\" / string(\"name\") -> handler {\\n        (name: String, _: Request) =>\\n          Response.text(s\"Hello $name!\")\\n      }\\n    )\\n\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a ZIO HTTP App for Counter Commands (Scala)\nDESCRIPTION: This Scala snippet implements an HTTP routing app using zio-http to accept increment and decrement commands for counter entities. It matches on GET routes, parses command parameters, builds a CommandMessage including timestamp and address, and invokes the domain backend. Responses are returned as text. Dependencies include zio, zio-http, edomata, and the previously defined BackendService. Expects valid Inc/Dec command strings, returns backend evaluation as HTTP response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.*\nimport zio.http.*\nimport edomata.core.CommandMessage\nimport BackendService.Service\nimport java.time.Instant\n\nobject ZIOCounterHttpApp {\n\n  def apply(service: Service) =\n    Routes(\n      // command: inc or dec\n      // GET /{edomaton address}/{command}/{command id}\n      Method.GET / string(\"address\") / string(\"command\") / string(\"commandId\") ->\n        handler { (address: String, command: String, commandId: String, _: Request) =>\n          val cmd = command match {\n            case \"inc\" => Command.Inc\n            case \"dec\" => Command.Dec\n          }\n\n          service(CommandMessage(commandId, Instant.now, address, cmd))\n            .map(r => Response.text(r.toString))\n            .orDie\n        })\n}\n```\n\n----------------------------------------\n\nTITLE: Using For Comprehensions with ZIO Effects in Scala\nDESCRIPTION: Illustrates how to use Scala's for comprehensions to create chains of ZIO effects in a more imperative style.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-operations.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval program: ZIO[Any, IOException, Unit] =\n  for {\n    _    <- Console.printLine(\"Hello! What is your name?\")\n    name <- Console.readLine\n    _    <- Console.printLine(s\"Hello, ${name}, welcome to ZIO!\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating Suspended ZIO Effects\nDESCRIPTION: Shows how to create a suspended ZIO effect using ZIO.suspend. This defers the creation of the effect until it's needed, which can be useful for recursive effects or to avoid allocating resources too early.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.IOException\n\nval suspendedEffect: RIO[Any, ZIO[Any, IOException, Unit]] =\n  ZIO.suspend(ZIO.attempt(Console.printLine(\"Suspended Hello World!\")))\n```\n\n----------------------------------------\n\nTITLE: Providing Layers to ZIO Application with Automatic Construction\nDESCRIPTION: This snippet shows how to provide individual layers to a ZIO application, allowing the compiler to automatically construct the dependency graph. It demonstrates error messages for missing dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/automatic-layer-construction.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp.provide(\n      Cake.live,\n      Chocolate.live,\n      Flour.live,\n      Spoon.live  \n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Expected Error with ZIO.fail - Safe Division Function - Scala\nDESCRIPTION: Implements a safe integer division function that uses ZIO.fail to handle division by zero as an expected, typed error. If b is zero, the effect fails with ArithmeticException, otherwise it succeeds with the result of division. Requires zio._, provides clear error signaling for anticipated error cases. Inputs: two integers; Output: ZIO effect that may fail with ArithmeticException.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, ArithmeticException, Int] =\n  if (b == 0)\n    ZIO.fail(new ArithmeticException(\"divide by zero\"))\n  else\n    ZIO.succeed(a / b)\n```\n\n----------------------------------------\n\nTITLE: Complete JSON Streaming Example with ZIO Kafka and ZIO Streams in Scala\nDESCRIPTION: A complete application demonstrating producing and consuming JSON data with zio-kafka, zio-streams, and zio-json. Includes both producer and consumer implementations in a streaming fashion with proper error handling and offset committing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport org.apache.kafka.clients.producer.ProducerRecord\nimport zio._\nimport zio.json._\nimport zio.kafka.consumer._\nimport zio.kafka.producer.{Producer, ProducerSettings}\nimport zio.kafka.serde._\nimport zio.stream.ZStream\n\nimport java.time.OffsetDateTime\nimport java.util.UUID\n\n/** This is the data we will be sending to Kafka in JSON format. */\ncase class Event(uuid: UUID, timestamp: OffsetDateTime, message: String)\n\n/** A zio-json encoder/decoder for [[Event]]. */\nobject Event {\n  implicit val encoder: JsonEncoder[Event] =\n    DeriveJsonEncoder.gen[Event]\n\n  implicit val decoder: JsonDecoder[Event] =\n    DeriveJsonDecoder.gen[Event]\n}\n\n/** A zio-kafka serializer/deserializer for [[Event]]. */\nobject EventKafkaSerde {\n  val event: Serde[Any, Event] =\n    Serde.string.inmapZIO[Any, Event](s =>\n      ZIO\n        .fromEither(s.fromJson[Event])\n        .mapError(e => new RuntimeException(e))\n    )(r => ZIO.succeed(r.toJson))\n}\n\nobject JsonStreamingKafkaApp extends ZIOAppDefault {\n  private val BOOSTRAP_SERVERS = List(\"localhost:9092\")\n  private val KAFKA_TOPIC      = \"json-streaming-hello\"\n\n  def run: ZIO[Any, Throwable, Unit] = {\n    val p: ZIO[Any, Throwable, Unit] =\n      ZIO.scoped {\n        for {\n          producer <- Producer.make(ProducerSettings(BOOSTRAP_SERVERS))\n          _ <- ZStream\n            .repeatZIO(Random.nextUUID <*> Clock.currentDateTime)\n            .schedule(Schedule.spaced(1.second))\n            .map { case (uuid, time) =>\n              new ProducerRecord(\n                KAFKA_TOPIC,\n                time.getMinute,\n                Event(uuid, time, \"Hello, World!\")\n              )\n            }\n            .via(producer.produceAll(Serde.int, EventKafkaSerde.event))\n            .runDrain\n        } yield ()\n      }\n\n    val c: ZIO[Any, Throwable, Unit] =\n      ZIO.scoped {\n        for {\n          consumer <- Consumer.make(\n            ConsumerSettings(BOOSTRAP_SERVERS).withGroupId(\"streaming-kafka-app\")\n          )\n          _ <- consumer\n            .plainStream(\n              Subscription.topics(KAFKA_TOPIC),\n              Serde.int,\n              EventKafkaSerde.event\n            )\n            .tap { r =>\n              val event: Event = r.value\n              Console.printLine(\n                s\"Event ${event.uuid} was sent at ${event.timestamp} with message ${event.message}\"\n              )\n            }\n            .map(_.offset)\n            .aggregateAsync(Consumer.offsetBatches)\n            .mapZIO(_.commit)\n            .runDrain\n        } yield ()\n      }\n\n    p <&> c\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ZLayers for Service Implementations\nDESCRIPTION: Defines companion objects for service implementations, each providing a ZLayer that describes how to construct the service. CLive's layer uses ZIO.service to access its dependencies from the environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject ALive {\n  val layer: ZLayer[Any, Nothing, ALive] = ZLayer.succeed(ALive())\n}\n\nobject BLive {\n  val layer: ZLayer[Any, Nothing, BLive] = ZLayer.succeed(BLive())\n}\n\nobject CLive {\n  val layer: ZLayer[B with A, Nothing, CLive] =\n    ZLayer {\n      for {\n        a <- ZIO.service[A]\n        b <- ZIO.service[B]\n      } yield CLive(a, b)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Recovering from Non-Fatal Errors Using catchNonFatalOrDie - Scala\nDESCRIPTION: Demonstrates using catchNonFatalOrDie to recover from all non-fatal exceptions when opening a file, providing a fallback file read if an error occurs. If a fatal error occurs, the effect dies and is not recovered. Key dependencies include the openFile function; parameters are the primary and backup file paths.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nopenFile(\"data.json\").catchNonFatalOrDie(_ => openFile(\"backup.json\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing Graceful Shutdown in ZIO Application\nDESCRIPTION: Demonstrates how to structure a ZIO application with graceful shutdown logic using the ensuring method to specify cleanup operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/gracefully-shutdown-zio-application.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject GracefulShutdownExample extends ZIOAppDefault {\n\n  def appLogic = {\n    // Your application logic goes here\n    ZIO.unit\n  }\n\n  def cleanup = {\n    // Perform cleanup operations here\n    ZIO.unit\n  }\n\n  override def run = appLogic.ensuring(cleanup)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Blocking Operations to ZIO Effects\nDESCRIPTION: Shows how to directly convert blocking code to ZIO effects using attemptBlocking. This ensures the operation runs on the dedicated blocking thread pool to avoid affecting asynchronous operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef blockingTask(n: Int) = ZIO.attemptBlocking {\n  do {\n    println(s\"Running blocking task number $n on dedicated blocking thread pool\")\n    Thread.sleep(3000)\n  } while (true)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Console I/O with ZIO\nDESCRIPTION: Demonstrates how to create a simple interactive console application using ZIO's Console service. The example shows composing console operations using for-comprehension to create a program that asks for a user's name and prints a welcome message. The program handles potential IOExceptions and runs without specific environment requirements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/console.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\n\nimport zio._\nimport zio.Console._\n\nobject MyHelloApp extends ZIOAppDefault {\n  val program: ZIO[Any, IOException, Unit] = for {\n    _    <- printLine(\"Hello, what is you name?\")\n    name <- readLine\n    _    <- printLine(s\"Hello $name, welcome to ZIO!\")\n  } yield ()\n\n  def run = program\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Service Interface Definition Violating First Law\nDESCRIPTION: Shows an incorrect DocRepo interface definition that violates the first law of ZIO Environment by exposing implementation dependencies (BlobStorage and MetadataRepo) in the service interface.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait DocRepo {\n  def save(document: Doc): ZIO[BlobStorage & MetadataRepo, Throwable, String]\n}\n```\n\n----------------------------------------\n\nTITLE: Basic ZIO Logging Example\nDESCRIPTION: Demonstrates basic logging functionality in a ZIO application using the default logger\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.log(\"Application started\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Web Service for Counter Entity in Scala\nDESCRIPTION: This code defines a web service using ZIO HTTP to handle incoming requests for the Counter entity. It provides routes for incrementing and decrementing counters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nimport com.devsisters.shardcake.{Messenger, Sharding}\nimport zio.http._\nimport zio.Scope\n\nobject WebService {\n  def apply(counter: Messenger[CounterMessage]): Routes[Sharding, Nothing] =\n\n    Routes(\n      Method.GET / string(\"entityId\") / \"inc\" -> handler { (entityId: String, _: Request) =>\n        counter\n          .send(entityId)(CounterMessage.Increase)\n          .map(r => Response.text(r.toString))\n      },\n      Method.GET / string(\"entityId\") / \"dec\" -> handler { (entityId: String, _: Request) =>\n        counter\n          .send(entityId)(CounterMessage.Decrease)\n          .map(r => Response.text(r.toString))\n      }\n    ).sandbox\n}\n```\n\n----------------------------------------\n\nTITLE: Chaining ZIO Effects Sequentially with flatMap in Scala\nDESCRIPTION: Illustrates sequential execution of ZIO effects using `flatMap`. It first executes `getStrLn` to read input, then uses its result within a callback function to create and execute a second effect, `putStrLn`, which prints the entered text. If the first effect (`getStrLn`) fails, the second effect is skipped, and the combined effect fails. Assumes `getStrLn` and `putStrLn` are defined ZIO effects for console I/O. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_operations.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval sequenced = \n  getStrLn.flatMap(input => putStrLn(s\"You entered: $input\"))\n```\n```\n\n----------------------------------------\n\nTITLE: Mapping Over Error Channel in ZIO Scala\nDESCRIPTION: Shows how to use the `ZIO#mapError` method to transform the failure value of a ZIO effect. It takes an `IO.fail(\"No no!\")` effect (which fails with a String) and applies a function (`msg => new Exception(msg)`) to its error value, resulting in a new effect `IO[Exception, Unit]` that fails with an `Exception`. This operation only affects the error type and does not change the effect's outcome from failure to success. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_operations.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval failed: IO[Exception, Unit] = \n  IO.fail(\"No no!\").mapError(msg => new Exception(msg))\n```\n```\n\n----------------------------------------\n\nTITLE: Adding Built-in ZIO HTTP Metrics to Routes\nDESCRIPTION: Scala code showing how to add built-in ZIO HTTP metrics to routes using the @@ syntax and the metrics middleware.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http._\nimport zio.schema.codec.JsonCodec.schemaBasedBinaryCodec\n\n\nobject UserRoutes {\n\n  def apply(): Routes[UserRepo, Response] =\n    Routes(\n      Method.GET / \"users\" -> handler {\n        UserRepo.users.foldZIO(\n          e =>\n            ZIO\n              .logError(s\"Failed to retrieve users. $e\") *>\n              ZIO.fail(Response.internalServerError(\"Cannot retrieve users!\")),\n          users =>\n            ZIO\n              .log(\n                s\"Retrieved users successfully: response length=${users.length}\"\n              )\n              .as(Response(body = Body.from(users)))\n        )\n      }\n    ) @@ Middleware.metrics()\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Handlers in ZIO HTTP\nDESCRIPTION: This code demonstrates various ways to combine Handlers in ZIO HTTP. It shows examples of using flatMap, andThen, and orElse operations to create more complex handlers from simple ones.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\n\nval a           : Handler[Any, Nothing, Int, Double]    = ???\nval b           : Handler[Any, Nothing, Double, String] = ???\ndef c(i: Double): Handler[Any, Nothing, Long, String]   = ???\n\nval d = a >>= c // a flatMap c (combine two handlers sequentially)\nval f = a >>> b // a andThen b (pipe output of the a handler to input of the b handler)\nval h = a <> b  // a orElse b  (run a, if it fails, run b)\n```\n\n----------------------------------------\n\nTITLE: Applying Filtering Operators to ZIO Effects in Scala\nDESCRIPTION: This Scala snippet demonstrates several ZIO operators for filtering the success value of an effect based on a predicate (`_ >= 0`). `filterOrFail` fails the effect with a specified error if the predicate fails. `filterOrDie` and `filterOrDieMessage` cause the fiber to die with an exception or message respectively if the predicate fails. `filterOrElse` executes a predefined alternative effect (`getNumber`), and `filterOrElseWith` executes an alternative effect derived from the original value (`ZIO.succeed(-x)`) if the predicate fails. It depends on the `zio` library, particularly `ZIO`, `Console`, `Random`, and `IllegalArgumentException`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/filtering-the-success-channel.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\ndef getNumber: ZIO[Any, Nothing, Int] =\n  (Console.print(\"Please enter a non-negative number: \") *> // Prompt user\n    Console.readLine.mapAttempt(_.toInt)) // Read line and attempt conversion to Int\n    .retryUntil(!_.isInstanceOf[NumberFormatException]).orDie // Retry on format errors, die on others\n\n// Filter: Fail with a specific error message if the random number is negative\nval r1: ZIO[Any, String, Int] =\n  Random.nextInt.filterOrFail(_ >= 0)(\"random number is negative\")\n\n// Filter: Die with a specific exception if the random number is negative\nval r2: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrDie(_ >= 0)(\n    new IllegalArgumentException(\"random number is negative\")\n  )\n\n// Filter: Die with a specific error message if the random number is negative\nval r3: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrDieMessage(_ >= 0)(\"random number is negative\")\n\n// Filter: Run the 'getNumber' effect if the random number is negative\nval r4: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrElse(_ >= 0)(getNumber)\n\n// Filter: Compute an alternative value (negated number) if the random number is negative\nval r5: ZIO[Any, Nothing, Int] =\n  Random.nextInt.filterOrElseWith(_ >= 0)(x => ZIO.succeed(-x))\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Event Case Class for Kafka JSON Messages in Scala\nDESCRIPTION: Defines an Event case class with UUID, timestamp, and message fields that will be serialized to and deserialized from JSON in Kafka messages.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport java.time.OffsetDateTime\nimport java.util.UUID\n\ncase class Event(\n  uuid: UUID,\n  timestamp: OffsetDateTime,\n  message: String\n)\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Runtime in Scala\nDESCRIPTION: Shows how to access the default Runtime in ZIO and use it to run an effect. This is useful when you need to explicitly use a Runtime instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends scala.App {\n  val myAppLogic = ZIO.succeed(???)\n\n  val runtime = Runtime.default\n\n  Unsafe.unsafe { implicit unsafe =>\n    runtime.unsafe.run(myAppLogic).getOrThrowFiberFailure()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Kafka Messages with Batched Offset Commits using ZIO Streams in Scala\nDESCRIPTION: This Scala example shows a more performant way to consume Kafka messages using `consumer.plainStream` by committing offsets in batches. After consuming and processing records (e.g., printing with `tap`), it extracts the `Offset` for each record, aggregates these offsets into batches using `aggregateAsync(Consumer.offsetBatches)`, and then commits each batch asynchronously via `mapZIO(_.commit)`. This reduces commit overhead.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\nimport zio.kafka._\nimport zio.kafka.consumer._\nimport zio.kafka.serde._\n\nval KAFKA_TOPIC = \"my-topic\"\nval consumer: Consumer = ???\n\nval c: ZIO[Any, Throwable, Unit] =\n  consumer\n    .plainStream(Subscription.topics(KAFKA_TOPIC), Serde.int, Serde.string)\n    .tap(e => Console.printLine(e.value))\n    .map(_.offset)                           // Get the offset of the record\n    .aggregateAsync(Consumer.offsetBatches)  // Group offsets in an OffsetBatch\n    .mapZIO(_.commit)                        // Commit the batch of offsets\n    .runDrain\n```\n\n----------------------------------------\n\nTITLE: Using foldTraceZIO to Handle Failure with Trace Details - Scala\nDESCRIPTION: Employs foldTraceZIO for failure handling, distinguishing negative and illegal ages by their error subtype and printing trace information. For failures, produces debug output with custom messages and stack traces, defaulting to zero value. Success case simply returns the value. The approach highlights advanced diagnostics and enriches error information in effectful workflows. Requires validate to be defined, as well as AgeValidationException and subtypes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  validate(5).foldTraceZIO(\n    failure = {\n      case (_: NegativeAgeException, trace) =>\n        ZIO.succeed(0).debug(\n          \"The entered age is negative\\n\" +\n            s\"trace info: ${trace.stackTrace.mkString(\"\\n\")}\" \n        )\n      case (_: IllegalAgeException, trace) =>\n        ZIO.succeed(0).debug(\n          \"The entered age in not legal\\n\" +\n            s\"trace info: ${trace.stackTrace.mkString(\"\\n\")}\" \n        )\n    },\n    success = s => ZIO.succeed(s)\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Runtime for ZIO Effects in Scala\nDESCRIPTION: This snippet illustrates how to create a custom Runtime with a specific environment. It creates a Runtime that can provide an Int value to effects, which can be useful for dependency injection or configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/running-effects.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval myRuntime: Runtime[Int] = \n  Runtime(ZEnvironment[Int](42), FiberRefs.empty, RuntimeFlags.default)\n```\n\n----------------------------------------\n\nTITLE: Property-Based Testing for Addition Function in Scala\nDESCRIPTION: Implements property-based tests for the addition function using ZIO Test. It tests the commutative, associative, and identity properties of addition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nobject AdditionSpec extends ZIOSpecDefault {\n\n  def add(a: Int, b: Int): Int = ???\n\n  def spec = suite(\"Add Spec\")(\n    test(\"add is commutative\") {\n      check(Gen.int, Gen.int) { (a, b) =>\n        assertTrue(add(a, b) == add(b, a))\n      }\n    },\n    test(\"add is associative\") {\n      check(Gen.int, Gen.int, Gen.int) { (a, b, c) =>\n        assertTrue(add(add(a, b), c) == add(a, add(b, c)))\n      }\n    },\n    test(\"add is identitive\") {\n      check(Gen.int) { a =>\n        assertTrue(add(a, 0) == a)\n      }\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting JVM Metrics Sidecar with ZIO in Scala\nDESCRIPTION: This snippet (from 'examples/jvm/src/main/scala/zio/examples/metrics/JvmMetricAppExample.scala') shows how to launch a ZIO-built JVM metrics collector as a sidecar process. It leverages ZIO's metric collection layers and composes them with other services so metrics are captured alongside a main application without requiring code changes in the primary codebase. Required dependencies include the ZIO and zio-metrics-jvm packages. Inputs are layer specifications and service compositions; outputs are sidecar metric processes and Prometheus endpoints. The solution assumes a compatible ZIO environment and correct service/layer configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/jvm.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport utils._\\n\\nprintSource(\"examples/jvm/src/main/scala/zio/examples/metrics/JvmMetricAppExample.scala\")\n```\n\n----------------------------------------\n\nTITLE: Debugging ZIO Stream with debug Effect\nDESCRIPTION: An example showing how to debug a ZIO Stream using the debug effect to print values before and after transformations, demonstrating debugging in stream-based ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/debug-a-zio-application.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nZStream\n  .fromIterable(1 to 3)\n  .debug(\"before map\")\n  .map(_ * 2)\n  .debug(\"after map\")\n  .runDrain\n```\n\n----------------------------------------\n\nTITLE: Implementing Safe File Word Count with ZIO.acquireReleaseWith in Scala\nDESCRIPTION: Provides a practical example of `ZIO.acquireReleaseWith` for safe file handling to count lines (as a proxy for words). It defines helper functions: `openFile` (acquire using `ZIO.attemptBlockingIO`), `closeFile` (release using `ZIO.succeedBlocking`), and `wordCount` (use using `ZIO.attemptBlocking`). `ZIO.acquireReleaseWith` orchestrates these effects, ensuring the file (`Source`) is properly closed via `closeFile` even if `wordCount` throws an exception.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\nimport scala.io.Source\nimport zio._\n\ndef wordCount(fileName: String): ZIO[Any, Throwable, Int] = {\n  def openFile(name: => String): ZIO[Any, IOException, Source] =\n    ZIO.attemptBlockingIO(Source.fromFile(name))\n\n  def closeFile(source: => Source): ZIO[Any, Nothing, Unit] =\n    ZIO.succeedBlocking(source.close())\n\n  def wordCount(source: => Source): ZIO[Any, Throwable, Int] =\n    ZIO.attemptBlocking(source.getLines().length)\n\n  ZIO.acquireReleaseWith(openFile(fileName))(closeFile(_))(wordCount(_))\n}\n```\n\n----------------------------------------\n\nTITLE: Typed Log Annotations with zio-logging (Scala)\nDESCRIPTION: This advanced example demonstrates the creation of a typed log annotation for a User case class, using zio-logging and zio-json for JSON encoding of structured log values. A custom log annotation is registered to include User information in log messages. The ConsoleLoggerConfig is customized to output both trace and user annotations in log format. Dependencies: zio, zio-logging, zio-json. Inputs: a list of users. Outputs: JSON log messages with structured user context. Constraints: requires zio-logging and zio-json setup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.json.{DeriveJsonEncoder, EncoderOps}\\nimport zio.logging.{ConsoleLoggerConfig, LogAnnotation, LogFormat, consoleJsonLogger}\\nimport zio._\\n\\nobject TypedLogAnnotationExample extends ZIOAppDefault {\\n\\n  case class User(firstName: String, lastName: String)\\n\\n  object User {\\n    implicit val encoder = DeriveJsonEncoder.gen[User]\\n  }\\n\\n  private val userLogAnnotation = LogAnnotation[User](\\\"user\\\", (_, u) => u, _.toJson)\\n  \\n  private val logConfig = ConsoleLoggerConfig.default.copy(\\n    format = LogFormat.default + LogFormat.annotation(LogAnnotation.TraceId) + LogFormat.annotation(userLogAnnotation)\\n  )\\n\\n  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =\\n    Runtime.removeDefaultLoggers >>> consoleJsonLogger(logConfig)\\n\\n  def run =\\n    for {\\n      _ <- ZIO.foreachPar(List(User(\\\"John\\\", \\\"Doe\\\"), User(\\\"Jane\\\", \\\"Doe\\\"))) { user =>\\n        {\\n          ZIO.logInfo(\\\"Starting operation\\\") *>\\n            ZIO.sleep(500.millis) *>\\n            ZIO.logInfo(\\\"Stopping operation\\\")\\n        } @@ userLogAnnotation(user)\\n      }\\n      _ <- ZIO.logInfo(\\\"Done\\\")\\n    } yield ()\\n\\n}\n```\n\n----------------------------------------\n\nTITLE: Complete ZIO Kafka Streaming Producer and Consumer Application in Scala\nDESCRIPTION: This Scala code provides a complete, runnable `ZIOAppDefault` application demonstrating a ZIO Kafka streaming producer and consumer. The producer sends a timestamped message every second to `KAFKA_TOPIC`. The consumer reads from the same topic, prints consumed messages, and commits offsets in batches using `aggregateAsync`. Both producer and consumer lifecycles are managed using `ZIO.scoped`. It highlights a performance caution regarding the use of `tap` which can break stream chunking.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport org.apache.kafka.clients.producer.ProducerRecord\nimport zio._\nimport zio.kafka.consumer._\nimport zio.kafka.producer.{Producer, ProducerSettings}\nimport zio.kafka.serde._\nimport zio.stream.ZStream\n\nobject StreamingKafkaApp extends ZIOAppDefault {\n  private val BOOSTRAP_SERVERS = List(\"localhost:9092\")\n  private val KAFKA_TOPIC      = \"streaming-hello\"\n\n  private val producerSettings = ProducerSettings(BOOSTRAP_SERVERS)\n  private val consumerSettings =\n    ConsumerSettings(BOOSTRAP_SERVERS).withGroupId(\"streaming-kafka-app\")\n\n  def run: ZIO[Any, Throwable, Unit] = {\n    val p: ZIO[Any, Throwable, Unit] =\n      ZIO.scoped {\n        for {\n          producer <- Producer.make(producerSettings)\n          _ <- ZStream\n            .repeatZIO(Clock.currentDateTime)\n            .schedule(Schedule.spaced(1.second))\n            .map { time =>\n              new ProducerRecord(\n                KAFKA_TOPIC,\n                time.getMinute,\n                s\"$time -- Hello, World!\"\n              )\n            }\n            .via(producer.produceAll(Serde.int, Serde.string))\n            .runDrain\n        } yield ()\n      }\n\n    val c: ZIO[Any, Throwable, Unit] =\n      ZIO.scoped {\n        for {\n          consumer <- Consumer.make(consumerSettings)\n          _ <- consumer\n            .plainStream(\n              Subscription.topics(KAFKA_TOPIC),\n              Serde.int,\n              Serde.string\n            )\n            // Do not use `tap` in throughput sensitive applications because it\n            // destroys the chunking structure and leads to lower performance.\n            // See the previous section for more info.\n            .tap(r => Console.printLine(\"Consumed: \" + r.value))\n            .map(_.offset)\n            .aggregateAsync(Consumer.offsetBatches)\n            .mapZIO(_.commit)\n            .runDrain\n        } yield ()\n      }\n\n    p <&> c\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Catching All Errors in ZIO (Scala)\nDESCRIPTION: Shows how to use the `catchAll` method to catch and recover from all types of errors. This allows for effectful recovery attempts.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nval z: IO[IOException, Array[Byte]] =\n  readFile(\"primary.json\").catchAll(_ =>\n    readFile(\"backup.json\"))\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Built-in Services in a Simple Application\nDESCRIPTION: This example demonstrates how to use ZIO's built-in services (Clock and Console) in a simple application. The code creates a ZIO application that displays the current date, prompts for a user's name, and then greets the user with their name.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, IOException, Unit] = \n    for {\n      date <- Clock.currentDateTime\n      _    <- ZIO.logInfo(s\"Application started at $date\")\n      _    <- Console.print(\"Enter your name: \")\n      name <- Console.readLine\n      _    <- Console.printLine(s\"Hello, $name!\")\n    } yield ()\n\n  def run = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: File Transfer Implementation\nDESCRIPTION: Complex example showing file transfer implementation using ZManaged resources.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef is(file: String): Task[FileInputStream]  = Task.effect(???)\ndef os(file: String): Task[FileOutputStream] = Task.effect(???)\n\ndef close(resource: Closeable): UIO[Unit] = Task.effectTotal(???)\ndef copy(from: FileInputStream, to: FileOutputStream): Task[Unit] = ???\n\ndef transfer(from: String, to: String): ZIO[Any, Throwable, Unit] = {\n  val resource: ZManaged[Any, Throwable, Unit] = for {\n    from <- ZManaged.make(is(from))(close)\n    to   <- ZManaged.make(os(to))(close)\n    _    <- copy(from, to).toManaged_\n  } yield ()\n  resource.useNow\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Application with Distage DI\nDESCRIPTION: Complete example showing how to create a ZIO application using Distage for dependency injection. Demonstrates creation of services, dependency wiring, and runtime execution using ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/distage.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport distage.{Activation, Injector, ModuleDef, Roots}\nimport izumi.distage.model.Locator\nimport izumi.distage.model.definition.Lifecycle\nimport zio.{ExitCode, Task, UIO, URIO, ZIO}\n\nimport java.time.LocalDateTime\n\ntrait Random {\n  def nextInteger: UIO[Int]\n}\n\nfinal class ScalaRandom extends Random {\n  override def nextInteger: UIO[Int] =\n    ZIO.effectTotal(scala.util.Random.nextInt())\n}\n\ntrait Logger {\n  def log(name: String): Task[Unit]\n}\n\nfinal class ConsoleLogger extends Logger {\n  override def log(line: String): Task[Unit] = {\n    val timeStamp = LocalDateTime.now()\n    ZIO.effect(println(s\"$timeStamp: $line\"))\n  }\n}\n\nfinal class RandomApp(random: Random, logger: Logger) {\n  def run: Task[Unit] = for {\n    random <- random.nextInteger\n    _ <- logger.log(s\"random number generated: $random\")\n  } yield ()\n}\n\nobject DistageExample extends zio.App {\n  def RandomAppModule: ModuleDef = new ModuleDef {\n    make[Random].from[ScalaRandom]\n    make[Logger].from[ConsoleLogger]\n    make[RandomApp] // `.from` is not required for concrete classes\n  }\n  \n  val resource: Lifecycle[Task, Locator] = Injector[Task]().produce(\n    plan = Injector[Task]().plan(\n      bindings = RandomAppModule,\n      activation = Activation.empty,\n      roots = Roots.target[RandomApp]\n    )\n  )\n\n  val myApp: Task[Unit] = resource.use(locator => locator.get[RandomApp].run)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Memoization of ZIO Layers\nDESCRIPTION: This example demonstrates how to manually memoize a ZIO layer using ZLayer#memoize, ensuring that the 'A' layer is initialized only once despite being used multiple times.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-memoization.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    ZIO.scoped {\n      a.memoize.flatMap { aLayer =>\n        for {\n          _ <- ZIO.service[A].provide(aLayer)\n          _ <- ZIO.service[A].provide(aLayer)\n        } yield ()\n      }\n    }\n    \n  def run = myApp\n}\n// The output:\n// initialized: MainApp$$anon$1@2bfc2bcc\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Application with Metrics and Prometheus Integration\nDESCRIPTION: This Scala code snippet showcases a complete ZIO application that collects metrics using ZIO ZMX and exposes them via Prometheus protocol. It sets up an HTTP server, defines custom metrics, and provides an endpoint for Prometheus to scrape.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_55\n\nLANGUAGE: scala\nCODE:\n```\nimport uzhttp._\nimport uzhttp.server.Server\nimport zio._\nimport zio.blocking.Blocking\nimport zio.clock.Clock\nimport zio.console._\nimport zio.duration.durationInt\nimport zio.zmx.metrics._\nimport zio.zmx.prometheus.PrometheusClient\n\nimport java.io.IOException\nimport java.lang\nimport java.net.InetSocketAddress\n\nobject ZmxSampleApp extends zio.App {\n\n  val myApp: ZIO[Console with Clock with Has[PrometheusClient] with Blocking, IOException, Unit] =\n    for {\n      server <-\n        Server\n          .builder(new InetSocketAddress(\"localhost\", 8080))\n          .handleSome { case request if request.uri.getPath == \"/\" =>\n            PrometheusClient.snapshot.map(p => Response.plain(p.value))\n          }\n          .serve\n          .use(_.awaitShutdown).fork\n      program <-\n        (for {\n          _ <- (ZIO.sleep(1.seconds) *> request @@ MetricAspect.count(\"request_counts\")).forever.forkDaemon\n          _ <- (ZIO.sleep(3.seconds) *>\n            ZIO.succeed(\n              lang.Runtime.getRuntime.totalMemory() - lang.Runtime.getRuntime.freeMemory()\n            ).map(_ / (1024.0 * 1024.0)) @@ MetricAspect.setGauge(\"memory_usage\")).forever.forkDaemon\n        } yield ()).fork\n      _ <- putStrLn(\"Press Any Key\") *> getStrLn.catchAll(_ => ZIO.none) *> server.interrupt *> program.interrupt\n    } yield ()\n\n  def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    myApp.provideCustomLayer(PrometheusClient.live).exitCode\n\n  private def request: UIO[Unit] = ZIO.unit\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Successful Handler in ZIO HTTP\nDESCRIPTION: This snippet shows how to create a Handler that always returns a successful response in ZIO HTTP. It uses the Handler.succeed constructor to create a handler that returns a text response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\n\nval app: Handler[Any, Nothing, Any, Response] =\n  Handler.succeed(Response.text(\"Hello, world!\"))\n```\n\n----------------------------------------\n\nTITLE: Complete Kafka Producer and Consumer Example with ZIO\nDESCRIPTION: A complete ZIO application that produces and consumes messages from a Kafka cluster without using ZIO Streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.kafka.consumer._\nimport zio.kafka.producer.{Producer, ProducerSettings}\nimport zio.kafka.serde._\n\n/** A simple app that produces and consumes messages from a kafka cluster\n * without using ZIO Streams.\n */\nobject SimpleKafkaApp extends ZIOAppDefault {\n  private val BOOSTRAP_SERVERS = List(\"localhost:9092\")\n  private val KAFKA_TOPIC      = \"hello\"\n\n  def run: ZIO[Scope, Throwable, Unit] = {\n    for {\n      c <- Consumer\n        .consumeWith(\n          settings =\n            ConsumerSettings(BOOSTRAP_SERVERS).withGroupId(\"simple-kafka-app\"),\n          subscription = Subscription.topics(KAFKA_TOPIC),\n          keyDeserializer = Serde.long,\n          valueDeserializer = Serde.string\n        ) { record =>\n          Console.printLine(s\"Consumed ${record.key()}, ${record.value()}\").orDie\n        }\n        .fork\n\n      producer <- Producer.make(ProducerSettings(BOOSTRAP_SERVERS))\n      p <- Clock.currentDateTime\n        .flatMap { time =>\n          producer.produce[Any, Long, String](\n            topic = KAFKA_TOPIC,\n            key = time.getHour.toLong,\n            value = s\"$time -- Hello, World!\",\n            keySerializer = Serde.long,\n            valueSerializer = Serde.string\n          )\n        }\n        .schedule(Schedule.spaced(1.second))\n        .fork\n\n      _ <- (c <*> p).join\n    } yield ()\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Fiber to ZIO Effect in Scala\nDESCRIPTION: Demonstrates how to convert a Fiber into a ZIO effect using ZIO.fromFiber. This allows integrating fiber results into the ZIO effect system.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval io: IO[Nothing, String] = ZIO.fromFiber(Fiber.succeed(\"Hello from Fiber!\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Finalizer Constructor in Scala\nDESCRIPTION: This snippet shows the signature of the 'finalizer' method in ZStream for adding finalization logic to streams. It takes a finalizer action that will be executed before the stream ends.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/resourceful-streams.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject ZStream {\n  def finalizer[R](\n    finalizer: URIO[R, Any]\n  ): ZStream[R, Nothing, Any] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Money Transfer Using ZIO STM\nDESCRIPTION: Demonstrates a basic money transfer function using STM that atomically transfers an amount between accounts, failing if the sender doesn't have enough funds. The transaction is executed using STM.atomically which turns the STM effect into a ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/stm.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\ndef transferMoney(from: TRef[Long], to: TRef[Long], amount: Long): STM[String, Long] =\n  for {\n    senderBal <- from.get\n    _         <- if (senderBal < amount) STM.fail(\"Not enough money\")\n                 else STM.unit\n    _         <- from.update(existing => existing - amount)\n    _         <- to.update(existing => existing + amount)\n    recvBal   <- to.get\n  } yield recvBal\n\nval program: IO[String, Long] = for {\n  sndAcc  <- STM.atomically(TRef.make(1000L))\n  rcvAcc  <- STM.atomically(TRef.make(0L))\n  recvAmt <- STM.atomically(transferMoney(sndAcc, rcvAcc, 500L))\n} yield recvAmt\n```\n\n----------------------------------------\n\nTITLE: Awaiting a Fiber's Exit Value in Scala using ZIO\nDESCRIPTION: This code demonstrates how to await a fiber's exit value in ZIO. It forks an effect and then uses the await method to get the Exit value, which provides full information on how the fiber completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber <- ZIO.succeed(\"Hi!\").fork\n  exit  <- fiber.await\n} yield exit\n```\n\n----------------------------------------\n\nTITLE: Implementing Efficient Pull-based Streams in Scala with ZIO\nDESCRIPTION: Demonstrates how to create an efficient, pull-based stream for downloading data as CSV. The stream lazily fetches data from a database, converts it to CSV, encodes it to UTF-8, and applies gzip compression.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef downloadAsCsv(id: String): ZStream[Db, IOException, Byte] =\n  jdbc\n    .selectMany(sql\"SELECT * FROM events WHERE userId = $id\")\n    .map(toCSV)\n    .via(ZPipeline.utf8Encode)\n    .via(ZPipeline.gzip)\n```\n\n----------------------------------------\n\nTITLE: Composing Optional ZIO Effects using For-Comprehension in Scala\nDESCRIPTION: Demonstrates composing multiple ZIO effects that return optional values (`IO[E, Option[A]]`) within a Scala for-comprehension. It uses `ZIO.fromOption` to start the chain, `.some` to lift subsequent optional results into the comprehension's context, and `.asSomeError` to handle errors within the optional context. Finally, `.unsome` lifts the successful result back into an `IO[Throwable, Option[(User, Team)]]`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait Team\ncase class User(teamId: String)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Team // Added from invisible block\ncase class User(teamId: String) // Added from invisible block\n\nval maybeId: IO[Option[Nothing], String] = ZIO.fromOption(Some(\"abc123\"))\ndef getUser(userId: String): IO[Throwable, Option[User]] = ???\ndef getTeam(teamId: String): IO[Throwable, Team] = ???\n\n\nval result: IO[Throwable, Option[(User, Team)]] = (for {\n  id   <- maybeId\n  user <- getUser(id).some\n  team <- getTeam(user.teamId).asSomeError\n} yield (user, team)).unsome\n```\n\n----------------------------------------\n\nTITLE: Implementing a Pulsar Producer-Consumer Application with ZIO\nDESCRIPTION: This complete example demonstrates how to create a Pulsar producer and consumer with ZIO Pulsar. It shows stream-based message production, subscription configuration, message consumption with acknowledgment, and proper ZIO environment setup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-pulsar.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport org.apache.pulsar.client.api.{PulsarClientException, Schema}\nimport zio._\nimport zio.blocking._\nimport zio.clock._\nimport zio.console._\nimport zio.pulsar._\nimport zio.stream._\n\nimport java.nio.charset.StandardCharsets\n\nobject StreamingExample extends zio.App {\n  val topic = \"my-topic\"\n\n  val producer: ZManaged[Has[PulsarClient], PulsarClientException, Unit] =\n    for {\n      sink <- Producer.make(topic, Schema.STRING).map(_.asSink)\n      _ <- Stream.fromIterable(0 to 100).map(i => s\"Message $i\").run(sink).toManaged_\n    } yield ()\n\n  val consumer: ZManaged[Has[PulsarClient] with Blocking with Console, PulsarClientException, Unit] =\n    for {\n      builder <- ConsumerBuilder.make(Schema.STRING).toManaged_\n      consumer <- builder\n        .subscription(Subscription(\"my-subscription\", SubscriptionType.Exclusive))\n        .topic(topic)\n        .build\n      _ <- consumer.receiveStream.take(10).foreach { e =>\n        consumer.acknowledge(e.getMessageId) *>\n          putStrLn(new String(e.getData, StandardCharsets.UTF_8)).orDie\n      }.toManaged_\n    } yield ()\n\n  val myApp =\n    for {\n      f <- consumer.fork\n      _ <- producer\n      _ <- f.join.toManaged_\n    } yield ()\n\n  def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    myApp\n      .provideCustom(\n        (Console.live ++ Clock.live) >+>\n          PulsarClient.live(\"localhost\", 6650)\n      ).useNow.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Executing ZIO Effects with Default Runtime in Scala\nDESCRIPTION: This code demonstrates how to use the default Runtime to execute a ZIO effect. It uses the unsafe run method to synchronously execute a simple println effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/running-effects.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nUnsafe.unsafe { implicit unsafe =>\n    runtime.unsafe.run(ZIO.attempt(println(\"Hello World!\"))).getOrThrowFiberFailure()\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Ref Values Atomically in Scala\nDESCRIPTION: Shows how to use the update method to atomically modify the state of a Ref using a pure function. It includes an example of incrementing a counter.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval counterInitial = 0\nfor {\n  counterRef <- Ref.make(counterInitial)\n  _          <- counterRef.update(_ + 1)\n  value <- counterRef.get\n} yield assert(value == 1)\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Foreach with Compositional Parallelism in ZIO 2.x (Scala)\nDESCRIPTION: Shows the preferred ZIO 2.x method for parallel processing with controlled concurrency. It uses `ZIO.foreachPar` to apply the `download` function to each URL and then compositionally modifies the effect using `.withParallelism(8)` to limit the maximum number of concurrent fibers to 8. This approach enhances composability compared to ZIO 1.x's `foreachParN`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nZIO.foreachPar(urls)(download).withParallelism(8)\n```\n\n----------------------------------------\n\nTITLE: Functional State Management with Ref in ZIO (Scala)\nDESCRIPTION: This snippet demonstrates encapsulating state mutation using a ZIO Ref, which safely manages concurrent updates in a functional style. The freshVar function atomically generates fresh variable names by updating the Ref. Requires ZIO's Ref and UIO, and receives an initial counter value. Inputs: initial value for Ref; outputs: effect yielding new variable names. Constraints: requires ZIO context, side effects managed by ZIO's runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nRef.make(0).flatMap { idCounter =>\n  def freshVar: UIO[String] =\n    idCounter.modify(cpt => (s\"var${cpt + 1}\", cpt + 1))\n\n  for {\n    v1 <- freshVar\n    v2 <- freshVar\n    v3 <- freshVar\n  } yield ()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fiber Interruption in Parallel Effects Using ZIO (Scala)\nDESCRIPTION: This Scala snippet presents a ZIO application that explores how parallel composition operators (<*>, <&>, zipWithPar) propagate interruptions between fibers. Several example tasks are created, each with custom interruption logic via onInterrupt. The code defines helper methods for logging fiber activity and uses debug statements to trace execution. Users can uncomment different parallel operation lines to observe how interruption flows. Dependencies include ZIO and knowledge of fiber concurrency constructs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\nobject MainApp extends ZIOAppDefault {\\n\\n  def debugInterruption(taskName: String) = (fibers: Set[FiberId]) =>\\n    for {\\n      fn <- ZIO.fiberId.map(_.threadName)\\n      _ <- ZIO.debug(\\n        s\"The $fn fiber which is the underlying fiber of the $taskName task \" +\\n          s\"interrupted by ${fibers.map(_.threadName).mkString(\", \")}\"\\n      )\\n    } yield ()\\n\\n  def task[R, E, A](name: String)(zio: ZIO[R, E, A]): ZIO[R, E, A] =\\n    zio.onInterrupt(debugInterruption(name))\\n\\n  def debugMainFiber =\\n    for {\\n      fn <- ZIO.fiberId.map(_.threadName)\\n      _ <- ZIO.debug(s\"Main fiber ($fn) starts executing the whole application.\")\\n    } yield ()\\n\\n  def run = {\\n    // self interrupting fiber \\n    val first = task(\"first\")(ZIO.interrupt)\\n\\n    // never ending fiber\\n    val second = task(\"second\")(ZIO.never)\\n\\n    debugMainFiber *> {\\n      // uncomment each line and run the code to see the result\\n\\n      // first fiber will be interrupted \\n      first *> second\\n\\n      // never ending application\\n      // second *> first\\n\\n      // first fiber will be interrupted\\n      // first <*> second\\n\\n      // never ending application\\n      // second <*> first\\n\\n      // first and second will be interrupted\\n      // first <&> second\\n\\n      // first and second will be interrupted \\n      // second <&> first\\n    }\\n  }\\n\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Routes in ZIO HTTP\nDESCRIPTION: This snippet shows how to create multiple routes and combine them into a single Routes object in ZIO HTTP. It defines two GET routes for '/hello' and '/greet' paths.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\n\nval routes: Routes[Any, Nothing] =\n  Routes(\n    Method.GET / \"hello\" -> handler(Response.text(\"Hello, world!\")),\n    Method.GET / \"greet\" -> handler(Response.text(\"Hello, ZIO!\"))\n  )\n```\n\n----------------------------------------\n\nTITLE: Modeling Expected Errors (Failures) with ZIO.fail in Scala\nDESCRIPTION: The `ZIO.fail` function is used to model expected errors, known as Failures, within a ZIO application. These are errors that the program anticipates and should have logic to handle, preventing them from propagating unhandled throughout the call stack.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nZIO.fail\n```\n\n----------------------------------------\n\nTITLE: Customizing the ZIO Runtime Executor with ZIOAppDefault in Scala\nDESCRIPTION: This snippet illustrates how to customize the ZIO runtime environment for an application extending `ZIOAppDefault`. By overriding the `bootstrap` value, it sets a custom `Executor` using `Runtime.setExecutor`. The custom executor is created from a standard Java `ThreadPoolExecutor` with specific configuration (core/max pool size, keep-alive time, queue). The application's logic is represented by `myAppLogic`. This requires dependencies on `zio`, `zio.Executor`, and standard Java concurrency utilities (`ThreadPoolExecutor`, `TimeUnit`, `LinkedBlockingQueue`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zioapp.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:invisible\nimport zio._\nval myAppLogic = ZIO.succeed(???)\n```\n```\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\nimport zio.Executor\nimport java.util.concurrent.{LinkedBlockingQueue, ThreadPoolExecutor, TimeUnit}\n\nobject CustomizedRuntimeZIOApp extends ZIOAppDefault {\n  override val bootstrap = Runtime.setExecutor(\n    Executor.fromThreadPoolExecutor(\n      new ThreadPoolExecutor(\n        5,\n        10,\n        5000,\n        TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue[Runnable]()\n      )\n    )\n  )\n\n  def run = myAppLogic\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Nested Fibers and Parent-Child Lifetime Management in ZIO (Scala)\nDESCRIPTION: Demonstrates how nested fibers work in ZIO: a parent fiber (`fooJob`) creates a long-running child fiber (`barJob`), but when the parent completes, the child is correctly interrupted and cleaned up. Shows composing effects, forking, and joining, as well as scheduled repetition and delays. Inputs and outputs are managed through ZIO's fiber API. Key dependency: ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug(\"Bar: still running!\")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- ZIO.debug(\"Foo: started!\")\n      _ <- barJob.fork\n      _ <- ZIO.sleep(3.seconds)\n      _ <- ZIO.debug(\"Foo: finished!\")\n    } yield ()\n\n  def run =\n    for {\n      f <- fooJob.fork\n      _ <- f.join\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Compositional Updates with FiberRef\nDESCRIPTION: Implementation of compositional updates for Map[String, Int] using FiberRef and Differ. Shows how to create and update a fiber-local variable with composable modifications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Main extends ZIOAppDefault {\n\n  val differ = Differ.map[String, Int, Int => Int](Differ.update[Int])\n\n  val retryConfig: FiberRef[Map[String, Int]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.makePatch[Map[String, Int], Differ.MapPatch[\n        String,\n        Int,\n        Int => Int\n      ]](\n        Map(\n          \"retries\" -> 3,\n          \"intervals\" -> 2\n        ),\n        differ = differ,\n        fork0 = differ.empty\n      )\n    }\n\n  def withRetry(n: Int): UIO[Unit] =\n    retryConfig.update(_.updated(\"retries\", n))\n\n  def withIntervals(n: Int): UIO[Unit] =\n    retryConfig.update(_.updated(\"intervals\", n))\n\n  def run = {\n    for {\n      _ <- withRetry(5) <&> withIntervals(3)\n      _ <- retryConfig.get.debug(\"retryConfig\")\n    } yield ()\n\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Locally Scoped Runtime Configuration in Scala\nDESCRIPTION: Shows how to apply runtime configuration to a specific region of code using ZIO's provide method. This example demonstrates changing logging behavior for a portion of the application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val addSimpleLogger: ZLayer[Any, Nothing, Unit] =\n    Runtime.addLogger((_, _, _, message: () => Any, _, _, _, _) => println(message()))\n\n  def run =\n    for {\n      _ <- ZIO.log(\"Application started!\")\n      _ <- {\n        for {\n          _ <- ZIO.log(\"I'm not going to be logged!\")\n          _ <- ZIO.log(\"I will be logged by the simple logger.\").provide(addSimpleLogger)\n          _ <- ZIO.log(\"Reset back to the previous configuration, so I won't be logged.\")\n        } yield ()\n      }.provide(Runtime.removeDefaultLoggers)\n      _ <- ZIO.log(\"Application is about to exit!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Uncatchable Fatal Errors in ZIO Scala\nDESCRIPTION: This Scala code snippet defines a ZIO application (`ZIOAppDefault`) that attempts to execute code throwing a `StackOverflowError`. Despite using `catchAll` and `catchAllDefect` to handle expected and unexpected errors respectively, the fatal `StackOverflowError` bypasses these handlers, causing the ZIO runtime to terminate the application abruptly. This demonstrates ZIO's behavior with JVM fatal errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/fatals.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO\n      .attempt(\n        throw new StackOverflowError(\n          \"The call stack pointer exceeds the stack bound.\"\n        )\n      )\n      .catchAll(_ => ZIO.unit)       // ignoring all expected errors\n      .catchAllDefect(_ => ZIO.unit) // ignoring all unexpected errors\n}\n```\n```\n\nLANGUAGE: scala\nCODE:\n```\n```scala\njava.lang.StackOverflowError: The call stack pointer exceeds the stack bound.\nat zio.examples.MainApp$.$anonfun$run$1(MainApp.scala:10)\nat zio.ZIO$.liftedTree1$1(ZIO.scala:2603)\nat zio.ZIO$.$anonfun$attempt$1(ZIO.scala:2603)\nat zio.ZIO$.$anonfun$isFatalWith$1(ZIO.scala:3571)\nat zio.internal.FiberContext.runUntil(FiberContext.scala:410)\nat zio.internal.FiberContext.run(FiberContext.scala:111)\nat zio.Runtime.unsafeRunWithRefs(Runtime.scala:400)\n  ...\n**** WARNING ****\nCatastrophic error encountered. Application not safely interrupted. Resources may be leaked. Check the logs for more details and consider overriding `Runtime.reportFatal` to capture context.\n```\n```\n\n----------------------------------------\n\nTITLE: Unified ZRef Type Parameters in Scala\nDESCRIPTION: Type signature for ZRef when error and value types are unified, enabling atomic modify and update operations with concurrent access safety.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/zref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nZRef[E, E, A, A]\n```\n\n----------------------------------------\n\nTITLE: Defining catchAllDefect and catchSomeDefect for ZIO - Scala\nDESCRIPTION: Adds operators to ZIO for catching defects (unhandled exceptions and fatal errors) with total or partial functions. catchAllDefect handles all defects with a handler, while catchSomeDefect applies recovery only to matching Throwables. This is foundational for catching dies in ZIO computations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def catchAllDefect[R1 <: R, E1 >: E, A1 >: A](h: Throwable => ZIO[R1, E1, A1]): ZIO[R1, E1, A1]\n\n  def catchSomeDefect[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[Throwable, ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating ZIO.acquireReleaseWith Structure in Scala\nDESCRIPTION: Shows the basic structure and signature of the `ZIO.acquireReleaseWith` combinator using placeholder implementations (`???`). It highlights the three distinct effectful parameters required: `acquire` for obtaining a resource, `release` for cleaning it up, and `use` for performing operations with the acquired resource. This construct guarantees the `release` effect runs after `acquire` succeeds, regardless of the `use` effect's outcome.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.acquireReleaseWith(acquire = ???)(release = ???)(use = ???)\n```\n\n----------------------------------------\n\nTITLE: Creating a Summary Metric Instance in Scala\nDESCRIPTION: Demonstrates the creation of a `Summary` metric instance named 'mySummary' using `Metric.summary`. This summary is configured to hold up to 100 samples (`maxSize`), retain samples for a maximum of 1 day (`maxAge`), allow a 3% error margin (`error`), and calculate the 10th, 50th, and 90th percentiles (`quantiles`). It imports necessary ZIO and metrics components.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/summary.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.metrics._\nimport zio.metrics.Metric.Summary\n\nval summary: Summary[Double] =\n  Metric.summary(\n    name = \"mySummary\", \n    maxAge = 1.day,\n    maxSize = 100,\n    error = 0.03d, \n    quantiles = Chunk(0.1, 0.5, 0.9)\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating a Deduplication Channel in Scala ZIO\nDESCRIPTION: Implements a channel that removes duplicate values from the input stream using a HashSet to track seen values, demonstrating state management with Ref in ZChannel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nimport scala.collection.immutable.HashSet\n\nobject MainApp extends ZIOAppDefault {\n  val dedup =\n    ZChannel.fromZIO(Ref.make[HashSet[Int]](HashSet.empty)).flatMap { ref =>\n      lazy val inner: ZChannel[Any, Any, Int, Any, Nothing, Int, Unit] =\n        ZChannel.readWith(\n          (i: Int) =>\n            ZChannel\n              .fromZIO(ref.modify(s => (s contains i, s incl i)))\n              .flatMap {\n                case true  => ZChannel.unit\n                case false => ZChannel.write(i)\n              } *> inner,\n          (_: Any) => ZChannel.unit,\n          (_: Any) => ZChannel.unit\n        )\n      inner\n    }\n\n  def run =\n    (ZChannel.writeAll(1, 2, 2, 3, 3, 4, 2, 5, 5) >>> dedup).runCollect.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Lifting Option to ZIO with Success on None using ZIO.noneOrFail Variants in Scala\nDESCRIPTION: Shows how to use `ZIO.noneOrFail` and `ZIO.noneOrFailWith` to convert an `Option` to a ZIO effect, succeeding when the Option is `None` and failing when it's `Some`. If `optionalValue` is `None`, the effect succeeds with `Unit`. If it's `Some(e)`, `ZIO.noneOrFail` fails with `e` (String), while `ZIO.noneOrFailWith` fails with a custom error created by applying the provided function to `e`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval optionalValue: Option[String] = ???\n\n// If the optional value is empty it succeeds with Unit\n// If the optional value is defined it will fail with the content of the optional value\nval r1: ZIO[Any, String, Unit] =\n  ZIO.noneOrFail(optionalValue)\n\n// If the optional value is empty it succeeds with Unit\n// If the optional value is defined, it will fail by applying the error function to it:\nval r2: ZIO[Any, NumberFormatException, Unit] =\n  ZIO.noneOrFailWith(optionalValue)(e => new NumberFormatException(e))\n```\n\n----------------------------------------\n\nTITLE: Mocking Configuration Provider for ZIO Service Testing in Scala\nDESCRIPTION: This snippet demonstrates how to create a mock configuration provider and use it in a ZIO test spec. It sets up a test for a service that reads configuration data, overriding the default config provider with a mocked version.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/configuration/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nobject MyServiceTest extends ZIOSpecDefault {\n\n  val mockConfigProvider: ZLayer[Any, Nothing, Unit] =\n    Runtime.setConfigProvider(ConfigProvider.fromMap(Map(\"timeout\" -> \"5s\")))\n\n  // This service reads configuration data (host and port) inside its implementation\n  def myService: ZIO[Any, Config.Error, Double] = ???\n\n  override def spec = {\n    val expected: Double = ??? // expected value\n    test(\"test myService\") {\n      for {\n        result <- myService\n      } yield assertTrue(result == expected)\n    }\n  }.provideLayer(mockConfigProvider)\n  \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Inversion of Control for Editor Service in Scala\nDESCRIPTION: Refactors the `Editor` class to accept its dependencies (`Formatter` and `Compiler`) as constructor parameters. This applies the Inversion of Control principle, decoupling the `Editor` from the *creation* of its dependencies. The responsibility of creating and providing the dependencies is shifted to the client code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent\nclass Editor(formatter: Formatter, compiler: Compiler) {\n  def formatAndCompile(code: String): UIO[String] =\n    formatter.format(code).flatMap(compiler.compile)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Catching All Errors with catchAll in ZIO for Scala\nDESCRIPTION: This snippet handles all error cases in a ZIO effect using catchAll, effectfully recovering from failure by running a backup operation. It demonstrates how to specify a fallback on error by returning another effect, and the error type may be narrowed or eliminated by this operation. Inputs are error-prone file-opening effects; outputs are recovered effects if the initial fails. Requires IO, catchAll, and relevant file-opening code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval z: IO[IOException, Array[Byte]] = \n  openFile(\"primary.json\").catchAll(_ => \n    openFile(\"backup.json\"))\n```\n\n----------------------------------------\n\nTITLE: Configuring Runtime with Custom Logger in Scala\nDESCRIPTION: Demonstrates how to configure the Runtime by providing a custom logger layer. This example removes default loggers and adds a simple custom logger.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val addSimpleLogger: ZLayer[Any, Nothing, Unit] =\n    Runtime.addLogger((_, _, _, message: () => Any, _, _, _, _) => println(message()))\n\n  def run = {\n    for {\n      _ <- ZIO.log(\"Application started!\")\n      _ <- ZIO.log(\"Application is about to exit!\")\n    } yield ()\n  }.provide(Runtime.removeDefaultLoggers ++ addSimpleLogger)\n}\n```\n\n----------------------------------------\n\nTITLE: Timeout Handling in ZIO (Scala)\nDESCRIPTION: Demonstrates how to add a timeout to an effect using the `timeout` method. The result is an `Option`, where `None` indicates that the timeout elapsed before the effect completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.succeed(\"Hello\").timeout(10.seconds)\n```\n\n----------------------------------------\n\nTITLE: File Line Counter Using Try-Finally\nDESCRIPTION: Improved implementation of file line counter using try-finally block to ensure resource cleanup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef lines(file: String): Task[Long] = ZIO.attempt {\n  def countLines(br: BufferedReader): Long = br.lines().count()\n  val bufferedReader = new BufferedReader(\n    new InputStreamReader(new FileInputStream(\"file.txt\")),\n    2048\n  )\n  try countLines(bufferedReader)\n  finally bufferedReader.close()\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Generator for Debugging in Scala\nDESCRIPTION: This snippet shows how to run a generator for debugging purposes using the runCollect and runCollectN methods to generate samples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/how-generators-work.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nval ints: ZIO[Any, Nothing, List[Int]] = Gen.int.runCollect.debug\n// Output: List(-2090696713)\n\nGen.int.runCollectN(5).debug\n// Output: List(281023690, -1852531706, -21674662, 187993034, -868811035)\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO#retry Method Signature in Scala\nDESCRIPTION: Defines the signature for the `retry` method on the ZIO trait. This method takes a `Schedule` policy and returns a new ZIO effect that retries the original effect upon failure according to the specified schedule. It depends on the ZIO core library and the `Schedule` data type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def retry[R1 <: R, S](policy: => Schedule[R1, E, S]): ZIO[R1, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.foreach for Sequential User Input in Scala\nDESCRIPTION: Demonstrates `ZIO.foreach` to collect a fixed number (3) of names from the user. It iterates over the range `1 to 3`. For each number in the range, it executes a sequence of ZIO effects: printing a prompt (`Console.print`) and reading a line (`Console.readLine`). The results from `Console.readLine` for each iteration are collected into a `Vector[String]` which is the final result of the `ZIO.foreach` effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nConsole.printLine(\"Please enter three names:\") *>\n  ZIO.foreach(1 to 3) { index =>\n    Console.print(s\"$index. \") *> Console.readLine\n  }.debug\n// Please enter three names:\n// 1. John\n// 2. Jane\n// 3. Joe\n// Vector(John, Jane, Joe)\n```\n\n----------------------------------------\n\nTITLE: Mapping Over Success Channel in ZIO Scala\nDESCRIPTION: Demonstrates using the `ZIO#map` method to transform the success value of a ZIO effect. It takes an existing `IO.succeed(21)` effect (which successfully computes an Int) and applies a function (`_ * 2`) to its success value, resulting in a new effect `UIO[Int]` that successfully computes `42`. This operation does not change whether the effect succeeds or fails. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_operations.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nimport zio._\n\nval succeeded: UIO[Int] = IO.succeed(21).map(_ * 2)\n```\n```\n\n----------------------------------------\n\nTITLE: Mapping ZIO Effects in Scala\nDESCRIPTION: Demonstrates how to transform the success and error values of ZIO effects using map and mapError methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-operations.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval succeeded: ZIO[Any, Nothing, Int] = ZIO.succeed(21).map(_ * 2)\n\nval failed: ZIO[Any, Exception, Unit] = \n  ZIO.fail(\"No no!\").mapError(msg => new Exception(msg))\n```\n\n----------------------------------------\n\nTITLE: Logging with ZIO.log (Scala)\nDESCRIPTION: This snippet demonstrates basic logging in a ZIO application using the ZIO.log function along with user interaction commands from the Console module. Required dependencies are zio and zio.Console. The code logs application start, reads user input, logs user interaction, and greets the user via the console. Inputs: none required. Outputs: log messages and terminal output. Ensure ZIO is set up in your project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\nval app =\\n  for {\\n    _ <- ZIO.log(\\\"Application started!\\\")\\n    name <- Console.readLine(\\\"Please enter your name: \\\" )\\n    _ <- ZIO.log(\\\"User entered its name: $name\\\")\\n    _ <- Console.printLine(\\\"Hello, $name\\\")\\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Completing ZIO Promises with Various Methods in Scala\nDESCRIPTION: Demonstrates different ways to complete a ZIO Promise, including succeed, complete, completeWith, done, fail, die, failCause, and interrupt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/promise.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval race: IO[String, Int] = for {\n    p     <- Promise.make[String, Int]\n    _     <- p.succeed(1).fork\n    _     <- p.complete(ZIO.succeed(2)).fork\n    _     <- p.completeWith(ZIO.succeed(3)).fork\n    _     <- p.done(Exit.succeed(4)).fork\n    _     <- p.fail(\"5\")\n    _     <- p.failCause(Cause.die(new Error(\"6\")))\n    _     <- p.die(new Error(\"7\"))\n    _     <- p.interrupt.fork\n    value <- p.await\n  } yield value\n```\n\n----------------------------------------\n\nTITLE: Interrupting Channel with Promise\nDESCRIPTION: Shows how to interrupt a channel using a Promise that gets fulfilled after a delay. The channel generates random numbers and prints them until the promise is fulfilled after 5 seconds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/channel-interruption.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nfor {\n  p <- Promise.make[Nothing, Unit]\n  f <- randomNumbers\n    .interruptWhen(p)\n    .mapOutZIO(e => Console.printLine(e))\n    .runDrain\n    .fork\n  _ <- p.succeed(()).delay(5.seconds)\n  _ <- f.join\n} yield ()\n\n// Output:\n// 74\n// 60\n// 52\n// 52\n// 79\n```\n\n----------------------------------------\n\nTITLE: Interactive Progress Bar Implementation with ZIO and Scala.js\nDESCRIPTION: Complete example showing how to create an interactive progress bar using ZIO and Scala.js. Demonstrates DOM manipulation, scheduling, and ZIO effects integration with browser APIs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-javascript.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.concurrent.TimeUnit\nimport org.scalajs.dom.{document,Element}\nimport zio._\nimport zio.Clock._\n\nobject Main extends ZIOAppDefault {\n\n  override def run = {\n    // The node into which we write our ZIO program output\n    val node: Element = dom.document.querySelector(\"#app\")\n    for {\n      _      <- Console.printLine(\"Starting progress bar demo.\")  // Outputs on browser console log.\n      _      <- IO.succeed(node.appendChild(target)) // \"node\" might provided in this page by mdoc.\n      target <- IO.succeed(document.createElement(\"pre\"))\n      _      <- update(target).repeat(Schedule.spaced(1.seconds))\n    } yield ExitCode.success\n  }\n\n  def update(target: Element) = {\n      for {\n        time   <- currentTime(TimeUnit.SECONDS)\n        output <- ZIO.succeed(progress((time % 11).toInt, 10))\n        _      <- ZIO.succeed(target.innerHTML = output)\n      } yield ()\n  }\n\n  def progress(tick: Int, size: Int) = {\n      val bar_length = tick\n      val empty_length = size - tick\n      val bar = \"#\" * bar_length + \" \" * empty_length\n      s\"$bar $bar_length%\"\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Accessor Methods for a BlobStorage Service\nDESCRIPTION: Example of implementing accessor methods in a companion object that fetch the service from the environment and forward method calls.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject BlobStorage {\n  // Accessor method for BlobStorage.get\n  def get(id: String): ZIO[BlobStorage, Throwable, Array[Byte]] =\n    ZIO.serviceWithZIO[BlobStorage](_.get(id))\n\n  // Accessor method for BlobStorage.put\n  def put(content: Array[Byte]): ZIO[BlobStorage, Throwable, String] =\n    ZIO.serviceWithZIO[BlobStorage](_.put(content))\n}\n```\n\n----------------------------------------\n\nTITLE: FiberRef Join vs InheritAll Comparison\nDESCRIPTION: Compares join and inheritAll behavior with delayed operations to show the difference in timing of value merging.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval withJoin =\n    for {\n        fiberRef <- FiberRef.make[Int](0)\n        fiber    <- (fiberRef.set(10) *> fiberRef.set(20).delay(2.seconds)).fork\n        _        <- fiber.join  // wait for fiber's end and copy final result 20 into fiberRef\n        v        <- fiberRef.get\n    } yield assert(v == 20)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval withoutJoin =\n    for {\n        fiberRef <- FiberRef.make[Int](0)\n        fiber    <- (fiberRef.set(10) *> fiberRef.set(20).delay(2.seconds)).fork\n        _        <- fiber.inheritAll.delay(1.second) // copy intermediate result 10 into fiberRef and continue\n        v        <- fiberRef.get\n    } yield assert(v == 10)\n```\n\n----------------------------------------\n\nTITLE: Main Application Assembly\nDESCRIPTION: Example of assembling and running a complete application using the DocRepo service with its dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/service-pattern.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n  val app =\n    for {\n      docRepo <- ZIO.service[DocRepo]\n      id      <- docRepo.save(\n                    Doc(\n                      \"title\",\n                      \"description\",\n                      \"en\",\n                      \"text/plain\",\n                      \"content\".getBytes()\n                    )\n                 )\n      doc     <- docRepo.get(id)\n      _       <- Console.printLine(\n                   s\"\"\"\n                     |Downloaded the document with $id id:\n                     |  title: ${doc.title}\n                     |  description: ${doc.description}\n                     |  language: ${doc.language}\n                     |  format: ${doc.format}\n                     |\"\"\".stripMargin\n                 )  \n      _       <- docRepo.delete(id)\n      _       <- Console.printLine(s\"Deleted the document with $id id\")\n    } yield ()\n\n  def run =\n    app.provide(\n      DocRepo.live,\n      InmemoryBlobStorage.layer,\n      InmemoryMetadataRepo.layer\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Resource Management with ZIO.acquireReleaseWith in Scala\nDESCRIPTION: Shows how to use ZIO.acquireReleaseWith for safe resource acquisition and release. It opens a file, processes its data, and ensures the file is closed, even in case of errors or interruptions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-resources.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval groupedFileData: IO[IOException, Unit] = \n  ZIO.acquireReleaseWith(openFile(\"data.json\"))(closeFile(_)) { file =>\n    for {\n      data    <- decodeData(file)\n      grouped <- groupData(data)\n    } yield grouped\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Logging with Context\nDESCRIPTION: A complete example that demonstrates ZIO Logging with the Logger Context feature. It shows how to configure a custom console logger and propagate context (user IDs) across fibers in a concurrent environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.clock.Clock\nimport zio.duration.durationInt\nimport zio.logging._\nimport zio.random.Random\nimport zio.{ExitCode, NonEmptyChunk, ZIO}\n\nobject ZIOLoggingExample extends zio.App {\n\n  val myApp: ZIO[Logging with Clock with Random, Nothing, Unit] =\n    for {\n      _ <- log.info(\"Hello from ZIO logger\")\n      _ <-\n        ZIO.foreachPar(NonEmptyChunk(\"UserA\", \"UserB\", \"UserC\")) { user =>\n          log.locally(UserId(Some(user))) {\n            for {\n              _ <- log.info(\"User validation\")\n              _ <- zio.random\n                .nextIntBounded(1000)\n                .flatMap(t => ZIO.sleep(t.millis))\n              _ <- log.info(\"Connecting to the database\")\n              _ <- zio.random\n                .nextIntBounded(100)\n                .flatMap(t => ZIO.sleep(t.millis))\n              _ <- log.info(\"Releasing resources.\")\n            } yield ()\n          }\n\n        }\n    } yield ()\n\n  type UserId = String\n  def UserId: LogAnnotation[Option[UserId]] = LogAnnotation[Option[UserId]](\n    name = \"user-id\",\n    initialValue = None,\n    combine = (_, r) => r,\n    render = _.map(userId => s\"[user-id: $userId]\")\n      .getOrElse(\"undefined-user-id\")\n  )\n\n  val env =\n    Logging.console(\n      logLevel = LogLevel.Info,\n      format =\n        LogFormat.ColoredLogFormat((ctx, line) => s\"${ctx(UserId)} $line\")\n    ) >>> Logging.withRootLoggerName(\"MyZIOApp\")\n\n  override def run(args: List[String]) =\n    myApp.provideCustomLayer(env).as(ExitCode.success)\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Running ZIO Effects using Runtime.default (Scala)\nDESCRIPTION: Shows how to execute ZIO effects when not using `zio.App`, typically for integration into existing applications or frameworks. It involves obtaining the default ZIO runtime (`Runtime.default`) and using its `unsafeRun` method to execute a ZIO `Task` (or any ZIO effect). It's advised to maintain a single runtime instance throughout the application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/getting_started.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject IntegrationExample {\n  val runtime = Runtime.default\n\n  runtime.unsafeRun(Task(println(\"Hello World!\")))\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Stream Processing with ZIO Stream\nDESCRIPTION: Demonstrates basic stream processing by creating a stream from an iterable range and printing each element. Uses ZStream.fromIterable with foreach for iteration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/consuming-streams.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Console._\nimport zio.stream._\n\nval result: Task[Unit] = ZStream.fromIterable(0 to 100).foreach(printLine(_))\n```\n\n----------------------------------------\n\nTITLE: Implementing Complete File Reading with AcquireRelease\nDESCRIPTION: Full working example of using acquireReleaseWith to safely read and process file contents.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.{ File, FileInputStream }\nimport java.nio.charset.StandardCharsets\n\nobject Main extends ZIOAppDefault {\n\n  // run my acquire release\n  def run = myAcquireRelease\n\n  def closeStream(is: FileInputStream) =\n    ZIO.succeed(is.close())\n\n  def convertBytes(is: FileInputStream, len: Long) =\n    ZIO.attempt {\n      val buffer = new Array[Byte](len.toInt)\n      is.read(buffer)\n      println(new String(buffer, StandardCharsets.UTF_8))\n    }\n\n  // myAcquireRelease is just a value. Won't execute anything here until interpreted\n  val myAcquireRelease: Task[Unit] = for {\n    file   <- ZIO.attempt(new File(\"/tmp/hello\"))\n    len    = file.length\n    string <- ZIO.acquireReleaseWith(ZIO.attempt(new FileInputStream(file)))(closeStream)(convertBytes(_, len))\n  } yield string\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Service Interface for Mocking in ZIO (Scala)\nDESCRIPTION: This snippet showcases a typical service interface definition for use with ZIO's mock framework. It includes various types of methods (zero args, multiple args, overloads, and effectful/noneffectful returns) and type aliases for service modules. Requires: zio.stream, zio.test.mock, and ZIO libraries. Inputs: Vary based on methods. Outputs: UIO, ZStream, ZSink as appropriate. Used as the real or mocked target in the ZIO environment for dependency injection and testing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n// main sources\n\nimport zio.stream.{ ZSink, ZStream }\nimport zio.test.mock._\n\ntype Example = Has[Example.Service]\n\nobject Example {\n  trait Service {\n    val static                                 : UIO[String]\n    def zeroArgs                               : UIO[Int]\n    def zeroArgsWithParens()                   : UIO[Long]\n    def singleArg(arg1: Int)                   : UIO[String]\n    def multiArgs(arg1: Int, arg2: Long)       : UIO[String]\n    def multiParamLists(arg1: Int)(arg2: Long) : UIO[String]\n    def command(arg1: Int)                     : UIO[Unit]\n    def overloaded(arg1: Int)                  : UIO[String]\n    def overloaded(arg1: Long)                 : UIO[String]\n    def function(arg1: Int)                    : String\n    def sink(a: Int)                           : ZSink[Any, String, Int, Int, List[Int]]\n    def stream(a: Int)                         : ZStream[Any, String, Int]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Recovering from Specific Errors with catchSome in ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#catchSome to recover from specific failure types. The example demonstrates handling a specific error message by switching to an alternative stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3) ++ ZStream.fail(\"Oh! Error!\") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\nval stream = s1.catchSome {\n  case \"Oh! Error!\" => s2\n}\n// Output: 1, 2, 3, 7, 8, 9\n```\n\n----------------------------------------\n\nTITLE: Replacing Service Implementation without Changing Application Logic\nDESCRIPTION: Demonstrates how to replace the implementation of service A with a custom version. The application logic remains unchanged while a different implementation is injected through layers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfinal case class ACustom() extends A {\n  def foo = ZIO.succeed(84)\n}\n\nobject ACustom {\n  val layer: ZLayer[Any, Nothing, A] = ZLayer.succeed(ACustom())\n}\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(\n    ACustom.layer,\n    BLive.layer,\n    CLive.layer\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Domain Errors with ZIO.fail in Scala\nDESCRIPTION: Defines a custom exception `NegativeNumberException` and a validation function `validateNonNegative`. This function returns a `ZIO` effect that either succeeds with the input integer if it's non-negative or fails with a `NegativeNumberException` using `ZIO.fail` if the input is negative. This demonstrates type-safe, domain-specific error handling in ZIO. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/failures.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class NegativeNumberException(msg: String) extends Exception(msg)\n\ndef validateNonNegative(input: Int): ZIO[Any, NegativeNumberException, Int] =\n  if (input < 0)\n    ZIO.fail(NegativeNumberException(s\"entered negative number: $input\"))\n  else\n    ZIO.succeed(input)\n```\n\n----------------------------------------\n\nTITLE: Implementing Concurrent State Management with ZIO Ref\nDESCRIPTION: Shows how to manage concurrent state in ZIO using the Ref data type, which provides safe concurrent access to mutable state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Counter(state: Ref[Int]) {\n  def inc = state.update(_ + 1)\n  def dec = state.update(_ - 1)\n  def get = state.get\n}\n\nobject Counter {\n  def make = Ref.make(0).map(Counter(_))\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      c <- Counter.make\n      _ <- c.inc <&> c.inc <&> c.inc <&> c.dec\n      _ <- c.get.debug(\"The current value of the counter\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Loom-Based Blocking Executor in ZIO Runtime via Bootstrap Layer (Scala)\nDESCRIPTION: This snippet shows how to configure the ZIO runtime to use Java virtual threads (Project Loom) specifically for its blocking executor. It overrides the `bootstrap` layer in `ZIOAppDefault` with `Runtime.enableLoomBasedBlockingExecutor`. The example executes a blocking task using `ZIO.attemptBlocking` and prints the thread name to confirm it's running on a virtual thread designed for blocking operations. Requires JDK 21+.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  override val bootstrap = \n    Runtime.enableLoomBasedBlockingExecutor\n\n  override def run = ZIO.attemptBlocking {\n    println(s\"Blocking task running on a virtual-thread: ${Thread.currentThread().getName()}\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Finalizing Effects with ZIO Ensuring in Scala\nDESCRIPTION: This snippet demonstrates ZIO's '.ensuring' method, which provides try/finally-style finalization for effects. The finalizer must not fail, and ensures that cleanup logic runs when the effect completes, even if an error or interruption occurs. Dependencies include the ZIO library, and the main parameters are the effect to protect and the finalizer. The example shows how a failed IO still runs its finalizer, with no return value expected from the finalizer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_resources.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval finalizer = \n  UIO.effectTotal(println(\"Finalizing!\"))\n// finalizer: UIO[Unit] = zio.ZIO$EffectTotal@65ccae4c\n\nval finalized: IO[String, Unit] = \n  IO.fail(\"Failed!\").ensuring(finalizer)\n// finalized: IO[String, Unit] = zio.ZIO$CheckInterrupt@5071b0bd\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZIO Test for Console Output in Scala\nDESCRIPTION: This snippet shows a complete ZIO test implementation. It tests a sayHello function that prints to the console, demonstrating how to use TestConsole to capture and assert on console output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/writing-our-first-test.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\nimport zio.test.Assertion._\n\nimport java.io.IOException\n\nimport HelloWorld._\n\nobject HelloWorld {\n  def sayHello: ZIO[Any, IOException, Unit] =\n    Console.printLine(\"Hello, World!\")\n}\n\nobject HelloWorldSpec extends ZIOSpecDefault {\n  def spec = suite(\"HelloWorldSpec\")(\n    test(\"sayHello correctly displays output\") {\n      for {\n        _      <- sayHello\n        output <- TestConsole.output\n      } yield assertTrue(output == Vector(\"Hello, World!\\n\"))\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Standalone ZIO Application with zio.App in Scala\nDESCRIPTION: Demonstrates how to create a complete, runnable ZIO application by extending `zio.App`. The `run` method serves as the entry point, receiving command-line arguments (`args: List[String]`) and returning an effect (`myAppLogic`) whose exit code determines the application's status. This example defines `myAppLogic` as a simple console interaction using `putStrLn` and `getStrLn` from `zio.console`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/running_effects.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nimport zio._\nimport zio.console._\n\nobject MyApp extends zio.App {\n\n  def run(args: List[String]) =\n    myAppLogic.exitCode\n\n  val myAppLogic =\n    for {\n      _    <- putStrLn(\"Hello! What is your name?\")\n      name <- getStrLn\n      _    <- putStrLn(s\"Hello, ${name}, welcome to ZIO!\")\n    } yield ()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using ZLayer.succeed to Create Simple Layers (Scala)\nDESCRIPTION: Demonstrates usage of ZLayer.succeed for constructing a ZLayer from a simple case class value. Requires the zio library and relevant service definitions. Input is typically a configuration or value, output is a type-safe ULayer. No resource management or side effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval configLayer: ULayer[AppConfig] = ZLayer.succeed(AppConfig(\"localhost\", 8080))\n```\n\n----------------------------------------\n\nTITLE: Serving Combined HTTP Route Modules with ZIO HTTP (Scala)\nDESCRIPTION: Starts an HTTP server that serves the combined routes of multiple modules by concatenating their respective Routes using the ++ operator. This enables modular and extensible HTTP application structure. Requires all referenced route modules to return valid Routes, and Server.default must be provided. The outcome is a running HTTP server handling multiple logical route groupings.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.http._\\n\\nServer.serve(\\n  GreetingRoutes() ++ DownloadRoutes() ++ CounterRoutes() ++ UserRoutes()\\n).provide(Server.default)\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#orElse for Primary/Backup Fallback in Scala\nDESCRIPTION: This example demonstrates the `orElse` combinator. It attempts to execute `readFile(\"primary.data\")`. If this effect fails (e.g., with an `IOException`), the effect defined by `readFile(\"backup.data\")` is executed instead. The resulting `primaryOrBackupData` effect will succeed with the bytes from the first successful read or fail if both reads fail.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.IOException\n\nval primaryOrBackupData: ZIO[Any, IOException, Array[Byte]] =\n  readFile(\"primary.data\").orElse(readFile(\"backup.data\"))\n```\n\n----------------------------------------\n\nTITLE: Creating ZLayer from AutoCloseable Resource\nDESCRIPTION: Example of creating a ZLayer from an AutoCloseable resource (BufferedSource) using ZLayer.scoped.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.io.BufferedSource\n\nval fileLayer: ZLayer[Any, Throwable, BufferedSource] =\n  ZLayer.scoped {\n    ZIO.fromAutoCloseable(\n      ZIO.attemptBlocking(scala.io.Source.fromFile(\"file.txt\"))\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Combining ZLayers in Scala ZIO\nDESCRIPTION: Example of combining multiple ZLayers to create a composite layer that provides multiple services. This demonstrates horizontal composition of layers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval myLayer: ZLayer[Any, Nothing, Has[Logging] with Has[RandomInt]] = \n    LoggingLive.layer ++ RandomIntLive.layer\n```\n\n----------------------------------------\n\nTITLE: Using NIO CompletionHandler with ZIO\nDESCRIPTION: Complex example showing how to read a file asynchronously using NIO CompletionHandler with ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-java.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef readFile(file: AsynchronousFileChannel): Task[Chunk[Byte]] = for {\n    pos <- Ref.make(0)\n    buf <- ZIO.succeed(ByteBuffer.allocate(1024))\n    contents <- Ref.make[Chunk[Byte]](Chunk.empty)\n    def go = pos.get.flatMap { p =>\n        ZIO.asyncWithCompletionHandler[Chunk[Byte]] { handler =>\n            file.read(buf, p, buf, handler)\n        }.flatMap {\n            case -1 => contents.get\n            case n  =>\n                ZIO.succeed {\n                    val arr = Array.ofDim[Byte](n)\n                    buf.get(arr, 0, n)\n                    buf.clear()\n                    Chunk.fromArray(arr)\n                }.flatMap { slice =>\n                    contents.update(_ ++ slice)\n                } *> pos.update(_ + n) *> go\n        }\n    }\n    dump <- go\n} yield dump\n```\n\n----------------------------------------\n\nTITLE: ZRefM Type Definition and Operations\nDESCRIPTION: Demonstrates the type signature ZRefM[RA, RB, EA, EB, A, B] which represents a polymorphic mutable reference with environment types RA and RB, error types EA and EB, and value types A and B. The reference supports set and get operations, with atomic modify and update operations available when error and value types are unified.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/zrefm.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nZRefM[RA, RB, EA, EB, A, B]\n```\n\n----------------------------------------\n\nTITLE: Composing ZIO Effects Sequentially\nDESCRIPTION: Demonstrates sequential composition of ZIO effects requiring multiple services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[A with B, Nothing, (String, Int)] =\n  for {\n    a <- A.foo\n    b <- B.bar\n  } yield (a, b)\n```\n\n----------------------------------------\n\nTITLE: Converting Future to ZIO Effect with ZIO.fromFuture - Scala\nDESCRIPTION: Shows how to safely bridge a Scala Future into a ZIO Task using ZIO.fromFuture. The provided lambda receives the ZIO-managed ExecutionContext and transforms a sample successful Future. Outcome is a Task effect resolving to a String; eg, \"Goodbye!\". Requires scala.concurrent.Future and ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.Future\n\nlazy val future = Future.successful(\"Hello!\")\n\nval zfuture: Task[String] =\n  ZIO.fromFuture { implicit ec =>\n    future.map(_ => \"Goodbye!\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating Custom JSON Serializer for Event with Serde.inmapZIO in Scala\nDESCRIPTION: Implements a Kafka serializer/deserializer for the Event class using zio-kafka's Serde.string.inmapZIO combinator. This effectful transformation handles JSON parsing and serialization with proper error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.kafka.serde._\n\nobject EventKafkaSerde {\n  val event: Serde[Any, Event] =\n    Serde.string.inmapZIO[Any, Event](s =>\n      ZIO\n        .fromEither(s.fromJson[Event])\n        .mapError(e => new RuntimeException(e))\n    )(r => ZIO.succeed(r.toJson))\n}\n```\n\n----------------------------------------\n\nTITLE: Retrying ZIO Effects with Fallback\nDESCRIPTION: Demonstrates the use of retryOrElse in ZIO, which allows specifying a retry schedule and a fallback to use if the effect does not succeed within the specified policy.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval retryOpenFile: ZIO[Any, IOException, DefaultData) = \n  openFile(\"primary.data\")\n      .retryOrElse(Schedule.recurs(5), (_, _) => ZIO.succeed(DefaultData))\n```\n\n----------------------------------------\n\nTITLE: ZIO Multiple Log Levels Example\nDESCRIPTION: Demonstrates using different log levels in ZIO including Fatal, Error, Warning, Info, Debug, and Trace\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      _ <- ZIO.logFatal(\"Fatal\")\n      _ <- ZIO.logError(\"Error\")\n      _ <- ZIO.logWarning(\"Warning\")\n      _ <- ZIO.logInfo(\"Info\")\n      _ <- ZIO.logDebug(\"Debug\")\n      _ <- ZIO.logTrace(\"Trace\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Exposing and Debugging the Cause of Failure in a ZIO Application - Scala\nDESCRIPTION: This snippet is a ZIO application demonstrating how to combine two failing ZIO effects and extract their causes using the cause operator. f1 and f2 are defined as failures, combined in parallel, and then myApp.cause exposes the combined failure's Cause, which is made untraced and printed via debug. Required dependencies are the zio library and ZIOAppDefault for application entrypoint. Inputs are synthetic failures, and the output is a debug print of the Cause. This showcases how to inspect error structure at runtime in an idiomatic ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-the-cause-in-the-succcess-channel.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1: ZIO[Any, String, Int] =\n    ZIO.fail(\"Oh uh!\").as(1)\n\n  val f2: ZIO[Any, String, Int] =\n    ZIO.fail(\"Oh error!\").as(2)\n\n  val myApp: ZIO[Any, String, (Int, Int)] = f1 zipPar f2\n\n  def run = myApp.cause.map(_.untraced).debug\n}\n```\n\n----------------------------------------\n\nTITLE: Composition of ZIO Option Effects with For-Comprehension - Scala\nDESCRIPTION: Illustrates composing multiple Option-based ZIO effects to retrieve a User and Team by chained, optional lookups. For-comprehension is used along with .some, .asSomeError, and .optional to encapsulate optionality through the monadic flow. Dependencies include zoption, getUser, getTeam. Inputs are Option[String] and effectful functions; output is an IO encapsulating a tuple Option[(User, Team)].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval maybeId: IO[Option[Nothing], String] = ZIO.fromOption(Some(\"abc123\"))\ndef getUser(userId: String): IO[Throwable, Option[User]] = ???\ndef getTeam(teamId: String): IO[Throwable, Team] = ???\n\nval result: IO[Throwable, Option[(User, Team)]] = (for {\n  id   <- maybeId\n  user <- getUser(id).some\n  team <- getTeam(user.teamId).asSomeError \n} yield (user, team)).optional \n```\n\n----------------------------------------\n\nTITLE: Creating Time-bounded Exponential Backoff Schedule in ZIO\nDESCRIPTION: Creates a schedule that applies exponential backoff but stops retrying after a specified total elapsed time. The schedule starts with 10 milliseconds delay and continues until the total elapsed time reaches 30 seconds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/examples.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval expMaxElapsed = (Schedule.exponential(10.milliseconds) >>> Schedule.elapsed).whileOutput(_ < 30.seconds)\n```\n\n----------------------------------------\n\nTITLE: Fallback Recovery after Failure Using catchAll - Scala\nDESCRIPTION: This snippet demonstrates using the catchAll combinator to provide a fallback file read operation. If reading the primary file fails for any typed error, the fallback gives another file. Relies on the readFile method and ZIO error handling, returning a ZIO effect that attempts both reads in sequence as needed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval z: ZIO[Any, IOException, Array[Byte]] =\n  readFile(\"primary.json\").catchAll(_ =>\n    readFile(\"backup.json\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Empty Route Modules for Composition (Scala)\nDESCRIPTION: Demonstrates the initialization of multiple empty Routes modules (GreetingRoutes, DownloadRoutes, CounterRoutes, UserRoutes), enabling modular composition. Each object returns an empty Routes value, providing a template structure for further route expansion. No incoming requests are handled unless routes are defined; this pattern is useful for scaffolding HTTP APIs using zio-http.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.http._\\n\\nobject GreetingRoutes {\\n  def apply() = Routes.empty\\n}\\n\\nobject DownloadRoutes {\\n  def apply() = Routes.empty\\n}\\n\\nobject CounterRoutes {\\n  def apply() = Routes.empty\\n}\\n\\nobject UserRoutes {\\n  def apply() = Routes.empty\\n}\n```\n\n----------------------------------------\n\nTITLE: Atomic Money Transfer Using STM\nDESCRIPTION: Thread-safe implementation of money transfer using STM to ensure atomic composition of withdraw and deposit operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(from: TRef[Int], to: TRef[Int], amount: Int): IO[String, Unit] =\n  STM.atomically {\n    for {\n      _ <- withdraw(from, amount)\n      _ <- deposit(to, amount)\n    } yield ()\n  }\n```\n\n----------------------------------------\n\nTITLE: Effectful Configuration within ZIO Bootstrap Layer in Scala\nDESCRIPTION: This snippet shows how to include effectful operations within the `bootstrap` layer for runtime configuration. It adds a custom logger and an additional layer (`effectfulConfiguration`) that logs a message during its initialization. The `bootstrap` layer combines removing default loggers, adding the simple logger, and the effectful configuration layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val addSimpleLogger: ZLayer[Any, Nothing, Unit] =\n    Runtime.addLogger((_, _, _, message: () => Any, _, _, _, _) => println(message()))\n  \n  val effectfulConfiguration: ZLayer[Any, Nothing, Unit] =\n    ZLayer.fromZIO(ZIO.log(\"Started effectful workflow to customize runtime configuration\"))\n\n  override val bootstrap: ZLayer[Any, Nothing, Unit] =\n    Runtime.removeDefaultLoggers ++ addSimpleLogger ++ effectfulConfiguration\n\n  def run =\n    for {\n      _ <- ZIO.log(\"Application started!\")\n      _ <- ZIO.log(\"Application is about to exit!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZIO Timer Metric for Workflow Duration Tracking in Scala\nDESCRIPTION: Provides a complete ZIO application example demonstrating a timer metric. It defines a simple `workflow`, a `randomDelay` effect, and creates a `timer` metric with millisecond precision and 10 buckets (1.0ms to 10.0ms). The `timer.trackDuration` aspect is applied to the combined `workflow <* randomDelay` effect to measure its execution time. The entire process is repeated 100 times. Depends on `zio`, `zio.metrics`, and `java.time.temporal.ChronoUnit`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/histogram.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.metrics._\n\nimport java.time.temporal.ChronoUnit\n\nobject Example extends ZIOAppDefault {\n\n  def workflow = ZIO.succeed(42)\n\n  def randomDelay =\n    for {\n      i <- Random.nextLongBetween(1L, 10)\n      _ <- ZIO.sleep(Duration.fromMillis(i))\n    } yield ()\n    \n  val timer =\n    Metric.timer(\n      name = \"timer\",\n      chronoUnit = ChronoUnit.MILLIS,\n      boundaries = Chunk.iterate(1.0, 10)(_ + 1.0)\n    )\n\n  val run = ((workflow <* randomDelay) @@ timer.trackDuration).repeatN(99)\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Input Safely Using ZIO.attempt - Scala\nDESCRIPTION: Demonstrates parsing user input to Int inside a ZIO effect using ZIO.attempt. Converts a String to Int, catching and typing exceptions via ZIO's error channel. Dependency is the zio library. Input is a String, output is a ZIO effect yielding Int or Throwable. No direct user interaction; intended as a helper function for safe input parsing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/examples.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\ndef parseInput(input: String): ZIO[Any, Throwable, Int] =\\n  ZIO.attempt(input.toInt)\n```\n\n----------------------------------------\n\nTITLE: Transforming ZIO Effect Values with map\nDESCRIPTION: Demonstrates transforming a ZIO effect's success value using the map method. This allows changing the type of value produced by an effect without changing its error type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval mappedValue: UIO[Int] = ZIO.succeed(21).map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Ignoring Errors and Results Using fold - Scala\nDESCRIPTION: Shows how to ignore both error and success results of a ZIO effect using fold, mapping both cases to Unit. The code first fails, transforms the value, and then discards all results via fold. This is a standard approach to create ZIO effects where only the completion status is important. Uses no external dependencies beyond zio.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval result: ZIO[Any, Nothing, Unit] =\n  ZIO\n    .fail(\"Uh oh!\")         // ZIO[Any, String, Int]\n    .as(5)                  // ZIO[Any, String, Int]\n    .fold(_ => (), _ => ()) // ZIO[Any, Nothing, Unit]\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic Service Interface in Scala\nDESCRIPTION: Defines a polymorphic KeyValueStore trait with type parameters for key type (K), value type (V), error type (E), and effect type (F). This interface declares methods for getting, setting, and removing key-value pairs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait KeyValueStore[K, V, E, F[_, _]] {\n  def get(key: K): F[E, V]\n\n  def set(key: K, value: V): F[E, V]\n\n  def remove(key: K): F[E, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Automatically Generating ZIO Dependency Graph\nDESCRIPTION: Demonstrates how to let ZIO automatically create the dependency graph based on provided layers. This approach simplifies the configuration process by allowing ZIO to handle the dependencies internally.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/examples.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def run =\n    myApp.provide(\n      InmemoryCache.layer,\n      DatabaseLive.layer,\n      UserRepoLive.layer,\n      BlobStorageLive.layer,\n      DocumentRepoLive.layer\n    )\n    \n}\n```\n\n----------------------------------------\n\nTITLE: ZIO AMQP Producer-Consumer Example\nDESCRIPTION: Complete example demonstrating how to create a connection, channel, and implement both producer and consumer patterns using ZIO AMQP. The producer publishes UUIDs to an exchange while the consumer reads from a queue and acknowledges messages.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-amqp.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport nl.vroste.zio.amqp._\nimport nl.vroste.zio.amqp.model._\nimport zio._\n\nimport java.net.URI\n\nobject ZIOAMQPExample extends ZIOAppDefault {\n\n  val channel: ZIO[Scope, Throwable, Channel] = for {\n    connection <- Amqp.connect(URI.create(\"amqp://localhost:5672\"))\n    channel    <- Amqp.createChannel(connection)\n  } yield channel\n\n  val myApp: ZIO[Any, Throwable, Unit] =\n    ZIO.scoped {\n      for {\n        channel                            <- channel\n        producer: ZIO[Any, Throwable, Long] =\n          Random.nextUUID\n            .flatMap(uuid => channel.publish(ExchangeName(\"my_exchange\"), uuid.toString.getBytes).unit)\n            .schedule(Schedule.spaced(1.seconds))\n\n        consumer: ZIO[Any, Throwable, Unit] =\n          channel\n            .consume(queue = QueueName(\"my_queue\"), consumerTag = ConsumerTag(\"my_consumer\"))\n            .mapZIO { record =>\n              val deliveryTag = record.getEnvelope.getDeliveryTag\n              Console.printLine(s\"Received $deliveryTag: ${new String(record.getBody)}\") *>\n                channel.ack(DeliveryTag(deliveryTag))\n            }\n            .runDrain\n        p                                  <- producer.fork\n        c                                  <- consumer.fork\n        _                                  <- p.zip(c).join\n      } yield ()\n    }\n\n  override def run: ZIO[Environment with ZIOAppArgs with Scope, Any, Any] = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking Multiple Collaborating Services\nDESCRIPTION: Shows how to create a composite mock environment that simulates multiple services working together. This example combines Console and Random services to test an interactive application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console.Console\nimport zio.random.Random\nimport zio.test.mock.MockRandom\n\nval combinedEnv: ULayer[Console with Random] = (\n  MockConsole.PutStrLn(equalTo(\"What is your name?\")) ++\n  MockConsole.GetStrLn(value(\"Mike\")) ++\n  MockRandom.NextInt(value(42)) ++\n  MockConsole.PutStrLn(equalTo(\"Mike, your lucky number today is 42!\"))\n)\n\nval combinedApp =\n  for {\n    _    <- console.putStrLn(\"What is your name?\")\n    name <- console.getStrLn.orDie\n    num  <- random.nextInt\n    _    <- console.putStrLn(s\"$name, your lucky number today is $num!\")\n  } yield ()\n\nval result = combinedApp.provideLayer(combinedEnv)\nassertM(result)(isUnit)\n```\n\n----------------------------------------\n\nTITLE: Retrying Failed Tests with Schedule in ZIO Test (Scala)\nDESCRIPTION: This code shows how to use the 'retry' test aspect in ZIO Test. It retries a failing test based on a provided schedule. The example uses Schedule.recurs(5) to retry the test up to 5 times until it succeeds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/repeat-and-retry.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\ntest(\"retrying a failing test based on the schedule until it succeeds\") {\n  ZIO.debug(\"retrying a failing test\")\n    .map(_ => assertTrue(true))\n} @@ TestAspect.retry(Schedule.recurs(5))\n```\n\n----------------------------------------\n\nTITLE: Defining AppConfig Service with Multiple Layer Implementations in ZIO Scala\nDESCRIPTION: Defines an `AppConfig` service trait and two `ZLayer` implementations in Scala using ZIO. `appArgsLayer` reads configuration from command-line arguments, while `systemEnvLayer` reads from environment variables. The `MainApp` demonstrates consuming the `AppConfig` service and injecting the `appArgsLayer` using `provideSome`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(poolSize: Int)\n\nobject AppConfig {\n  def poolSize: ZIO[AppConfig, Nothing, Int] =\n    ZIO.serviceWith[AppConfig](_.poolSize)\n\n  val appArgsLayer: ZLayer[ZIOAppArgs, Nothing, AppConfig] =\n    ZLayer {\n      ZIOAppArgs.getArgs\n        .map(_.headOption.map(_.toInt).getOrElse(8))\n        .map(poolSize => AppConfig(poolSize))\n    }\n\n  val systemEnvLayer: ZLayer[Any, SecurityException, AppConfig] =\n    ZLayer.fromZIO(\n      System\n        .env(\"POOL_SIZE\")\n        .map(_.headOption.map(_.toInt).getOrElse(8))\n        .map(poolSize => AppConfig(poolSize))\n    )\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[AppConfig, Nothing, Unit] =\n    for {\n      poolSize <- AppConfig.poolSize\n      _        <- ZIO.debug(s\"Application started with $poolSize pool size.\")\n    } yield ()\n\n  def run = myApp.provideSome[ZIOAppArgs](AppConfig.appArgsLayer)\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Kubernetes Cluster and Listing Nodes with ZIO\nDESCRIPTION: Example of using Scala k8s with ZIO to create a Kubernetes client and list nodes in the cluster. Uses kubectl proxy for simplified authentication.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/scala-k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport dev.hnaderi.k8s.client.APIs\nimport dev.hnaderi.k8s.client.ZIOKubernetesClient\n\n// This example uses `kubectl proxy` to simplify authentication\nval client = ZIOKubernetesClient.make(\"http://localhost:8001\")\nval nodes = ZIOKubernetesClient.send(APIs.nodes.list())\n```\n\n----------------------------------------\n\nTITLE: Implementing Map Differ Example\nDESCRIPTION: Example showing how to implement a Differ for Map[String, Int] using ZIO's built-in utilities. Demonstrates diffing, combining patches, and applying patches to values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval differ   = Differ.map[String, Int, Int => Int](Differ.update[Int])\nval patch1   = differ.diff(Map(\"retries\" -> 3), Map(\"retries\" -> 5))\nval patch2   = differ.diff(Map(\"intervals\" -> 2), Map(\"intervals\" -> 3))\nval combined = differ.combine(patch1, patch2)\nval result   = differ.patch(combined)(Map(\"retries\" -> 3, \"intervals\" -> 2))\nprintln(result)\n```\n\n----------------------------------------\n\nTITLE: Parallel Processing with Automatic Cancellation in Scala using ZIO\nDESCRIPTION: Illustrates parallel processing of multiple statements with ZIO, where failure in one task automatically cancels all other running tasks. This ensures efficient resource usage and error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval aggregated =\n  ZIO.foreach(account.statements) { statement =>\n    downloadStatement(statement.s3Bucket) \n  }.map(aggregateStatements(_))\n```\n\n----------------------------------------\n\nTITLE: Using flatMap to Combine API Results into a Single Stream\nDESCRIPTION: This snippet demonstrates using flatMap to convert a stream of author names into a stream of books by concatenating the results of multiple API calls to getAuthorBooks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nval authors: ZStream[Any, Throwable, String] = \n  ZStream(\"Mary\", \"James\", \"Robert\", \"Patricia\", \"John\")\nval allBooks: ZStream[Any, Throwable, Book]  = \n  authors.flatMap(getAuthorBooks _)\n```\n\n----------------------------------------\n\nTITLE: Complete ZIO Layer Implementation Example\nDESCRIPTION: Shows full implementation of services using ZIO layers, including Formatter, Compiler, Counter, and Editor services with proper dependency management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ntrait Formatter {\n  def format(code: String): UIO[String]\n}\n\ncase class ScalaFormatter() extends Formatter {\n  def format(code: String): UIO[String] = \n    ZIO.succeed(code) // dummy implementation\n}\n\nobject ScalaFormatter {\n  val layer: ULayer[Formatter] = ZLayer.succeed(ScalaFormatter())\n}\n\ntrait Compiler {\n  def compile(code: String): UIO[String]\n}\n\ncase class ScalaCompiler() extends Compiler {\n  def compile(code: String): UIO[String] = ZIO.succeed(code)\n}\nobject ScalaCompiler {\n  val layer = ZLayer.succeed(ScalaCompiler())\n}\n\ntrait Editor {\n  def formatAndCompile(code: String): UIO[String]\n}\n\ntrait Counter {\n  def inc: UIO[Unit]\n  def dec: UIO[Unit]\n  def get: UIO[Int]\n}\n\ncase class CounterLive(ref: Ref[Int]) extends Counter {\n  def inc: UIO[Unit] = ref.update(_ + 1)\n  def dec: UIO[Unit] = ref.update(_ - 1)\n  def get: UIO[Int]  = ref.get\n}\n\nobject CounterLive {\n  // Effectful constructor\n  def make: UIO[Counter] = Ref.make(0).map(new CounterLive(_))\n\n  val layer: ULayer[Counter] = ZLayer.fromZIO(CounterLive.make)\n}\n\ncase class EditorLive(\n    formatter: Formatter,\n    compiler: Compiler,\n    counter: Counter\n) extends Editor {\n  def formatAndCompile(code: String): UIO[String] = ???\n}\n\nobject EditorLive {\n  val layer: ZLayer[Counter with Compiler with Formatter, Nothing, Editor] =\n    ZLayer {\n      for {\n        // we will discuss ZIO.service later\n        formatter <- ZIO.service[Formatter] \n        compiler  <- ZIO.service[Compiler]\n        counter   <- ZIO.service[Counter]\n      } yield EditorLive(formatter, compiler, counter)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val environment =\n    ((ScalaFormatter.layer ++ ScalaCompiler.layer ++ CounterLive.layer) >>> EditorLive.layer).build\n\n  def run =\n    for {\n      editor <- environment.map(_.get[Editor])\n      _      <- editor.formatAndCompile(\"println(\\\"Hello, world!\\\")\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Command-Line Arguments in a ZIOAppDefault Scala Application\nDESCRIPTION: This example shows how to access command-line arguments within a ZIO application extending `ZIOAppDefault`. It utilizes the built-in `getArgs` method (which returns a `ZIO[ZIOAppArgs, Nothing, Chunk[String]]`) to retrieve the arguments passed to the application. The code then checks if any arguments were provided and prints a corresponding message to the console. It depends on the `zio` library, including `ZIOAppDefault`, `ZIO`, `Console`, and the implicit `ZIOAppArgs` service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zioapp.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject HelloApp extends ZIOAppDefault {\n  def run = for {\n    args <- getArgs\n    _ <-\n      if (args.isEmpty)\n        Console.printLine(\"Please provide your name as an argument\")\n      else\n        Console.printLine(s\"Hello, ${args.head}!\")\n  } yield ()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declarative Dependency Resolution in ZIO\nDESCRIPTION: Demonstrates declarative dependency resolution using ZIO's R type parameter and service pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval workflow: ZIO[Compiler with Formatter, Nothing, String] =\n for {\n   f  <- ZIO.service[Formatter] \n   r1 <- f.format(\"println(\\\"Hello, world!\\\")\")\n   c  <- ZIO.service[Compiler]\n   r1 <- c.compile(r1)\n } yield r1\n```\n\n----------------------------------------\n\nTITLE: Reading Parquet file with ZparkIO and ZIO\nDESCRIPTION: This example demonstrates how to use ZparkIO to read a Parquet file in a Spark job. It showcases ZIO features like retrying, timing out, and integrating with Spark's DataFrame API. The function is designed to be used within a ZIO environment that provides Clock and SparkModule.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zparkio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport com.leobenkel.zparkio.Services.SparkModule\nimport com.leobenkel.zparkio.Services.SparkModule.SparkModule\nimport com.leobenkel.zparkio.ZparkioApplicationTimeoutException\nimport org.apache.spark.sql.DataFrame\nimport zio.clock.Clock\nimport zio.duration.durationInt\nimport zio.{Schedule, Task, ZIO}\n\ndef readParquetFile[A](parquetPath: String): ZIO[Clock with SparkModule, Throwable, DataFrame] =\n  for {\n    spark <- SparkModule()\n    dataset <- Task(spark.read.parquet(parquetPath))\n      .retry(\n        Schedule.recurs(3) && Schedule.exponential(2.seconds)\n      )\n      .timeoutFail(ZparkioApplicationTimeoutException())(5.minutes)\n  } yield dataset\n```\n\n----------------------------------------\n\nTITLE: Propagating Parent Fiber Interruption to Children in ZIO (Scala)\nDESCRIPTION: This snippet shows how interrupting a parent fiber in ZIO leads to automatic interruption of all its child fibers. The ZIOAppDefault application spawns two child fibers (random number and random boolean printers) with scheduled repeated effects, and both are set up with onInterrupt hooks for debug logging. The parent fiber is later interrupted, and each child's interruption event is observed and logged for traceability. ZIO, Schedule, and Random modules must be available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\nobject MainApp extends ZIOAppDefault {\\n\\n  def debugInterruption(taskName: String) = (fibers: Set[FiberId]) =>\\n    for {\\n      fn <- ZIO.fiberId.map(_.threadName)\\n      _ <- ZIO.debug(\\n        s\"The $fn fiber which is the underlying fiber of the $taskName task \" +\\n          s\"interrupted by ${fibers.map(_.threadName).mkString(\", \")}\"\\n      )\\n    } yield ()\\n\\n  def task =\\n    for {\\n      fn <- ZIO.fiberId.map(_.threadName)\\n      _ <- ZIO.debug(s\"$fn starts running that will print random numbers and booleans\")\\n      f1 <- Random.nextIntBounded(100)\\n        .debug(\"random number \")\\n        .schedule(Schedule.spaced(1.second).forever)\\n        .onInterrupt(debugInterruption(\"random number\"))\\n        .fork\\n      f2 <- Random.nextBoolean\\n        .debug(\"random boolean \")\\n        .schedule(Schedule.spaced(2.second).forever)\\n        .onInterrupt(debugInterruption(\"random boolean\"))\\n        .fork\\n        _ <- f1.join\\n        _ <- f2.join\\n    } yield ()\\n\\n  def run =\\n    for {\\n      f <- task.fork\\n      _ <- ZIO.sleep(5.second)\\n      _ <- f.interrupt\\n    } yield ()\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DocRepo Service Interface in ZIO\nDESCRIPTION: Defines the DocRepo trait which provides document management operations like getting, saving, deleting, and finding documents, following the first law of ZIO Environment by not exposing implementation dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait DocRepo {\n  def get(id: String): ZIO[Any, Throwable, Doc]\n\n  def save(document: Doc): ZIO[Any, Throwable, String]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n\n  def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Application Using Terminal Service in Scala\nDESCRIPTION: Implements a simple ZIO application that uses the Terminal service to interact with the user, demonstrating dependency injection without ZIO environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef myApp(c: Terminal): Task[Unit] =\n  for {\n    _    <- c.print(\"Please enter your name: \")\n    name <- c.readLine\n    _    <- c.printLine(s\"Hello, $name!\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Launching a ZIO Application from a Layer (Scala)\nDESCRIPTION: Shows how to declare a ZLayer representing an application (e.g., HTTP server) and start it with launch. Dependencies (JsonParser, TemplateEngine) are composed into HttpServer. Calls launch to build and run the layer until interrupted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n\n  val httpServer: ZLayer[Any, Nothing, HttpServer] =\n    ZLayer.make[HttpServer](\n      JsonParserLive.layer,\n      TemplateEngineLive.layer \n    )\n\n  def run = httpServer.launch\n\n}\n\n```\n\n----------------------------------------\n\nTITLE: Converting Safe Synchronous Operations to ZIO Effects\nDESCRIPTION: Demonstrates using ZIO.succeed to convert side-effects that don't throw exceptions into ZIO effects. This should only be used when we're certain the operation cannot fail with an exception.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef printLine(line: String): UIO[Unit] =\n  ZIO.succeed(println(line))\n\nval succeedTask: UIO[Long] =\n  ZIO.succeed(java.lang.System.nanoTime())\n```\n\n----------------------------------------\n\nTITLE: Illustrating Sandbox/Unsandbox Type Flow in Scala\nDESCRIPTION: Shows the sequence of type transformations when applying `sandbox`, error handling (`catchSome`), and `unsandbox` to a ZIO effect. It clarifies how the error type changes from `E` to `Cause[E]` and back to `E`. Requires the `zio` library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/sandboxing.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval effect: ZIO[Any, String, String] =\n  ZIO.succeed(\"primary result\") *> ZIO.fail(\"Oh uh!\")\n\neffect            // ZIO[Any, String, String]\n  .sandbox        // ZIO[Any, Cause[String], String]\n  .catchSome(???) // ZIO[Any, Cause[String], String]\n  .unsandbox      // ZIO[Any, String, String]\n```\n\n----------------------------------------\n\nTITLE: TranzactIO Example with Doobie and ZIO\nDESCRIPTION: This comprehensive example demonstrates how to use TranzactIO with Doobie and ZIO. It includes database setup, querying, and transaction management. The code showcases person data insertion and retrieval using an in-memory H2 database.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tranzactio.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport doobie.implicits._\nimport io.github.gaelrenoux.tranzactio.doobie\nimport io.github.gaelrenoux.tranzactio.doobie.{Connection, Database, TranzactIO, tzio}\nimport org.h2.jdbcx.JdbcDataSource\nimport zio.blocking.Blocking\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.{ExitCode, Has, URIO, ZIO, ZLayer, blocking}\n\nimport javax.sql.DataSource\n\nobject TranzactIOExample extends zio.App {\n\n  val query: ZIO[Connection with Console, Throwable, Unit] = for {\n    _ <- PersonQuery.setup\n    _ <- PersonQuery.insert(Person(\"William\", \"Stewart\"))\n    _ <- PersonQuery.insert(Person(\"Michelle\", \"Streeter\"))\n    _ <- PersonQuery.insert(Person(\"Johnathon\", \"Martinez\"))\n    users <- PersonQuery.list\n    _ <- putStrLn(users.toString)\n  } yield ()\n\n  val myApp: ZIO[zio.ZEnv, Throwable, Unit] =\n    Database.transactionOrWidenR(query).provideCustom(services.database)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n\ncase class Person(firstName: String, lastName: String)\n\nobject PersonQuery {\n  def list: TranzactIO[List[Person]] = tzio {\n    sql\"\"\"SELECT first_name, last_name FROM person\"\"\".query[Person].to[List]\n  }\n\n  def setup: TranzactIO[Unit] = tzio {\n    sql\"\"\"\n        CREATE TABLE person (\n          first_name VARCHAR NOT NULL,\n          last_name VARCHAR NOT NULL\n        )\n        \"\"\".update.run.map(_ => ())\n  }\n\n  def insert(p: Person): TranzactIO[Unit] = tzio {\n    sql\"\"\"INSERT INTO person (first_name, last_name) VALUES (${p.firstName}, ${p.lastName})\"\"\".update.run\n      .map(_ => ())\n  }\n}\n\nobject services {\n  val datasource: ZLayer[Blocking, Throwable, Has[DataSource]] =\n    ZLayer.fromEffect(\n      blocking.effectBlocking {\n        val ds = new JdbcDataSource\n        ds.setURL(s\"jdbc:h2:mem:mydb;DB_CLOSE_DELAY=10\")\n        ds.setUser(\"sa\")\n        ds.setPassword(\"sa\")\n        ds\n      }\n    )\n\n  val database: ZLayer[Any, Throwable, doobie.Database.Database] =\n    (Blocking.live >>> datasource ++ Blocking.live ++ Clock.live) >>> Database.fromDatasource\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Effectful Folding in ZIO (Scala)\nDESCRIPTION: Demonstrates the use of `fold` to handle both failure and success non-effectfully. This allows for simple error handling and success processing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nlazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: UIO[Array[Byte]] =\n  readFile(\"primary.data\").fold(\n    _    => DefaultData,\n    data => data)\n```\n\n----------------------------------------\n\nTITLE: Creating ZLayer for Service\nDESCRIPTION: Defines the ZLayer constructor for DocRepo service, lifting the implementation into ZIO's dependency injection system.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/service-pattern.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject DocRepo {\n  /**\n   * The \"live\" implementation of the `DocRepo` service.\n   */\n  val live: ZLayer[BlobStorage & MetadataRepo, Nothing, DocRepo] =\n    ZLayer {\n      for {\n        metadataRepo <- ZIO.service[MetadataRepo]\n        blobStorage  <- ZIO.service[BlobStorage]\n      } yield new DocRepoLive(metadataRepo, blobStorage)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Write Operations in ZChannel with Scala\nDESCRIPTION: Demonstrates different methods to write data to a ZChannel's output port, including write for single elements, writeAll for multiple elements, and writeChunk for writing a Chunk of elements. Each example shows the output when run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/creating-channels.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nZChannel.write(1).runCollect.debug\n// Output: (Chunk(1),()) \n\nZChannel.writeAll(1, 2, 3).runCollect.debug\n// Output: (Chunk(1,2,3),()) \n\nZChannel.writeChunk(Chunk(1, 2, 3)).runCollect.debug\n// Output: (Chunk(1,2,3),()) \n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Multiple Database Instances in ZIO Scala\nDESCRIPTION: This comprehensive example demonstrates how to create, provide, and use multiple instances of a Database service in a ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.nio.charset.StandardCharsets\n\ntrait Database {\n  def add(key: String, value: Array[Byte]): ZIO[Any, Throwable, Unit]\n}\n\nobject Database {\n  val layer: ULayer[Map[String, Database]] = {\n    ZLayer.succeedEnvironment(\n      ZEnvironment(\n        Map(\n          \"persistent\" -> PersistentDatabase.apply(),\n          \"inmemory\" -> InmemoryDatabase.apply()\n        )\n      )\n    )\n  }\n}\n\ncase class InmemoryDatabase() extends Database {\n  override def add(key: String, value: Array[Byte]): ZIO[Any, Throwable, Unit] =\n    ZIO.unit <* ZIO.logInfo(s\"new $key added to the inmemory database\")\n}\n\ncase class PersistentDatabase() extends Database {\n  override def add(key: String, value: Array[Byte]): ZIO[Any, Throwable, Unit] =\n    ZIO.unit <* ZIO.logInfo(s\"new $key added to the persistent database\")\n}\n\nobject MultipleDatabaseExample extends ZIOAppDefault {\n  val myApp = for {\n    inmemory <- ZIO.serviceAt[Database](\"inmemory\")\n      .flatMap(x => ZIO.fromOption[Database](x))\n      .orElseFail(\"failed to find an in-memory database in the ZIO environment\")\n    persistent <- ZIO.serviceAt[Database](\"persistent\")\n      .flatMap(x => ZIO.fromOption[Database](x))\n      .orElseFail(\"failed to find an persistent database in the ZIO environment\")\n    _ <- inmemory.add(\"key1\", \"value1\".getBytes(StandardCharsets.UTF_8))\n    _ <- persistent.add(\"key2\", \"value2\".getBytes(StandardCharsets.UTF_8))\n  } yield ()\n\n  def run = myApp.provideLayer(Database.layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Switching Streams on Timeout with timeoutTo in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates using ZStream#timeoutTo to switch to an alternative stream if the primary stream doesn't produce values within a specified duration. This provides fallback behavior for slow streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_80\n\nLANGUAGE: scala\nCODE:\n```\nval alternative = ZStream.fromEffect(ZIO.effect(???))\nstream.timeoutTo(10.seconds)(alternative)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZIO 2.x Improved Environment Compiler Errors in Scala\nDESCRIPTION: Example of ZIO 2.x application with missing layers, showcasing more descriptive and helpful compiler errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_55\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Config(host: String, port: Int)\n\ntrait Logger {\n  def log(line: Any): Task[Unit]\n}\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      config <- ZIO.service[Config]\n      logger <- ZIO.service[Logger]\n      _ <- logger.log(s\"Application started with the following config: $config\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZLayers for Services in Scala\nDESCRIPTION: Demonstrates how to define ZLayers for A and B services, including service access methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject A {\n  def foo: ZIO[A, Nothing, String] = \n    ZIO.serviceWithZIO[A](_.foo) \n  \n  val layer: ZLayer[Any, Nothing, A] = \n    ZLayer.succeed(new A) \n}\n\nobject B {\n  def bar: ZIO[B, Nothing, Int] = \n    ZIO.serviceWithZIO[B](_.bar)\n  \n  val layer: ZLayer[Any, Nothing, B] = \n    ZLayer.succeed(new B)\n}\n```\n\n----------------------------------------\n\nTITLE: Rewriting ZIO Error Handling Combinators for Infallible Effects\nDESCRIPTION: This table shows how to rewrite various ZIO error handling combinators when dealing with effects that cannot fail (UIO). It provides equivalent expressions that preserve the original behavior without unnecessary error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/canfail.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nuio <> zio | uio\nuio.catchAll(f) | uio\nuio.catchSome(pf) | uio\nuio.either | uio\nuio.eventually | uio\nuio.flatMapError(f) | uio\nuio.fold(f, g) | uio.map(g)\nuio.foldZIO(f, g) | uio.flatMap(g)\nuio.mapBoth(f, g) |  uio.map(g)\nuio.mapError(f) | uio\nuio.option | uio\nuio.orDie | uio\nuio.orDieWith(f) | uio\nuio.orElse(zio) | uio\nuio.orElseEither(zio) | uio\nuio.orElseFail(e) | uio\nuio.asElseSucceed(a) | uio\nuio.refineOrDie(pf) | uio\nuio.refineOrDieWith(pf)(f) | uio\nuio.refineToOrDie | uio\nuio.retry(s) | uio\nuio.retryOrElse(s, f) | uio\nuio.retryOrElseEither(s, f) | uio\nuio.tapBoth(f, g) | uio.tap(g)\nuio.tapError(f) | uio\nZIO.partitionZIO(in)(f) | ZIO.foreach(in)(f)\nZIO.partitionZIOPar(in)(f) | ZIO.foreachPar(in)(f)\nZIO.validateZIO(in)(f) | ZIO.foreach(in)(f)\nZIO.validateFirstZIO(in)(f) | ZIO.foreach(in)(f)\n```\n\n----------------------------------------\n\nTITLE: Handling Unrefined Exceptions with ZIO.unrefineTo - Scala\nDESCRIPTION: Showcases the use of ZIO.succeed for synchronous code and unrefineTo for lifting thrown exceptions (like NumberFormatException) into the error channel. Accepts a string, converts synchronously to Int, and widens the error channel to admit NumberFormatException. Requires zio. Useful for migrating thrown exceptions into typed effect errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/examples.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\ndef parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\\n  ZIO.succeed(input.toInt)                 // ZIO[Any, Nothing, Int]\\n    .unrefineTo[NumberFormatException]     // ZIO[Any, NumberFormatException, Int]\n```\n\n----------------------------------------\n\nTITLE: Testing ZIO Timeout with TestClock in Scala\nDESCRIPTION: Demonstrates how to test ZIO's timeout functionality using TestClock. It forks a fiber that sleeps for 5 minutes with a 1-minute timeout, then adjusts the TestClock to trigger the timeout.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nfor {\n  fiber  <- ZIO.sleep(5.minutes).timeout(1.minute).fork\n  _      <- TestClock.adjust(1.minute)\n  result <- fiber.join\n} yield assertTrue(result.isEmpty)\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Histogram with Linear Buckets in Scala\nDESCRIPTION: Demonstrates how to define a Histogram metric named \"histogram\" using `Metric.histogram`. It specifies linear boundaries starting at 0, with a step size of 10, creating 11 buckets (0-10, 10-20, ..., 90-100, plus an implicit +Inf bucket). Requires `zio` and `zio.metrics`. The resulting `histogram` object can be applied to ZIO effects yielding `Double` values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/histogram.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.metrics._\n\nval histogram =\n  Metric.histogram(\"histogram\", MetricKeyType.Histogram.Boundaries.linear(0, 10, 11))\n```\n\n----------------------------------------\n\nTITLE: Applying Top-Level ZIO Runtime Configuration in Scala\nDESCRIPTION: This example demonstrates creating and applying a top-level runtime configuration in a `ZIOAppDefault`. It defines a configuration `layer` that removes default loggers and adds a simple one. This layer is then unsafely converted into a custom `Runtime` which is assigned to the `override val runtime`. The `run` method then executes, using this pre-configured runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  // In a real-world application we might need to implement a `sl4jlogger` layer\n  val addSimpleLogger: ZLayer[Any, Nothing, Unit] =\n    Runtime.addLogger((_, _, _, message: () => Any, _, _, _, _) => println(message()))\n\n  val layer: ZLayer[Any, Nothing, Unit] =\n    Runtime.removeDefaultLoggers ++ addSimpleLogger\n\n  override val runtime: Runtime[Any] =\n    Unsafe.unsafe { implicit unsafe =>\n      Runtime.unsafe.fromLayer(layer)\n    }\n\n  def run = ZIO.log(\"Application started!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Timeout to an Effect with ZIO Scala\nDESCRIPTION: Demonstrates using ZIO#timeout to apply a time limit to an effect, returning Some(result) if completed in time, or None if not. Requires zio.duration._ and ZIO. Input is an effect and a finite duration; output is Option of the result. Automatically interrupts timed-out computations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.duration._\n\nIO.succeed(\"Hello\").timeout(10.seconds)\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Nested Logging Spans in Scala with ZIO\nDESCRIPTION: Illustrates how to create multiple nested logging spans and log within them using ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.logSpan(\"span1\") {\n  for {\n    _ <- ZIO.log(\"log inside span1\")\n    _ <- ZIO.logSpan(\"span2\") {\n      ZIO.log(\"log inside span1 and span2\")\n    }\n    _ <- ZIO.log(\"log inside span1\")\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO#retryUntil and ZIO#retryUntilZIO Signatures in Scala\nDESCRIPTION: Defines the signatures for `retryUntil` and `retryUntilZIO` methods on the ZIO trait. These methods retry a failed effect indefinitely until the error produced satisfies a given predicate (`f`). `retryUntil` takes a simple predicate, while `retryUntilZIO` takes a predicate that returns a ZIO effect (`URIO`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def retryUntil(f: E => Boolean): ZIO[R, E, A]\n  def retryUntilZIO[R1 <: R](f: E => URIO[R1, Boolean]): ZIO[R1, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Effect Retrying in Scala with ZIO\nDESCRIPTION: Demonstrates how to use ZIO's retry function to create a repeated effect that follows a specified retry policy. The action will be retried according to the schedule policy until it succeeds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/retrying.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval action:       ZIO[R, E, A] = ???\nval policy: Schedule[R1, E, S] = ???\n\nval repeated = action retry policy\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Helper Function for Reading Files in Scala with ZIO\nDESCRIPTION: This invisible mdoc snippet defines a helper function `readFile` that simulates reading a file. It uses `ZIO.attempt` to wrap a potentially throwing operation (represented by `???`) and `refineToOrDie[IOException]` to specifically handle `IOException`, ensuring the effect fails only with `IOException` or defects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.{ FileNotFoundException, IOException }\n\ndef readFile(s: String): ZIO[Any, IOException, Array[Byte]] =\n  ZIO.attempt(???).refineToOrDie[IOException]\n```\n\n----------------------------------------\n\nTITLE: Running a ZIO Application with SimpleLogger Implementation Scala\nDESCRIPTION: Demonstrates how to run the previously defined `myApp` ZIO application in Scala by providing the `SimpleLogger` implementation. It defines a `MainApp` extending `ZIOAppDefault` and uses the `provide` method with `SimpleLogger.live` layer to satisfy the `Logging` dependency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(SimpleLogger.live)\n}\n```\n\n----------------------------------------\n\nTITLE: Handing Off Values Between ZIO Fibers Using Promise (Scala)\nDESCRIPTION: This example demonstrates inter-fiber communication using Promise in ZIO with the Console and Clock modules. One fiber produces and sets a value after a timed delay, and another fiber awaits the value and prints it. Requires zio.console._, zio.clock._, and zio.duration._ as dependencies. Inputs are actions and the main effect, outputs are performed via side-effects in Console. Limitations: fibers must be joined to avoid premature exit.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/promise.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.io.IOException\\nimport zio.console._\\nimport zio.duration._\\nimport zio.clock._\\n\\nval program: ZIO[Console with Clock, IOException, Unit] = \\n  for {\\n    promise         <-  Promise.make[Nothing, String]\\n    sendHelloWorld  =   (IO.succeed(\"hello world\") <* sleep(1.second)).flatMap(promise.succeed)\\n    getAndPrint     =   promise.await.flatMap(putStrLn(_))\\n    fiberA          <-  sendHelloWorld.fork\\n    fiberB          <-  getAndPrint.fork\\n    _               <-  (fiberA zip fiberB).join\\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Fast Interruption with interruptFork in ZIO Scala\nDESCRIPTION: Shows how to use Fiber#interruptFork for fast interruption, allowing the program to continue while the interruption happens in the background.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber <- printLine(\"Working on the first job\")\n    .schedule(Schedule.fixed(1.seconds))\n    .ensuring {\n      (printLine(\n        \"Finalizing or releasing a resource that is time-consuming\"\n      ) *> ZIO.sleep(7.seconds)).orDie\n    }\n    .fork\n  _ <- fiber.interruptFork.delay(4.seconds) // fast interruption\n  _ <- printLine(\n    \"Starting another task while interruption of the previous fiber happening in the background\"\n  )\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Tailing Pod Logs Example with ZIO K8s\nDESCRIPTION: A complete example of using ZIO K8s to stream logs from a Kubernetes pod. The program accepts a pod name and optional container name as arguments, and continuously prints the logs to the console.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport com.coralogix.zio.k8s.client.K8sFailure\nimport com.coralogix.zio.k8s.client.config.httpclient._\nimport com.coralogix.zio.k8s.client.model.K8sNamespace\nimport com.coralogix.zio.k8s.client.v1.pods\nimport com.coralogix.zio.k8s.client.v1.pods.Pods\nimport zio._\nimport zio.console.Console\n\nimport scala.languageFeature.implicitConversions\n\nobject ZIOK8sLogsExample extends zio.App {\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = (args match {\n    case List(podName) => tailLogs(podName, None)\n    case List(podName, containerName) => tailLogs(podName, Some(containerName))\n    case _ => console.putStrLnErr(\"Usage: <podname> [containername]\")\n  })\n    .provideCustom(k8sDefault >>> Pods.live)\n    .exitCode\n\n  def tailLogs(podName: String,\n               containerName: Option[String]\n              ): ZIO[Pods with Console, K8sFailure, Unit] =\n    pods\n      .getLog(\n        name = podName,\n        namespace = K8sNamespace.default,\n        container = containerName,\n        follow = Some(true)\n      )\n      .tap { line: String =>\n        console.putStrLn(line).ignore\n      }\n      .runDrain\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Different Failure Causes with Sandbox in Scala\nDESCRIPTION: Demonstrates a complete ZIO application using `sandbox` to catch specific failure causes. It defines an effect that fails, applies `sandbox`, uses `catchSome` to pattern match on the `Cause` (handling `Interrupt`, `Die`, and `Fail`), provides fallback results, and uses `unsandbox` to return the error channel to its original type. Requires the `zio` library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/sandboxing.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect: ZIO[Any, String, String] =\n    ZIO.succeed(\"primary result\") *> ZIO.fail(\"Oh uh!\")\n\n  val myApp: ZIO[Any, Cause[String], String] =\n    effect.sandbox.catchSome {\n      case Cause.Interrupt(fiberId, _) =>\n        ZIO.debug(s\"Caught interruption of a fiber with id: $fiberId\") *>\n          ZIO.succeed(\"fallback result on fiber interruption\")\n      case Cause.Die(value, _) =>\n        ZIO.debug(s\"Caught a defect: $value\") *>\n          ZIO.succeed(\"fallback result on defect\")\n      case Cause.Fail(value, _) =>\n        ZIO.debug(s\"Caught a failure: $value\") *>\n          ZIO.succeed(\"fallback result on failure\")\n    }\n\n  val finalApp: ZIO[Any, String, String] = myApp.unsandbox.debug(\"final result\")\n\n  def run = finalApp\n}\n\n// Output:\n// Caught a failure: Oh uh!\n// final result: fallback result on failure\n```\n\n----------------------------------------\n\nTITLE: Resource Acquisition and Cleanup with ZIO Bracket in Scala\nDESCRIPTION: This snippet illustrates the ZIO '.bracket' pattern, which manages safe acquisition and release of resources, such as files, mirroring the try-finally pattern. It demonstrates specifying an acquire effect, a release effect (that cleans up the resource), and a use effect (that processes the resource). Dependencies are ZIO and code to open, process, and close files. The bracketed usage ensures release is always invoked, regardless of failures or interruptions, returning the grouped data.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_resources.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval groupedFileData: IO[IOException, Unit] = \n  openFile(\"data.json\").bracket(closeFile(_)) { file =>\n    for {\n      data    <- decodeData(file)\n      grouped <- groupData(data)\n    } yield grouped\n  }\n```\n\n----------------------------------------\n\nTITLE: Forking an Effect with ZIO Fibers in Scala\nDESCRIPTION: Demonstrates how to define a recursive, effectful Fibonacci calculation and fork its execution onto a new fiber using ZIO. Requires ZIO as a dependency, and the function expects a Long as an input and returns a fiber representing the running computation. The output is a fiber handle for potential manipulation (join, interrupt, etc.).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef fib(n: Long): UIO[Long] = UIO {\n  if (n <= 1) UIO.succeed(n)\n  else fib(n - 1).zipWith(fib(n - 2))(_ + _)\n}.flatten\n\nval fib100Fiber: UIO[Fiber[Nothing, Long]] = \n  for {\n    fiber <- fib(100).fork\n  } yield fiber\n```\n\n----------------------------------------\n\nTITLE: Complete ZIO Temporal Application Example\nDESCRIPTION: A complete example showing how to define and implement a Temporal workflow using ZIO Temporal. Includes workflow interface definition, implementation, worker setup, and client invocation code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-temporal.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n//> using scala \"3.3.0\"\n\n//> using lib \"dev.zio::zio:2.0.16\"\n//> using lib \"dev.vhonta::zio-temporal-core:0.4.0\"\n//> using lib \"dev.zio::zio-logging:2.1.14\"\n//> using lib \"dev.zio::zio-logging-slf4j2-bridge:2.1.14\"\n\nimport zio.*\nimport zio.temporal.*\nimport zio.temporal.worker.*\nimport zio.temporal.workflow.*\nimport zio.logging.*\n\n// This is our workflow interface\n@workflowInterface\ntrait EchoWorkflow:\n\n  @workflowMethod\n  def echo(str: String): String\n\n// Workflow implementation\nclass EchoWorkflowImpl extends EchoWorkflow:\n  private val logger = ZWorkflow.makeLogger\n\n  override def echo(str: String): String =\n    logger.info(s\"Worker: Received \\\"$str\\\"\")\n    s\"ACK: $str\"\n\n// Main Application\nobject Main extends ZIOAppDefault:\n  val taskQueue = \"echo-queue\"\n\n  // Worker implementation\n  val setupWorker = ZWorkerFactory.newWorker(taskQueue) @@\n    ZWorker.addWorkflow[EchoWorkflowImpl].fromClass\n\n  // Client implementation\n  def invokeWorkflow(msg: String) = ZIO.serviceWithZIO[ZWorkflowClient]: client =>\n    for\n      uuid <- Random.nextUUID\n      workflowID = s\"echo-$uuid\"\n      echoWorkflow <- client\n                        .newWorkflowStub[EchoWorkflow]\n                        .withTaskQueue(taskQueue)\n                        .withWorkflowId(workflowID)\n                        .withWorkflowRunTimeout(2.seconds)\n                        .withRetryOptions(ZRetryOptions.default.withMaximumAttempts(3))\n                        .build\n      _   <- ZIO.logInfo(s\"Will submit message \\\"$msg\\\" with workflow ID $workflowID\")\n      res <- ZWorkflowStub.execute(echoWorkflow.echo(msg))\n      _   <- ZIO.logInfo(s\"Greeting received: $res\")\n    yield res\n\n  // Logging configuration\n  val logFilter: LogFilter[String] = LogFilter.logLevelByName(\n    LogLevel.Info,\n    \"io.grpc.netty\" -> LogLevel.Warning,\n    \"io.netty\"      -> LogLevel.Warning,\n    \"io.temporal\"   -> LogLevel.Error,\n  )\n  override val bootstrap: ZLayer[ZIOAppArgs, Any, Any] =\n    Runtime.removeDefaultLoggers >>> consoleLogger(ConsoleLoggerConfig(LogFormat.colored, logFilter))\n\n  // ZIO Main Program\n  def run: ZIO[ZIOAppArgs & Scope, Any, Any] =\n    val program =\n      for\n        args           <- getArgs\n        msg             = if args.isEmpty then \"testMsg\" else args.mkString(\" \")\n        _              <- setupWorker\n        _              <- ZWorkerFactory.setup\n        _              <- ZWorkflowServiceStubs.setup()\n        workflowResult <- invokeWorkflow(msg)\n        _              <- ZIO.logInfo(s\"The workflow result: $workflowResult\")\n      yield ExitCode.success\n\n    program\n      .provideSome[ZIOAppArgs & Scope](\n        ZWorkflowServiceStubsOptions.make,\n        ZWorkflowClientOptions.make,\n        ZWorkerFactoryOptions.make,\n        ZWorkflowClient.make,\n        ZWorkflowServiceStubs.make,\n        ZWorkerFactory.make,\n        slf4j.bridge.Slf4jBridge.initialize,\n      )\n```\n\n----------------------------------------\n\nTITLE: End-to-End Example: Using Cats Effect Resource with ZIO Scope (Scala)\nDESCRIPTION: Shows a complete application using the CatsApp typeclass to run a ZIO task, integrating with Cats Effect Resource management via toScoped. It reads a file using the interoperable resource, printing the file content, and returns a ZIO ExitCode. Dependencies include zio.interop.catz, CatsApp, and ZIO types. Key parameters include the filename and command-line arguments. Expected output is the printed file content and app exit code. Cross-library interoperation is demonstrated.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.catz._\n\nobject CatsEffectResourceInterop extends CatsApp {\n  def fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n    cats.effect.Resource.make(File.open[F](name))(_.close)\n\n  def myApp: zio.ZIO[Scope, Throwable, Unit] = for {\n    c <- fileResource[zio.Task](\"log.txt\").toScoped\n    _ <- zio.Console.printLine(s\"file content: $c\")\n  } yield ()\n\n  override def run(args: List[String]): zio.URIO[Scope, zio.ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Server and Clients with SubscriptionRef\nDESCRIPTION: A complete example showing how to create a SubscriptionRef, start a server to update it, run multiple clients to observe the changes, and finally collect and display the results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/subscriptionref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  subscriptionRef <- SubscriptionRef.make(0L)\n  server          <- server(subscriptionRef.ref).fork\n  chunks          <- ZIO.collectAllPar(List.fill(100)(client(subscriptionRef.changes)))\n  _               <- server.interrupt\n  _               <- ZIO.foreach(chunks)(chunk => console.putStrLn(chunk.toString))\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.firstSuccessOf for Distributed Config Retrieval in Scala\nDESCRIPTION: This example demonstrates `ZIO.firstSuccessOf`. It defines a `remoteConfig` function simulating fetching configuration. It first tries to get the config from `masterConfig`. If that fails, it iterates through `nodeConfigs` (configs for \"node1\", \"node2\", etc.), trying each one via `orElse` semantics until a `remoteConfig` call succeeds. The final `config` effect represents the result of the first successful fetch.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Config\n\ndef remoteConfig(name: String): ZIO[Any, Throwable, Config] =\n  ZIO.attempt(???)\n\nval masterConfig: ZIO[Any, Throwable, Config] =\n  remoteConfig(\"master\")\n\nval nodeConfigs: Seq[ZIO[Any, Throwable, Config]] =\n  List(\"node1\", \"node2\", \"node3\", \"node4\").map(remoteConfig)\n\nval config: ZIO[Any, Throwable, Config] =\n  ZIO.firstSuccessOf(masterConfig, nodeConfigs)\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO Server with Persistent Storage\nDESCRIPTION: Server configuration using persistent storage for user management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/restful-webservice.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nServer.serve(\n  GreetingRoutes() ++ DownloadRoutes() ++ CounterRoutes() ++ UserRoutes()\n).provide(\n  Server.defaultWithPort(8080),\n  ZLayer.fromZIO(Ref.make(0)),\n  PersistentUserRepo.layer\n)\n```\n\n----------------------------------------\n\nTITLE: Updating Ref.Synchronized with ZIO Effect in Scala\nDESCRIPTION: Demonstrates how to create and update a Ref.Synchronized using a ZIO effect. The example creates a ref with an initial value, updates it with an effect, and then retrieves the updated value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/refsynchronized.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nfor {\n  ref <- Ref.Synchronized.make(\"current\")\n  updateEffect = ZIO.succeed(\"update\")\n  _ <- ref.updateZIO(_ => updateEffect)\n  value <- ref.get\n} yield assert(value == \"update\")\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Effect Using Unsafe Run in Scala\nDESCRIPTION: Demonstrates how to run a ZIO effect using the Runtime's unsafe.run method. This approach is used for advanced cases or integrating with legacy code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject RunZIOEffectUsingUnsafeRun extends scala.App {\n  val myAppLogic = for {\n    _ <- Console.printLine(\"Hello! What is your name?\")\n    n <- Console.readLine\n    _ <- Console.printLine(\"Hello, \" + n + \", good to meet you!\")\n  } yield ()\n\n  Unsafe.unsafe { implicit unsafe =>\n      zio.Runtime.default.unsafe.run(\n        myAppLogic\n      ).getOrThrowFiberFailure()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO Runtime via Bootstrap Layer in Scala\nDESCRIPTION: This snippet demonstrates how to customize the ZIO runtime by overriding the `bootstrap` layer in a `ZIOAppDefault`. It removes the default loggers and adds a simple custom logger that prints messages to the console. The `run` method then uses `ZIO.log` which utilizes the configured logger.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val addSimpleLogger: ZLayer[Any, Nothing, Unit] =\n    Runtime.addLogger((_, _, _, message: () => Any, _, _, _, _) => println(message()))\n\n  override val bootstrap: ZLayer[Any, Nothing, Unit] =\n    Runtime.removeDefaultLoggers ++ addSimpleLogger\n\n  def run =\n    for {\n      _ <- ZIO.log(\"Application started!\")\n      _ <- ZIO.log(\"Application is about to exit!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Counter Increment Implementation\nDESCRIPTION: Initial implementation of an increment function using Ref that is not thread-safe due to race conditions between get and set operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef inc(counter: Ref[Int], amount: Int) = for {\n  c <- counter.get\n  _ <- counter.set(c + amount)\n} yield c\n```\n\n----------------------------------------\n\nTITLE: Creating an HTTP Server with ZIO HTTP\nDESCRIPTION: Demonstrates how to create a simple HTTP server using ZIO HTTP. It sets up a route that responds to GET requests on the '/hello' path with an HTML response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\nimport zio.http.template.Html\nimport zio.ZIOAppDefault\n\nobject ZIOHttpServer extends ZIOAppDefault {\n  val routes =\n    Routes(\n      Method.GET / \"hello\" -> handler(Response.html(Html.fromString(\"<h1>Say hello to zio-http</h1>\")))\n    )\n\n  def run = Server.serve(routes).provide(Server.defaultWithPort(8080))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Management with AcquireRelease\nDESCRIPTION: Demonstrates safe resource management using ZIO's acquireReleaseWith for file operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nval groupedFileData: IO[IOException, Unit] = ZIO.acquireReleaseWith(openFile(\"data.json\"))(closeFile(_)) { file =>\n  for {\n    data    <- decodeData(file)\n    grouped <- groupData(data)\n  } yield grouped\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Kafka Consumer Instance in Scala\nDESCRIPTION: This Scala code snippet shows how to create a ZIO Kafka `Consumer` instance using `Consumer.make`. It configures the consumer with bootstrap server addresses and a consumer group ID via `ConsumerSettings`. The resulting `consumer` is a `ZIO` effect requiring a `Scope` in its environment for resource management, ensuring the consumer connection is closed when the scope terminates.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.kafka._\nimport zio.kafka.consumer._\n\nval consumer: ZIO[Scope, Throwable, Consumer] =\n  Consumer.make(\n    ConsumerSettings(List(\"localhost:9092\"))\n      .withGroupId(\"streaming-kafka-app\")\n  )\n```\n\n----------------------------------------\n\nTITLE: Eliminating Environment Dependency with ZLayer in Scala\nDESCRIPTION: Demonstrates how to use ZLayer to provide a DatabaseConnection context and eliminate the environment dependency from a ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\ntrait DatabaseConnection\n\n// An effect which requires DatabaseConnection to run\nval effect: ZIO[DatabaseConnection, IOException, String] = ???\n\n// A layer that produces DatabaseConnection service\nval dbConnection: ZLayer[Any, IOException, DatabaseConnection] = ???\n\n// After applying dbConnection to our environmental effect the reurned\n// effect has no dependency on the DatabaseConnection\nval eliminated: ZIO[Any, IOException, String] = \n  dbConnection { // Provides DatabaseConnection context\n    effect       // An effect running within `DatabaseConnection` context\n  }\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retryOrElse with Fallback Logic in Scala\nDESCRIPTION: Illustrates `retryOrElse` within a `ZIOAppDefault`. An effect generating a random number fails if the number is less than 9. It retries up to 5 times using `Schedule.recurs(5)`. If all retries fail, the `orElse` block is executed, logging the last error and schedule output (number of retries), and returning a default value (-1). Requires `zio.Random` and `zio.Schedule`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    Random\n      .nextIntBounded(11)\n      .flatMap { n =>\n        if (n < 9)\n          ZIO.fail(s\"$n is less than 9!\").debug(\"failed\")\n        else\n          ZIO.succeed(n).debug(\"succeeded\")\n      }\n      .retryOrElse(\n        policy = Schedule.recurs(5),\n        orElse = (lastError, scheduleOutput: Long) =>\n          ZIO.debug(s\"after $scheduleOutput retries, we couldn't succeed!\") *> \n            ZIO.debug(s\"the last error message we received was: $lastError\") *>\n            ZIO.succeed(-1)\n      )\n      .debug(\"the final result\")\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Background Processes with ZIO Layers\nDESCRIPTION: This example demonstrates how to create a layer with a background process attached to the global scope. The background process continues running in the global scope even though the layer is provided locally to a specific part of the application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val layer: ZLayer[Scope, Nothing, Int] =\n    ZLayer.fromZIO {\n      ZIO\n        .debug(\"Still running ...\")\n        .repeat(Schedule.fixed(1.second))\n        .forkDaemon\n        .as(42)\n    }\n\n  def run =\n    for {\n      _ <- ZIO.service[Int].provideLayer(layer) *> ZIO.debug(\"Int layer provided\")\n      _ <- ZIO.sleep(5.seconds)\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Server-Client Example with SubscriptionRef\nDESCRIPTION: A full example showing how to create a SubscriptionRef, start a server process to update it, run multiple clients in parallel to observe the changes, and finally clean up resources by interrupting the server.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/subscriptionref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  subscriptionRef <- SubscriptionRef.make(0L)\n  server          <- server(subscriptionRef).fork\n  chunks          <- ZIO.collectAllPar(List.fill(100)(client(subscriptionRef.changes)))\n  _               <- server.interrupt\n  _               <- ZIO.foreach(chunks)(chunk => Console.printLine(chunk))\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Converting Synchronous Side-Effects to ZIO Tasks\nDESCRIPTION: Shows how to wrap synchronous side-effects that might throw exceptions into ZIO Tasks using ZIO.attempt. This safely captures any exceptions that might be thrown.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.io.StdIn\n\nval getLine: Task[String] =\n  ZIO.attempt(StdIn.readLine())\n```\n\n----------------------------------------\n\nTITLE: Basic File Line Counter Using ZIO Task\nDESCRIPTION: Implementation of a file line counter using ZIO Task without proper resource management, demonstrating potential resource leakage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef lines(file: String): Task[Long] = ZIO.attempt {\n  def countLines(br: BufferedReader): Long = br.lines().count()\n  val bufferedReader = new BufferedReader(\n    new InputStreamReader(new FileInputStream(\"file.txt\")),\n    2048\n  )\n  val count = countLines(bufferedReader)\n  bufferedReader.close()\n  count\n}\n```\n\n----------------------------------------\n\nTITLE: Refining Error Types and Handling Recoverable Errors in Scala ZIO\nDESCRIPTION: This example shows how to use ZIO's refineOrDie method to handle specific recoverable errors (TemporaryUnavailable) while letting the fiber die for other unexpected errors. It also demonstrates retry logic and final error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/dont-type-unexpected-errors.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval response: ZIO[Any, Nothing, Response] =\n  ZIO\n    .attemptBlocking(\n      httpClient.fetchUrl(url)\n    ) // ZIO[Any, Throwable, Response]\n    .refineOrDie[TemporaryUnavailable] {\n      case e: TemporaryUnavailable => e\n    } // ZIO[Any, TemporaryUnavailable, Response]\n    .retry(\n      Schedule.fibonacci(1.second)\n    ) // ZIO[Any, TemporaryUnavailable, Response]\n    .orDie // ZIO[Any, Nothing, Response]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lossless Error Handling with ZIO\nDESCRIPTION: Shows how ZIO preserves all error information, providing a lossless error model compared to traditional try-catch.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nZIO.fail(\"e1\")\n  .ensuring(ZIO.succeed(throw new Exception(\"e2\")))\n  .catchAll {\n    case \"e1\" => Console.printLine(\"e1\")\n    case \"e2\" => Console.printLine(\"e2\")\n  }\n\n// Output:\n// e1\n```\n\n----------------------------------------\n\nTITLE: Defining Folding Methods in ZIO - Scala\nDESCRIPTION: This snippet defines the fold and foldZIO methods on the ZIO effect monad, allowing non-effectful and effectful (but pure) handling of both failure and success cases. fold requires non-effectful handlers, while foldZIO allows effectful continuations depending on whether the computation failed or succeeded. Both are core combinators for error handling in functional effectful code using ZIO. No external dependencies, and requires familiarity with ZIO types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def fold[B](\n    failure: E => B,\n    success: A => B\n  ): ZIO[R, Nothing, B]\n\n  def foldZIO[R1 <: R, E2, B](\n    failure: E => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  ): ZIO[R1, E2, B]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZIO gRPC Server\nDESCRIPTION: Implementation of a gRPC server using ZIO gRPC. Defines a greeting service that responds to hello requests, using ZIO for purely functional handling of the service logic and server lifecycle.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-grpc.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport io.grpc.ServerBuilder\nimport io.grpc.examples.helloworld.helloworld.ZioHelloworld.ZGreeter\nimport io.grpc.examples.helloworld.helloworld.{HelloReply, HelloRequest}\nimport io.grpc.protobuf.services.ProtoReflectionService\nimport scalapb.zio_grpc.{ServerLayer, ServiceList}\nimport zio.console.putStrLn\nimport zio.{ExitCode, URIO, ZEnv, ZIO}\n\nobject HelloWorldServer extends zio.App {\n\n  val helloService: ZGreeter[ZEnv, Any] =\n    (request: HelloRequest) =>\n      putStrLn(s\"Got request: $request\") *>\n        ZIO.succeed(HelloReply(s\"Hello, ${request.name}\"))\n\n\n  val myApp = for {\n    _ <- putStrLn(\"Server is running. Press Ctrl-C to stop.\")\n    _ <- ServerLayer\n      .fromServiceList(\n        ServerBuilder\n          .forPort(9000)\n          .addService(ProtoReflectionService.newInstance()),\n        ServiceList.add(helloService))\n      .build.useForever\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Different Implementations of ZIO Services\nDESCRIPTION: Illustrates how to provide different implementations of the same service (Cache) to different parts of the application. In this case, InmemoryCache is used for UserRepo and PersistentCache for DocumentRepo.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/examples.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Throwable, UserRepo with DocumentRepo] =\n    ((InmemoryCache.layer ++ DatabaseLive.layer) >>> UserRepoLive.layer) ++\n      ((PersistentCache.layer ++ BlobStorageLive.layer) >>> DocumentRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n```\n\n----------------------------------------\n\nTITLE: ZIO HTTP Request Logging Implementation\nDESCRIPTION: Implementation of logging in a ZIO HTTP application, demonstrating request logging, error handling, and correlation ID tracking\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.json._\nimport zio.http._\n\nRoutes(\n  Method.POST / \"users\" -> handler { (req: Request) =>\n    (for {\n      body <- req.body.asString\n      _ <- ZIO.logInfo(s\"POST /users -d $body\")\n      u = body.fromJson[User]\n      r <- u match {\n        case Left(e) =>\n          ZIO.logErrorCause(s\"Failed to parse the input\", Cause.fail(e))\n            .as(Response.text(e).status(Status.BadRequest))\n        case Right(u) =>\n          UserRepo.register(u)\n            .foldCauseZIO(\n              failure =>\n                ZIO.logErrorCause(s\"Failed to register user\", Cause.fail(failure))\n                  .as(Response.status(Status.InternalServerError)),\n              success =>\n                ZIO.logInfo(s\"User registered: $success\")\n                  .as(Response.text(success))\n            )\n      }\n    } yield r) @@ logSpan(\"register-user\") @@ logAnnotateCorrelationId(req)\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Retrying ZIO Effects with Schedule\nDESCRIPTION: Shows how to use the retry method in ZIO to retry an effect according to a specified schedule, useful for handling transient errors in cloud systems.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval retriedOpenFile: ZIO[Any, IOException, Array[Byte]] = \n  openFile(\"primary.data\")\n      .retry(Schedule.recurs(5))\n```\n\n----------------------------------------\n\nTITLE: Using AutoCloseable Resources with ZIO.scoped in Scala\nDESCRIPTION: Demonstrates how to use ZIO.scoped and ZIO.fromAutoCloseable to safely manage AutoCloseable resources like FileInputStream. It reads all bytes from a file and returns the length.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-resources.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval bytesInFile: IO[Throwable, Int] =\n  ZIO.scoped {\n    for {\n      stream <- ZIO.fromAutoCloseable(openFileInputStream(\"data.json\"))\n      data   <- ZIO.attemptBlockingIO(stream.readAllBytes())\n    } yield data.length\n  }\n```\n\n----------------------------------------\n\nTITLE: Efficient Resource Management in Scala with ZIO Scope\nDESCRIPTION: Shows how to use ZIO's Scope for automatic resource management. This example reads a file's content, ensuring that the file handler is properly closed regardless of whether the operation completes successfully or is interrupted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.io.BufferedSource\n\ndef source(name: String): ZIO[Scope, Throwable, BufferedSource] =\n  ZIO.acquireRelease(ZIO.attemptBlocking(scala.io.Source.fromFile(name)))(s => ZIO.succeedBlocking(s.close()))\n\nval fileContent: ZIO[Any, Throwable, String] =\n  ZIO.scoped {\n    source(\"file.txt\").map(_.getLines()).map(_.mkString(\"\\n\"))\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic ZIO I/O Effect in Scala\nDESCRIPTION: Demonstrates defining a `ZIO` effect named `readLine` using `zio.Console.readLine`. This effect requires no specific environment (`Any`), can fail with an `IOException`, and succeeds with a `String` representing the input read from the console.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.IOException\n\nval readLine: ZIO[Any, IOException, String] =\n  Console.readLine\n```\n\n----------------------------------------\n\nTITLE: Basic Banking Operations Implementation\nDESCRIPTION: Initial implementation of deposit and withdraw functions using Ref.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef deposit(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ + amount)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef withdraw(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ - amount)\n```\n\n----------------------------------------\n\nTITLE: Automatic Layer Construction in ZIO\nDESCRIPTION: Demonstrates automatic layer construction for A and B services using ZLayer.make.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval appLayer: ZLayer[Any, Nothing, A with B] =\n  ZLayer.make[A with B](A.layer, B.layer)\n```\n\n----------------------------------------\n\nTITLE: Getting Line Separator with ZIO System in Scala\nDESCRIPTION: Shows the usage of `system.lineSeparator` to obtain the platform-specific line separator string (e.g., \"\\n\" on Unix-like systems or \"\\r\\n\" on Windows). It returns a `URIO[System, String]` effect, which is guaranteed not to fail and provides the separator string.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/access-system-information.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nsystem.lineSeparator\n// res2: zio.package.URIO[system.package.System, String] = zio.ZIO$Read@260f05ee\n```\n\n----------------------------------------\n\nTITLE: Implementing Live and Fake Services for ZIO in Scala\nDESCRIPTION: This code defines concrete implementations for the previously declared service traits. `LoggingServiceLive` implements `LoggingService` by printing to the console. `EmailServiceFake` provides a test implementation for `EmailService` that simulates sending an email by printing a message.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ncase class LoggingServiceLive() extends LoggingService {\n  override def log(line: String): UIO[Unit] =\n    ZIO.succeed(print(line))\n}\n\ncase class EmailServiceFake() extends EmailService {\n  override def send(user: String, content: String): Task[Unit] =\n    ZIO.attempt(println(s\"sending email to $user\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.serviceWith for Accessing AppConfig Members in Scala\nDESCRIPTION: Demonstrates the use of ZIO.serviceWith to create accessor methods for AppConfig members. This is used when accessing service members that return ordinary values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(host: String, port: Int, poolSize: Int)\n\nobject AppConfig {\n  // Accessor Methods\n  def host: ZIO[AppConfig, Nothing, String]  = ZIO.serviceWith(_.host) \n  def port: ZIO[AppConfig, Nothing, Int]     = ZIO.serviceWith(_.port)\n  def poolSize: ZIO[AppConfig, Nothing, Int] = ZIO.serviceWith(_.poolSize)\n}\n\nval myApp: ZIO[AppConfig, Nothing, Unit] =\n  for {\n    host     <- AppConfig.host\n    port     <- AppConfig.port\n    _        <- ZIO.logInfo(s\"The service will be service at $host:$port\")\n    poolSize <- AppConfig.poolSize\n    _        <- ZIO.logInfo(s\"Application started with $poolSize pool size\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: ADT Encoding/Decoding Tests\nDESCRIPTION: Test cases for encoding and decoding ADT instances\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.json._\n\ntest(\"decode from custom adt\") {\n  val json =\n    \"\"\"\n      |[\n      |  {\n      |    \"Apple\": {\n      |      \"poison\": false\n      |    }\n      |  },\n      |  {\n      |    \"Banana\": {\n      |      \"curvature\": 0.5\n      |    }\n      |  }\n      |]\n      |\"\"\".stripMargin\n\n  val decoded = json.fromJson[List[Fruit]]\n  assertTrue(decoded == Right(List(Apple(false), Banana(0.5))))\n} +\ntest(\"roundtrip custom adt\") {\n  val fruits = List(Apple(false), Banana(0.5))\n  val json = fruits.toJson\n  val roundTrip = json.fromJson[List[Fruit]]\n  assertTrue(roundTrip == Right(fruits))\n}\n```\n\n----------------------------------------\n\nTITLE: Testing ZIO Effect Failure with Specific Error Type using `exit` (Scala)\nDESCRIPTION: This example demonstrates how to verify that a ZIO effect fails with a specific error instance. It defines a custom error type `MyError` and an effect that fails with it. The test uses `.exit` to capture the effect's outcome and `assertTrue` to compare the resulting `Exit` value directly against the expected `Exit.fail` containing the specific error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\nimport zio.test.Assertion._\n\ncase class MyError(msg: String) extends Exception\n\nval effect: ZIO[Any, MyError, Unit] = ZIO.fail(MyError(\"my error msg\"))\n\ntest(\"test if a ZIO effect fails with a particular error type\") {\n  for {\n    exit <- effect.exit\n  } yield assertTrue(exit == Exit.fail(MyError(\"my error msg\")))\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Akka HTTP Route Test with ZIO Test\nDESCRIPTION: An example of writing Akka HTTP Route test specification using ZIO Test and the Akka HTTP Route TestKit integration. It demonstrates how to test HTTP route handling with ZIO Test assertions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.http.scaladsl.model.HttpResponse\nimport akka.http.scaladsl.server.Directives.complete\nimport zio.test.Assertion._\nimport zio.test._\nimport zio.test.akkahttp.DefaultAkkaRunnableSpec\n\nobject MySpec extends DefaultAkkaRunnableSpec {\n  def spec =\n    suite(\"MySpec\")(\n      testM(\"my test\") {\n        assertM(Get() ~> complete(HttpResponse()))(\n          handled(\n            response(equalTo(HttpResponse()))\n          )\n        )\n      }\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci Function as UIO in Scala\nDESCRIPTION: This snippet demonstrates the implementation of a Fibonacci function as an unexceptional effect using UIO. The function has no requirements, doesn't expect any failure, and succeeds with an Int value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/uio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{UIO, ZIO}\n\ndef fib(n: Int): UIO[Int] =\n  if (n <= 1) {\n    ZIO.succeed(1)\n  } else {\n    for {\n      fiber1 <- fib(n - 2).fork\n      fiber2 <- fib(n - 1).fork\n      v2     <- fiber2.join\n      v1     <- fiber1.join\n    } yield v1 + v2\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining Histogram and Timer Metrics with ZIO Metric API in Scala\nDESCRIPTION: Shows the static methods within the `Metric` object used to create Histogram metrics. `histogram` creates a standard histogram for Double values with specified boundaries. `timer` creates specialized histograms for measuring Durations, allowing configuration of name, description, time unit, and bucket boundaries. Requires `zio.metrics` library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/histogram.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Metric {\n  def histogram(\n      name: String,\n      boundaries: Histogram.Boundaries\n    ): Histogram[Double] = ???\n  \n  def timer(\n      name: String,\n      description: String,\n      chronoUnit: ChronoUnit\n    ): Metric[MetricKeyType.Histogram, Duration, MetricState.Histogram] = ???\n  \n  def timer(\n      name: String,\n      chronoUnit: ChronoUnit,\n      boundaries: Chunk[Double]\n    ): Metric[MetricKeyType.Histogram, Duration, MetricState.Histogram] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Log Levels with ZIO.logLevel (Scala)\nDESCRIPTION: This snippet shows how to use the ZIO.logLevel combinator to perform effectful logic with a specified log level, overriding the default. Here, a warning-level message is emitted. Dependencies: zio, LogLevel. Parameters: a log level and a ZIO effect. Outputs: log entry at the desired level. No input required.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nZIO.logLevel(LogLevel.Warning) {\\n  ZIO.log(\\\"The response time exceeded its threshold!\\\")\\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive App Demonstrating Uncaught Defects with map - Scala\nDESCRIPTION: Defines a ZIOAppDefault object simulating a read-eval-print-loop for integer input and even/odd reporting, but using map (not mapAttempt) to parse the input. If the input is not an integer, a NumberFormatException defect is produced and the application crashes. Dependencies: zio._ and Console; input, output, and side effects are managed through ZIO primitives. Illustrates the limitation of map with side-effecting/exceptional code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, Nothing, Unit] =\n    Console.print(\"Please enter a number: \").orDie *>\n      Console.readLine.orDie\n        .map(_.toInt)\n        .map(_ % 2 == 0)\n        .flatMap {\n          case true =>\n            Console.printLine(\"You have entered an even number.\").orDie\n          case false =>\n            Console.printLine(\"You have entered an odd number.\").orDie\n        }\n\n  def run = myApp\n}\n\n```\n\n----------------------------------------\n\nTITLE: ZStream Creation Examples\nDESCRIPTION: Shows various ways to create ZStreams including empty streams, single-value streams, finite streams, and infinite streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream.ZStream\nval emptyStream         : ZStream[Any, Nothing, Nothing]   = ZStream.empty\nval oneIntValueStream   : ZStream[Any, Nothing, Int]       = ZStream.succeed(4)\nval oneListValueStream  : ZStream[Any, Nothing, List[Int]] = ZStream.succeed(List(1, 2, 3))\nval finiteIntStream     : ZStream[Any, Nothing, Int]       = ZStream.range(1, 10)\nval infiniteIntStream   : ZStream[Any, Nothing, Int]       = ZStream.iterate(1)(_ + 1)\n```\n\n----------------------------------------\n\nTITLE: Composing ZIO Effects with Diverse Error Types in a For-Comprehension - Scala\nDESCRIPTION: Demonstrates composing multiple ZIO effects, each potentially failing with different error types, within a for-comprehension. The code shows the sequential use of 'userAuth', 'userProfile', 'generateEmail', and 'sendEmail', some of which can fail with their own domain-specific error types (like 'ExpiredAuth', 'InvalidUserId', and 'EmailDeliveryError'). All errors are automatically widened to 'Exception' at compile time, resulting in the type IO[Exception, Receipt]. Dependencies: ZIO library, definitions of effectful functions and error types. Inputs: token, userId, orderDetails, and an email address. Output: an IO effect with a Receipt on success. Limitation: Specific error details are abstracted into Exception, so fine-grained handling is lost at this level.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/algebraic-data-types.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: IO[Exception, Receipt] =\n  for {\n    service <- userAuth(token)                // IO[ExpiredAuth, UserService]\n    profile <- service.userProfile(userId)    // IO[InvalidUserId, Profile]\n    body    <- generateEmail(orderDetails)    // IO[Nothing, String]\n    receipt <- sendEmail(\"Your order detail\",\n       body, profile.email)                   // IO[EmailDeliveryError, Unit]\n  } yield receipt\n```\n\n----------------------------------------\n\nTITLE: Composing Metric Aspects on ZIO Effects in Scala\nDESCRIPTION: This snippet illustrates how to instrument a ZIO effect with multiple metric aspects, specifically a Gauge and a Counter. Metric.counter is used to create a counter and fromConst assigns it a constant value increment. Random.nextDoubleBetween samples a Double and the effect is decorated with both absoluteGauge and countAll aspects via '@@' operator. Inputs are the gauge and counter metric, and output is a Unit result. This pattern enables tracking both instantaneous and cumulative statistics for an effect's execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/gauge.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval countAll = Metric.counter(\"countAll\").fromConst(1)\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  _ <- Random.nextDoubleBetween(0.0d, 100.0d) @@ absoluteGauge @@ countAll\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Composing Alternative STM Transactions with orTry\nDESCRIPTION: Shows how to use orTry to compose alternative STM transactions. This example creates a variation of the transfer function that fails immediately with an error message instead of retrying when funds are insufficient.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/stm.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef transferMoneyFailFast(from: TRef[Long], to: TRef[Long], amount: Long): STM[String, Long] =\n    transferMoneyNoMatterWhat(from, to, amount) orTry STM.fail(\"Sender does not have enough of money\")\n```\n\n----------------------------------------\n\nTITLE: Resourceful Constructor with ZLayer.scoped\nDESCRIPTION: Demonstration of creating a resourceful constructor using ZLayer.scoped, which handles resource acquisition and release.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class A(a: Int)\nobject A {\n  val layer: ZLayer[Any, Nothing, A] =\n    ZLayer.scoped {\n      ZIO.acquireRelease(acquire = ZIO.debug(\"Initializing A\") *> ZIO.succeed(A(5)))(\n        release = _ => ZIO.debug(\"Releasing A\")\n      )\n    }\n}\n\nobject ZIOApp extends ZIOAppDefault {\n  val myApp: ZIO[A, Nothing, Int] =\n    for {\n      a <- ZIO.serviceWith[A](_.a)\n    } yield a * a\n\n  def run =\n    myApp\n      .debug(\"result\")\n      .provide(A.layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fiber-Local State with ZIO FiberRef in Scala\nDESCRIPTION: This example contrasts with the `Ref` example by using `FiberRef.make`. It creates a fiber-local reference. Two concurrent fibers (`left` and `right`) update this `FiberRef`. The output demonstrates that each fiber operates on its own independent copy of the value. Updates in one fiber do not affect the value seen by the other, highlighting the isolation provided by `FiberRef`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject FiberRefExample extends ZIOAppDefault {\n  def run =\n    for {\n      ref <- FiberRef.make(0)\n      left = ref.updateAndGet(_ + 1).debug(\"left1\") *>\n        ref.updateAndGet(_ + 1).debug(\"left2\")\n      right = ref.updateAndGet(_ + 1).debug(\"right1\") *>\n        ref.updateAndGet(_ + 3).debug(\"right2\")\n      _ <- left <&> right\n    } yield ()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Basic ZIO-Doobie Integration\nDESCRIPTION: Demonstrates basic integration between ZIO and Doobie for database operations including table creation, insertion, and querying. Uses H2 in-memory database with basic CRUD operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nimport doobie._\nimport doobie.implicits._\nimport fs2.Stream\nimport zio.Task\nimport zio.interop.catz._\n\nimplicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\n\ncase class User(id: String, name: String, age: Int)\n\ndef xa: Transactor[Task] =\n  Transactor.fromDriverManager[Task](\n    \"org.h2.Driver\",\n    \"jdbc:h2:mem:users;DB_CLOSE_DELAY=-1\"\n  )\n\ndef createTable: doobie.ConnectionIO[Int] =\n  sql\"\"\"CREATE TABLE IF NOT EXISTS USERS(\n        |id   INT SERIAL UNIQUE,\n        |name VARCHAR NOT NULL UNIQUE,\n        |age  SMALLINT\n        |)\"\"\".stripMargin.update.run\n\ndef dropTable: doobie.ConnectionIO[Int] =\n  sql\"\"\"DROP TABLE IF EXISTS USERS\"\"\".update.run\n\ndef insert(name: String, age: Int): doobie.ConnectionIO[Int] =\n  sql\"insert into users (name, age) values ($name, $age)\".update.run\n\ndef loadUsers: Stream[doobie.ConnectionIO, User] =\n  sql\"\"\"SELECT * FROM users\"\"\".query[User].stream\n\nval doobieApp: Stream[doobie.ConnectionIO, User] = for {\n  _ <- fs2.Stream.eval(dropTable)\n  _ <- fs2.Stream.eval(createTable)\n  _ <- fs2.Stream.eval(insert(\"Olivia\", 21))\n  _ <- fs2.Stream.eval(insert(\"Oliver\", 30))\n  u <- loadUsers\n} yield u\n\nval run: Stream[Task, User] = doobieApp.transact(xa)\n\nval allUsers: List[User] =\n  zioRuntime.unsafeRun(run.compile.toList)\n```\n\n----------------------------------------\n\nTITLE: Updating Application Configuration Using ZLayer's update Method\nDESCRIPTION: This example shows a practical application of the update method for modifying application configuration. It initializes an AppConfig with a poolSize of 5, then updates it to increase the poolSize by 10, resulting in a final value of 15.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\ncase class AppConfig(poolSize: Int)\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[AppConfig, IOException, Unit] =\n    for {\n      config <- ZIO.service[AppConfig]\n      _ <- Console.printLine(s\"Application config after the update operation: $config\")\n    } yield ()\n\n\n  val appLayers: ZLayer[Any, Nothing, AppConfig] =\n    ZLayer(ZIO.succeed(AppConfig(5)).debug(\"Application config initialized\"))\n\n  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =\n    appLayers.update[AppConfig](c =>\n      c.copy(poolSize = c.poolSize + 10)\n    )\n\n  def run = myApp.provide(updatedConfig)\n}\n\n// Output:\n// Application config initialized: AppConfig(5)\n// Application config after the update operation: AppConfig(15)\n```\n\n----------------------------------------\n\nTITLE: Creating ZLayer from Config Loading Effect\nDESCRIPTION: Example of creating a ZLayer from a ZIO effect that loads application configuration from a file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(poolSize: Int)\n  \nobject AppConfig {\n  private def loadConfig : Task[AppConfig] = \n    ZIO.attempt(???) // loading config from a file\n    \n  val layer: TaskLayer[AppConfig] = \n    ZLayer(loadConfig)  // or ZLayer.fromZIO(loadConfig)\n} \n```\n\n----------------------------------------\n\nTITLE: Catching Specific Defects Using catchAllDefect - Scala\nDESCRIPTION: Shows how to catch and recover from defects (e.g., dieMessage) using catchAllDefect with pattern matching. The handler logs specific defect types and demonstrates how matching works for different Throwables. The operator cannot catch typed failures or fiber interruptions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.dieMessage(\"Boom!\")\n  .catchAllDefect {\n    case e: RuntimeException if e.getMessage == \"Boom!\" =>\n      ZIO.debug(\"Boom! defect caught.\")\n    case _: NumberFormatException =>\n      ZIO.debug(\"NumberFormatException defect caught.\")\n    case _ =>\n      ZIO.debug(\"Unknown defect caught.\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Catching Failures with Execution Trace Using catchAllTrace - Scala\nDESCRIPTION: Shows how to use catchAllTrace to act only on errors at a specific source line, leveraging stack trace inspection for fine-grained recovery or logging. Each caught error provides both the error value and its trace. Inputs are the failure and its stack trace; output is a debug log depending on the line number condition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO\n  .fail(\"Oh uh!\")\n  .catchAllTrace {\n    case (\"Oh uh!\", trace)\n      if trace.toJava\n        .map(_.getLineNumber)\n        .headOption\n        .contains(4) =>\n      ZIO.debug(\"caught a failure on the line number 4\")\n    case _ =>\n      ZIO.debug(\"caught other failures\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Interrupting a Fiber Using Fiber#interrupt in ZIO (Scala)\nDESCRIPTION: This Scala code defines a ZIO application that spawns a fiber to execute a long-running task, then interrupts it and logs the interruption. The example leverages ZIOAppDefault for application structure, ZIO.fiberId for fiber naming, ZIO.debug for logging, and ZIO.sleep for delays. It demonstrates using onInterrupt to respond to interruptions and proper fiber management; outputs are logged to show the interruption event. Required dependency: ZIO (and its runtime), no additional prerequisites.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\nobject MainApp extends ZIOAppDefault {\\n  def task = {\\n    for {\\n      fn <- ZIO.fiberId.map(_.threadName)\\n      _ <- ZIO.debug(s\"$fn starts a long running task\")\\n      _ <- ZIO.sleep(1.minute)\\n      _ <- ZIO.debug(\"done!\")\\n    } yield ()\\n  }\\n\\n  def run =\\n    for {\\n      f <-\\n        task.onInterrupt(\\n          ZIO.debug(s\"Task interrupted while running\")\\n        ).fork\\n      _ <- f.interrupt\\n    } yield ()\\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Gauge Metric to a ZIO Effect in Scala\nDESCRIPTION: This Scala snippet demonstrates defining a ZIO effect (`memoryUsage`) that calculates current Java Runtime memory usage in MB. It utilizes the `@@` operator to apply the `Metric.gauge` aspect, instrumenting the effect to record the computed value under the metric name \"memory_usage\". This requires importing `zio` and `zio.metrics`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent:nest\nimport zio._\nimport zio.metrics._\n\ndef memoryUsage: ZIO[Any, Nothing, Double] = {\n  import java.lang.Runtime._\n  ZIO\n    .succeed(getRuntime.totalMemory() - getRuntime.freeMemory())\n    .map(_ / (1024.0 * 1024.0)) @@ Metric.gauge(\"memory_usage\")\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Complete example of Resource to ZManaged conversion\nDESCRIPTION: Full working example showing how to convert a Cats Effect Resource to ZManaged and use it in a ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.catz._\n\nobject CatsEffectResourceInterop extends CatsApp {\n  def fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n    cats.effect.Resource.make(File.open[F](name))(_.close)\n\n  def myApp: zio.ZIO[Any, Throwable, Unit] = for {\n    c <- fileResource[zio.Task](\"log.txt\").toManaged.use(_.read)\n    _ <- zio.Console.printLine(s\"file content: $c\")\n  } yield ()\n\n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with Untyped Errors in Scala using ZIO\nDESCRIPTION: This snippet demonstrates a file upload function with untyped error handling. It shows how developers might resort to catch-all error logging when error types are not explicitly defined, potentially leading to over-defensive programming.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/logging-errors.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nsealed trait UploadError extends Exception\ncase class FileExist(name: String)          extends UploadError\ncase class FileNotExist(name: String)       extends UploadError\ncase class StorageLimitExceeded(limit: Int) extends UploadError\n\n/**\n * This API fail with `FileExist` failure when the provided file name exist.\n */\ndef upload(name: String): Task[Unit] = {\n    if (...)\n      ZIO.fail(FileExist(name))\n    else if (...)\n      ZIO.fail(StorageLimitExceeded(limit)) // This error is undocumented unintentionally\n    else\n      ZIO.attempt(...)\n}\n\nupload(\"contacts.csv\").catchAll {\n  case FileExist(name) => delete(\"contacts.csv\") *> upload(\"contacts.csv\")\n  case _ =>\n    for {\n      _ <- ZIO.log(error.toString) // logging the error\n      _ <- ZIO.fail(error) // failing again (just like rethrowing exceptions in OOP)\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Bounded Queue in Scala with ZIO\nDESCRIPTION: Demonstrates how to create a bounded queue, offer an item, and take an item from the queue using ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/queue.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval res: UIO[Int] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(1)\n  v1 <- queue.take\n} yield v1\n```\n\n----------------------------------------\n\nTITLE: Initializing Edomata Skunk Backend with ZIO (Scala)\nDESCRIPTION: This snippet wires up the Edomata backend using Skunk (for PostgreSQL), sets up codecs for all data types with Circe, and adapts the network, tracing, and console for ZIO's Task environment. It provides methods for building and compiling the domain backend and defines how to turn an incoming command into a side-effectful service call. Requires Edomata, Skunk, Circe, ZIO, Cats Effect, and related typeclass instances. Inputs are commands, outputs are RIO with EitherNec results; errors are surfaced via Task and can be caught or propagated.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.duration.*\nimport cats.effect.std.Console\nimport cats.effect.{Async, Concurrent, Resource}\nimport cats.data.EitherNec\nimport edomata.core.{CommandMessage, DomainService}\nimport edomata.skunk.{BackendCodec, CirceCodec, SkunkBackend}\nimport edomata.backend.Backend\nimport edomata.skunk.SkunkBackend.PartialBuilder\nimport edomata.syntax.all.liftTo\nimport fs2.io.net.Network\nimport skunk.Session\nimport io.circe.generic.auto.*\nimport natchez.Trace\nimport natchez.Trace.Implicits.noop\nimport zio.*\nimport zio.interop.catz.*\n\nobject BackendService {\n  given BackendCodec[Event] = CirceCodec.jsonb // or .json\n  given BackendCodec[Notification] = CirceCodec.jsonb\n  given BackendCodec[Counter] = CirceCodec.jsonb\n  given Network[Task] = Network.forAsync[Task]\n  given Trace[Task] = Trace.Implicits.noop\n  given Console[Task] = Console.make[Task]\n\n  def backend =\n    SkunkBackend(\n      Session\n        .single(\"localhost\", 5432, \"postgres\", \"postgres\", Some(\"postgres\"))\n    )\n\n  def buildBackend =\n    backend\n      .builder(CounterService, \"counter\")\n      .withRetryConfig(retryInitialDelay = 2.seconds)\n      .persistedSnapshot(200)\n      .build\n      .toScopedZIO\n\n  type Service = CommandMessage[Command] => RIO[Scope, EitherNec[String, Unit]]\n\n  def service: ZIO[Scope, Throwable, Service] =\n    buildBackend\n      .map(_.compile(CounterService().liftTo[Task]))\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Using Services from ZEnvironment in a ZIO App (Scala)\nDESCRIPTION: Shows how to access a service managed by `ZEnvironment` within a ZIO application (`ZIOAppDefault`). It retrieves the `Editor` service instance from the `environment` using `environment.get[Editor]` and then calls its `formatAndCompile` method as part of the application's main logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nobject MainApp extends ZIOAppDefault {\n  def run = \n    environment.get[Editor].formatAndCompile(\"println(\\\"Hello, world!\\\")\")\n}\n```\n```\n\n----------------------------------------\n\nTITLE: S3 Operations with ZIO S3\nDESCRIPTION: Example of using ZIO S3 to interact with S3-compatible object storage. It demonstrates creating a bucket, uploading a JSON object, and retrieving the object with streaming.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nimport software.amazon.awssdk.auth.credentials.AwsBasicCredentials\nimport software.amazon.awssdk.regions.Region\nimport zio.console.putStrLn\nimport zio.s3._\nimport zio.stream.{ZStream, ZTransducer}\nimport zio.{Chunk, ExitCode, URIO}\n\nimport java.net.URI\n\nobject ZIOS3Example extends zio.App {\n\n  val myApp = for {\n    _ <- createBucket(\"docs\")\n    json = Chunk.fromArray(\"{\\\"id\\\" : 1 , \\\"name\\\" : \\\"A1\\\"}\".getBytes)\n    _ <- putObject(\n      bucketName = \"docs\",\n      key = \"doc1\",\n      contentLength = json.length,\n      content = ZStream.fromChunk(json),\n      options = UploadOptions.fromContentType(\"application/json\")\n    )\n    _ <- getObject(\"docs\", \"doc1\")\n      .transduce(ZTransducer.utf8Decode)\n      .foreach(putStrLn(_))\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp\n      .provideCustomLayer(\n        live(\n          Region.CA_CENTRAL_1,\n          AwsBasicCredentials.create(\"MyKey\", \"MySecret\"),\n          Some(URI.create(\"http://localhost:9000\"))\n        )\n      )\n      .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Data Models in Scala\nDESCRIPTION: Definition of Employee data model and Role enumeration using case classes and sealed traits\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Employee(name: String, role: Role)\n\nsealed trait Role\nobject Role {\n  case object SoftwareDeveloper       extends Role\n  case object SiteReliabilityEngineer extends Role\n  case object DevOps                  extends Role\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom HostPorts Config in Scala ZIO Application\nDESCRIPTION: This snippet shows how to use the custom HostPorts configuration in a ZIO application. It reads the config and prints each HostPort entry.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/configuration/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  config <- ZIO.config[HostPorts]\n  _      <- Console.printLine(s\"Application started with:\")\n  _      <- ZIO.foreachDiscard(config.hostPorts)(e => Console.printLine(s\"  - http://${e.host}:${e.port}\"))\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Reading File Contents Using ZIO Streams\nDESCRIPTION: This snippet shows how to achieve the same functionality as the previous example using ZIO streams. It can handle files of any size efficiently by processing the file in a streaming manner.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nZStream.fromFile(Paths.get(\"file.txt\"))\n  .transduce(ZTransducer.utf8Decode >>> ZTransducer.splitLines)\n  .foreach(putStrLn(_))\n```\n\n----------------------------------------\n\nTITLE: Implementing ZLayers for Counter, Formatter, Compiler, and Editor\nDESCRIPTION: Comprehensive example of implementing ZLayers for Counter, Formatter, Compiler, and Editor classes, demonstrating effectful constructors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ncase class Counter(ref: Ref[Int]) {\n  def inc: UIO[Unit] = ref.update(_ + 1)\n  def dec: UIO[Unit] = ref.update(_ - 1)\n  def get: UIO[Int]  = ref.get\n}\n\nobject Counter {\n  val layer: ZLayer[Any, Nothing, Counter] = \n    ZLayer {\n      Ref.make(0).map(new Counter(_))\n    }\n}\n\nclass Formatter {\n  def format(code: String): UIO[String] = ???\n}\n\nobject Formatter {\n  val layer: ZLayer[Any, Nothing, Formatter] =\n    ZLayer.succeed(new Formatter())\n}\n\nclass Compiler {\n  def compile(code: String): UIO[String] = ???\n}\n\nobject Compiler {\n  val layer: ZLayer[Any, Nothing, Compiler] = \n    ZLayer.succeed(new Compiler())\n}\n\nclass Editor(formatter: Formatter, compiler: Compiler, counter: Counter) {\n  def formatAndCompile(code: String): UIO[String] = ???\n}\n\nobject Editor {\n  val layer: ZLayer[Formatter with Compiler with Counter, Nothing, Editor] =\n    ZLayer {\n      for {\n        formatter <- ZIO.service[Formatter]\n        compiler  <- ZIO.service[Compiler]\n        counter   <- ZIO.service[Counter]\n      } yield new Editor(formatter, compiler, counter) \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZIO.acquireReleaseWith Execution Flow in Scala\nDESCRIPTION: Illustrates the guaranteed execution order of `ZIO.acquireReleaseWith` within a `ZIOAppDefault`. It uses `ZIO.succeed` for a simple string resource and `ZIO.debug` to trace the flow. The output confirms that the `acquire` effect runs first ('resource acquired'), followed by the `use` effect ('start using resource'), and finally the `release` effect is executed ('resource released'), demonstrating the guaranteed cleanup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO.acquireReleaseWith {\n      ZIO.succeed(\"resource\").tap(r => ZIO.debug(s\"$r acquired\"))\n    } { i =>\n      ZIO.debug(s\"$i released\")\n    } { i =>\n      ZIO.debug(s\"start using $i\")\n    }\n}\n// Output:\n// resource acquired\n// start using resource\n// resource released\n```\n\n----------------------------------------\n\nTITLE: Simplified Pipeline with ZIO Streams\nDESCRIPTION: Streamlined implementation using ZIO Streams, showing how to create a processing pipeline with proper buffering and resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef generateElement: Task[Int]    = ZIO.succeed(???)\ndef process(i: Int): Task[Int]    = ZIO.succeed(???)\ndef printElem(i: Int): Task[Unit] = ZIO.succeed(???)\n\nZStream\n  .repeatZIO(generateElement)\n  .buffer(16)\n  .mapZIO(process(_))\n  .buffer(16)\n  .mapZIO(process(_))\n  .buffer(16)\n  .tap(printElem(_))\n```\n\n----------------------------------------\n\nTITLE: Handling Blocking Synchronous Code with ZIO in Scala\nDESCRIPTION: Shows how to handle blocking synchronous code using ZIO.blocking, ZIO.attemptBlocking, and ZIO.attemptBlockingCancelable. These methods ensure that blocking operations are executed on a dedicated thread pool for optimal performance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/creating-effects.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef safeDownload(url: String) =\n  ZIO.blocking(download(url))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval sleeping =\n  ZIO.attemptBlocking(Thread.sleep(Long.MaxValue))\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef accept(l: ServerSocket) =\n  ZIO.attemptBlockingCancelable(l.accept())(ZIO.succeed(l.close()))\n```\n\n----------------------------------------\n\nTITLE: Setting Scoped Log Levels with ZIO FiberRef in Scala\nDESCRIPTION: This snippet illustrates how log levels in ZIO are managed using `FiberRef`. The `ZIO.logLevel` operator is used to temporarily change the logging level (to `LogLevel.Trace` in this case) for a specific region of code. Logs within this region respect the new level, while logs outside retain the previous level.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nfor {\n  _ <- ZIO.log(\"Application started!\")\n  _ <- ZIO.logLevel(LogLevel.Trace) {\n    for {\n      _ <- ZIO.log(\"Entering trace log level region\")\n      _ <- ZIO.log(\"Doing something\")\n      _ <- ZIO.log(\"Leaving trace log level region\")\n    } yield ()\n  }\n  _ <- ZIO.log(\"Application ended!\")\n} yield ()\n```\n```\n\n----------------------------------------\n\nTITLE: Writing Application Logic Using Services\nDESCRIPTION: Creates a ZIO application that uses the service interfaces A and C. The application retrieves the services from the environment using ZIO.service and calls their methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval myApp: ZIO[A with C, Nothing, Unit] =\n  for {\n    a <- ZIO.service[A]\n    _ <- a.foo\n    c <- ZIO.service[C]\n    _ <- c.baz\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Slick Interop for Database Operations in Scala\nDESCRIPTION: This comprehensive example demonstrates how to create a database-agnostic Slick repository using ZIO Slick Interop. It includes database configuration, table definition, repository implementation, and a main application that uses the repository.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-slick-interop.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport com.typesafe.config.ConfigFactory\nimport slick.interop.zio.DatabaseProvider\nimport slick.interop.zio.syntax._\nimport slick.jdbc.H2Profile.api._\nimport slick.jdbc.JdbcProfile\nimport zio.console.Console\nimport zio.interop.console.cats.putStrLn\nimport zio.{ExitCode, IO, URIO, ZEnvironment, ZIO, ZLayer}\n\nimport scala.jdk.CollectionConverters._\n\ncase class Item(id: Long, name: String)\n\ntrait ItemRepository {\n  def add(name: String): IO[Throwable, Long]\n\n  def getById(id: Long): IO[Throwable, Option[Item]]\n\n  def upsert(name: String): IO[Throwable, Long]\n}\n\nobject ItemsTable {\n  class Items(tag: Tag) extends Table[Item](\n    _tableTag = tag,\n    _tableName = \"ITEMS\"\n  ) {\n    def id = column[Long](\"ID\", O.PrimaryKey, O.AutoInc)\n\n    def name = column[String](\"NAME\")\n\n    def * = (id, name) <> ((Item.apply _).tupled, Item.unapply _)\n  }\n\n  val table = TableQuery[ItemsTable.Items]\n}\n\nobject SlickItemRepository {\n  val live: ZLayer[DatabaseProvider, Throwable, ItemRepository] =\n    ZLayer.fromServiceM { db =>\n      db.profile.flatMap { profile =>\n        import profile.api._\n\n        val initialize = ZIO.fromDBIO(ItemsTable.table.schema.createIfNotExists)\n\n        val repository = new ItemRepository {\n          private val items = ItemsTable.table\n\n          def add(name: String): IO[Throwable, Long] =\n            ZIO\n              .fromDBIO((items returning items.map(_.id)) += Item(0L, name))\n              .provideEnvironment(ZEnvironment(db))\n\n          def getById(id: Long): IO[Throwable, Option[Item]] = {\n            val query = items.filter(_.id === id).result\n\n            ZIO.fromDBIO(query).map(_.headOption).provideEnvironment(ZEnvironment(db))\n          }\n\n          def upsert(name: String): IO[Throwable, Long] =\n            ZIO\n              .fromDBIO { implicit ec =>\n                (for {\n                  itemOpt <- items.filter(_.name === name).result.headOption\n                  id <- itemOpt.fold[DBIOAction[Long, NoStream, Effect.Write]](\n                    (items returning items.map(_.id)) += Item(0L, name)\n                  )(item => (items.map(_.name) update name).map(_ => item.id))\n                } yield id).transactionally\n              }\n              .provideEnvironment(Environment(db))\n        }\n\n        initialize.as(repository).provideEnvironment(Environment(db))\n      }\n    }\n}\n\n\nobject Main extends zio.App {\n\n  private val config = ConfigFactory.parseMap(\n    Map(\n      \"url\" -> \"jdbc:h2:mem:test1;DB_CLOSE_DELAY=-1\",\n      \"driver\" -> \"org.h2.Driver\",\n      \"connectionPool\" -> \"disabled\"\n    ).asJava\n  )\n\n  private val env: ZLayer[Any, Throwable, ItemRepository] =\n    (ZLayer.succeed(config) ++ ZLayer.succeed[JdbcProfile](\n      slick.jdbc.H2Profile\n    )) >>> DatabaseProvider.live >>> SlickItemRepository.live\n\n  val myApp: ZIO[Console with Has[ItemRepository], Throwable, Unit] =\n    for {\n      repo <- ZIO.service[ItemRepository]\n      aId1 <- repo.add(\"A\")\n      _ <- repo.add(\"B\")\n      a <- repo.getById(1L)\n      b <- repo.getById(2L)\n      aId2 <- repo.upsert(\"A\")\n      _ <- putStrLn(s\"$aId1 == $aId2\")\n      _ <- putStrLn(s\"A item: $a\")\n      _ <- putStrLn(s\"B item: $b\")\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideCustom(env).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Sidecar Pattern with Bootstrap Layer in Scala ZIO\nDESCRIPTION: This snippet shows how to implement the sidecar pattern using the bootstrap layer in ZIO. It defines a MetricsService that sets up a Prometheus metrics exporter, which is then used as a bootstrap layer in the main application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/architectural-patterns.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http._\nimport zio.metrics.connectors.prometheus.PrometheusPublisher\nimport zio.metrics.connectors.{MetricsConfig, prometheus}\n\nobject MetricsService {\n  private val metricsConfig = ZLayer.succeed(MetricsConfig(5.seconds))\n\n  private val exporter: ZLayer[PrometheusPublisher, Nothing, Unit] =\n    ZLayer.fromZIO {\n      Server\n        .serve(\n          Routes(Method.GET / \"metrics\" ->\n            handler(ZIO.serviceWithZIO[PrometheusPublisher](_.get.map(Response.text)))\n          )\n        )\n        .provideSome[PrometheusPublisher](Server.defaultWithPort(8081))\n        .forkDaemon\n        .unit\n    }\n\n  val layer: ZLayer[Any, Nothing, Unit] =\n    ZLayer.make[Unit](\n      exporter,\n      metricsConfig,\n      prometheus.publisherLayer,\n      prometheus.prometheusLayer\n    )\n\n}\n\nobject UserAoo extends ZIOAppDefault {\n  override val bootstrap = MetricsService.layer\n\n  def run = Server.serve(userHttpApp).provideSome(Server.defaultWithPort(8080))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Thread-Safe Counter with Ref in ZIO\nDESCRIPTION: Example of implementing a thread-safe counter using Ref. The Counter class encapsulates operations for incrementing, decrementing, and retrieving the counter value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/global-shared-state.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Counter(value: Ref[Int]) {\n  def inc: UIO[Unit] = value.update(_ + 1)\n  def dec: UIO[Unit] = value.update(_ - 1)\n  def get: UIO[Int] = value.get\n}\n\nobject Counter {\n  def make: UIO[Counter] = Ref.make(0).map(Counter(_))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Blocking Effects with effectBlocking in Scala ZIO\nDESCRIPTION: This snippet shows how to properly create blocking effects using ZIO's dedicated blocking thread pool. It uses the effectBlocking operator to run blocking operations on the appropriate thread pool.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/blocking.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.blocking._\ndef blockingTask(n: Int) = effectBlocking {\n  do {\n    println(s\"Running blocking task number $n on dedicated blocking thread pool\")\n    Thread.sleep(3000) \n  } while (true)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Logger with Clock Service in ZIO 2.0\nDESCRIPTION: Improved implementation of the Logger service in ZIO 2.0 where the Clock service now includes retry operations, eliminating the need to explicitly provide the Clock environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_81\n\nLANGUAGE: scala\nCODE:\n```\ncase class JournalLoggerLive(clock: Clock, journal: Journal) extends Logger {\n  override def log(line: String): UIO[Unit] = {\n    for {\n      current <- clock.currentDateTime\n      _       <- journal.append(s\"$current--$line\").retry(Schedule.exponential(2.seconds)).orDie\n    } yield ()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Different Types of Queues in Scala with ZIO\nDESCRIPTION: Shows how to create bounded, dropping, sliding, and unbounded queues using ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/queue.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval boundedQueue: UIO[Queue[Int]] = Queue.bounded[Int](100)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval droppingQueue: UIO[Queue[Int]] = Queue.dropping[Int](100)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval slidingQueue: UIO[Queue[Int]] = Queue.sliding[Int](100)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval unboundedQueue: UIO[Queue[Int]] = Queue.unbounded[Int]\n```\n\n----------------------------------------\n\nTITLE: AutoCloseable Resource Management\nDESCRIPTION: Examples of creating ZManaged resources from AutoCloseable instances.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nZManaged.fromAutoCloseable(ZIO.effect(new FileInputStream(\"file.txt\")))\n// res1: ZManaged[Any, Throwable, FileInputStream] = zio.ZManaged$$anon$2@19dd8c22\nZManaged.fromAutoCloseable(ZIO.effect(fromResource(\"file.txt\")))\n// res2: ZManaged[Any, Throwable, scala.io.BufferedSource] = zio.ZManaged$$anon$2@60c09e2e\nZManaged.fromAutoCloseable(ZIO.effect(fromFile(\"file.txt\")))\n// res3: ZManaged[Any, Throwable, scala.io.BufferedSource] = zio.ZManaged$$anon$2@210bd8dd\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO Application with Multiple Layers\nDESCRIPTION: Demonstrates how to create a ZIO application with multiple configuration layers including ServerConfig, DBConfig, and AppConfig. The example shows how to compose these layers and provide them to the main application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/examples.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class ServerConfig(host: String, port: Int)\nobject ServerConfig {\n  val layer: ULayer[ServerConfig] =\n    ZLayer.succeed(ServerConfig(\"localhost\", 8080))\n}\n\ncase class DBConfig(name: String)\nobject DBConfig {\n  val layer: ULayer[DBConfig] =\n    ZLayer.succeed(DBConfig(\"my-test-db\"))\n}\n\ncase class AppConfig(db: DBConfig, serverConfig: ServerConfig)\nobject AppConfig {\n  val layer: ZLayer[DBConfig with ServerConfig, Nothing, AppConfig] =\n    ZLayer {\n      for {\n        db     <- ZIO.service[DBConfig]\n        server <- ZIO.service[ServerConfig]\n      } yield AppConfig(db, server)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      c <- ZIO.service[AppConfig]\n      _ <- ZIO.debug(s\"Application started with config: ${c}\")\n    } yield ()\n\n  def run = myApp.provide(AppConfig.layer, DBConfig.layer, ServerConfig.layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ref.modify using Compare-and-Set in Scala\nDESCRIPTION: This code snippet demonstrates how ZIO implements the modify function for Ref using a lock-free, compare-and-set approach. It repeatedly attempts to update the value atomically until successful.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Ref[A](value: AtomicReference[A]) { self =>\n  def modify[B](f: A => (B, A)): UIO[B] = ZIO.succeed {\n    var loop = true\n    var b: B = null.asInstanceOf[B]\n    while (loop) {\n      val current = value.get\n      val tuple   = f(current)\n      b = tuple._1\n      loop = !value.compareAndSet(current, tuple._2)\n    }\n    b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ZEnvironment with Built-in Services in Scala\nDESCRIPTION: This snippet demonstrates how to create a ZEnvironment containing all built-in ZIO services (Console, Clock, Random, and System) with their live implementations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval environment: ZEnvironment[Console & Clock & Random & System] =\n  ZEnvironment[Console, Clock, Random, System](\n    Console.ConsoleLive,\n    Clock.ClockLive,\n    Random.RandomLive,\n    System.SystemLive\n  )\n```\n\n----------------------------------------\n\nTITLE: Basic ZIO Application with Environment Access\nDESCRIPTION: Demonstrates a basic ZIO application that uses environment to access and manipulate document repository services, including saving, retrieving, and deleting documents.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val app =\n    for {\n      id <-\n        ZIO.serviceWithZIO[DocRepo](_.save(\n          Doc(\n              \"How to write a ZIO application?\",\n              \"In this tutorial we will learn how to write a ZIO application.\",\n              \"en\",\n              \"text/plain\",\n              \"content\".getBytes()\n            )\n          )\n        )\n      doc <- ZIO.serviceWithZIO[DocRepo](_.get(id))\n      _ <- Console.printLine(\n        s\"\"\"\n          |Downloaded the document with $id id:\n          |  title: ${doc.title}\n          |  description: ${doc.description}\n          |  language: ${doc.language}\n          |  format: ${doc.format}\n          |\"\"\".stripMargin\n      )\n      _ <- ZIO.serviceWithZIO[DocRepo](_.delete(id))\n      _ <- Console.printLine(s\"Deleted the document with $id id\")\n    } yield ()\n\n  def run =\n    app.provide(\n      DocRepoImpl.layer,\n      InmemoryBlobStorage.layer,\n      InmemoryMetadataRepo.layer\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Stream Elements with ZSink in Scala\nDESCRIPTION: Demonstrates how to use ZSink to consume and sum elements from a ZStream. Creates a stream of integers from 1 to 1000 and uses ZSink.sum to calculate their sum.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nval stream = ZStream.fromIterable(1 to 1000)\nval sink   = ZSink.sum[Int]\nval sum    = stream.run(sink)\n```\n\n----------------------------------------\n\nTITLE: Concurrent State Management with Ref in ZIO\nDESCRIPTION: Example showing how Ref can be used to manage state concurrently across multiple fibers. One fiber reads names from the console while another adds predefined names at regular intervals.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/global-shared-state.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef getNames: ZIO[Any, String, List[String]] =\n  for {\n    ref <- Ref.make(List.empty[String])\n    f1 <- Console\n      .readLine(\"Please enter a name or 'q' to exit: \")\n      .orDie\n      .repeatWhileZIO {\n        case \"q\"  => ZIO.succeed(false)\n        case name => ref.update(_ appended name).as(true)\n      }.fork \n      f2 <- ZIO.foreachDiscard(Seq(\"John\", \"Jane\", \"Joe\", \"Tom\")) { name =>\n        ref.update(_ appended name) *> ZIO.sleep(1.second)\n      }\n      .fork\n    _ <- f1.join\n    _ <- f2.join\n    v <- ref.get\n  } yield v\n```\n\n----------------------------------------\n\nTITLE: Implementing Age Validation with ZIO's Declarative Error Handling\nDESCRIPTION: Demonstrates declarative error handling using ZIO, defining custom error types and a validation function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] =\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#timeout with Successful Completion in Scala\nDESCRIPTION: Demonstrates the `ZIO#timeout` operator applied to the `myApp` effect with a 3-second timeout. Since the effect completes within 2 seconds (before the timeout), the resulting effect succeeds with `Some(\"result\")`. The example also includes timing the execution to show it takes approximately 2 seconds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/timing-out.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .timeout(3.second)\n      .debug(\"output\")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug(\"execution time of the whole program in second\")\n}\n\n// Output:\n// start doing something.\n// my job is finished!\n// output: Some(result)\n// execution time of the whole program in second: 2\n```\n```\n\n----------------------------------------\n\nTITLE: Chaining ZIO Effects with flatMap\nDESCRIPTION: Demonstrates sequencing ZIO effects using flatMap, where the second effect can depend on the result of the first. This is the fundamental building block for composing complex effect sequences.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval chainedActionsValue: UIO[List[Int]] = ZIO.succeed(List(1, 2, 3)).flatMap { list =>\n  ZIO.succeed(list.map(_ + 1))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Semaphore using Ref in ZIO (Scala)\nDESCRIPTION: Shows how to build a basic semaphore abstraction using ZIO's Ref to manage shared state. The S trait defines P (acquire) and V (release) operations, which are managed atomically on the internal counter. P retries acquisition if the value is negative or changed, ensuring thread safety. Dependencies: ZIO Ref, UIO, and ZIO environment. Input: initial semaphore count; Output: S instance with safe acquire/release. Limitations: naive spinning and not production-optimized.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait S {\n  def P: UIO[Unit]\n  def V: UIO[Unit]\n}\n\nobject S {\n  def apply(v: Long): UIO[S] =\n    Ref.make(v).map { vref =>\n      new S {\n        def V = vref.update(_ + 1).unit\n\n        def P = (vref.get.flatMap { v =>\n          if (v < 0)\n            ZIO.fail(())\n          else\n            vref.modify(v0 => if (v0 == v) (true, v - 1) else (false, v)).flatMap {\n              case false => ZIO.fail(())\n              case true  => ZIO.unit\n            }\n        } <> P).unit\n      }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Switching AppConfig Implementation in ZIO MainApp Scala (Diff)\nDESCRIPTION: Illustrates changing the dependency injection for the `AppConfig` service in a ZIO Scala application. This diff shows replacing the `appArgsLayer` (command-line args) with `systemEnvLayer` (environment variables) using the `provide` method in the `MainApp`'s `run` definition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md#2025-04-23_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[AppConfig, Nothing, Unit] =\n    for {\n      poolSize <- AppConfig.poolSize\n      _        <- ZIO.debug(s\"Application started with $poolSize pool size.\")\n    } yield ()\n\n-  def run = myApp.provideSome[ZIOAppArgs](AppConfig.appArgsLayer)\n+  def run = myApp.provide(AppConfig.systemEnvLayer)\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Creating ZIO ConcurrentMap Instances in Scala\nDESCRIPTION: This snippet demonstrates different ways to create ConcurrentMap instances using ZIO. It shows creating an empty map, creating from an iterable, and creating with initial key-value pairs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/concurrentmap.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.ConcurrentMap\nimport zio.{Chunk, ZIO}\n\nfor {\n  emptyMap <- ConcurrentMap.empty[Int, String]\n  data     <- ZIO.succeed(Chunk(1 -> \"A\", 2 -> \"B\", 3 -> \"C\"))\n  mapA     <- ConcurrentMap.fromIterable(data)\n  map100   <- ConcurrentMap.make(1 -> 100)\n  mapB     <- ConcurrentMap.make((\"A\", 1), (\"B\", 2), (\"C\", 3))\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Supervising a ZIO Effect Using Supervisor (Scala)\nDESCRIPTION: This snippet illustrates attaching a Supervisor to a ZIO effect using the supervised combinator, which enables monitoring of all child fibers spawned during the effect's execution. It uses flatMap to supply the Supervisor at runtime, supervises the computation, and supports later introspection. The snippet assumes Supervisor and an example effect (fib) are in scope. Input is a Supervisor and the effect to be supervised; output is a supervised effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/supervisor.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\ndef fib(n: Int): ZIO[Any, Nothing, Int] = ???\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval supervised = supervisor.flatMap(s => fib(20).supervised(s))\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retry with a Schedule in Scala\nDESCRIPTION: Demonstrates using the `retry` method on a ZIO effect (`readFile`). The effect is retried up to 5 times upon failure, controlled by `Schedule.recurs(5)`. This requires the ZIO library and assumes a `readFile` function is defined.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval retriedOpenFile: ZIO[Any, IOException, Array[Byte]] =\n  readFile(\"primary.data\").retry(Schedule.recurs(5))\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Input and Output with Dimap in Scala ZIO\nDESCRIPTION: This example shows how to use the dimap operation to transform both the input and output of a ZSink. It converts String inputs to integers, performs a sum operation, and then converts the result back to a String.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/operations.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\n// Convert its input to integers, do the computation and then convert them back to a string\nval sumSink: ZSink[Any, Nothing, String, Nothing, String] =\n  numericSum.dimap[String, String](_.toInt, _.toString)\n  \nval sum: ZIO[Any, Nothing, String] =\n  ZStream(\"1\", \"2\", \"3\", \"4\", \"5\").run(sumSink)\n// Output: 15\n```\n\n----------------------------------------\n\nTITLE: Consuming Items from a Queue in Scala with ZIO\nDESCRIPTION: Shows various methods to consume items from a queue, including take, poll, takeUpTo, and takeAll operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/queue.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval oldestItem: UIO[String] = for {\n  queue <- Queue.bounded[String](100)\n  f <- queue.take.fork // will be suspended because the queue is empty\n  _ <- queue.offer(\"something\")\n  v <- f.join\n} yield v\n```\n\nLANGUAGE: scala\nCODE:\n```\nval polled: UIO[Option[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(10)\n  _ <- queue.offer(20)\n  head <- queue.poll\n} yield head\n```\n\nLANGUAGE: scala\nCODE:\n```\nval taken: UIO[Chunk[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(10)\n  _ <- queue.offer(20)\n  chunk  <- queue.takeUpTo(5)\n} yield chunk\n```\n\nLANGUAGE: scala\nCODE:\n```\nval all: UIO[Chunk[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(10)\n  _ <- queue.offer(20)\n  chunk  <- queue.takeAll\n} yield chunk\n```\n\n----------------------------------------\n\nTITLE: Automatic Layer Construction for ZIO Dependency Graph in Scala\nDESCRIPTION: This code snippet shows how to use ZIO's automatic layer construction feature. It uses the 'provide' method to automatically create the dependency graph at compile-time, simplifying the process of managing dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/building-dependency-graph.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval res: ZIO[Any, Throwable, Unit] =\n  myApp.provide(\n    Logging.live,\n    Database.live,\n    BlobStorage.live,\n    DocRepo.live,\n    UserRepo.live\n  )\n```\n\n----------------------------------------\n\nTITLE: Converting ZManaged to Cats Effect Resource\nDESCRIPTION: Complete example showing how to convert a ZIO ZManaged resource to a Cats Effect Resource and use it in a Cats Effect application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.catz._\n\nobject ZManagedToResource extends cats.effect.IOApp {\n  implicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\n\n  val resource: cats.effect.Resource[cats.effect.IO, java.io.InputStream] =\n    zio.ZManaged\n      .fromAutoCloseable(\n        zio.ZIO.effect(\n          java.nio.file.Files.newInputStream(\n            java.nio.file.Paths.get(\"file.txt\")\n          )\n        )\n      )\n      .toResource[cats.effect.IO]\n\n  val effect: cats.effect.IO[Unit] =\n    resource\n      .use { is =>\n        cats.effect.IO.delay(is.readAllBytes())\n      }\n      .flatMap(bytes =>\n        cats.effect.IO.delay(\n          println(s\"file length: ${bytes.length}\")\n        )\n      )\n\n  override def run(args: List[String]): cats.effect.IO[cats.effect.ExitCode] =\n    effect.as(cats.effect.ExitCode.Success)\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Layer Assembly Using ZLayer.make\nDESCRIPTION: This snippet demonstrates how to use ZLayer.make to automatically assemble layers for a given type. It shows examples for creating a Cake layer and a combined Chocolate & Flour layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/automatic-layer-construction.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval cakeLayer: ZLayer[Any, Nothing, Cake] =\n  ZLayer.make[Cake](\n    Cake.live,\n    Chocolate.live,\n    Flour.live,\n    Spoon.live\n  )\n\nval chocolateAndFlourLayer: ZLayer[Any, Nothing, Chocolate & Flour] =\n  ZLayer.make[Chocolate & Flour](\n    Chocolate.live,\n    Flour.live,\n    Spoon.live\n  )\n```\n\n----------------------------------------\n\nTITLE: Generic Resource Management with ZIO AcquireRelease\nDESCRIPTION: Example showing the structure of ZIO's acquireRelease pattern for generic resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef use(resource: Resource): Task[Any] = ZIO.attempt(???)\ndef release(resource: Resource): UIO[Unit] = ZIO.succeed(???)\ndef acquire: Task[Resource] = ZIO.attempt(???)\n\nval result: Task[Any] = ZIO.acquireReleaseWith(acquire)(release)(use)\n```\n\n----------------------------------------\n\nTITLE: Simple CyclicBarrier Synchronization Example\nDESCRIPTION: Shows how to synchronize three tasks using a CyclicBarrier with random delays.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/cyclicbarrier.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent.CyclicBarrier\n\nobject MainApp extends ZIOAppDefault {\n  def task(name: String) =\n    for {\n      b <- ZIO.service[CyclicBarrier]\n      _ <- ZIO.debug(s\"task-$name: started my job right now!\")\n      d <- Random.nextLongBetween(1000, 10000)\n      _ <- ZIO.sleep(Duration.fromMillis(d))\n      _ <- ZIO.debug(s\"task-$name: finished my job and waiting for other parties to finish their jobs\")\n      _ <- b.await \n      _ <- ZIO.debug(s\"task-$name: the barrier is now broken, so I'm going to exit immediately!\")\n    } yield ()\n\n  def run =\n    for {\n      b    <- CyclicBarrier.make(3)\n      tasks = task(\"1\") <&> task(\"2\") <&> task(\"3\")\n      _    <- tasks.provide(ZLayer.succeed(b))\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Layer from Non-Resourceful Effect (Scala)\nDESCRIPTION: Uses a for-comprehension and ZLayer.apply to provide dependencies (A, B) and produce a composite service implementation (C). Dependencies required: ZIO, service traits. Output is a ZLayer with required inputs A and B resolved to C.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait A\ntrait B\ntrait C\ncase class CLive(a: A, b: B) extends C\n\nobject CLive {\n  val layer: ZLayer[A & B, Nothing, C] =\n    ZLayer {\n      for {\n        a <- ZIO.service[A]\n        b <- ZIO.service[B]\n      } yield CLive(a, b)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining ZIO Effects Sequentially with zip in Scala\nDESCRIPTION: Shows how to combine two ZIO effects sequentially using the `ZIO#zip` method. It executes `ZIO.succeed(\"4\")` followed by `ZIO.succeed(2)`. If both succeed, the resulting effect `zipped` succeeds with a tuple containing both success values (`(\"4\", 2)`). If either effect fails, the combined effect fails. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_operations.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval zipped: UIO[(String, Int)] = \n  ZIO.succeed(\"4\").zip(ZIO.succeed(2))\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parallel Failures in ZIO (Scala)\nDESCRIPTION: This Scala code defines a ZIO application that executes two failing effects (`ZIO.fail`) in parallel using the `<&>` combinator. This setup leads to multiple potential errors occurring concurrently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.fail(\"Oh!\") <&> ZIO.fail(\"Uh!\")\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Lifting ZIO Queue to Cats Effect IO with Dispatcher (Cats Effect 3.x, Scala)\nDESCRIPTION: This example demonstrates creation and manipulation of a ZIO Queue within Cats Effect 3.x by providing a cats.effect.std.Dispatcher and necessary runtime implicits. It creates a bounded queue, offers values, takes all, and prints the result using IO app structure. Requires cats.effect.IO, cats.effect.std.Dispatcher, zio.Runtime, execution context, and interop-cats queues. Limitations include requirement for dispatcher allocation. Inputs are queue size and values, output is printed queue state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.Queue\n\nobject ZioQueueInteropWithCats extends scala.App {\n\n  implicit val ceRuntime: cats.effect.unsafe.IORuntime =\n    cats.effect.unsafe.IORuntime.global\n\n  implicit val zioRuntime: zio.Runtime[Any] =\n    zio.Runtime.default\n\n  implicit val ec: scala.concurrent.ExecutionContextExecutor =\n    scala.concurrent.ExecutionContext.global\n\n  implicit val dispatcher: cats.effect.std.Dispatcher[cats.effect.IO] =\n    cats.effect.std\n      .Dispatcher[cats.effect.IO]\n      .allocated\n      .unsafeRunSync()\n      ._1\n\n  def liftedToIO: cats.effect.IO[List[Int]] = for {\n    q <- Queue.bounded[cats.effect.IO, Int](100)\n    _ <- q.offer(1)\n    _ <- q.offer(2)\n    r <- q.takeAll\n  } yield (r)\n\n  val catsApp = liftedToIO\n    .flatMap { e =>\n      cats.effect.IO.println(s\"List of elements retrieved from Queue: $e\")\n    }\n    .as(cats.effect.ExitCode.Success)\n\n  catsApp.unsafeRunSync()\n}\n```\n\n----------------------------------------\n\nTITLE: Managing ZIO Environment Scopes with FiberRef in Scala\nDESCRIPTION: This code demonstrates how ZIO uses `FiberRef` internally to manage the environment. Accessing a service (`ZIO.service[String]`) retrieves the value from the current environment. Using `provide` locally overrides the environment for the wrapped effect, showcasing how `FiberRef` allows for scoped environment modifications. The output confirms that the environment changes within the `provide` scope and reverts afterward.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  private val fooLayer = ZLayer.succeed(\"foo\")\n  private val barLayer = ZLayer.succeed(\"bar\") \n  \n  def run =\n    (for {\n      _ <- ZIO.service[String].debug(\"context\")\n      _ <- ZIO.service[String].debug(\"context\").provide(barLayer)\n      _ <- ZIO.service[String].debug(\"context\")\n    } yield ()).provide(fooLayer)\n}\n// Output:\n// context: foo\n// context: bar\n// context: foo\n```\n```\n\n----------------------------------------\n\nTITLE: Recovering from Defects with catchAllCause in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates the use of ZStream#catchAllCause to recover from all types of failures, including defects. The example shows how to handle a stream that dies with an error message by switching to an alternative stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3) ++ ZStream.dieMessage(\"Oh! Boom!\") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\n\nval stream = s1.catchAllCause(_ => s2)\n// Output: 1, 2, 3, 7, 8, 9\n```\n\n----------------------------------------\n\nTITLE: Catching Specific Errors in ZIO (Scala)\nDESCRIPTION: Demonstrates the use of `catchSome` to catch and recover from specific types of exceptions. This allows for targeted error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nval data: IO[IOException, Array[Byte]] =\n  readFile(\"primary.data\").catchSome {\n    case _ : FileNotFoundException =>\n      readFile(\"backup.data\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Ensuring for Post-Finalization Actions in Scala\nDESCRIPTION: This snippet demonstrates how to use the 'ensuring' operator to execute additional code after the stream's finalization has completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/resourceful-streams.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nZStream\n  .finalizer(Console.printLine(\"Finalizing the stream\").orDie)\n  .ensuring(\n    printLine(\"Doing some other works after stream's finalization\").orDie\n  )\n  \n// Output:\n// Finalizing the stream\n// Doing some other works after stream's finalization\n```\n\n----------------------------------------\n\nTITLE: Finding Prime Numbers and Handling Errors with ZIO in Scala\nDESCRIPTION: This example demonstrates finding a random prime number between 1000 and 10000 using ZIO. It uses flatMapError to collect errors in a Ref, retries until 5 attempts, and handles the final result or errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/chaining-effects-based-on-errors.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def isPrime(n: Int): Boolean =\n    if (n <= 1) false else (2 until n).forall(i => n % i != 0)\n\n  def findPrimeBetween(\n      minInclusive: Int,\n      maxExclusive: Int\n  ): ZIO[Any, List[String], Int] =\n    for {\n      errors <- Ref.make(List.empty[String])\n      number <- Random\n        .nextIntBetween(minInclusive, maxExclusive)\n        .reject {\n          case n if !isPrime(n) =>\n            s\"non-prime number rejected: $n\"\n        }\n        .flatMapError(error => errors.updateAndGet(_ :+ error))\n        .retryUntil(_.length >= 5)\n    } yield number\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    findPrimeBetween(1000, 10000)\n      .flatMap(prime => Console.printLine(s\"found a prime number: $prime\").orDie)\n      .catchAll { (errors: List[String]) =>\n        Console.printLine(\n          s\"failed to find a prime number after 5 attempts:\\n  ${errors.mkString(\"\\n  \")}\"\n        )\n      }\n      .orDie\n\n  def run = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Timeouts with TestClock in ZIO Test (Scala)\nDESCRIPTION: Demonstrates how to use TestClock to control time passage in ZIO Test, allowing for efficient testing of timeout functionality without actual waiting.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/why-zio-test.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\ntest(\"timeout\") {\n  for {\n    fiber  <- ZIO.sleep(5.minutes).timeout(1.minute).fork\n    _      <- TestClock.adjust(1.minute)\n    result <- fiber.join\n  } yield assertTrue(result.isEmpty)\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#orElseEither for Different Config Sources in Scala\nDESCRIPTION: This example illustrates `orElseEither`. It first tries `readLocalConfig`. If that fails, it tries `readRemoteConfig`. Because the success types (`LocalConfig` and `RemoteConfig`) differ, the result is wrapped in `Either[LocalConfig, RemoteConfig]`. The resulting effect succeeds with `Left(localConfig)` if the first succeeds, or `Right(remoteConfig)` if the first fails and the second succeeds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait LocalConfig\ntrait RemoteConfig\n\ndef readLocalConfig: ZIO[Any, Throwable, LocalConfig] = ???\ndef readRemoteConfig: ZIO[Any, Throwable, RemoteConfig] = ???\n\nval result: ZIO[Any, Throwable, Either[LocalConfig, RemoteConfig]] =\n  readLocalConfig.orElseEither(readRemoteConfig)\n```\n\n----------------------------------------\n\nTITLE: Using ZIO's Race Operator for Efficient Parallel Execution in Scala\nDESCRIPTION: Shows how to use ZIO's race operator to efficiently run two tasks in parallel, automatically canceling the slower task. This example demonstrates loading data from cache or database, whichever completes first.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval loaded = loadFromCache(productId).race(loadFromDb(productId))\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Retry with ZIO Schedule\nDESCRIPTION: Demonstrates basic retry functionality using ZIO's retry method with a Schedule to handle transient failures when reading a file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nval retriedOpenFile: ZIO[Any, IOException, Array[Byte]] =\n  readFile(\"primary.data\").retry(Schedule.recurs(5))\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Console Application with ZIO\nDESCRIPTION: Example showing how to create an interactive console application using ZIO's Console service. Demonstrates composition of console operations using for-comprehension to create a simple greeting program that reads user input and responds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/console.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\n\nimport zio.ZIO\nimport zio.console._\n\nobject MyHelloApp extends zio.App {\n  val program: ZIO[Console, IOException, Unit] = for {\n    _ <- putStrLn(\"Hello, what is you name?\")\n    name <- getStrLn\n    _ <- putStrLn(s\"Hello $name, welcome to ZIO!\")\n  } yield ()\n\n  override def run(args: List[String]) = program.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZLayer Type Alias in ZIO (Scala)\nDESCRIPTION: Defines the conceptual type alias for ZLayer, making it explicit how ZLayers map dependencies and errors in Scala. No dependencies or special parameters; shows the high-level mental model. The type represents an asynchronous effect from requirements (RIn) to Either[E, ROut].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype ZLayer[-RIn, +E, +ROut] = RIn => async Either[E, ROut]\n```\n\n----------------------------------------\n\nTITLE: Retrying ZLayer Construction on Failure (Scala)\nDESCRIPTION: Demonstrates how to automatically retry layer acquisition on failure using a schedule (fibonacci backoff with 1 second) with retry. Requires the Schedule and Clock from ZIO. Input is a failing layer, output is a layer wrapped to retry on errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval databaseLayer: ZLayer[Any, Throwable, DatabaseConnection]   = ???\n\nval retriedLayer : ZLayer[Clock, Throwable, DatabaseConnection] = databaseLayer.retry(Schedule.fibonacci(1.second))\n```\n\n----------------------------------------\n\nTITLE: Non-Atomic Money Transfer Implementation\nDESCRIPTION: Initial implementation of transfer function that doesn't guarantee atomic operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(from: Ref[Int], to: Ref[Int], amount: Int) = for {\n  _ <- withdraw(from, amount)\n  _ <- deposit(to, amount)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Environment Variables with ZIO System Service\nDESCRIPTION: Demonstrates how to access system environment variables using the ZIO System service's env function. The example checks for the USER environment variable and handles both the case when it exists and when it doesn't.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/system.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  user <- System.env(\"USER\")\n  _    <- user match {\n            case Some(value) => \n              Console.printLine(s\"The USER env is: $value\")\n            case None        => \n              Console.printLine(\"Oops! The USER env is not set\")\n          }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Config for ServiceConfig in Scala using ZIO\nDESCRIPTION: This example shows how to create a nested configuration for a ServiceConfig case class. It uses the nested combinator to group related config values under a common namespace.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/configuration/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class ServiceConfig(hostPort: HostPort, timeout: Int)\n\nobject ServiceConfig {\n  implicit val config: Config[ServiceConfig] =\n    (HostPort.config.nested(\"hostport\") ++ Config.int(\"timeout\")).map {\n      case (a, b) => ServiceConfig(a, b)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Processing with ZIO Operations\nDESCRIPTION: Example showing how to process a list of numbers using ZIO's parallel operations to filter prime numbers and perform additional work.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef isPrime(number: Int): Task[Boolean] = ZIO.succeed(???)\ndef moreHardWork(i: Int): Task[Boolean] = ZIO.succeed(???)\n\nval numbers = 1 to 1000\n\nfor {\n  primes <- ZIO.filterPar(numbers)(isPrime)\n  _      <- ZIO.foreachPar(primes)(moreHardWork) @@ parallel(20)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Composing ZIO Effects with Multiple Services\nDESCRIPTION: Shows how to compose ZIO effects that require multiple services (A, B, and C).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[A with B with C, Nothing, Unit] =\n  for {\n    _ <- A.foo\n    _ <- C.baz\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Service in Scala with ZIO\nDESCRIPTION: Defines a Counter trait and its implementation with resource management capabilities. Includes increment and get operations, along with lifecycle management through acquire and release methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.util.UUID\n\ntrait Counter {\n  def increment: UIO[Unit]\n  def get: UIO[Int]\n}\n\nobject Counter {\n  val increment: ZIO[Counter, Nothing, Unit] =\n    ZIO.serviceWithZIO[Counter](_.increment)\n\n  val get: ZIO[Counter, Nothing, RuntimeFlags] =\n    ZIO.serviceWithZIO[Counter](_.get)\n\n  val live: ZLayer[Any, Nothing, Counter] = ZLayer.scoped {\n    for {\n      id <- Ref.make(UUID.randomUUID())\n      ref <- Ref.make(0)\n      service = CounterLive(id, ref)\n      _ <- service.acquire\n      _ <- ZIO.addFinalizer(service.release)\n    } yield service\n  }\n}\n\nfinal case class CounterLive(id: Ref[UUID], ref: Ref[Int]) extends Counter {\n  def acquire: UIO[Unit] = {\n    Random.nextUUID\n      .flatMap(n => id.set(n) *> ZIO.debug(s\"Acquired counter $n\"))\n  }\n\n  def increment: UIO[Unit] =\n    ref.update(_ + 1)\n\n  def get: UIO[Int] =\n    ref.get\n\n  def release: UIO[Unit] =\n    id.get.flatMap(id => ZIO.debug(s\"Released counter $id\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Service Dependencies in Scala\nDESCRIPTION: Demonstrates how to instantiate a service by providing concrete implementations of its dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass ServiceAImpl extends ServiceA\nclass ServiceBImpl extends ServiceB\nval fooService = new FooServiceImpl(new ServiceAImpl, new ServiceBImpl)\n```\n\n----------------------------------------\n\nTITLE: Consuming a Stream with ZSink in Scala\nDESCRIPTION: This example demonstrates consuming a stream by running it with a sink. The sink aggregates all stream elements by summing them, returning a ZIO effect that contains the final sum when the stream completes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_65\n\nLANGUAGE: scala\nCODE:\n```\nval sum: UIO[Int] = ZStream(1,2,3).run(Sink.sum)\n```\n\n----------------------------------------\n\nTITLE: Validating an Age with Custom Error Types - Scala\nDESCRIPTION: Defines a ZIO effect for age validation using a domain-specific error hierarchy. Custom exceptions indicate negative or illegal ages. The function produces a failure if the age is invalid or returns the validated age. Key parameters are the input age, and the effect may fail with AgeValidationException or succeed with Int.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] =\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n```\n\n----------------------------------------\n\nTITLE: Implementing Circuit Breaker Pattern with ZIO\nDESCRIPTION: Complete example demonstrating how to implement a Circuit Breaker pattern for handling external API calls using Rezilience. The example includes error handling, state management, and retry policies with exponential backoff.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/rezilience.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport nl.vroste.rezilience.CircuitBreaker.{CircuitBreakerCallError, State}\nimport nl.vroste.rezilience._\nimport zio._\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.duration._\n\nobject CircuitBreakerExample extends zio.App {\n\n  def callExternalSystem: ZIO[Console, String, Nothing] =\n    putStrLn(\"External service called, but failed!\").orDie *>\n      ZIO.fail(\"External service failed!\")\n\n  val myApp: ZIO[Console with Clock, Nothing, Unit] =\n    CircuitBreaker.withMaxFailures(\n      maxFailures = 10,\n      resetPolicy = Schedule.exponential(1.second),\n      onStateChange = (state: State) =>\n        ZIO(println(s\"State changed to $state\")).orDie\n    ).use { cb =>\n      for {\n        _ <- ZIO.foreach_(1 to 10)(_ => cb(callExternalSystem).either)\n        _ <- cb(callExternalSystem).catchAll(errorHandler)\n        _ <- ZIO.sleep(2.seconds)\n        _ <- cb(callExternalSystem).catchAll(errorHandler)\n      } yield ()\n    }\n\n  def errorHandler: CircuitBreakerCallError[String] => URIO[Console, Unit] = {\n    case CircuitBreaker.CircuitBreakerOpen =>\n      putStrLn(\"Circuit breaker blocked the call to our external system\").orDie\n    case CircuitBreaker.WrappedError(error) =>\n      putStrLn(s\"External system threw an exception: $error\").orDie\n  }\n  \n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Shared Layer to Test Suite in ZIO Test (Scala)\nDESCRIPTION: Shows how to provide a shared ZLayer (in this case, a Kafka layer) to an entire test suite, demonstrating ZIO Test's resource management capabilities.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/why-zio-test.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nsuite(\"a test suite with shared kafka layer\")(test1, test2, test3)\n  .provideCustomLayerShared(kafkaLayer)\n```\n\n----------------------------------------\n\nTITLE: Adding Items to a Queue in Scala with ZIO\nDESCRIPTION: Demonstrates different ways to add items to a queue, including offering a single item and multiple items.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/queue.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval res1: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](100)\n  _ <- queue.offer(1)\n} yield ()\n```\n\nLANGUAGE: scala\nCODE:\n```\nval res2: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](1)\n  _ <- queue.offer(1)\n  f <- queue.offer(1).fork // will be suspended because the queue is full\n  _ <- queue.take\n  _ <- f.join\n} yield ()\n```\n\nLANGUAGE: scala\nCODE:\n```\nval res3: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](100)\n  items = Range.inclusive(1, 10).toList\n  _ <- queue.offerAll(items)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Using the Counter in a Concurrent ZIO Application\nDESCRIPTION: Example demonstrating how to use the Counter concurrently in a ZIO application. Multiple increment and decrement operations are performed in parallel using the <&> operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/global-shared-state.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      c <- Counter.make\n      _ <- c.inc <&> c.inc <&> c.dec <&> c.inc\n      v <- c.get\n      _ <- ZIO.debug(s\"This counter has a value of $v.\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Ensuring Blocking Execution of Existing ZIO Effect using blocking - Scala\nDESCRIPTION: Shows the conversion of an already constructed Task effect for downloading data over HTTP (uses Source.fromURL) so that it runs on the dedicated ZIO blocking thread pool, preserving non-blocking semantics for the runtime. The blocking method is used to shift the context of the effect. Requires scala.io.Source and zio.blocking.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.{ Codec, Source }\n\ndef download(url: String) =\n  Task.effect {\n    Source.fromURL(url)(Codec.UTF8).mkString\n  }\n\ndef safeDownload(url: String) =\n  blocking(download(url))\n```\n\n----------------------------------------\n\nTITLE: Using Fallback in ZIO with orElse\nDESCRIPTION: Demonstrates how to use the orElse combinator in ZIO to try one effect, and if it fails, try another effect as a fallback.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval primaryOrBackupData: ZIO[Any, IOException, Array[Byte]] = \n  openFile(\"primary.data\").orElse(openFile(\"backup.data\"))\n```\n\n----------------------------------------\n\nTITLE: Importing zio-interop-cats for Cats Effect 3.x\nDESCRIPTION: Dependency configuration for adding ZIO interoperability with Cats Effect 3.x to your project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-interop-cats\" % \"3.1.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Acquiring Multiple Permits with ZIO Semaphore in Scala\nDESCRIPTION: This snippet shows how to use a ZIO Semaphore to acquire multiple permits at once. It demonstrates that a binary semaphore is a special case of a counting semaphore, allowing the acquisition of any number of permits.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/semaphore.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval semTaskN = (sem: Semaphore) => for {\n  _ <- sem.withPermits(5)(task)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Zipping of ZSinks\nDESCRIPTION: Demonstrates how to zip two ZSinks (Kafka and Pulsar) to run in parallel, combining their results in a tuple. The example shows sink creation and parallel combination using zipPar operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/concurrency-and-parallelism.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nval kafkaSink: ZSink[Any, Throwable, Record, Record, Unit] =\n  ZSink.foreach[Any, Throwable, Record](record => ZIO.attempt(???))\n\nval pulsarSink: ZSink[Any, Throwable, Record, Record, Unit] =\n  ZSink.foreach[Any, Throwable, Record](record => ZIO.attempt(???))\n\nval stream: ZSink[Any, Throwable, Record, Record, Unit] =\n  kafkaSink zipPar pulsarSink\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci with ZIO Fibers\nDESCRIPTION: This example demonstrates a recursive implementation of the Fibonacci sequence using ZIO fibers. It creates parallel fibers for each recursive call, showing how fibers can be used for parallelism without consuming unlimited threads.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef fib(n: Int): UIO[Int] =\n  if (n <= 1) {\n    ZIO.succeed(1)\n  } else {\n    for {\n      fiber1 <- fib(n - 2).fork\n      fiber2 <- fib(n - 1).fork\n      v2     <- fiber2.join\n      v1     <- fiber1.join\n    } yield v1 + v2\n  }\n```\n\n----------------------------------------\n\nTITLE: Complex TestClock Example with Dependencies in Scala\nDESCRIPTION: Demonstrates a more complex scenario using TestClock with multiple services and dependencies. It tests a scheduling service that depends on a logging service, simulating time passage and handling potential failures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.Assertion._\nimport zio.test._\nimport zio.{test => _, _}\n\ntrait SchedulingService {\n  def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean]\n}\n\ntrait LoggingService {\n  def log(msg: String): ZIO[Any, Exception, Unit]\n}\n\nval schedulingLayer: ZLayer[LoggingService, Nothing, SchedulingService] =\n  ZLayer.fromFunction { (loggingService: LoggingService) =>\n    new SchedulingService {\n      def schedule(promise: Promise[Unit, Int]): ZIO[Any, Exception, Boolean] =\n        (ZIO.sleep(10.seconds) *> promise.succeed(1))\n          .tap(b => loggingService.log(b.toString))\n    }\n}\n\ntest(\"One can control time for failing effects too\") {\n  val failingLogger = ZLayer.succeed(new LoggingService {\n    override def log(msg: String): ZIO[Any, Exception, Unit] = ZIO.fail(new Exception(\"BOOM\"))\n  })\n\n  val layer = failingLogger >>> schedulingLayer\n\n  val testCase =\n    for {\n      promise <- Promise.make[Unit, Int]\n      result <- ZIO.serviceWithZIO[SchedulingService](_.schedule(promise)).exit.fork\n      _ <- TestClock.adjust(10.seconds)\n      readRef <- promise.await\n      result <- result.join\n    } yield assertTrue((1 == readRef) && result.isFailure)\n  testCase.provideLayer(layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Polling ZIO Promises in Scala\nDESCRIPTION: Demonstrates how to poll a ZIO Promise to check its completion status without suspending the fiber, using both poll and poll.some methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/promise.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval ioPromise4: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\nval ioIsItDone: UIO[Option[IO[Exception, String]]] = ioPromise4.flatMap(p => p.poll)\nval ioIsItDone2: IO[Option[Nothing], IO[Exception, String]] = ioPromise4.flatMap(p => p.poll.some)\n```\n\n----------------------------------------\n\nTITLE: Tracking Fiber Lifecycle with Supervisor.track in ZIO (Scala)\nDESCRIPTION: This snippet demonstrates how to instantiate a Supervisor in ZIO that collects and tracks child fibers. The track method accepts a boolean weak parameter to determine if children should be tracked with weak references (preventing memory leaks) or not. The code requires the ZIO library, and the resulting supervisor is used to monitor fiber status in ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/supervisor.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.Supervisor\n```\n\nLANGUAGE: Scala\nCODE:\n```\nval supervisor = Supervisor.track(true)\n```\n\n----------------------------------------\n\nTITLE: Creating Ref Examples - Scala\nDESCRIPTION: Examples of creating Ref instances with different types of immutable values including primitives and custom types\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval counterRef = Ref.make(0)\n// counterRef: UIO[Ref[Int]] = zio.ZIO$EffectTotal@34507957\nval stringRef = Ref.make(\"initial\") \n// stringRef: UIO[Ref[String]] = zio.ZIO$EffectTotal@3564252 \n\nsealed trait State\ncase object Active  extends State\ncase object Changed extends State\ncase object Closed  extends State\n\nval stateRef = Ref.make(Active) \n// stateRef: UIO[Ref[Active.type]] = zio.ZIO$EffectTotal@1c10a424\n```\n\n----------------------------------------\n\nTITLE: Collection Operations with ZSink\nDESCRIPTION: Shows how to collect stream elements into various collections like Chunk, Set, and Map. Includes examples of collecting all elements, collecting with size limits, and collecting with conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/creating-sinks.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval stream: UStream[Int] = ZStream(1, 2, 3, 4, 5)\nval collection: UIO[Chunk[Int]] = stream.run(ZSink.collectAll[Int])\n\nval collectAllToSet: ZSink[Any, Nothing, Int, Nothing, Set[Int]] = ZSink.collectAllToSet[Int]\nval stream: ZIO[Any, Nothing, Set[Int]] = ZStream(1, 3, 2, 3, 1, 5, 1).run(collectAllToSet)\n```\n\n----------------------------------------\n\nTITLE: Creating a Mock for a Polymorphic Service\nDESCRIPTION: Implementation of a mock for a service with polymorphic methods. Uses Poly.Effect variants to create capability tags for methods with type parameters, and the 'of' combinator to specify concrete types when creating expectations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\n// test sources\nobject PolyExampleMock extends Mock[PolyExample] {\n\n  object PolyInput  extends Poly.Effect.Input[Throwable, String]\n  object PolyError  extends Poly.Effect.Error[Int, String]\n  object PolyOutput extends Poly.Effect.Output[Int, Throwable]\n  object PolyAll    extends Poly.Effect.InputErrorOutput\n\n  val compose: URLayer[Has[Proxy], PolyExample] =\n    ZLayer.fromServiceM { proxy =>\n      withRuntime.map { rts =>\n        new PolyExample.Service {\n          def polyInput[I: Tag](input: I)                     = proxy(PolyInput.of[I], input)\n          def polyError[E: Tag](input: Int)                   = proxy(PolyError.of[E], input)\n          def polyOutput[A: Tag](input: Int)                  = proxy(PolyOutput.of[A], input)\n          def polyAll[I: Tag, E: Tag, A: Tag](input: I) = proxy(PolyAll.of[I, E, A], input)\n        }\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Fiber Finalization on Interruption in ZIO Scala\nDESCRIPTION: Demonstrates fiber finalization during interruption, ensuring that resources are properly released even when a fiber is interrupted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber <- printLine(\"Working on the first job\")\n    .schedule(Schedule.fixed(1.seconds))\n    .ensuring {\n      (printLine(\n        \"Finalizing or releasing a resource that is time-consuming\"\n      ) *> ZIO.sleep(7.seconds)).orDie\n    }\n    .fork\n  _     <- fiber.interrupt.delay(4.seconds)\n  _     <- printLine(\n          \"Starting another task when the interruption of the previous task finished\"\n        )\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Ensuring IO Operations Run on the Blocking Thread Pool\nDESCRIPTION: Shows how to take an existing ZIO effect and ensure it runs on the blocking thread pool using ZIO.blocking. This is useful when wrapping IO operations that might block.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.io.{ Codec, Source }\n\ndef download(url: String) =\n  ZIO.attempt {\n    Source.fromURL(url)(Codec.UTF8).mkString\n  }\n\ndef safeDownload(url: String) =\n  ZIO.blocking(download(url))\n```\n\n----------------------------------------\n\nTITLE: Defining the IO Type Alias in ZIO with Scala\nDESCRIPTION: This Scala snippet defines the `IO[+E, +A]` type alias as being equivalent to `ZIO[Any, E, A]`. It signifies an effect that requires no specific environment (`Any`), can fail with an error of type `E`, or succeed with a value of type `A`. This alias simplifies signatures for common ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/io.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype IO[+E, +A] = ZIO[Any, E, A]\n```\n\n----------------------------------------\n\nTITLE: Defining Exit Data Type in Scala\nDESCRIPTION: This snippet shows the definition of the Exit data type in ZIO. It is a sealed abstract class with two case classes: Success containing a value of type A, and Failure containing a Cause of type E.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/exit.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nsealed abstract class Exit[+E, +A] extends Product with Serializable { self =>\n  // Exit operators\n}\nobject Exit {\n  final case class Success[+A](value: A)        extends Exit[Nothing, A]\n  final case class Failure[+E](cause: Cause[E]) extends Exit[E, Nothing]\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Recurring Effects with TestClock in Scala\nDESCRIPTION: Shows how to test an effect that recurs with a fixed delay using TestClock. It creates a queue, offers items to it every 60 minutes, and verifies the timing of these offers by adjusting the TestClock.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Queue\nimport zio.test._\n\nfor {\n  q <- Queue.unbounded[Unit]\n  _ <- q.offer(()).delay(60.minutes).forever.fork\n  a <- q.poll.map(_.isEmpty)\n  _ <- TestClock.adjust(60.minutes)\n  b <- q.take.as(true)\n  c <- q.poll.map(_.isEmpty)\n  _ <- TestClock.adjust(60.minutes)\n  d <- q.take.as(true)\n  e <- q.poll.map(_.isEmpty)\n} yield assertTrue(a && b && c && d && e)\n```\n\n----------------------------------------\n\nTITLE: Money Transfer Example Using TRef\nDESCRIPTION: A complete example showing how to use TRef for concurrent operations with STM. Implements a money transfer between accounts that ensures atomicity and consistency, with proper retry logic to ensure sufficient funds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\ndef transfer(tSender: TRef[Int],\n             tReceiver: TRef[Int],\n             amount: Int): UIO[Int] = {\n  STM.atomically {\n    for {\n      _ <- tSender.get.retryUntil(_ >= amount)\n      _ <- tSender.update(_ - amount)\n      nAmount <- tReceiver.updateAndGet(_ + amount)\n    } yield nAmount\n  }\n}\n\nval transferredMoney: UIO[String] = for {\n  tSender <- TRef.makeCommit(50)\n  tReceiver <- TRef.makeCommit(100)\n  _ <- transfer(tSender, tReceiver, 50).fork\n  _ <- tSender.get.retryUntil(_ == 0).commit\n  tuple2 <- tSender.get.zip(tReceiver.get).commit\n  (senderBalance, receiverBalance) = tuple2\n} yield s\"sender: $senderBalance & receiver: $receiverBalance\"\n```\n\n----------------------------------------\n\nTITLE: Composing Fibers with zip in Scala using ZIO\nDESCRIPTION: This snippet demonstrates how to compose two fibers using the zip method in ZIO. It forks two effects, zips their fibers, and then joins the combined fiber to get both results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber1 <- ZIO.succeed(\"Hi!\").fork\n  fiber2 <- ZIO.succeed(\"Bye!\").fork\n  fiber   = fiber1.zip(fiber2)\n  tuple  <- fiber.join\n} yield tuple\n```\n\n----------------------------------------\n\nTITLE: Ref Update Operation Example - Scala\nDESCRIPTION: Example showing how to atomically update Ref values using pure functions\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval counterInitial = 0\nfor {\n  counterRef <- Ref.make(counterInitial)\n  _          <- counterRef.update(_ + 1)\n  value <- counterRef.get\n} yield assert(value == 1)\n```\n\n----------------------------------------\n\nTITLE: Parallel Error Accumulation with ZIO#validatePar in Scala\nDESCRIPTION: This example shows how ZIO#validatePar zips effects in parallel and accumulates errors, combining causes with Cause.Both.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/error-accumulation.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1 = ZIO.succeed(1).debug\n  val f2 = ZIO.succeed(2) *> ZIO.fail(\"Oh uh!\")\n  val f3 = ZIO.succeed(3).debug\n  val f4 = ZIO.succeed(4) *> ZIO.fail(\"Oh error!\")\n  val f5 = ZIO.succeed(5).debug\n\n  val myApp: ZIO[Any, String, ((((Int, Int), Int), Int), Int)] =\n    f1 validatePar f2 validatePar f3 validatePar f4 validatePar f5\n\n  def run = myApp.cause.map(_.untraced).debug.uncause\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Retrying Money Transfer with STM.retry\nDESCRIPTION: Creates a money transfer function that uses STM.retry instead of failing when there are insufficient funds. The transaction will automatically retry until the sender has enough money, continuing only when underlying transactional data structures change.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/stm.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef transferMoneyNoMatterWhat(from: TRef[Long], to: TRef[Long], amount: Long): STM[String, Long] =\n  for {\n    senderBal <- from.get\n    _         <- if (senderBal < amount) STM.retry else STM.unit\n    _         <- from.update(existing => existing - amount)\n    _         <- to.update(existing => existing + amount)\n    recvBal   <- to.get\n  } yield recvBal\n```\n\n----------------------------------------\n\nTITLE: Using >+> Operator for ZLayer Composition in Scala\nDESCRIPTION: Demonstrates the use of the >+> operator for ZLayer composition. This operator combines layers while passing through intermediate dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ??? // B  ==> C\n\nval finalLayer: ZLayer[A, Throwable, B & C] = // A ==> B & C\n  fooLayer >+> barLayer\n```\n\n----------------------------------------\n\nTITLE: Converting Java CompletionStage to ZIO Task - Scala\nDESCRIPTION: This snippet defines a function that transforms a Java CompletionStage into a ZIO Task in Scala, adding logging for completion events. It uses ZIO.fromCompletionStage combined with a functional wrapper that logs upon stage completion. Dependencies include ZIO and Java\\'s CompletionStage. The input is a by-name CompletionStage, and the output is a Task representing its result, logging side effects upon completion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-java.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef loggedStage[A](stage: => CompletionStage[A]): Task[A] =\n    ZIO.fromCompletionStage(UIO {\n        stage.thenApplyAsync { a =>\n            println(\"Stage completed with \" + a)\n            a\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Complete Supervisor Monitoring Example\nDESCRIPTION: A comprehensive example showing how to monitor fibers in a ZIO application using Supervisor, including fibonacci calculation and periodic status checking.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/supervisor.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject SupervisorExample extends zio.App {\n  import zio.duration._\n\n  val program = for {\n    supervisor <- Supervisor.track(true)\n    fiber <- fib(20).supervised(supervisor).fork\n    policy = Schedule\n      .spaced(500.milliseconds)\n      .whileInputM[Any, Unit](_ => fiber.status.map(x => !x.isDone))\n    logger <- monitorFibers(supervisor)\n      .repeat(policy).fork\n    _ <- logger.join\n    result <- fiber.join\n    _ <- putStrLn(s\"fibonacci result: $result\")\n  } yield ()\n\n  def monitorFibers(supervisor: Supervisor[Chunk[Fiber.Runtime[Any, Any]]]) = for {\n    length <- supervisor.value.map(_.length)\n    _ <- putStrLn(s\"number of fibers: $length\")\n  } yield ()\n\n  def fib(n: Int): ZIO[Clock, Nothing, Int] =\n    if (n <= 1) {\n      ZIO.succeed(1)\n    } else {\n      for {\n        _ <- sleep(500.milliseconds)\n        fiber1 <- fib(n - 2).fork\n        fiber2 <- fib(n - 1).fork\n        v2 <- fiber2.join\n        v1 <- fiber1.join\n      } yield v1 + v2\n    }\n\n  override def run(args: List[String]) = program.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Debugging Fail Cause in Scala\nDESCRIPTION: Shows how to create a Fail cause using Cause.fail and ZIO.failCause, and demonstrates debugging the cause of various ZIO effects including combined effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.failCause(Cause.fail(\"Oh uh!\")).cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646395282),Chunk(<empty>.MainApp.run(MainApp.scala:4))))\n\nZIO.fail(\"Oh uh!\").cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646395627),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n\n(ZIO.fail(\"Oh uh!\") *> ZIO.dieMessage(\"Boom!\") *> ZIO.interrupt).cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646396370),Chunk(<empty>.MainApp.run(MainApp.scala:6))))\n\n(ZIO.fail(\"Oh uh!\") <*> ZIO.fail(\"Oh Error!\")).cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646396419),Chunk(<empty>.MainApp.run(MainApp.scala:9))))\n\nval myApp: ZIO[Any, String, Int] =\n  for {\n    i <- ZIO.succeed(5)\n    _ <- ZIO.fail(\"Oh uh!\")\n    _ <- ZIO.dieMessage(\"Boom!\")\n    _ <- ZIO.interrupt\n  } yield i\nmyApp.cause.debug\n// Fail(Oh uh!,Trace(Runtime(2,1646397126),Chunk(<empty>.MainApp.myApp(MainApp.scala:13),<empty>.MainApp.run(MainApp.scala:17))))\n```\n\n----------------------------------------\n\nTITLE: Defining Download Routes in Scala\nDESCRIPTION: Creates routes for file download functionality without environment dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/restful-webservice.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject DownloadRoutes {\n  def apply(): Routes[Any, Nothing] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Basic ZSink Constructors in Scala\nDESCRIPTION: Demonstrates common sink constructors like head, last, count, sum, and take. These sinks perform basic operations on streams like getting first/last elements, counting, summing values, and taking specific numbers of elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/creating-sinks.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval sink: ZSink[Any, Nothing, Int, Int, Option[Int]] = ZSink.head[Int]\nval head: ZIO[Any, Nothing, Option[Int]] = ZStream(1, 2, 3, 4).run(sink)\n\nval sink: ZSink[Any, Nothing, Int, Nothing, Option[Int]] = ZSink.last[Int]\nval last: ZIO[Any, Nothing, Option[Int]] = ZStream(1, 2, 3, 4).run(sink)\n\nval sink : ZSink[Any, Nothing, Int, Nothing, Long] = ZSink.count\nval count: ZIO[Any, Nothing, Long] = ZStream(1, 2, 3, 4, 5).run(sink)\n```\n\n----------------------------------------\n\nTITLE: Using Lenses in ZIO Optics to Update Nested Data Structures\nDESCRIPTION: Demonstrates how to create and compose lenses to modify deeply nested data structures. The example creates lenses for a Developer/Manager/Rating hierarchy and updates a nested upvotes value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.optics._\n\ncase class Developer(name: String, manager: Manager)\ncase class Manager(name: String, rating: Rating)\ncase class Rating(upvotes: Int, downvotes: Int)\n\nval developerLens = Lens[Developer, Manager](\n  get = developer => Right(developer.manager),\n  set = manager => developer => Right(developer.copy(manager = manager))\n)\n\nval managerLens = Lens[Manager, Rating](\n  get = manager => Right(manager.rating),\n  set = rating => manager => Right(manager.copy(rating = rating))\n)\n\nval ratingLens = Lens[Rating, Int](\n  get = rating => Right(rating.upvotes),\n  set = upvotes => rating => Right(rating.copy(upvotes = upvotes))\n)\n\n// Composing lenses\nval optic = developerLens >>> managerLens >>> ratingLens\n\nval jane    = Developer(\"Jane\", Manager(\"Steve\", Rating(0, 0)))\nval updated = optic.update(jane)(_ + 1)\n\nprintln(updated)\n```\n\n----------------------------------------\n\nTITLE: Processing High-Throughput Data Streams with ZIO Streams in Scala\nDESCRIPTION: This example demonstrates using ZIO Streams for processing high-throughput data. It uses ZStream to create a stream of integers and processes them in parallel using mapZIOParUnordered.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nobject MainApp extends ZIOAppDefault {\n  def doWork(n: Int): ZIO[Any, Nothing, Unit] =  ??? \n\n  def run =\n    ZStream\n      .fromIterable(1 to 100000)\n      .mapZIOParUnordered(Int.MaxValue)(doWork)\n      .runDrain\n}\n```\n\n----------------------------------------\n\nTITLE: Using Thread-Safe ConcurrentMap in ZIO\nDESCRIPTION: Example demonstrating correct concurrent operations using ConcurrentMap, showing consistent results when incrementing a value 100 times in parallel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/concurrentmap.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent.ConcurrentMap\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      map <- ConcurrentMap.make((\"foo\", 0), (\"bar\", 1), (\"baz\", 2))\n      _ <- ZIO.foreachParDiscard(1 to 100)(_ =>\n        map.computeIfPresent(\"foo\", (_, v) => v + 1)\n      )\n      _ <- map.get(\"foo\").debug(\"The final value of foo is\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Retrying a Failing Stream with Schedule in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates how to use ZStream#retry to retry a failing stream according to a given schedule. The example shows retrying a stream that reads user input with an exponential backoff schedule.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval numbers = ZStream(1, 2, 3) ++ \n  ZStream\n    .fromZIO(\n      Console.print(\"Enter a number: \") *> Console.readLine\n        .flatMap(x =>\n          x.toIntOption match {\n            case Some(value) => ZIO.succeed(value)\n            case None        => ZIO.fail(\"NaN\")\n          }\n        )\n    )\n    .retry(Schedule.exponential(1.second))\n```\n\n----------------------------------------\n\nTITLE: Forking a Fibonacci Calculation in Scala using ZIO\nDESCRIPTION: This snippet demonstrates how to fork a Fibonacci calculation into a separate fiber using ZIO. It defines a recursive Fibonacci function and then forks its execution for the 100th Fibonacci number.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef fib(n: Long): UIO[Long] = \n  ZIO.suspendSucceed {\n    if (n <= 1) ZIO.succeed(n)\n    else fib(n - 1).zipWith(fib(n - 2))(_ + _)\n  }\n\nval fib100Fiber: UIO[Fiber[Nothing, Long]] = \n  for {\n    fiber <- fib(100).fork\n  } yield fiber\n```\n\n----------------------------------------\n\nTITLE: Converting Future to ZIO Effect\nDESCRIPTION: Demonstrates converting a Scala Future into a ZIO effect using ZIO.fromFuture. Includes logging of successful Future completion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-future.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef loggedFuture[A](future: ExecutionContext => Future[A]): UIO[Task[A]] = {\n  ZIO.fromFuture { implicit ec =>\n    future(ec).flatMap { result =>\n      Future(println(\"Future succeeded with \" + result)).map(_ => result)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Finalizers\nDESCRIPTION: Demonstrates how to use ensuring for resource cleanup that works with both synchronous and asynchronous effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval finalizer =\n  ZIO.succeed(println(\"Finalizing!\"))\n\nval finalized: IO[String, Unit] =\n  ZIO.fail(\"Failed!\").ensuring(finalizer)\n```\n\n----------------------------------------\n\nTITLE: Constraining Effects with ZIO and Console Capability in Scala\nDESCRIPTION: This example rewrites the previous command-like function using ZIO's effect system, restricting possible effects through type signatures. The function declares its dependency on the Console environment, uses console.putStrLn for output, and ensures errors are escalated via orDie. Requires: ZIO library with Console module, and Event type. Input: Event instance. Output: URIO[Console, Unit], effectful computation within ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console.Console\n\ndef processEvent(event: Event): URIO[Console, Unit] =\n  console.putStrLn(s\"Got $event\").orDie\n```\n\n----------------------------------------\n\nTITLE: Defining a Terminal Service Interface in Scala\nDESCRIPTION: Defines a Terminal service interface with methods for printing, printing lines, and reading lines as ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Terminal {\n  def print(line: Any): Task[Unit]\n\n  def printLine(line: Any): Task[Unit]\n\n  def readLine: Task[String]\n}\n```\n\n----------------------------------------\n\nTITLE: Fast Time Movement with TestClock in Scala\nDESCRIPTION: Demonstrates how TestClock can be used to move time forward instantly. It measures the start time, adjusts the clock by 1 minute, and then verifies that at least 60 seconds have passed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport java.util.concurrent.TimeUnit\nimport zio.Clock.currentTime\nimport zio.test.Assertion.isGreaterThanEqualTo\n\ntest(\"One can move time very fast\") {\n  for {\n    startTime <- currentTime(TimeUnit.SECONDS)\n    _         <- TestClock.adjust(1.minute)\n    endTime   <- currentTime(TimeUnit.SECONDS)\n  } yield assertTrue((endTime - startTime) >= 60L)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing AppConfig Service from ZIO Environment in Scala\nDESCRIPTION: Demonstrates how to access the AppConfig service from the ZIO environment using ZIO.service. It also shows how to provide the AppConfig layer when running the effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval myApp: ZIO[AppConfig, Nothing, Unit] =\n  for {\n    config <- ZIO.service[AppConfig]\n    _      <- ZIO.logInfo(s\"Application started with config: $config\")\n  } yield ()\n```\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(ZLayer.succeed(AppConfig(\"localhost\", 8080)))\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Promises for Inter-Fiber Communication in Scala\nDESCRIPTION: Illustrates a scenario where a ZIO Promise is used to hand over a value between two Fibers, demonstrating Promise creation, completion, and awaiting in a concurrent context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/promise.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\n\nval program: ZIO[Any, IOException, Unit] = \n  for {\n    promise         <-  Promise.make[Nothing, String]\n    sendHelloWorld  =   (ZIO.succeed(\"hello world\") <* ZIO.sleep(1.second)).flatMap(promise.succeed)\n    getAndPrint     =   promise.await.flatMap(Console.printLine(_))\n    fiberA          <-  sendHelloWorld.fork\n    fiberB          <-  getAndPrint.fork\n    _               <-  (fiberA zip fiberB).join\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom ZIO Runtime with Specific Environment in Scala\nDESCRIPTION: This snippet shows how to create a custom ZIO `Runtime` instance populated with specific service implementations in its environment. It manually constructs a `Runtime` with a `ZEnvironment` containing instances of `LoggingServiceLive` and `EmailServiceFake`, along with empty `FiberRefs` and default `RuntimeFlags`. This allows running effects that require these services without explicitly providing them later.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval testableRuntime = Runtime(\n  ZEnvironment[LoggingService, EmailService](LoggingServiceLive(), EmailServiceFake()),\n  FiberRefs.empty,\n  RuntimeFlags.default\n)\n```\n\n----------------------------------------\n\nTITLE: Error Accumulation with ZIO.validate in Scala\nDESCRIPTION: This snippet demonstrates ZIO.validate, which transforms a collection and accumulates all errors in the error channel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/error-accumulation.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val res: ZIO[Any, ::[String], List[Int]] =\n    ZIO.validate(List.range(1, 7)){ n =>\n      if (n < 5)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s\"$n is not less that 5\")\n    }\n  def run = res.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO Stream Dependencies\nDESCRIPTION: Initial imports required for working with ZIO Streams, including core ZIO types, Queue, Stream, Pipeline, and IO operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{ZIO, Task}\nimport zio.Queue\nimport zio.stream.{ZStream, ZPipeline}\nimport java.nio.file.{Files, Path, Paths}\nimport zio.Console._\nimport java.io.IOException\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Echo Channel in Scala ZIO\nDESCRIPTION: Demonstrates how to create a basic echo channel that reads a value from the input port and prints it to the console using ZChannel.readWith.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nval producer = \n  ZChannel.write(1)\n  \nval consumer = \n  ZChannel.readWith(\n    (i: Int) => ZChannel.fromZIO(Console.printLine(\"Consumed: \" + i)),\n    (_: Any) => ZChannel.unit,\n    (_: Any) => ZChannel.unit\n  )\n\n(producer >>> consumer).run\n// Output:\n// Consumed: 1\n```\n\n----------------------------------------\n\nTITLE: Forking and Joining Fibers for Concurrent Effects in ZIO (Scala)\nDESCRIPTION: This example demonstrates how to use the ZIO `.fork` method to concurrently analyze and validate data in separate fibers, with subsequent joining and optional interruption logic. It shows how to coordinate the results between two concurrent computations, and manage their lifecycle. Inputs are effects for analysis and validation; outputs are the results of the analysis. Requires the ZIO library, and depends on the functions defined in the setup snippet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval analyzed =\n  for {\n    fiber1   <- analyzeData(data).fork  // IO[E, Analysis]\n    fiber2   <- validateData(data).fork // IO[E, Boolean]\n    // Do other stuff\n    valid    <- fiber2.join\n    _        <- if (!valid) fiber1.interrupt\n                else ZIO.unit\n    analyzed <- fiber1.join\n  } yield analyzed\n```\n\n----------------------------------------\n\nTITLE: Demonstrating High Throughput with ZIO Fibers in Scala\nDESCRIPTION: This snippet shows how to create and manage thousands of lightweight fibers in ZIO for high throughput processing. It uses ZIO.foreach to create fibers and Fiber.collectAll to join them.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def doWork(n: Int): ZIO[Any, Nothing, Unit] =  ??? \n  \n  def run =\n    ZIO\n      .foreach(1 to 100000)(n => doWork(n).fork)\n      .flatMap(f => Fiber.collectAll(f).join)\n}\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application with Dependencies\nDESCRIPTION: Demonstrates how to run a ZIO application with provided dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = result\n}\n```\n\n----------------------------------------\n\nTITLE: Buffering Workloads with ZIO Queue\nDESCRIPTION: Shows how to use ZIO's Queue data type to buffer workloads, processing messages one at a time while allowing high-volume message sending.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\ntrait Actor[-In] {\n  def tell(i: In): UIO[Boolean]\n}\n\nobject Actor {\n  def make[In](receive: In => UIO[Unit]): ZIO[Scope, Nothing, Actor[In]] =\n    for {\n      queue <- Queue.unbounded[In]\n      _     <- queue.take.flatMap(receive).forever.forkScoped\n    } yield new Actor[In] {\n      override def tell(i: In): UIO[Boolean] =\n        queue.offer(i)\n    }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.scoped {\n    for {\n      actor <- Actor.make[Int](n => ZIO.debug(s\"processing job-$n\").delay(1.second))\n      _     <- ZIO.foreachParDiscard(1 to 1000)(actor.tell)\n      _     <- ZIO.debug(\"All messages were sent to the actor!\")\n      _     <- ZIO.never\n    } yield ()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: STM-based Withdraw Implementation\nDESCRIPTION: Atomic withdraw implementation using STM and TRef for transactional operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef withdraw(accountBalance: TRef[Int], amount: Int): STM[String, Unit] =\n  for {\n    balance <- accountBalance.get\n    _ <- if (balance < amount)\n      STM.fail(\"Insufficient funds in you account\")\n    else\n      accountBalance.update(_ - amount)\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing an Editor Class with ZIO and Dependency Injection\nDESCRIPTION: This snippet shows an Editor class using ZIO and dependency injection, where Formatter and Compiler services are injected as dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nclass Editor {\n private val formatter = new Formatter\n private val compiler = new Compiler\n \n def formatAndCompile(code: String): UIO[String] =\n formatter.format(code).flatMap(compiler.compile)\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Prometheus Metrics as HTTP Endpoint\nDESCRIPTION: Scala code demonstrating how to create an HTTP endpoint that exposes metrics in Prometheus format.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\nimport zio._\nimport zio.metrics.connectors.prometheus.PrometheusPublisher\n\nobject PrometheusPublisherRoutes {\n  def apply(): Routes[PrometheusPublisher, Nothing] = {\n    Routes(\n      Method.GET / \"metrics\" ->\n        handler(\n          ZIO.serviceWithZIO[PrometheusPublisher](_.get.map(Response.text))\n        )\n    )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: FiberRef Await Behavior\nDESCRIPTION: Demonstrates how await differs from join in terms of FiberRef value propagation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5)\n```\n\n----------------------------------------\n\nTITLE: Converting a ZLayer to a Scoped Value (Scala)\nDESCRIPTION: Illustrates creating a resourceful layer using ZLayer.scoped and converting it to a scoped ZIO value with ZLayer.build. Assumes the existence of a Database service and a connect effect. Handles initialization and resource cleanup. Output is a ZIO effect that produces a scoped environment containing the Database.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Database {\n  def close: UIO[Unit]\n}\n\nobject Database {\n  def connect: ZIO[Any, Throwable, Database] = ???\n}\n\nval database: ZLayer[Any, Throwable, Database] =\n  ZLayer.scoped {\n    ZIO.acquireRelease {\n      Database.connect.debug(\"connecting to the database\")\n    } { database =>\n      database.close\n    }\n  }\n\nval scopedDatabase: ZIO[Scope, Throwable, ZEnvironment[Database]] =\n  database.build\n```\n\n----------------------------------------\n\nTITLE: STM Interoperability with Cats Effect: Transfer Money Example (Scala)\nDESCRIPTION: Provides a comprehensive example of using zio.interop.stm to integrate ZIO STM abstractions (TRef and STM) with Cats Effect IO. The code defines a transferMoney function using STM over IO, executes atomic account balance transfers, and prints the resulting balance. Dependencies include cats.effect.IO, zio.interop.stm, IORuntime, and ZIO runtime. Input parameters are TRef accounts and transfer amount; output is the resulting balance post-transaction. The workflow demonstrates transactional memory support between ZIO and Cats Effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.effect.IO\nimport cats.effect.unsafe.IORuntime\nimport zio.interop.stm.{STM, TRef}\n\nimplicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\nimplicit val catsRuntime: IORuntime            = IORuntime.global\n\ndef transferMoney(\n    from: TRef[IO, Long],\n    to: TRef[IO, Long],\n    amount: Long\n): STM[IO, Long] =\n  for {\n    senderBal <- from.get\n    _ <-\n      if (senderBal < amount)\n        STM.fail[IO](new Exception(\"Not enough money\"))\n      else\n        STM.unit[IO]\n    _       <- from.update(existing => existing - amount)\n    _       <- to.update(existing => existing + amount)\n    recvBal <- to.get\n  } yield recvBal\n\nval program: IO[Long] = for {\n  sndAcc <- STM.atomically[cats.effect.IO, TRef[IO, Long]](\n    TRef.make[IO, Long](1000)\n  )\n  rcvAcc <- STM.atomically[cats.effect.IO, TRef[IO, Long]](\n    TRef.make[IO, Long](200)\n  )\n  recvAmt <- STM.atomically(transferMoney(sndAcc, rcvAcc, 500L))\n} yield recvAmt\n\nprogram\n  .flatMap(amount =>\n    IO.println(s\"Balance of second account after transaction: $amount\")\n  )\n  .unsafeRunSync()\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO Server with In-Memory Storage\nDESCRIPTION: Server configuration combining all routes with in-memory user repository implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/restful-webservice.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nServer.serve(\n  GreetingRoutes() ++ DownloadRoutes() ++ CounterRoutes() ++ UserRoutes()\n).provide(\n  Server.defaultWithPort(8080),\n  ZLayer.fromZIO(Ref.make(0)),\n  InmemoryUserRepo.layer\n)\n```\n\n----------------------------------------\n\nTITLE: Safe Concurrent Counter Example - Scala\nDESCRIPTION: Example showing proper concurrent state management using atomic updates\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nobject CountRequests extends zio.App {\n  import zio.console._\n\n  def request(counter: Ref[Int]): ZIO[Console, Nothing, Unit] = {\n    for {\n      _ <- counter.update(_ + 1)\n      reqNumber <- counter.get\n      _ <- putStrLn(s\"request number: $reqNumber\").orDie\n    } yield ()\n  }\n\n  private val initial = 0\n  private val program =\n    for {\n      ref <- Ref.make(initial)\n      _ <- request(ref) zipPar request(ref)\n      rn <- ref.get\n      _ <- putStrLn(s\"total requests performed: $rn\").orDie\n    } yield ()\n\n  override def run(args: List[String]) = program.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO gRPC Client in Scala\nDESCRIPTION: Demonstrates how to implement a ZIO gRPC client in Scala to interact with the previously defined gRPC server. Includes client configuration and a simple request example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport io.grpc.ManagedChannelBuilder\nimport io.grpc.examples.helloworld.helloworld.HelloRequest\nimport io.grpc.examples.helloworld.helloworld.ZioHelloworld.GreeterClient\nimport scalapb.zio_grpc.ZManagedChannel\nimport zio.console._\nimport zio.{ExitCode, URIO}\n\nobject HelloWorldClient extends zio.App {\n  def myApp =\n    for {\n      r <- GreeterClient.sayHello(HelloRequest(\"World\"))\n      _ <- putStrLn(r.message)\n    } yield ()\n\n  val clientLayer =\n    GreeterClient.live(\n      ZManagedChannel(\n        ManagedChannelBuilder.forAddress(\"localhost\", 9000).usePlaintext()\n      )\n    )\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideCustomLayer(clientLayer).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Leftover Values in ZIO Sink\nDESCRIPTION: Shows how to ignore leftover values in a ZIO Sink using the ignoreLeftover operation. This is useful when remaining elements after sink consumption are not needed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/leftovers.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nZSink.take[Int](3).ignoreLeftover\n```\n\n----------------------------------------\n\nTITLE: Retrying with Fallback Strategy in Scala using ZIO\nDESCRIPTION: Shows how to implement a retry mechanism with a fallback strategy using ZIO's retryOrElse function. This allows handling cases where the retry policy fails to produce a successful result, by providing an alternative action.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/retrying.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval action:       ZIO[R, E, A] = ???\nval policy: Schedule[R1, A, B] = ???\n\nval orElse: (E, S) => ZIO[R1, E1, A1] = ???\n\nval repeated = action retryOrElse (policy, orElse)\n```\n\n----------------------------------------\n\nTITLE: Testing Code with Unused Collaborators\nDESCRIPTION: Demonstrates how to test code paths that don't use all declared dependencies. Uses Mock.empty to create a mock service that expects no calls, allowing tests for branches that don't interact with certain services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nobject MaybeConsoleSpec extends DefaultRunnableSpec {\n  def spec = suite(\"processEvent\")(\n    testM(\"expect no call\") {\n      def maybeConsole(invokeConsole: Boolean) =\n        ZIO.when(invokeConsole)(console.putStrLn(\"foo\"))\n\n      val maybeTest1 = maybeConsole(false).provideLayer(MockConsole.empty)\n      val maybeTest2 = maybeConsole(true).provideLayer(MockConsole.PutStrLn(equalTo(\"foo\")))\n      assertM(maybeTest1)(isUnit) *> assertM(maybeTest2)(isUnit)\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BlobStorage Service Interface in ZIO\nDESCRIPTION: Defines the BlobStorage trait which provides operations for storing, retrieving, and deleting binary data blobs with ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait BlobStorage {\n  def get(id: String): ZIO[Any, Throwable, Array[Byte]]\n\n  def put(content: Array[Byte]): ZIO[Any, Throwable, String]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lossless Either Projection and Unprojection in ZIO 2.x (Scala)\nDESCRIPTION: Illustrates the improved, lossless behavior of `Either` projections in ZIO 2.x. An effect producing `Left[Int, String]` is created. Applying `.left` projects the `Int` to the success channel while preserving the `String` type information within the `Either` structure of the error channel (implicitly `Either[Throwable, String]`). The subsequent `.map(_ * 2).unleft` demonstrates that the projection can be reversed (`unleft`) after transformations, reconstructing the original `Either` structure, showcasing losslessness.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nval effect         = ZIO.attempt(Left[Int, String](5))\nval leftProjection = effect.left\nval unlefted       = leftProjection.map(_ * 2).unleft \n```\n\n----------------------------------------\n\nTITLE: Using ignore Operator to Discard Results - Scala\nDESCRIPTION: Alternative to fold: demonstrates the use of the ignore method, which discards both error and success values, similar to mapping both cases to Unit. Useful for converting any effect to a ZIO returning Unit. No special prerequisites beyond ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval result: ZIO[Any, Nothing, Unit] = ZIO.fail(\"Uh oh!\").as(5).ignore\n```\n\n----------------------------------------\n\nTITLE: File Transfer with Nested ZIO Brackets\nDESCRIPTION: An example showing file transfer using nested brackets to manage both input and output file streams, demonstrating how to handle multiple resources sequentially with the bracket pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef is(file: String): Task[FileInputStream]  = Task.effect(???)\ndef os(file: String): Task[FileOutputStream] = Task.effect(???)\n\ndef close(resource: Closeable): UIO[Unit] = Task.effectTotal(???)\ndef copy(from: FileInputStream, to: FileOutputStream): Task[Unit] = ???\n\ndef transfer(src: String, dst: String): ZIO[Any, Throwable, Unit] = {\n  Task.bracket(is(src))(close) { in =>\n    Task.bracket(os(dst))(close) { out =>\n      copy(in, out)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic ZIO Test Suite in Scala\nDESCRIPTION: This snippet demonstrates how to create a minimal test suite by extending ZIOSpecDefault and implementing the spec method. It sets up the structure for adding tests later.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/writing-our-first-test.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nobject HelloWorldSpec extends ZIOSpecDefault {\n  def spec = \n    suite(\"HelloWorldSpec\")(\n      ??? // all tests go here\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shared State with ZIO Ref in Scala\nDESCRIPTION: This example uses `Ref.make` to create a mutable reference shared between two concurrently running fibers (`left` and `right`). Both fibers update the same `Ref`. The output shows that updates from both fibers interleave and affect the shared state, demonstrating the behavior of `Ref` for shared mutable state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject RefExample extends ZIOAppDefault {\n\n  def run =\n    for {\n      ref <- Ref.make(0)\n      left = ref.updateAndGet(_ + 1).debug(\"left1\") *>\n        ref.updateAndGet(_ + 1).debug(\"left2\")\n      right = ref.updateAndGet(_ + 1).debug(\"right1\") *>\n        ref.updateAndGet(_ + 3).debug(\"right2\")\n      _ <- left <&> right\n    } yield ()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a ZLayer for a Dependent Service in Scala\nDESCRIPTION: Demonstrates how to create a ZLayer for service C that depends on services A and B.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nobject C {\n  def baz: ZIO[C, Nothing, Unit] = ZIO.serviceWithZIO[C](_.baz)\n\n  val layer: ZLayer[A with B, Nothing, C] =\n    ZLayer {\n      for {\n        a <- ZIO.service[A]\n        b <- ZIO.service[B]\n      } yield C(a, b)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Scoping Child Fiber with Parent in ZIO and Automatic Interruption (Scala)\nDESCRIPTION: This code demonstrates how a parent fiber's lifecycle dictates the fate of its child fibers in ZIO. When the parent finishes, any non-joined child fiber is automatically interrupted. The example uses ZIOAppDefault, creates a child fiber that runs forever with ZIO.never, and logs interruption events with onInterrupt. Outputs illustrate fiber thread management and the precise point of child fiber interruption. ZIO (Scala) is required.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\nobject MainApp extends ZIOAppDefault {\\n  def debugInterruption(taskName: String) = (fibers: Set[FiberId]) =>\\n    for {\\n      fn <- ZIO.fiberId.map(_.threadName)\\n      _  <- ZIO.debug(\\n              s\"the $fn fiber which is the underlying fiber of the $taskName task \" +\\n              s\"interrupted by ${fibers.map(_.threadName).mkString(\", \")}\"\\n            )\\n    } yield ()\\n\\n  def run =\\n    for {\\n      fn <- ZIO.fiberId.map(_.threadName)\\n      _  <- ZIO.debug(s\"$fn starts working.\")\\n      child =\\n        for {\\n          cfn <- ZIO.fiberId.map(_.threadName)\\n          _   <- ZIO.debug(s\"$cfn starts working by forking from its parent ($fn)\")\\n          _   <- ZIO.never\\n        } yield ()\\n      _  <- child.onInterrupt(debugInterruption(\"child\")).fork\\n      _  <- ZIO.sleep(1.second)\\n      _  <- ZIO.debug(s\"$fn finishes its job and is going go exit.\")\\n    } yield ()\\n    \\n}\n```\n\n----------------------------------------\n\nTITLE: Managing State with Recursive Functions in ZIO\nDESCRIPTION: Example of managing application state using a recursive function approach where state is passed as a parameter through recursive calls. This function collects user input names until the user enters 'q'.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/global-shared-state.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef inputNames: ZIO[Any, String, List[String]] = {\n  def loop(names: List[String]): ZIO[Any, String, List[String]] = {\n    Console.readLine(\"Please enter a name or `q` to exit: \").orDie.flatMap {\n      case \"q\" =>\n        ZIO.succeed(names)\n      case name =>\n        loop(names appended name)\n    }\n  }\n\n  loop(List.empty[String])\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Services with Dependencies in Scala\nDESCRIPTION: Demonstrates how to define services A and B with their corresponding layers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfinal class A {\n  def foo: ZIO[Any, Nothing, String] = ZIO.succeed(\"Hello!\")\n}\n\nobject A {\n  def foo: ZIO[A, Nothing, String] = ZIO.serviceWithZIO[A](_.foo)\n\n  val layer: ZLayer[Any, Nothing, A] = ZLayer.succeed(new A)\n}\n\nfinal class B {\n  def bar: ZIO[Any, Nothing, Int] = ZIO.succeed(42)\n}\n\nobject B {\n  def bar: ZIO[B, Nothing, Int] = ZIO.serviceWithZIO[B](_.bar)\n\n  val layer: ZLayer[Any, Nothing, B] = ZLayer.succeed(new B)\n}\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Asynchronous Tasks with ZIO Semaphore in Scala\nDESCRIPTION: This snippet demonstrates how to use a ZIO Semaphore to synchronize asynchronous tasks. It creates a semaphore with one permit and executes multiple tasks that require the semaphore's permit to run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/semaphore.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.concurrent.TimeUnit\nimport zio._\nimport zio.Console._\n\nval task = for {\n  _ <- printLine(\"start\")\n  _ <- ZIO.sleep(Duration(2, TimeUnit.SECONDS))\n  _ <- printLine(\"end\")\n} yield ()\n\nval semTask = (sem: Semaphore) => for {\n  _ <- sem.withPermit(task)\n} yield ()\n\nval semTaskSeq = (sem: Semaphore) => (1 to 3).map(_ => semTask(sem))\n\nval program = for {\n\n  sem <- Semaphore.make(permits = 1)\n\n  seq <- ZIO.succeed(semTaskSeq(sem))\n\n  _ <- ZIO.collectAllPar(seq)\n\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Chaining ZIO Effects with flatMap in Scala\nDESCRIPTION: Shows how to sequence two ZIO effects using the flatMap method, which allows the second effect to depend on the result of the first.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-operations.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval sequenced: ZIO[Any, IOException, Unit] =\n  Console.readLine.flatMap(input => Console.printLine(s\"You entered: $input\"))\n```\n\n----------------------------------------\n\nTITLE: Quill with ZIO Integration Example\nDESCRIPTION: A complete example of using Quill with ZIO to perform database operations. It demonstrates defining entities, inserting data, and querying data using Quill's compile-time query generation with ZIO integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_53\n\nLANGUAGE: scala\nCODE:\n```\nimport io.getquill._\nimport io.getquill.context.ZioJdbc._\nimport zio.console.{Console, putStrLn}\nimport zio.{ExitCode, Has, URIO, ZIO}\n\nimport java.io.Closeable\nimport javax.sql\n\nobject QuillZIOExample extends zio.App {\n  val ctx = new H2ZioJdbcContext(Literal)\n\n  import ctx._\n\n  case class Person(name: String, age: Int)\n\n  val myApp: ZIO[Console with Has[sql.DataSource with Closeable], Exception, Unit] =\n    for {\n      _ <- ctx.run(\n        quote {\n          liftQuery(List(Person(\"Alex\", 25), Person(\"Sarah\", 23)))\n            .foreach(r =>\n              query[Person].insert(r)\n            )\n        }\n      ).onDS\n      result <- ctx.run(\n        quote(query[Person].filter(p => p.name == \"Sarah\"))\n      ).onDS\n      _ <- putStrLn(result.toString)\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp\n      .provideCustomLayer(DataSourceLayer.fromPrefix(\"myH2DB\"))\n      .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Job Processing with ZIO\nDESCRIPTION: Shows how to achieve parallelism in ZIO using ZIO.foreachPar and ZIO.withParallelism operators to process jobs concurrently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def jobRunner(n: Int) =\n    for {\n      _ <- Console.printLine(s\"job$n - started\")\n      _ <- ZIO.sleep(1.second)\n      _ <- Console.printLine(s\"job$n - finished\")\n    } yield ()\n\n  val jobs = (1 to 10)\n  \n  def run = ZIO.foreachParDiscard(jobs)(jobRunner)\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nZIO.withParallelism(4) {\n  ZIO.foreachParDiscard(jobs)(jobRunner)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Proxy Server with Tracing\nDESCRIPTION: Proxy HTTP server that forwards requests to the backend while maintaining trace context and adding span information.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_50\n\nLANGUAGE: scala\nCODE:\n```\nobject ProxyServer extends CatsApp {\n\n  type AppTask[A] = ZIO[Clock, Throwable, A]\n\n  private val backend = AsyncHttpClientZioBackend()\n\n  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =\n    ZIO.runtime[Clock].flatMap { implicit runtime =>\n      implicit val ec = runtime.platform.executor.asEC\n      BlazeServerBuilder[AppTask](ec)\n        .bindHttp(port = 8080, host = \"0.0.0.0\")\n        .withHttpApp(\n          Router[AppTask](mappings = \"/\" -> {\n            val dsl: Http4sDsl[AppTask] = Http4sDsl[AppTask]\n            import dsl._\n\n            HttpRoutes.of[AppTask] { case GET -> Root =>\n              (for {\n                _ <- OpenTracing.tag(Tags.SPAN_KIND.getKey, Tags.SPAN_KIND_CLIENT)\n                _ <- OpenTracing.tag(Tags.HTTP_METHOD.getKey, GET.name)\n                _ <- OpenTracing.setBaggageItem(\"proxy-baggage-item-key\", \"proxy-baggage-item-value\")\n                buffer = new TextMapAdapter(mutable.Map.empty[String, String].asJava)\n                _ <- OpenTracing.inject(HttpHeadersFormat, buffer)\n                headers <- extractHeaders(buffer)\n                res <-\n                  backend.flatMap { implicit backend =>\n                    basicRequest.get(Uri(\"0.0.0.0\", 9000).path(\"/\")).headers(headers).send()\n                  }.map(_.body)\n                    .flatMap {\n                      case Right(_) => Ok(\"Ok!\")\n                      case Left(_) => Ok(\"Oops!\")\n                    }\n              } yield res)\n                .root(operation = \"GET /\")\n                .provideLayer(\n                  makeJaegerTracer(host = \"0.0.0.0:9411\", serviceName = \"proxy-server\")\n                )\n            }\n          }).orNotFound\n        )\n        .serve\n        .compile[AppTask, AppTask, catsExitCode]\n        .drain\n        .as(ExitCode.success)\n    }.exitCode\n\n  private def extractHeaders(adapter: TextMapAdapter): UIO[Map[String, String]] = {\n    val m = mutable.Map.empty[String, String]\n    UIO(adapter.forEach { entry =>\n      m.put(entry.getKey, entry.getValue)\n      ()\n    }).as(m.toMap)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Test ZIO Service with In-Memory State in Scala\nDESCRIPTION: This snippet defines a 'test' implementation of the `Database.Service` (`TestService`) using an in-memory `Map` to simulate database interactions. It includes helper methods (`setTestData`, `getTestData`) to manage the state for testing purposes. A `TestDatabase` trait and companion object are provided for easy injection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nclass TestService extends Database.Service {\n  private var map: Map[UserID, UserProfile] = Map()\n\n  def setTestData(map0: Map[UserID, UserProfile]): Task[Unit] = \n    Task { map = map0 }\n\n  def getTestData: Task[Map[UserID, UserProfile]] = \n    Task(map)\n\n  def lookup(id: UserID): Task[UserProfile] = \n    Task(map(id))\n\n  def update(id: UserID, profile: UserProfile): Task[Unit] = \n    Task.effect { map = map + (id -> profile) }\n}\ntrait TestDatabase extends Database {\n  val database: TestService = new TestService\n}\nobject TestDatabase extends TestDatabase\n```\n```\n\n----------------------------------------\n\nTITLE: Consuming Stream with ZSink\nDESCRIPTION: Shows how to consume a stream using ZSink by calculating the sum of stream elements. Uses the run method with ZSink.sum to process the stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/consuming-streams.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval sum: UIO[Int] = ZStream(1,2,3).run(ZSink.sum)\n```\n\n----------------------------------------\n\nTITLE: Consuming Kafka Messages with Individual Offset Commits using ZIO Streams in Scala\nDESCRIPTION: This Scala example demonstrates consuming messages from a Kafka topic using `consumer.plainStream` and committing offsets individually. The stream subscribes to `KAFKA_TOPIC`, uses `Serde.int` and `Serde.string` for deserialization, prints each consumed value using `tap`, extracts the `Offset` from each `CommittableRecord`, and then commits each offset individually using `mapZIO(_.commit)`. This method is noted as potentially inefficient due to frequent commits.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\nimport zio.kafka._\nimport zio.kafka.consumer._\nimport zio.kafka.serde._\n\nval KAFKA_TOPIC = \"my-topic\"\nval consumer: Consumer = ???\n\nval c: ZIO[Any, Throwable, Unit] =\n  consumer\n    .plainStream(Subscription.topics(KAFKA_TOPIC), Serde.int, Serde.string)\n    .tap(e => Console.printLine(e.value))\n    .map(_.offset)      // Get the offset of the record\n    .mapZIO(_.commit)   // Commit the offset\n    .runDrain\n```\n\n----------------------------------------\n\nTITLE: Failing Stream on Left Values with rightOrFail (Scala)\nDESCRIPTION: Shows how to use ZStream#rightOrFail to fail a stream of Either values as soon as a Left value is emitted. The example demonstrates converting a stream of Either[String, Int] to a stream that fails on Left values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\n// Stream of Either values that cannot fail\nval eitherStream: ZStream[Any, Nothing, Either[String, Int]] =\n  ZStream(Right(1), Right(2), Left(\"failed to parse\"), Right(4))\n\n// A Fails with the first emission of the left value\nval stream: ZStream[Any, String, Int] = eitherStream.rightOrFail(\"fail\")\n```\n\n----------------------------------------\n\nTITLE: Performing Effects for TMap Entries in ZIO STM\nDESCRIPTION: Uses foreach to perform an STM effect for each key-value pair in the map. This example adds formatted entries to a transactional queue for each element in the map.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foreachTMap = (for {\n  tMap   <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  tQueue <- TQueue.unbounded[String]\n  _      <- tMap.foreach((k, v) => tQueue.offer(s\"$k -> $v\").unit)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Metrics in ZIO Application\nDESCRIPTION: Scala code demonstrating how to implement custom metrics in a ZIO application, using a Fibonacci calculation as an example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.metrics.Metric\n\nobject MainApp extends ZIOAppDefault {\n  private val count = Metric.counterInt(\"fib_call_total\").fromConst(1)\n\n  def fib(n: Int): ZIO[Any, Nothing, Int] =\n    if (n <= 1) ZIO.succeed(1)\n    else for {\n      a <- fib(n - 1) @@ count\n      b <- fib(n - 2) @@ count\n    } yield a + b\n\n  def run =\n    for {\n      i <- Console.readLine(\"Please enter a number to calculate fibonacci: \").mapAttempt(_.toInt)\n      n <- fib(i) @@ count\n      _ <- Console.printLine(s\"fib($i) = $n\")\n      c <- count.value\n      _ <- ZIO.debug(s\"number of fib calls to calculate fib($i): ${c.count}\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Either to ZIO Effect using ZIO.fromEither in Scala\nDESCRIPTION: Uses `ZIO.fromEither` to convert a `scala.util.Either[E, A]` into a `ZIO[Any, E, A]` effect. A `Right(\"Success!\")` becomes a ZIO effect that succeeds with the value \"Success!\", while a `Left(e)` would become a ZIO effect that fails with the error `e`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval zeither = ZIO.fromEither(Right(\"Success!\"))\n```\n\n----------------------------------------\n\nTITLE: Implementing `parseInt` using `refineToOrDie` in ZIO Scala\nDESCRIPTION: Demonstrates implementing a `parseInt` function using `ZIO.attempt` to capture potential exceptions from `String#toInt` into the error channel (`Throwable`). It then uses `refineToOrDie[NumberFormatException]` to specifically handle only `NumberFormatException` as a typed error, causing any other `Throwable` to become a defect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.attempt(input.toInt)                 // ZIO[Any, Throwable, Int]\n    .refineToOrDie[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n```\n\n----------------------------------------\n\nTITLE: Applying Test Aspects in ZIO Test (Scala)\nDESCRIPTION: Shows how to apply and compose multiple test aspects in ZIO Test, such as timeouts and platform-specific test execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/why-zio-test.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.TestAspect._\n\ntest(\"another zio test\")(???) @@ timeout(60.seconds) @@ jvmOnly\n```\n\n----------------------------------------\n\nTITLE: Debugging ZIO Fibonacci Function with debug Effect\nDESCRIPTION: The ZIO Fibonacci function enhanced with ZIO.debug to trace the computation steps, demonstrating the proper way to debug ZIO applications using built-in debugging effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/debug-a-zio-application.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef fib(n: Int): ZIO[Any, Nothing, Int] = {\n  if (n <= 1) ZIO.succeed(n).debug(s\"fib($n) = $n\")\n  else {\n    fib(n - 1)\n      .zipWith(fib(n - 2))(_ + _)\n      .debug(s\"fib($n) = fib(${n - 1}) + fib(${n - 2})\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Partially Providing Services Using ZIO#provideSome in Scala\nDESCRIPTION: This snippet shows how to partially provide service implementations to a ZIO effect using the provideSome method. It demonstrates providing only the Foo service while leaving Bar as a requirement.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-propagation.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval mainEffectSome: ZIO[Bar, Nothing, Unit] = \n  myApp.provideSome(FooLive.layer)\n```\n\n----------------------------------------\n\nTITLE: Folding Operations on ZIO Streams\nDESCRIPTION: Demonstrates two folding operations on streams: a simple fold that sums all elements, and a conditional fold that sums elements while meeting a condition. Uses runFold and runFoldWhile methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/consuming-streams.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval s1: ZIO[Any, Nothing, Int] = ZStream(1, 2, 3, 4, 5).runFold(0)(_ + _)\nval s2: ZIO[Any, Nothing, Int] = ZStream.iterate(1)(_ + 1).runFoldWhile(0)(_ <= 5)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Simplified File Transfer with ZManaged and ZIO Composition\nDESCRIPTION: A more concise implementation of file transfer using ZManaged combined with ZIO effects, demonstrating how to convert between ZIO and ZManaged and use useNow for direct execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(from: String, to: String): ZIO[Any, Throwable, Unit] = {\n  val resource: ZManaged[Any, Throwable, Unit] = for {\n    from <- ZManaged.make(is(from))(close)\n    to   <- ZManaged.make(os(to))(close)\n    _    <- copy(from, to).toManaged_\n  } yield ()\n  resource.useNow\n}\n```\n\n----------------------------------------\n\nTITLE: Http4s Integration with ZIO (Cats Effect 2)\nDESCRIPTION: Example of creating an Http4s web server using ZIO and Cats Effect 2, implementing a simple Hello World route.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.effect.{ConcurrentEffect, Sync, Timer}\nimport cats.implicits._\nimport fs2.Stream\nimport org.http4s.HttpRoutes\nimport org.http4s.client.blaze.BlazeClientBuilder\nimport org.http4s.dsl.Http4sDsl\nimport org.http4s.server.blaze.BlazeServerBuilder\nimport zio.interop.catz._\nimport zio.interop.catz.implicits._ \nimport zio.{Task, URIO}\n\nimport scala.concurrent.ExecutionContext.global\n\nobject ZioHttp4sInterop extends CatsApp {\n  def run(args: List[String]): URIO[Any, zio.ExitCode] =\n    stream[Task].compile.drain.exitCode\n  \n  def stream[F[_]: ConcurrentEffect: Timer]: Stream[F, Nothing] = {\n    import org.http4s.implicits._\n    val httpApp = helloWorldRoute[F].orNotFound\n    for {\n      _ <- BlazeClientBuilder[F](global).stream\n      exitCode <- BlazeServerBuilder[F](global)\n        .bindHttp(8080, \"0.0.0.0\")\n        .withHttpApp(httpApp)\n        .serve\n    } yield exitCode\n  }.drain\n\n  def helloWorldRoute[F[_]: Sync]: HttpRoutes[F] = {\n    val dsl = new Http4sDsl[F]{}\n    import dsl._\n    HttpRoutes.strict[F] {\n      case GET -> Root =>\n        Ok(\"Hello, World!\")\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Configuration Using ZIO.config - Scala\nDESCRIPTION: This snippet shows how to access typed configuration in a ZIO effect using `ZIO.config`. It leverages the previously defined `HttpServerConfig` to obtain config values safely, which can be used in effectful code for further processing. Requires the config descriptor to be in scope.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nZIO.config[HttpServerConfig].flatMap { config =>\n  ??? // Do something with the configuration\n}\n```\n\n----------------------------------------\n\nTITLE: Creating TRef in a Transaction\nDESCRIPTION: Creates a TRef within an STM transaction. This provides a mutable reference to an immutable value that can participate in transactional operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval createTRef: STM[Nothing, TRef[Int]] = TRef.make(10)\n```\n\n----------------------------------------\n\nTITLE: Completing a TPromise with Success\nDESCRIPTION: Successfully completes a TPromise by setting its value. This example creates a TPromise and then immediately completes it with the value 0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpromise.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseSucceed: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.succeed(0).commit\n} yield tPromise\n```\n\n----------------------------------------\n\nTITLE: Validating Weight with ZIO Option\nDESCRIPTION: Demonstrates using a Scala if-else expression with ZIO to validate a weight input and return an Option[Double].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef validateWeightOption(weight: Double): ZIO[Any, Nothing, Option[Double]] =\n  if (weight >= 0)\n    ZIO.some(weight)\n  else\n    ZIO.none\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retryOrElseEither for Distinct Outcomes in Scala\nDESCRIPTION: Demonstrates `retryOrElseEither`. It attempts `readLocalConfig` and retries based on a Fibonacci schedule (`Schedule.fibonacci(1.seconds)`). If retries fail, it executes the `orElse` fallback (`readRemoteConfig`). The final result is an `Either`, containing the successful result from `readRemoteConfig` (Left) or `readLocalConfig` (Right). Requires placeholder definitions for `LocalConfig`, `RemoteConfig`, `readLocalConfig`, and `readRemoteConfig`, along with ZIO and `Schedule`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait LocalConfig\ntrait RemoteConfig\n\ndef readLocalConfig: ZIO[Any, Throwable, LocalConfig] = ???\ndef readRemoteConfig: ZIO[Any, Throwable, RemoteConfig] = ???\n\nval result: ZIO[Any, Throwable, Either[RemoteConfig, LocalConfig]] =\n  readLocalConfig.retryOrElseEither(\n    schedule0 = Schedule.fibonacci(1.seconds),\n    orElse = (_, _: Duration) => readRemoteConfig\n  )\n```\n\n----------------------------------------\n\nTITLE: Catching Specific Errors in ZIO\nDESCRIPTION: Illustrates the use of the catchSome method to catch and recover from specific types of recoverable errors in ZIO, allowing for targeted error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval data: ZIO[Any, IOException, Array[Byte]] = \n  openFile(\"primary.data\").catchSome {\n    case _ : FileNotFoundException => \n      openFile(\"backup.data\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating CyclicBarrier Behavior in Scala with ZIO\nDESCRIPTION: This code snippet demonstrates the behavior of a CyclicBarrier in ZIO. It creates a barrier, forks two fibers that await on the barrier, and shows how a timeout can cause the barrier to break. The example uses TestClock to simulate time passage and checks the barrier's broken state before and after the timeout.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/cyclicbarrier.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent.CyclicBarrier\nimport zio.test.TestClock\n\nfor {\n  barrier   <- CyclicBarrier.make(100)\n  f1        <- barrier.await.timeout(1.second).fork\n  f2        <- barrier.await.fork\n  _         <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  _         <- f2.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  isBroken1 <- barrier.isBroken\n  _         <- TestClock.adjust(1.second)\n  isBroken2 <- barrier.isBroken\n  res1      <- f1.await\n  res2      <- f2.await\n} yield assert(!isBroken1 && isBroken2)\n```\n\n----------------------------------------\n\nTITLE: Implementing a LogSpan Aspect in Scala for ZIO\nDESCRIPTION: Defines a custom ZIO Aspect called LogAspect.logSpan that can be applied to any ZIO workflow to wrap it in a logging span.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject LogAspect {\n  def logSpan(\n      label: String\n  ): ZIOAspect[Nothing, Any, Nothing, Any, Nothing, Any] =\n    new ZIOAspect[Nothing, Any, Nothing, Any, Nothing, Any] {\n      override def apply[R, E, A](zio: ZIO[R, E, A])(\n        implicit trace: Trace\n      ): ZIO[R, E, A] =\n        ZIO.logSpan(label)(zio)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using fold to Provide Default Data on Failure - Scala\nDESCRIPTION: Demonstrates using fold to select a default value if a ZIO effect fails, otherwise returning the successful result. readFile is invoked, and on failure DefaultData is used. Shows how to convert a possibly failing ZIO into a UIO by handling both success and failure. Assumes previous definition of readFile and DefaultData.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nlazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: UIO[Array[Byte]] =\n  readFile(\"primary.data\").fold(_ => DefaultData, data => data)\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Effects with a Custom Runtime Environment in Scala\nDESCRIPTION: This snippet demonstrates how to run a ZIO effect using a custom `Runtime` (`testableRuntime`) that already contains the required services (`LoggingService` and `EmailService`) in its environment. It uses `Unsafe.unsafe` and `runtime.unsafe.run` to execute a `for`-comprehension that calls the service accessor methods (`LoggingService.log` and `EmailService.send`). The services are automatically picked up from the runtime's environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nUnsafe.unsafe { implicit unsafe =>\n    testableRuntime.unsafe.run(\n      for {\n        _ <- LoggingService.log(\"sending newsletter\")\n        _ <- EmailService.send(\"David\", \"Hi! Here is today's newsletter.\")\n      } yield ()\n    ).getOrThrowFiberFailure()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Caliban GraphQL API in Scala\nDESCRIPTION: Demonstrates how to define a Caliban GraphQL API using case classes and ADTs in Scala. Includes data models, query definitions, and a simple ZIO application to serve the GraphQL API.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport caliban.GraphQL.graphQL\nimport caliban.schema.Annotations.GQLDescription\nimport caliban.{RootResolver, ZHttpAdapter}\nimport zhttp.http._\nimport zhttp.service.Server\nimport zio.{ExitCode, ZEnv, ZIO}\n\nimport scala.language.postfixOps\n\nsealed trait Role\n\nobject Role {\n  case object SoftwareDeveloper       extends Role\n  case object SiteReliabilityEngineer extends Role\n  case object DevOps                  extends Role\n}\n\ncase class Employee(\n    name: String,\n    role: Role\n)\n\ncase class EmployeesArgs(role: Role)\ncase class EmployeeArgs(name: String)\n\ncase class Queries(\n    @GQLDescription(\"Return all employees with specific role\")\n    employees: EmployeesArgs => List[Employee],\n    @GQLDescription(\"Find an employee by its name\")\n    employee: EmployeeArgs => Option[Employee]\n)\nobject CalibanExample extends zio.App {\n\n  val employees = List(\n    Employee(\"Alex\", Role.DevOps),\n    Employee(\"Maria\", Role.SoftwareDeveloper),\n    Employee(\"James\", Role.SiteReliabilityEngineer),\n    Employee(\"Peter\", Role.SoftwareDeveloper),\n    Employee(\"Julia\", Role.SiteReliabilityEngineer),\n    Employee(\"Roberta\", Role.DevOps)\n  )\n\n  val myApp = for {\n    interpreter <- graphQL(\n      RootResolver(\n        Queries(\n          args => employees.filter(e => args.role == e.role),\n          args => employees.find(e => e.name == args.name)\n        )\n      )\n    ).interpreter\n    _ <- Server\n      .start(\n        port = 8088,\n        http = Http.route { case _ -> Root / \"api\" / \"graphql\" =>\n          ZHttpAdapter.makeHttpService(interpreter)\n        }\n      )\n      .forever\n  } yield ()\n\n  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =\n    myApp.exitCode\n\n}\n```\n\n----------------------------------------\n\nTITLE: Resource Usage with Scope Service\nDESCRIPTION: Example of using Scope as a service in the ZIO environment for managing resource lifecycles.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval resourcefulApp: ZIO[Scope, Nothing, Unit] =\n  for {\n    scope <- ZIO.service[Scope]\n    _     <- ZIO.debug(\"Entering the scope!\")\n    _ <- scope.addFinalizer(\n      for {\n        _ <- ZIO.debug(\"The finalizer is started!\")\n        _ <- ZIO.sleep(5.seconds)\n        _ <- ZIO.debug(\"The finalizer is done!\")\n      } yield ()\n    )\n    _ <- ZIO.debug(\"Leaving scope!\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Using Hub with ZStream in Scala\nDESCRIPTION: Demonstrates how to use a Hub with a ZStream, allowing multiple consumers to process the same stream of transactions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntype Transaction = ???\n\nval transactionStream: ZStream[Any, Nothing, Transaction] =\n  ???\n\nval hub: Hub[Take[Nothing, Transaction]] =\n  ???\n\ntransactionStream.into(hub)\n```\n\n----------------------------------------\n\nTITLE: Converting Callback-Based APIs to ZIO Effects\nDESCRIPTION: Demonstrates converting an asynchronous callback-based API into a ZIO effect using ZIO.async. This transforms difficult-to-use callback APIs into composable ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject legacy {\n  def login(\n    onSuccess: User => Unit,\n    onFailure: AuthError => Unit): Unit = ???\n}\n\nval login: IO[AuthError, User] =\n  ZIO.async[Any, AuthError, User] { callback =>\n    legacy.login(\n      user => callback(ZIO.succeed(user)),\n      err  => callback(ZIO.fail(err))\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO#orElseEither Method Signature in Scala\nDESCRIPTION: This snippet shows the method signature for `orElseEither`. Similar to `orElse`, it executes the `that` effect if the original fails. However, it unifies the potentially different success types (`A` and `B`) into an `Either[A, B]`, allowing fallbacks with different successful outcomes. The error type `E2` is determined by the fallback effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def orElseEither[R1 <: R, E2, B](that: => ZIO[R1, E2, B]): ZIO[R1, E2, Either[A, B]]\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Console for Input (Scala)\nDESCRIPTION: Shows how to read a line of text from standard input using the `getStrLn` effect from `zio.console`. The example then uses `flatMap` to chain this effect with `putStrLn`, effectively creating a program that reads a line and then prints it back (echoes it). The resulting `echo` value is a `ZIO` effect representing this combined operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/getting_started.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval echo = getStrLn.flatMap(line => putStrLn(line))\n// echo: ZIO[Console, java.io.IOException, Unit] = zio.ZIO$FlatMap@49de1505\n```\n\n----------------------------------------\n\nTITLE: Creating Reloadable Layer for Counter Service\nDESCRIPTION: This snippet shows how to create a reloadable layer for the Counter service using the ZLayer#reloadable method from zio-macros.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros._\n\nobject Counter {\n\n  val live: ZLayer[Any, Nothing, Counter] = ???\n\n  val reloadable: ZLayer[ServiceReloader, ServiceReloader.Error, Counter] =\n    live.reloadable\n}\n```\n\n----------------------------------------\n\nTITLE: Safe String Conversion Using mapAttempt - Scala\nDESCRIPTION: Demonstrates use of mapAttempt to map side-effecting code (.toInt) within a ZIO effect, handling exceptions as typed failures instead of defects. Dependencies: zio._ and input/output routines. Output type is ZIO[Any, Throwable, Int]; exceptions from toInt become ZIO errors, not program crashes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval result: ZIO[Any, Throwable, Int] =\n  Console.readLine.orDie.mapAttempt(_.toInt)\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Debugging Die Cause in Scala\nDESCRIPTION: Illustrates how to create a Die cause using Cause.die and ZIO.failCause, and shows examples of debugging Die causes in various ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.failCause(Cause.die(new Throwable(\"Boom!\"))).cause.debug\n// Die(java.lang.Throwable: Boom!,Trace(Runtime(2,1646479908),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n\nZIO.succeed(5 / 0).cause.debug\n// Die(java.lang.ArithmeticException: / by zero,Trace(Runtime(2,1646480112),Chunk(zio.internal.FiberContext.runUntil(FiberContext.scala:538),<empty>.MainApp.run(MainApp.scala:3))))\n\nZIO.dieMessage(\"Boom!\").cause.debug\n// Stackless(Die(java.lang.RuntimeException: Boom!,Trace(Runtime(2,1646398246),Chunk(<empty>.MainApp.run(MainApp.scala:7)))),true)\n```\n\n----------------------------------------\n\nTITLE: Creating Jaeger Tracer ZLayer\nDESCRIPTION: Implementation of a ZLayer that provides Jaeger tracer configuration for OpenTracing with Zipkin reporter setup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nobject JaegerTracer {\n  def makeJaegerTracer(host: String, serviceName: String): ZLayer[Clock, Throwable, Clock with OpenTracing] =\n    OpenTracing.live(new Configuration(serviceName)\n      .getTracerBuilder\n      .withSampler(new ConstSampler(true))\n      .withReporter(\n        new ZipkinV2Reporter(\n          AsyncReporter.create(\n            OkHttpSender.newBuilder\n              .compressionEnabled(true)\n              .endpoint(\n                new URIBuilder()\n                  .setScheme(\"http\")\n                  .setHost(host)\n                  .setPath(\"/api/v2/spans\")\n                  .build.toString\n              )\n              .build\n          )\n        )\n      )\n      .build\n    ) ++ Clock.live\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Various Cause Types in Scala with ZIO\nDESCRIPTION: This example demonstrates how to create different types of causes in ZIO including Fail, Die, Then, Both, and Interrupt. It shows how to run operations that result in different failure scenarios and capture their exit values for inspection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/cause.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.duration._\nfor {\n  failExit <- ZIO.fail(\"Oh! Error!\").run\n  dieExit  <- ZIO.effectTotal(5 / 0).run\n  thenExit <- ZIO.fail(\"first\").ensuring(ZIO.die(throw new Exception(\"second\"))).run\n  bothExit <- ZIO.fail(\"first\").zipPar(ZIO.die(throw new Exception(\"second\"))).run\n  fiber    <- ZIO.sleep(1.second).fork\n  _        <- fiber.interrupt\n  interruptionExit <- fiber.join.run\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Declaring map and mapAttempt in ZIO Trait - Scala\nDESCRIPTION: Adds method signatures for map and mapAttempt to the ZIO trait, showing how values or side-effecting computations (possibly throwing exceptions) are mapped over a ZIO effect. map preserves the original error type, but mapAttempt uniformly maps failures into Throwable. These combinators define how user code is applied to effect results during transformation. Requires the Cause and Throwable types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n  trait ZIO[-R, +E, +A] {\n    def map[B](f: A => B): ZIO[R, E, B]\n    def mapAttempt[B](f: A => B): ZIO[R, Throwable, B]\n  }\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Imports and Runtime for ZIO Reactive Streams\nDESCRIPTION: Sets up the necessary imports and runtime environment for ZIO and Reactive Streams interop examples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-reactive-streams.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport org.reactivestreams.example.unicast._\nimport zio._\nimport zio.interop.reactivestreams._\nimport zio.stream._\n\nval runtime = Runtime.default\n```\n\n----------------------------------------\n\nTITLE: Defining a Stream-Based API Function\nDESCRIPTION: This code defines a function that returns a ZIO stream of books for a given author name. It represents a typical API endpoint that returns streaming results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\ndef getAuthorBooks(author: String): ZStream[Any, Throwable, Book] = ZStream(???)\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Encoder and Decoder for Event Class in Scala\nDESCRIPTION: Defines JSON encoder and decoder for the Event case class using zio-json's derivation capabilities. These are used to convert between Event objects and JSON strings.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.json._\n\nobject Event {\n  implicit val encoder: JsonEncoder[Event] =\n    DeriveJsonEncoder.gen[Event]\n\n  implicit val decoder: JsonDecoder[Event] =\n    DeriveJsonDecoder.gen[Event]\n}\n```\n\n----------------------------------------\n\nTITLE: ZKeyedPool with Key-dependent Size Example\nDESCRIPTION: Example showing how to create a ZKeyedPool with different sizes based on key patterns. Keys starting with 'foo' have a pool size of 2, keys starting with 'bar' have a size of 3, and other keys have a size of 1.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zkeyedpool.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  pool <- ZKeyedPool.make(resource, (key: String) => key match {\n    case k if k.startsWith(\"foo\") => 2\n    case k if k.startsWith(\"bar\") => 3\n    case _                        => 1\n  })\n  _    <- pool.get(\"foo1\")\n  item <- pool.get(\"bar1\")\n  _    <- ZIO.debug(s\"Item: $item\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing No-Op Side Effect with ZIO in Scala\nDESCRIPTION: This snippet defines an alternative processEvent2 function that models an effectful operation with ZIO but does nothing, returning ZIO.unit. The type signature is identical to the previous, demonstrating the possible range of effects. Requires: ZIO and Console. Input: Event instance. Output: URIO[Console, Unit], with no actual effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef processEvent2(event: Event): URIO[Console, Unit] =\n  ZIO.unit\n```\n\n----------------------------------------\n\nTITLE: Converting Publisher to ZIO Stream\nDESCRIPTION: Demonstrates converting a Reactive Streams Publisher to a ZIO Stream with configurable queue size for buffering elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-reactive-streams.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval streamFromPublisher = publisher.toStream(qSize = 16)\nruntime.unsafeRun(\n  streamFromPublisher.run(Sink.collectAll[Integer])\n)\n```\n\n----------------------------------------\n\nTITLE: Interrupting Parent Fiber without Affecting Daemon Fibers in ZIO (Scala)\nDESCRIPTION: This snippet illustrates that interrupting a parent fiber does not interrupt globally-scoped (daemon) fibers created via `forkDaemon`. The parent (`fooJob`) may be interrupted after a delay, logging shows that the daemon continues execution independently. Handles both interruption hooks and ongoing asynchronous work. Requires ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp2 extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug(\"Bar: still running!\")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Any, Nothing, Unit] =\n    (for {\n      _ <- ZIO.debug(\"Foo: started!\")\n      _ <- barJob.forkDaemon\n      _ <- ZIO.sleep(3.seconds)\n      _ <- ZIO.debug(\"Foo: finished!\")\n    } yield ()).onInterrupt(_ => ZIO.debug(\"Foo: interrupted!\"))\n\n  def run =\n    for {\n      f <- fooJob.fork\n      _ <- ZIO.sleep(2.seconds)\n      _ <- f.interrupt\n      _ <- ZIO.sleep(3.seconds)\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Intersecting Schedules with AND Operator\nDESCRIPTION: Shows how to intersect two schedules using the && operator. Combines exponential backoff with a fixed number of recurrences.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval expUpTo10 = Schedule.exponential(1.second) && Schedule.recurs(10)\n```\n\n----------------------------------------\n\nTITLE: Declaring Sliding Hub Constructor in Scala\nDESCRIPTION: Defines the signature for creating a sliding Hub with a specified capacity. The actual implementation is not provided in this snippet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef sliding[A](requestedCapacity: Int): UIO[Hub[A]] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: ZStream Creation from Async Callbacks in Scala\nDESCRIPTION: Demonstrates creating ZStreams from asynchronous callback-based APIs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// Asynchronous Callback-based API\ndef registerCallback(\n    name: String,\n    onEvent: Int => Unit,\n    onError: Throwable => Unit\n): Unit = ???\n\n// Lifting an Asynchronous API to ZStream\nval stream = ZStream.effectAsync[Any, Throwable, Int] { cb =>\n  registerCallback(\n    \"foo\",\n    event => cb(ZIO.succeed(Chunk(event))),\n    error => cb(ZIO.fail(error).mapError(Some(_)))\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding Sequential ZIO Errors with Then Cause - Scala\nDESCRIPTION: This Scala snippet demonstrates how to use ZIO's ensuring combinator to model try-finally behavior, where failure in both the main effect and the ensuring finalizer are combined via the Then cause. It relies on the 'zio' library, and expects ZIO to be properly imported. The code intentionally generates two errors, then inspects the combined cause using 'debug'. The expected output is a composed Cause reflecting both failures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\\n\\nval myApp =\\n  ZIO.fail(\"first\")\\n    .ensuring(ZIO.die(throw new Exception(\"second\")))\\n\\nmyApp.cause.debug\\n// Then(Fail(first,Trace(Runtime(2,1646486975),Chunk(<empty>.MainApp.myApp(MainApp.scala:4),<empty>.MainApp.myApp(MainApp.scala:5),<empty>.MainApp.run(MainApp.scala:7)))),Die(java.lang.Exception: second,Trace(Runtime(2,1646486975),Chunk(zio.internal.FiberContext.runUntil(FiberContext.scala:538),<empty>.MainApp.myApp(MainApp.scala:5),<empty>.MainApp.run(MainApp.scala:7)))))\n```\n\n----------------------------------------\n\nTITLE: Interruptible Blocking Operation in Scala ZIO\nDESCRIPTION: This snippet shows how to create interruptible blocking effects using effectBlockingInterrupt. This translates ZIO interruption into thread interruption, allowing the blocking operation to be properly terminated.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/blocking.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  _ <- putStrLn(\"Starting a blocking operation\")\n  fiber <- effectBlockingInterrupt {\n    while(true) {\n      Thread.sleep(1000)\n      println(\"Doing some blocking operation\")\n    }\n  }.ensuring(\n     putStrLn(\"End of the blocking operation\").orDie\n   ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(3.seconds)\n    )\n  )\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing Cleanup Actions with Ensuring\nDESCRIPTION: Shows how to implement cleanup actions that execute regardless of success or failure of the main effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport zio.Task\nvar i: Int = 0\nval action: Task[String] =\n  ZIO.succeed(i += 1) *>\n    ZIO.fail(new Throwable(\"Boom!\"))\nval cleanupAction: UIO[Unit] = ZIO.succeed(i -= 1)\nval composite = action.ensuring(cleanupAction)\n```\n\n----------------------------------------\n\nTITLE: Configurable Logger Usage Example\nDESCRIPTION: Example demonstrating the usage of the enhanced logging system with the ability to switch between different logger implementations at runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject FiberRefChangeDefaultLoggerExample extends ZIOAppDefault {\n  def run = for {\n    _ <- Logging.log(\"Hello World!\")\n    _ <- ZIO.foreachParDiscard(List(\"Jane\", \"John\")) { name =>\n      Logging.locallyWithLogger(Logging.silentLogger) {\n        Logging.logAnnotate(\"name\", name) {\n          for {\n            _ <- Logging.log(s\"Received request\")\n            fiberId <- ZIO.fiberId.map(_.ids.head)\n            _ <- Logging.logAnnotate(\"fiber_id\", s\"$fiberId\")(\n              Logging.log(\"Processing request\")\n            )\n            _ <- Logging.log(\"Finished processing request\")\n          } yield ()\n        }\n      }\n    }\n    _ <- Logging.log(\"All requests processed\")\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Counter in a Sequential ZIO Application\nDESCRIPTION: Example demonstrating how to use the Counter in a sequential ZIO application. It performs a series of increment and decrement operations before retrieving and displaying the final counter value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/global-shared-state.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      c <- Counter.make\n      _ <- c.inc\n      _ <- c.inc\n      _ <- c.dec\n      _ <- c.inc\n      v <- c.get\n      _ <- ZIO.debug(s\"This counter has a value of $v.\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining catchAllCause and catchSomeCause for ZIO - Scala\nDESCRIPTION: Declares the base operators for catching full error causes, including failures, defects, and interruptions. catchAllCause provides a handler for any ZIO Cause, and catchSomeCause allows partial matching. Essential for inspecting and recovering from all error causes in effectful computations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def catchAllCause[R1 <: R, E2, A1 >: A](h: Cause[E] => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n\n  def catchSomeCause[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[Cause[E], ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Local Scoping of FiberRef Values\nDESCRIPTION: Shows how to use the locally method to scope FiberRef values within a specific effect execution context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  correlationId <- FiberRef.make[String](\"\")\n  v1            <- correlationId.locally(\"my-correlation-id\")(correlationId.get)\n  v2            <- correlationId.get\n} yield v1 == \"my-correlation-id\" && v2 == \"\"\n```\n\n----------------------------------------\n\nTITLE: Joining a Fiber to Retrieve Its Result in ZIO Scala\nDESCRIPTION: Shows the usage of Fiber#join to await completion of a forked computation. Requires the ZIO environment, and demonstrates how to fork a simple effect and then join the fiber to retrieve its result. Input is an effectful computation; output is the joined result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  fiber   <- IO.succeed(\"Hi!\").fork\n  message <- fiber.join\n} yield message\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Kafka Producer.produceAll for Streaming Production in Scala\nDESCRIPTION: This Scala example demonstrates using the `producer.produceAll` method within a ZIO Stream pipeline. It maps chunks of integers into `ProducerRecord` instances with integer keys and string values, then pipes them through `produceAll` using appropriate Serdes (`Serde.int`, `Serde.string`) to send them to Kafka. The resulting stream of `RecordMetadata` is drained.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nZStream\n  .fromIterator(Iterator.from(0), maxChunkSize = 50)\n           // ZStream[Any, Throwable, Int]\n  .mapChunksZIO { chunk =>\n    chunk.map { i =>\n      new ProducerRecord(topic, key = i, value = s\"record $i\") \n    }\n  }        // ZStream[Any, Throwable, ProducerRecord]\n  .via(producer.produceAll(Serde.int, Serde.string))\n           // ZStream[Any, Throwable, RecordMetadata]\n  .runDrain\n```\n\n----------------------------------------\n\nTITLE: Defining Core ZIO Streams Components using ZChannel\nDESCRIPTION: Core type definitions showing how ZStream, ZSink and ZPipeline are implemented using ZChannel as their underlying abstraction. ZChannel provides a unified way to handle both input and output operations with error handling and environment requirements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZChannel[-Env, -InErr, -InElem, -InDone, +OutErr, +OutElem, +OutDone] \n\ncase class ZStream[-R, +E, +A] (\n  val channel: ZChannel[R, Any, Any, Any, E, Chunk[A], Any]\n)\n\ncase class ZSink[-R, +E, -In, +L, +Z] (\n  val channel: ZChannel[R, ZNothing, Chunk[In], Any, E, Chunk[L], Z]\n)\n\ncase class ZPipeline[-R, +E, -In, +Out] (\n  val channel: ZChannel[R, ZNothing, Chunk[In], Any, E, Chunk[Out], Any]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Layers for Services A, B, and C in Scala\nDESCRIPTION: This snippet defines traits A, B, and C, along with their corresponding ZLayers. B and C depend on A, demonstrating a dependency relationship.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-memoization.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait A\ntrait B\ntrait C\n\ncase class BLive(a: A) extends B\ncase class CLive(a: A) extends C\n\nval a: ZLayer[Any, Nothing, A] =\n  ZLayer(ZIO.succeed(new A {}).debug(\"initialized\"))\n\nval b: ZLayer[A, Nothing, B] =\n  ZLayer {\n    for {\n      a <- ZIO.service[A]\n    } yield BLive(a)\n  }\n\nval c: ZLayer[A, Nothing, C] =\n  ZLayer {\n    for {\n      a <- ZIO.service[A]\n    } yield CLive(a)\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Counter for Effect Output Values in Scala\nDESCRIPTION: Creates a `Counter[Long]` metric named \"countBytes\" using `Metric.counter`. This counter is intended to be incremented by the numeric output value of the ZIO effect it's applied to, suitable for tracking totals like bytes processed. Requires importing `zio._` and `zio.metrics._`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/counter.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval countBytes = Metric.counter(\"countBytes\")\n```\n\n----------------------------------------\n\nTITLE: Atomic Counter Update Implementation\nDESCRIPTION: Improved version of increment function using atomic updateAndGet operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef inc(counter: Ref[Int], amount: Int) = counter.updateAndGet(_ + amount)\n```\n\n----------------------------------------\n\nTITLE: Adaptive Batching with Dynamic Schedule in Scala\nDESCRIPTION: This advanced batching algorithm dynamically adjusts the batching schedule based on load. It uses longer timeouts (30s) when batch sizes are small, then switches to shorter timeouts (5s with jitter) when batch sizes exceed a threshold, balancing throughput and latency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_62\n\nLANGUAGE: scala\nCODE:\n```\nval schedule: Schedule[Clock with Random, Chunk[Chunk[Record]], Long] =\n  // Start off with 30-second timeouts as long as the batch size is < 1000\n  Schedule.fixed(30.seconds).whileInput[Chunk[Chunk[Record]]](_.flatten.length < 100) andThen\n    // and then, switch to a shorter jittered schedule for as long as batches remain over 1000\n    Schedule.fixed(5.seconds).jittered.whileInput[Chunk[Chunk[Record]]](_.flatten.length >= 1000)\n    \ndataStream\n  .aggregateAsyncWithin(ZTransducer.collectAllN(2000), schedule)\n```\n\n----------------------------------------\n\nTITLE: Basic FiberRef Logger Implementation in Scala\nDESCRIPTION: Implementation of a basic logging service using FiberRef to maintain isolated contextual state between fibers. Includes core logging functionality with annotation support.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Logger {\n  def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n  ): ZIO[R, E, A]\n  def log(message: String): UIO[Unit]\n}\n\nobject Logging extends Logger {\n  def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n  ): ZIO[R, E, A] = currentAnnotations.locallyWith(_.updated(key, value))(zio)\n\n  def log(message: String): UIO[Unit] = {\n    currentAnnotations.get.flatMap {\n      case annotation if annotation.isEmpty =>\n        Console.printLine(message).orDie\n      case annotation =>\n        val line =\n          s\"${annotation.map { case (k, v) => s\"[$k=$v]\" }.mkString(\" \")} $message\"\n        Console.printLine(line).orDie\n    }\n  }\n\n  val currentAnnotations: FiberRef[Map[String, String]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(Map.empty[String, String])\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Zipping ZIO Effects in Scala\nDESCRIPTION: Demonstrates how to combine two ZIO effects into a single effect using the zip, zipLeft, and zipRight methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-operations.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval zipped: ZIO[Any, Nothing, (String, Int)] = \n  ZIO.succeed(\"4\").zip(ZIO.succeed(2))\n\nval zipRight1: ZIO[Any, IOException, String] =\n  Console.printLine(\"What is your name?\").zipRight(Console.readLine)\n\nval zipRight2: ZIO[Any, IOException, String] =\n  Console.printLine(\"What is your name?\") *>\n    Console.readLine\n```\n\n----------------------------------------\n\nTITLE: Composing Logical Assertions in Scala\nDESCRIPTION: Illustrates how to compose multiple assertions using logical operators (AND, OR, NOT) to create more complex assertions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nval greaterThanZero: Assertion[Int] = Assertion.isPositive\nval lessThanFive   : Assertion[Int] = Assertion.isLessThan(5)\nval equalTo10      : Assertion[Int] = Assertion.equalTo(10)\n\nval assertion: Assertion[Int] = greaterThanZero && lessThanFive || !equalTo10\n```\n\n----------------------------------------\n\nTITLE: Defining EmailService Trait and Object in Scala\nDESCRIPTION: This snippet defines an EmailService trait with a send method and an accompanying object with a ZIO-based send method that uses the service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-propagation.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait EmailService {\n  def send(email: String, content: String): UIO[Unit]\n}\n\nobject EmailService {\n  def send(email: String, content: String) = ZIO.serviceWithZIO[EmailService](_.send(email, content))\n}\n```\n\n----------------------------------------\n\nTITLE: Effectful Handling with foldM for Content Fetching in ZIO for Scala\nDESCRIPTION: This snippet uses foldM to handle success and failure when reading a list of URLs, returning 'NoContent' on error or fetching the content on success. It requires ZIO and IO, and shows pattern matching in handlers. Inputs include filename to read and effectful content fetch; the output is a UIO[Content]. Used for implementing robust workflows where each branch is an effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nval urls: UIO[Content] =\n  readUrls(\"urls.json\").foldM(\n    error   => IO.succeed(NoContent(error)), \n    success => fetchContent(success)\n  )\n```\n\n----------------------------------------\n\nTITLE: Forking Fibers with Automatic Supervision in ZIO (Scala)\nDESCRIPTION: This snippet demonstrates structured concurrency in ZIO through automatic supervision, where a child fiber is forked and its lifetime is tied to its parent. When the parent fiber terminates, the child is interrupted. The example uses `onInterrupt` handlers and debug logs to show fiber lifecycles. Key dependencies: ZIO library, ZIOAppDefault trait. Input is no arguments; output is debug output during execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    for {\n      _ <- ZIO.debug(s\"Application started!\")\n      _ <- ZIO.never.onInterrupt(_ => ZIO.debug(s\"The child fiber interrupted!\")).fork\n      _ <- ZIO.debug(s\"Application finished!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Console for Output\nDESCRIPTION: This snippet shows how to use ZIO's Console module to print output to the console. It demonstrates both print and printLine functions for output with and without trailing line breaks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\n// Print without trailing line break\nConsole.print(\"Hello World\")\n\n// Print string and include trailing line break\nConsole.printLine(\"Hello World\")\n```\n\n----------------------------------------\n\nTITLE: Improved Stream Unfolding with Last Page Handling\nDESCRIPTION: Second attempt using Option type to properly handle the last page of paginated results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval secondAttempt: ZStream[Console, Throwable, RowData] = \n  ZStream.unfoldChunkM(Option[Int](0)) {\n    case None => ZIO.none // We already hit the last page\n    case Some(pageNumber) => // We did not hit the last page yet\n     for {\n        page <- listPaginated(pageNumber)\n      } yield Some(page.results, if (page.isLast) None else Some(pageNumber + 1))\n  }\n```\n\n----------------------------------------\n\nTITLE: Compositional Updates with RetryConfig\nDESCRIPTION: Complete example showing how to use the RetryConfig Differ with FiberRef for composable updates of the case class configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Main extends ZIOAppDefault {\n\n  val retryConfig: FiberRef[RetryConfig] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.makePatch[RetryConfig, (Int => Int, Int => Int)](\n        initialValue0 = RetryConfig(\n          retries = 3,\n          intervals = 2\n        ),\n        differ = differ,\n        fork0 = differ.empty\n      )\n    }\n\n  def withRetry(n: Int) = retryConfig.update(_.copy(retries = n))\n\n  def withIntervals(n: Int) = retryConfig.update(_.copy(intervals = n))\n\n  def run =\n    for {\n      _ <- withRetry(5) <&> withIntervals(3)\n      _ <- retryConfig.get.debug(\"retryConfig\")\n    } yield ()\n    \n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO.firstSuccessOf and ZIO#firstSuccessOf Signatures in Scala\nDESCRIPTION: These signatures introduce methods to run the first successful effect from a collection. `ZIO.firstSuccessOf` is a static method taking an initial effect and an iterable of fallback effects. `ZIO#firstSuccessOf` is an instance method called on an effect, taking an iterable of subsequent effects. Both execute effects sequentially using `orElse` until one succeeds, returning its result. If all fail, the last failure is returned.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nobject ZIO {\n  def firstSuccessOf[R, R1 <: R, E, A](\n    zio: => ZIO[R, E, A],\n    rest: => Iterable[ZIO[R1, E, A]]\n  ): ZIO[R1, E, A] =\n}\n\ntrait ZIO[-R, +E, +A] {\n  final def firstSuccessOf[R1 <: R, E1 >: E, A1 >: A](\n    rest: => Iterable[ZIO[R1, E1, A1]]\n  ): ZIO[R1, E1, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Fallback with orElse in ZIO (Scala)\nDESCRIPTION: Shows how to use the `orElse` combinator to try one effect, and if it fails, try another effect. This provides a fallback mechanism for error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nval primaryOrBackupData: IO[IOException, Array[Byte]] =\n  readFile(\"primary.data\").orElse(readFile(\"backup.data\"))\n```\n\n----------------------------------------\n\nTITLE: Interrupting Fibers with ZIO in Scala\nDESCRIPTION: Shows how to interrupt a long-running or infinite fiber using Fiber#interrupt and capture termination as an Exit. Requires ZIO. Demonstrates interruption of a forever-running effect and awaiting its cleanup before continuing. Output details how the fiber was terminated.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  fiber <- IO.succeed(\"Hi!\").forever.fork\n  exit  <- fiber.interrupt\n} yield exit\n```\n\n----------------------------------------\n\nTITLE: Wrapping Synchronous Side Effect with ZIO.effect - Scala\nDESCRIPTION: Demonstrates usage of ZIO.effect to wrap a synchronous, exception-throwing side effect (here, reading a line from stdin) in a managed Task effect. The error type is always Throwable. This integrates legacy or side-effecting APIs into ZIO's functional effect system.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn\n\nval getStrLn: Task[String] =\n  ZIO.effect(StdIn.readLine())\n```\n\n----------------------------------------\n\nTITLE: Selective Failure Recovery by Error Type Using catchSome - Scala\nDESCRIPTION: Handles only FileNotFoundException failures, providing a fallback operation selectively. The partial function enables other errors to pass through unhandled. The key dependency is readFile, and parameters involve specifying which error type to recover from.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval data: ZIO[Any, IOException, Array[Byte]] =\n  readFile(\"primary.data\").catchSome {\n    case _ : FileNotFoundException =>\n      readFile(\"backup.data\")\n  }\n```\n\n----------------------------------------\n\nTITLE: RetryConfig Case Class Definition\nDESCRIPTION: Definition of a type-safe RetryConfig case class for structured configuration management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\ncase class RetryConfig(\n    retries: Int,\n    intervals: Int\n)\n```\n\n----------------------------------------\n\nTITLE: Database Transaction Management with ZIO Environment\nDESCRIPTION: Illustrates database transaction handling using ZIO environment, showing atomic operations and transaction management patterns.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait DatabaseTransaction {\n  def get(key: String): Task[Int]\n  def put(key: String, value: Int): Task[Unit]\n}\n\nobject DatabaseTransaction {\n  def get(key: String): ZIO[DatabaseTransaction, Throwable, Int] =\n    ZIO.serviceWithZIO(_.get(key))\n\n  def put(key: String, value: Int): ZIO[DatabaseTransaction, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.put(key, value))\n}\n\ntrait Database {\n  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A]\n}\n\nobject Database {\n  def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Database, E, A] =\n    ZIO.serviceWithZIO(_.atomically(zio))\n}\n\ncase class DatabaseLive() extends Database {\n  override def atomically[E, A](zio: ZIO[DatabaseTransaction, E, A]): ZIO[Any, E, A] = ???\n}\n\nobject DatabaseLive {\n  val layer = ZLayer.succeed(DatabaseLive())\n}\n\nobject MainDatabaseApp extends ZIOAppDefault {\n  val myApp: ZIO[Database, Throwable, Unit] =\n    for {\n      _ <- Database.atomically(DatabaseTransaction.put(\"counter\", 0))\n      _ <- ZIO.foreachPar(List(1 to 10)) { _ =>\n        Database.atomically(\n          for {\n            value <- DatabaseTransaction.get(\"counter\")\n            _ <- DatabaseTransaction.put(\"counter\", value + 1)\n          } yield ()\n        )\n      }\n    } yield ()\n\n  def run = myApp.provideLayer(DatabaseLive.layer)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect Ref Creation with Mutable Data in Scala\nDESCRIPTION: Shows an example of incorrectly creating a Ref with mutable data, which can lead to race conditions. This is followed by the correct approach using immutable data.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Compiles but don't work properly\nval init = collection.mutable.Seq(1,3,5)\nval counterRef = Ref.make(init)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval init = Seq(1,3,5)\nval counterRef = Ref.make(init)\n```\n\n----------------------------------------\n\nTITLE: Defining `refineOrDieWith` Signature in ZIO Scala\nDESCRIPTION: Shows the type signature of the `refineOrDieWith` operator. This operator refines the error channel `E` to `E1` using a partial function `pf`. It requires an additional function `f` (`E => Throwable`) to convert any errors of type `E` not handled by `pf` into `Throwable` defects. This is useful when `E` is not necessarily a `Throwable`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def refineOrDieWith[E1](pf: PartialFunction[E, E1])(f: E => Throwable): ZIO[R, E1, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Repeat Combinator with Ref in Scala\nDESCRIPTION: Demonstrates how to use Ref to implement a repeat combinator that executes an effect a specified number of times.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef repeat[E, A](n: Int)(io: IO[E, A]): IO[E, Unit] =\n  Ref.make(0).flatMap { iRef =>\n    def loop: IO[E, Unit] = iRef.get.flatMap { i =>\n      if (i < n)\n        io *> iRef.update(_ + 1) *> loop\n      else\n        ZIO.unit\n    }\n    loop\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Hub to Broadcast Messages in Scala\nDESCRIPTION: Demonstrates how to use a Hub to broadcast a message to multiple subscribers. It creates a bounded Hub, subscribes twice, publishes a message, and then reads from both subscriptions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nHub.bounded[String](2).flatMap { hub =>\n  ZIO.scoped {\n    hub.subscribe.zip(hub.subscribe).flatMap { case (left, right) =>\n      for {\n        _ <- hub.publish(\"Hello from a hub!\")\n        _ <- left.take.flatMap(Console.printLine(_))\n        _ <- right.take.flatMap(Console.printLine(_))\n      } yield ()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Error Type of ZIO Effect from Option in Scala\nDESCRIPTION: Shows how to use `mapError` on a ZIO effect derived from an `Option` (using `ZIO.fromOption`) to change the uninformative `Option[Nothing]` error type to a more specific type, like `String`, providing a custom error message.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval zoption: IO[Option[Nothing], Int] = ZIO.fromOption(Some(2)) // Assuming zoption from previous snippet\n\nval zoption2: IO[String, Int] = zoption.mapError(_ => \"It wasn't there!\")\n```\n\n----------------------------------------\n\nTITLE: Extracting Right or Failing from ZIO[R, E, Either[E, A]] in Scala\nDESCRIPTION: Transforms a `ZIO[R, E, Either[E, A]]` into a `ZIO[R, E, A]`. If the resulting `Either` is `Right(a)`, the effect succeeds with `a`. If it's `Left(e)`, the effect fails with the error `e` directly, as the `Either`'s left type matches the ZIO error type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfrom.rightOrFail\n```\n\n----------------------------------------\n\nTITLE: Reading File Lines with Basic Resource Management in Scala\nDESCRIPTION: A basic example showing how to read and count lines from a file without proper resource cleanup, which can lead to resource leakage if an exception occurs before the file is closed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef lines(file: String): Task[Long] = Task.effect {\n  def countLines(br: BufferedReader): Long = br.lines().count()\n  val bufferedReader = new BufferedReader(\n    new InputStreamReader(new FileInputStream(\"file.txt\")),\n    2048\n  )\n  val count = countLines(bufferedReader)\n  bufferedReader.close()\n  count\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Subscriber to ZIO Sink\nDESCRIPTION: Shows how to convert a Reactive Streams Subscriber to a ZIO Sink, including error handling through a Promise side channel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-reactive-streams.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval asSink = subscriber.toSink[Throwable]\nval failingStream = Stream.range(3, 13) ++ Stream.fail(new RuntimeException(\"boom!\"))\nruntime.unsafeRun(\n  asSink.flatMap { case (errorP, sink) =>\n    failingStream.run(sink).catchAll(errorP.fail)\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Updating ZLayer Components Using the update Method\nDESCRIPTION: This example demonstrates how to replace individual components in a ZLayer using the update method. It creates a layer with String, Int, and Double components, then updates each one separately with new values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval origin: ZLayer[Any, Nothing, String & Int & Double] = \n  ZLayer.succeedEnvironment(ZEnvironment[String, Int, Double](\"foo\", 123, 1.3))\n\nval updated1 = origin.update[String](_ + \"bar\")\nval updated2 = origin.update[Int](_ + 5)\nval updated3 = origin.update[Double](_ - 0.3)\n```\n\n----------------------------------------\n\nTITLE: ZIO Log Level Override Example\nDESCRIPTION: Shows how to override the default log level for a specific workflow in ZIO\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.logLevel(LogLevel.Debug) {\n  for {\n    _ <- ZIO.log(\"Workflow Started.\")\n    _ <- ZIO.log(\"Running task 1.\")\n    _ <- ZIO.log(\"Running task 2.\")\n    _ <- ZIO.log(\"Workflow Completed.\")\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Interrupting a Forked ZIO Effect with Typed Errors in Scala\nDESCRIPTION: This Scala code snippet demonstrates interrupting a ZIO effect (`validateNonNegativeNumber`) that has a typed error channel (`String`). It forks the effect into a separate fiber, explicitly interrupts that fiber using `f.interrupt`, and then attempts to join it. This shows that interruption is a possible termination cause for a ZIO effect, separate from its declared typed error channel (`E`) or potential defects. Depends on the ZIO library and the `validateNonNegativeNumber` function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/typed-errors-guarantees.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval myApp: ZIO[Any, String, Int] =\n  for {\n    f <- validateNonNegativeNumber(\"5\").fork\n    _ <- f.interrupt\n    r <- f.join\n  } yield r\n```\n\n----------------------------------------\n\nTITLE: Converting Between Either and ZStream Error Types (Scala)\nDESCRIPTION: Shows how to convert between Either-based error handling and ZStream error handling using absolve. This is useful when integrating with legacy APIs that use Either for error representation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_75\n\nLANGUAGE: scala\nCODE:\n```\ndef legacyFetchUrlAPI(url: URL): Either[Throwable, String] = ???\n\ndef fetchUrl(\n    url: URL\n): ZStream[Blocking, Throwable, String] = \n  ZStream.fromEffect(\n    zio.blocking.effectBlocking(legacyFetchUrlAPI(url))\n  ).absolve\n```\n\n----------------------------------------\n\nTITLE: Composing Fibers with OrElse in ZIO Scala\nDESCRIPTION: Illustrates composing fibers so that if the first fails, the result of the second is used instead, via Fiber#orElse. One fiber fails, the other succeeds; the composed fiber yields the successful result. Requires ZIO and works for any effects providing values or errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  fiber1 <- IO.fail(\"Uh oh!\").fork\n  fiber2 <- IO.succeed(\"Hurray!\").fork\n  fiber   = fiber1.orElse(fiber2)\n  message  <- fiber.join\n} yield message\n```\n\n----------------------------------------\n\nTITLE: HTTP Server Implementation with ZIO Environment\nDESCRIPTION: Shows how to implement an HTTP server using ZIO environment for request context handling, including route definitions and request/response processing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\nimport java.net.URI\nimport java.nio.charset.StandardCharsets\n\ntype HttpApp = ZIO[HttpRequest, Throwable, HttpResponse]\ntype HttpRoute = Map[String, HttpApp]\n\ncase class HttpRequest(method: Int,\n                       uri: URI,\n                       headers: Map[String, String],\n                       body: UStream[Byte])\n\ncase class HttpResponse(status: Int,\n                        headers: Map[String, String],\n                        body: UStream[Byte])\n\nobject HttpResponse {\n  def apply(status: Int, message: String): HttpResponse =\n    HttpResponse(\n      status = status,\n      headers = Map.empty,\n      body = ZStream.fromChunk(\n        Chunk.fromArray(message.getBytes(StandardCharsets.UTF_8))\n      )\n    )\n\n  def ok(msg: String): HttpResponse = HttpResponse(200, msg)\n\n  def error(msg: String): HttpResponse = HttpResponse(500, msg)\n}\n\ntrait HttpServer {\n  def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit]\n}\n\nobject HttpServer {\n  def serve(map: HttpRoute, host: String, port: Int): ZIO[HttpServer, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.serve(map, host, port))\n}\n\ncase class HttpServerLive() extends HttpServer {\n  override def serve(map: HttpRoute, host: String, port: Int): ZIO[Any, Throwable, Unit] = ???\n}\n\nobject HttpServerLive {\n  val layer: URLayer[Any, HttpServer] = ZLayer.succeed(HttpServerLive())\n}\n\nobject MainWebApp extends ZIOAppDefault {\n\n  val myApp: ZIO[HttpServer, Throwable, Unit] = for {\n    _ <- ZIO.unit\n    healthcheck: HttpApp = ZIO.service[HttpRequest].map { _ =>\n      HttpResponse.ok(\"up\")\n    }\n\n    pingpong = ZIO.service[HttpRequest].flatMap { req =>\n      ZIO.ifZIO(\n        req.body.via(ZPipeline.utf8Decode).runHead.map(_.contains(\"ping\"))\n      )(\n        onTrue = ZIO.attempt(HttpResponse.ok(\"pong\")),\n        onFalse = ZIO.attempt(HttpResponse.error(\"bad request\"))\n      )\n    }\n\n    map = Map(\n      \"/healthcheck\" -> healthcheck,\n      \"/pingpong\" -> pingpong\n    )\n    _ <- HttpServer.serve(map, \"localhost\", 8080)\n  } yield ()\n\n  def run = myApp.provideLayer(HttpServerLive.layer)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting and Re-wrapping Option Values in ZIO Scala\nDESCRIPTION: Demonstrates using `ZIO#some` to transform a `ZIO[R, E, Option[A]]` into `ZIO[R, Option[E], A]`, extracting the value from `Some` and moving the `None` case to the error channel. `ZIO#unsome` performs the inverse, wrapping the success value back into an `Option`. This requires an initial ZIO effect yielding an Option.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/zooming-in-on-nested-values.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nZIO.attempt(Option(\"something\")) // ZIO[Any, Throwable, Option[String]]\n  .some                          // ZIO[Any, Option[Throwable], String]\n  .unsome                        // ZIO[Any, Throwable, Option[String]]\n```\n\n----------------------------------------\n\nTITLE: Piping Schedules with >>> Operator\nDESCRIPTION: Shows how to pipe schedule outputs using the >>> operator. Combines spaced recurrence with elapsed time measurement.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval totalElapsed = Schedule.spaced(1.second) <* Schedule.recurs(5) >>> Schedule.elapsed\n```\n\n----------------------------------------\n\nTITLE: Creating and Using TestRandom in Scala ZIO Test\nDESCRIPTION: This snippet demonstrates how to create a TestRandom object using the 'makeTest' method and use it to generate a random integer, useful for accessing testing functionality without using the environment type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  testRandom <- TestRandom.makeTest(TestRandom.DefaultData)\n  n          <- testRandom.nextInt\n} yield n\n```\n\n----------------------------------------\n\nTITLE: Executing Environmental Effects using ZIO.accessM in Scala\nDESCRIPTION: This snippet demonstrates accessing and executing effects defined within a service interface (`DatabaseOps`) provided via the ZIO environment. `ZIO.accessM` is used to retrieve and run the `getTableNames` and `getColumnNames` effects. The resulting effect requires a `DatabaseOps` environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala\ntrait DatabaseOps {\n  def getTableNames: Task[List[String]]\n  def getColumnNames(table: String): Task[List[String]]\n}\n\nval tablesAndColumns: ZIO[DatabaseOps, Throwable, (List[String], List[String])] = \n  for {\n    tables  <- ZIO.accessM[DatabaseOps](_.getTableNames)\n    columns <- ZIO.accessM[DatabaseOps](_.getColumnNames(\"user_table\"))\n  } yield (tables, columns)\n```\n```\n\n----------------------------------------\n\nTITLE: Using Union Types with Unrelated Error Types in Scala\nDESCRIPTION: This example demonstrates how union types can be used with completely unrelated error types that don't share a common supertype or extend Exception/Throwable. It shows how to combine these distinct errors in a ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/union-types.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.*\n\n// Two unrelated errors without having a common supertype\ntrait FooError\ntrait BarError\n\ndef foo: IO[FooError, Nothing] = ZIO.fail(new FooError {})\ndef bar: IO[BarError, Nothing] = ZIO.fail(new BarError {})\n\nval myApp: ZIO[Any, FooError | BarError, Unit] = for {\n  _ <- foo\n  _ <- bar\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Operating on ZIO Queue: Basic Operations in Scala\nDESCRIPTION: Demonstrates basic operations on a ZIO Queue including queue creation, offering an item, and taking an item. Shows the usage pattern for safely adding and retrieving values asynchronously within a for-comprehension. Requires zio._ in scope. Takes no external input; returns the dequeued value as an Int.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\nval res: UIO[Int] = for {\\n  queue <- Queue.bounded[Int](100)\\n  _ <- queue.offer(1)\\n  v1 <- queue.take\\n} yield v1\\n\n```\n\n----------------------------------------\n\nTITLE: Refining Error Channel to NumberFormatException with ZIO.refineToOrDie - Scala\nDESCRIPTION: Refines the error channel from Throwable to NumberFormatException using ZIO.refineToOrDie, making expected parsing errors explicit and typed. Accepts a string input and attempts to convert it to Int, returning a ZIO effect that fails only with NumberFormatException. Dependencies: zio. Useful when only specific parse errors need typed handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/examples.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\n\\ndef parseInput(input: String): ZIO[Any, NumberFormatException, Int] =\\n  ZIO.attempt(input.toInt)                 // ZIO[Any, Throwable, Int]\\n    .refineToOrDie[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n```\n\n----------------------------------------\n\nTITLE: Implementing Before and After Test Aspects in ZIO\nDESCRIPTION: Example showing how to use TestAspect.before to set environment variables and TestAspect.after to clean up resources after test execution. The test verifies if a temporary directory path is set correctly.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/before-after-around.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\ntest(\"before and after\") {\n  for {\n    tmp <- System.env(\"TEMP_DIR\")\n  } yield assertTrue(tmp.contains(\"/tmp/test\"))\n} @@ TestAspect.before(\n  TestSystem.putEnv(\"TEMP_DIR\", s\"/tmp/test\")\n) @@ TestAspect.after(\n  System.env(\"TEMP_DIR\").flatMap(deleteDir)\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter.live as a ZLayer in Scala\nDESCRIPTION: Implementation of a Counter service as a ZLayer with acquire and release lifecycle methods using ZIO's scoped resources.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ZLayer.scoped {\n    for {\n      id <- Ref.make(UUID.randomUUID())\n      ref <- Ref.make(0)\n      service = CounterLive(id, ref)\n      _ <- service.acquire\n      _ <- ZIO.addFinalizer(service.release)\n    } yield service\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Storage Services\nDESCRIPTION: Skeleton implementation of in-memory versions of BlobStorage and MetadataRepo services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/service-pattern.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject InmemoryBlobStorage {\n  /**\n   * An in-memory implementation of the `BlobStorage` service.\n   */\n  val layer = \n    ZLayer {\n      ???\n    } \n}\n\nobject InmemoryMetadataRepo {\n  /**\n   * An in-memory implementation of the `MetadataRepo` service.\n   */\n  val layer = \n    ZLayer {\n      ???\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#timeout with disconnect for Early Return in Scala\nDESCRIPTION: Demonstrates combining `disconnect` with `timeout` on an `uninterruptible` effect (`myApp`). Applying `disconnect` before `timeout(1.second)` allows the timeout operation to return `None` immediately after 1 second, even though the underlying uninterruptible effect continues running in the background. This results in an execution time reflecting the timeout duration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/timing-out.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .uninterruptible\n      .disconnect\n      .timeout(1.second)\n      .debug(\"output\")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug(\"execution time of the whole program in second\")\n}\n\n// Output:\n// start doing something.\n// output: None\n// execution time of the whole program in second: 1\n```\n```\n\n----------------------------------------\n\nTITLE: Dying Effect Example - ZIO Runtime - Scala\nDESCRIPTION: Creates a ZIO effect that dies with an ArithmeticException ('divide by zero'). Demonstrates using ZIO.die to describe an unrecoverable error. Dependencies: zio._. No input or output is produced; the effect always dies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval dyingEffect: ZIO[Any, Nothing, Nothing] =\n  ZIO.die(new ArithmeticException(\"divide by zero\"))\n```\n\n----------------------------------------\n\nTITLE: Validating a List with ZIO and Accumulating Errors - Scala\nDESCRIPTION: Creates a ZIO effect that validates a list of integers, succeeding only for even numbers and failing with error messages for odds. Utilizes ZIO.validate to process each number and accumulate errors as a list of strings. Outputs a ZIO effect with all valid numbers or a list of error messages, requiring an import of zio._ for type usage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/flipping-the-error-and-success-channel.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval evens: ZIO[Any, List[String], List[Int]] =\n  ZIO.validate(List(1, 2, 3, 4, 5)) { n =>\n    if (n % 2 == 0)\n      ZIO.succeed(n)\n    else\n      ZIO.fail(s\"$n is not even\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Retrieving an Optional Value from a TPromise in ZIO STM\nDESCRIPTION: Shows how to check if a TPromise has been completed and retrieve its value if available. The poll method returns an Option[Either[E, A]] which will be None if the promise hasn't been completed yet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpromise.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseOptionValue: UIO[Option[Either[String, Int]]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.succeed(0).commit\n  res      <- tPromise.poll.commit\n} yield res\n```\n\n----------------------------------------\n\nTITLE: Combining foldZIO with Data Lookup and Error Wrapping - Scala\nDESCRIPTION: Uses foldZIO to wrap an error into a custom domain object (NoContent) or, on success, invoke another effectful function (fetchContent) with the result. Emphasizes converting errors to typed business representations. Requires readUrls and fetchContent to be defined, as well as Content, NoContent, and OkContent types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval urls: UIO[Content] =\n  readUrls(\"urls.json\").foldZIO(\n    error   => ZIO.succeed(NoContent(error)),\n    success => fetchContent(success)\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Application Dependencies in Scala\nDESCRIPTION: This code snippet defines the basic structure of a ZIO application that requires DocRepo and UserRepo services. It sets up the type signature for the main application logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/building-dependency-graph.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[DocRepo with UserRepo, Throwable, Unit] = ZIO.attempt(???)\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Option to ZIO Effect\nDESCRIPTION: Shows how to convert a Scala Option to a ZIO effect using ZIO.fromOption. It also demonstrates error handling with orElseFail and advanced usage with some and asSomeError operators.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/creating-effects.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval zoption: IO[Option[Nothing], Int] = ZIO.fromOption(Some(2))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval zoption2: ZIO[Any, String, Int] = zoption.orElseFail(\"It wasn't there!\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval result: ZIO[Any, Throwable, Option[(User, Team)]] = (for {\n  id   <- maybeId\n  user <- getUser(id).some\n  team <- getTeam(user.teamId).asSomeError \n} yield (user, team)).unsome\n```\n\n----------------------------------------\n\nTITLE: Creating ZSink from Hub for Multi-Consumer Publishing\nDESCRIPTION: Demonstrates creating a sink from a Hub to enable multiple consumers to receive the same data stream. Implements a producer and two consumers pattern with synchronized startup using a Promise.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/creating-sinks.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[Any, IOException, Unit] =\n  for {\n    promise <- Promise.make[Nothing, Unit]\n    hub <- Hub.bounded[Int](1)\n    sink <- ZIO.succeed(ZSink.fromHub(hub))\n    producer <- ZStream\n      .iterate(0)(_ + 1)\n      .schedule(Schedule.fixed(1.seconds))\n      .run(sink)\n      .fork\n    consumers <- ZIO.scoped {\n      hub.subscribe.zip(hub.subscribe).flatMap { case (left, right) =>\n        for {\n          _ <- promise.succeed(())\n          f1 <- left.take.flatMap(e => printLine(s\"Left Queue: $e\")).forever.fork\n          f2 <- right.take.flatMap(e => printLine(s\"Right Queue: $e\")).forever.fork\n          _ <- f1.zip(f2).join\n        } yield ()\n      }\n    }.fork\n    _ <- promise.await\n    _ <- producer.zip(consumers).join\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining a Sample ZIO Effect in Scala\nDESCRIPTION: Defines a ZIO effect named `myApp` which simulates an operation by logging start and end messages and introducing a 2-second delay using `ZIO.sleep`. Upon successful completion, it yields the string \"result\". This effect is used as a basis for demonstrating various timeout operators.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/timing-out.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent\nimport zio._\n\nval myApp =\n  for {\n    _ <- ZIO.debug(\"start doing something.\")\n    _ <- ZIO.sleep(2.second)\n    _ <- ZIO.debug(\"my job is finished!\")\n  } yield \"result\"\n```\n```\n\n----------------------------------------\n\nTITLE: Stream Pagination Using ZStream.paginate\nDESCRIPTION: Final implementation using paginate operation for more ergonomic handling of paginated API results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nval finalAttempt: ZStream[Console, Throwable, RowData] = \n  ZStream.paginateChunkM(0) { pageNumber =>\n    for {\n      page <- listPaginated(pageNumber)\n    } yield page.results -> (if (!page.isLast) Some(pageNumber + 1) else None)\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating ZSink from Bounded Queue for Batched Processing\nDESCRIPTION: Shows how to create a sink from a bounded queue for producer-consumer pattern. Includes a producer streaming integers and a consumer printing them with fixed delay scheduling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/creating-sinks.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: IO[IOException, Unit] =\n  for {\n    queue    <- Queue.bounded[Int](32)\n    producer <- ZStream\n      .iterate(1)(_ + 1)\n      .schedule(Schedule.fixed(200.millis))\n      .run(ZSink.fromQueue(queue))\n      .fork\n    consumer <- queue.take.flatMap(printLine(_)).forever\n    _        <- producer.zip(consumer).join\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Complex Error Handling with foldZIO in ZIO (Scala)\nDESCRIPTION: Demonstrates a more complex use of `foldZIO` to handle both failure and success of a method, with different processing for each case. This showcases the flexibility of ZIO's error handling capabilities.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\nval urls: UIO[Content] =\n  readUrls(\"urls.json\").foldZIO(\n    error   => ZIO.succeed(NoContent(error)),\n    success => fetchContent(success)\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining Channel Flipping Methods in ZIO Trait - Scala\nDESCRIPTION: Defines the ZIO trait with methods to flip error and success channels. The flip method reverses the result and error channels, while flipWith allows transformation using a provided function. These methods are foundational in ZIO for advanced error handling and channel manipulation. No external dependencies are required beyond ZIO's own type system.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/flipping-the-error-and-success-channel.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def flip: ZIO[R, A, E]\n  def flipWith[R1, A1, E1](f: ZIO[R, A, E] => ZIO[R1, A1, E1]): ZIO[R1, E1, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cause Data Structure in Scala\nDESCRIPTION: Shows the internal implementation of the Cause data type as a semiring structure, including its subtypes like Empty, Fail, Die, Interrupt, Stackless, Then, and Both.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nsealed abstract class Cause[+E] extends Product with Serializable { self =>\n  import Cause._\n  def trace: Trace = ???\n\n  final def ++[E1 >: E](that: Cause[E1]): Cause[E1] = Then(self, that)\n  final def &&[E1 >: E](that: Cause[E1]): Cause[E1] = Both(self, that)\n}\n\nobject Cause extends Serializable {\n  case object Empty extends Cause[Nothing]\n  final case class Fail[+E](value: E, override val trace: Trace) extends Cause[E]\n  final case class Die(value: Throwable, override val trace: Trace) extends Cause[Nothing]\n  final case class Interrupt(fiberId: FiberId, override val trace: Trace) extends Cause[Nothing]\n  final case class Stackless[+E](cause: Cause[E], stackless: Boolean) extends Cause[E]\n  final case class Then[+E](left: Cause[E], right: Cause[E]) extends Cause[E]\n  final case class Both[+E](left: Cause[E], right: Cause[E]) extends Cause[E]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Exit in ZIO Effects\nDESCRIPTION: This example demonstrates how to use the Exit type in a ZIO effect. It shows how to obtain the Exit value of an effect using ZIO#exit and how to pattern match on the result to handle both Success and Failure cases.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/exit.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Console._\n\nimport java.io.IOException\n\nval result: ZIO[Any, IOException, Unit] = \n  for {\n    successExit <- ZIO.succeed(1).exit\n    _ <- successExit match {\n      case Exit.Success(value) =>\n        printLine(s\"exited with success value: ${value}\")\n      case Exit.Failure(cause) =>\n        printLine(s\"exited with failure state: $cause\")\n    }\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Handling All Typed Errors in Scala using ZIO\nDESCRIPTION: This snippet demonstrates how to handle all typed errors in ZIO, resulting in an error channel of type Nothing. This approach ensures that all expected errors are explicitly handled, providing maximum type safety and eliminating the need for defensive error logging.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/logging-errors.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[Any, Nothing, Unit] =\n  upload(\"contacts.csv\")\n    .catchAll {\n      case FileExist(name) =>\n        ZIO.unit // handling FileExist error case\n      case StorageLimitExceeded(limit) =>\n        ZIO.unit // handling StorageLimitExceeded error case\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating Layers with ZLayer.make in ZIO 2.x\nDESCRIPTION: This snippet demonstrates how to directly construct a layer using ZLayer.make in ZIO 2.x. It shows a more concise way of creating complex dependency graphs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_51\n\nLANGUAGE: scala\nCODE:\n```\nval layer = ZLayer.make[DocRepo with UserRepo](\n  Logging.live,\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live\n)\n```\n\n----------------------------------------\n\nTITLE: ZIO Application with SLF4J Integration\nDESCRIPTION: Example of integrating SLF4J logging into a ZIO application using the zio-logging library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/create-custom-logger-for-a-zio-application.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n  override val bootstrap = SLF4J.slf4j(LogFormat.colored)\n\n  def run = ZIO.log(\"Application started!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Config for List of HostPorts in Scala using ZIO\nDESCRIPTION: This example demonstrates how to create a configuration for a list of HostPort objects. It uses the listOf constructor to create a config for a list of custom types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/configuration/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class HostPorts(hostPorts: List[HostPort])\n\nobject HostPorts {\n  implicit val config: Config[HostPorts] =\n    Config.listOf(HostPort.config).map(HostPorts(_))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Exception-specific Retry Schedule in ZIO\nDESCRIPTION: Creates a schedule that retries with exponential backoff only when a TimeoutException occurs. It combines an exponential backoff schedule with a predicate that filters for specific exception types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/examples.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.TimeoutException\n\nval whileTimeout = Schedule.exponential(10.milliseconds) && Schedule.recurWhile[Throwable] {\n  case _: TimeoutException => true\n  case _ => false\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Interruptible Blocking Operations with Cancellation in ZIO\nDESCRIPTION: Demonstrates how to create interruptible blocking operations with custom cancellation logic using attemptBlockingCancelable. This pattern is useful when working with resources that need explicit cancellation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.net.ServerSocket\n\ndef accept(l: ServerSocket) =\n  ZIO.attemptBlockingCancelable(l.accept())(ZIO.succeed(l.close()))\n```\n\n----------------------------------------\n\nTITLE: Refining Errors with refineOrDie in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates the use of ZStream#refineOrDie to keep specific error types and terminate the fiber for others. The example shows refining a stream to only handle IllegalArgumentException.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZStream[Any, Throwable, Int] =\n  ZStream.fail(new Throwable)\n\nval res: ZStream[Any, IllegalArgumentException, Int] =\n  stream.refineOrDie { case e: IllegalArgumentException => e }\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Task to CompletableFuture\nDESCRIPTION: Demonstrates converting a ZIO Task to a Java CompletableFuture.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-java.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef taskToStage[A](task: Task[A]): UIO[CompletableFuture[A]] =\n    task.toCompletableFuture\n```\n\n----------------------------------------\n\nTITLE: Asserting Exit Value is Died in Scala\nDESCRIPTION: Creates an assertion `Assertion[Exit[Any, Any]]` that verifies if a ZIO `Exit` value represents a fiber death (defect) caused by a `Throwable`. It takes a nested assertion to check properties of the `Throwable` causing the death.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndies(assertion: Assertion[Throwable])\n```\n\n----------------------------------------\n\nTITLE: Vertical Composition of ZLayers in Scala\nDESCRIPTION: Illustrates vertical composition of two ZLayers using the >>> operator. This composition feeds the output of one layer as input to the subsequent layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???  // A ==> B\nval barLayer: ZLayer[B, Nothing  , C] = ???  // B ==> C\n\nval horizontal: ZLayer[A, Throwable, C] =    // A ==> C\n  fooLayer >>> barLayer\n```\n\n----------------------------------------\n\nTITLE: Collecting User Input Recursively with ZIO in Scala\nDESCRIPTION: Implements a function `getNames` using manual recursion with ZIO effects (`Console.print`, `Console.readLine`, `ZIO.succeed`) to collect names from the console. It prompts the user repeatedly until 'exit' is entered, accumulating the names in a list. A nested helper function `loop` manages the state (the list of names) and the recursive calls.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\nimport zio._\n\ndef getNames: ZIO[Any, IOException, List[String]] =\n  Console.print(\"Please enter all names\") *>\n    Console.printLine(\" (enter \\\"exit\\\" to indicate end of the list):\") *> {\n      def loop(\n          names: List[String]\n      ): ZIO[Any, IOException, List[String]] = {\n        Console.print(s\"${names.length + 1}. \") *> Console.readLine\n          .flatMap {\n            case \"exit\" => ZIO.succeed(names)\n            case name   => loop(names.appended(name))\n          }\n      }\n      loop(List.empty[String])\n    }\n// Please enter all names (enter \"exit\" to indicate end of the list):\n// 1. John\n// 2. Jane\n// 3. Joe\n// 4. exit\n// List(John, Jane, Joe)\n```\n\n----------------------------------------\n\nTITLE: Converting Java Future to ZIO RIO\nDESCRIPTION: Example of wrapping a Java Future-based HTTP client in a ZIO RIO computation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-java.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef execute(client: HttpAsyncClient, request: HttpUriRequest): RIO[Blocking, HttpResponse] =\n    ZIO.fromFutureJava(UIO {\n        client.execute(request, null)\n    })\n```\n\n----------------------------------------\n\nTITLE: Basic Managed Resource Usage Example\nDESCRIPTION: Demonstrates creating and using a managed Queue resource with proper acquisition and release handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/managed.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\ndef doSomething(queue: Queue[Int]): UIO[Unit] = IO.unit\n\nval managedResource = Managed.make(Queue.unbounded[Int])(_.shutdown)\nval usedResource: UIO[Unit] = managedResource.use { queue => doSomething(queue) }\n```\n\n----------------------------------------\n\nTITLE: Running ZStream into Existing Hub in Scala\nDESCRIPTION: Defines a method to send values emitted by a ZStream to an existing Hub. It allows for integration with pre-existing or custom-created Hubs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZStream[-R, +E, +O] {\n  def runIntoHub[E1 >: E, O1 >: O](\n    hub: => Hub[Take[E1, O1]]\n  ): ZIO[R, E1, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Either to ZStream with absolve (Scala)\nDESCRIPTION: Shows how to use ZStream.absolve to convert a stream of Either values into a ZStream, submerging the error case into the ZStream error type. The example demonstrates converting a legacy API result to a ZStream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef legacyFetchUrlAPI(url: URL): Either[Throwable, String] = ???\n\ndef fetchUrl(\n    url: URL\n): ZStream[Any, Throwable, String] = \n  ZStream.fromZIO(\n    ZIO.attemptBlocking(legacyFetchUrlAPI(url))\n  ).absolve\n```\n\n----------------------------------------\n\nTITLE: Implementing Producer-Consumer Pattern with ZIO SQS in Scala\nDESCRIPTION: This example demonstrates producing a stream of events to an AWS SQS queue and then consuming them. It shows how to create a queue, get its URL, produce messages using a ZIO Stream, and consume them with SqsStream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nimport io.github.vigoo.zioaws\nimport io.github.vigoo.zioaws.core.config.CommonAwsConfig\nimport io.github.vigoo.zioaws.sqs.Sqs\nimport software.amazon.awssdk.auth.credentials.{\n  AwsBasicCredentials,\n  StaticCredentialsProvider\n}\nimport software.amazon.awssdk.regions.Region\nimport zio.clock.Clock\nimport zio.sqs.producer.{Producer, ProducerEvent}\nimport zio.sqs.serialization.Serializer\nimport zio.sqs.{SqsStream, SqsStreamSettings, Utils}\nimport zio.stream.ZStream\nimport zio.{ExitCode, RIO, URIO, ZLayer, _}\n\nobject ProducerConsumerExample extends zio.App {\n  val queueName = \"MyQueue\"\n\n  val client: ZLayer[Any, Throwable, Sqs] = zioaws.netty.default ++\n    ZLayer.succeed(\n      CommonAwsConfig(\n        region = Some(Region.of(\"ap-northeast-2\")),\n        credentialsProvider = StaticCredentialsProvider.create(\n          AwsBasicCredentials.create(\"key\", \"key\")\n        ),\n        endpointOverride = None,\n        commonClientConfig = None\n      )\n    ) >>>\n    zioaws.core.config.configured() >>>\n    zioaws.sqs.live\n\n  val stream: ZStream[Any, Nothing, ProducerEvent[String]] =\n    ZStream.iterate(0)(_ + 1).map(_.toString).map(ProducerEvent(_))\n\n  val program: RIO[Sqs with Clock, Unit] = for {\n    _        <- Utils.createQueue(queueName)\n    queueUrl <- Utils.getQueueUrl(queueName)\n    producer = Producer.make(queueUrl, Serializer.serializeString)\n    _ <- producer.use { p =>\n      p.sendStream(stream).runDrain\n    }\n    _ <- SqsStream(\n      queueUrl,\n      SqsStreamSettings(stopWhenQueueEmpty = true, waitTimeSeconds = Some(3))\n    ).foreach(msg => UIO(println(msg.body)))\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    program.provideCustomLayer(client).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counter Service in Scala ZIO\nDESCRIPTION: This code defines a `Counter` service with a ZLayer for initialization and release. It provides methods to increment and get the counter value, demonstrating ZIO's resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/sharing-layers-within-the-same-file.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Counter(value: Ref[Int]) {\n  def inc: UIO[Unit] = value.update(_ + 1)\n  def get: UIO[Int] = value.get\n}\n\nobject Counter {\n  val layer =\n    ZLayer.scoped(\n      ZIO.acquireRelease(\n        Ref.make(0).map(Counter(_)) <* ZIO.debug(\"Counter initialized!\")\n      )(c => c.get.debug(\"Number of tests executed\"))\n    )\n  def inc = ZIO.service[Counter].flatMap(_.inc)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Failing ZIO Effects with Exceptions in Scala\nDESCRIPTION: Demonstrates creating a failing ZIO effect using `ZIO.fail` where the error type is an `Exception`. This is common practice when modeling failures that originate from potentially exception-throwing code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval f2 = ZIO.fail(new Exception(\"Uh oh!\"))\n```\n\n----------------------------------------\n\nTITLE: Updating ZLayer Dependency in Scala with ZIO\nDESCRIPTION: This snippet demonstrates a ZIO application that composes several service layers and then updates the Cache layer from InmemoryCache to PersistentCache using ZLayer#update. Required dependencies include ZIO, and implementations for Database, BlobStorage, Cache, DocumentRepo, and UserRepo. The myApp value retrieves UserRepo and DocumentRepo from the environment, while the layers value composes all required service layers. The run method supplies the layers to the application, with the Cache implementation swapped at runtime. To run, ensure all supporting classes (like PersistentCache and other concrete layers) are in scope.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/examples.md#2025-04-23_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\\n\\nobject MainApp extends ZIOAppDefault {\\n\\n  def myApp: ZIO[DocumentRepo & UserRepo, Nothing, Unit] =\\n    for {\\n      _ <- ZIO.service[UserRepo]\\n      _ <- ZIO.service[DocumentRepo]\\n    } yield ()\\n\\n  val layers: ZLayer[Any, Throwable, Database & BlobStorage & Cache & DocumentRepo & UserRepo] =\\n    DatabaseLive.layer >+>\\n      BlobStorageLive.layer >+>\\n      InmemoryCache.layer >+>\\n      DocumentRepoLive.layer >+>\\n      UserRepoLive.layer\\n\\n  def run =\\n    myApp.provideLayer(\\n      layers.update[Cache](_ => new PersistentCache)\\n    )\\n}\n```\n\n----------------------------------------\n\nTITLE: Imperative Dependency Resolution in ZIO\nDESCRIPTION: Shows how to imperatively resolve dependencies using ZEnvironment as an IoC container.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval workflow: ZIO[Scope, Nothing, Unit] =\n  for {\n    env <- (ScalaFormatter.layer ++ ScalaCompiler.layer).build\n    f   <- env.get[Formatter].format(\"println(\\\"Hello, world!\\\")\")\n    _   <- env.get[Compiler].compile(f)\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#orElseSucceed for Constant Fallback Value in Scala\nDESCRIPTION: This snippet shows `orElseSucceed`. It uses the same `validate` function as the previous example. If `validate(3)` fails (which it will because 3 < 18, resulting in `IllegalAgeException`), `orElseSucceed(0)` catches this failure and transforms the effect into a successful one with the value `0`. The resulting effect's error type becomes `Nothing`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval result: ZIO[Any, Nothing, Int] =\n  validate(3).orElseSucceed(0)\n```\n\n----------------------------------------\n\nTITLE: ZStream Creation from Effects in Scala\nDESCRIPTION: Examples of creating ZStreams from ZIO effects, including console and random number generation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval readline: ZStream[Console, IOException, String] = \n  ZStream.fromEffect(zio.console.getStrLn)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval randomInt: ZStream[Random, Nothing, Int] = \n  ZStream.fromEffect(zio.random.nextInt)\n```\n\n----------------------------------------\n\nTITLE: Converting IO to Monix Task - Scala Extension Method\nDESCRIPTION: Provides a Scala extension method to convert a ZIO IO value into a Monix Task, wrapped in a UIO effect. Requires the interop-monix dependency. The output is an effect that, when run, gives a Monix Task equivalent to the given IO instance. This method abstracts the interoperability logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-monix.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef toTask: UIO[eval.Task[A]]\n```\n\n----------------------------------------\n\nTITLE: Reading File with NIO CompletionHandler and ZIO - Scala\nDESCRIPTION: This code example demonstrates asynchronous file reading using Java NIO\\'s AsynchronousFileChannel and ZIO\\'s effectAsyncWithCompletionHandler in Scala. It creates refs for tracking position and accumulating file content, recursively reads into a buffer via the NIO completion handler, and accumulates all bytes as a Chunk[Byte]. Dependencies are ZIO, Ref, Chunk, ByteBuffer, and an AsynchronousFileChannel instance. Inputs: an open AsynchronousFileChannel; Output: a Task containing the file contents as a Chunk of bytes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-java.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef readFile(file: AsynchronousFileChannel): Task[Chunk[Byte]] = for {\n    pos <- Ref.make(0)\n    buf <- ZIO.effectTotal(ByteBuffer.allocate(1024))\n    contents <- Ref.make[Chunk[Byte]](Chunk.empty)\n    def go = pos.get.flatMap { p =>\n        ZIO.effectAsyncWithCompletionHandler[Chunk[Byte]] { handler =>\n            file.read(buf, p, buf, handler)\n        }.flatMap {\n            case -1 => contents.get\n            case n  =>\n                ZIO.effectTotal {\n                    val arr = Array.ofDim[Byte](n)\n                    buf.get(arr, 0, n)\n                    buf.clear()\n                    Chunk.fromArray(arr)\n                }.flatMap { slice =>\n                    contents.update(_ ++ slice)\n                } *> pos.update(_ + n) *> go\n        }\n    }\n    dump <- go\n} yield dump\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Order Independence in ZIO Automatic Layer Construction\nDESCRIPTION: This snippet illustrates that the order of dependencies doesn't matter when using ZIO's automatic layer construction. It provides the same dependencies as the previous example but in a different order.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/building-dependency-graph.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval res: ZIO[Any, Throwable, Unit] =\n  myApp.provide(\n    DocRepo.live,\n    BlobStorage.live,\n    Logging.live,\n    Database.live,\n    UserRepo.live\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining Foo and Bar Services with ZLayer in Scala\nDESCRIPTION: This snippet defines two services (Foo and Bar) along with their live implementations and ZLayer definitions. It shows how to create reusable service definitions in ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-propagation.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait Foo {\n  def foo(): UIO[String]\n}\n\nobject Foo {\n  def foo(): ZIO[Foo, Nothing, String] = ZIO.serviceWithZIO[Foo](_.foo())\n}\n\ncase class FooLive() extends Foo {\n  override def foo(): UIO[String] = ZIO.succeed(\"foo\")\n}\n\nobject FooLive {\n  val layer: ULayer[Foo] = ZLayer.succeed(FooLive())\n}\n\ntrait Bar {\n  def bar(): UIO[Int]\n}\n\nobject Bar {\n  def bar(): ZIO[Bar, Nothing, Int] = ZIO.serviceWithZIO[Bar](_.bar())\n}\n\ncase class BarLive() extends Bar {\n  override def bar(): UIO[Int] = ZIO.succeed(1)\n}\n\nobject BarLive {\n  val layer: ULayer[Bar] = ZLayer.succeed(BarLive())\n}\n\nval myApp: ZIO[Foo & Bar, Nothing, Unit] = for {\n  foo  <- Foo.foo()\n  bar  <- Bar.bar()\n  _    <- ZIO.debug(s\"foo: $foo, bar: $bar\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining Placeholders for Concurrency Examples (Scala)\nDESCRIPTION: Sets up placeholder definitions required for the subsequent parallel execution examples. It defines an empty `List[String]` named `urls` and a function `download` that takes a URL `String` and returns a `Task[String]` (representing an effectful operation like downloading content), using `ZIO.attempt(???)` as a placeholder for the actual implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nval urls: List[String] = List.empty\ndef download(url: String): Task[String] = ZIO.attempt(???)\n```\n\n----------------------------------------\n\nTITLE: Defining a readFile Helper Function for Retry Examples in Scala\nDESCRIPTION: Defines a helper function `readFile` that attempts an operation (represented by `???`) and refines potential exceptions to `IOException`. This function serves as the base effect for demonstrating retry mechanisms in subsequent examples and requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.{ FileNotFoundException, IOException }\n\ndef readFile(s: String): ZIO[Any, IOException, Array[Byte]] =\n  ZIO.attempt(???).refineToOrDie[IOException]\n```\n\n----------------------------------------\n\nTITLE: Applying Timeout Test Aspect in Scala using ZIO\nDESCRIPTION: This snippet demonstrates how to apply a timeout test aspect to a ZIO test. It creates a test that runs an infinite loop, which is then limited to 1 second using the timeout aspect. The test will be interrupted after 1 second, regardless of whether it has completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/timing-out-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"effects can be safely interrupted\") {\n  for {\n    _ <- ZIO.attempt(println(\"Still going ...\")).forever\n  } yield assertTrue(true)\n} @@ TestAspect.timeout(1.second)\n```\n\n----------------------------------------\n\nTITLE: Creating Failing ZIO Effects with Exceptions in Scala\nDESCRIPTION: Demonstrates using `ZIO.fail` to create a failing effect where the error type is a standard `Exception`. This allows integration with traditional exception-based error handling if needed. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/failures.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval f3: ZIO[Any, Exception, Nothing] =\n  ZIO.fail(new Exception(\"Oh uh!\"))\n```\n\n----------------------------------------\n\nTITLE: Converting Either to ZIO Effect with ZIO.fromEither - Scala\nDESCRIPTION: Shows transformation of an Either value (here, Right(\"Success!\")) into a ZIO effect using ZIO.fromEither. The effect will succeed on Right, or fail with value from Left. No dependencies outside ZIO. Input is Either; output effect can error or succeed with values from respective sides.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval zeither = ZIO.fromEither(Right(\"Success!\"))\n```\n\n----------------------------------------\n\nTITLE: Parallel Stream Processing with ZIO Streams\nDESCRIPTION: Shows improved version using ZIO Streams that enables pipelining and handles infinite streams. Uses parallel mapping and filtering operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef prime(number: Int): Task[(Boolean, Int)] = Task.succeed(???)\n\nZStream.fromIterable(numbers)\n  .mapMParUnordered(20)(prime(_))\n  .filter(_._1).map(_._2)\n  .mapMParUnordered(20)(moreHardWork(_))\n```\n\n----------------------------------------\n\nTITLE: Cancelling Blocking Operations with effectBlockingCancelable in Scala ZIO\nDESCRIPTION: This snippet demonstrates how to use effectBlockingCancelable to handle the cancellation of blocking operations that don't respect Thread#interrupt. It provides a separate cancel effect that gets executed during interruption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/blocking.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval myApp =\n  for {\n    service <- ZIO.effect(BlockingService())\n    fiber   <- effectBlockingCancelable(\n      effect = service.start()\n    )(\n      cancel = UIO.effectTotal(service.close())\n    ).fork\n    _       <- fiber.interrupt.schedule(\n      Schedule.delayed(\n        Schedule.duration(3.seconds)\n      )\n    )\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Getting a List of Keys from a TMap in ZIO STM\nDESCRIPTION: Extracts a List of keys from a TMap using the keys method. This provides access to all the keys in the map as a List.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tMapKeysList: UIO[List[String]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  list <- tMap.keys\n} yield list).commit\n```\n\n----------------------------------------\n\nTITLE: Retrieving an Element from a TArray in ZIO STM (Scala)\nDESCRIPTION: Demonstrates how to retrieve the element at a specific index (the 3rd element at index 2) from a TArray. This example creates a TArray, retrieves an element, and commits the transaction to get a ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tArrayGetElem: UIO[Int] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  elem   <- tArray(2)\n} yield elem).commit\n```\n\n----------------------------------------\n\nTITLE: Creating Chunk using Unfold Method in Scala\nDESCRIPTION: Creates a Chunk by repeatedly applying a function that generates elements, continuing until the function returns None. This example generates a sequence of doubled values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval unfolded = Chunk.unfold(0)(n => if (n < 8) Some((n*2, n+2)) else None)\n// unfolded: Chunk[Int] = IndexedSeq(0, 4, 8, 12)\n```\n\n----------------------------------------\n\nTITLE: Surfacing Failures with either in ZIO (Scala)\nDESCRIPTION: Shows how to use the `either` method to surface failures in ZIO. This transforms a `ZIO[R, E, A]` into a `ZIO[R, Nothing, Either[E, A]]`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nval zeither: UIO[Either[String, Int]] =\n  ZIO.fail(\"Uh oh!\").either\n```\n\n----------------------------------------\n\nTITLE: Adding Finalizer to Clean Up Temporary Directory in Scala\nDESCRIPTION: This example shows how to add a finalizer to an existing stream to clean up a temporary directory after the application logic completes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/resourceful-streams.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.Console._\n\ndef application: ZStream[Any, IOException, Unit] = ZStream.fromZIO(printLine(\"Application Logic.\"))\ndef deleteDir(dir: Path): ZIO[Any, IOException, Unit] = printLine(\"Deleting file.\")\n\nval myApp: ZStream[Any, IOException, Any] =\n  application ++ ZStream.finalizer(\n    (deleteDir(Paths.get(\"tmp\")) *>\n      printLine(\"Temporary directory was deleted.\")).orDie\n  )\n```\n\n----------------------------------------\n\nTITLE: Ensuring Fiber Interruption Callback Execution in ZIO (Scala)\nDESCRIPTION: This snippet refines the previous example by ensuring the child fiber's `onInterrupt` callback is executed by using a Promise-based latch for coordination and fiber ID context. It illustrates reliable synchronization between fibers when handling structured concurrency and graceful shutdown. Input is no arguments; output is debug logs with fiber IDs. Requires ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    ZIO.fiberIdWith { parent =>\n      for {\n        _     <- ZIO.debug(s\"fiber-${parent.id} Application started!\")\n        latch <- Promise.make[Nothing, Unit]\n        _ <- ZIO.fiberIdWith { child =>\n               (latch.succeed(()) *> ZIO.never).onInterrupt(_ =>\n                 ZIO.debug(s\"fiber-${child.id} The child fiber interrupted!\")\n               )\n             }.fork\n        _ <- latch.await\n        _ <- ZIO.debug(s\"fiber-${parent.id} Application finished!\")\n      } yield ()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing with Mock Service Implementations in Scala\nDESCRIPTION: Demonstrates how programming to interfaces (traits) facilitates testing. It defines mock implementations (`MockFormatter`, `MockCompiler`) of the `Formatter` and `Compiler` traits. An instance of `EditorLive` is then created using these mock dependencies, allowing the `Editor`'s logic to be tested in isolation. A basic ZIO Test structure is shown for asserting the result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nclass MockFormatter extends Formatter {\n  def format(code: String): UIO[String] = \n    ZIO.succeed(code) // dummy implementation\n}\n\nclass MockCompiler extends Compiler {\n  def compile(code: String): UIO[String] = \n    ZIO.succeed(code) // dummy implementation\n}\n\nval formatter = new MockFormatter() // Creating mock formatter\nval compiler  = new MockCompiler()  // Creating mock compiler\nval editor    = new EditorLive(formatter, compiler) // Assembling formatter and compiler into CodeEditor\n\nimport zio.test._\n\nval expectedOutput = ???\nfor {\n  r <- editor.formatAndCompile(\"println(\\\"Hello, world!\\\")\") \n} yield assertTrue(r == expectedOutput)\n```\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple ZIOAppDefault Applications in Scala\nDESCRIPTION: This example demonstrates composing two separate ZIO applications (`MyApp1` and `MyApp2`), both extending `ZIOAppDefault`, into a single executable application (`Main`). `MyApp2` overrides its `bootstrap` layer, potentially adding infrastructure like logging or profiling (represented by placeholder layers). The `<>` operator combines the layers of both applications. `ZIOApp.Proxy` is used in the final `Main` object to delegate to the composed application, effectively running both `run` effects in parallel after merging their respective layers. This depends on the `zio` library, specifically `ZIOAppDefault`, `ZIOApp.Proxy`, `ZIO`, and `ZLayer`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zioapp.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:invisible\nimport zio._\nval asyncProfiler, slf4j, loggly, newRelic = ZLayer.empty\n```\n```\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MyApp1 extends ZIOAppDefault {    \n  def run = ZIO.succeed(???)\n}\n\nobject MyApp2 extends ZIOAppDefault {\n  override val bootstrap: ZLayer[Any, Any, Any] =\n    asyncProfiler ++ slf4j ++ loggly ++ newRelic\n\n  def run = ZIO.succeed(???)\n}\n\nobject Main extends ZIOApp.Proxy(MyApp1 <> MyApp2)\n```\n```\n\n----------------------------------------\n\nTITLE: Composing ZIO Effects in Parallel\nDESCRIPTION: Shows parallel composition of ZIO effects requiring multiple services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[A with B, Nothing, (String, Int)] = A.foo <&> B.bar\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO Dependencies\nDESCRIPTION: Import statements for ZIO core classes and related utilities needed for ZStream operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Cause.Die\nimport zio.Console._\nimport zio.stm.{STM, TQueue}\nimport java.io.{BufferedReader, FileReader, FileInputStream, IOException}\nimport java.nio.file.{Files, Path, Paths}\nimport java.nio.file.Path._\nimport java.net.URL\nimport java.lang.IllegalArgumentException\nimport scala.concurrent.TimeoutException\n```\n\n----------------------------------------\n\nTITLE: Validating Weight with ZIO FlatMap\nDESCRIPTION: Demonstrates using ZIO's flatMap to handle effectful inputs when validating a weight value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef validateWeightOrFailZIO[R](weight: ZIO[R, Nothing, Double]): ZIO[R, String, Double] =\n  weight.flatMap { w =>\n    if (w >= 0)\n      ZIO.succeed(w)\n    else\n      ZIO.fail(s\"negative input: $w\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Using Scoped ZStream from Hub with Promise in Scala\nDESCRIPTION: Demonstrates how to use a scoped ZStream from a Hub, ensuring subscription completion before publishing. It uses a Promise for synchronization.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  promise <- Promise.make[Nothing, Unit]\n  hub     <- Hub.bounded[String](2)\n  scoped  = ZStream.fromHubScoped(hub).tap(_ => promise.succeed(()))\n  stream   = ZStream.unwrapScoped(scoped)\n  fiber   <- stream.take(2).runCollect.fork\n  _       <- promise.await\n  _       <- hub.publish(\"Hello\")\n  _       <- hub.publish(\"World\")\n  _       <- fiber.join\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Counting Random Key Occurrences with Frequency Metric in ZIO (Scala)\nDESCRIPTION: This snippet demonstrates applying a Frequency metric (freq) to count the occurrences of randomly generated String keys in a ZIO effect. It uses ZIO Random.nextIntBounded to produce an integer in [0,9], maps it to a String key, tags the resulting effect with the freq metric, and repeats this operation 100 times. The metric will automatically track and count each unique key string. Requires importing zio._ for effect and random utilities, and a previously created Frequency metric instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/frequency.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\n(Random.nextIntBounded(10).map(v => s\"MyKey-$v\") @@ freq).repeatN(100)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive Echo Channel in Scala ZIO\nDESCRIPTION: Creates an infinite console echo service that continuously reads input from the console and writes it back until 'exit' is entered. Uses recursive composition of ZChannel instances.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream.ZChannel\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val producer: ZChannel[Any, Any, Any, Any, IOException, String, Nothing] =\n    ZChannel\n      .fromZIO(Console.readLine(\"Please enter some text: \"))\n      .flatMap(i => ZChannel.write(i) *> producer)\n\n  val consumer: ZChannel[Any, Any, String, Any, IOException, Nothing, Unit] =\n    ZChannel.readWith(\n      (i: String) => i match {\n        case \"exit\" => ZChannel.unit\n        case _ => ZChannel.fromZIO(Console.printLine(\"Consumed: \" + i)) *> consumer\n      },\n      (_: Any) => ZChannel.unit,\n      (_: Any) => ZChannel.unit\n    )\n\n  def run = (producer >>> consumer).run\n}\n```\n\n----------------------------------------\n\nTITLE: Submerging Failures with absolve in ZIO (Scala)\nDESCRIPTION: Demonstrates the use of `ZIO.absolve` to submerge failures, which is the opposite of `either`. It turns a `ZIO[R, Nothing, Either[E, A]]` into a `ZIO[R, E, A]`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\ndef sqrt(io: UIO[Double]): IO[String, Double] =\n  ZIO.absolve(\n    io.map(value =>\n      if (value < 0.0) Left(\"Value must be >= 0.0\")\n      else Right(Math.sqrt(value))\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Basic ZState Usage with Integer State in Scala\nDESCRIPTION: Demonstrates the fundamental usage of ZState with an Int as the state type. The example shows how to access the state, update it incrementally, and finally retrieve and display the current state value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/zstate.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nobject ZStateExample extends zio.ZIOAppDefault {\n  val myApp: ZIO[ZState[Int], IOException, Unit] = for {\n    s <- ZIO.service[ZState[Int]]\n    _ <- s.update(_ + 1)\n    _ <- s.update(_ + 2)\n    state <- s.get\n    _ <- Console.printLine(s\"current state: $state\")\n  } yield ()\n\n  def run = ZIO.stateful(0)(myApp)\n}\n```\n\n----------------------------------------\n\nTITLE: Basic ZLayer Derivation in Scala\nDESCRIPTION: Demonstrates the basic usage of ZLayer.derive to create simple ZLayer instances for Database and UserService classes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/automatic-zlayer-derivation.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nclass Database(connection: String)\nobject Database {\n  val layer: ZLayer[String, Nothing, Database] = ZLayer.derive[Database]\n}\n\nclass UserService(db: Database)\nobject UserService {\n  val layer: ZLayer[Database, Nothing, UserService] = ZLayer.derive[UserService]\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up ZIO Runtime for Benchmarking\nDESCRIPTION: Demonstrates how to create a runtime optimized for benchmarking by using ZIO's built-in benchmark Platform configuration. This disables tracing and auto-yielding for better performance measurement.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval benchmarkRuntime = Runtime.default.mapPlatform(_ => Platform.benchmark)\n```\n\n----------------------------------------\n\nTITLE: Cancellable Server Socket Accept Operation\nDESCRIPTION: Implementation of a cancellable blocking operation for accepting server socket connections using attemptBlockingCancelable.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport java.net.{Socket, ServerSocket}\nimport zio._\n\ndef accept(ss: ServerSocket): Task[Socket] =\n  ZIO.attemptBlockingCancelable(ss.accept())(ZIO.succeed(ss.close()))\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retryWhile to Retry Based on Error Condition in Scala\nDESCRIPTION: Demonstrates the `retryWhile` method. The `remoteService` effect is retried indefinitely as long as it fails with an error that equals `TemporarilyUnavailable`. Requires the `remoteService` definition and `TemporarilyUnavailable` error type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nremoteService.retryWhile(_ == TemporarilyUnavailable)\n```\n\n----------------------------------------\n\nTITLE: Fixed-size ZKeyedPool Usage Example\nDESCRIPTION: Complete example showing how to create and use a ZKeyedPool with a fixed size. It demonstrates creating resources for different keys and how the pool manages their lifecycle.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zkeyedpool.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject ZKeyedPoolExample extends ZIOAppDefault {\n  def resource(key: String): ZIO[Scope, Nothing, String] = ZIO.acquireRelease(\n    ZIO.random\n      .flatMap(_.nextUUID.map(_.toString))\n      .flatMap(uuid => ZIO.debug(s\"Acquiring the resource with the $key key and the $uuid id\").as(uuid))\n  )(uuid => ZIO.debug(s\"Releasing the resource with the $key key and the $uuid id!\"))\n\n  def run =\n    for {\n      pool <- ZKeyedPool.make(resource, 3)\n      _    <- pool.get(\"foo\")\n      item <- pool.get(\"bar\")\n      _    <- ZIO.debug(s\"Item: $item\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Nested File Transfer Using AcquireRelease\nDESCRIPTION: Example of nested resource management for file transfer using ZIO's acquireRelease.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(src: String, dst: String): ZIO[Any, Throwable, Unit] = {\n  ZIO.acquireReleaseWith(is(src))(close) { in =>\n    ZIO.acquireReleaseWith(os(dst))(close) { out =>\n      copy(in, out)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Server that Updates a RefM Value\nDESCRIPTION: A server function that takes a RefM and continuously updates its value by incrementing it. This demonstrates the updating side of a SubscriptionRef pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/subscriptionref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef server(ref: RefM[Long]): UIO[Nothing] =\n  ref.update(n => ZIO.succeed(n + 1)).forever\n```\n\n----------------------------------------\n\nTITLE: Exporting HTTP Request Total Metrics for Prometheus in ZIO\nDESCRIPTION: This snippet shows the Prometheus-formatted output for total HTTP requests metrics. It includes counters for both POST and GET requests to the '/users' endpoint, broken down by method, path, and status code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_8\n\nLANGUAGE: prometheus\nCODE:\n```\n# TYPE http_requests_total counter\n# HELP http_requests_total\nhttp_requests_total{method=\"POST\",path=\"/users\",status=\"200\",} 2.0 1714503503829\n# TYPE http_requests_total counter\n# HELP http_requests_total\nhttp_requests_total{method=\"GET\",path=\"/users\",status=\"200\",} 1.0 1714503503829\n```\n\n----------------------------------------\n\nTITLE: Removing an Element from a TMap by Key in ZIO STM\nDESCRIPTION: Demonstrates removing a key-value pair from a TMap using the delete method. The operation takes a key and removes the corresponding entry from the map.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval deleteElem: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  _    <- tMap.delete(\"b\")\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Traditional Blocking Scala Constructor Implementation\nDESCRIPTION: Example showing problematic blocking operation in a traditional Scala constructor for a KafkaProducer class. This approach is discouraged as it can lead to performance issues.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nclass ProducerInput\n\nclass KafkaProducer(input: ProducerInput) {\n  def send(message: String): Unit = ???\n}\n\nobject KafkaProducer {\n  def apply() = {\n    // Blocking operation, we should avoid it inside constructors\n    val input = doSomeBlockingOperation()\n    new KafkaProducer(input)\n  }\n\n  private def doSomeBlockingOperation(): ProducerInput = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Writing and Reading Parquet Files with Filtering in Scala\nDESCRIPTION: This example demonstrates how to write a small chunk of data to a Parquet file and read it back applying a filter predicate. It uses ZIO, ZIO Streams, and ZIO Schema for type-safe operations and codec derivation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-apache-parquet.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n//> using scala \"3.5.0\"\n//> using dep me.mnedokushev::zio-apache-parquet-core:0.1.0\n\nimport zio.*\nimport zio.schema.*\nimport me.mnedokushev.zio.apache.parquet.core.codec.*\nimport me.mnedokushev.zio.apache.parquet.core.hadoop.{ ParquetReader, ParquetWriter, Path }\nimport me.mnedokushev.zio.apache.parquet.core.filter.syntax.*\nimport me.mnedokushev.zio.apache.parquet.core.filter.*\n\nimport java.nio.file.Files\n\nobject Filtering extends ZIOAppDefault:\n\n  case class MyRecord(a: Int, b: String, c: Option[Long])\n\n  object MyRecord:\n    // We need to provide field names using singleton types\n    given Schema.CaseClass3.WithFields[\"a\", \"b\", \"c\", Int, String, Option[Long], MyRecord] =\n      DeriveSchema.gen[MyRecord]\n    given SchemaEncoder[MyRecord]                                                          =\n      Derive.derive[SchemaEncoder, MyRecord](SchemaEncoderDeriver.default)\n    given ValueEncoder[MyRecord]                                                           =\n      Derive.derive[ValueEncoder, MyRecord](ValueEncoderDeriver.default)\n    given ValueDecoder[MyRecord]                                                           =\n      Derive.derive[ValueDecoder, MyRecord](ValueDecoderDeriver.default)\n    given TypeTag[MyRecord]                                                                =\n      Derive.derive[TypeTag, MyRecord](TypeTagDeriver.default)\n\n    // Define accessors to use them later in the filter predicate.\n    // You can give any names to the accessors as we demonstrate here.\n    val (id, name, age) = Filter[MyRecord].columns\n\n  val data =\n    Chunk(\n      MyRecord(1, \"bob\", Some(10L)),\n      MyRecord(2, \"bob\", Some(12L)),\n      MyRecord(3, \"alice\", Some(13L)),\n      MyRecord(4, \"john\", None)\n    )\n\n  val recordsFile = Path(Files.createTempDirectory(\"records\")) / \"records.parquet\"\n\n  override def run =\n    (\n      for {\n        writer   <- ZIO.service[ParquetWriter[MyRecord]]\n        reader   <- ZIO.service[ParquetReader[MyRecord]]\n        _        <- writer.writeChunk(recordsFile, data)\n        fromFile <- reader.readChunkFiltered(\n                      recordsFile,\n                      filter(\n                        MyRecord.id > 1 `and` (\n                          MyRecord.name =!= \"bob\" `or`\n                            // Use .nullable syntax for optional fields.\n                            MyRecord.age.nullable > 10L\n                        )\n                      )\n                    )\n        _        <- Console.printLine(fromFile)\n      } yield ()\n    ).provide(\n      ParquetWriter.configured[MyRecord](),\n      ParquetReader.configured[MyRecord]()\n    )\n  // Outputs:\n  // Chunk(MyRecord(2,bob,Some(12)),MyRecord(3,alice,Some(13)),MyRecord(4,john,None))\n```\n\n----------------------------------------\n\nTITLE: Using dropWhile Method on Chunk in Scala\nDESCRIPTION: Demonstrates the dropWhile method which removes elements as long as they satisfy a predicate. This example drops elements while they are greater than or equal to 2.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nChunk(9, 2, 5, 1, 6).dropWhile(_ >= 2)\n// res6: Chunk[Int] = IndexedSeq(1, 6)\n```\n\n----------------------------------------\n\nTITLE: Converting Future to Fiber\nDESCRIPTION: Shows how to convert a Scala Future into a ZIO Fiber using Fiber.fromFuture. This is a pure operation that works with any reasonable fiber equality implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-future.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef futureToFiber[A](future: => Future[A]): Fiber[Throwable, A] = \n  Fiber.fromFuture(future)\n```\n\n----------------------------------------\n\nTITLE: Accessing Multiple Dependencies from ZEnvironment in a ZIO Workflow (Scala)\nDESCRIPTION: Illustrates retrieving multiple distinct services (`Formatter` and `Compiler`) individually from the `ZEnvironment` within a ZIO `for`-comprehension. It demonstrates fetching each required dependency using `environment.get[...]` when needed during the workflow execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nval workflow: ZIO[Any, Nothing, Unit] =\n  for {\n    f <- environment.get[Formatter].format(\"println(\\\"Hello, world!\\\")\")\n    _ <- environment.get[Compiler].compile(f)\n  } yield ()\n```\n```\n\n----------------------------------------\n\nTITLE: Non-effectful Folding of Errors and Successes with fold in ZIO for Scala\nDESCRIPTION: This code uses fold to handle both failure and success cases in a non-effectful, purely functional way. A default value is returned on failure, and success passes through the data. The snippet requires ZIO and IO, input as an error-prone effect, and outputs a UIO with an error-free result. This is efficient for simple error handling where only values (not effects) are required.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nlazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: UIO[Array[Byte]] = \n  openFile(\"primary.data\").fold(\n    _    => DefaultData,\n    data => data)\n```\n\n----------------------------------------\n\nTITLE: Creating Conditional Repeating ZStreams in Scala\nDESCRIPTION: Shows how to create ZStreams that repeat until a condition is met using ZStream.repeatEffectOption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval userInputs: ZStream[Console, IOException, String] = \n  ZStream.repeatEffectOption(\n    zio.console.getStrLn.mapError(Option(_)).flatMap {\n      case \"EOF\" => ZIO.fail[Option[IOException]](None)\n      case o     => ZIO.succeed(o)\n    }\n  )\n\ndef drainIterator[A](it: Iterator[A]): ZStream[Any, Throwable, A] =\n  ZStream.repeatEffectOption {\n    ZIO(it.hasNext).mapError(Some(_)).flatMap { hasNext =>\n      if (hasNext) ZIO(it.next()).mapError(Some(_))\n      else ZIO.fail(None)\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Modifying TRef Value in a Single Transaction\nDESCRIPTION: Shows how to modify a TRef value and extract information in a single transaction. The modify method applies a function that returns both a result and a new value for the reference.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval modifySingle: UIO[(String, Int)] = (for {\n  tRef <- TRef.make(10)\n  mValue <- tRef.modify(v => (\"Zee-Oh\", v + 10))\n  nValue <- tRef.get\n} yield (mValue, nValue)).commit\n```\n\n----------------------------------------\n\nTITLE: Folding ZIO Effects with Default Value\nDESCRIPTION: Shows how to use the fold method in ZIO to handle both failure and success cases, converting them to a common type with a default value for the failure case.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nlazy val DefaultData: Array[Byte] = Array(0, 0)\n\nval primaryOrDefaultData: ZIO[Any, Nothing, Array[Byte]] = \n  openFile(\"primary.data\").fold(\n    _    => DefaultData, // Failure case\n    data => data)        // Success case\n```\n\n----------------------------------------\n\nTITLE: File Operations with ZSink\nDESCRIPTION: Shows how to create file sinks for writing stream data to files. Includes example of converting string streams to byte streams and writing to specified file paths.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/creating-sinks.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef fileSink(path: Path): ZSink[Any, Throwable, String, Byte, Long] =\n  ZSink\n    .fromPath(path)\n    .contramapChunks[String](_.flatMap(_.getBytes))\n\nval result = ZStream(\"Hello\", \"ZIO\", \"World!\")\n  .intersperse(\"\\n\")\n  .run(fileSink(Paths.get(\"file.txt\")))\n```\n\n----------------------------------------\n\nTITLE: Checking Available Permits in TSemaphore in Scala ZIO\nDESCRIPTION: Shows how to query the number of remaining permits in a TSemaphore using the available method. This example creates a semaphore with 2 permits, acquires one, and then checks how many permits are still available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tsemaphore.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreAvailable: STM[Nothing, Long] = for {\n  tSem <- TSemaphore.make(2L)\n  _    <- tSem.acquire\n  cap  <- tSem.available\n} yield cap\n\ntSemaphoreAvailable.commit\n```\n\n----------------------------------------\n\nTITLE: Creating Shared Base Spec for ZIO Tests in Scala\nDESCRIPTION: This snippet defines an abstract base class SharedCounterSpec that includes the shared Counter layer in its bootstrap.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/sharing-layers-between-multiple-files.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nabstract class SharedCounterSpec extends ZIOSpec[Counter] {\n  override val bootstrap: ZLayer[Any, Nothing, Counter] = Counter.layer\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Default ZIO Runtime with Custom Environment in Scala\nDESCRIPTION: This snippet demonstrates modifying the environment of the default ZIO `Runtime`. It uses `Runtime.default.withEnvironment` to replace the default environment with a new `ZEnvironment` containing instances of `LoggingServiceLive` and `EmailServiceFake`. The resulting `testableRuntime` inherits other settings from the default runtime but has the specified services available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval testableRuntime: Runtime[LoggingService with EmailService] =\n  Runtime.default.withEnvironment {\n    ZEnvironment[LoggingService, EmailService](LoggingServiceLive(), EmailServiceFake())\n  }\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Future to ZIO Fiber in Scala\nDESCRIPTION: This snippet provides a function that converts a by-name Future to a ZIO Fiber, using Fiber.fromFuture. It allows encapsulating Future computations as lightweight ZIO fibers. There are no additional dependencies besides ZIO and Scala's Future. The input is a by-name Future, the output is a Fiber of the computed result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-future.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef futureToFiber[A](future: => Future[A]): Fiber[Throwable, A] = \n  Fiber.fromFuture(future)\n```\n\n----------------------------------------\n\nTITLE: Controlling Asynchronous Code with TestClock in Scala\nDESCRIPTION: Shows how TestClock affects asynchronous code scheduled to run after a certain time. It creates a promise that resolves after 10 seconds and uses TestClock to simulate the time passage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion.equalTo\n\ntest(\"One can control time as he see fit\") {\n  for {\n    promise <- Promise.make[Unit, Int]\n    _       <- (ZIO.sleep(10.seconds) *> promise.succeed(1)).fork\n    _       <- TestClock.adjust(10.seconds)\n    readRef <- promise.await\n  } yield assertTrue(1 == readRef)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Fiber to Scala Future in Scala\nDESCRIPTION: This snippet presents a function to convert a ZIO Fiber into a Scala Future by leveraging the Fiber's toFuture method. It provides interoperability for joining an existing fiber from the standard Scala Future API. Dependencies include ZIO and Scala's concurrent.Future; expects a Fiber as input, outputs an effect yielding the corresponding Future.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-future.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef fiberToFuture[A](fiber: Fiber[Throwable, A]): UIO[Future[A]] = \n  fiber.toFuture\n```\n\n----------------------------------------\n\nTITLE: Non-deterministic Random Number Generation Test in Scala ZIO\nDESCRIPTION: Shows how to use the nondeterministic test aspect to generate different sequences of random numbers for each test repetition by changing the seed of the pseudo-random generator before each run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/non-deterministic-test-data.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\nimport zio.test.TestAspect._\n\ntest(\"pseudo-random number generator with random initial seed on each repetition\") {\n  check(Gen.int(0, 100)) { n =>\n    ZIO.attempt(n).debug.map(_ => assertTrue(true))\n  }\n} @@\n  nondeterministic @@\n  samples(5) @@\n  after(Console.printLine(\"----\").orDie) @@\n  repeat(Schedule.recurs(1))\n```\n\n----------------------------------------\n\nTITLE: Defining MetadataRepo Service Interface in ZIO\nDESCRIPTION: Defines the MetadataRepo trait which provides operations for storing, retrieving, deleting, and searching document metadata with ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait MetadataRepo {\n  def get(id: String): ZIO[Any, Throwable, Metadata]\n\n  def put(id: String, metadata: Metadata): ZIO[Any, Throwable, Unit]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n\n  def findByTitle(title: String): ZIO[Any, Throwable, Map[String, Metadata]]\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#timeoutFail/timeoutFailCause for Timeout Errors in Scala\nDESCRIPTION: Demonstrates the `ZIO#timeoutFail` and `ZIO#timeoutFailCause` operators. `timeoutFail` causes the effect to fail with a specified error (`TimeoutException`) if the timeout (1 second) elapses before the `delayedNextInt` effect completes. `timeoutFailCause` causes the effect to fail with a specified `Cause` (containing a `Die` defect here) upon timeout.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/timing-out.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\nimport scala.concurrent.TimeoutException\n\nval r1: ZIO[Any, TimeoutException, Int] =\n  delayedNextInt.timeoutFail(new TimeoutException)(1.second)\n\nval r2: ZIO[Any, Nothing, Int] =\n  delayedNextInt.timeoutFailCause(Cause.die(new Error(\"timeout\")))(1.second)\n```\n```\n\n----------------------------------------\n\nTITLE: Multiple Assertions with assertTrue in Scala\nDESCRIPTION: Shows how to assert multiple assertions inside a single assertTrue call in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntest(\"multiple assertions\"){\n  assertTrue(\n    true,\n    1 + 1 == 2,\n    Some(1 + 1) == Some(2)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Setting and Asserting JVM System Properties with TestSystem in Scala\nDESCRIPTION: This snippet demonstrates how to use TestSystem to set a JVM system property and then assert its value. It sets the 'java.vm.name' property to 'VM' and then retrieves and checks this value using System.property.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/system.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\nimport zio.test.Assertion._\n\nfor {\n  _      <- TestSystem.putProperty(\"java.vm.name\", \"VM\")\n  result <- System.property(\"java.vm.name\")\n} yield assertTrue(result == Some(\"VM\"))\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Setting Ref Values in Scala\nDESCRIPTION: Demonstrates how to retrieve the current value of a Ref using get and set a new value using set. It shows both flatMap and for-comprehension approaches.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nRef.make(\"initial\")\n   .flatMap(_.get)\n   .flatMap(current => Console.printLine(s\"current value of ref: $current\"))\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  ref   <- Ref.make(\"initial\")\n  value <- ref.get\n} yield assert(value == \"initial\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  ref   <- Ref.make(\"initial\")\n  _     <- ref.set(\"update\")\n  value <- ref.get\n} yield assert(value == \"update\")\n```\n\n----------------------------------------\n\nTITLE: Common ZStream Constructors in Scala\nDESCRIPTION: Examples of basic ZStream constructors including apply, unit, never, repeat, range, environment, and managed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZStream[Any, Nothing, Int] = ZStream(1, 2, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval unit: ZStream[Any, Nothing, Unit] = ZStream.unit\n```\n\nLANGUAGE: scala\nCODE:\n```\nval never: ZStream[Any, Nothing, Nothing] = ZStream.never\n```\n\nLANGUAGE: scala\nCODE:\n```\nval nats: ZStream[Any, Nothing, Int] = \n  ZStream.iterate(1)(_ + 1) // 1, 2, 3, ...\n```\n\nLANGUAGE: scala\nCODE:\n```\nval range: ZStream[Any, Nothing, Int] = ZStream.range(1, 5) // 1, 2, 3, 4\n```\n\nLANGUAGE: scala\nCODE:\n```\nval clockStream: ZStream[Clock, Nothing, Clock] = ZStream.environment[Clock]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval managedStream: ZStream[Blocking, Throwable, BufferedReader] =\n  ZStream.managed(\n    ZManaged.fromAutoCloseable(\n      zio.blocking.effectBlocking(\n        Files.newBufferedReader(java.nio.file.Paths.get(\"file.txt\"))\n      )\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retryUntilEquals for Specific Error Matching in Scala\nDESCRIPTION: Shows the `retryUntilEquals` method, a shorthand for `retryUntil` with an equality check. The `remoteService` effect is retried until the error equals `DataCorrupted`. Requires the `remoteService` definition and `DataCorrupted` error type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nremoteService.retryUntilEquals(DataCorrupted)\n```\n\n----------------------------------------\n\nTITLE: Composing Two Queues with bothWith in Scala\nDESCRIPTION: Composes two ZIO queues using bothWith, broadcasting offer/take to both queues and collecting their outputs. Demonstrates advanced queue composition. Standard zio._ usage with basic Scala types. Returns a tuple (Int, String) from a combined take.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval fromComposedQueues: UIO[(Int, String)] = \\n  for {\\n    q1       <- Queue.bounded[Int](3)\\n    q2       <- Queue.bounded[Int](3)\\n    q2Mapped =  q2.map(_.toString)\\n    both     =  q1.bothWith(q2Mapped)((_, _))\\n    _        <- both.offer(1)\\n    iAndS    <- both.take\\n    (i, s)   =  iAndS\\n  } yield (i, s)\\n\n```\n\n----------------------------------------\n\nTITLE: Simulating Timed Stream Events with TestClock in Scala\nDESCRIPTION: Shows how to use TestClock to test a stream of timed events. It creates a stream of 30 elements spaced 1 second apart and uses TestClock to simulate the passage of time, allowing the stream to generate all elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\n\ntest(\"test clock\") {\n  val stream = ZStream.iterate(0)(_ + 1).schedule(Schedule.spaced(1.second))\n  val s1 = stream.take(30)\n  val sink = ZSink.collectAll[Int]\n  for {\n    fiber <- s1.run(sink).fork\n    _ <- TestClock.adjust(1.second).repeat(Schedule.recurs(30))\n    runner <- fiber.join\n  } yield assert(runner.size)(equalTo(30))\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Suspended Fiber Status and Blocking ID in ZIO with Scala\nDESCRIPTION: This Scala snippet demonstrates how to check the status of a ZIO fiber. It forks a non-terminating fiber (`f1`) and another fiber (`f2`) that awaits `f1`. It then polls `f2`'s status until it's `Suspended`, extracts the ID of the fiber being blocked on (`f1.id`), and verifies it using an assertion. Requires the `zio` library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiberstatus.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent\nimport zio._\n\nfor {\n  f1 <- ZIO.never.fork\n  f2 <- f1.await.fork\n  blockingOn <- f2.status\n    .collect(()) { case Fiber.Status.Suspended(_, _, blockingOn) =>\n      blockingOn\n    }\n    .eventually\n} yield (assert(blockingOn == f1.id))\n```\n```\n\n----------------------------------------\n\nTITLE: Stub Example for readFile ZIO Effect - Scala\nDESCRIPTION: Defines a stub for a readFile function returning a ZIO effect that attempts to read bytes from a file. It refines the possible Throwable failures to IOException using refineToOrDie. This is a placeholder for demonstrating error handling, and does not actually implement the IO logic (uses ???). Depends on ZIO and java.io.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.{ FileNotFoundException, IOException }\n\ndef readFile(s: String): ZIO[Any, IOException, Array[Byte]] =\n  ZIO.attempt(???).refineToOrDie[IOException]\n```\n\n----------------------------------------\n\nTITLE: Refining Non-Throwable Errors with `refineOrDieWith` in ZIO Scala\nDESCRIPTION: Illustrates using `refineOrDieWith` on an effect where the error type `E` is `String`. It refines the error space using a partial function to handle specific strings (\"FooError\", \"BarError\"). Any other string error (like \"BazError\") is converted into a `Throwable` defect using the provided function `e => new Throwable(e)`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def effect(i: String): ZIO[Any, String, Nothing] = {\n    if (i == \"foo\") ZIO.fail(\"FooError\")\n    else if (i == \"bar\") ZIO.fail(\"BarError\")\n    else ZIO.fail(\"BazError\")\n  }\n\n  val refined: ZIO[Any, String, Nothing] =\n    effect(\"baz\").refineOrDieWith {\n      case \"FooError\" | \"BarError\" => \"Oh Uh!\"\n    }(e => new Throwable(e))\n\n  def run = refined.catchAll(_ => ZIO.unit)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a TArray with Specified Values in ZIO STM (Scala)\nDESCRIPTION: Creates a TArray pre-populated with the specified integer values. The make method accepts a varargs parameter to initialize the array with the provided elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval specifiedValuesTArray: STM[Nothing, TArray[Int]] = TArray.make(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty TMap in ZIO STM\nDESCRIPTION: Creates an empty transactional map (TMap) using the empty constructor. This operation returns an STM effect that produces an empty TMap when executed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval emptyTMap: STM[Nothing, TMap[String, Int]] = TMap.empty[String, Int]\n```\n\n----------------------------------------\n\nTITLE: Reading and Dividing User Input with ZIO - Scala\nDESCRIPTION: Defines a ZIO application that reads two integers from the user and performs division, displaying the result. Utilizes IO for interaction, with explicit error handling for IOExceptions during input but does not guard against division by zero, instead allowing ArithmeticException to cause a defect and crash. Requires zio, java.io, and the Console module. Inputs are user-supplied, outputs are printed to the console.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/examples.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\nimport java.io.IOException\\n\\nobject MainApp extends ZIOAppDefault {\\n  def run =\\n    for {\\n      a <- readNumber(\"Enter the first number  (a): \")\\n      b <- readNumber(\"Enter the second number (b): \")\\n      r <- divide(a, b)\\n      _ <- Console.printLine(s\"a / b: $r\")\\n    } yield ()\\n\\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\\n    Console.print(msg) *> Console.readLine.map(_.toInt)\\n\\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\\n    if (b == 0)\\n      ZIO.die(new ArithmeticException(\"divide by zero\")) // unexpected error\\n    else\\n      ZIO.succeed(a / b)\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Global-Scoped (Daemon) Fibers in ZIO (Scala)\nDESCRIPTION: Shows how to fork fibers as daemons using `forkDaemon`, so that their lifetime is tied to the global scope and not to the parent fiber. The daemon fiber continues executing even after the parent fiber finishes, as demonstrated by continued debug output after the parent has ended. The snippet uses time delays and effect repetition. Requires ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug(\"Bar: still running!\")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- ZIO.debug(\"Foo: started!\")\n      _ <- barJob.forkDaemon\n      _ <- ZIO.sleep(3.seconds)\n      _ <- ZIO.debug(\"Foo: finished!\")\n    } yield ()\n\n  def run =\n    for {\n      f <- fooJob.fork\n      _ <- ZIO.sleep(5.seconds)\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating ZManaged-based Resource Transfer to Scoped in Scala\nDESCRIPTION: Complete example of migrating a ZManaged-based file transfer function to use Scope in ZIO 2.0, demonstrating changes in resource management and error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_71\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io._\n\ndef close(resource: Closeable): UIO[Unit] =\n  ZIO.attempt(resource.close()).orDie\n\ndef is(file: String): ZIO[Scope, IOException, FileInputStream] =\n  ZIO.acquireRelease(ZIO.attemptBlockingIO(new FileInputStream(file)))(close)\n\ndef os(file: String): ZIO[Scope, IOException, FileOutputStream] =\n  ZIO.acquireRelease(ZIO.attemptBlockingIO(new FileOutputStream(file)))(close)\n\ndef copy(\n    from: FileInputStream,\n    to: FileOutputStream\n): IO[IOException, Unit] =\n  ZIO.attemptBlockingIO(???)\n\ndef transfer(from: String, to: String): IO[Throwable, Unit] =\n  ZIO.scoped {\n    for {\n      from <- is(from)\n      to   <- os(to)\n      _    <- copy(from, to)\n    } yield ()\n  }\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Error Recovery with catchAll - Scala\nDESCRIPTION: This snippet demonstrates exhaustively handling all custom validation exceptions using catchAll with pattern matching. It uses ZIO.debug and as to log errors and return default values for all cases. The effect's input is an age Int, and the output handles both NegativeAgeException and IllegalAgeException, always returning an Int.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  validate(20)\n  .catchAll {\n    case NegativeAgeException(age) =>\n      ZIO.debug(s\"negative age: $age\").as(-1)\n    case IllegalAgeException(age) =>\n      ZIO.debug(s\"illegal age: $age\").as(-1)\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Generators in ZIO Test\nDESCRIPTION: Shows how to create generators for basic types like Int and String using ZIO Test's Gen data type. These generators are used to produce random values for property testing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/getting-started.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nval intGen: Gen[Any, Int] = Gen.int\nval stringGen: Gen[Sized, String] = Gen.string\n```\n\n----------------------------------------\n\nTITLE: Using withLive for Partial Live Environment Access in ZIO (Scala)\nDESCRIPTION: Demonstrates using Live.withLive to apply a timeout operation from the live environment to a long-running task in the test environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/live.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\nval longRunningSUT =\n  ZIO.attemptBlockingInterrupt {\n    // ... \n    Thread.sleep(10000) // simulating a long-running blocking operation\n    // ...\n  }\n  \ntest(\"withLive provides real environment to a single part of an effect\") {\n  assertZIO(Live.withLive(longRunningSUT)(_.timeout(3.seconds)))(anything)\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.scoped for Resource Management in Scala\nDESCRIPTION: Example of using ZIO.scoped to manage resources and eliminate Scope from the environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_66\n\nLANGUAGE: scala\nCODE:\n```\nZIO.scoped {\n  openFile(name).flatMap(file => useFile(file))  // ZIO[Scoped, IOException, Unit]\n}                                                // ZIO[Any, IOException, Unit]\n```\n\n----------------------------------------\n\nTITLE: Performing Cleanup on Error with onError in ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#onError to perform cleanup tasks when a stream encounters an error. The example demonstrates printing a cleanup message when the stream fails.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nval stream = \n  (ZStream(1, 2, 3) ++ ZStream.dieMessage(\"Oh! Boom!\") ++ ZStream(4, 5))\n    .onError(_ => Console.printLine(\"Stream application closed! We are doing some cleanup jobs.\").orDie)\n```\n\n----------------------------------------\n\nTITLE: Creating an Absolute Gauge Metric Instance with ZIO in Scala\nDESCRIPTION: This snippet shows concrete instantiation of a gauge metric using Metric.gauge and assigns it to absoluteGauge. It relies on importing zio._ and zio.metrics._ for relevant types and constructors. The gauge is named 'setGauge' and is typed Double, representing a value that can increase or decrease over time. This is typically used for point-in-time measurements like memory usage or queue size.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/gauge.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.metrics._\nval absoluteGauge = Metric.gauge(\"setGauge\")\n```\n\n----------------------------------------\n\nTITLE: Taking All Elements from TPriorityQueue in Scala ZIO\nDESCRIPTION: Shows how to take all elements from a TPriorityQueue in sorted order using takeAll method within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpriorityqueue.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval sorted: STM[Nothing, Chunk[Int]] =\n  for {\n    queue  <- TPriorityQueue.empty[Int]\n    _      <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n    sorted <- queue.takeAll\n  } yield sorted\n```\n\n----------------------------------------\n\nTITLE: Acquiring a Permit from TSemaphore in Scala ZIO\nDESCRIPTION: Shows how to acquire a permit from a TSemaphore, which reduces the number of available permits. This example creates a semaphore with 2 permits and acquires one permit within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tsemaphore.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreAcq: STM[Nothing, TSemaphore] = for {\n  tSem <- TSemaphore.make(2L)\n  _    <- tSem.acquire\n} yield tSem\n\ntSemaphoreAcq.commit\n```\n\n----------------------------------------\n\nTITLE: Defining a ZIO Service Module and Interface in Scala\nDESCRIPTION: This snippet defines the structure for a database service using the ZIO module pattern. It declares a `Database` module trait with an abstract `database` member, and a nested `Database.Service` trait defining the service's capabilities (`lookup`, `update`). Dependencies like `UserID` and `UserProfile` are assumed to be defined elsewhere.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nobject Database {\n  trait Service {\n    def lookup(id: UserID): Task[UserProfile]\n    def update(id: UserID, profile: UserProfile): Task[Unit]\n  }\n}\ntrait Database {\n  def database: Database.Service\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Manual Layer Construction for ZIO Dependency Graph in Scala\nDESCRIPTION: This snippet demonstrates how to manually construct a dependency graph for a ZIO application using composition operators. It combines multiple layers to provide the required DocRepo and UserRepo dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/building-dependency-graph.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval appLayer: URLayer[Any, DocRepo with UserRepo] =\n  ((Logging.live ++ Database.live ++ (Logging.live >>> BlobStorage.live)) >>> DocRepo.live) ++\n    ((Logging.live ++ Database.live) >>> UserRepo.live)\n    \nval res: ZIO[Any, Throwable, Unit] = myApp.provideLayer(appLayer)\n```\n\n----------------------------------------\n\nTITLE: Creating a Manual Reloadable Service with Reloadable.manual in Scala\nDESCRIPTION: Converting a standard ZLayer to a manually reloadable service using the Reloadable.manual constructor.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n  \n  val reloadable: ZLayer[Any, Nothing, Reloadable[Counter]] = \n    Reloadable.manual(live)\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a ZIO Counter Aspect to Effects in Scala\nDESCRIPTION: Demonstrates applying the previously defined `countAll` counter aspect to two separate `ZIO.unit` effects using the `@@` operator within a for-comprehension. This will increment the \"countAll\" counter twice when the `myApp` effect is executed, summing the increments from both annotated effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/counter.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval myApp = for {\n  _ <- ZIO.unit @@ countAll\n  _ <- ZIO.unit @@ countAll\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using FiberRef for Fiber-local Storage in Scala ZIO\nDESCRIPTION: Demonstrates how to create a FiberRef instance with an initial value of 0, set its value to 10, and then verify that the get operation returns the expected value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make[Int](0)\n  _        <- fiberRef.set(10)\n  v        <- fiberRef.get\n} yield v == 10\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.serviceWithZIO for Accessing Foo Service Member in Scala\nDESCRIPTION: Shows how to use ZIO.serviceWithZIO to create an accessor method for a service member that returns a ZIO effect. This example uses the Foo service with a foo method returning a Task.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Foo {\n  def foo(input: String): Task[Unit]\n}\n\nobject Foo {\n  // Accessor Method\n  def foo(input: String): ZIO[Foo, Throwable, Unit] =\n    ZIO.serviceWithZIO(_.foo(input))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Auto-Reloadable Service with Reloadable.auto in Scala\nDESCRIPTION: Converting a standard ZLayer to an automatically reloadable service using the Reloadable.auto constructor with a fixed schedule.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n  \n  val autoReloadable: ZLayer[Any, Nothing, Reloadable[Counter]] =\n    Reloadable.auto(live, Schedule.fixed(5.seconds))\n}\n```\n\n----------------------------------------\n\nTITLE: Running a ZIO Application with DateTimeLogger Implementation Scala\nDESCRIPTION: Demonstrates how to run the previously defined `myApp` ZIO application in Scala by providing the alternative `DateTimeLogger` implementation. It defines a `MainApp` extending `ZIOAppDefault` and uses the `provide` method with `DateTimeLogger.live` layer to satisfy the `Logging` dependency, showcasing easy swapping.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(DateTimeLogger.live)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Counter Constructors in Scala\nDESCRIPTION: Defines the `counter`, `counterDouble`, and `counterInt` methods within the `Metric` object for creating `Counter` metrics of type `Long`, `Double`, and `Int` respectively. These methods take a `name` string as input and are the primary constructors for counter metrics.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/counter.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Metric {\n  def counter(name: String): Counter[Long] = ???\n  def counterDouble(name: String): Counter[Double] = ???\n  def counterInt(name: String): Counter[Int] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming All Elements in a TArray with STM Effects in ZIO (Scala)\nDESCRIPTION: Applies an STM effect-producing transformation to every element in the TArray. The transformSTM method allows for more complex transactional transformations where the new values may depend on other STM operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformSTMTArray: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.transformSTM(a => STM.succeed(a * a))\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Converting Validation Errors to Either with ZIO.either (Scala)\nDESCRIPTION: This example demonstrates how to use validate combined with ZIO.either to expose errors on the success channel as Either. The resulting effect is a URIO that cannot fail, as all errors are now values. Dependencies include the previously defined validate function and the ZIO library. The input is an integer age, and the output is an unexceptional effect returning Either[AgeValidationException, Int].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval age: Int = ???\n\nval res: URIO[Any, Either[AgeValidationException, Int]] = validate(age).either\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Managed Resources\nDESCRIPTION: Shows how to combine multiple Managed resources using flatMap with proper acquisition and release handling for all resources.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/managed.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval managedQueue: Managed[Nothing, Queue[Int]] = Managed.make(Queue.unbounded[Int])(_.shutdown)\nval managedFile: Managed[IOException, File] = Managed.make(openFile(\"data.json\"))(closeFile)\n\nval combined: Managed[IOException, (Queue[Int], File)] = for {\n    queue <- managedQueue\n    file  <- managedFile\n} yield (queue, file)\n\nval usedCombinedRes: IO[IOException, Unit] = combined.use { case (queue, file) => doSomething(queue, file) }\n```\n\n----------------------------------------\n\nTITLE: Using ZIO reject Operator Example (Scala)\nDESCRIPTION: Demonstrates using the `reject` operator on a ZIO effect. It generates a random integer between 0 and 19 using `Random.nextIntBounded(20)`. The `reject` operator then checks the result: if it's an even number or the number 5, the effect fails with a descriptive error message; otherwise, the effect succeeds with the original odd number (excluding 5). The `.debug` operator logs the outcome (success or failure).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/rejecting-some-success-values.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval myApp: ZIO[Any, String, Int] =\n  Random\n    .nextIntBounded(20)\n    .reject {\n      case n if n % 2 == 0 => s\"even number rejected: $n\"\n      case 5               => \"number 5 was rejected\"\n    }\n    .debug\n```\n\n----------------------------------------\n\nTITLE: Retrying with Fallback using retryOrElse in ZIO for Scala\nDESCRIPTION: Demonstrates retrying an effect and specifying a fallback with retryOrElse. An effect will be retried per the schedule, and if still failing, a default value is supplied. Dependencies are ZIO, IO, Schedule, and matching types. The inputs are effect and fallback; outputs are the recovered or retried value. Useful for specifying custom failure recovery logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\n  openFile(\"primary.data\").retryOrElse(\n    Schedule.recurs(5), \n    (_, _) => ZIO.succeed(DefaultData))\n```\n\n----------------------------------------\n\nTITLE: Performing Field-Level Assertions with `hasField` in ZIO Test (Scala)\nDESCRIPTION: This test uses `assert` combined with the `hasField` assertion to check specific fields of a `User` object. It verifies that the user's age is greater than or equal to 18 and that the user's country (accessed via `u.address.country`) is not equal to \"USA\". The `&&` operator combines multiple assertions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntest(\"Rich checking\") {\n  assert(\n    User(\"Jonny\", 26, Address(\"Denmark\", \"Copenhagen\"))\n  )(\n    hasField(\"age\", (u:User) => u.age, isGreaterThanEqualTo(18)) &&\n    hasField(\"country\", (u:User) => u.address.country, not(equalTo(\"USA\")))\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ConfigMap from Directory in Scala k8s\nDESCRIPTION: Example of creating a Kubernetes ConfigMap by loading data from a directory using Scala k8s kubectl-style helpers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/scala-k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval config2 = ConfigMap(\n  data = DataMap.fromDir(new File(\"path/to/data-directory\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a TPromise in ZIO STM\nDESCRIPTION: Creates a TPromise instance that can be set exactly once. The TPromise is parameterized with String as the error type and Int as the success type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpromise.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromise: STM[Nothing, TPromise[String, Int]] = TPromise.make[String, Int]\n```\n\n----------------------------------------\n\nTITLE: Running the Application with Service Layers\nDESCRIPTION: Defines a ZIO application that runs the myApp by providing all required layers. The provide method composes and injects all service implementations into the application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(\n    ALive.layer,\n    BLive.layer,\n    CLive.layer\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Performing a Union Operation on TSets in Scala ZIO STM\nDESCRIPTION: Performs a union operation between two TSets, resulting in a set containing all elements from both sets. This modifies the first set (tSetA) with the union result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\n// unionTSet = {1, 2, 3, 4, 5, 6}\nval unionTSet: UIO[TSet[Int]] = (for {\n  tSetA <- TSet.make(1, 2, 3, 4)\n  tSetB <- TSet.make(3, 4, 5, 6)\n  _     <- tSetA.union(tSetB)\n} yield tSetA).commit\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Test Spec1 with Shared Counter in Scala\nDESCRIPTION: This snippet shows the implementation of Spec1, which extends SharedCounterSpec and includes a test that increments the shared Counter.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/sharing-layers-between-multiple-files.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nobject Spec1 extends SharedCounterSpec {\n  override def spec =\n    test(\"test1\") {\n      assertTrue(true)\n    } @@ TestAspect.after(Counter.inc)\n}\n```\n\n----------------------------------------\n\nTITLE: Failing on Left Values in Either Streams (Scala)\nDESCRIPTION: Shows how to convert a stream of Either values into a stream that fails when encountering the first Left value using rightOrFail. This allows treating Either values as potential stream failures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_77\n\nLANGUAGE: scala\nCODE:\n```\n// Stream of Either values that cannot fail\nval eitherStream: ZStream[Any, Nothing, Either[String, Int]] =\n  ZStream(Right(1), Right(2), Left(\"failed to parse\"), Right(4))\n\n// A Fails with the first emission of the left value\nval stream: ZStream[Any, String, Int] = eitherStream.rightOrFail(\"fail\")\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Either and Absolve Signatures in Scala\nDESCRIPTION: This snippet presents the trait signature for ZIO's either and absolve methods. The either method transforms a failing ZIO effect into a success channel effect containing Either, while absolve performs the opposite by flattening an Either error into ZIO's failure channel. Both methods are core to error handling in ZIO and require the CanFail and IsSubtypeOfOutput type evidence. Inputs and outputs are parameterized; additional implicit evidence may be required.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def either(implicit ev: CanFail[E]): URIO[R, Either[E, A]]\n  def absolve[E1 >: E, B](implicit ev: A IsSubtypeOfOutput Either[E1, B]): ZIO[R, E1, B]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Paginated ZStreams in Scala\nDESCRIPTION: Shows how to create paginated ZStreams using ZStream.paginate, which allows emission of values to end one step further than unfold.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval stream = ZStream.paginate(0) { s =>\n  s -> (if (s < 3) Some(s + 1) else None)\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Cancelable Blocking Operation with effectBlockingCancelable - Scala\nDESCRIPTION: Demonstrates use of effectBlockingCancelable to run a blocking operation (accepting a connection on ServerSocket) with an associated cancellation action that executes on interruption (closing the socket). Useful for integrating interruptible blocking IO with ZIO's resource-safety guarantees.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport java.net.ServerSocket\nimport zio.UIO\n\ndef accept(l: ServerSocket) =\n  effectBlockingCancelable(l.accept())(UIO.effectTotal(l.close()))\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Task to CompletableFuture - Scala\nDESCRIPTION: This function provides a way to turn a ZIO Task into a Java CompletableFuture in Scala. It leverages ZIO\\'s toCompletableFuture extension for direct integration with Java APIs expecting a CompletionStage. The input is any ZIO Task yielding type A, outputting a UIO producing a CompletableFuture[A] corresponding to CompletionStage semantics.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-java.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef taskToStage[A](task: Task[A]): UIO[CompletableFuture[A]] =\n    task.toCompletableFuture\n```\n\n----------------------------------------\n\nTITLE: Converting Future to ZIO Task using ZIO.fromFuture in Scala\nDESCRIPTION: Shows how to use `ZIO.fromFuture` to convert a Scala `Future[A]` into a `Task[A]` (i.e., `ZIO[Any, Throwable, A]`). It requires a function `ExecutionContext => Future[A]`, allowing ZIO to potentially manage the execution context where the `Future`'s callbacks are run. Any exception completing the `Future` results in a failed ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.concurrent.Future\n\nlazy val future = Future.successful(\"Hello!\")\n\nval zfuture: Task[String] =\n  ZIO.fromFuture { implicit ec =>\n    future.map(_ => \"Goodbye!\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Server Function Using Ref\nDESCRIPTION: A simple server implementation that continuously updates a Ref value by incrementing it. This demonstrates how a Ref can be used without needing to know it's a SubscriptionRef.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/subscriptionref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef server(ref: Ref[Long]): UIO[Nothing] =\n  ref.update(_ + 1).forever\n```\n\n----------------------------------------\n\nTITLE: Tagging a Metric Counter with MetricLabel in ZIO - Scala\nDESCRIPTION: This snippet demonstrates how to initialize a metric counter using ZIO's Metric API and append multiple MetricLabel instances to provide contextual metadata such as environment, method, endpoint, and zone. It requires the zio and zio.metrics dependencies. The function Metric.counter initializes a counter metric, and the tagged method attaches labels as key-value pairs using MetricLabel objects. Inputs include the metric name and label pairs; the output is a labeled metric ready for further use. This approach allows for rich, filterable metric streams in monitoring solutions. No runtime code is executed in this compile-only example, which assumes the necessary ZIO infrastructure is already in place.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/metriclabel.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\nimport zio.metrics._\\n\\nval counter = Metric.counter(\"http_requests\")\\n  .tagged(\\n    MetricLabel(\"env\", \"production\"),\\n    MetricLabel(\"method\", \"GET\"),\\n    MetricLabel(\"endpoint\", \"/api/users\"),\\n    MetricLabel(\"zone\", \"ap-northeast\"),\\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating Chunks from Collections in Scala\nDESCRIPTION: Creates Chunks from existing collections like List and Array.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval fromIterableChunk: Chunk[Int] = Chunk.fromIterable(List(1, 2, 3))\nval fromArrayChunk: Chunk[Int] = Chunk.fromArray(Array(1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Retrieving System Environment Variables with ZIO\nDESCRIPTION: This snippet demonstrates how to use the `env` function to retrieve an environment variable named 'USER'. It handles both cases where the variable exists or is not set.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/system.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console._\nimport zio.system._\nfor {\n  user <- env(\"USER\")\n  _ <- user match {\n    case Some(value) => putStr(s\"The USER env is: $value\")\n    case None => putStr(\"Oops! The USER env is not set\")\n  }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Combining Schedules with Union Operator\nDESCRIPTION: Demonstrates combining two schedules using the union (||) operator. Combines exponential backoff with fixed spacing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval expCapped = Schedule.exponential(100.milliseconds) || Schedule.spaced(1.second)\n```\n\n----------------------------------------\n\nTITLE: Mapping Errors and Causes in parseInt Effect - Scala\nDESCRIPTION: Demonstrates how to use mapError and mapErrorCause operators to transform the error information of a ZIO effect produced by the parseInt function. Requires zio._ and parseInt definition. parseInt returns a ZIO effect with NumberFormatException error, which is then mapped to a message string or made untraced. The key parameters are parseInt's input and the error mapping functions; outputs are new ZIO effects with adapted error types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] = ???\n\n// mapping the error of the original effect to its message\nval r1: ZIO[Any, String, Int] =\n  parseInt(\"five\")                // ZIO[Any, NumberFormatException, Int]\n    .mapError(e => e.getMessage)  // ZIO[Any, String, Int]\n\n// mapping the cause of the original effect to be untraced\nval r2 = parseInt(\"five\")         // ZIO[Any, NumberFormatException, Int]\n  .mapErrorCause(_.untraced)      // ZIO[Any, NumberFormatException, Int]\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Values in ZLayer Derivation\nDESCRIPTION: Demonstrates how to override pre-defined default values in ZLayer.derive by defining custom implicit values with higher priority.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/automatic-zlayer-derivation.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport ZLayer.Derive.Default\n\nclass Wheels(number: Int)\nobject Wheels {\n  implicit val defaultWheels: Default.WithContext[Any, Nothing, Wheels] =\n    Default.succeed(new Wheels(4))\n}\nclass Car(wheels: Wheels)\n\nval carLayer1: ZLayer[Any, Nothing, Car] = ZLayer.derive[Car] // wheels.number == 4\nval carLayer2: ZLayer[Wheels, Nothing, Car] = locally {\n  // The default instance is discarded\n  implicit val newWheels: Default.WithContext[Wheels, Nothing, Wheels] =\n     Default.service[Wheels]\n\n  ZLayer.derive[Car]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Auto-Reloadable Service with ZLayer Extension Method in Scala\nDESCRIPTION: Converting a standard ZLayer to an automatically reloadable service using the ZLayer#reloadableAuto extension method with a fixed schedule.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n  \n  val autoReloadable: ZLayer[Any, Nothing, Reloadable[Counter]] =\n    live.reloadableAuto(Schedule.fixed(5.seconds))\n}\n```\n\n----------------------------------------\n\nTITLE: Recovering from Specific Causes with catchSomeCause in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates the use of ZStream#catchSomeCause to recover from specific causes of failures. The example shows how to handle a specific die message by switching to an alternative stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Cause._\nimport zio.stream._\n\nval s1 = ZStream(1, 2, 3) ++ ZStream.dieMessage(\"Oh! Boom!\") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\nval stream = s1.catchSomeCause { case Die(value, _) => s2 }\n```\n\n----------------------------------------\n\nTITLE: Defining THub Interface in Scala\nDESCRIPTION: Core trait definition for THub showing the fundamental publish and subscribe operations. The publish method takes a value of type A and returns a Boolean wrapped in USTM, while subscribe returns a TDequeue wrapped in USTM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/thub.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait THub[A] {\n  def publish(a: A): USTM[Boolean]\n  def subscribe: USTM[TDequeue[B]]\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#validate for Error Accumulation in Scala\nDESCRIPTION: This snippet demonstrates how ZIO#validate accumulates errors when zipping effects, combining causes with Cause.Then.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/error-accumulation.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1 = ZIO.succeed(1).debug\n  val f2 = ZIO.succeed(2) *> ZIO.fail(\"Oh uh!\")\n  val f3 = ZIO.succeed(3).debug\n  val f4 = ZIO.succeed(4) *> ZIO.fail(\"Oh error!\")\n  val f5 = ZIO.succeed(5).debug\n\n  val myApp: ZIO[Any, String, (Int, Int, Int)] =\n    f1 validate f2 validate f3 validate f4 validate f5\n\n  def run = myApp.cause.debug.uncause\n}\n```\n\n----------------------------------------\n\nTITLE: Handling All Error Causes with catchAllCause - Scala\nDESCRIPTION: Implements detailed error cause matching to distinguish and handle various error types, from failures and defects to fiber interruptions and composed causes. Outputs debug messages according to the precise error condition. The handler inspects all subtypes of Cause[E], making it suitable for advanced effect recovery logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval exceptionalEffect = ZIO.attempt(???)\n\nexceptionalEffect.catchAllCause {\n  case Cause.Empty =>\n    ZIO.debug(\"no error caught\")\n  case Cause.Fail(value, _) =>\n    ZIO.debug(s\"a failure caught: $value\")\n  case Cause.Die(value, _) =>\n    ZIO.debug(s\"a defect caught: $value\")\n  case Cause.Interrupt(fiberId, _) =>\n    ZIO.debug(s\"a fiber interruption caught with the fiber id: $fiberId\")\n  case Cause.Stackless(cause: Cause.Die, _) =>\n    ZIO.debug(s\"a stackless defect caught: ${cause.value}\")\n  case Cause.Stackless(cause: Cause[_], _) =>\n    ZIO.debug(s\"an unknown stackless defect caught: ${cause.squashWith(identity)}\")\n  case Cause.Then(left, right) =>\n    ZIO.debug(s\"two consequence causes caught\")\n  case Cause.Both(left, right) =>\n    ZIO.debug(s\"two parallel causes caught\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZRef Type Parameters in Scala\nDESCRIPTION: Type signature for ZRef showing its polymorphic nature with error types EA and EB, and value types A and B. The reference supports atomic operations when error and value types are unified.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/zref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nZRef[EA, EB, A, B]\n```\n\n----------------------------------------\n\nTITLE: Acquiring and Releasing Multiple Permits with TSemaphore\nDESCRIPTION: Demonstrates how to acquire and release multiple permits at once using acquireN and releaseN methods. This example creates a semaphore with 3 permits, acquires all 3, checks that none are available, and then releases all 3 permits.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tsemaphore.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreAcquireNReleaseN: STM[Nothing, Boolean] = for {\n  sem <- TSemaphore.make(3L)\n  _   <- sem.acquireN(3L)\n  cap <- sem.available \n  _   <- sem.releaseN(3L)\n} yield cap == 0\n\ntSemaphoreAcquireNReleaseN.commit\n```\n\n----------------------------------------\n\nTITLE: Customizing ZIO 2.x Runtime using Layers in Scala\nDESCRIPTION: This Scala code shows the ZIO 2.x approach to runtime customization using Layers within a `ZIOAppDefault`. Instead of manipulating a `Platform` object, it uses the `provide` method with a runtime customization layer (`Runtime.setExecutor(customExecutor)`) to configure the environment for running the application logic (`myApp`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_43\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val customExecutor: zio.Executor = ???\n\n  val myApp = \n    ZIO.debug(\"Application started\")\n\n  def run =\n    myApp.provide(\n      Runtime.setExecutor(customExecutor)\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Racing Effects in ZIO (Scala)\nDESCRIPTION: Shows how to race multiple effects in parallel using ZIO's `race` method. The first successful result is returned.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  winner <- ZIO.succeed(\"Hello\").race(ZIO.succeed(\"Goodbye\"))\n} yield winner\n```\n\n----------------------------------------\n\nTITLE: Read File with Typed Error Handling - Scala\nDESCRIPTION: This code illustrates a typed file-reading ZIO effect, refining only IOException failures. Dependencies include zio and java.io. The key parameter is the file path, producing an effect that attempts to read the file and refines thrown errors to IOExceptions. The output is a ZIO effect that may fail with an IOException or succeed with the file contents as Array[Byte].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.{ FileNotFoundException, IOException }\n\ndef readFile(s: String): ZIO[Any, IOException, Array[Byte]] =\n  ZIO.attempt(???).refineToOrDie[IOException]\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#timeoutTo for Custom Timeout Results in Scala\nDESCRIPTION: Introduces the `ZIO#timeoutTo` operator, which allows specifying custom values for both success and timeout scenarios. The example defines a `delayedNextInt` effect (2-second delay) and applies `timeoutTo` with a 1-second timeout, showing how to map the result to `Option[Int]`, `Either[String, Int]`, or `Int` depending on whether the timeout occurs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/timing-out.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent\nimport zio._\n\nval delayedNextInt: ZIO[Any, Nothing, Int] =\n  Random.nextIntBounded(10).delay(2.second)\n\nval r1: ZIO[Any, Nothing, Option[Int]] =\n  delayedNextInt.timeoutTo(None)(Some(_))(1.seconds)\n\nval r2: ZIO[Any, Nothing, Either[String, Int]] =\n  delayedNextInt.timeoutTo(Left(\"timeout\"))(Right(_))(1.seconds)\n\nval r3: ZIO[Any, Nothing, Int] =\n  delayedNextInt.timeoutTo(-1)(identity)(1.seconds)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a SubscriptionRef with make Constructor\nDESCRIPTION: The make constructor for SubscriptionRef which creates a new instance with the specified initial value. The actual implementation is omitted in this snippet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/subscriptionref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject SubscriptionRef {\n  def make[A](a: A): UIO[SubscriptionRef[A]] =\n    ???\n}\n```\n\n----------------------------------------\n\nTITLE: Folding Operations with ZSink\nDESCRIPTION: Demonstrates various folding operations including basic fold, weighted fold, and fold until operations. These allow for accumulating stream elements with different termination conditions and grouping strategies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/creating-sinks.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nZSink.foldLeft[Int, Int](0)(_ + _)\n\nZStream.iterate(0)(_ + 1).run(\n  ZSink.fold(0)(sum => sum <= 10)((acc, n: Int) => acc + n)\n)\n\nZStream(1, 2, 3, 4).run(ZSink.foldLeft[Int, Int](0)(_ + _))\n```\n\n----------------------------------------\n\nTITLE: Partial Pattern Matching with foldCauseZIO and Handling MatchError - Scala\nDESCRIPTION: Demonstrates how non-exhaustive handling of causes with foldCauseZIO can lead to MatchError if not all cause variants are handled. The code prepares an exceptional effect which is interrupted, then only matches Fail and Die, omitting Interrupt. This is useful for understanding the necessity of exhaustivity in pattern matching cause types. Shows output stack trace for reference.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  val exceptionalEffect: ZIO[Any, Throwable, Unit] = ZIO.interrupt\n\n  val myApp: ZIO[Any, IOException, Unit] =\n    exceptionalEffect.foldCauseZIO(\n      failure = {\n        case Cause.Fail(value, _) => ZIO.debug(s\"failure: $value\")\n        case Cause.Die(value, _) => ZIO.debug(s\"cause: ${value.toString}\")\n        // case Cause.Interrupt(failure, _) => ZIO.debug(s\"${failure.threadName} interrupted!\")\n      },\n      success = succeed => ZIO.debug(s\"succeeded with $succeed value\")\n    )\n\n  def run = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Regional Parallelism with ZIO FiberRef in Scala\nDESCRIPTION: This snippet demonstrates how `ZIO.withParallelism` uses `FiberRef` internally to control the parallelism factor for a specific code region. An outer effect runs with unbounded parallelism, while an inner effect (`myJob(\"bar\")`) is constrained to a parallelism level of 1 using `ZIO.withParallelism(1)`. After exiting the region, the parallelism setting reverts.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\nobject MainApp extends ZIOAppDefault {\n  def myJob(name: String) =\n    ZIO.foreachParDiscard(1 to 3)(i =>\n      ZIO.debug(s\"The $name-$i job started\") *> ZIO.sleep(2.second)\n    )\n\n  def run =\n    ZIO.withParallelismUnbounded(\n      for {\n        _ <- myJob(\"foo\")\n        _ <- ZIO.debug(\"------------------\")\n        _ <- ZIO.withParallelism(1)(myJob(\"bar\"))\n        _ <- ZIO.debug(\"------------------\")\n        _ <- myJob(\"baz\")\n      } yield ()\n    )\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Merging Error Channel into Success Channel with ZIO.merge in Scala\nDESCRIPTION: This snippet demonstrates how to use ZIO's merge method to combine the error channel into the success channel of a ZIO effect, effectively converting a ZIO that may fail with a String into one that only succeeds, with the error value mapped into the success channel. It requires the ZIO library and works with basic ZIO effect construction. The key parameter is the failure message string. Input is a failing ZIO effect, and output is a merged ZIO effect with error represented in the success channel. Works only when error and success channels can be reconciled into a common supertype.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/merging-the-error-channel-into-the-success-channel.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\\n\\nval merged : ZIO[Any, Nothing, String] =\\n  ZIO.fail(\\\"Oh uh!\\\") // ZIO[Any, String, Nothing]\\n    .merge           // ZIO[Any, Nothing, String]\n```\n\n----------------------------------------\n\nTITLE: Converting Scoped ZIO to Cats Effect Resource (Scala)\nDESCRIPTION: Illustrates creating a Cats Effect Resource from a scoped ZIO value using Resource.scoped. This allows migration of ZIO resource management into the Cats Effect ecosystem, enabling typical resource usage and safe release. Dependencies include zio.interop.catz, cats.effect.IO, and the resource functions. The key parameter is a ZIO-producing function of an InputStream, and the output is an IO Resource of InputStream managed by Cats Effect. It showcases round-trip interoperability for effectful resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.catz._\n\nobject ZManagedToResource extends cats.effect.IOApp {\n  implicit val zioRuntime: zio.Runtime[Any] = zio.Runtime.default\n\n  val resource: cats.effect.Resource[cats.effect.IO, java.io.InputStream] = {\n    val scopedZIO: ZIO[Any with Scope, Throwable, InputStream]= ZIO\n      .fromAutoCloseable(\n        zio.ZIO.attempt(\n          java.nio.file.Files.newInputStream(\n            java.nio.file.Paths.get(\"crawl.log\")\n          )\n        )\n      )\n    \n    Resource.scoped[IO, Any](scopedZIO)\n  }\n\n  val effect: cats.effect.IO[Unit] =\n    resource\n      .use { is =>\n        cats.effect.IO.delay(is.readAllBytes())\n      }\n      .flatMap(bytes =>\n        cats.effect.IO.delay(\n          println(s\"file length: ${bytes.length}\")\n        )\n      )\n\n  override def run(args: List[String]): cats.effect.IO[cats.effect.ExitCode] =\n    effect.as(cats.effect.ExitCode.Success)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Test Spec with ZTestJUnitRunner Annotation in Scala\nDESCRIPTION: This example shows how to create a ZIO Test specification as a Scala class annotated with @RunWith(classOf[ZTestJUnitRunner]). This approach allows running the spec as a JUnit test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/junit-integration.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport org.junit.runner.RunWith\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.junit.ZTestJUnitRunner\n\n@RunWith(classOf[ZTestJUnitRunner])\nclass MySpec extends ZIOSpecDefault {\n  def spec = suite(\"MySpec\")(\n    test(\"test\") {\n      for {\n        _ <- ZIO.unit\n      } yield assertCompletes\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Managing State with Ref in ZIO\nDESCRIPTION: Example of rewriting the recursive state management using ZIO's Ref data type. This approach is more concise and allows state to be shared between multiple fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/global-shared-state.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef getNames: ZIO[Any, String, List[String]] =\n  Ref.make(List.empty[String])\n    .flatMap { ref =>\n      Console\n        .readLine(\"Please enter a name or 'q' to exit: \")\n        .orDie\n        .repeatWhileZIO {\n          case \"q\" => ZIO.succeed(false)\n          case name => ref.update(_ appended name).as(true)\n        } *> ref.get\n    }\n```\n\n----------------------------------------\n\nTITLE: Custom Runtime Creation\nDESCRIPTION: Examples of creating custom Runtime instances with specific service implementations\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval testableRuntime = Runtime(\n  Has.allOf[Logging, Email](LoggingLive(), EmailMock()),\n  Platform.default\n)\n```\n\n----------------------------------------\n\nTITLE: ZIO 2.x Simplified Services Example\nDESCRIPTION: Example showing how the same functionality is implemented in ZIO 2.x without environment requirements for default services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nobject MainApp extends App {\n  val myApp: ZIO[Any, IOException, Unit] =\n    for {\n      rnd <- Random.nextIntBounded(100)\n      _   <- Console.printLine(s\"Random number: $rnd\")\n      _   <- Clock.sleep(1.second)\n    } yield ()\n\n  def run = myApp.forever\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Multiple Instances of a Service in ZIO Scala\nDESCRIPTION: This snippet shows how to access a specific instance of a service when multiple instances are provided in the ZIO environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval database: URIO[Map[String, Database], Option[Database]] =\n  ZIO.serviceAt[Database](\"inmemory\")\n```\n\n----------------------------------------\n\nTITLE: Wrapping Blocking Synchronous Side Effect with effectBlocking - Scala\nDESCRIPTION: Shows how to wrap a blocking operation (Thread.sleep) in a ZIO effect using effectBlocking, which ensures blocking code runs on a dedicated thread pool to avoid thread starvation. Use for safe integration of blocking APIs. Output is a ZIO effect representing the blocking call.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.blocking._\n\nval sleeping =\n  effectBlocking(Thread.sleep(Long.MaxValue))\n```\n\n----------------------------------------\n\nTITLE: Debugging ZLayer Construction with ZLayer.Debug\nDESCRIPTION: This snippet shows how to use ZLayer.Debug.tree and ZLayer.Debug.mermaid for debugging layer construction. It demonstrates including these debug layers in the layer provision.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/automatic-layer-construction.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp.provide(\n      Cake.live,\n      Chocolate.live,\n      Flour.live,\n      Spoon.live,\n      ZLayer.Debug.tree\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Multiple Services from ZIO Environment in Scala\nDESCRIPTION: Shows how to access multiple services (Foo, Bar, Baz) from the ZIO environment using ZIO.service for each service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Foo\ntrait Bar\ntrait Baz\n\nfor {\n  foo <- ZIO.service[Foo]  \n  bar <- ZIO.service[Bar]\n  bax <- ZIO.service[Baz]\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout with Automatic Cancellation in Scala using ZIO\nDESCRIPTION: Demonstrates how to add a timeout to a ZIO workflow, ensuring that all running tasks are automatically canceled when the timeout is reached. This helps in efficient resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval timedOut = aggregated.timeout(10.seconds)\n```\n\n----------------------------------------\n\nTITLE: Converting CompletionStage to ZIO Fiber\nDESCRIPTION: Shows how to convert a Java CompletionStage to a ZIO Fiber, creating a synthetic fiber without identity.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-java.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef stageToFiber[A](stage: => CompletionStage[A]): Fiber[Throwable, A] = \n  Fiber.fromCompletionStage(future)\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Read Operations in Scala\nDESCRIPTION: Shows how to compose multiple read operations using the *> operator to read sequential values from the input port. Each example demonstrates reading a different number of values from a channel that has written multiple values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/creating-channels.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nval read = ZChannel.read[Int] \n\n(ZChannel.writeAll(1, 2, 3) >>> (read *> read)).runCollect.debug\n// Output: (Chunk(),2) \n\n(ZChannel.writeAll(1, 2, 3) >>> (read *> read *> read)).runCollect.debug\n// Output: (Chunk(),3) \n```\n\n----------------------------------------\n\nTITLE: Opening File with Scope in Scala\nDESCRIPTION: Example of using Scope to open a file, demonstrating how resource management is handled in ZIO 2.0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_65\n\nLANGUAGE: scala\nCODE:\n```\ndef openFile(name: String): ZIO[Scope, IOException, FileInputStream] =\n  ZIO.acquireRelease(acquire)(release)\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Streams Dependencies in SBT\nDESCRIPTION: SBT configuration to add ZIO core and ZIO Streams libraries as test dependencies. The version numbers are dynamically inserted based on the current ZIO build version.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += Seq(\n  \"dev.zio\" %% \"zio\"         % \"${zio.BuildInfo.version.split('+').head}\" % Test\n  \"dev.zio\" %% \"zio-streams\" % \"${zio.BuildInfo.version.split('+').head}\" % Test\n)\n```\n\n----------------------------------------\n\nTITLE: Stream Processing with Foreach\nDESCRIPTION: Shows how to process stream elements using the foreach method, which applies a callback function to each element in the stream. Demonstrates printing each element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/consuming-streams.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nZStream(1, 2, 3).foreach(printLine(_))\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retryWhileEquals for Specific Error Matching in Scala\nDESCRIPTION: Shows the `retryWhileEquals` method, a shorthand for `retryWhile` with an equality check. The `remoteService` effect is retried as long as the error equals `TemporarilyUnavailable`. Requires the `remoteService` definition and `TemporarilyUnavailable` error type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nremoteService.retryWhileEquals(TemporarilyUnavailable)\n```\n\n----------------------------------------\n\nTITLE: Extracting Right or Failing with Mapping from ZIO[R, E, Either[B, A]] in Scala\nDESCRIPTION: Transforms a `ZIO[R, E, Either[B, A]]` into a `ZIO[R, E, A]`. If the resulting `Either` is `Right(a)`, the effect succeeds with `a`. If it's `Left(b)`, the function `f` is used to map the value `b` to an error of type `E`, and the effect fails with that mapped error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfrom.rightOrFailWith(f)\n```\n\n----------------------------------------\n\nTITLE: Polling Queue Head in Scala\nDESCRIPTION: Demonstrates non-blocking polling of a queue using poll, which returns Option[Int]. Adds two elements and inspects the front without removing if empty. Best for cases where immediate result is required.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval polled: UIO[Option[Int]] = for {\\n  queue <- Queue.bounded[Int](100)\\n  _ <- queue.offer(10)\\n  _ <- queue.offer(20)\\n  head <- queue.poll\\n} yield head\\n\n```\n\n----------------------------------------\n\nTITLE: Extended Scope Management Example in Scala\nDESCRIPTION: Demonstrates practical scope management with multiple resources and finalizers, showing resource acquisition and release ordering.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject ExtendingScopesExample extends ZIOAppDefault {\n  val resource1: ZIO[Scope, Nothing, Unit] =\n    ZIO.acquireRelease(ZIO.debug(\"Acquiring the resource 1\"))(_ =>\n      ZIO.debug(\"Releasing the resource one\") *> ZIO.sleep(5.seconds)\n    )\n  val resource2: ZIO[Scope, Nothing, Unit] =\n    ZIO.acquireRelease(ZIO.debug(\"Acquiring the resource 2\"))(_ =>\n      ZIO.debug(\"Releasing the resource two\") *> ZIO.sleep(3.seconds)\n    )\n\n  def run =\n    ZIO.scoped(\n      for {\n        scope <- ZIO.scope\n        _     <- ZIO.debug(\"Entering the main scope!\")\n        _     <- scope.addFinalizer(ZIO.debug(\"Releasing the main resource!\") *> ZIO.sleep(2.seconds))\n        _     <- scope.extend(resource1)\n        _     <- scope.extend(resource2)\n        _     <- ZIO.debug(\"Leaving scope!\")\n      } yield ()\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Task Type Alias in Scala\nDESCRIPTION: This snippet shows how to define a type alias for ZIO's Task, which is equivalent to Monix's Task[A]. It demonstrates that ZIO's Task is an alias for ZIO[Any, Throwable, A].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-monix.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nTask[A]\n```\n\n----------------------------------------\n\nTITLE: Handling Pass-through Dependencies in ZIO\nDESCRIPTION: Demonstrates how to use the >+> operator to pass through all dependencies to the final layer, making them available in the layer's output. This approach exposes internal dependencies to the caller if needed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/examples.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  // passthrough all dependencies\n  val layers: ZLayer[Any, Throwable, Database & BlobStorage & Cache & DocumentRepo & UserRepo] =\n    DatabaseLive.layer >+>\n      BlobStorageLive.layer >+>\n      InmemoryCache.layer >+>\n      DocumentRepoLive.layer >+>\n      UserRepoLive.layer\n\n  // providing all passthrough dependencies to the ZIO application\n  def run = myApp.provideLayer(layers)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZIO 1.x Environment Compiler Errors in Scala\nDESCRIPTION: Example of ZIO 1.x application with missing layers, showing complex compiler errors when requirements are not met.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_54\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 1.x\nimport zio._\n\ncase class Config(host: String, port: Int)\n\ntrait Logger {\n  def log(line: Any): Task[Unit]\n}\n\nobject MainApp extends App {\n  val myApp =\n    for {\n      config <- ZIO.service[Config]\n      logger <- ZIO.service[Logger]\n      _ <- logger.log(s\"Application started with the following config: $config\")\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Account Withdraw Function\nDESCRIPTION: Simple implementation of account withdraw operation using Ref.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef withdraw(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ - amount)\n```\n\n----------------------------------------\n\nTITLE: Accessing Specific Fields from a ZIO Environment in Scala\nDESCRIPTION: This snippet shows how to access specific fields (`server`, `port`) from a case class (`Config`) provided as the ZIO environment using `ZIO.access`. It constructs a string containing the configuration details. The resulting effect requires a `Config` environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nfinal case class Config(server: String, port: Int)\n\nval configString: URIO[Config, String] = \n  for {\n    server <- ZIO.access[Config](_.server)\n    port   <- ZIO.access[Config](_.port)\n  } yield s\"Server: $server, port: $port\"\n```\n```\n\n----------------------------------------\n\nTITLE: Safe Lock Usage with Scope in Scala\nDESCRIPTION: Demonstrates safer lock usage using readLock and writeLock methods with automatic resource management via Scope.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/treentrantlock.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Console._\nimport zio.stm._\n\nval saferProgram: UIO[Unit] = for {\n  lock <- TReentrantLock.make.commit\n  f1   <- ZIO.scoped(lock.readLock *> ZIO.sleep(5.seconds) *> printLine(\"Powering down\").orDie).fork\n  f2   <- ZIO.scoped(lock.readLock *> lock.writeLock *> printLine(\"Huzzah, writes are mine\").orDie).fork\n  _    <- (f1 zip f2).join\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Fully Polymorphic Accessor Methods with TagKK\nDESCRIPTION: Enhanced accessor methods for the KeyValueStore that make the effect type F fully polymorphic using TagKK context bound. This allows the service to work with any bifunctor effect type, not just ZIO's IO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject KeyValueStore {\n  def get[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =\n    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.get(key))\n\n  def set[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K, value: V): ZIO[KeyValueStore[K, V, E, F], Nothing, F[E, V]] =\n    ZIO.serviceWith[KeyValueStore[K, V, E, F]](_.set(key, value))\n\n  def remove[K: Tag, V: Tag, E: Tag, F[_, _] : TagKK](key: K): ZIO[KeyValueStore[K, V, E, F], E, Unit] =\n    ZIO.serviceWith(_.remove(key))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Unbounded TQueue in Scala using ZIO STM\nDESCRIPTION: Creates an empty unbounded TQueue that can grow without a predefined limit using the ZIO STM library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueUnbounded: STM[Nothing, TQueue[Int]] = TQueue.unbounded[Int]\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci Function in Scala\nDESCRIPTION: A tail-recursive implementation of the Fibonacci sequence function in Scala, which calculates the nth Fibonacci number efficiently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/debug-a-zio-application.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef fib(n: Int): Int = {\n  @annotation.tailrec\n  def go(n: Int, a: Int, b: Int): Int =\n    if (n == 0) a\n    else go(n - 1, b, a + b) \n  go(n, 0, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Values with ZIO Random\nDESCRIPTION: Demonstrates how to generate different types of random values using ZIO Random service. Shows generation of random integers, printable characters, and doubles within a specified range using for-comprehension.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/random.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.random._\nimport zio.console._\nfor {\n  randomInt <- nextInt\n  _ <- putStrLn(s\"A random Int: $randomInt\")\n  randomChar <- nextPrintableChar\n  _ <- putStrLn(s\"A random Char: $randomChar\")\n  randomDouble <- nextDoubleBetween(1.0, 5.0)\n  _ <- putStrLn(s\"A random double between 1.0 and 5.0: $randomDouble\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Parallel ZIO Layer Initialization Example\nDESCRIPTION: Demonstration of parallel initialization of multiple layers in ZIO. Shows how ZLayer automatically handles parallel execution of independent components A and B in the dependency graph.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class A(a: Int)\nobject A {\n  val layer: ZLayer[Any, Nothing, A] =\n    ZLayer.fromZIO {\n      for {\n        _ <- ZIO.debug(\"Initializing A\")\n        _ <- ZIO.sleep(3.seconds)\n        _ <- ZIO.debug(\"Initialized A\")\n      } yield A(1)\n    }\n}\n\ncase class B(b: Int)\nobject B {\n  val layer: ZLayer[Any, Nothing, B] =\n    ZLayer.fromZIO {\n      for {\n        _ <- ZIO.debug(\"Initializing B\")\n        _ <- ZIO.sleep(2.seconds)\n        _ <- ZIO.debug(\"Initialized B\")\n      } yield B(2)\n    }\n}\n\nobject ZIOApp extends ZIOAppDefault {\n  val myApp: ZIO[A with B, Nothing, Int] =\n    for {\n      a <- ZIO.serviceWith[A](_.a)\n      b <- ZIO.serviceWith[B](_.b)\n    } yield a + b\n\n  def run =\n    myApp\n      .debug(\"result\")\n      .provide(A.layer, B.layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Constant Increment ZIO Counter in Scala\nDESCRIPTION: Creates a `Counter` metric named \"countAll\" using `Metric.counter`. The `.fromConst(1)` method transforms it into an aspect that increments the counter by a fixed value of `1` each time the ZIO effect it's applied to is executed. Requires importing `zio._` and `zio.metrics._`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/counter.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.metrics._\nval countAll = Metric.counter(\"countAll\").fromConst(1)\n```\n\n----------------------------------------\n\nTITLE: Declarative Encoding for Effect System in Scala\nDESCRIPTION: Implements an effect system using declarative encoding, separating the definition of effects from their interpretation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/functional-design-patterns.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait IO[+A] { self =>\n  def map[B](f: A => B): IO[B] = flatMap(f andThen IO.succeedNow)\n\n  def flatMap[B](f: A => IO[B]): IO[B] = IO.FlatMap(self, f)\n\n  def unsafeRunSync(): A = {\n    type Cont = Any => IO[Any]\n\n    def run(stack: List[Cont], currentIO: IO[Any]): A = {\n      def continue(value: Any) =\n        stack match {\n          case ::(cont, next) => run(next, cont(value))\n          case Nil            => value.asInstanceOf[A]\n        }\n\n      currentIO match {\n        case IO.SucceedNow(value) => continue(value)\n        case IO.Succeed(thunk)    => continue(thunk())\n        case IO.FlatMap(io, cont) => run(stack appended cont, io)\n      }\n    }\n\n    run(stack = Nil, currentIO = self)\n  }\n}\n\nobject IO {\n  def succeedNow[A](value: A): IO[A] = IO.SucceedNow(value)\n  def succeed[A](value: => A): IO[A] = IO.Succeed(() => value)\n\n  final case class SucceedNow[A](value: A)                    extends IO[A]\n  final case class Succeed[A](thunk: () => A)                 extends IO[A]\n  final case class FlatMap[A, B](io: IO[A], cont: A => IO[B]) extends IO[B]\n}\n```\n\n----------------------------------------\n\nTITLE: Folding Elements of a TArray with STM Effects in ZIO (Scala)\nDESCRIPTION: Combines all elements of a TArray using a binary operator that produces STM effects. The foldSTM method allows for more complex folding operations where the combination may depend on other transactional operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldSTMTArray: UIO[Int] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  sum    <- tArray.foldSTM(0)((acc, el) => STM.succeed(acc + el))\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: STM-based Deposit Implementation\nDESCRIPTION: Atomic deposit implementation using STM and TRef.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef deposit(accountBalance: TRef[Int], amount: Int): STM[Nothing, Unit] =\n  accountBalance.update(_ + amount)\n```\n\n----------------------------------------\n\nTITLE: Focusing on Left/Right Sides of Either Values in ZIO Scala\nDESCRIPTION: Illustrates manipulating `ZIO[R, E, Either[L, R]]` effects. `ZIO#left` focuses on the `Left` value, producing `ZIO[R, Either[E, R], L]` by moving the `Right` case to the error channel. `ZIO#unleft` reverses this. Similarly, `ZIO#right` focuses on the `Right` value (`ZIO[R, Either[L, E], R]`), moving the `Left` case to the error channel, and `ZIO#unright` reverses that operation. Requires the `zio` import and an initial ZIO effect yielding an Either.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/zooming-in-on-nested-values.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval eitherEffect: ZIO[Any, Exception, Either[String, Int]] = ???\n\neitherEffect // ZIO[Any, Exception, Either[String, Int]]\n  .left      // ZIO[Any, Either[Exception, Int], String]\n  .unleft    // ZIO[Any, Exception, Either[String, Int]]\n\neitherEffect // ZIO[Any, Exception, Either[String, Int]]\n  .right     // ZIO[Any, Either[String, Exception], Int]\n  .unright   // ZIO[Any, Exception, Either[String, Int]]\n```\n\n----------------------------------------\n\nTITLE: Defining ServiceReloader Trait in Scala\nDESCRIPTION: This code defines the ServiceReloader trait, which provides methods for registering and reloading services dynamically.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntrait ServiceReloader {\n  def register[A: Tag: IsReloadable](serviceLayer: ZLayer[Any, Any, A]): IO[ServiceReloader.Error, A]\n  def reload[A: Tag]: IO[ServiceReloader.Error, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ZLayers from Service Implementations in Scala ZIO\nDESCRIPTION: Example of lifting service implementations into ZLayers. ZLayer automatically wraps the services in the Has data type, enabling composition of services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nobject LoggingLive {\n  val layer: URLayer[Any, Has[Logging]] =\n    (LoggingLive.apply _).toLayer\n}\n\nobject RandomIntLive {\n  val layer: URLayer[Any, Has[RandomInt]] =\n    (RandomIntLive.apply _).toLayer\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Expectations for Polymorphic Methods\nDESCRIPTION: Shows how to create expectations for polymorphic methods by specifying concrete types with the 'of' combinator. Demonstrates both success and failure cases for different type combinations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport PolyExampleMock._\n\nval exp06 = PolyInput.of[String](equalTo(\"foo\"), value(\"bar\"))\nval exp07 = PolyInput.of[Int](equalTo(42), failure(new Exception))\nval exp08 = PolyInput.of[Long](equalTo(42L), value(\"baz\"))\n\nval exp09 = PolyAll.of[Int, Throwable, String](equalTo(42), value(\"foo\"))\nval exp10 = PolyAll.of[Int, Throwable, String](equalTo(42), failure(new Exception))\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty TSet in Scala ZIO STM\nDESCRIPTION: Creates an empty TSet that can store elements of type Int. This operation is performed within an STM transaction context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval emptyTSet: STM[Nothing, TSet[Int]] = TSet.empty[Int]\n```\n\n----------------------------------------\n\nTITLE: Defining SubscriptionRef Trait in Scala\nDESCRIPTION: Definition of the SubscriptionRef trait which extends Ref.Synchronized and adds a changes method that returns a ZStream of all value changes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/subscriptionref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\ntrait SubscriptionRef[A] extends Ref.Synchronized[A] {\n  def changes: ZStream[Any, Nothing, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Tapping Operations in ZIO Streams\nDESCRIPTION: Demonstrates how to observe stream elements using tap operation without affecting the stream's content or type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZStream[Console, IOException, Int] =\n  ZStream(1, 2, 3)\n    .tap(x => putStrLn(s\"before mapping: $x\"))\n    .map(_ * 2)\n    .tap(x => putStrLn(s\"after mapping: $x\"))\n```\n\n----------------------------------------\n\nTITLE: Simple Value Decoding Examples\nDESCRIPTION: Test cases demonstrating decoding of primitive types like String and Int\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.json._\n\ntest(\"decode from string\") {\n  val json    = \"\\\"John Doe\\\"\"\n  val decoded = JsonDecoder[String].decodeJson(json)\n\n  assertTrue(decoded == Right(\"John Doe\"))\n}\n\ntest(\"decode from int\") {\n  val json    = \"123\"\n  val decoded = JsonDecoder[Int].decodeJson(json)\n\n  assertTrue(decoded == Right(123))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Class\nDESCRIPTION: Shows the basic structure of implementing the DocRepo trait with a concrete class.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/service-pattern.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfinal class DocRepoLive() extends DocRepo {\n  override def get(id: String): ZIO[Any, Throwable, Doc] = ???\n\n  override def save(document: Doc): ZIO[Any, Throwable, String] = ???\n\n  override def delete(id: String): ZIO[Any, Throwable, Unit] = ???\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Error Recovery with catchAll in ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#catchAll to recover from stream failures by choosing different recovery streams based on the error value. This allows for more granular error handling than simple orElse.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_69\n\nLANGUAGE: scala\nCODE:\n```\nval first =\n  ZStream(1, 2, 3) ++\n    ZStream.fail(\"Uh Oh!\") ++\n    ZStream(4, 5) ++\n    ZStream.fail(\"Ouch\")\n\nval second = ZStream(6, 7, 8)\nval third = ZStream(9, 10, 11)\n\nval stream = first.catchAll {\n  case \"Uh Oh!\" => second\n  case \"Ouch\"   => third\n}\n// Output: 1, 2, 3, 6, 7, 8\n```\n\n----------------------------------------\n\nTITLE: Implementing Effectful Counter Service in Scala with ZIO\nDESCRIPTION: Shows implementation of a Counter service with effectful construction using ZIO's Ref for state management. Demonstrates basic service trait definition and live implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait Counter {\n  def inc: UIO[Unit]\n  def dec: UIO[Unit]\n  def get: UIO[Int]\n}\n\ncase class CounterLive(ref: Ref[Int]) extends Counter {\n  def inc: UIO[Unit] = ref.update(_ + 1)\n  def dec: UIO[Unit] = ref.update(_ - 1)\n  def get: UIO[Int]  = ref.get\n}\n\nobject CounterLive {\n  // Effectful constructor\n  def make: UIO[Counter] = Ref.make(0).map(new CounterLive(_))\n}\n\nclass EditorLive(\n    formatter: Formatter,\n    compiler: Compiler,\n    counter: Counter\n) extends Editor {\n  def formatAndCompile(code: String): UIO[String] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Generators in ZIO Test\nDESCRIPTION: Demonstrates how to compose generators to create more complex types. It shows creating a tuple generator and a generator for a custom Person case class.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/getting-started.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval stringIntGen: Gen[Sized, (String, Int)] = stringGen <*> intGen\n\ncase class Person(name: String, age: Int)\nval personGen: Gen[Sized, Person] = stringIntGen.map(Person.tupled)\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.validateFirst for First Success in Scala\nDESCRIPTION: This example shows ZIO.validateFirst, which collects all errors but returns only the first success.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/error-accumulation.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val res: ZIO[Any, List[String], Int] =\n    ZIO.validateFirst(List.range(1, 4)) { n =>\n      if (n < 5)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s\"$n is not less that 5\")\n    }\n  def run = res.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Pipeline Implementation with Queues and Fibers\nDESCRIPTION: Demonstrates a manual approach to creating a processing pipeline using ZIO queues and fibers, showing the complexity of low-level implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef writeToInput(q: Queue[Int]): Task[Unit]                            = Task.succeed(???)\ndef processBetweenQueues(from: Queue[Int], to: Queue[Int]): Task[Unit] = Task.succeed(???)\ndef printElements(q: Queue[Int]): Task[Unit]                           = Task.succeed(???)\n\nfor {\n  input  <- Queue.bounded[Int](16)\n  middle <- Queue.bounded[Int](16)\n  output <- Queue.bounded[Int](16)\n  _      <- writeToInput(input).fork\n  _      <- processBetweenQueues(input, middle).fork\n  _      <- processBetweenQueues(middle, output).fork\n  _      <- printElements(output).fork\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout with timeoutFail in ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#timeoutFail to timeout a stream if it doesn't produce a value after a specified duration. The example demonstrates timing out a stream after 10 seconds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nstream.timeoutFail(new TimeoutException)(10.seconds)\n```\n\n----------------------------------------\n\nTITLE: Writing a Simple ZIO-based Test with MUnit in Scala\nDESCRIPTION: This example demonstrates how to write a basic test using MUnit ZIO. It shows a simple addition test wrapped in ZIO effects, leveraging the ZSuite trait for ZIO integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/munit-zio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport munit._\nimport zio._\n\nclass SimpleZIOSpec extends ZSuite {\n  testZ(\"1 + 1 = 2\") {\n    for {\n      a <- ZIO(1)\n      b <- ZIO(1)\n    }\n    yield assertEquals(a + b, 2)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ZStream from Hub with Shutdown in Scala\nDESCRIPTION: Defines methods to create ZStreams from Hubs with automatic shutdown functionality. It includes variants for regular and chunked data structures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZStream[-R, +E, +O] {\n  def toHub[E1 >: E, O1 >: O](\n    capacity: Int\n  ): ZIO[R with Scope, Nothing, Hub[Take[E1, O1]]]\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive TestAspect Usage in Test Suite\nDESCRIPTION: Complete example showing various test aspects including platform-specific tests, timeouts, ignored tests, and aspect composition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.{test => _, _}\nimport zio.test.TestAspect._\n\nobject MySpec extends ZIOSpecDefault {\n  def spec = suite(\"A Suite\")(\n    test(\"A passing test\") {\n      assertTrue(true)\n    },\n    test(\"A passing test run for JVM only\") {\n      assertTrue(true)\n    } @@ jvmOnly,\n    test(\"A passing test run for JS only\") {\n      assertTrue(true)\n    } @@ jsOnly,\n    test(\"A passing test with a timeout\") {\n      assertTrue(true)\n    } @@ timeout(10.nanos),\n    test(\"A failing test... that passes\") {\n      assertTrue(true)\n    } @@ failing,\n    test(\"A ignored test\") {\n      assertTrue(false)\n    } @@ ignore,\n    test(\"A test using a live service instead of the test service\") {\n      for {\n        _ <- TestClock.timeZone\n      } yield assertCompletes\n    } @@ withLiveClock,\n    test(\"A flaky test that only works on the JVM and sometimes fails; let's compose some aspects!\") {\n      assertTrue(false)\n    } @@ jvmOnly           \n      @@ eventually        \n      @@ timeout(20.nanos) \n  ) @@ timeout(60.seconds)\n```\n\n----------------------------------------\n\nTITLE: Providing Multiple Services Using ZIO#provide in Scala\nDESCRIPTION: This snippet demonstrates how to provide multiple service implementations to a ZIO effect using the provide method. It shows how to inject dependencies for Foo and Bar services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-propagation.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval mainEffect: ZIO[Any, Nothing, Unit] = \n  myApp.provide(FooLive.layer, BarLive.layer)\n```\n\n----------------------------------------\n\nTITLE: Creating ZStream from Hub in Scala\nDESCRIPTION: Defines a method to create a ZStream from a Hub subscription. This allows streaming of values published to the hub while the subscription is active.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nobject ZStream {\n  def fromHub[O](hub: Hub[O]): ZStream[Any, Nothing, O] =\n    ???\n}\n```\n\n----------------------------------------\n\nTITLE: Using flatMap to Transform and Concatenate ZIO Streams\nDESCRIPTION: This example demonstrates the flatMap operator which applies a function to each element of a stream and concatenates the resulting streams. It repeats each number four times to create a new stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nval stream = ZStream(1, 2, 3).flatMap(x => ZStream.repeat(x).take(4))\n// Input:  1, 2, 3\n// Output: 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO Kafka Streaming Producer API Interface in Scala\nDESCRIPTION: This Scala code snippet shows the definition of the `produceAll` method within the ZIO Kafka `Producer` trait. This method returns a `ZPipeline` which transforms an input stream of `ProducerRecord[K, V]` into an output stream of `RecordMetadata`. It requires `Serializer` instances for the key and value types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ntrait Producer {\n  def produceAll[R, K, V](\n    keySerializer: Serializer[R, K],\n    valueSerializer: Serializer[R, V]\n  ): ZPipeline[R, Throwable, ProducerRecord[K, V], RecordMetadata]\n}\n```\n\n----------------------------------------\n\nTITLE: Game Selection with ZIO WhenCaseZIO\nDESCRIPTION: Illustrates using ZIO's whenCaseZIO operator to create a game selection program with user input.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef minesweeper(level: String)     = ZIO.attempt(???)\ndef ticTacToe                      = ZIO.attempt(???)\ndef snake(rows: Int, columns: Int) = ZIO.attempt(???)\n\ndef myApp =\n  ZIO.whenCaseZIO {\n    (Console.print(\n      \"Please choose one game (minesweeper, snake, tictactoe)? \"\n    ) *> Console.readLine).orDie\n  } {\n    case \"minesweeper\" =>\n      Console.print(\n        \"Please enter the level of the game (easy/hard/medium)?\"\n      ) *> Console.readLine.flatMap(minesweeper)\n    case \"snake\" =>\n      Console.printLine(\n        \"Please enter the size of the game: \"\n      ) *> Console.readLine.mapAttempt(_.toInt).flatMap(n => snake(n, n))\n    case \"tictactoe\" => ticTacToe\n  }\n```\n\n----------------------------------------\n\nTITLE: Error Handling with ZIO#repeatOrElse\nDESCRIPTION: Shows how to implement repetition with error handling using the ZIO#repeatOrElse function. This includes an orElse callback that runs if the repetition process fails.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/repetition.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval action:       ZIO[R, E, A] = ???\nval policy: Schedule[R1, A, B] = ???\n\nval orElse: (E, Option[B]) => ZIO[R1, E2, B] = ???\n\nval repeated = action repeatOrElse (policy, orElse)\n```\n\n----------------------------------------\n\nTITLE: Switching Streams on Timeout with timeoutTo in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates the use of ZStream#timeoutTo to switch to an alternative stream if the first stream doesn't produce a value after a specified duration. The example shows switching to an alternative stream after 10 seconds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval alternative = ZStream.fromZIO(ZIO.attempt(???))\nstream.timeoutTo(10.seconds)(alternative)\n```\n\n----------------------------------------\n\nTITLE: Modeling Dependencies in ZIO Environment\nDESCRIPTION: Shows how to model contextual values as part of the ZIO Environment, making dependencies explicit in the type signature. This approach allows avoiding boilerplate while maintaining type safety.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/faq.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef someEffect(...): ZIO[UserId & CorrelationId, ErrorType, A] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: Annotating Logs with Custom Information in Scala using ZIO\nDESCRIPTION: Demonstrates how to annotate log messages with custom information using ZIO.logAnnotate, useful for correlating logs between multiple services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  // We use random delay to simulate interleaving of operations in real world\n  def randomDelay = Random.nextIntBounded(1000).flatMap(t => ZIO.sleep(t.millis))\n\n  def run =\n    ZIO.foreachParDiscard(Chunk(\"UserA\", \"UserB\", \"UserC\")) { user =>\n      ZIO.logAnnotate(\"user-id\", user) {\n        for {\n          _ <- randomDelay\n          _ <- ZIO.log(\"fetching user from database\")\n          _ <- randomDelay\n          _ <- ZIO.log(\"downloading user's profile picture\")\n        } yield ()\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using @throwing Annotation with Accessor Methods\nDESCRIPTION: Example demonstrating the @throwing annotation to mark impure methods, which pushes potential exceptions to the ZIO error channel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros.accessible\nimport zio.macros.throwing\n\n@accessible\ntrait ServiceC {\n  @throwing\n  def impureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceC {\n  def impureMethod(input: Something): ZIO[ServiceC, Throwable, SomethingElse] =\n    ZIO.serviceWithZIO[ServiceC](s => ZIO(s.impureMethod(input)))\n}\n```\n\n----------------------------------------\n\nTITLE: Grouping Stream Elements in Scala using ZIO\nDESCRIPTION: Shows various ways to group ZStream elements, including grouping by key, effectful grouping, and time-based grouping.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\n  case class Exam(person: String, score: Int)\n\n  val examResults = Seq(\n    Exam(\"Alex\", 64),\n    Exam(\"Michael\", 97),\n    Exam(\"Bill\", 77),\n    Exam(\"John\", 78),\n    Exam(\"Bobby\", 71)\n  )\n\n  val groupByKeyResult: ZStream[Any, Nothing, (Int, Int)] =\n    Stream\n      .fromIterable(examResults)\n      .groupByKey(exam => exam.score / 10 * 10) {\n        case (k, s) => ZStream.fromEffect(s.runCollect.map(l => k -> l.size))\n      }\n```\n\nLANGUAGE: scala\nCODE:\n```\nabstract class ZStream[-R, +E, +O] {\n  final def groupBy[R1 <: R, E1 >: E, K, V](\n    f: O => ZIO[R1, E1, (K, V)],\n    buffer: Int = 16\n  ): ZStream.GroupBy[R1, E1, K, V]\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval counted: UStream[(Char, Long)] =\n  ZStream(\"Mary\", \"James\", \"Robert\", \"Patricia\", \"John\", \"Jennifer\", \"Rebecca\", \"Peter\")\n    .groupBy(x => ZIO.succeed((x.head, x))) { case (char, stream) =>\n      ZStream.fromEffect(stream.runCount.map(count => char -> count))\n    }\n// Input:  Mary, James, Robert, Patricia, John, Jennifer, Rebecca, Peter\n// Output: (P, 2), (R, 2), (M, 1), (J, 3)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval classifyStudents: ZStream[Console, IOException, (String, Seq[String])] =\n  ZStream.fromEffect(\n    putStrLn(\"Please assign each student to one of the A, B, or C classrooms.\")\n  ) *> ZStream(\"Mary\", \"James\", \"Robert\", \"Patricia\", \"John\", \"Jennifer\", \"Rebecca\", \"Peter\")\n    .groupBy(student =>\n      putStr(s\"What is the classroom of $student? \") *>\n        getStrLn.map(classroom => (classroom, student))\n    ) { case (classroom, students) =>\n      ZStream.fromEffect(\n        students\n          .fold(Seq.empty[String])((s, e) => s :+ e)\n          .map(students => classroom -> students)\n      )\n    }\n\n// Input: \n// Please assign each student to one of the A, B, or C classrooms.\n// What is the classroom of Mary? A\n// What is the classroom of James? B\n// What is the classroom of Robert? A\n// What is the classroom of Patricia? C\n// What is the classroom of John? B\n// What is the classroom of Jennifer? A\n// What is the classroom of Rebecca? C\n// What is the classroom of Peter? A\n//\n// Output: \n// (B,List(James, John))\n// (A,List(Mary, Robert, Jennifer, Peter))\n// (C,List(Patricia, Rebecca))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval groupedResult: ZStream[Any, Nothing, Chunk[Int]] =\n  Stream.fromIterable(0 to 8).grouped(3)\n\n// Input:  0, 1, 2, 3, 4, 5, 6, 7, 8\n// Output: Chunk(0, 1, 2), Chunk(3, 4, 5), Chunk(6, 7, 8)\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\nimport zio.duration._\nimport zio.clock.Clock\n\nval groupedWithinResult: ZStream[Any with Clock, Nothing, Chunk[Int]] =\n  Stream.fromIterable(0 to 10)\n    .repeat(Schedule.spaced(1.seconds))\n    .groupedWithin(30, 10.seconds)\n```\n\n----------------------------------------\n\nTITLE: Advanced CountdownLatch Example with Multiple Producers in Scala ZIO\nDESCRIPTION: Advanced example showing multiple concurrent producers with a CountdownLatch requiring multiple conditions to be met before consumption starts.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/countdownlatch.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent._\n\nobject MainApp extends ZIOAppDefault {\n\n  def consume(queue: Queue[Int]): UIO[Nothing] =\n    queue.take\n      .flatMap(i => ZIO.debug(s\"consumed: $i\"))\n      .forever\n\n  def produce(queue: Queue[Int], latch: CountdownLatch): UIO[Nothing] =\n    (Random\n      .nextIntBounded(100)\n      .tap(i => queue.offer(i))\n      .tap(i => ZIO.when(i == 50)(latch.countDown)) *> ZIO.sleep(500.millis)).forever\n\n  def run =\n    for {\n      latch <- CountdownLatch.make(5)\n      queue <- Queue.unbounded[Int]\n      p = ZIO.collectAllParDiscard(ZIO.replicate(10)(produce(queue, latch)))\n      c = latch.await *> consume(queue)\n      _     <-  p <&> c\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Racing Effects in Scala using ZIO\nDESCRIPTION: This snippet demonstrates how to race two effects concurrently in ZIO, returning the first successful result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  winner <- ZIO.succeed(\"Hello\").race(ZIO.succeed(\"Goodbye\"))\n} yield winner\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#timeout with Uninterruptible Effect Timeout in Scala\nDESCRIPTION: Shows the behavior of `ZIO#timeout` with a 1-second timeout when applied to an `uninterruptible` version of the `myApp` effect. Although the timeout elapses after 1 second, the uninterruptible effect continues running until completion (2 seconds). Only then does the `timeout` operator yield `None`. The execution time reflects the original effect's duration, not the timeout.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/timing-out.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .uninterruptible\n      .timeout(1.second)\n      .debug(\"output\")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug(\"execution time of the whole program in second\")\n}\n\n// Output:\n// start doing something.\n// my job is finished!\n// output: None\n// execution time of the whole program in second: 2\n```\n```\n\n----------------------------------------\n\nTITLE: Flattening ZIO[R, E, Either[B, A]] to ZIO[R, E, A] in Scala\nDESCRIPTION: Transforms a `ZIO[R, E, Either[B, A]]` effect into a `ZIO[R, E, A]`. It uses `flatMap` to access the inner `Either` and then applies `ZIO.fromEither` combined with `mapError` to handle the `Either`'s `Left` case by converting the `B` value to an error `E` using the `ifLeft` function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfrom.flatMap(ZIO.fromEither(_).mapError(ifLeft))\n```\n\n----------------------------------------\n\nTITLE: Forking ZIO Fibers in Local Scope with forkScoped\nDESCRIPTION: This example demonstrates how to use ZIO#forkScoped to attach a fiber to a local scope. The forked fiber's lifetime can outlive its parent fiber but will be terminated when the local scope is closed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val barJob: ZIO[Any, Nothing, Long] =\n    ZIO\n      .debug(\"Bar: still running!\")\n      .repeat(Schedule.fixed(1.seconds))\n\n  val fooJob: ZIO[Scope, Nothing, Unit] =\n    (for {\n      _ <- ZIO.debug(\"Foo: started!\")\n      _ <- barJob.forkScoped\n      _ <- ZIO.sleep(2.seconds)\n      _ <- ZIO.debug(\"Foo: finished!\")\n    } yield ()).onInterrupt(_ => ZIO.debug(\"Foo: interrupted!\"))\n\n  def run =\n    for {\n      _ <- ZIO.scoped {\n        for {\n          _ <- ZIO.debug(\"Local scope started!\")\n          _ <- fooJob.fork\n          _ <- ZIO.sleep(5.seconds)\n          _ <- ZIO.debug(\"Leaving the local scope!\")\n        } yield ()\n      }\n      _ <- ZIO.debug(\"Do something else and sleep for 10 seconds\")\n      _ <- ZIO.sleep(10.seconds)\n      _ <- ZIO.debug(\"Application exited!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: In-memory Implementation Stubs for ZIO Services\nDESCRIPTION: Defines placeholder ZLayer implementations for in-memory BlobStorage and MetadataRepo services, demonstrating the standard pattern for creating service implementations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject InmemoryBlobStorage {\n  val layer = \n    ZLayer {\n      ???\n    } \n}\n\n\nobject InmemoryMetadataRepo {\n  val layer = \n    ZLayer {\n      ???\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Main Application for ZIO Shardcake\nDESCRIPTION: This code defines the main application using ZIO Shardcake. It sets up the sharding, web service, and necessary layers for the application to run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nimport com.devsisters.shardcake._\nimport zio._\nimport zio.http.Server\n\nobject HttpApp extends ZIOAppDefault {\n\n  def run: Task[Unit] =\n    ZIO.scoped {\n      for {\n        port    <- System.env(\"HTTP_PORT\").map(_.flatMap(_.toIntOption).getOrElse(8080))\n        _       <- Sharding.registerEntity(Counter, Counter.behavior)\n        _       <- Sharding.registerScoped\n        counter <- Sharding.messenger(Counter)\n        _       <- Server.serve(WebService(counter)).provideSome[Sharding](Server.defaultWithPort(port))\n      } yield ()\n    }.provide(\n      ShardConfig.layer,\n      ZLayer.succeed(GrpcConfig.default),\n      ZLayer.succeed(RedisConfig.default),\n      RedisLive.layer,\n      StorageRedis.live,\n      KryoSerialization.live,\n      ShardManagerClient.liveWithSttp,\n      GrpcPods.live,\n      Sharding.live,\n      GrpcShardingService.live\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Stateful Counter Channel in Scala ZIO\nDESCRIPTION: Creates a channel that tracks the count of all values it has processed and returns the final count as a completion value, demonstrating state management in channels.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nobject MainApp extends ZIOAppDefault {\n  val counter = {\n      def count(c: Int): ZChannel[Any, Any, Int, Any, String, Int, Int] =\n        ZChannel.readWith(\n          (i: Int) => ZChannel.write(i) *> count(c + 1),\n          (_: Any) => ZChannel.fail(\"error\"),\n          (_: Any) => ZChannel.succeed(c)\n        )\n\n      count(0)\n    }\n\n  def run = (ZChannel.writeAll(1, 2, 3, 4, 5) >>> counter).runCollect.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Prelude in SBT\nDESCRIPTION: Adds the ZIO Prelude library dependency to a Scala project's build.sbt file. ZIO Prelude provides functional abstractions and data types with tight ZIO integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-prelude\" % \"1.0.0-RC5\"\n```\n\n----------------------------------------\n\nTITLE: Method Equivalence between Cats FlatMap.Ops and ZIO\nDESCRIPTION: A mapping table showing the equivalent methods between Cats Effect's FlatMap.Ops and ZIO. This includes common operations like flatMap, flatten, and various product operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-cats-effect.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nflatMap      -> flatMap\nflatten      -> flatten\nproductREval -> zipRight\nproductLEval -> zipLeft\nmproduct     -> zipPar\nflatTap      -> tap\n```\n\n----------------------------------------\n\nTITLE: Absolving ZIO[R, Throwable, Either[Throwable, A]] in Scala\nDESCRIPTION: Transforms a `ZIO[R, Throwable, Either[Throwable, A]]` into a `ZIO[R, Throwable, A]`. It 'absolves' the inner `Either`: a `Left(throwable)` becomes a failure in the resulting ZIO effect, and a `Right(a)` becomes a success.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfrom.absolve\n```\n\n----------------------------------------\n\nTITLE: Creating a One-Time Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that recurs exactly one time and returns one Unit element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval once = Schedule.once\n```\n\n----------------------------------------\n\nTITLE: Collecting Schedule Outputs\nDESCRIPTION: Shows how to collect all schedule outputs into a Chunk using collectAll.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval collect = Schedule.recurs(5).collectAll\n```\n\n----------------------------------------\n\nTITLE: Using SandboxWith for Concise Error Handling in Scala\nDESCRIPTION: Provides an example ZIO application demonstrating the `sandboxWith` operator. It achieves the same result as the previous `sandbox`/`catchSome`/`unsandbox` example but uses `sandboxWith` to pass a function that handles the different `Cause` types directly. Requires the `zio` library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/sandboxing.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect: ZIO[Any, String, String] =\n    ZIO.succeed(\"primary result\") *> ZIO.fail(\"Oh uh!\")\n\n  val myApp =\n    effect.sandboxWith[Any, String, String] { e =>\n      e.catchSome {\n        case Cause.Interrupt(fiberId, _) =>\n          ZIO.debug(s\"Caught interruption of a fiber with id: $fiberId\") *>\n            ZIO.succeed(\"fallback result on fiber interruption\")\n        case Cause.Die(value, _) =>\n          ZIO.debug(s\"Caught a defect: $value\") *>\n            ZIO.succeed(\"fallback result on defect\")\n        case Cause.Fail(value, _) =>\n          ZIO.debug(s\"Caught a failure: $value\") *>\n            ZIO.succeed(\"fallback result on failure\")\n      }\n    }\n  def run = myApp.debug\n}\n\n// Output:\n// Caught a failure: Oh uh!\n// fallback result on failure\n```\n\n----------------------------------------\n\nTITLE: Implementing Periodic Time Printing with ZIO Sleep\nDESCRIPTION: Shows how to create an infinite loop that prints the current time with a one-second delay between iterations. Uses non-blocking ZIO.sleep implementation along with Clock.currentDateTime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/clock.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef printTimeForever: ZIO[Any, Throwable, Nothing] =\n  Clock.currentDateTime.flatMap(Console.printLine(_)) *>\n    ZIO.sleep(1.seconds) *> printTimeForever\n```\n\n----------------------------------------\n\nTITLE: Setting up Custom Errors and Effect for `unrefine` Example in ZIO Scala\nDESCRIPTION: Defines custom `Throwable` types (`Foo`, `Bar`, `Baz`), an unsafe function `unsafeOpThatMayThrows` that throws these, and wraps it in a `ZIO.succeed`. This creates an effect `effect` with error type `Nothing` that may die with `Foo`, `Bar`, or `Baz` defects. This setup prepares for demonstrating the `unrefine` operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Foo(msg: String) extends Throwable(msg)\ncase class Bar(msg: String) extends Throwable(msg)\ncase class Baz(msg: String) extends Throwable(msg)\n\nobject MainApp extends ZIOAppDefault {\n  def unsafeOpThatMayThrows(i: String): String =\n    if (i == \"foo\")\n      throw Foo(\"Oh uh!\")\n    else if (i == \"bar\")\n      throw Bar(\"Oh Error!\")\n    else if (i == \"baz\")\n      throw Baz(\"Oh no!\")\n    else i\n\n  def effect(i: String): ZIO[Any, Nothing, String] =\n    ZIO.succeed(unsafeOpThatMayThrows(i))\n\n  val unrefined: ZIO[Any, Foo, String] =\n    effect(\"foo\").unrefine { case e: Foo => e }\n\n  def run = unrefined.catchAll(_ => ZIO.unit)\n}\n```\n\n----------------------------------------\n\nTITLE: Finalizing Effects with ZIO#ensuring in Scala\nDESCRIPTION: Demonstrates how to use ZIO#ensuring to guarantee execution of finalizers, even in case of failures. The finalizer prints a message, and is attached to a failing effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-resources.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval finalizer: UIO[Unit] = \n  ZIO.succeed(println(\"Finalizing!\"))\n\nval finalized: IO[String, Unit] = \n  ZIO.fail(\"Failed!\").ensuring(finalizer)\n```\n\n----------------------------------------\n\nTITLE: Implementing Structured Logging with ZIO Environment\nDESCRIPTION: A solution for structured logging that uses the ZIO environment to store contextual state (annotations) and isolate state between different fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Solution 1: Using the ZIO environment to store the contextual state\nimport zio._\n\nobject Logging {\n  type Annotation = Map[String, String]\n\n  def logAnnotate[R, E, A](key: String, value: String)(\n    zio: ZIO[R with Annotation, E, A]\n  ): ZIO[R with Annotation, E, A] = {\n    for {\n      s <- ZIO.service[Annotation]\n      r <- zio.provideSomeLayer[R](ZLayer.succeed(s.updated(key, value)))\n    } yield (r)\n  }\n\n  def log(message: String): ZIO[Annotation, Nothing, Unit] = {\n    ZIO.service[Annotation].flatMap {\n      case annotation if annotation.isEmpty => \n        Console.printLine(message).orDie\n      case annotation =>\n        val line =\n          s\"${annotation.map { case (k, v) => s\"[$k=$v]\" }.mkString(\" \")} $message\"\n        Console.printLine(line).orDie\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a TMap with Specified Values in ZIO STM\nDESCRIPTION: Creates a TMap with specified key-value pairs using the make method. This initializes a transactional map with the provided entries.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval specifiedValuesTMap: STM[Nothing, TMap[String, Int]] = TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n```\n\n----------------------------------------\n\nTITLE: Transforming Values in a TMap in ZIO STM\nDESCRIPTION: Uses transformValues to apply a function to every value in the TMap while keeping the keys unchanged. This is useful when only the values need to be modified.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformValuesTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  _    <- tMap.transformValues(v => v * v)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Database Connection Pool Example\nDESCRIPTION: Example demonstrating creation and usage of a dynamic-sized database connection pool with time-to-live configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zpool.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nZIO.scoped {\n  ZPool.make(acquireDbConnection, 10 to 20, 60.seconds).flatMap { pool =>\n    ZIO.scoped {\n      pool.get.flatMap { conn => useConnection(conn) }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parallel Resource Management in Scala\nDESCRIPTION: Implements parallel resource acquisition and release using ZIO.parallelFinalizers, allowing two resources to be managed concurrently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef zipScoped[R <: Scope, E, A, B](\n  left: ZIO[R, E, A],\n  right: ZIO[R, E, B]\n): ZIO[R, E, (A, B)] =\n  ZIO.parallelFinalizers(left.zipPar(right))\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Generators in Scala Test\nDESCRIPTION: This example demonstrates how to use multiple generators in a single test case, showing how samples are generated as the cartesian product of their streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/how-generators-work.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ntest(\"two deterministic generators\") {\n  check(Gen.const(1), Gen.fromIterable(List(\"a\", \"b\", \"c\"))) { (a, b) =>\n    println((a, b))\n    assertTrue(true)\n  }\n} @@ TestAspect.samples(5)\n```\n\n----------------------------------------\n\nTITLE: Creating a ZLayer for DocRepoImpl Service\nDESCRIPTION: Defines a ZLayer for DocRepoImpl that requires BlobStorage and MetadataRepo services as dependencies, following ZIO's dependency injection pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject DocRepoImpl {\n  val layer: ZLayer[BlobStorage with MetadataRepo, Nothing, DocRepo] =\n    ZLayer {\n      for {\n        metadataRepo <- ZIO.service[MetadataRepo]\n        blobStorage  <- ZIO.service[BlobStorage]\n      } yield DocRepoImpl(metadataRepo, blobStorage)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Debugging Both Cause in Scala\nDESCRIPTION: Demonstrates how to create and debug Both causes in ZIO, which occur when parallel computations fail for multiple reasons.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval myApp: ZIO[Any, String, Unit] =\n  for {\n    f1 <- ZIO.fail(\"Oh uh!\").fork\n    f2 <- ZIO.dieMessage(\"Boom!\").fork\n    _ <- (f1 <*> f2).join\n  } yield ()\nmyApp.cause.debug\n// Both(Fail(Oh uh!,Trace(Runtime(13,1646481219),Chunk(<empty>.MainApp.myApp(MainApp.scala:5)))),Stackless(Die(java.lang.RuntimeException: Boom!,Trace(Runtime(14,1646481219),Chunk(<empty>.MainApp.myApp(MainApp.scala:6)))),true))\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Task to Scala Future in Scala\nDESCRIPTION: This snippet defines a function to convert a ZIO Task into a Scala Future using the toFuture method. As ZIO's toFuture is effectful (returns a UIO), this function returns an unstarted effect which, upon execution with a runtime, yields a Future whose computation matches the Task. Requires ZIO and proper runtime to execute the effect; the input is a Task, and the output is an effect producing a Future.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-future.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef taskToFuture[A](task: Task[A]): UIO[Future[A]] = \n  task.toFuture\n```\n\n----------------------------------------\n\nTITLE: Configuring Expectations for Unit-Returning Methods\nDESCRIPTION: Demonstrates how to create expectations for methods that return Unit. Shows both explicit and implicit approaches to defining the expected output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.mock.MockConsole\n\nval exp03 = MockConsole.PutStrLn(equalTo(\"Welcome to ZIO!\"))\nval exp04 = MockConsole.PutStrLn(equalTo(\"Welcome to ZIO!\"), unit)\n```\n\n----------------------------------------\n\nTITLE: Traditional Unit Testing for Addition Function in Scala\nDESCRIPTION: Demonstrates a traditional unit testing approach for the addition function using ZIO Test. It tests specific input-output pairs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nobject AdditionSpec extends ZIOSpecDefault {\n\n  def add(a: Int, b: Int): Int = ???\n\n  val testData = Seq(\n    ((0, 0), 0),\n    ((1, 0), 1),\n    ((0, 1), 1),\n    ((0, -1), -1),\n    ((-1, 0), -1),\n    ((1, 1), 2),\n    ((1, -1), 0),\n    ((-1, 1), 0)\n  )\n\n  def spec =\n    test(\"test add function\") {\n      assertTrue {\n        testData.forall { case ((a, b), expected) =>\n          add(a, b) == expected\n        }\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Async HTTP Client Backend Dependencies for ZIO K8s\nDESCRIPTION: Configuration for adding the asynchronous HTTP client backend dependencies as an alternative for ZIO K8s.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n\"com.softwaremill.sttp.client3\" %% \"async-http-client-backend-zio\" % \"3.1.1\"\n\"com.softwaremill.sttp.client3\" %% \"slf4j-backend\"                 % \"3.1.1\"\n```\n\n----------------------------------------\n\nTITLE: Wrapping Java Future into ZIO RIO - Scala\nDESCRIPTION: This snippet creates a ZIO RIO effect from a Java java.util.concurrent.Future by wrapping it via ZIO.fromFutureJava in Scala. The example demonstrates integrating with an async HTTP client using Java Futures and indicates that blocking may occur internally. The function requires a HttpAsyncClient, HttpUriRequest, and ZIO\\'s Blocking environment; it outputs a RIO effect encapsulating the HTTP response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-java.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef execute(client: HttpAsyncClient, request: HttpUriRequest): RIO[Blocking, HttpResponse] =\n    ZIO.fromFutureJava(UIO {\n        client.execute(request, null)\n    })\n```\n\n----------------------------------------\n\nTITLE: Scoped Resource Management in ZLayer Derivation\nDESCRIPTION: Shows how to use ZLayer.Derive.Scoped trait to manage scoped resources in ZLayer.derive, including background tasks and health checks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/automatic-zlayer-derivation.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Connection {\n  def healthCheck: ZIO[Any, Throwable, Unit]\n  // ...\n}\n\nclass ThirdPartyService(connection: Connection) extends ZLayer.Derive.Scoped[Any, Nothing] {\n\n  // Repeats health check every 10 seconds in background during the layer's lifetime\n  override def scoped(implicit trace: Trace): ZIO[Scope, Nothing, Any] =\n    connection.healthCheck\n      .ignoreLogged\n      .repeat(Schedule.spaced(10.seconds))\n      .forkScoped\n}\n\nobject ThirdPartyService {\n  // `ZLayer.Derive.Scoped` should be used with `ZLayer.derive`\n  val layer: ZLayer[Connection, Nothing, ThirdPartyService] = ZLayer.derive[ThirdPartyService]\n}\n```\n\n----------------------------------------\n\nTITLE: Recovering from Failure with orElse in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates the use of ZStream#orElse to recover from stream failures by switching to an alternative stream when an error occurs. When the first stream fails, execution continues with the second stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_68\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3) ++ ZStream.fail(\"Oh! Error!\") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\n\nval stream = s1.orElse(s2)\n// Output: 1, 2, 3, 7, 8, 9\n```\n\n----------------------------------------\n\nTITLE: Implementing RetryOrElse with Fallback\nDESCRIPTION: Shows how to use retryOrElse to specify a fallback strategy when retries are exhausted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_43\n\nLANGUAGE: scala\nCODE:\n```\nreadFile(\"primary.data\").retryOrElse(\n  Schedule.recurs(5),\n  (_, _:Long) => ZIO.succeed(DefaultData)\n)\n```\n\n----------------------------------------\n\nTITLE: ZSink Type Alias Definition in Scala\nDESCRIPTION: Shows the type alias definition for Sink, which is a specialized version of ZSink that doesn't require any specific environment (Any).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype Sink[+E, A, +L, +B] = ZSink[Any, E, A, L, B]\n```\n\n----------------------------------------\n\nTITLE: Running a Succeeding Channel with runCollect in Scala\nDESCRIPTION: Demonstrates how to run a channel created with ZChannel.succeed and view its output. The output shows an empty Chunk (no produced data) and the done value 42.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/creating-channels.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nchannel.runCollect.debug\n\n// Output: \n//   (Chunk(),42)\n```\n\n----------------------------------------\n\nTITLE: Composing a Mock Service Layer from Proxy with ZIO (Scala)\nDESCRIPTION: Implements the compose function as a URLayer transforming a Proxy into an Example service. Each method delegates to the corresponding proxy capability or executes them through the ZIO runtime as needed. Demonstrates use of withRuntime, handling effectful methods, overloading, and error mapping for ZSink. Dependencies: ZIO, ExampleMock, Example service definitions. Inputs: Proxy. Outputs: URLayer providing Example for test environments.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport ExampleMock._\n\nval compose: URLayer[Has[Proxy], Example] =\n  ZLayer.fromServiceM { proxy =>\n    withRuntime.map { rts =>\n      new Example.Service {\n        val static                                 = proxy(Static)\n        def zeroArgs                               = proxy(ZeroArgs)\n        def zeroArgsWithParens()                   = proxy(ZeroArgsWithParens)\n        def singleArg(arg1: Int)                   = proxy(SingleArg, arg1)\n        def multiArgs(arg1: Int, arg2: Long)       = proxy(MultiArgs, arg1, arg2)\n        def multiParamLists(arg1: Int)(arg2: Long) = proxy(MultiParamLists, arg1, arg2)\n        def command(arg1: Int)                     = proxy(Command, arg1)\n        def overloaded(arg1: Int)                  = proxy(Overloaded._0, arg1)\n        def overloaded(arg1: Long)                 = proxy(Overloaded._1, arg1)\n        def function(arg1: Int)                    = rts.unsafeRunTask(proxy(Function, arg1))\n        def sink(a: Int)                           = rts.unsafeRun(proxy(Sink, a).catchAll(error => UIO(ZSink.fail[String, Int](error))))\n        def stream(a: Int)                         = rts.unsafeRun(proxy(Stream, a))\n      }\n    }\n  }\n```\n\n----------------------------------------\n\nTITLE: Debugging ZLayer Construction with ZLayer.Debug.mermaid\nDESCRIPTION: This snippet demonstrates how to use ZLayer.Debug.mermaid for debugging ZLayer construction. It generates a Mermaid diagram to visualize the dependency graph.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_53\n\nLANGUAGE: scala\nCODE:\n```\nval layer = ZLayer.make[DocRepo with UserRepo](\n  Logging.live,\n  DocRepo.live,\n  Database.live,\n  BlobStorage.live,\n  UserRepo.live,\n  ZLayer.Debug.mermaid\n)\n```\n\n----------------------------------------\n\nTITLE: Performing an Intersection Operation on TSets in Scala ZIO STM\nDESCRIPTION: Performs an intersection operation between two TSets, resulting in a set containing only elements present in both sets. This modifies the first set (tSetA) with the intersection result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\n// intersectionTSet = {3, 4}\nval intersectionTSet: UIO[TSet[Int]] = (for {\n  tSetA <- TSet.make(1, 2, 3, 4)\n  tSetB <- TSet.make(3, 4, 5, 6)\n  _     <- tSetA.intersect(tSetB)\n} yield tSetA).commit\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Task to Future\nDESCRIPTION: Demonstrates converting a ZIO Task into a Scala Future using the toFuture method. The conversion is effectful and requires runtime execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-future.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef taskToFuture[A](task: Task[A]): UIO[Future[A]] = \n  task.toFuture\n```\n\n----------------------------------------\n\nTITLE: Effectful Folding in ZIO (Scala)\nDESCRIPTION: Shows how to use `foldZIO` to effectfully handle both failure and success. This powerful method allows for complex error handling and success processing logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nval primaryOrSecondaryData: IO[IOException, Array[Byte]] =\n  readFile(\"primary.data\").foldZIO(\n    _    => readFile(\"secondary.data\"),\n    data => ZIO.succeed(data))\n```\n\n----------------------------------------\n\nTITLE: Migrating Unsafe ZIO Workflow Execution from ZIO 1.x to 2.x (Diff)\nDESCRIPTION: This diff snippet illustrates the code changes needed to migrate the unsafe execution example from ZIO 1.x to ZIO 2.x. It replaces the direct call to `Runtime.default.unsafeRun` with the `Unsafe.unsafe` block, which provides the necessary `implicit unsafe` capability for the new `Runtime.default.unsafe.run` method. It also shows extracting the result using `getOrThrowFiberFailure`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_34\n\nLANGUAGE: diff\nCODE:\n```\nimport zio._\n\nobject MainApp {\n  val zioWorkflow: ZIO[Any, Nothing, Int] = ???\n\n  def legacyApplication(input: Int): Unit = ???\n\n  def zioApplication: Int =\n-    Runtime.default.unsafeRun(zioWorkflow)\n+    Unsafe.unsafe { implicit unsafe =>\n+      Runtime.default.unsafe.run(zioWorkflow).getOrThrowFiberFailure()\n+    }\n\n  def main(args: Array[String]): Unit = {\n    legacyApplication(zioApplication)\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Resource Retry Pattern\nDESCRIPTION: Example showing how to implement retry logic for failed resource acquisitions from the pool.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zpool.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nZPool.make(acquireDbConnection, 10).flatMap { pool =>\n  pool.get.flatMap( conn => useConnection(conn)).eventually\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with ZIO's CatchAll Method in Scala\nDESCRIPTION: Shows how to handle errors in ZIO using the catchAll method, providing pattern matching for different error types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nvalidate(17).catchAll {\n  case NegativeAgeException(age) => ???\n  case IllegalAgeException(age)  => ???\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Gen Data Type and Helper Methods in Scala\nDESCRIPTION: This code block provides a simplified implementation of the Gen data type along with helper methods for creating various types of generators, including constant, random integer, and element generators.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/how-generators-work.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\nimport zio.stream._\n\ncase class Gen[R, A](sample: ZStream[R, Nothing, A]) {\n  def map[B](f: A => B): Gen[R, B] = Gen(sample.map(f))\n\n  def flatMap[R1 <: R, B](f: A => Gen[R1, B]): Gen[R1, B] = ???\n\n  def runCollect: ZIO[R, Nothing, List[A]] = sample.runCollect.map(_.toList)\n}\n\nobject Gen {\n  // A constant generator of the specified value.\n  def const[A](a: => A): Gen[Any, A] = \n    Gen(ZStream.succeed(a))\n  \n  // A random generator of integers.\n  def int: Gen[Any, Int] = \n    Gen(ZStream.fromZIO(Random.nextInt))\n  def int(min: Int, max: Int): Gen[Any, Int] = \n    ???\n  \n  // A random generator of specified values.\n  def elements[A](as: A*): Gen[Any, A] = \n    if (as.isEmpty) Gen(ZStream.empty) else int(0, as.length - 1).map(as)\n  \n  // A constant generator of fixed values.\n  def fromIterable[A](xs: Iterable[A]): Gen[Any, A] = \n    Gen(ZStream.fromIterable(xs))\n}\n\nGen.const(42).runCollect.debug\n// Output: List(42)\n\nGen.int.runCollect.debug\n// Output: List(82) or List(3423) or List(-352) or ...\n\nGen.elements(1, 2, 3).runCollect.debug\n// Output: List(1) or List(2) or List(3)\n\nGen.fromIterable(List(1, 2, 3))\n// Output: List(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Debouncing Stream Elements in Scala\nDESCRIPTION: The debounce method emits elements only after a minimum period of inactivity, filtering out bursts of events. This example shows debouncing with a 100ms window, outputting only elements that are followed by at least 100ms of silence.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_56\n\nLANGUAGE: scala\nCODE:\n```\nval stream = (\n  ZStream(1, 2, 3) ++\n    ZStream.fromEffect(ZIO.sleep(500.millis)) ++ ZStream(4, 5) ++\n    ZStream.fromEffect(ZIO.sleep(10.millis)) ++\n    ZStream(6)\n).debounce(100.millis) // emit only after a pause of at least 100 ms\n// Output: 3, 6\n```\n\n----------------------------------------\n\nTITLE: Offering Item to Bounded Queue in Scala\nDESCRIPTION: Offers an Int value into a newly created bounded ZIO Queue. Operations are chained in a for-comprehension and complete as a UIO[Unit]. No extra dependencies needed beyond zio._; capacity is set to 100.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval res1: UIO[Unit] = for {\\n  queue <- Queue.bounded[Int](100)\\n  _ <- queue.offer(1)\\n} yield ()\\n\n```\n\n----------------------------------------\n\nTITLE: Tapping ZLayer for Side Effects in Scala\nDESCRIPTION: Shows how to perform side effects based on the success or failure of a ZLayer using tap and tapError methods. This allows debugging or logging without changing the layer's signature or flow.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval config: ZLayer[Any, Throwable, AppConfig] =\n  ZLayer.fromZIO(\n    ZIO.attempt(???) // reading config from a file\n  )\n\nval res: ZLayer[Any, Throwable, AppConfig] =\n  config\n    .tap(cnf => ZIO.debug(s\"layer acquisition succeeded with $cnf\"))\n    .tapError(err => ZIO.debug(s\"error occurred during reading the config $err\"))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZState Fiber Behavior in Scala\nDESCRIPTION: Illustrates how ZState behaves with fibers, specifically showing how state is merged when a child fiber joins its parent. This example demonstrates the inheritance of behavior from FiberRef where child fiber state replaces parent fiber state upon joining.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/zstate.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class MyState(counter: Int)\n\nobject ZStateExample extends ZIOAppDefault {\n  val myApp = for {\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n    fiber <-\n      (for {\n        _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n        state <- ZIO.getState[MyState]\n        _ <- Console.printLine(s\"Current state inside the forked fiber: $state\")\n      } yield ()).fork\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 5))\n    state1 <- ZIO.getState[MyState]\n    _ <- Console.printLine(s\"Current state before merging the fiber: $state1\")\n    _ <- fiber.join\n    state2 <- ZIO.getState[MyState]\n    _ <- Console.printLine(s\"The final state: $state2\")\n  } yield ()\n\n  def run =\n    ZIO.stateful(MyState(0))(myApp)\n}\n```\n\n----------------------------------------\n\nTITLE: Scheduling Stream Emissions with ZStream#schedule in Scala\nDESCRIPTION: This example demonstrates how to control the timing of stream emissions using the schedule operator. It spaces out elements with a fixed 1-second delay between each emission, useful for rate limiting or creating time-based sequences.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_63\n\nLANGUAGE: scala\nCODE:\n```\nval stream = Stream(1, 2, 3, 4, 5).schedule(Schedule.spaced(1.second))\n```\n\n----------------------------------------\n\nTITLE: Providing ZLayer to Application in Scala ZIO\nDESCRIPTION: Example of providing a ZLayer to a ZIO application using provideLayer. This is the modern approach to dependency injection in ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval mainApp: ZIO[Any, Nothing, Unit] = myApp.provideLayer(myLayer) \n// mainApp: ZIO[Any, Nothing, Unit] = zio.ZIO$CheckInterrupt@4682e5d9\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Pulsar in SBT for Scala 3\nDESCRIPTION: SBT dependency configuration for adding the ZIO Pulsar library in Scala 3 projects. ZIO Pulsar provides a type-safe, ZIO-integrated client for Apache Pulsar.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.github.jczuchnowski\" %% \"zio-pulsar\" % \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Manual Pipeline Implementation with Queues\nDESCRIPTION: Example showing manual pipeline implementation using ZIO Queues and Fibers, demonstrating the complexity of low-level concurrent programming.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef writeToInput(q: Queue[Int]): Task[Unit]                            = ZIO.succeed(???)\ndef processBetweenQueues(from: Queue[Int], to: Queue[Int]): Task[Unit] = ZIO.succeed(???)\ndef printElements(q: Queue[Int]): Task[Unit]                           = ZIO.succeed(???)\n\nfor {\n  input  <- Queue.bounded[Int](16)\n  middle <- Queue.bounded[Int](16)\n  output <- Queue.bounded[Int](16)\n  _      <- writeToInput(input).fork\n  _      <- processBetweenQueues(input, middle).fork\n  _      <- processBetweenQueues(middle, output).fork\n  _      <- printElements(output).fork\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Refining Custom Domain Errors with `refineOrDie` in ZIO Scala\nDESCRIPTION: Provides an example of using `refineOrDie` with custom `DomainError` types (`Foo`, `Bar`, `Baz`). It refines an effect initially failing with `Baz` by using a partial function that only handles `Foo` and `Bar`. Consequently, the `Baz` error is converted into a defect, and the resulting effect's error channel only contains `Foo` and `Bar` (though in this specific run, it results in a defect).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nsealed abstract class DomainError(msg: String)\n  extends Exception(msg)\n    with Serializable\n    with Product\ncase class Foo(msg: String) extends DomainError(msg)\ncase class Bar(msg: String) extends DomainError(msg)\ncase class Baz(msg: String) extends DomainError(msg)\n\nobject MainApp extends ZIOAppDefault {\n  val effect: ZIO[Any, DomainError, Unit] =\n    ZIO.fail(Baz(\"Oh uh!\"))\n\n  val refined: ZIO[Any, DomainError, Unit] =\n    effect.refineOrDie {\n      case foo: Foo => foo\n      case bar: Bar => bar\n    }\n\n  def run = refined.catchAll(_ => ZIO.unit).debug\n}\n```\n\n----------------------------------------\n\nTITLE: Providing an Environment to a ZIO Effect in Scala\nDESCRIPTION: This snippet demonstrates how to provide the required environment (`Int`) to a ZIO effect (`square`) using the `provide` method. The original effect `square` requires an `Int` (`URIO[Int, Int]`), and after providing the value `42`, the resulting effect `result` has its requirements satisfied (`UIO[Int]`), indicated by the environment type changing to `Any` (aliased as `UIO`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval square: URIO[Int, Int] = \n  for {\n    env <- ZIO.environment[Int]\n  } yield env * env\n\nval result: UIO[Int] = square.provide(42)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Debugging Empty Cause in Scala\nDESCRIPTION: Demonstrates how to create an Empty cause using ZIO.failCause and Cause.empty, and how to debug the underlying cause of a successful ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.failCause(Cause.empty).cause.debug\n// Empty\n\nZIO.succeed(5).cause.debug\n// Empty\n\nZIO.attempt(5).cause.debug\n// Empty\n```\n\n----------------------------------------\n\nTITLE: File Reading with ZManaged Resource\nDESCRIPTION: Example of using ZManaged to safely handle a BufferedReader resource for reading the first line of a file, with proper resource cleanup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console._\ndef printFirstLine(file: String): ZIO[Console, Throwable, Unit] = {\n  def acquire(file: String) = ZIO.effect(new BufferedReader(new FileReader(file)))\n  def release(reader: BufferedReader) = ZIO.effectTotal(reader.close())\n\n  ZManaged.make(acquire(file))(release).use { reader =>\n    putStrLn(reader.readLine()) \n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Foreach with Unbounded Parallelism in ZIO 2.x (Scala)\nDESCRIPTION: Demonstrates how to run a parallel operation in ZIO 2.x without a predefined limit on the number of fibers. It uses `ZIO.foreachPar` followed by `.withParallelismUnbounded`. This allows the ZIO runtime to potentially create as many fibers as needed, constrained only by system resources, for executing the `download` tasks concurrently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nZIO.foreachPar(urls)(download).withParallelismUnbounded\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout in Scala using ZIO\nDESCRIPTION: This code shows how to implement a timeout for an effect in ZIO. It returns a new effect that succeeds with an Option value, where None indicates the timeout elapsed before the effect completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nZIO.succeed(\"Hello\").timeout(10.seconds)\n```\n\n----------------------------------------\n\nTITLE: Basic TestAspect Usage in Scala ZIO\nDESCRIPTION: Demonstrates the basic syntax for applying test aspects to individual tests and test suites using the @@ operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.{test, _}\n\ntest(\"a single test\") {\n  ???\n} @@ testAspect\n\nsuite(\"suite of multiple tests\") {\n  ???\n} @@ testAspect\n```\n\n----------------------------------------\n\nTITLE: Implementing Distributed Counter with ZIO Akka Cluster\nDESCRIPTION: A distributed counter application using Akka Cluster Sharding and PubSub features. Demonstrates cluster event handling, entity management, and message distribution across nodes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.ActorSystem\nimport com.typesafe.config.{Config, ConfigFactory}\nimport zio.akka.cluster.Cluster\nimport zio.akka.cluster.sharding.{Entity, Sharding}\nimport zio.console.putStrLn\nimport zio.{ExitCode, Has, Managed, Task, URIO, ZIO, ZLayer}\n\nsealed trait Counter extends Product with Serializable\ncase object Inc extends Counter\ncase object Dec extends Counter\n\ncase class CounterApp(port: String) {\n  val config: Config =\n    ConfigFactory.parseString(\n      s\"\"\"\n         |akka {\n         |  actor {\n         |    provider = \"cluster\"\n         |  }\n         |  remote {\n         |    netty.tcp {\n         |      hostname = \"127.0.0.1\"\n         |      port = $port\n         |    }\n         |  }\n         |  cluster {\n         |    seed-nodes = [\"akka.tcp://CounterApp@127.0.0.1:2551\"]\n         |  }\n         |}\n         |\"\"\".stripMargin)\n\n  val actorSystem: ZLayer[Any, Throwable, Has[ActorSystem]] =\n    ZLayer.fromManaged(\n      Managed.make(Task(ActorSystem(\"CounterApp\", config)))(sys =>\n        Task.fromFuture(_ => sys.terminate()).either\n      )\n    )\n\n  val counterApp: ZIO[zio.ZEnv, Throwable, Unit] =\n    actorSystem.build.use(sys =>\n      for {\n        queue <- Cluster\n          .clusterEvents(true)\n          .provideCustomLayer(ZLayer.succeedMany(sys))\n\n        pubsub <- zio.akka.cluster.pubsub.PubSub\n          .createPubSub[Int]\n          .provideCustomLayer(ZLayer.succeedMany(sys))\n\n        liveUsersLogger <- pubsub\n          .listen(\"LiveUsers\")\n          .flatMap(\n            _.take.tap(u => putStrLn(s\"Number of live users: $u\")).forever\n          )\n          .fork\n        totalRequestLogger <- pubsub\n          .listen(\"TotalRequests\")\n          .flatMap(\n            _.take.tap(r => putStrLn(s\"Total request until now: $r\")).forever\n          )\n          .fork\n\n        clusterEvents <- queue.take\n          .tap(x => putStrLn(\"New event in cluster: \" + x.toString))\n          .forever\n          .fork\n\n        counterEntityLogic = (c: Counter) =>\n          for {\n            entity <- ZIO.environment[Entity[Int]]\n            newState <- c match {\n              case Inc =>\n                entity.get.state.updateAndGet(s => Some(s.getOrElse(0) + 1))\n              case Dec =>\n                entity.get.state.updateAndGet(s => Some(s.getOrElse(0) - 1))\n            }\n            _ <- pubsub.publish(entity.get.id, newState.getOrElse(0)).orDie\n          } yield ()\n        cluster <- Sharding\n          .start(\"CounterEntity\", counterEntityLogic)\n          .provideCustomLayer(ZLayer.succeedMany(sys))\n\n        _ <- cluster.send(\"LiveUsers\", Inc)\n        _ <- cluster.send(\"TotalRequests\", Inc)\n        _ <- cluster.send(\"LiveUsers\", Dec)\n        _ <- cluster.send(\"LiveUsers\", Inc)\n        _ <- cluster.send(\"LiveUsers\", Inc)\n        _ <- cluster.send(\"TotalRequests\", Inc)\n        _ <- cluster.send(\"TotalRequests\", Inc)\n\n        _ <-\n          clusterEvents.join zipPar liveUsersLogger.join zipPar totalRequestLogger.join\n      } yield ()\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Executing External Commands with ZIO Process\nDESCRIPTION: Demonstrates using ZIO Process to interact with external commands including command piping, output streaming, and file redirection. The example shows running system commands like dmesg, cat, grep and database operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console.putStrLn\nimport zio.process.Command\nimport zio.{ExitCode, URIO}\n\nimport java.io.File\n\nobject ZIOProcessExample extends zio.App {\n\n  val myApp = for {\n    fiber <- Command(\"dmesg\", \"--follow\").linesStream\n      .foreach(putStrLn(_))\n      .fork\n    cpuModel <- (Command(\"cat\", \"/proc/cpuinfo\") |\n      Command(\"grep\", \"model name\") |\n      Command(\"head\", \"-n\", \"1\") |\n      Command(\"cut\", \"-d\", \":\", \"-f\", \"2\")).string\n    _ <- putStrLn(s\"CPU Model: $cpuModel\")\n    _ <- (Command(\"pg_dump\", \"my_database\") > new File(\"dump.sql\")).exitCode\n    _ <- fiber.join\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Event History and State from Edomata Backend with ZIO (Scala)\nDESCRIPTION: This Scala application queries the event history and current state for a given counter entity (FooCounter) via the Edomata backend repository, displaying the results with ZIO's debug logging. It uses ZIO stream interop to collect events from the backend and outputs the collected history/state. Dependencies are ZIO, Edomata, FS2, Cats Effect, and console logging. Inputs are the entity key, outputs are ZIO debug logs of history and state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.*\nimport zio.interop.catz.*\nimport zio.stream.interop.fs2z._\nimport cats.effect.std.Console\n\nobject ZIOStateAndHistory extends ZIOAppDefault {\n  given Console[Task] = Console.make[Task]\n\n  def run =\n    ZIO.scoped {\n      for {\n        backendService <- BackendService.buildBackend.orDie\n        history <- backendService.repository\n          .history(\"FooCounter\")\n          .toZStream()\n          .runCollect\n        state <- backendService.repository.get(\"FooCounter\")\n        _ <- ZIO.debug(s\"FooCounter History: $history\")\n        _ <- ZIO.debug(s\"FooCounter State: $state\")\n      } yield ()\n    }\n}\n\n// Output:\n// FooCounter History: Chunk(Valid(Counter(0),0),Valid(Counter(1),1),Valid(Counter(2),2),Valid(Counter(1),3),Valid(Counter(2),4))\n// FooCounter State: Valid(Counter(2),4)\n```\n\n----------------------------------------\n\nTITLE: Tapping Schedule Outputs\nDESCRIPTION: Demonstrates how to tap into schedule outputs for side effects like logging.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval tappedSchedule = Schedule.count.whileOutput(_ < 5).tapOutput(o => Console.printLine(s\"retrying $o\").orDie)\n```\n\n----------------------------------------\n\nTITLE: Complex Folding in ZIO with Content Handling\nDESCRIPTION: Demonstrates a more complex use of foldZIO in ZIO, handling both failure and success of a readUrls method and transforming the result into a Content type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval urls: ZIO[Any, Nothing, Content] =\n  readUrls(\"urls.json\").foldZIO(\n    error   => ZIO.succeed(Content.NoContent(error)), \n    success => fetchContent(success)\n  )\n```\n\n----------------------------------------\n\nTITLE: Mitigating Division by Zero with Input Validation - ZIO/Scala\nDESCRIPTION: This snippet enhances the prior example by ensuring the denominator is not zero before performing division. By using repeatUntil(_ != 0) on input, it prevents division by zero without generating a defect. Still relies on parsing user input as integer without explicit handling for conversation failures (NumberFormatException). Requires zio, java.io, and the Console module.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/examples.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\\nimport java.io.IOException\\n\\nobject MainApp extends ZIOAppDefault {\\n  def run =\\n    for {\\n      a <- readNumber(\"Enter the first number  (a): \")\\n      b <- readNumber(\"Enter the second number (b): \").repeatUntil(_ != 0)\\n      r <- divide(a, b)\\n      _ <- Console.printLine(s\"a / b: $r\")\\n    } yield ()\\n\\n  def readNumber(msg: String): ZIO[Any, IOException, Int] =\\n    Console.print(msg) *> Console.readLine.map(_.toInt)\\n\\n  def divide(a: Int, b: Int): ZIO[Any, Nothing, Int] = ZIO.succeed(a / b)\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Effect Using EmailService in Scala\nDESCRIPTION: This snippet creates a ZIO effect that uses the EmailService to send an email. It demonstrates how to create an effect that requires a specific service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-propagation.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval app: ZIO[EmailService, Nothing, Unit] = EmailService.send(\"john@doe.com\", \"Hello John!\")\n```\n\n----------------------------------------\n\nTITLE: Joining an Interrupted Fiber in ZIO Scala\nDESCRIPTION: Demonstrates how to join an interrupted fiber, showing that ZIO's concurrency model respects brackets even when joining an interrupted fiber.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nval myApp =\n  (\n    for {\n      fiber <- printLine(\"Running a job\").delay(1.seconds).forever.fork\n      _     <- fiber.interrupt.delay(3.seconds)\n      _     <- fiber.join // Joining an interrupted fiber\n    } yield ()\n  ).ensuring(\n    printLine(\n      \"This finalizer will be executed without occurring any deadlock\"\n    ).orDie\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Executor for ZIO Runtime\nDESCRIPTION: Shows how to create a custom executor using Java's ThreadPoolExecutor and configure it with ZIO Runtime. The example sets up a thread pool with minimum 5 and maximum 10 threads with a 5-second timeout.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.internal.Executor\nimport java.util.concurrent.{ThreadPoolExecutor, TimeUnit, LinkedBlockingQueue}\n\nval runtime = Runtime.default.mapPlatform(\n  _.withExecutor(\n    Executor.fromThreadPoolExecutor(_ => 1024)(\n      new ThreadPoolExecutor(\n        5,\n        10,\n        5000,\n        TimeUnit.MILLISECONDS,\n        new LinkedBlockingQueue[Runnable]()\n      )\n    )\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Offering with Fiber Suspension in Scala\nDESCRIPTION: Illustrates offering into a queue where the operation suspends due to full capacity. It forks the offer on a fiber, demonstrating how ZIO manages blocked producers. Requires only zio._. After dequeuing, the fiber resumes, showing synchronization.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval res2: UIO[Unit] = for {\\n  queue <- Queue.bounded[Int](1)\\n  _ <- queue.offer(1)\\n  f <- queue.offer(1).fork // will be suspended because the queue is full\\n  _ <- queue.take\\n  _ <- f.join\\n} yield ()\\n\n```\n\n----------------------------------------\n\nTITLE: Shrinking a TMap by Transforming Keys in ZIO STM\nDESCRIPTION: Demonstrates how transform can be used to shrink a TMap by mapping multiple keys to the same key, which effectively reduces the size of the map.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval shrinkTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  _    <- tMap.transform((_, v) => \"d\" -> v)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Custom Blocking Service with Cancellation Support\nDESCRIPTION: Implementation of a BlockingService class that handles cancellation through a flag-based approach rather than thread interruption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.util.concurrent.atomic.AtomicReference\n\nfinal case class BlockingService() {\n  private val released = new AtomicReference(false)\n\n  def start(): Unit = {\n    while (!released.get()) {\n      println(\"Doing some blocking operation\")\n      try Thread.sleep(1000)\n      catch {\n        case _: InterruptedException => () // Swallowing InterruptedException\n      }\n    }\n    println(\"Blocking operation closed.\")\n  }\n\n  def close(): Unit = {\n    println(\"Releasing resources and ready to be closed.\")\n    released.getAndSet(true)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Thread Pool Exhaustion with Blocking Tasks in Scala ZIO\nDESCRIPTION: This snippet demonstrates how blocking tasks can exhaust the primary thread pool in ZIO. It creates 20 blocking tasks that run in parallel, causing all threads to get stuck and preventing remaining tasks from executing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/blocking.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{ZIO, URIO}\nimport zio.console._ \ndef blockingTask(n: Int): URIO[Console, Unit] =\n  putStrLn(s\"running blocking task number $n\").orDie *>\n    ZIO.effectTotal(Thread.sleep(3000)) *>\n    blockingTask(n)\n\nval program = ZIO.foreachPar((1 to 100).toArray)(blockingTask)\n```\n\n----------------------------------------\n\nTITLE: Accessing ZIO Service with for-comprehension\nDESCRIPTION: Demonstrates how to access a ZIO service using ZIO.service within a for-comprehension.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval effect: ZIO[A, Nothing, String] =\n  for {\n    a <- ZIO.service[A] \n    r <- a.foo\n  } yield r\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#timeout with Interruptible Effect Timeout in Scala\nDESCRIPTION: Illustrates the `ZIO#timeout` operator with a 1-second timeout applied to the `myApp` effect (which takes 2 seconds). Because the timeout duration is shorter than the effect's execution time and the effect is interruptible by default, the effect is interrupted after 1 second, and the resulting effect yields `None`. The execution time reflects the timeout duration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/timing-out.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run =\n    myApp\n      .timeout(1.second)\n      .debug(\"output\")\n      .timed\n      .map(_._1.toMillis / 1000)\n      .debug(\"execution time of the whole program in second\")\n}\n\n// Output:\n// start doing something.\n// output: None\n// execution time of the whole program in second: 1\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Combined Service Implementation in Scala ZIO\nDESCRIPTION: Implementation of a combined service that implements multiple service interfaces. This is a workaround approach before introducing the Has type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval LoggingWithRandomIntLive = new Logging with RandomInt {\n  override def log(line: String): UIO[Unit] =\n    ZIO.effectTotal(println(line))\n\n  override def random: UIO[Int] =\n    ZIO.effectTotal(scala.util.Random.nextInt())\n}\n```\n\n----------------------------------------\n\nTITLE: Testing GraphQL API with cURL\nDESCRIPTION: A cURL command to send a GraphQL query to the API endpoint for retrieving software developers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/graphql-webservice.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl 'http://localhost:8088/api/graphql' --data-binary '{\"query\":\"query{\\n employees(role: SoftwareDeveloper){\\n name\\n role\\n}\\n}\"}'\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO#orElse Method Signature in Scala\nDESCRIPTION: This snippet shows the method signature for the `orElse` combinator within the ZIO trait. It takes another ZIO effect (`that`) as a parameter, which will be executed if the original effect fails. Both effects must be compatible in terms of their requirement (`R1 <: R`) and success types (`A1 >: A`), and the resulting effect's error type is determined by the fallback effect (`E2`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def orElse[R1 <: R, E2, A1 >: A](that: => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Repeats in ZIO Tests\nDESCRIPTION: Example showing how to repeat a test multiple times using the repeats test aspect. The test will be repeated 5 times to ensure stability.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/configuring-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\ntest(\"repeating a test\") {\n  ZIO.attempt(\"Repeating a test to ensure its stability\")\n    .debug\n    .map(_ => assertTrue(true))\n} @@ TestAspect.nonFlaky @@ TestAspect.repeats(5)\n```\n\n----------------------------------------\n\nTITLE: Configuring Scala.js Build Dependencies for ZIO\nDESCRIPTION: Build configuration snippet showing how to include ZIO in a Scala.js project by adding necessary dependencies and settings to build.sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-javascript.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscalaJSUseMainModuleInitializer := true\nlibraryDependencies += \"dev.zio\" %%% \"zio\" % \"${zio.BuildInfo.version}\"\n```\n\n----------------------------------------\n\nTITLE: Compiling Test Source Code with SBT - Bash\nDESCRIPTION: This code runs the 'Test/compile' command in an active sbt session, compiling only the project's tests. It requires sbt to be running in the project's root. Compiled test classes will be output to the test target directory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nTest/compile\n```\n\n----------------------------------------\n\nTITLE: Asserting Map Keys Satisfy Condition in Scala\nDESCRIPTION: Creates an assertion `Assertion[Map[K, V]]` that checks if the keys of a `Map` (as an `Iterable[K]`) satisfy the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nhasKeys[K, V](assertion: Assertion[Iterable[K]])\n```\n\n----------------------------------------\n\nTITLE: Illustrating Fail-Fast Behavior of ZIO.foreach in Scala\nDESCRIPTION: This example demonstrates how ZIO.foreach fails when it encounters the first error in a collection transformation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/error-accumulation.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, String, List[Int]] =\n    ZIO.foreach(List(1, 2, 3, 4, 5)) { n =>\n      if (n < 4)\n        ZIO.succeed(n)\n      else\n        ZIO.fail(s\"$n is not less that 4\")\n    }\n\n  def run = myApp.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Dropping Hub Constructor in Scala\nDESCRIPTION: Defines the signature for creating a dropping Hub with a specified capacity. The actual implementation is not provided in this snippet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef dropping[A](requestedCapacity: Int): UIO[Hub[A]] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: Unexpected Error with ZIO.die - Crash on Division by Zero - Scala\nDESCRIPTION: Implements a division function that kills the effect (unrecoverable error) using ZIO.die when dividing by zero, treating it as a defect rather than a typed failure. Focuses on unexpected or unrecoverable errors. Requires zio._. Inputs: two integers; Output: ZIO effect that never fails in the typed error channel but may die as a defect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n  if (b == 0)\n    ZIO.die(new ArithmeticException(\"divide by zero\")) // Unexpected error\n  else\n    ZIO.succeed(a / b)\n```\n\n----------------------------------------\n\nTITLE: Creating a Failing Channel with ZChannel.fail in Scala\nDESCRIPTION: Creates a ZChannel that fails with a specified error. This channel won't produce any data or succeed with a done value, as it fails immediately with the provided exception.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/creating-channels.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\nimport zio.stream._\n\nval channel: ZChannel[Any, Any, Any, Any, Exception, Nothing, Nothing] = \n  ZChannel.fail(new Exception(\"error\"))\n```\n\n----------------------------------------\n\nTITLE: Transforming All Elements in a TArray in ZIO STM (Scala)\nDESCRIPTION: Applies a transformation function to every element in the TArray. In this example, each element is squared using the transform method which applies the given function to all elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformTArray: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.transform(a => a * a)\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Transforming Sink Input with Contramap in Scala ZIO\nDESCRIPTION: This snippet demonstrates how to use the contramap operation to change the input type of a ZSink. It converts a numeric sum sink to accept String inputs by applying a conversion function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/operations.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nval numericSum: ZSink[Any, Nothing, Int, Nothing, Int]    = \n  ZSink.sum[Int]\nval stringSum : ZSink[Any, Nothing, String, Nothing, Int] = \n  numericSum.contramap((x: String) => x.toInt)\n\nval sum: ZIO[Any, Nothing, Int] =\n  ZStream(\"1\", \"2\", \"3\", \"4\", \"5\").run(stringSum)\n// Output: 15\n```\n\n----------------------------------------\n\nTITLE: Effectfully Folding Elements in a TMap in ZIO STM\nDESCRIPTION: Uses foldSTM to effectfully fold the elements of a TMap. This allows folding operations that might need to perform additional STM operations during the folding process.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldSTMTMap: UIO[Int] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  sum  <- tMap.foldSTM(0) { case (acc, (_, v)) => STM.succeed(acc + v) }\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: Scope Usage Example with Finalizer\nDESCRIPTION: Demonstrates creating a scope, adding a finalizer, and closing the scope with proper resource cleanup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  scope <- Scope.make\n  _ <- ZIO.debug(\"Scope is created!\")\n  _ <- scope.addFinalizer(\n    for {\n      _ <- ZIO.debug(\"The finalizer is started!\")\n      _ <- ZIO.sleep(5.seconds)\n      _ <- ZIO.debug(\"The finalizer is done!\")\n    } yield ()\n  )\n  _ <- ZIO.debug(\"Leaving scope!\")\n  _ <- scope.close(Exit.succeed(()))\n  _ <- ZIO.debug(\"Scope is closed!\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Using Auto-Reloadable Services in a ZIO Application\nDESCRIPTION: Example of a ZIO application that uses an automatically reloadable Counter service, demonstrating service interaction without manual reloading.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.util.UUID\n\nobject AutoReloadableExample extends ZIOAppDefault {\n  val app: ZIO[Reloadable[Counter], Any, Unit] =\n    for {\n      reloadable <- ZIO.service[Reloadable[Counter]]\n      counter <- reloadable.get\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug(\"Counter value is\")\n      _ <- ZIO.sleep(6.second)\n      counter <- reloadable.get // getting reloadable service from environment\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug(\"Counter value is\")\n    } yield ()\n\n  def run = app.provide(Counter.autoReloadable)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Robust Long-Running Application using ZStream.mergeAllUnbounded\nDESCRIPTION: This example shows a declarative approach to implement a long-running application using ZStream.mergeAllUnbounded, which combines all streaming components concurrently into one application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nval managedApp =\n  for {\n  //_ <- other resources\n    _ <- ZStream\n      .mergeAllUnbounded(16)(\n        kafkaConsumer.drain,\n        ZStream.fromEffect(httpServer),\n        ZStream.fromEffect(scheduledJobRunner)\n      )\n      .runDrain\n      .toManaged_\n  } yield ()\n\nval myApp = managedApp.use_(ZIO.unit).exitCode\n```\n\n----------------------------------------\n\nTITLE: Converting Typed Errors to Unchecked Failures in Scala ZIO\nDESCRIPTION: This snippet demonstrates how to use ZIO's orDie method to convert a typed error (IOException) into an unchecked failure, effectively letting the fiber crash on error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/dont-type-unexpected-errors.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nConsole.printLine(\"Hello, World\") // ZIO[Any, IOException, Unit]\n  .orDie                          // ZIO[Any, Nothing, Unit]\n```\n\n----------------------------------------\n\nTITLE: Migrating ZManaged to Scope in Scala\nDESCRIPTION: Example of migrating from ZManaged to Scope in ZIO 2.0, showing changes in type signatures and resource handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_68\n\nLANGUAGE: scala\nCODE:\n```\nobject HttpClient {\n-   def make(): ZManaged[Config, IOException, HttpClient] = ???\n+   def make(): ZIO[Config with Scope, IOException, HttpClient] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Mean Age Using Ref.Synchronized and Parallel Effects in Scala\nDESCRIPTION: Illustrates a real-world use case of Ref.Synchronized where parallel effects are used to update a shared state. The example fetches ages for a list of users in parallel, updates a shared sum, and calculates the mean age.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/refsynchronized.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval meanAge =\n  for {\n    ref <- Ref.Synchronized.make(0)\n    _ <- ZIO.foreachPar(users) { user =>\n      ref.updateZIO(sumOfAges =>\n        api.getAge(user).map(_ + sumOfAges)\n      )\n    }\n    v <- ref.get\n  } yield (v / users.length)\n```\n\n----------------------------------------\n\nTITLE: Using catchAll for Selective Error Handling in ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#catchAll to handle specific error types differently. The example demonstrates handling two different error messages by switching to different streams based on the error value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval first =\n  ZStream(1, 2, 3) ++\n    ZStream.fail(\"Uh Oh!\") ++\n    ZStream(4, 5) ++\n    ZStream.fail(\"Ouch\")\n\nval second = ZStream(6, 7, 8)\nval third = ZStream(9, 10, 11)\n\nval stream = first.catchAll {\n  case \"Uh Oh!\" => second\n  case \"Ouch\"   => third\n}\n// Output: 1, 2, 3, 6, 7, 8\n```\n\n----------------------------------------\n\nTITLE: Parallel Mapping with mapMPar in ZIO Streams\nDESCRIPTION: Shows how to perform parallel mapping operations on stream elements using mapMPar.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\ndef fetchUrl(url: URL): Task[String] = Task.succeed(???)\ndef getUrls: Task[List[URL]] = Task.succeed(???)\n\nval pages = ZStream.fromIterableM(getUrls).mapMPar(8)(fetchUrl)\n```\n\n----------------------------------------\n\nTITLE: Setting Value in TRef with Multiple Transactions\nDESCRIPTION: Shows how to set a value in a TRef using multiple transactions. First, it creates and commits a TRef, then sets a new value and retrieves it in a separate committed transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval setMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  nValue <- tRef.set(20).flatMap(_ => tRef.get).commit\n} yield nValue\n```\n\n----------------------------------------\n\nTITLE: Manual Acquire and Release of TSemaphore for an STM Action\nDESCRIPTION: Demonstrates the manual approach to execute an STM action with acquire and release calls. This example shows how to wrap an arbitrary STM action between semaphore acquire and release operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tsemaphore.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\ndef yourSTMAction: STM[Nothing, Unit] = STM.unit\n\nval tSemaphoreWithoutPermit: STM[Nothing, Unit] = \n  for {\n    sem <- TSemaphore.make(1L)\n    _   <- sem.acquire\n    a   <- yourSTMAction\n    _   <- sem.release\n  } yield a\n\ntSemaphoreWithoutPermit.commit\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query Definitions\nDESCRIPTION: Definition of GraphQL queries for fetching employees\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\ntype Queries {\n  employees(role: Role!): [Employee!]!\n}\n```\n\nLANGUAGE: graphql\nCODE:\n```\ntype Queries {\n  employee(name: String!): Employee\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing `parseInt` using `unrefineTo` in ZIO Scala\nDESCRIPTION: Shows an alternative `parseInt` implementation starting with `ZIO.succeed`. Since `ZIO.succeed` has `Nothing` as its error type, `unrefineTo[NumberFormatException]` broadens the error channel. If `input.toInt` were to throw an exception (making the effect die with a defect), this operator makes it *possible* (though not guaranteed without further handling) to later catch defects specifically matching `NumberFormatException` as typed errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef parseInt(input: String): ZIO[Any, NumberFormatException, Int] =\n  ZIO.succeed(input.toInt)              // ZIO[Any, Nothing, Int]\n    .unrefineTo[NumberFormatException]  // ZIO[Any, NumberFormatException, Int]\n```\n\n----------------------------------------\n\nTITLE: ZIO Loop Examples\nDESCRIPTION: Provides various examples of using ZIO's loop and loopDiscard operators for different scenarios.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\nimport zio._\n\nval r1: ZIO[Any, Nothing, List[Int]] =\n  ZIO.loop(1)(_ <= 5, _ + 1)(n => ZIO.succeed(n)).debug\n// List(1, 2, 3, 4, 5)\n\nval r2: ZIO[Any, Nothing, List[Int]] =\n  ZIO.loop(1)(_ <= 5, _ + 1)(n => ZIO.succeed(n * 2)).debug\n// List(2, 4, 6, 8, 10)\n\nval r3: ZIO[Any, IOException, List[Unit]] =\n  ZIO.loop(1)(_ <= 5, _ + 1) { index =>\n    Console.printLine(s\"Currently at index $index\")\n  }.debug\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// Currently at index 5\n// List((), (), (), (), ())\n\nval r4: ZIO[Any, IOException, Unit] =\n  ZIO.loopDiscard(1)(_ <= 5, _ + 1) { index =>\n    Console.printLine(s\"Currently at index $index\")\n  }.debug\n// Currently at index 1\n// Currently at index 2\n// Currently at index 3\n// Currently at index 4\n// Currently at index 5\n// ()\n\nval r5: ZIO[Any, IOException, List[String]] =\n  Console.printLine(\"Please enter three names: \") *>\n    ZIO.loop(1)(_ <= 3, _ + 1) { n =>\n      Console.print(s\"$n. \") *> Console.readLine\n    }.debug\n// Please enter three names:\n// 1. John\n// 2. Jane\n// 3. Joe\n// List(John, Jane, Joe)\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response from GraphQL Query\nDESCRIPTION: Sample JSON response from the GraphQL API showing the structure of the data returned when querying for employees with the SoftwareDeveloper role.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/caliban.md#2025-04-23_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\" : {\n    \"employees\" : [\n      {\n        \"name\" : \"Maria\",\n        \"role\" : \"SoftwareDeveloper\"\n      },\n      {\n        \"name\" : \"Peter\",\n        \"role\" : \"SoftwareDeveloper\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating fold Interruption Limitations in MainApp - Scala\nDESCRIPTION: Defines a ZIO application where an interrupted fiber is followed by fold. Because fold does not handle InterruptedException, this application will crash. Illustrates operator limitations for fiber interruption recovery. Uses zio and ZIOAppDefault.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = (ZIO.interrupt *> ZIO.fail(\"Uh oh!\")).fold(_ => (), _ => ())\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Get Operation Example - Scala\nDESCRIPTION: Examples of using the get operation to retrieve values from a Ref using different syntactic approaches\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nRef.make(\"initial\")\n   .flatMap(_.get)\n   .flatMap(current => putStrLn(s\"current value of ref: $current\"))\n```\n\n----------------------------------------\n\nTITLE: Publishing ZStream Values to Hub with Take in Scala\nDESCRIPTION: Demonstrates publishing values from a ZStream to a Hub using Take, which allows for handling of different stream states (emitting values, errors, or completion).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  promise <- Promise.make[Nothing, Unit]\n  hub     <- Hub.bounded[Take[Nothing, String]](2)\n  scoped  = ZStream.fromHubScoped(hub).tap(_ => promise.succeed(()))\n  stream   = ZStream.unwrapScoped(scoped).flattenTake\n  fiber   <- stream.take(2).runCollect.fork\n  _       <- promise.await\n  _       <- ZStream(\"Hello\", \"World\").runIntoHub(hub)\n  _       <- fiber.join\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Implementing Traversal with ZIO and Scalaz\nDESCRIPTION: Demonstrates how to use Scalaz's traverse functionality with ZIO effects to transform a collection of user IDs into a collection of users. Shows integration between ZIO effects and Scalaz's IList data structure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-scalaz-7x.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scalaz._, Scalaz._\nimport zio.interop.scalaz72._\n\ntype Database = IList[User]\n\ndef findUser(id: UserId): ZIO[Database, UserError, User] = ...\ndef findUsers(ids: IList[UserId]): ZIO[Database, UserError, IList[User]] = ids.traverse(findUser(_))\n```\n\n----------------------------------------\n\nTITLE: Defining a Document Domain Model in Scala ZIO\nDESCRIPTION: Defines the domain model classes Doc and Metadata for a document management system, with fields for document properties like title, description, language, format, and content.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Doc(\n    title: String,\n    description: String,\n    language: String,\n    format: String,\n    content: Array[Byte]\n)\ncase class Metadata(\n    title: String,\n    description: String,\n    language: String,\n    format: String\n)\n```\n\n----------------------------------------\n\nTITLE: Composing STM Transactions in Scala\nDESCRIPTION: Example of composing STM transactions using flatMap and orElse combinators. These operations allow for creating complex, atomic transactions from simpler ones.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nSTM#commit\nSTM.atomically\nSTM#flatMap\nSTM#orElse\n```\n\n----------------------------------------\n\nTITLE: Starting Kafka Cluster with Docker Compose\nDESCRIPTION: Command to start the Kafka cluster using Docker Compose.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ docker compose up -d\n```\n\n----------------------------------------\n\nTITLE: Cyclic Behavior Example with Multiple Tasks\nDESCRIPTION: Demonstrates the cyclic nature of the barrier with more tasks than the barrier size.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/cyclicbarrier.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent.CyclicBarrier\n\nobject MainApp extends ZIOAppDefault {\n\n  def task(name: String) =\n    for {\n      b <- ZIO.service[CyclicBarrier]\n      _ <- ZIO.debug(s\"task-$name: started my job right now!\")\n      d <- Random.nextLongBetween(1000, 10000)\n      _ <- ZIO.sleep(Duration.fromMillis(d))\n      _ <- ZIO.debug(s\"task-$name: finished my job and waiting for other parties to finish their jobs\")\n      _ <- b.await\n      _ <- ZIO.debug(s\"task-$name: the barrier is now broken, so I'm going to exit immediately!\")\n    } yield ()\n\n  def run =\n    for {\n      b <- CyclicBarrier.make(\n             parties = 3,\n             action = ZIO.debug(\n               \"The barrier is released right now!\" +\n                 \"I can do some effectful actions on release of barrier.\"\n             )\n           )\n      tasks = task(\"1\") <&>\n                task(\"2\") <&>\n                task(\"3\") <&>\n                task(\"4\") <&>\n                task(\"5\")\n      _ <- tasks.provide(ZLayer.succeed(b))\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Reloadable Counter Service with Reload Operation\nDESCRIPTION: Shows a complete example of using a Reloadable Counter service, including incrementing the counter and reloading the service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval app: ZIO[Reloadable[Counter], Any, Unit] =\n  for {\n    reloadable <- ZIO.service[Reloadable[Counter]]\n    counter    <- reloadable.get\n    _          <- counter.increment\n    _          <- counter.increment\n    _          <- counter.increment\n    _          <- counter.get.debug(\"Counter value is\")\n    _          <- reloadable.reload\n    counter    <- reloadable.get\n    _          <- counter.increment\n    _          <- counter.increment\n    _          <- counter.get.debug(\"Counter value is\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Configuring Sample Size in ZIO Tests\nDESCRIPTION: Example demonstrating how to customize the number of samples for property-based testing. Sets the number of samples to 50 for checking a random variable.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/configuring-tests.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\ntest(\"customized number of samples\") {\n  for {\n    ref <- Ref.make(0)\n    _ <- check(Gen.int)(_ => assertZIO(ref.update(_ + 1))(Assertion.anything))\n    value <- ref.get\n  } yield assertTrue(value == 50)\n} @@ TestAspect.samples(50)\n```\n\n----------------------------------------\n\nTITLE: Setting a TRef Value Across Multiple Transactions in Scala ZIO STM\nDESCRIPTION: Creates a TRef in one transaction and then sets its value and retrieves the new value in another transaction. Demonstrates chaining operations in a single transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval setMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  nValue <- tRef.set(20).flatMap(_ => tRef.get).commit\n} yield nValue\n```\n\n----------------------------------------\n\nTITLE: Applying a ZIO Counter Incrementing by Effect Output in Scala\nDESCRIPTION: Applies the `countBytes` counter aspect (created previously) to a `Random.nextLongBetween(0, 100)` effect using the `@@` operator. The \"countBytes\" counter will be incremented by the specific random `Long` value generated by the effect each time `myApp` is executed. Requires `zio.Random`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/counter.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval myApp = Random.nextLongBetween(0, 100) @@ countBytes\n```\n\n----------------------------------------\n\nTITLE: Implementing Age Validation with Custom Exceptions in ZIO (Scala)\nDESCRIPTION: This snippet defines a sealed trait and case classes for exception handling specific to age validation, along with a validate function that checks for illegal or negative ages and returns the appropriate ZIO effect. The function requires no dependencies and produces either a failure with a specific AgeValidationException or a success with the age value. It demonstrates the use of ZIO.fail and ZIO.succeed for error modeling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] =\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n```\n\n----------------------------------------\n\nTITLE: Taking Single Element from TQueue in Scala ZIO\nDESCRIPTION: Retrieves and removes the first element from a TQueue, blocking if the queue is empty.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueTake: UIO[Int] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offerAll(List(1, 2))\n  res    <- tQueue.take\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Safe State Management in Concurrent Scala Applications\nDESCRIPTION: Shows a safe way to manage state in concurrent applications using the update method, which modifies the Ref atomically and avoids race conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// Safe State Management\nobject CountRequests extends ZIOAppDefault {\n\n  def request(counter: Ref[Int]): ZIO[Any, Nothing, Unit] = {\n    for {\n      _ <- counter.update(_ + 1)\n      reqNumber <- counter.get\n      _ <- Console.printLine(s\"request number: $reqNumber\").orDie\n    } yield ()\n  }\n\n  private val initial = 0\n  private val myApp =\n    for {\n      ref <- Ref.make(initial)\n      _ <- request(ref) zipPar request(ref)\n      rn <- ref.get\n      _ <- Console.printLine(s\"total requests performed: $rn\").orDie\n    } yield ()\n\n  def run = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: Functional Data Modeling in Scala\nDESCRIPTION: Demonstrates functional data modeling using sum and product types (Algebraic Data Types) to represent event data.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/functional-design-patterns.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncase class Event(id: String, timestamp: Long, details: EventType)\n\nsealed trait EventType\nobject EventType {\n  final case class ClickEvent(element: String) extends EventType\n  final case class ViewEvent(page: String) extends EventType\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Defects and Mapping Errors with `unrefineWith` in ZIO Scala\nDESCRIPTION: Provides an example using `unrefineWith`. An effect `effect` either fails with a typed error `Foo` or dies with a defect `Bar`. `unrefineWith` is used with a partial function `{ case e: Bar => e.getMessage }` to catch the `Bar` defect and turn it into a typed `String` error. The second function `(e => e.getMessage)` maps any original typed `Foo` errors also into `String` errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  case class Foo(msg: String) extends Exception(msg)\n  case class Bar(msg: String) extends Exception(msg)\n\n  val effect: ZIO[Any, Foo, Nothing] =\n    ZIO.ifZIO(Random.nextBoolean)(\n      onTrue = ZIO.fail(Foo(\"Oh uh!\")),\n      onFalse = ZIO.die(Bar(\"Boom!\"))\n    )\n\n  val unrefined: ZIO[Any, String, Nothing] =\n    effect\n      .unrefineWith {\n        case e: Bar => e.getMessage\n      }(e => e.getMessage)\n\n  def run = unrefined.cause.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Using CountdownLatch for Synchronization in ZIO Scala\nDESCRIPTION: This example demonstrates typical usage of a CountdownLatch in ZIO. It creates a latch with a count of 100, forks 10 fibers that wait on the latch before incrementing a counter, then counts down the latch 100 times to release the waiting fibers. It validates that all 10 fibers executed after the latch was released.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/countdownlatch.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent.CountdownLatch\n\nfor {\n  latch  <- CountdownLatch.make(100)\n  count  <- Ref.make(0)\n  ps     <- ZIO.collectAll(List.fill(10)(Promise.make[Nothing, Unit]))\n  _      <- ZIO.forkAll(ps.map(p => latch.await *> count.update(_ + 1) *> p.succeed(())))\n  _      <- latch.countDown.repeat(Schedule.recurs(99))\n  _      <- ZIO.foreach_(ps)(_.await)\n  result <- count.get\n} yield assert(result == 10)\n```\n\n----------------------------------------\n\nTITLE: Creating a TSemaphore in Scala ZIO\nDESCRIPTION: Demonstrates how to create a TSemaphore with a specified number of permits. This example creates a semaphore with 10 initial permits using the TSemaphore.make method within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tsemaphore.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreCreate: STM[Nothing, TSemaphore] = TSemaphore.make(10L)\n```\n\n----------------------------------------\n\nTITLE: Creating a Function-Based Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that always recurs, mapping input values through a specified function (incrementing integers in this example).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval inc = Schedule.fromFunction[Int, Int](_ + 1)\n```\n\n----------------------------------------\n\nTITLE: Implementing Resource Pool Example\nDESCRIPTION: Example showing creation and usage of a ZPool with UUID resources, demonstrating resource acquisition and release patterns.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zpool.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject PoolExample extends ZIOAppDefault {\n  def resource: ZIO[Scope, Nothing, UUID] = ZIO.acquireRelease(\n    ZIO.random.flatMap(_.nextUUID).flatMap(uuid => ZIO.debug(s\"Acquiring the resource: $uuid!\").as(uuid))\n  )(uuid => ZIO.debug(s\"Releasing the resource $uuid!\"))\n\n  def run =\n    for {\n      pool <- ZPool.make(resource, 3)\n      item <- pool.get\n      _ <- ZIO.debug(s\"Item: $item\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Doobie Transactor for Cats Effect 2\nDESCRIPTION: Implementation of a custom HikariCP transactor for Doobie with Cats Effect 2, using ZIO's blocking thread pool for JDBC operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.ZManaged\nimport zio.{ Runtime, Task, ZIO, ZManaged }\nimport doobie.hikari.HikariTransactor\nimport cats.effect.Blocker\nimport zio.interop.catz._\n\ndef transactor: ZManaged[Any, Throwable, HikariTransactor[Task]] =\n  for {\n    rt <- ZIO.runtime[Any].toManaged\n    be <- ZIO.blockingExecutor.toManaged                          \n    xa <- HikariTransactor\n            .newHikariTransactor[Task](\n              \"org.h2.Driver\",                                    \n              \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\",               \n              \"sa\",                                               \n              \"\",                                                 \n              be.asExecutionContext,                              \n              Blocker.liftExecutionContext(be.asExecutionContext) \n            )\n            .toManagedZIO\n  } yield xa\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Descriptor with Magnolia - Scala\nDESCRIPTION: This code creates an implicit configuration descriptor in the companion object of `HttpServerConfig` using ZIO Config's Magnolia integration. The descriptor enables automatic mapping from configuration sources to the `HttpServerConfig` case class, required by ZIO's configuration loading system. It nests configuration under the 'HttpServerConfig' key for structured loading.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.config._\nimport zio.Config\nimport zio.config.magnolia.deriveConfig\n\nobject HttpServerConfig {\n  implicit val config: Config[HttpServerConfig] =\n    deriveConfig[HttpServerConfig].nested(\"HttpServerConfig\")\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Test Spec2 with Shared Counter in Scala\nDESCRIPTION: This snippet demonstrates the implementation of Spec2, which also extends SharedCounterSpec and includes a test that increments the shared Counter.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/sharing-layers-between-multiple-files.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nobject Spec2 extends SharedCounterSpec {\n  override def spec: Spec[Scope with Counter, Any] =\n    test(\"test2\") {\n      assertTrue(true)\n    } @@ TestAspect.after(Counter.inc)\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Expected Output with Lazy Evaluation in ZIO 2.x (Scala Output)\nDESCRIPTION: Provides sample console output for the ZIO 2.x lazy evaluation example using `bracket` (or `acquireReleaseWith`) with a by-name parameter. It shows three distinct random numbers, confirming that the effect was executed multiple times as expected due to lazy evaluation, contrasting with the ZIO 1.x behavior.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n355191016\n2046799548\n333146616\n```\n\n----------------------------------------\n\nTITLE: Batch Processing with Synchronous Aggregation in Scala\nDESCRIPTION: This example demonstrates batch processing by aggregating single elements into chunks of 5 using ZTransducer.collectAllN. The source stream is tapped to display each element being produced, while the sink processes batches with artificial delay.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_58\n\nLANGUAGE: scala\nCODE:\n```\nval source =\n  ZStream\n    .iterate(1)(_ + 1)\n    .take(200)\n    .tap(x =>\n      putStrLn(s\"Producing Element $x\")\n        .schedule(Schedule.duration(1.second).jittered)\n    )\n\nval sink = \n  ZSink.foreach((e: Chunk[Int]) =>\n    putStrLn(s\"Processing batch of events: $e\")\n      .schedule(Schedule.duration(3.seconds).jittered)\n  )\n  \nval myApp = \n  source.aggregate(ZTransducer.collectAllN[Int](5)).run(sink)\n```\n\n----------------------------------------\n\nTITLE: Setting Value in TRef with a Single Transaction\nDESCRIPTION: Demonstrates how to set a new value in a TRef within a single transaction. The transaction creates the TRef, sets a new value, and retrieves the updated value before committing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval setSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  _ <- tRef.set(20)\n  nValue <- tRef.get\n} yield nValue).commit\n```\n\n----------------------------------------\n\nTITLE: Using ZIO When Operator for Weight Validation\nDESCRIPTION: Shows how to use ZIO's when operator as an alternative to if-then expressions for weight validation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef validateWeightOption(weight: Double): ZIO[Any, Nothing, Option[Double]] =\n  ZIO.when(weight > 0)(ZIO.succeed(weight))\n```\n\n----------------------------------------\n\nTITLE: Streaming with Apache Pulsar and ZIO\nDESCRIPTION: Complete example showing how to produce and consume messages with Apache Pulsar using ZIO Pulsar. This example demonstrates creating a producer that sends messages and a consumer that reads them using ZIO streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\nimport org.apache.pulsar.client.api.{PulsarClientException, Schema}\nimport zio._\nimport zio.blocking._\nimport zio.clock._\nimport zio.console._\nimport zio.pulsar._\nimport zio.stream._\n\nimport java.nio.charset.StandardCharsets\n\nobject StreamingExample extends zio.App {\n  val topic = \"my-topic\"\n\n  val producer: ZManaged[Has[PulsarClient], PulsarClientException, Unit] =\n    for {\n      sink <- Producer.make(topic, Schema.STRING).map(_.asSink)\n      _ <- Stream.fromIterable(0 to 100).map(i => s\"Message $i\").run(sink).toManaged_\n    } yield ()\n\n  val consumer: ZManaged[Has[PulsarClient] with Blocking with Console, PulsarClientException, Unit] =\n    for {\n      builder <- ConsumerBuilder.make(Schema.STRING).toManaged_\n      consumer <- builder\n        .subscription(Subscription(\"my-subscription\", SubscriptionType.Exclusive))\n        .topic(topic)\n        .build\n      _ <- consumer.receiveStream.take(10).foreach { e =>\n        consumer.acknowledge(e.getMessageId) *>\n          putStrLn(new String(e.getData, StandardCharsets.UTF_8)).orDie\n      }.toManaged_\n    } yield ()\n\n  val myApp =\n    for {\n      f <- consumer.fork\n      _ <- producer\n      _ <- f.join.toManaged_\n    } yield ()\n\n  def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    myApp\n      .provideCustomLayer(\n        (Console.live ++ Clock.live) >+>\n          PulsarClient.live(\"localhost\", 6650)\n      ).useNow.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Using a ZIO Counter with Repeating Effects in Scala\nDESCRIPTION: Creates a `Counter` named \"request_counts\" inline and applies it as an aspect to the `zio.Random.nextLongBounded(10)` effect. The effect is executed repeatedly using `repeatUntil` until the generated random number equals 7, incrementing the \"request_counts\" counter on each repetition (execution) of the effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/counter.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n(zio.Random.nextLongBounded(10) @@ Metric.counter(\"request_counts\")).repeatUntil(_ == 7)\n```\n\n----------------------------------------\n\nTITLE: Converting ZStream to FS2 Stream with interop-cats (Scala)\nDESCRIPTION: Shows how to convert a ZIO ZStream into an FS2 Stream using the toFs2Stream extension. By importing zio.stream.interop.fs2z and constructing a ZStream from chunks, this enables integration with FS2's ecosystem. Key inputs are chunk values; the result is an FS2 Stream representation. Dependencies are zio.stream, zio.Chunk, and interop.fs2z.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream.ZStream\nimport zio.Chunk\nimport zio.stream.interop.fs2z._\nval fs2stream = ZStream.fromChunks(Chunk(1, 2, 3, 4)).toFs2Stream\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Service with Proper Type Parameters\nDESCRIPTION: Example of a polymorphic KeyValueStore service with type parameters K and V, showing how @accessible macro works with proper type parameters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros.accessible\n\n\n@accessible\ntrait KeyValueStore[K, V] {\n  def set(key: K, value: V): Task[V]\n\n  def get(key: K): Task[V]\n}\n\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set(\"key\", 5)\n      key <- KeyValueStore.get[String, Int](\"key\")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Reloadable Constructors in Scala\nDESCRIPTION: Definition of the two primary constructors for Reloadable services: manual for explicit reloading and auto for scheduled automatic reloading.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject Reloadable {\n  def manual[In, E, Out](\n      layer: ZLayer[In, E, Out]\n    ): ZLayer[In, E, Reloadable[Out]] = ???\n    \n  def auto[In, E, Out](\n      layer: ZLayer[In, E, Out],\n      schedule: Schedule[In, Any, Any]\n    ): ZLayer[In, E, Reloadable[Out]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Java Future to ZIO Fiber\nDESCRIPTION: Shows how to convert a Java Future to a ZIO Fiber for HTTP client operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-java.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef execute(client: HttpAsyncClient, request: HttpUriRequest): Fiber[Throwable, HttpResponse] =\n    Fiber.fromFutureJava {\n        client.execute(request, null)\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing an In-Memory Key-Value Store in ZIO\nDESCRIPTION: A concrete implementation of the KeyValueStore service interface using an in-memory Map wrapped in a ZIO Ref for thread-safe concurrent access. The implementation provides methods for getting, setting, and removing String keys with Int values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, String, IO] {\n\n  override def get(key: String): IO[String, Int] =\n    map.get.map(_.get(key)).someOrFail(s\"$key not found\")\n\n  override def set(key: String, value: Int): IO[String, Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def remove(key: String): IO[String, Unit] =\n    map.update(_.removed(key))\n}\n\nobject InmemoryKeyValueStore {\n  def layer: ULayer[KeyValueStore[String, Int, String, IO]] =\n    ZLayer {\n      Ref.make(Map[String, Int]()).map(InmemoryKeyValueStore.apply)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hub Shutdown Methods in Scala\nDESCRIPTION: Extends the Hub trait with methods for managing the Hub's lifecycle, including shutdown, isShutdown, and awaitShutdown.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait Hub[A] {\n  def awaitShutdown: UIO[Unit]\n  def isShutdown: UIO[Boolean]\n  def shutdown: UIO[Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Workflow with ServiceReloader\nDESCRIPTION: This example demonstrates how to implement a parallel workflow where the service is reloaded independently of the main application logic, allowing for continuous service updates.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject ServiceReloaderParallelWorkflowExample extends ZIOAppDefault {\n  def reloadWorkflow =\n    ServiceReloader.reload[Counter].delay(5.seconds)\n\n  def app: ZIO[Counter with ServiceReloader, ServiceReloader.Error, Unit] =\n    for {\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug(\"Counter value\")\n\n      _ <- ZIO.sleep(6.seconds)\n\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug(\"Counter value\")\n    } yield ()\n\n  def run = (app <&> reloadWorkflow).provide(Counter.reloadable, ServiceReloader.live)\n}\n```\n\n----------------------------------------\n\nTITLE: Recovering from Fatal Defects with catchAllCause in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates using ZStream#catchAllCause to recover from all types of failures including fatal defects (which normally terminate the fiber). This allows handling of both regular errors and unexpected terminations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_70\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3) ++ ZStream.dieMessage(\"Oh! Boom!\") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\n\nval stream = s1.catchAllCause(_ => s2)\n// Output: 1, 2, 3, 7, 8, 9\n```\n\n----------------------------------------\n\nTITLE: Using tap for Side Effects Without Changing Result\nDESCRIPTION: Shows how to use the tap method to perform side effects based on a ZIO effect's result without changing the original value. This pattern is useful for logging, metrics, or other operations that shouldn't affect the data flow.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def isPrime(n: Int): Boolean =\n    if (n <= 1) false else (2 until n).forall(i => n % i != 0)\n\n  val myApp: ZIO[Any, IOException, Unit] =\n    for {\n      ref <- Ref.make(List.empty[Int])\n      prime <-\n        Random\n          .nextIntBetween(0, Int.MaxValue)\n          .tap(random => ref.update(_ :+ random))\n          .repeatUntil(isPrime)\n      _ <- Console.printLine(s\"found a prime number: $prime\")\n      tested <- ref.get\n      _ <- Console.printLine(\n        s\"list of tested numbers: ${tested.mkString(\", \")}\"\n      )\n    } yield ()\n\n  def run = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Service Traits and Accessors in ZIO Scala\nDESCRIPTION: This snippet defines two service traits, `LoggingService` and `EmailService`, along with their companion objects containing accessor methods (`log` and `send`). These accessors provide a convenient way to interact with the services within a ZIO environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait LoggingService {\n  def log(line: String): UIO[Unit]\n}\n\nobject LoggingService {\n  def log(line: String): URIO[LoggingService, Unit] =\n    ZIO.serviceWithZIO[LoggingService](_.log(line))\n}\n\ntrait EmailService {\n  def send(user: String, content: String): Task[Unit]\n}\n\nobject EmailService {\n  def send(user: String, content: String): ZIO[EmailService, Throwable, Unit] =\n    ZIO.serviceWithZIO[EmailService](_.send(user, content))\n}\n```\n\n----------------------------------------\n\nTITLE: Retrying Failed Streams with Schedule in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates retrying a failing stream according to a schedule using ZStream#retry. This example retries a stream that gets user input with exponential backoff when parsing fails.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_74\n\nLANGUAGE: scala\nCODE:\n```\nval numbers = ZStream(1, 2, 3) ++ \n  ZStream\n    .fromEffect(\n      zio.console.putStr(\"Enter a number: \") *> zio.console.getStrLn\n        .flatMap(x =>\n          x.toIntOption match {\n            case Some(value) => ZIO.succeed(value)\n            case None        => ZIO.fail(\"NaN\")\n          }\n        )\n    )\n    .retry(Schedule.exponential(1.second))\n```\n\n----------------------------------------\n\nTITLE: Creating Top-Level ZIO Runtime from Layer in Scala\nDESCRIPTION: This snippet illustrates how to create a top-level ZIO `Runtime` instance directly from a `ZLayer`. It uses `Unsafe.unsafe` and `Runtime.unsafe.fromLayer` to convert the provided configuration `layer` into a `Runtime[Any]`. This approach allows for runtime customization that applies globally before the main application logic runs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval runtime: Runtime[Any] =\n  Unsafe.unsafe { implicit unsafe =>\n    Runtime.unsafe.fromLayer(layer)\n  }\n```\n\n----------------------------------------\n\nTITLE: Offering Multiple Elements to TPriorityQueue in Scala ZIO\nDESCRIPTION: Demonstrates how to create a queue and offer multiple elements to it in a single STM transaction using offerAll method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpriorityqueue.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval queue: STM[Nothing, TPriorityQueue[Int]] =\n  for {\n    queue <- TPriorityQueue.empty[Int]\n    _     <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n  } yield queue\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed Error Handling in Scala using ZIO\nDESCRIPTION: This snippet showcases how to use typed errors in ZIO. It demonstrates that with typed errors, unhandled errors are propagated through the error channel, eliminating the need for defensive error logging and providing better compile-time safety.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/logging-errors.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[Any, UploadError, Unit] =\n  upload(\"contacts.csv\")\n    .catchSome {\n      case FileExist(name) => delete(name) *> upload(name)\n    }\n```\n\n----------------------------------------\n\nTITLE: Tailing Kubernetes Pod Logs with ZIO K8s\nDESCRIPTION: Complete example showing how to use ZIO K8s to read and follow the logs of a Kubernetes pod. This example demonstrates creating a ZIO application that connects to the Kubernetes API and streams container logs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nimport com.coralogix.zio.k8s.client.K8sFailure\nimport com.coralogix.zio.k8s.client.config.httpclient._\nimport com.coralogix.zio.k8s.client.model.K8sNamespace\nimport com.coralogix.zio.k8s.client.v1.pods\nimport com.coralogix.zio.k8s.client.v1.pods.Pods\nimport zio._\nimport zio.console.Console\n\nimport scala.languageFeature.implicitConversions\n\nobject ZIOK8sLogsExample extends zio.App {\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = (args match {\n    case List(podName) => tailLogs(podName, None)\n    case List(podName, containerName) => tailLogs(podName, Some(containerName))\n    case _ => console.putStrLnErr(\"Usage: <podname> [containername]\")\n  })\n    .provideCustomLayer(k8sDefault >>> Pods.live)\n    .exitCode\n\n  def tailLogs(podName: String,\n               containerName: Option[String]\n              ): ZIO[Pods with Console, K8sFailure, Unit] =\n    pods\n      .getLog(\n        name = podName,\n        namespace = K8sNamespace.default,\n        container = containerName,\n        follow = Some(true)\n      )\n      .tap { line: String =>\n        console.putStrLn(line).ignore\n      }\n      .runDrain\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Errors with ZIO.logError (Scala)\nDESCRIPTION: This example demonstrates direct logging at the error level using ZIO.logError. It logs a single error message indicating that a file is missing. Dependencies: zio. There are no required inputs; the output is an error-level log message.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nZIO.logError(\\\"File does not exist: ~/var/www/favicon.ico\\\")\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Accessor Methods for DocRepo Service\nDESCRIPTION: Defines static accessor methods in the DocRepo companion object that allow for using the service with ZIO's dependency injection system, enabling a more readable fluent API style.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject DocRepo {\n  def get(id: String): ZIO[DocRepo, Throwable, Doc] =\n    ZIO.serviceWithZIO[DocRepo](_.get(id))\n\n  def save(document: Doc): ZIO[DocRepo, Throwable, String] =\n    ZIO.serviceWithZIO[DocRepo](_.save(document))\n\n  def delete(id: String): ZIO[DocRepo, Throwable, Unit] =\n    ZIO.serviceWithZIO[DocRepo](_.delete(id))\n\n  def findByTitle(title: String): ZIO[DocRepo, Throwable, List[Doc]] =\n    ZIO.serviceWithZIO[DocRepo](_.findByTitle(title))\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Value with Default from a TMap in ZIO STM\nDESCRIPTION: Gets a value associated with a key from a TMap using getOrElse, which provides a default value if the key is not present in the map.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval elemGetOrElse: UIO[Int] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  elem <- tMap.getOrElse(\"d\", 4)\n} yield elem).commit\n```\n\n----------------------------------------\n\nTITLE: Basic ZIO Console Interaction Logic\nDESCRIPTION: Example showing basic console input/output using ZIO effects\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console._\n\ndef myAppLogic =\n  for {\n    _ <- putStrLn(\"Hello! What is your name?\")\n    n <- getStrLn\n    _ <- putStrLn(\"Hello, \" + n + \", good to meet you!\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining Foo and Bar Services in ZIO 2.x\nDESCRIPTION: Example of defining Foo and Bar services using Service Pattern 2.0 in ZIO 2.x. It shows the simplified trait-based approach without Has[_] wrappers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_62\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 2.x\n\ntrait Foo {\n  def foo(input: String): UIO[Unit]\n}\n\ntrait Bar {\n  def bar(input: String): UIO[Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Folding Elements in a TMap in ZIO STM\nDESCRIPTION: Demonstrates folding the elements of a TMap using a specified associative binary operator. This is useful for aggregating the data in the map into a single value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldTMap: UIO[Int] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  sum  <- tMap.fold(0) { case (acc, (_, v)) => acc + v }\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: Broadcasting ZStream to Multiple Streams in Scala\nDESCRIPTION: Defines methods for broadcasting ZStream values to multiple streams, including static and dynamic subscription models. These use Hub internally for efficient implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZStream[-R, +E, +O] {\n  def broadcast(\n    n: Int,\n    maximumLag: Int\n  ): ZIO[R with Scope, Nothing, List[ZStream[Any, E, O]]]\n  def broadcastDynamic(\n    maximumLag: Int\n  ): ZIO[R with Scope, Nothing, ZIO[Scope, Nothing, ZStream[Any, E, O]]]\n}\n```\n\n----------------------------------------\n\nTITLE: Custom ZLogger Implementation in Scala\nDESCRIPTION: Implementation of a custom logger by extending the ZLogger trait with timestamp and log level formatting.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/create-custom-logger-for-a-zio-application.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval logger: ZLogger[String, Unit] =\n  new ZLogger[String, Unit] {\n    override def apply(\n      trace: Trace,\n      fiberId: FiberId,\n      logLevel: LogLevel,\n      message: () => String,\n      cause: Cause[Any],\n      context: FiberRefs,\n      spans: List[LogSpan],\n      annotations: Map[String, String]\n    ): Unit =\n      println(s\"${java.time.Instant.now()} - ${logLevel.label} - ${message()}\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Deferring Layer Creation in ZLayer Composition with Scala\nDESCRIPTION: Illustrates how to defer the creation of intermediate layers in ZLayer composition. This technique is useful when certain dependencies need to be provided externally.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval fooLayer: ZLayer[A    , Throwable, B] = ??? // A ==> B \nval barLayer: ZLayer[B & C, Throwable, D] = ??? // B & C ==> D\n\nval layer: ZLayer[A & C, Throwable, D] =        // A & C ==> D\n  (fooLayer ++ ZLayer.service[C]) >>> barLayer\n\n// ((A ==> B) ++ (C ==> C)) >>> (B & C ==> D)\n// (A & C ==> B & C) >>> (B & C ==> D)\n// (A & C ==> D)\n```\n\n----------------------------------------\n\nTITLE: Filtering Sink Input in Scala ZIO\nDESCRIPTION: This snippet demonstrates how to use the filterInput operation on a ZSink to filter incoming elements. It collects positive integers in groups of three using ZSink.collectAllN and filterInput.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/operations.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nZStream(1, -2, 0, 1, 3, -3, 4, 2, 0, 1, -3, 1, 1, 6)\n  .transduce(\n    ZSink\n      .collectAllN[Int](3)\n      .filterInput[Int](_ > 0)\n  )\n// Output: Chunk(Chunk(1,1,3),Chunk(4,2,1),Chunk(1,1,6),Chunk())\n```\n\n----------------------------------------\n\nTITLE: Generating Constant Values in Scala with ZIO Test\nDESCRIPTION: Demonstrates how to create a generator that always produces the same constant value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nGen.const(true).runCollectN(5)\n// Output: List(true, true, true, true, true)\n```\n\n----------------------------------------\n\nTITLE: Side Effects on TArray Elements in Scala ZIO STM\nDESCRIPTION: Demonstrates how to perform side effects on each element of a TArray using foreach\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foreachTArray = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.foreach(a => STM.succeed(println(a)))\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Enhanced Configurable Logger Implementation\nDESCRIPTION: Advanced implementation of the logging service with support for multiple logger types and runtime configuration. Includes both default and silent logger implementations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Logging {\n\n  val defaultLogger: Logger = new Logger {\n    def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n    ): ZIO[R, E, A] = currentAnnotations.locallyWith(_.updated(key, value))(zio)\n\n    def log(message: String): UIO[Unit] = {\n      currentAnnotations.get.flatMap {\n        case annotation if annotation.isEmpty =>\n          Console.printLine(message).orDie\n        case annotation =>\n          val line =\n            s\"${annotation.map { case (k, v) => s\"[$k=$v]\" }.mkString(\" \")} $message\"\n          Console.printLine(line).orDie\n      }\n    }\n  }\n\n  val silentLogger: Logger = new Logger {\n    def logAnnotate[R, E, A](key: String, value: String)(\n      zio: ZIO[R, E, A]\n    ): ZIO[R, E, A] = currentAnnotations.locallyWith(_.updated(key, value))(zio)\n\n    def log(message: String): UIO[Unit] = ZIO.unit\n  }\n\n  def log(message: String): ZIO[Any, Nothing, Unit] =\n    currentLogger.get.flatMap(_.log(message))\n\n  def logAnnotate[R, E, A](key: String, value: String)(\n    zio: ZIO[R, E, A]\n  ): ZIO[R, E, A] = currentLogger.get.flatMap(_.logAnnotate(key, value)(zio))\n\n  def locallyWithLogger[R, E, A](newLogger: Logger)(zio: ZIO[R, E, A]) = {\n    currentLogger.locallyWith(_ => newLogger)(zio)\n  }\n\n  def updateLogger(logger: Logger => Logger): UIO[Unit] = currentLogger.update(logger)\n\n  val currentLogger: FiberRef[Logger] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(defaultLogger)\n    }\n\n  val currentAnnotations: FiberRef[Map[String, String]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(Map.empty[String, String])\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Cause Contains Specified Cause in Scala\nDESCRIPTION: Creates an assertion `Assertion[Cause[E]]` that checks if a `Cause[E]` contains a specific sub-cause. This is useful for verifying specific failure reasons within complex ZIO error channels.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ncontainsCause[E](cause: Cause[E])\n```\n\n----------------------------------------\n\nTITLE: Getting the Size of a TQueue in ZIO STM\nDESCRIPTION: Demonstrates how to get the number of elements currently in a TQueue using the size method within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueSize: UIO[Int] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offerAll(List(1, 2))\n  size   <- tQueue.size\n} yield size).commit\n```\n\n----------------------------------------\n\nTITLE: Using ZIOAspect for Effect Modification\nDESCRIPTION: Demonstration of ZIOAspect which enables modifying existing ZIO effects with additional aspects like debugging, tracing, and logging. The example shows debug and logged aspects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_86\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[Random, Nothing, String] =\n  ZIO.ifZIO(\n    Random.nextIntBounded(10) @@ ZIOAspect.debug map (_ % 2 == 0)\n  )(\n    onTrue = ZIO.succeed(\"Hello!\"), \n    onFalse = ZIO.succeed(\"Good Bye!\")) @@ ZIOAspect.debug @@ ZIOAspect.logged(\"result\")\n    \n// Sample Output:     \n// 2\n// Hello!\n// timestamp=2021-09-05T15:32:56.705901Z level=INFO thread=#2 message=\"result: Hello!\" file=ZIOAspect.scala line=74 class=zio.ZIOAspect$$anon$4 method=apply\n```\n\n----------------------------------------\n\nTITLE: Implementing Services with Constructor-based Dependency Injection\nDESCRIPTION: Creates concrete implementations of the service interfaces. CLive depends on services A and B which are injected through its constructor, demonstrating constructor-based dependency injection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nfinal case class ALive() extends A {\n  def foo = ZIO.succeed(42)\n}\n\nfinal case class BLive() extends B {\n  def bar: ZIO[Any, Nothing, String] = ZIO.succeed(\"Hello!\")\n}\n\nfinal case class CLive(a: A, b: B) extends C {\n  def baz: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- a.foo\n      _ <- b.bar\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UIO Type Alias in Scala\nDESCRIPTION: Definition of the UIO type alias which represents an unexceptional effect that requires no specific environment, cannot fail, but succeeds with a value of type A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/uio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype UIO[+A] = ZIO[Any, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Using ZState with Custom State Type in Scala\nDESCRIPTION: Shows how to use ZState with a custom case class (MyState) instead of a primitive type. This approach is recommended to avoid ambiguity when multiple state types are used in an application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/zstate.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nfinal case class MyState(counter: Int)\n\nobject ZStateExample extends zio.ZIOAppDefault {\n\n  val myApp: ZIO[ZState[MyState], IOException, Unit] =\n    for {\n      counter <- ZIO.service[ZState[MyState]]\n      _ <- counter.update(state => state.copy(counter = state.counter + 1))\n      _ <- counter.update(state => state.copy(counter = state.counter + 2))\n      state <- counter.get\n      _ <- Console.printLine(s\"Current state: $state\")\n    } yield ()\n\n  def run = ZIO.stateful(MyState(0))(myApp)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating TRef Value with Multiple Transactions\nDESCRIPTION: Demonstrates updating a TRef value with a function across multiple transactions. Creates and commits a TRef first, then applies the update function in a separate transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval updateMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  nValue <- tRef.updateAndGet(_ + 20).commit\n} yield nValue\n```\n\n----------------------------------------\n\nTITLE: Composing Alternative STM Transactions with orTry\nDESCRIPTION: Demonstrates how to compose alternative STM transactions using orTry to implement immediate failure instead of retrying when conditions aren't met.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/stm.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef transferMoneyFailFast(from: TRef[Long], to: TRef[Long], amount: Long): STM[String, Long] =\n    transferMoneyNoMatterWhat(from, to, amount) orTry STM.fail(\"Sender does not have enough of money\")\n```\n\n----------------------------------------\n\nTITLE: Creating Scoped ZStream from Hub in Scala\nDESCRIPTION: Defines a method to create a ZStream from a Hub subscription within a scoped effect. This allows for controlled subscription timing and resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nobject ZStream {\n  def fromHubScoped[O](\n    hub: Hub[O]\n  ): ZIO[Scope, Nothing, ZStream[Any, Nothing, O]] =\n    ???\n}\n```\n\n----------------------------------------\n\nTITLE: ScopedRef Resource Management Example\nDESCRIPTION: Demonstrates automatic resource cleanup when updating ScopedRef values. Shows how setting a new value automatically releases the previous resource.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scopedref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = for {\n    _ <- ZIO.unit\n    r1 = ZIO.acquireRelease(\n           ZIO\n             .debug(\"acquiring the first resource\")\n             .as(5)\n         )(_ => ZIO.debug(\"releasing the first resource\"))\n    r2 = ZIO.acquireRelease(\n           ZIO\n             .debug(\"acquiring the second resource\")\n             .as(10)\n         )(_ => ZIO.debug(\"releasing the second resource\"))\n    sref <- ScopedRef.fromAcquire(r1)\n    _    <- sref.get.debug\n    _    <- sref.set(r2)\n    _    <- sref.get.debug\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Routes in Scala\nDESCRIPTION: Defines stateful counter routes that require a Ref[Int] environment for maintaining state between requests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/restful-webservice.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject CounterRoutes {\n  def apply(): Routes[Ref[Int], Nothing] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Map Key Presence in Scala\nDESCRIPTION: Creates an assertion that checks if a Map contains a specified key. It can also optionally check the value associated with the key against a given assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_12\n\nLANGUAGE: Scala\nCODE:\n```\nhasKey[K, V](key: K)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nhasKey[K, V](key: K, assertion: Assertion[V])\n```\n\n----------------------------------------\n\nTITLE: Asserting String Equals Ignoring Case in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if a `String` is equal to another `String`, ignoring case differences.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nequalsIgnoreCase(other: String)\n```\n\n----------------------------------------\n\nTITLE: Adding Multiple Elements to a TQueue in ZIO STM\nDESCRIPTION: Shows how to add multiple elements to a TQueue at once using the offerAll method with a List. This operation is performed within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueOfferAll: UIO[TQueue[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offerAll(List(1, 2))\n} yield tQueue).commit\n```\n\n----------------------------------------\n\nTITLE: Updating TRef Value in a Single Transaction\nDESCRIPTION: Shows how to update a TRef value using a function in a single transaction. The updateAndGet method applies the function and returns the new value, all atomically.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval updateSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  nValue <- tRef.updateAndGet(_ + 20)\n} yield nValue).commit\n```\n\n----------------------------------------\n\nTITLE: Concurrent Counter Test Implementation\nDESCRIPTION: Example showing how race conditions can affect concurrent operations on a shared counter.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  counter <- Ref.make(0)\n  _ <- ZIO.collectAllPar(ZIO.replicate(10)(inc(counter, 1)))\n  value <- counter.get\n} yield (value)\n```\n\n----------------------------------------\n\nTITLE: Defining Hub Interface in Scala\nDESCRIPTION: Defines the basic interface for a Hub, including publish and subscribe methods. The publish method returns a boolean indicating success, while subscribe returns a scoped Dequeue for receiving messages.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Hub[A] {\n  def publish(a: A): UIO[Boolean]\n  def subscribe: ZIO[Scope, Nothing, Dequeue[A]]\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Key-Value Pair to a TMap in ZIO STM\nDESCRIPTION: Demonstrates adding a new key-value pair to a TMap using the put method. The operation is performed within an STM transaction that is committed to make it effectful.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval putElem: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2))\n  _    <- tMap.put(\"c\", 3)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Basic FiberRef Join Operation in Scala\nDESCRIPTION: Demonstrates the basic join operation where a child fiber's FiberRef value replaces the parent's value when joined.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n```\n\n----------------------------------------\n\nTITLE: Combining Live Clock and TestClock for Stream Testing in Scala\nDESCRIPTION: Demonstrates a technique to slow down TestClock advancements using a live clock. It creates a stream of 30 elements spaced 1 second apart and simulates time passage at a controlled rate.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\nimport zio.test.TestAspect._\n\n\ntest(\"live clock\") {\n  val stream = ZStream.iterate(0)(_ + 1).schedule(Schedule.spaced(1.second))\n  val s1 = stream.take(30)\n  val sink = ZSink.collectAll[Int]\n  for {\n    fiber <- TestClock.adjust(1.second).repeat(Schedule.spaced(10.milliseconds)).fork\n    _ <- fiber.join\n    runner <- s1.run(sink)\n  } yield assert(runner.size)(equalTo(30))\n} @@ TestAspect.withLiveClock\n```\n\n----------------------------------------\n\nTITLE: Merging Values in a TMap with a Function in ZIO STM\nDESCRIPTION: Uses the merge method to either add a new key-value pair or combine an existing value with a new one using a provided function. If the key exists, the function is applied to merge the values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval mergeElem: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  _    <- tMap.merge(\"c\", 4)((x, y) => x * y)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Taking All Elements from a TQueue in ZIO STM\nDESCRIPTION: Retrieves and removes all elements from a TQueue in a single operation using the takeAll method. This returns a Chunk containing all elements that were in the queue.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueTakeAll: UIO[Chunk[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](4)\n  _      <- tQueue.offerAll(List(1, 2))\n  res    <- tQueue.takeAll\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Interruptible Blocking Operation in ZIO\nDESCRIPTION: Shows how to create an interruptible blocking operation using ZIO.attemptBlockingInterrupt, which properly handles interruption signals.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  _ <- Console.printLine(\"Starting a blocking operation\")\n  fiber <- ZIO.attemptBlockingInterrupt {\n    while(true) {\n      Thread.sleep(1000)\n      println(\"Doing some blocking operation\")\n    }\n  }.ensuring(\n     Console.printLine(\"End of the blocking operation\").orDie\n   ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(3.seconds)\n    )\n  )\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Using Symbolic Aliases for Zipping in ZIO (Scala)\nDESCRIPTION: Demonstrates the use of symbolic aliases `*>` and `<*` for `zipRight` and `zipLeft` respectively. These operators can be more concise and easier to read for some developers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval zipRight2 =\n  Console.printLine(\"What is your name?\") *>\n  Console.readLine\n```\n\n----------------------------------------\n\nTITLE: STM-based Deposit Implementation\nDESCRIPTION: Thread-safe implementation of deposit using STM's TRef for atomic transactions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef deposit(accountBalance: TRef[Int], amount: Int): STM[Nothing, Unit] =\n  accountBalance.update(_ + amount)\n```\n\n----------------------------------------\n\nTITLE: Merging ZIO Streams with a Specific Termination Strategy\nDESCRIPTION: This code shows how to merge streams with a specific termination strategy. The example uses TerminationStrategy.Left which means the resulting stream will terminate when the left-hand side stream terminates.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream.ZStream.TerminationStrategy\nval s1 = ZStream.iterate(1)(_+1).take(5).chunkN(1)\nval s2 = ZStream.repeat(0).chunkN(1)\n\nval merged = s1.merge(s2, TerminationStrategy.Left)\n```\n\n----------------------------------------\n\nTITLE: Enabling map and flatMap Composition for Console Effects in Scala\nDESCRIPTION: Introduces an implicit class, ConsoleSyntax, that adds map and flatMap methods to Console[A], supporting functional composition via Scala's for comprehensions. map transforms a result, while flatMap sequences controls based on previous results. This enhancement enables idiomatic chaining and composition of console programs as pure values. No external libraries are required beyond standard Scala syntax for implicits.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/background.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimplicit class ConsoleSyntax[+A](self: Console[A]) {\n  def map[B](f: A => B): Console[B] =\n    flatMap(a => succeed(f(a)))\n\n  def flatMap[B](f: A => Console[B]): Console[B] =\n    self match {\n      case Return(value) => f(value())\n      case PrintLine(line, next) =>\n        PrintLine(line, next.flatMap(f))\n      case ReadLine(next) =>\n        ReadLine(line => next(line).flatMap(f))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Imperative Scala While Loop Equivalent to ZIO.iterate\nDESCRIPTION: Shows the imperative Scala `while` loop structure that `ZIO.iterate` functionally represents. It initializes a mutable state variable `s`, checks a condition `cont(s)` before each iteration, and updates the state using a `body(s)` function within the loop until the condition becomes false. The final state `s` is the result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nvar s = initial\nwhile (cont(s)) {\n  s = body(s)\n}\ns\n```\n\n----------------------------------------\n\nTITLE: Unrecoverable Fiber Interruption with catchAll - Scala\nDESCRIPTION: Demonstrates that ZIO#catchAll cannot recover from fiber interruptions. A ZIO effect is forcibly interrupted before a fail, and catchAll is applied, but fiber interruption is not caught. The output documents an InterruptedException occurring at runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val interruptedEffect: ZIO[Any, String, Nothing] =\n    ZIO.interrupt *> ZIO.fail(\"Oh uh!\")\n\n  def run = interruptedEffect.catchAll(_ => ZIO.unit)\n}\n\n// Output:\n// timestamp=2022-03-03T11:10:15.573588420Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.InterruptedException: Interrupted by thread \\\"zio-fiber-\\\"\n//\\tat <empty>.MainApp.die(MainApp.scala:6)\n//\\tat <empty>.MainApp.run(MainApp.scala:8)\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Layer Memoization in ZIO Application\nDESCRIPTION: This snippet shows how layers are memoized when provided globally in a ZIO application. The 'a' layer is shared between 'b' and 'c' layers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-memoization.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[B & C, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[B]\n      _ <- ZIO.service[C]\n    } yield ()\n    \n  // alternative: myApp.provideLayer((a >>> b) ++ (a >>> c))\n  def run = myApp.provide(a, b, c) \n}\n// Output:\n// initialized: MainApp3$$anon$32@62c8b8d3\n```\n\n----------------------------------------\n\nTITLE: Interrupting a Fiber in Scala using ZIO\nDESCRIPTION: This snippet shows how to interrupt a running fiber in ZIO. It forks an infinite effect and then interrupts it, returning the Exit value describing how the fiber completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber <- ZIO.succeed(\"Hi!\").forever.fork\n  exit  <- fiber.interrupt\n} yield exit\n```\n\n----------------------------------------\n\nTITLE: Interrupting Channel with ZIO Effect\nDESCRIPTION: Demonstrates how to interrupt a channel using ZChannel.interruptWhen with a timed ZIO effect. Creates a stream of random numbers that gets interrupted after 3 seconds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/channel-interruption.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\ndef randomNumbers: ZChannel[Any, Any, Any, Any, Nothing, Int, Nothing] =\n  ZChannel\n    .fromZIO(Random.nextIntBounded(100))\n    .flatMap(ZChannel.write) *>\n    ZChannel.fromZIO(ZIO.sleep(1.second)) *> randomNumbers\n\nrandomNumbers.interruptWhen(ZIO.sleep(3.seconds).as(\"Done!\")).runCollect.debug\n// One output: (Chunk(84,57,70),Done!)\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci Calculation with UIO and Concurrency\nDESCRIPTION: Implementation of a recursive fibonacci function using UIO to represent the computation as an unexceptional effect. The example demonstrates ZIO's concurrency features through forking and joining fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/uio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.UIO\ndef fib(n: Int): UIO[Int] =\n  if (n <= 1) {\n    UIO.succeed(1)\n  } else {\n    for {\n      fiber1 <- fib(n - 2).fork\n      fiber2 <- fib(n - 1).fork\n      v2     <- fiber2.join\n      v1     <- fiber1.join\n    } yield v1 + v2\n  }\n```\n\n----------------------------------------\n\nTITLE: Reverting Either to ZIO Failure with ZIO.absolve (Scala)\nDESCRIPTION: This snippet demonstrates sequencing ZIO methods to transform errors from the failure channel to the success channel and back using either and absolve. The sequence validate -> either -> absolve shows how to expose errors and funnel them back into ZIO's typed failure, with no external dependencies except for the previously defined validate function. Age input remains generic (???), and the effects return to the original signature after transformation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval age: Int = ???\nvalidate(age) // ZIO[Any, AgeValidationException, Int]\n  .either     // ZIO[Any, Either[AgeValidationException, Int]]\n  .absolve    // ZIO[Any, AgeValidationException, Int]\n```\n\n----------------------------------------\n\nTITLE: Converting Resource to ZStream in Scala\nDESCRIPTION: Demonstrates converting a source resource into a ZStream of lines using the scoped constructor. The stream reads lines from a source and manages resource lifecycle.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\ndef lines(name: => String): ZStream[Any, IOException, String] =\n  ZStream.scoped(source(name)).flatMap { source =>\n    ZStream.fromIteratorSucceed(source.getLines())\n  }\n```\n\n----------------------------------------\n\nTITLE: Shrinking a TSet Using Transform in Scala ZIO STM\nDESCRIPTION: Demonstrates how a TSet can be shrunk when the transform function maps multiple elements to the same value. In this example, all elements are transformed to 1, resulting in a set with only one element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval shrinkTSet: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.transform(_ => 1)\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: Composing Write and Read Channels in Scala\nDESCRIPTION: Demonstrates how to compose writer and reader channels using the >>> operator. The writer channel produces data that the reader channel consumes, with the reader returning the read value as its done value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/creating-channels.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nval read = ZChannel.read[Int] \n\n(ZChannel.write(1) >>> read).runCollect.debug\n// Output: (Chunk(0),1) \n```\n\n----------------------------------------\n\nTITLE: Creating Bounded ZIO Queue in Scala\nDESCRIPTION: Shows how to instantiate a back-pressured bounded queue using ZIO. Requires zio._ and no additional dependencies. Capacity is parameterized and set to 100. Returns a Queue[Int].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval boundedQueue: UIO[Queue[Int]] = Queue.bounded[Int](100)\\n\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Console for Output (Scala)\nDESCRIPTION: Demonstrates using `putStr` and `putStrLn` functions from the ZIO Console module to print text to the standard output. `putStr` prints the string without a trailing newline, while `putStrLn` appends a newline. Both return a `ZIO` effect that requires a `Console` environment and may fail with an `java.io.IOException`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/getting_started.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// Print without trailing line break\nputStr(\"Hello World\")\n// res8: ZIO[Console, java.io.IOException, Unit] = zio.ZIO$Read@18df26a1\n\n// Print string and include trailing line break\nputStrLn(\"Hello World\")\n// res9: ZIO[Console, java.io.IOException, Unit] = zio.ZIO$Read@52b30dcd\n```\n\n----------------------------------------\n\nTITLE: Using Logical AND Operator with assertTrue in Scala\nDESCRIPTION: Demonstrates the use of the && operator to combine multiple assertions in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ntest(\"&&\") {\n  check(Gen.int <*> Gen.int) { case (x: Int, y: Int) =>\n    assertTrue(x + y == y + x) && assertTrue(x * y == y * x)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Algebraic Data Type for Console Effects in Scala\nDESCRIPTION: Defines an ADT named Console[A] with three casesReturn, PrintLine, and ReadLineto represent effectful console operations in an immutable, type-safe way. No external dependencies are needed. Inputs and outputs are parameterized on the result type A, with each case handling different effectful behaviors: returning a value, printing a line, or reading a line from the console. This forms the foundational data structure for modeling effectful console programs as pure values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/background.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nsealed trait Console[+A]\nfinal case class Return[A](value: () => A) extends Console[A]\nfinal case class PrintLine[A](line: String, rest: Console[A]) extends Console[A]\nfinal case class ReadLine[A](rest: String => Console[A]) extends Console[A]\n```\n\n----------------------------------------\n\nTITLE: Concatenating Multiple ZIO Streams with concatAll\nDESCRIPTION: This snippet shows how to concatenate multiple ZIO streams using the ZStream.concatAll constructor, which takes a collection of streams and joins them sequentially.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nval c3 = ZStream.concatAll(Chunk(a, b))\n```\n\n----------------------------------------\n\nTITLE: Creating Failed Task Effect Using Task.fail - Scala\nDESCRIPTION: Shows how to create a Task effect that fails with an Exception, representing error scenarios compatible with Throwable-based error handling. The effect will fail with the provided exception instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval f2 = Task.fail(new Exception(\"Uh oh!\"))\n```\n\n----------------------------------------\n\nTITLE: Fallback with orElse Combinator in ZIO for Scala\nDESCRIPTION: This demonstrates the use of orElse to provide a fallback effect if the primary effect fails. It tries to open a primary file, and on failure, falls back to opening a backup file. orElse requires ZIO/IO and compatible effect signatures. Inputs are primary and backup effects; the output is the restored effect. This is a common pattern for graceful degradation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval primaryOrBackupData: IO[IOException, Array[Byte]] = \n  openFile(\"primary.data\").orElse(openFile(\"backup.data\"))\n```\n\n----------------------------------------\n\nTITLE: Type-level Numeric Assertion Constructor with approximatelyEquals - ZIO Test API Signature - Scala\nDESCRIPTION: Describes the function signature for Assertion.approximatelyEquals, used to build assertions checking numeric proximity. This API requires an implicit Numeric instance for type A and takes reference (the value being matched) and tolerance (permitted deviation). Output is an Assertion[A] comparing a numeric value against the given tolerance; the method is generic over numeric types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nAssertion.approximatelyEquals[A: Numeric](reference: A, tolerance: A): Assertion[A]\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Service with Higher-Kinded Type Parameter F[_, _]\nDESCRIPTION: Example of a KeyValueStore service with a higher-kinded type parameter F[_, _], using the @accessibleMM macro to generate accessor methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros.accessibleMM\n\n@accessibleMM[IO]\ntrait KeyValueStore[K, V, E, F[_, _]] {\n  def set(key: K, value: V): F[E, V]\n\n  def get(key: K): F[E, V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, String, IO] {\n  override def set(key: String, value: Int): IO[String, Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): IO[String, Int] =\n    map.get.map(_.get(key)).someOrFail(s\"key not found: $key\")\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, String, IO]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      _ <- KeyValueStore.set[String, Int, String](\"key\", 5)\n      key <- KeyValueStore.get[String, Int, String](\"key\")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n\n}\n```\n\n----------------------------------------\n\nTITLE: Effectful Transformation of TArray Elements in Scala ZIO STM\nDESCRIPTION: Shows how to perform effectful transformation of all elements in a TArray using transformM\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformMTArray: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.transformM(a => STM.succeed(a * a))\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Iterable Assertions in Scala\nDESCRIPTION: Collection of assertion functions for testing Iterable properties including size, content matching, and element validation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nforall[A](assertion: Assertion[A]): Assertion[Iterable[A]]\nhasFirst[A](assertion: Assertion[A]): Assertion[Iterable[A]]\nhasSize[A](assertion: Assertion[Int]): Assertion[Iterable[A]]\nisDistinct: Assertion[Iterable[Any]]\nisEmpty: Assertion[Iterable[Any]]\n```\n\n----------------------------------------\n\nTITLE: Asserting Throwable Message in Scala\nDESCRIPTION: Creates an assertion `Assertion[Throwable]` that checks if a `Throwable`'s message satisfies the provided nested string assertion. Useful for verifying specific error messages.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nhasMessage(message: Assertion[String])\n```\n\n----------------------------------------\n\nTITLE: Creating Unbounded ZIO Queue in Scala\nDESCRIPTION: Instantiates an unbounded ZIO Queue, allowing unlimited items. Only zio._ required. Returns a Queue[Int] that never back-pressures or overflows.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval unboundedQueue: UIO[Queue[Int]] = Queue.unbounded[Int]\\n\n```\n\n----------------------------------------\n\nTITLE: Monitoring Fibers Periodically in a ZIO Application with Supervisor (Scala)\nDESCRIPTION: This comprehensive example demonstrates how to initialize a fiber supervisor, periodically log the count of running fibers, and compute a result in a concurrent ZIO workflow. It uses ZIOAppDefault as the main entry point and defines helper methods for recursive computation and fiber monitoring. Dependencies include zio, zio.Fiber.Status, Schedule, and Console. Key parameters include the initial supervisor, the repeated monitoring policy, and recursive job launching. The output includes fiber count logs and the final computed result, showcasing practical supervisory monitoring.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/supervisor.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\nimport zio.Fiber.Status\n\nobject SupervisorExample extends ZIOAppDefault {\n\n  def run = for {\n    supervisor <- Supervisor.track(true)\n    fiber <- fib(20).supervised(supervisor).fork\n    policy = Schedule\n      .spaced(500.milliseconds)\n      .whileInputZIO[Any, Unit](_ => fiber.status.map(_ != Status.Done))\n    logger <- monitorFibers(supervisor)\n      .repeat(policy).fork\n    _ <- logger.join\n    result <- fiber.join\n    _ <- Console.printLine(s\"fibonacci result: $result\")\n  } yield ()\n\n  def monitorFibers(supervisor: Supervisor[Chunk[Fiber.Runtime[Any, Any]]]) = for {\n    length <- supervisor.value.map(_.length)\n    _ <- Console.printLine(s\"number of fibers: $length\")\n  } yield ()\n\n  def fib(n: Int): ZIO[Any, Nothing, Int] =\n    if (n <= 1) {\n      ZIO.succeed(1)\n    } else {\n      for {\n        _ <- ZIO.sleep(500.milliseconds)\n        fiber1 <- fib(n - 2).fork\n        fiber2 <- fib(n - 1).fork\n        v2 <- fiber2.join\n        v1 <- fiber1.join\n      } yield v1 + v2\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Providing EmailService Implementation in Scala\nDESCRIPTION: This snippet shows how to provide an implementation of the EmailService to a ZIO effect using the provideEnvironment method. It demonstrates dependency injection in ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-propagation.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval loggingImpl = new EmailService {\n  override def send(email: String, content: String): UIO[Unit] = ???\n}\n\nval effect = app.provideEnvironment(ZEnvironment(loggingImpl))\n```\n\n----------------------------------------\n\nTITLE: Basic ZIO Logging Setup with Tofu\nDESCRIPTION: Example showing how to set up basic ZIO logging with Tofu integration, including spans and annotations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tofu-zio2-logging.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport tofu.logging.zlogs._\nimport zio._\n\nobject Main extends ZIOAppDefault {\n  val program: UIO[Unit] = ZIO.log(\"Hello, ZIO logging!\")\n\n  override def run = {\n    program.logSpan(\"full_app\") @@ ZIOAspect.annotated(\"foo\", \"bar\")\n  }.provide(\n    Runtime.removeDefaultLoggers,\n    TofuZLogger.addToRuntime\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Continuous Retrying with Eventually in ZIO Test (Scala)\nDESCRIPTION: This snippet illustrates the use of the 'eventually' test aspect in ZIO Test. It continuously retries a failing test until it passes, without a limit on the number of retries. This is useful for tests that may fail intermittently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/repeat-and-retry.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\ntest(\"retrying a failing test until it succeeds\") {\n  ZIO.debug(\"retrying a failing test\")\n    .map(_ => assertTrue(true))\n} @@ TestAspect.eventually\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Test Suite in Scala\nDESCRIPTION: This code snippet shows how to define a ZIO test suite with multiple tests using ZIOSpecDefault.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/running-tests.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nobject ExampleSpec extends ZIOSpecDefault {\n  def spec = suite(\"clock\")(\n    test(\"foo\") {\n      assertTrue(true)\n    },\n    test(\"foo bar\") {\n      assertTrue(true)\n    },\n    test(\"foo bar baz\") {\n      assertTrue(true)\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Completing a TPromise with Success in ZIO STM\nDESCRIPTION: Demonstrates how to successfully complete a TPromise with a value. The example creates a TPromise, then completes it with an integer value of 0 using the succeed method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpromise.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseSucceed: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.succeed(0).commit\n} yield tPromise\n```\n\n----------------------------------------\n\nTITLE: Defining Layer Type Alias in Scala for ZIO\nDESCRIPTION: This snippet defines the Layer type alias as a specialized version of ZLayer. It represents a layer that doesn't require any input services (Any), may fail with an error type E, and produces an output of type ROut.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/layer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Layer[+E, +ROut] = ZLayer[Any, E, ROut]\n```\n\n----------------------------------------\n\nTITLE: Getting Current Time in Different TimeUnits using ZIO Clock\nDESCRIPTION: Demonstrates how to get current time in different time units using Clock.currentTime. Shows examples of getting time in milliseconds and days using Java TimeUnit.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/clock.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.util.concurrent.TimeUnit\n\nval inMilliseconds: UIO[Long] = Clock.currentTime(TimeUnit.MILLISECONDS)\nval inDays        : UIO[Long] = Clock.currentTime(TimeUnit.DAYS)\n```\n\n----------------------------------------\n\nTITLE: Defining a Service with Dependencies in Scala\nDESCRIPTION: Shows how to define a service C that depends on services A and B.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nfinal case class C(a: A, b: B) {\n  def baz: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- a.foo\n      _ <- b.bar\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Using Try-Catch for Exception Handling in Scala\nDESCRIPTION: Shows how to handle exceptions using try-catch blocks when calling the divide function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef readFromConsole: (Int, Int) = ???\n\nval (a, b) = readFromConsole\n\ntry {\n  Some(divide(a, b))\n} catch {\n  case _: IllegalArgumentException => None\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped UserRepository with ZLayer\nDESCRIPTION: Comprehensive example of implementing a scoped UserRepository service and converting it to a ZLayer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.io.Source._\nimport java.io.{FileInputStream, FileOutputStream, Closeable}\n\ntrait DBConfig\ntrait Transactor\ntrait User\n\ndef dbConfig: Task[DBConfig] = ZIO.attempt(???)\ndef initializeDb(config: DBConfig): Task[Unit] = ZIO.attempt(???)\ndef makeTransactor(config: DBConfig): ZIO[Scope, Throwable, Transactor] = ZIO.attempt(???)\n\ntrait UserRepository {\n  def save(user: User): Task[Unit]\n}\n\ncase class UserRepositoryLive(xa: Transactor) extends UserRepository {\n  override def save(user: User): Task[Unit] = ZIO.attempt(???)\n}\n\ndef scoped: ZIO[Scope, Throwable, UserRepository] = \n  for {\n    cfg <- dbConfig\n    _   <- initializeDb(cfg)\n    xa  <- makeTransactor(cfg)\n  } yield new UserRepositoryLive(xa)\n\nobject UserRepositoyLive {\n  val layer : ZLayer[Any, Throwable, UserRepository] =\n    ZLayer.scoped(scoped)\n}\n```\n\n----------------------------------------\n\nTITLE: Including Middle Services in ZLayer Output with Scala\nDESCRIPTION: Shows how to include middle services in the output of a composed ZLayer. This technique allows exposing intermediate services in the final layer's output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ??? // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ??? // B  ==> C\n\nval finalLayer: ZLayer[A, Throwable, B & C] = // A ==> B & C\n  fooLayer >>> (ZLayer.service[B] ++ barLayer)\n  \n// (A ==> B) >>> ((B ==> B) ++ (B ==> C))\n// (A ==> B) >>> (B ==> B & C)\n// (A ==> B & C)\n```\n\n----------------------------------------\n\nTITLE: Creating an Exponential Backoff Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that recurs using exponential backoff, starting with the specified duration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval exponential = Schedule.exponential(10.milliseconds)\n```\n\n----------------------------------------\n\nTITLE: Generating Deterministic Elements from an Iterable in Scala using ZIO Test\nDESCRIPTION: Shows how to create a generator that produces elements from a predefined iterable in a deterministic order.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nGen.fromIterable(List(\"red\", \"green\", \"blue\"))\n  .runCollectN(10)\n  .debug\n// Output: List(red, green, blue, red, green, blue, red, green, blue, red)\n```\n\n----------------------------------------\n\nTITLE: Running a Failing ZIO Application in Scala\nDESCRIPTION: Shows a simple ZIO application (`ZIOAppDefault`) whose `run` method executes an effect that ultimately fails using `ZIO.fail`. Running this application will cause it to terminate and print an error message and stack trace. Depends on the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/failures.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.succeed(5) *> ZIO.fail(\"Oh uh!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Shutting Down a Queue in Scala with ZIO\nDESCRIPTION: Demonstrates how to shut down a queue and handle the shutdown process, including interrupting suspended fibers and awaiting shutdown.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/queue.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval takeFromShutdownQueue: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](3)\n  f <- queue.take.fork\n  _ <- queue.shutdown // will interrupt f\n  _ <- f.join // Will terminate\n} yield ()\n```\n\nLANGUAGE: scala\nCODE:\n```\nval awaitShutdown: UIO[Unit] = for {\n  queue <- Queue.bounded[Int](3)\n  p <- Promise.make[Nothing, Boolean]\n  f <- queue.awaitShutdown.fork\n  _ <- queue.shutdown\n  _ <- f.join\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Completing a TPromise with Either\nDESCRIPTION: Completes a TPromise using the done method with an Either value. This demonstrates both success and failure completion using Either.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpromise.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseDoneSucceed: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.done(Right(0)).commit\n} yield tPromise\n\nval tPromiseDoneFail: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.done(Left(\"failed\")).commit\n} yield tPromise\n```\n\n----------------------------------------\n\nTITLE: Creating Uninterruptible ZIO Effect in Scala\nDESCRIPTION: Shows how to create an uninterruptible ZIO effect that prints the current date and time every second, which cannot be interrupted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber <- Clock.currentDateTime\n    .flatMap(time => printLine(time))\n    .schedule(Schedule.fixed(1.seconds))\n    .uninterruptible\n    .fork\n  _     <- fiber.interrupt // Runtime stuck here and does not go further\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Service Trait Definitions\nDESCRIPTION: Example service trait definitions for Logging and Email functionality\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait Logging {\n  def log(line: String): UIO[Unit]\n}\n\nobject Logging {\n  def log(line: String): URIO[Has[Logging], Unit] =\n    ZIO.serviceWith[Logging](_.log(line))\n}\n\ntrait Email {\n  def send(user: String, content: String): Task[Unit]\n}\n\nobject Email {\n  def send(user: String, content: String): ZIO[Has[Email], Throwable, Unit] =\n    ZIO.serviceWith[Email](_.send(user, content))\n}\n```\n\n----------------------------------------\n\nTITLE: Logging Spans with ZIO.logSpan (Scala)\nDESCRIPTION: This snippet demonstrates the use of ZIO.logSpan to measure and log the duration of an operation within a labeled span. The example performs a one-second sleep and then logs a completion message, all under the contextual span. Dependencies: zio. Inputs: none. Outputs: log messages with span duration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nZIO.logSpan(\\\"myspan\\\") {\\n  ZIO.sleep(1.second) *> ZIO.log(\\\"The job is finished!\\\")\\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom ZIO Runtime in Scala\nDESCRIPTION: Demonstrates the creation of a custom `Runtime[R]` tailored for a specific environment `R`. It requires providing an instance of the environment (`42` of type `Int` in this example) and a `zio.internal.Platform` (using the default `Platform.default`). Custom runtimes are necessary when effects depend on user-defined services or configurations not included in `Runtime.default`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/running_effects.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nimport zio.internal.Platform\n\nval myRuntime: Runtime[Int] = Runtime(42, Platform.default)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Random Option with ZIO WhenZIO\nDESCRIPTION: Demonstrates using ZIO's whenZIO operator to create a random option of an integer value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef randomIntOption: ZIO[Any, Nothing, Option[Int]] =\n  Random.nextInt.whenZIO(Random.nextBoolean)\n```\n\n----------------------------------------\n\nTITLE: Creating a Fibonacci Backoff Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that always recurs, increasing delays by summing the preceding two delays similar to the Fibonacci sequence.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval fibonacci = Schedule.fibonacci(10.milliseconds)\n```\n\n----------------------------------------\n\nTITLE: Defining the SubscriptionRef Trait in Scala\nDESCRIPTION: The SubscriptionRef trait definition which includes a changes stream that can be consumed to observe all changes and a ref that provides access to the current value via a RefM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/subscriptionref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\ntrait SubscriptionRef[A] {\n  def changes: ZStream[Any, Nothing, A]\n  def ref: RefM[A]\n}\n```\n\n----------------------------------------\n\nTITLE: Reading File Lines with ZIO Bracket\nDESCRIPTION: A real-world example showing how to count lines in a file using ZIO's bracket pattern, which ensures proper resource acquisition and cleanup even in the presence of errors or interruptions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef lines(file: String): Task[Long] = {\n  def countLines(reader: BufferedReader): Task[Long]    = Task.effect(reader.lines().count())\n  def releaseReader(reader: BufferedReader): UIO[Unit]  = Task.effectTotal(reader.close())\n  def acquireReader(file: String): Task[BufferedReader] = Task.effect(new BufferedReader(new FileReader(file), 2048))\n\n  Task.bracket(acquireReader(file), releaseReader, countLines)\n}\n```\n\n----------------------------------------\n\nTITLE: Selective Error Recovery with catchSome in ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#catchSome to recover from specific errors while letting other errors propagate. This provides more targeted error handling than catchAll for specific error conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_71\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3) ++ ZStream.fail(\"Oh! Error!\") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\nval stream = s1.catchSome {\n  case \"Oh! Error!\" => s2\n}\n// Output: 1, 2, 3, 7, 8, 9\n```\n\n----------------------------------------\n\nTITLE: Implementing Reloadable Counter Service with ServiceReloader\nDESCRIPTION: This example demonstrates how to implement a reloadable Counter service using the ServiceReloader approach. It includes the application logic and service configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros._\n\nimport java.util.UUID\n\nobject ServiceReloaderExample extends ZIOAppDefault {\n\n  def app: ZIO[Counter with ServiceReloader, ServiceReloader.Error, Unit] =\n    for {\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug(\"Counter value\")\n\n      _ <- ServiceReloader.reload[Counter]\n      _ <- ZIO.sleep(1.seconds)\n\n      _ <- Counter.increment\n      _ <- Counter.increment\n      _ <- Counter.get.debug(\"Counter value\")\n    } yield ()\n\n  def run = app.provide(Counter.reloadable, ServiceReloader.live)\n}\n```\n\n----------------------------------------\n\nTITLE: Taking Multiple Elements from a TQueue in ZIO STM\nDESCRIPTION: Retrieves and removes up to a specified number of elements from a TQueue using the takeUpTo method. This operation returns a Chunk containing the retrieved elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueTakeUpTo: UIO[Chunk[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](4)\n  _      <- tQueue.offerAll(List(1, 2))\n  res    <- tQueue.takeUpTo(3)\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Handling Only Defects with ZIO Resurrect in Scala\nDESCRIPTION: Demonstrates that `ZIO#resurrect` converts defects (from `ZIO.dieMessage`) into `Throwable` failures but does *not* handle interruptions (from `ZIO.interrupt`). The interruption remains unhandled, causing the application to terminate with an error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/converting-defects-to-failures.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect1 =\n    ZIO\n      .dieMessage(\"Boom!\") // ZIO[Any, Nothing, Nothing]\n      .resurrect           // ZIO[Any, Throwable, Nothing]\n      .ignore\n  val effect2 =\n    ZIO.interrupt          // ZIO[Any, Nothing, Nothing]\n      .resurrect           // ZIO[Any, Throwable, Nothing]\n      .ignore\n\n  def run =\n    (effect1 <*> effect2)\n      .debug(\"couldn't recover from fiber interruption\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Counter Entity in Scala for ZIO Shardcake\nDESCRIPTION: This code defines a Counter entity using Shardcake library in ZIO. It includes message types, message handling logic, and entity behavior.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport com.devsisters.shardcake._\nimport zio._\n\nsealed trait CounterMessage\nobject CounterMessage {\n  case class Increase(replier: Replier[Int]) extends CounterMessage\n  case class Decrease(replier: Replier[Int]) extends CounterMessage\n}\n\nobject Counter extends EntityType[CounterMessage](\"counter\") {\n\n  def handleMessage(\n    entityId: String,\n    state: Ref[Int],\n    message: CounterMessage\n  ): ZIO[Sharding, Nothing, Unit] =\n    podPort.flatMap { port =>\n      message match {\n        case CounterMessage.Increase(replier) =>\n          state\n            .updateAndGet(_ + 1)\n            .debug(s\"The $entityId counter increased inside localhost:$port pod\")\n            .flatMap(replier.reply)\n        case CounterMessage.Decrease(replier) =>\n          state\n            .updateAndGet(_ - 1)\n            .debug(s\"The $entityId counter decreased inside localhost:$port pod\")\n            .flatMap(replier.reply)\n      }\n    }\n\n  def behavior(\n    entityId: String,\n    messages: Dequeue[CounterMessage]\n  ): ZIO[Sharding, Nothing, Nothing] =\n    Ref.make(0).flatMap { state =>\n      messages.take.flatMap(handleMessage(entityId, state, _)).forever\n    }\n\n  def podPort: UIO[String] =\n    System\n      .env(\"PORT\")\n      .some\n      .orDieWith(_ => new Exception(\"Application started without any specified port!\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retryN for Fixed Retries in Scala\nDESCRIPTION: Shows how to use the `retryN` method to retry a failing ZIO effect (`readFile`) a specific number of times (5 in this case). This is a convenience method for simple fixed retry counts and requires the ZIO library and a `readFile` function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval file = readFile(\"primary.data\").retryN(5)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Single Failure in ZIO Application (Scala)\nDESCRIPTION: This Scala code defines a ZIO application using `ZIOAppDefault`. It demonstrates a sequential execution where the application terminates upon encountering the first failure (`ZIO.fail`). The subsequent `die` and `interruption` effects are not executed because the sequence (`*>`) is short-circuited by the initial failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val fail = ZIO.fail(\"Oh uh!\")\n  val die = ZIO.dieMessage(\"Boom!\")\n  val interruption = ZIO.interrupt\n\n  def run = (fail <*> die) *> interruption\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Modifying a TRef Value in a Single Transaction in Scala ZIO STM\nDESCRIPTION: Creates a TRef and modifies its value, returning both a derived value (a string) and updating the reference. Then retrieves the new value to demonstrate the change was applied.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval modifySingle: UIO[(String, Int)] = (for {\n  tRef <- TRef.make(10)\n  mValue <- tRef.modify(v => (\"Zee-Oh\", v + 10))\n  nValue <- tRef.get\n} yield (mValue, nValue)).commit\n```\n\n----------------------------------------\n\nTITLE: Defining foldCause and foldCauseZIO in ZIO - Scala\nDESCRIPTION: Shows trait declarations for foldCause and foldCauseZIO, which are the most powerful effect combinators for handling causes, including interruptions and defects. These forms provide full access to the Cause of the failure for advanced error handling and recovery. Requires ZIO library and familiarity with zio.Cause.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def foldCause[B](\n    failure: Cause[E] => B,\n    success: A => B\n  ): ZIO[R, Nothing, B]\n\n  def foldCauseZIO[R1 <: R, E2, B](\n    failure: Cause[E] => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  ): ZIO[R1, E2, B]\n}\n```\n\n----------------------------------------\n\nTITLE: Releasing CyclicBarrier\nDESCRIPTION: Shows how to release a barrier with two parties. Creates a barrier for 2 parties, forks two fibers that await the barrier, and verifies the release order through tickets.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/cyclicbarrier.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.CyclicBarrier\nimport zio._\n\nfor {\n  barrier <- CyclicBarrier.make(2)\n  f1      <- barrier.await.fork\n  _       <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  f2      <- barrier.await.fork\n  ticket1 <- f1.join\n  ticket2 <- f2.join\n} yield assert(ticket1 == 1 && ticket2 == 0)\n```\n\n----------------------------------------\n\nTITLE: Offering Multiple Items with offerAll in Scala\nDESCRIPTION: Showcases using offerAll to enqueue a batch of items. Uses Range to generate a list of Ints and offers them all at once. Requires zio._ and standard Scala collections. Useful for batch processing scenarios.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval res3: UIO[Unit] = for {\\n  queue <- Queue.bounded[Int](100)\\n  items = Range.inclusive(1, 10).toList\\n  _ <- queue.offerAll(items)\\n} yield ()\\n\n```\n\n----------------------------------------\n\nTITLE: Catching All Errors in ZIO Effects\nDESCRIPTION: Shows how to use the catchAll method to catch and recover from all types of recoverable errors in ZIO, specifying an error handler that returns the effect to execute in case of an error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval z: ZIO[Any, IOException, Array[Byte]] = \n  openFile(\"primary.json\").catchAll { error => \n    for {\n      _    <- ZIO.logErrorCause(\"Could not open primary file\", Cause.fail(error))\n      file <- openFile(\"backup.json\")\n    } yield file \n  }\n```\n\n----------------------------------------\n\nTITLE: Applying Debug Aspect to ZIO Effect in Scala\nDESCRIPTION: Demonstrates how to add a debugging aspect to a ZIO effect using the @@ operator. The debug aspect doesn't change the return type of the effect but adds debugging capabilities.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval myApp: ZIO[Any, Throwable, String] =\n  ZIO.attempt(\"Hello!\") @@ ZIOAspect.debug\n```\n\n----------------------------------------\n\nTITLE: Converting CompletionStage to ZIO Task\nDESCRIPTION: Demonstrates how to convert a Java CompletionStage to a ZIO Task with logging functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-java.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef loggedStage[A](stage: => CompletionStage[A]): Task[A] =\n    ZIO.fromCompletionStage(UIO {\n        stage.thenApplyAsync { a =>\n            println(\"Stage completed with \" + a)\n            a\n        }\n    })\n```\n\n----------------------------------------\n\nTITLE: Creating a Supervisor from an Initial Fiber Set with Supervisor.fibersIn in ZIO (Scala)\nDESCRIPTION: This snippet shows how to construct a Supervisor in ZIO using an AtomicReference containing a sorted set of fibers. The fibersIn method initializes the Supervisor with the given reference, allowing it to track a predefined group of fibers. Dependencies include ZIO, java.util.concurrent.atomic, and scala.collection.immutable.SortedSet. Inputs include a reference to the fiber set, and the output is a new Supervisor tied to this set.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/supervisor.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport java.util.concurrent.atomic.AtomicReference\nimport zio.{ Fiber, ZIO }\nimport scala.collection.immutable.SortedSet\ndef fibers: Seq[Fiber.Runtime[Any, Any]] = ???\n```\n\nLANGUAGE: Scala\nCODE:\n```\ndef fiberListSupervisor = for { \n  ref <- ZIO.succeed(new AtomicReference(SortedSet.from(fibers)))\n  s <- Supervisor.fibersIn(ref)\n} yield (s)\n```\n\n----------------------------------------\n\nTITLE: Removing Elements Based on a Predicate in Scala ZIO STM\nDESCRIPTION: Removes all elements that satisfy a given predicate (in this case, even numbers) from a TSet. This is a destructive operation that modifies the collection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval removedEvenElems: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.removeIf(_ % 2 == 0)\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: Creating an Editor Service with Direct Dependency Instantiation in Scala\nDESCRIPTION: Defines an `Editor` class that requires `Formatter` and `Compiler` services. In this tightly coupled approach, the `Editor` class directly instantiates its dependencies (`Formatter` and `Compiler`) within its own definition. The `formatAndCompile` method demonstrates using these internal instances.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nclass Editor {\n  private val formatter: Formatter = new Formatter()\n  private val compiler: Compiler   = new Compiler()\n\n  def formatAndCompile(code: String): UIO[String] =\n    formatter.format(code).flatMap(compiler.compile)\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Scala Documentation with Code References in ZIO\nDESCRIPTION: Demonstrates how to properly document code with ScalaDoc, using links to reference other members. This practice makes documentation navigable and ensures accurate references, exemplified with ZIO type aliases.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/coding-guidelines.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  /**\n   * @see See [[zio.ZIO.absolve]]\n   */\n  def absolve[R, A](v: RIO[R, Either[Throwable, A]]): RIO[R, A] =\n    ZIO.absolve(v)\n```\n\n----------------------------------------\n\nTITLE: Nested TestAspect Application\nDESCRIPTION: Example of applying multiple test aspects using nested function calls, demonstrating JVM-only testing and test repetition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\nrepeat(Schedule.recurs(5))(\n  jvmOnly(\n    test(\"test\") {\n      assertTrue(true)\n    }\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Interrupting CyclicBarrier\nDESCRIPTION: Shows how interrupting a waiting party affects the barrier state. Demonstrates timeout-based interruption and its effect on the barrier's broken state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/cyclicbarrier.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.CyclicBarrier\nimport zio._\nimport zio.duration._\nimport zio.test.environment.TestClock\n\nfor {\n  barrier   <- CyclicBarrier.make(100)\n  f1        <- barrier.await.timeout(1.second).fork\n  f2        <- barrier.await.fork\n  _         <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  _         <- f2.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  isBroken1 <- barrier.isBroken\n  _         <- TestClock.adjust(1.second)\n  isBroken2 <- barrier.isBroken\n  res1      <- f1.await\n  res2      <- f2.await\n} yield assert(!isBroken1 && isBroken2)\n```\n\n----------------------------------------\n\nTITLE: Hiding Passed-through Dependencies in ZLayer Composition with Scala\nDESCRIPTION: Shows how to hide passed-through dependencies in a ZLayer composition using type ascription. This allows for flexible composition while controlling the exposed interface.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nlazy val hidden: ZLayer[Any, Nothing, Cake] = all\n```\n\n----------------------------------------\n\nTITLE: GraphQL Schema Definition\nDESCRIPTION: Example of GraphQL schema definition for Employee and Role types\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\ntype Employee {\n  name: String!\n  role: Role!\n}\n\nenum Role {\n  SoftwareDeveloper\n  SiteReliabilityEngineer\n  DevOps\n}\n```\n\n----------------------------------------\n\nTITLE: Defining STM Type Aliases in Scala\nDESCRIPTION: Type aliases for different variants of ZSTM that provide different error and environment type parameters. These aliases simplify common STM usage patterns by providing specialized versions of the base ZSTM type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ntype RSTM[-R, +A]  = ZSTM[R, Throwable, A]\ntype URSTM[-R, +A] = ZSTM[R, Nothing, A]\ntype STM[+E, +A]   = ZSTM[Any, E, A]\ntype USTM[+A]      = ZSTM[Any, Nothing, A]\ntype TaskSTM[+A]   = ZSTM[Any, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Using ZIO.iterate for Simple State Iteration in Scala\nDESCRIPTION: Demonstrates `ZIO.iterate` with two examples. The first (`r1`) increments an integer state starting from 1 as long as it's less than or equal to 5, resulting in 6. The second (`r2`) doubles the state starting from 1 while it's less than or equal to 5, debugging intermediate steps (2, 4, 8) and showing the final result (8). Both examples use `ZIO.succeed` for the effectful body.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval r1 = ZIO.iterate(1)(_ <= 5)(s => ZIO.succeed(s + 1)).debug\n// 6\n\nval r2 = ZIO.iterate(1)(_ <= 5)(s => ZIO.succeed(s * 2).debug).debug(\"result\")\n// 2\n// 4\n// 8\n// result: 8\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO IO with Error Mapping to CompletableFuture - Scala\nDESCRIPTION: This function demonstrates converting a general ZIO effect IO[E, A] to a CompletableFuture in Scala by supplying an error mapper from E to Throwable. It uses ZIO\\'s toCompletableFutureWith utility to bridge error models between ZIO and Java. Dependencies are ZIO, IO, and CompletableFuture, with a required custom error conversion function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-java.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef ioToStage[E, A](io: IO[E, A])(toThrowable: E => Throwable): UIO[CompletableFuture[A]] =\n    io.toCompletableFutureWith(toThrowable)\n```\n\n----------------------------------------\n\nTITLE: Racing Two Effects in Parallel with ZIO Scala\nDESCRIPTION: Shows the basic use of ZIO's race combinator to obtain the result of the first completed effect. Provides two alternatives; the first to succeed is the result. Requires ZIO, and can be composed with more complex error handling when needed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  winner <- IO.succeed(\"Hello\").race(IO.succeed(\"Goodbye\"))\n} yield winner\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Type Alias in ZIO\nDESCRIPTION: This code defines the Stream type as an alias for ZStream with specific type parameters. The Stream type represents a ZIO stream that doesn't require any services, may fail with an error type E, and produces elements of type A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/stream.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Stream[+E, +A] = ZStream[Any, E, A]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Buffered Channel in Scala ZIO\nDESCRIPTION: Creates a channel with an internal buffer that accumulates values and outputs them based on buffer state. Demonstrates using ZChannel.buffer for managing buffered streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\ndef buffered(input: Int) =\n  ZChannel\n    .fromZIO(Ref.make(input))\n    .flatMap { ref =>\n      ZChannel.buffer[Any, Int, Unit](\n        0,\n        i => if (i == 0) true else false,\n        ref\n      )\n    }\n```\n\n----------------------------------------\n\nTITLE: Ref For-Comprehension Example - Scala\nDESCRIPTION: Example showing how to use Ref with for-comprehension syntax\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  ref   <- Ref.make(\"initial\")\n  value <- ref.get\n} yield assert(value == \"initial\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZIO 2.x Layer Composition and Elimination in Scala\nDESCRIPTION: Example of composing multiple layers and eliminating services from environmental effects in ZIO 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_58\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Foo\ntrait Bar\ntrait Baz\n\nobject MainApp extends ZIOAppDefault {\n\n  val needsFooAndBarAndBaz: ZIO[Foo & Bar & Baz, Nothing, Unit] =\n    for {\n      foo <- ZIO.service[Foo]\n      bar <- ZIO.service[Bar]\n      baz <- ZIO.service[Baz]\n      _ <- ZIO.debug(s\"Foo: $foo, Bar: $bar, Baz: $baz\")\n    } yield ()\n\n  val fooAndBarLayer: ULayer[Foo with Bar] =\n    ZLayer.succeed(new Foo {}) ++ ZLayer.succeed(new Bar {})\n\n  val needsBaz: ZIO[Baz, Nothing, Unit] =\n    fooAndBarLayer(needsFooAndBarAndBaz)\n\n  def run = needsBaz.provide(ZLayer.succeed(new Baz {}))\n\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Accessor Methods with Tag Context Bounds\nDESCRIPTION: Properly defined accessor methods for the KeyValueStore service with Tag context bounds added to the polymorphic type parameters. This enables the ZIO environment system to have runtime type information for the service dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject KeyValueStore {\n  def get[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n\n  def set[K: Tag, V: Tag, E: Tag](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n\n  def remove[K: Tag, V: Tag, E: Tag](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =\n    ZIO.serviceWithZIO(_.remove(key))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining catchSome for ZIO - Scala\nDESCRIPTION: This snippet defines the catchSome method for selectively recovering from certain errors using a partial function. It enables effectful handling only for specific failure types. Requires a partial function from error to effect, and the output is a new effect with possibly a broader error type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def catchSome[R1 <: R, E1 >: E, A1 >: A](pf: PartialFunction[E, ZIO[R1, E1, A1]]): ZIO[R1, E1, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Performing a Difference Operation on TSets in Scala ZIO STM\nDESCRIPTION: Performs a difference operation between two TSets, resulting in a set containing elements from the first set that are not in the second set. This modifies the first set (tSetA) with the difference result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\n// diffTSet = {1, 2}\nval diffTSet: UIO[TSet[Int]] = (for {\n  tSetA <- TSet.make(1, 2, 3, 4)\n  tSetB <- TSet.make(3, 4, 5, 6)\n  _     <- tSetA.diff(tSetB)\n} yield tSetA).commit\n```\n\n----------------------------------------\n\nTITLE: Simple Test Declaration in ZIO\nDESCRIPTION: Shows a basic test declaration using ZIO test framework with assertTrue assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ntest(\"test\") {\n  assertTrue(true)\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Configuration Using ZLayer Horizontal Composition\nDESCRIPTION: This example shows how to update application configuration using horizontal composition. It initializes an AppConfig with poolSize 5, then completely replaces it with a new configuration having poolSize 8 by horizontally composing with a new layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\ncase class AppConfig(poolSize: Int)\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[AppConfig, IOException, Unit] =\n    for {\n      config <- ZIO.service[AppConfig]\n      _      <- Console.printLine(s\"Application config after the update operation: $config\")\n    } yield ()\n\n\n  val appLayers: ZLayer[Any, Nothing, AppConfig] =\n    ZLayer(ZIO.succeed(AppConfig(5)).debug(\"Application config initialized\"))\n\n  val updatedConfig: ZLayer[Any, Nothing, AppConfig] =\n    appLayers ++ ZLayer.succeed(AppConfig(8))\n\n  def run = myApp.provide(updatedConfig)\n}\n// Output:\n// Application config initialized: AppConfig(5)\n// Application config after the update operation: AppConfig(8)\n```\n\n----------------------------------------\n\nTITLE: Creating a Managed Resource for File with Cats Effect (Scala)\nDESCRIPTION: This snippet illustrates defining a Resource representing acquisition and finalization for the File effect, using Resource.make for lifecycle safety. fileResource takes a filename and returns a Cats Effect Resource of File, ensuring proper clean-up via the close method. It requires cats.effect.Sync and cats.effect.Resource in scope, with key parameter being the resource name for management. The output is a managed Resource that provides a File[F] acquisition/finalization flow.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\ndef fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n  cats.effect.Resource.make(File.open[F](name))(_.close)\n```\n\n----------------------------------------\n\nTITLE: Asserting Map Values Satisfy Condition in Scala\nDESCRIPTION: Creates an assertion `Assertion[Map[K, V]]` that checks if the values of a `Map` (as an `Iterable[V]`) satisfy the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nhasValues[K, V](assertion: Assertion[Iterable[V]])\n```\n\n----------------------------------------\n\nTITLE: Creating a Fixed-Spacing Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that recurs continuously, with each repetition spaced by the specified duration from the last run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval spaced = Schedule.spaced(10.milliseconds)\n```\n\n----------------------------------------\n\nTITLE: Modeling Unexpected Errors (Defects) with ZIO.die in Scala\nDESCRIPTION: The `ZIO.die` function is used to model unexpected errors, known as Defects, in ZIO. These errors are not anticipated at the point they occur and are typically propagated up the application stack. They might be converted to Failures at a higher level if appropriate, or potentially crash the application if left unhandled.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nZIO.die\n```\n\n----------------------------------------\n\nTITLE: Defining ZStream Type Aliases in Scala\nDESCRIPTION: This code snippet defines two type aliases for the ZStream data type. Stream[E, A] represents a ZIO stream that doesn't require services and may fail with E or produce A elements. UStream[A] is a non-failing stream that produces A elements without requiring services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/type-aliases.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Stream[+E, +A] = ZStream[Any, E, A]\ntype UStream[+A]    = ZStream[Any, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Retaining Elements Based on a Predicate in Scala ZIO STM\nDESCRIPTION: Keeps only elements that satisfy a given predicate (in this case, even numbers) in a TSet. This is a destructive operation that modifies the collection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval retainedEvenElems: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.retainIf(_ % 2 == 0)\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: Asserting Exit Value Fails with Error in Scala\nDESCRIPTION: Creates an assertion `Assertion[Exit[E, Any]]` that checks if a ZIO `Exit` value represents a failure. It takes a nested assertion that must be satisfied by the error value `E` within the failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nfails[E](assertion: Assertion[E])\n```\n\n----------------------------------------\n\nTITLE: Creating and Completing ZIO Promises with Failure in Scala\nDESCRIPTION: Demonstrates creating a ZIO Promise and completing it with a failure, returning a boolean indicating whether the Promise was set.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/promise.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval ioPromise2: UIO[Promise[Exception, Nothing]] = Promise.make[Exception, Nothing]\nval ioBooleanFailed: UIO[Boolean] = ioPromise2.flatMap(promise => promise.fail(new Exception(\"boom\")))\n```\n\n----------------------------------------\n\nTITLE: Locally Scoping FiberRef Values in ZIO Scala\nDESCRIPTION: This snippet demonstrates the `FiberRef#locally` method. It creates a `FiberRef`, then uses `locally` to set its value (\"my-correlation-id\") only for the duration of the `correlationId.get` effect within that scope. The final assertion confirms that the value was changed locally (`v1`) but the original value (`v2`) outside the `locally` scope remains unchanged.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nfor {\n  correlationId <- FiberRef.make[String](\"\")\n  v1            <- correlationId.locally(\"my-correlation-id\")(correlationId.get)\n  v2            <- correlationId.get\n} yield v1 == \"my-correlation-id\" && v2 == \"\"\n```\n```\n\n----------------------------------------\n\nTITLE: Sequential Errors with Ensuring in ZIO (Scala)\nDESCRIPTION: This Scala code defines a ZIO application demonstrating sequential errors using `ensuring`. An initial effect fails (`ZIO.fail`), and its finalizer (`ensuring`) causes a defect (`ZIO.dieMessage`). Because finalizers run regardless of the original effect's outcome, both the failure and the defect occur sequentially.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.fail(\"Oh uh!\").ensuring(ZIO.dieMessage(\"Boom!\"))\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Buffering Stream Elements with ZStream#buffer in Scala\nDESCRIPTION: This example demonstrates buffering a stream with a capacity of 4 elements, allowing a faster producer to progress independently of a slower consumer. The tap operations show elements before and after buffering, while schedule spaces consumption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_55\n\nLANGUAGE: scala\nCODE:\n```\nZStream\n  .fromIterable(1 to 10)\n  .chunkN(1)\n  .tap(x => zio.console.putStrLn(s\"before buffering: $x\"))\n  .buffer(4)\n  .tap(x => zio.console.putStrLn(s\"after buffering: $x\"))\n  .schedule(Schedule.spaced(5.second))  \n```\n\n----------------------------------------\n\nTITLE: Creating ZSink from OutputStream for Byte Stream Processing\nDESCRIPTION: Demonstrates creating a sink from System.err OutputStream to write string data. The sink converts strings to byte chunks and writes them with newline separators.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/creating-sinks.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nZStream(\"Application\", \"Error\", \"Logs\")\n  .intersperse(\"\\n\")\n  .run(\n    ZSink\n      .fromOutputStream(java.lang.System.err)\n      .contramapChunks[String](_.flatMap(_.getBytes))\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating Repeated Effects with ZIO#repeat\nDESCRIPTION: Demonstrates how to create a repeated effect using the ZIO#repeat function with a schedule policy. The schedule determines the repetition strategy for the action.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/repetition.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval action:      ZIO[R, E, A] = ???\nval policy: Schedule[R1, A, B] = ???\n\nval repeated = action repeat policy\n```\n\n----------------------------------------\n\nTITLE: Implementing Stream Unfolding for Pagination\nDESCRIPTION: First attempt at converting paginated API to stream using unfold operation, which doesn't handle the last page correctly.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nval firstAttempt: ZStream[Console, Throwable, RowData] = \n  ZStream.unfoldChunkM(0) { pageNumber =>\n    for {\n      page <- listPaginated(pageNumber)\n    } yield\n      if (page.isLast) None\n      else Some((page.results, pageNumber + 1))\n  }\n```\n\n----------------------------------------\n\nTITLE: Asserting String Contains Substring in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if a `String` contains the specified substring `element`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\ncontainsString(element: String)\n```\n\n----------------------------------------\n\nTITLE: Catching Some Errors with catchSome in ZIO for Scala\nDESCRIPTION: Here, only specific error types (such as FileNotFoundException) are handled while others are re-thrown. The example shows pattern matching inside catchSome to selectively recover from certain failures and fall back as needed. It keeps the same error type while potentially widening it. Inputs are file reads; outputs are the result or fallback. Dependencies include ZIO, IO, and relevant exception types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nval data: IO[IOException, Array[Byte]] = \n  openFile(\"primary.data\").catchSome {\n    case _ : FileNotFoundException => \n      openFile(\"backup.data\")\n  }\n```\n\n----------------------------------------\n\nTITLE: Converting Mutable State to Function Transformation Pipeline in Scala\nDESCRIPTION: Refactoring the mutable state operations into a series of function calls where each function takes a state and returns a new transformed state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef foo(state: Int): Int = bar(state + 1)\ndef bar(state: Int): Int = baz(state * 2)\ndef baz(state: Int): Int = state * state\n\nprintln(foo(5)) \n// Output: 144\n```\n\n----------------------------------------\n\nTITLE: Cancelling Server Socket Accept in Scala ZIO\nDESCRIPTION: This example shows how to make a ServerSocket's accept() method cancellable using effectBlockingCancelable. Since accepting connections is a blocking operation that doesn't respond to interrupts, we provide a close() method as the cancellation action.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/blocking.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport java.net.{Socket, ServerSocket}\ndef accept(ss: ServerSocket): RIO[Blocking, Socket] =\n  effectBlockingCancelable(ss.accept())(UIO.effectTotal(ss.close()))\n```\n\n----------------------------------------\n\nTITLE: Taking an Element from a TQueue in ZIO STM\nDESCRIPTION: Retrieves and removes the first element from a TQueue using the take method within an STM transaction. If the queue is empty, it will block until an element is available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueTake: UIO[Int] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offerAll(List(1, 2))\n  res    <- tQueue.take\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Defining a Commutative Property for Addition in Scala\nDESCRIPTION: Demonstrates how to define a property for checking if addition is commutative. It includes a placeholder implementation for the add function and a predicate to test commutativity.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/getting-started.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = ???\n\ndef is_add_commutative(a: Int, b: Int): Boolean =\n  add(a, b) == add(b, a)\n```\n\n----------------------------------------\n\nTITLE: Using Logical OR Operator with assertTrue in Scala\nDESCRIPTION: Shows how to use the || operator to combine assertions in ZIO Test, where at least one assertion must be true.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nsuite(\"||\")(\n  test(\"false || true\") {\n    assertTrue(false) || assertTrue(true) // this will pass\n  },\n  test(\"true || false\") {\n    assertTrue(true) || assertTrue(false) // this will pass\n  },\n  test(\"true || true\") {\n    assertTrue(true) || assertTrue(true) // this will pass\n  },\n  test(\"false || false\") {\n    assertTrue(false) || assertTrue(false) // this will false\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Folding ZIO Effects with Secondary Effect\nDESCRIPTION: Illustrates the use of foldZIO method in ZIO to handle both failure and success cases by specifying effects to be executed in each case.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval primaryOrSecondaryData: ZIO[Any, IOException, Array[Byte]] = \n  openFile(\"primary.data\").foldZIO(\n    _    => openFile(\"secondary.data\"), // Error handler\n    data => ZIO.succeed(data))          // Success handler\n```\n\n----------------------------------------\n\nTITLE: Merging and Transforming ZIO Streams with mergeWith\nDESCRIPTION: This snippet demonstrates using mergeWith to merge two streams of different types and transform the elements to a common type (Int) during the merge operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(\"1\", \"2\", \"3\")\nval s2 = ZStream(4.1, 5.3, 6.2)\n\nval merged = s1.mergeWith(s2)(_.toInt, _.toInt)\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO 2.x Unsafe Marker and Runtime UnsafeAPI in Scala\nDESCRIPTION: This Scala snippet introduces the ZIO 2.x approach to unsafe operations. It defines the `Unsafe` object and marker trait, along with the `Runtime.UnsafeAPI` which contains the new `run` method. The `Unsafe` type acts as a capability, making unsafe operations explicit in the type signature or requiring an `unsafe` block.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nobject Unsafe {\n  def unsafe[A](f: Unsafe => A): A = ???\n}\n\ntrait Runtime[+R] { self =>\n  def unsafe: UnsafeAPI\n  \n  trait UnsafeAPI {\n    def run[E, A](zio: ZIO[R, E, A])(implicit trace: Trace, unsafe: Unsafe): Exit[E, A]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming a Stream with fold in Scala\nDESCRIPTION: These examples show how to consume a stream by folding its elements into a single value. The first fold sums all elements, while foldWhile conditionally accumulates elements until a predicate is satisfied, both returning a ZIO with the result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_66\n\nLANGUAGE: scala\nCODE:\n```\nval s1: ZIO[Any, Nothing, Int] = ZStream(1, 2, 3, 4, 5).fold(0)(_ + _)\nval s2: ZIO[Any, Nothing, Int] = ZStream.iterate(1)(_ + 1).foldWhile(0)(_ <= 5)(_ + _)\n```\n\n----------------------------------------\n\nTITLE: Creating a Chunk with Specified Values in Scala\nDESCRIPTION: Creates a Chunk by directly providing element values as arguments.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval specifiedValuesChunk = Chunk(1,2,3)\n```\n\n----------------------------------------\n\nTITLE: Implementing ZLayer for Editor, Compiler, and Formatter\nDESCRIPTION: Implementation of ZLayer for Editor, Compiler, and Formatter classes, demonstrating how to create layers for each component.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Formatter {\n  val layer: ZLayer[Any, Nothing, Formatter] =\n    ZLayer.succeed(new Formatter())\n}\n\nobject Compiler {\n  val layer: ZLayer[Any, Nothing, Compiler] =\n    ZLayer.succeed(new Compiler())\n}\n\nobject Editor {\n  val layer: ZLayer[Formatter with Compiler, Nothing, Editor] =\n    ZLayer {\n      for {\n        formatter <- ZIO.service[Formatter]\n        compiler  <- ZIO.service[Compiler]\n      } yield new Editor(formatter, compiler) \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving a TRef Value Across Multiple Transactions in Scala ZIO STM\nDESCRIPTION: Creates a TRef in one transaction and retrieves its value in a separate transaction. This demonstrates how to work with TRefs across multiple transaction boundaries.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval retrieveMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  value <- tRef.get.commit\n} yield value\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom ZIO Mock Layer (Scala)\nDESCRIPTION: Presents an expanded mock object for AccountObserver, providing explicit tag, method, and layer definitions for use with ZIO's testing ecosystem. Includes capability tags, ZLayer composition, and method proxies, demonstrating the result of using @mockable. Input: AccountEvent, Output: UIO[Unit] for processEvent, with custom proxy integration. Useful for advanced or manual test setups.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{ Has, UIO, URLayer, ZLayer }\nimport zio.test.mock.{ Mock, Proxy }\n\nobject AccountObserverMock extends Mock[Has[AccountObserver.Service]] {\n\n  object ProcessEvent extends Effect[AccountEvent, Nothing, Unit]\n  object RunCommand   extends Effect[Unit, Nothing, Unit]\n\n  val compose: URLayer[Has[Proxy], AccountObserver] =\n    ZLayer.fromServiceM { proxy =>\n      withRuntime.map { rts =>\n        new AccountObserver.Service {\n          def processEvent(event: AccountEvent) = proxy(ProcessEvent, event)\n          def runCommand: UIO[Unit]           = proxy(RunCommand)\n        }\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing System Properties with ZIO System Service\nDESCRIPTION: Shows how to retrieve system properties using the ZIO System service's property function. The example checks for the LOG_LEVEL property and handles both cases when it's set or not set.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/system.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  user <- System.property(\"LOG_LEVEL\")\n  _    <- user match {\n           case Some(value) => \n             Console.printLine(s\"The LOG_LEVEL property is: $value\")\n           case None => \n             Console.printLine(\"Oops! The LOG_LEVEL property is not set\")\n         }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Executing Parallel Foreach with Fixed Parallelism in ZIO 1.x (Scala)\nDESCRIPTION: Demonstrates the ZIO 1.x approach for processing a collection (`urls`) in parallel using a fixed number of fibers. It uses `ZIO.foreachParN(8)` to apply the `download` function to each URL, ensuring that no more than 8 `download` effects run concurrently. This pattern is deprecated in ZIO 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nZIO.foreachParN(8)(urls)(download)\n```\n\n----------------------------------------\n\nTITLE: Lock Upgrading and Downgrading in Scala\nDESCRIPTION: Demonstrates how to upgrade from a read lock to a write lock and then downgrade back to a read lock.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/treentrantlock.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval upgradeDowngradeProgram: UIO[(Boolean, Boolean, Boolean, Boolean)] = for {\n  lock               <- TReentrantLock.make.commit\n  _                  <- lock.acquireRead.commit\n  _                  <- lock.acquireWrite.commit  // upgrade\n  isWriteLocked      <- lock.writeLocked.commit   // now write-locked\n  isReadLocked       <- lock.readLocked.commit    // and read-locked\n  _                  <- lock.releaseWrite.commit  // downgrade\n  isWriteLockedAfter <- lock.writeLocked.commit   // no longer write-locked\n  isReadLockedAfter  <- lock.readLocked.commit    // still read-locked\n} yield (isWriteLocked, isReadLocked, isWriteLockedAfter, isReadLockedAfter)\n```\n\n----------------------------------------\n\nTITLE: ZIO 2.x App Implementation\nDESCRIPTION: Example showing the new way to implement applications in ZIO 2.x using ZIOAppDefault trait.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.ZIOAppDefault\nimport zio.Console._\n\nobject MyApp extends ZIOAppDefault {\n  def run =\n    for {\n      arguments <- getArgs\n      _         <- startMyApp(arguments) \n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: FiberRef Join Semantics\nDESCRIPTION: Shows how FiberRef values are merged back into parent fibers when using join operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n```\n\n----------------------------------------\n\nTITLE: CyclicBarrier Internal Structure\nDESCRIPTION: Shows the internal implementation structure of CyclicBarrier with private fields.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/cyclicbarrier.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass CyclicBarrier private (\n  private val _parties: Int,\n  private val _waiting: Ref[Int],\n  private val _lock: Ref[Promise[Unit, Unit]],\n  private val _action: UIO[Any],\n  private val _broken: Ref[Boolean]\n)\n```\n\n----------------------------------------\n\nTITLE: Passing Through Dependencies in ZLayers with Scala\nDESCRIPTION: Shows how to pass through dependencies in ZLayers using the passthrough operator and ZLayer.service. This technique allows including intermediate dependencies in the final layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval fooLayer: ZLayer[A, Nothing, B] = ???  // A ==> B\n\nval result1 : ZLayer[A, Nothing, A & B] =  // A ==> A & B\n  fooLayer.passthrough\n  \nval result2 : ZLayer[A, Nothing, A & B] =  // A ==> A & B\n  ZLayer.service[A] ++ fooLayer\n \n// (A ==> A) ++ (A ==> B)\n// (A ==> A & B)\n```\n\n----------------------------------------\n\nTITLE: ZIO FHIR Indexer Implementation Example\nDESCRIPTION: Complete example showing how to implement a FHIR resource indexer using ZIO. Demonstrates creation of a ConditionIndexer class, configuration layers, and ZIO runtime setup with dependency injection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/fhir-indexer.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject ZioApp extends ZIOAppDefault {\n\n  class ConditionIndexer(override val hapiFhirClient: FHIRHapiClient) extends ApiIndexer {\n    override type ProcessResult = Unit\n\n    override def indexApi[T <: IParam](searchMetadata: RequestMetadata[T]): ZIO[Any, Throwable, Unit] = {\n      for {\n        data <- createPagedApiIndexingFlow[Encounter, T](searchMetadata)\n        _ <- ZIO.log(s\"Processed api: ${getClass.getSimpleName} with ${data.size} entries\")\n      } yield ()\n    }\n  }\n\n  object ConditionIndexer {\n    val layer: ZLayer[FHIRHapiClient, Nothing, ConditionIndexer] = ZLayer {\n      for {\n        hapiClient <- ZIO.service[FHIRHapiClient]\n      } yield new ConditionIndexer(hapiClient)\n    }\n  }\n\n  def myApp: ZIO[ConditionIndexer, Nothing, Exit[Throwable, Unit]] = {\n    val requestMetadata = RequestMetadata[TokenClientParam](\"\")\n    for {\n      conditionsService <- ZIO.service[ConditionIndexer]\n      zio = conditionsService.indexApi[TokenClientParam](requestMetadata)\n    } yield {\n      Unsafe.unsafe { implicit unsafe =>\n        Runtime.default.unsafe.run(zio)\n      }\n    }\n  }\n\n  object FhirConfigTest {\n    val layer: zio.ZLayer[Any, Nothing, FhirIndexingConfig] =\n      zio.ZLayer.succeed(FhirIndexingConfig(url = \"\",\n        authUrl =\"/oauth2/token\",\n        clientId = \"\",\n        secret = \"\"))\n  }\n\n\n  override def run: ZIO[Any, Throwable, Exit[Throwable, Unit]] = {\n    myApp.debug(\"example\")\n      .provide(\n        Client.default,\n        FhirConfigTest.layer,\n        FhirAuthClientImpl.layer(),\n        FHIRHapiClientImpl.layer(),\n        ConditionIndexer.layer\n      )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Loss of Referential Transparency in Imperative Error Handling\nDESCRIPTION: Illustrates how imperative error handling can break referential transparency in Scala functions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef divide10By(b: Int): Option[Int] = {\n  val result = divide(10, b)\n  try {\n    Some(result)\n  } catch {\n    case _: IllegalArgumentException => None\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Time-based Aggregation with ZStream#aggregateAsyncWithin in Scala\nDESCRIPTION: The aggregateAsyncWithin method combines element count-based and time-based aggregation. It emits chunks either when the transducer has collected its target number of elements or when the schedule triggers, whichever comes first.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_60\n\nLANGUAGE: scala\nCODE:\n```\nabstract class ZStream[-R, +E, +O] {\n  def aggregateAsyncWithin[R1 <: R, E1 >: E, P](\n    transducer: ZTransducer[R1, E1, O, P],\n    schedule: Schedule[R1, Chunk[P], Any]\n  ): ZStream[R1 with Clock, E1, P] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Service Interface in Scala\nDESCRIPTION: Shows how to define a basic service interface using a Scala trait, which is the first step in implementing the service pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait FooService {\n\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Sized Integer Generator in Scala\nDESCRIPTION: Example of creating a sized generator that generates integer values within a range determined by the current size.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/sized.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nval sizedInts: Gen[Any, Int] = \n  Gen.sized(Gen.int(0, _))\n```\n\n----------------------------------------\n\nTITLE: Horizontal Composition of ZLayers in Scala\nDESCRIPTION: Demonstrates horizontal composition of two ZLayers using the ++ operator. This composition combines the requirements and capabilities of both layers side-by-side.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???        // A ==> B\nval barLayer: ZLayer[C, Nothing  , D] = ???        // C ==> D\n\nval horizontal: ZLayer[A & C, Throwable, B & D] =  // A & C ==> B & D\n  fooLayer ++ barLayer\n```\n\n----------------------------------------\n\nTITLE: Migrating ZManaged.make to ZIO.acquireRelease in Scala\nDESCRIPTION: Example of replacing ZManaged.make with ZIO.acquireRelease for resource acquisition and release in ZIO 2.0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_70\n\nLANGUAGE: scala\nCODE:\n```\n- ZManaged.fromAutoCloseable(\n-   zio.blocking.effectBlockingIO(new FileInputStream(\"file.txt\")) \n- )\n+ ZIO.fromAutoCloseable(\n+   ZIO.attemptBlockingIO(new FileInputStream(\"file.txt\")) \n+ )\n```\n\n----------------------------------------\n\nTITLE: Composing Layers for Dependency Graph in ZIO 1.x\nDESCRIPTION: This snippet demonstrates how to manually compose layers to create a dependency graph in ZIO 1.x. It shows the complex process of combining multiple layers with vertical and horizontal compositions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nval appLayer: URLayer[Any, DocRepo with UserRepo] =\n  (((Console.live >>> Logging.live) ++ Database.live ++ (Console.live >>> Logging.live >>> BlobStorage.live)) >>> DocRepo.live) ++\n    (((Console.live >>> Logging.live) ++ Database.live) >>> UserRepo.live)\n    \nval res: ZIO[Any, Nothing, Unit] = myApp.provideLayer(appLayer)\n```\n\n----------------------------------------\n\nTITLE: Combining mapM and contramapM for Time-in-Queue Measurement in Scala\nDESCRIPTION: Combines contramapM and mapM to capture enqueue and dequeue timestamps and compute duration in the queue. Uses zio.duration._ for duration calculation and requires ZIO Clock and zio._. Returns a queue producing (Duration, String).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.duration._\\n\\nval timeQueued: UIO[ZQueue[Clock, Clock, Nothing, Nothing, String, (Duration, String)]] =\\n  for {\\n    queue <- Queue.bounded[(Long, String)](3)\\n    enqueueTimestamps = queue.contramapM { el: String =>\\n      currentTimeMillis.map((_, el))\\n    }\\n    durations = enqueueTimestamps.mapM { case (enqueueTs, el) =>\\n      currentTimeMillis\\n        .map(dequeueTs => ((dequeueTs - enqueueTs).millis, el))\\n    }\\n  } yield durations\\n\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Helper Methods with ZState in Scala\nDESCRIPTION: Demonstrates the helper methods available on the ZIO data type for working with ZState, including updateState, getState, and getStateWith. These methods provide a more direct way to interact with state from the environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/zstate.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nfinal case class MyState(counter: Int)\n\nval myApp: ZIO[ZState[MyState], IOException, Int] =\n  for {\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 1))\n    _ <- ZIO.updateState[MyState](state => state.copy(counter = state.counter + 2))\n    state <- ZIO.getStateWith[MyState](_.counter)\n    _ <- Console.printLine(s\"Current state: $state\")\n  } yield state\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO#orElseFail and ZIO#orElseSucceed Signatures in Scala\nDESCRIPTION: These method signatures show how to handle failures by providing constant fallback values. `orElseFail` replaces any failure of the original effect with a new, specified failure value `e1` of type `E1`. `orElseSucceed` replaces any failure with a specified success value `a1` of type `A1`, making the resulting effect infallible (`Nothing` error type).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +R, +E] {\n  def orElseFail[E1](e1: => E1): ZIO[R, E1, A]\n\n  def orElseSucceed[A1 >: A](a1: => A1): ZIO[R, Nothing, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fail-Fast Behavior with ZIO#zip in Scala\nDESCRIPTION: This snippet shows how ZIO#zip stops at the first error, only returning the first failure in the stack trace.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/error-accumulation.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val f1: ZIO[Any, Nothing, Int] = ZIO.succeed(1)\n  val f2: ZIO[Any, String, Int]  = ZIO.fail(\"Oh uh!\").as(2)\n  val f3: ZIO[Any, Nothing, Int] = ZIO.succeed(3)\n  val f4: ZIO[Any, String, Int]  = ZIO.fail(\"Oh no!\").as(4)\n\n  val myApp: ZIO[Any, String, (Int, Int, Int, Int)] =\n    f1 zip f2 zip f3 zip f4\n\n  def run = myApp.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Editor with ZIO flatMap\nDESCRIPTION: Example of creating an Editor instance using ZIO's flatMap to handle the effectful Counter constructor.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval editor: ZIO[Any, Nothing, Editor] =\n  Counter.make.map { counter =>\n    new Editor(\n      Formatter.make,\n      Compiler.make,\n      counter\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: CyclicBarrier Reset Operation Example\nDESCRIPTION: Demonstrates how to reset a barrier and handle interrupted tasks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/cyclicbarrier.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent.CyclicBarrier\n\nobject MainApp extends ZIOAppDefault {\n  def task(name: String, b: CyclicBarrier) =\n    for {\n      _ <- ZIO.debug(s\"task-$name: started my job right now!\")\n      _ <- b.await\n      _ <- ZIO.debug(\n             s\"task-$name: the barrier is now released, \" +\n               s\"so I'm going to exit immediately!\"\n           )\n    } yield ()\n\n  def run =\n    for {\n      b  <- CyclicBarrier.make(3)\n      f1 <- task(\"1\", b).fork\n      f2 <- task(\"2\", b).fork\n      f3 <-\n        (ZIO.sleep(1.second) *> task(\"3\", b))\n          .onInterrupt(\n            ZIO.debug(\n              \"task-3: I started my job with some delay! \" +\n                \"so before getting the chance to await on the barrier, \" +\n                \"the reset operation interrupted me!\"\n            )\n          )\n          .fork\n      _ <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n      _ <- f2.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n      _ <- b.waiting.debug(\"waiting fibers before reset\")\n      _ <- ZIO.whenZIO(f3.status.map(_.isInstanceOf[Fiber.Status.Running]))(b.reset)\n      _ <- b.waiting.debug(\"waiting fibers after reset\")\n      _ <- f1.join\n      _ <- f2.join\n      _ <- f3.join\n    } yield ()\n```\n\n----------------------------------------\n\nTITLE: Including Hidden Dependencies in ZLayer Composition with Scala\nDESCRIPTION: Demonstrates how to include hidden dependencies when composing ZLayers vertically. This is useful when intermediate dependencies need to be exposed in the final layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/manual-layer-construction.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval fooLayer: ZLayer[A, Throwable, B] = ???  // A  ==> B\nval barLayer: ZLayer[B, Throwable, C] = ???  // B  ==> C\n\nval finalLayer: ZLayer[A & B, Throwable, C] = // A & B ==> C\n  (fooLayer ++ ZLayer.service[B]) >>> barLayer\n\n// ((A ==> B) ++ (B ==> B)) >>> (B ==> C)\n// (A & B ==> B) >> (B ==> C)\n// (A & B ==> C)\n```\n\n----------------------------------------\n\nTITLE: Http4s Integration with ZIO (Cats Effect 3)\nDESCRIPTION: Example of creating an Http4s web server using ZIO and Cats Effect 3, implementing a simple Hello World route with updated type classes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.Applicative\nimport cats.effect.Async\nimport fs2.Stream\nimport org.http4s.HttpRoutes\nimport org.http4s.blaze.client.BlazeClientBuilder\nimport org.http4s.blaze.server.BlazeServerBuilder\nimport org.http4s.dsl.Http4sDsl\nimport zio.interop.catz._\nimport zio.{Task, URIO}\n\nimport scala.concurrent.ExecutionContext.global\n\nobject ZioHttp4sInterop extends zio.interop.catz.CatsApp {\n  def stream[F[_]: Async]: Stream[F, Nothing] = {\n    import org.http4s.implicits._\n    val httpApp = helloWorldRoute[F].orNotFound\n    for {\n      _ <- BlazeClientBuilder[F](global).stream\n      exitCode <- BlazeServerBuilder[F](global)\n        .bindHttp(8080, \"0.0.0.0\")\n        .withHttpApp(httpApp)\n        .serve\n    } yield exitCode\n  }.drain\n\n  def helloWorldRoute[F[_]: Applicative]: HttpRoutes[F] = {\n    val dsl = new Http4sDsl[F] {}\n    import dsl._\n    HttpRoutes.strict[F] { case GET -> Root =>\n      Ok(\"Hello, World!\")\n    }\n  }\n\n  def run(args: List[String]): URIO[Any, zio.ExitCode] =\n    stream[Task].compile.drain.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Counter Increment Implementation in Scala\nDESCRIPTION: Initial implementation of an increment function using Ref that is not atomic and susceptible to race conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef inc(counter: Ref[Int], amount: Int) = for {\n  c <- counter.get\n  _ <- counter.set(c + amount)\n} yield c\n```\n\n----------------------------------------\n\nTITLE: Wiring and Running the Event Sourced Application with ZIO (Scala)\nDESCRIPTION: This Scala snippet defines the main ZIO application entry point, wiring up the backend service and HTTP app, and starting the HTTP server on port 8090. It leverages ZIO's resource scoping, effect composition and interop with Cats Effect. Dependencies are ZIO, zio-http, BackendService, and provide Console for logging. Inputs are none; it wires previously defined services, initiates serving, and manages resource acquisition and release.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.*\nimport zio.interop.catz.*\nimport zio.http.*\nimport cats.effect.std.Console\n\nobject MainApp extends ZIOAppDefault {\n  given Console[Task] = Console.make[Task]\n\n  def run =\n    ZIO.scoped {\n      for {\n        backendService <- BackendService.service\n        _ <- ZIOCounterHttpApp(backendService).serve.provide(Server.defaultWithPort(8090))\n      } yield ()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Non-Exhaustive catchAll Match Causing Defect - Scala\nDESCRIPTION: Illustrates the result of an incomplete catchAll match, where failure to cover all exceptions causes a MatchError defect. The code implements a main ZIOAppDefault with a partial pattern match and documents the runtime MatchError. The run method returns a ZIO effect that may fail and result in a defect due to incomplete matching.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n  val result: ZIO[Any, Nothing, Int] =\n    validate(15)\n      .catchAll {\n        case NegativeAgeException(age) =>\n          ZIO.debug(s\"negative age: $age\").as(-1)\n//        case IllegalAgeException(age) =>\n//          ZIO.debug(s\"illegal age: $age\").as(-1)\n      }\n\n  def run = result\n}\n\n// Output:\n// timestamp=2022-03-01T06:33:13.454651904Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" scala.MatchError: MainApp$IllegalAgeException (of class MainApp$IllegalAgeException)\n//\\tat MainApp$.$anonfun$result$1(MainApp.scala:6)\n//\\tat scala.util.Either.fold(Either.scala:190)\n//\\tat zio.ZIO.$anonfun$foldZIO$1(ZIO.scala:945)\n//  ...\n//\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:538)\"\n```\n\n----------------------------------------\n\nTITLE: Creating and Debugging Interrupt Cause in Scala\nDESCRIPTION: Demonstrates how to create and debug Interrupt causes in ZIO, including examples of interrupting fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.interrupt.cause.debug\n// Interrupt(Runtime(2,1646471715),Trace(Runtime(2,1646471715),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n\nZIO.never.fork\n  .flatMap(f => f.interrupt *> f.join)\n  .cause\n  .debug\n// Interrupt(Runtime(2,1646472025),Trace(Runtime(13,1646472025),Chunk(<empty>.MainApp.run(MainApp.scala:7))))\n```\n\n----------------------------------------\n\nTITLE: Releasing a Permit to TSemaphore in Scala ZIO\nDESCRIPTION: Demonstrates how to release a permit back to a TSemaphore after using a shared resource. This example creates a semaphore with 1 permit, acquires it, and then releases it within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tsemaphore.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreRelease: STM[Nothing, TSemaphore] = for {\n  tSem <- TSemaphore.make(1L)\n  _    <- tSem.acquire\n  _    <- tSem.release\n} yield tSem\n\ntSemaphoreRelease.commit\n```\n\n----------------------------------------\n\nTITLE: Using unsafeRun for ZIO Effect Execution\nDESCRIPTION: Example demonstrating direct execution of ZIO effects using unsafeRun\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject RunZIOEffectUsingUnsafeRun extends scala.App {\n  zio.Runtime.default.unsafeRun(\n    myAppLogic\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO SandboxWith Operator Signature in Scala\nDESCRIPTION: Shows the type signature for the `sandboxWith` method. This operator provides a combined way to sandbox an effect, apply a function (often for error handling) to the sandboxed effect, and then unsandbox the result. The provided function `f` operates on the `ZIO[R1, Cause[E], A]` and returns a potentially transformed effect `ZIO[R1, Cause[E2], B]`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/sandboxing.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def sandboxWith[R1 <: R, E2, B](f: ZIO[R1, Cause[E], A] => ZIO[R1, Cause[E2], B])\n}\n```\n\n----------------------------------------\n\nTITLE: Effectful Folding of TArray Elements in Scala ZIO STM\nDESCRIPTION: Shows how to perform effectful folding of TArray elements using foldM\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldMTArray: UIO[Int] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  sum    <- tArray.foldM(0)((acc, el) => STM.succeed(acc + el))\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: Collecting Leftover Values with ZIO Sink\nDESCRIPTION: Demonstrates how to collect leftover values from a ZIO Stream after sink consumption. Shows two examples: one collecting 3 elements with remaining values, and another taking the head element with remaining values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/leftovers.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval s1: ZIO[Any, Nothing, (Chunk[Int], Chunk[Int])] =\n  ZStream(1, 2, 3, 4, 5).run(\n    ZSink.take(3).collectLeftover\n  )\n// Output: (Chunk(1, 2, 3), Chunk(4, 5))\n\n\nval s2: ZIO[Any, Nothing, (Option[Int], Chunk[Int])] =\n  ZStream(1, 2, 3, 4, 5).run(\n    ZSink.head[Int].collectLeftover\n  )\n// Output: (Some(1), Chunk(2, 3, 4, 5))\n```\n\n----------------------------------------\n\nTITLE: Adding Jitter to Schedules\nDESCRIPTION: Demonstrates adding randomization to schedule delays using jittered. Helps prevent thundering herd problems in distributed systems.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval jitteredExp = Schedule.exponential(10.milliseconds).jittered\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Stream to Publisher\nDESCRIPTION: Illustrates the conversion of a ZIO Stream to a Reactive Streams Publisher.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-reactive-streams.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval stream = Stream.range(3, 13)\nruntime.unsafeRun(\n  stream.toPublisher.flatMap { publisher =>\n    UIO(publisher.subscribe(subscriber))\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Expected Output for ZIO Resurrect Example (Failure)\nDESCRIPTION: Shows the console output and stack trace when running the ZIO application that uses `resurrect`. The output indicates an `InterruptedException` because `resurrect` does not convert fiber interruptions into failures, letting the interruption terminate the fiber and log an error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/converting-defects-to-failures.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntimestamp=2022-02-18T14:21:52.559872464Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.InterruptedException: Interrupted by thread \\\"zio-fiber-\\\"\n\tat <empty>.MainApp.effect2(MainApp.scala:10)\n\tat <empty>.MainApp.effect2(MainApp.scala:11)\n\tat <empty>.MainApp.effect2(MainApp.scala:12)\n\tat <empty>.MainApp.run(MainApp.scala:15)\n\tat <empty>.MainApp.run(MainApp.scala:16)\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Profile Picture Retrieval Function with Logging Spans in Scala\nDESCRIPTION: Shows a practical example of using logging spans in a function that retrieves a user's profile picture, including multiple log statements within the span.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class User(id: String, name: String, profileImage: String)\n\ndef getProfilePicture(username: String) =\n  ZIO.logSpan(\"get-profile-picture\") {\n    for {\n      _    <- ZIO.log(s\"Getting information of $username from the UserService\")\n      user <- ZIO.succeed(User(\"1\", \"john\", \"john.png\"))\n      _    <- ZIO.log(s\"Downloading profile image ${user.profileImage}\")\n      img  <- ZIO.succeed(Array[Byte](1, 2, 3))\n      _    <- ZIO.log(\"Profile image downloaded\")\n    } yield img\n  }\n```\n\n----------------------------------------\n\nTITLE: Handling User Input and Validation Recovery with ZIO.either (Scala)\nDESCRIPTION: This snippet illustrates a realistic application where user input for age is collected, validated, and the result is handled using pattern matching over the Either produced by ZIO.either. It demonstrates for-comprehension, dependency on Console and Java IO classes, and conditional logging based on validation outcome. Input is read from the console, converted to Int, and handled accordingly; dependencies include zio.Console and java.io.IOException.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\nimport java.io.IOException\n\nval myApp: ZIO[Any, IOException, Unit] =\n  for {\n    _ <- Console.print(\"Please enter your age: \")\n    age <- Console.readLine.map(_.toInt)\n    res <- validate(age).either\n    _ <- res match {\n      case Left(error) => ZIO.debug(s\"validation failed: $error\")\n      case Right(age) => ZIO.debug(s\"The $age validated!\")\n    }\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Forking Fiber Interruption in Scala using ZIO\nDESCRIPTION: This code shows how to fork the interruption of a fiber into a new fiber in ZIO, allowing for non-blocking interruption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/basic-concurrency.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiber <- ZIO.succeed(\"Hi!\").forever.fork\n  _     <- fiber.interrupt.fork // I don't care!\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Converting Java Streams to ZIO Streams in Scala\nDESCRIPTION: Shows how to convert a Java Stream to a ZIO Stream using ZStream.fromJavaStream and ZStream.fromJavaIterator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef fromJavaStream[A](stream: => java.util.stream.Stream[A]): ZStream[Any, Throwable, A] =\n  ZStream.fromJavaIterator(stream.iterator())\n```\n\n----------------------------------------\n\nTITLE: Transforming Elements of a TSet Effectfully in Scala ZIO STM\nDESCRIPTION: Transforms each element in a TSet by applying an effectful function (squaring each value in this case) using transformSTM. This is a destructive operation that modifies the original collection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformSTMTSet: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.transformSTM(a => STM.succeed(a * a))\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: Testing Deeply Nested Values with TestLens in Scala\nDESCRIPTION: Shows how to test deeply nested values using TestLens operators in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ntest(\"assertion of multiple nested values (TestLens#right.some)\") {\n  val sut: Either[Error, Option[Int]] = Right(Some(40 + 2))\n  assertTrue(sut.is(_.right.some) == 42)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Try to ZIO Effect with ZIO.fromTry - Scala\nDESCRIPTION: Illustrates use of ZIO.fromTry to wrap a scala.util.Try computation (here, division by zero). The resulting effect encodes Try's failure (Throwable) or success (42). Input is a Try; output is a ZIO effect failing with Throwable on Try failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.util.Try\n\nval ztry = ZIO.fromTry(Try(42 / 0))\n```\n\n----------------------------------------\n\nTITLE: Using FiberRef for Contextual Values in ZIO\nDESCRIPTION: Demonstrates using ZIO's FiberRef for managing contextual values like UserId and CorrelationId. This approach provides fiber-local state without exposing requirements in the type signature.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/faq.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval currentUserId: FiberRef[UserId] = ???\nval currentCorrelationId: FiberRef[CorrelationId] = ???\n\ndef someEffect(...): ZIO[Any, ErrorType, A] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: Using Semaphore with Multiple Permits in ZIO (Scala)\nDESCRIPTION: This example shows how to use withPermits to acquire multiple permits at once from a semaphore. It demonstrates a task that requires 5 permits to execute, which is useful for resource allocation scenarios where operations require different quantities of a resource.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/semaphore.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval semTaskN = (sem: Semaphore) => for {\n  _ <- sem.withPermits(5)(task)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Error Cleanup with onError in ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#onError to perform cleanup operations when a stream fails. This allows executing a ZIO effect for resource cleanup regardless of how the stream terminates.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_73\n\nLANGUAGE: scala\nCODE:\n```\nval stream = \n  (ZStream(1, 2, 3) ++ ZStream.dieMessage(\"Oh! Boom!\") ++ ZStream(4, 5))\n    .onError(_ => putStrLn(\"Stream application closed! We are doing some cleanup jobs.\").orDie)\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#retryUntil to Retry Based on Error Condition in Scala\nDESCRIPTION: Illustrates the use of `retryUntil`. The `remoteService` effect is retried indefinitely as long as it fails, until the failure error is equal to `DataCorrupted`. Requires the `remoteService` definition and its associated error types (`DataCorrupted`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nremoteService.retryUntil(_ == DataCorrupted)\n```\n\n----------------------------------------\n\nTITLE: Defining Service Traits and Layers in Scala\nDESCRIPTION: This snippet defines several service traits (Cake, Chocolate, Flour, Spoon) and their corresponding ZLayers. It demonstrates the dependency relationships between these services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/automatic-layer-construction.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Cake\n\nobject Cake {\n  val live: ZLayer[Chocolate & Flour, Nothing, Cake] =\n    for {\n      _ <- ZLayer.environment[Chocolate & Flour]\n      cake <- ZLayer.succeed(new Cake {})\n    } yield cake\n}\n\ntrait Spoon\n\nobject Spoon {\n  val live: ULayer[Spoon] =\n    ZLayer.succeed(new Spoon {})\n}\n\ntrait Chocolate\n\nobject Chocolate {\n  val live: ZLayer[Spoon, Nothing, Chocolate] =\n    ZLayer.service[Spoon].project(_ => new Chocolate {})\n}\n\ntrait Flour\n\nobject Flour {\n  val live: ZLayer[Spoon, Nothing, Flour] =\n    ZLayer.service[Spoon].project(_ => new Flour {})\n}\n```\n\n----------------------------------------\n\nTITLE: Producing Records to Kafka Topic\nDESCRIPTION: Helper function to produce records to a Kafka topic using zio-kafka Producer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef produceRecord(producer: Producer, topic: String, key: Long, value: String): RIO[Any, RecordMetadata] =\n  producer.produce[Any, Long, String](\n    topic = topic,\n    key = key,\n    value = value,\n    keySerializer = Serde.long,\n    valueSerializer = Serde.string\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining `refineToOrDie` Signature in ZIO Scala\nDESCRIPTION: Shows the type signature of the `refineToOrDie` operator on a ZIO effect. This operator narrows the typed error channel `E` to a subtype `E1`, converting any other errors of type `E` that are not of type `E1` into defects (untyped errors).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nZIO[-R, +E, +A] {\n  def refineToOrDie[E1 <: E]: ZIO[R, E1, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Platform Line Separator with ZIO System Service\nDESCRIPTION: Demonstrates how to determine the line separator for the underlying platform using the lineSeparator method from the ZIO System service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/system.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nSystem.lineSeparator\n```\n\n----------------------------------------\n\nTITLE: Creating a Test Spec with Mocked Dependencies\nDESCRIPTION: Shows how to write a ZIO test specification that uses a mock environment. The test checks that the application behaves correctly when provided with the mocked Console service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nobject AccountObserverSpec extends DefaultRunnableSpec {\n  def spec = suite(\"processEvent\")(\n    testM(\"calls putStrLn > getStrLn > putStrLn and returns unit\") {\n      val result = app.provideLayer(mockEnv >>> AccountObserver.live)\n      assertM(result)(isUnit)\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Console Output Example Using URIO\nDESCRIPTION: Example of putStrLn function that requires Console service as environment and returns a URIO effect. This demonstrates practical usage of URIO type in console operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/urio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef putStrLn(line: => String): ZIO[Console, IOException, Unit] =\n  ZIO.accessM(_.get putStrLn line)\n```\n\n----------------------------------------\n\nTITLE: Non-atomic Money Transfer Implementation\nDESCRIPTION: Basic implementation of money transfer that doesn't guarantee atomic operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(from: Ref[Int], to: Ref[Int], amount: Int) = for {\n  _ <- withdraw(from, amount)\n  _ <- deposit(to, amount)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating Empty TPriorityQueue in Scala ZIO\nDESCRIPTION: Demonstrates how to create an empty TPriorityQueue using the default ordering and a custom reverse ordering for integers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpriorityqueue.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval minQueue: STM[Nothing, TPriorityQueue[Int]] =\n  TPriorityQueue.empty\n```\n\nLANGUAGE: scala\nCODE:\n```\nval maxQueue: STM[Nothing, TPriorityQueue[Int]] =\n  TPriorityQueue.empty(Ordering[Int].reverse)\n```\n\n----------------------------------------\n\nTITLE: Partial Dependency Injection with ZIO#provideSome in ZIO 2.x\nDESCRIPTION: This snippet shows how to use ZIO#provideSome for partial dependency injection in ZIO 2.x, which is similar to ZIO#provideSomeLayer in ZIO 1.x but with a simpler syntax.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_52\n\nLANGUAGE: scala\nCODE:\n```\nval app: ZIO[Any, Nothing, Unit] =\n  myApp.provideSome[Logging](\n    DocRepo.live,\n    Database.live,\n    BlobStorage.live,\n    UserRepo.live\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating Mock Service Capabilities with ZIO Test (Scala)\nDESCRIPTION: Defines a mock implementation of the 'Example' service using ZIO Test's Mock framework. Each mockable method or value is modeled as a capability tag (Effect, Method, Sink, or Stream), capturing inputs, errors, and outputs per method signature. Overloads are grouped in numbered objects. A compose value is declared (but here left unimplemented) for integrating the mock with the ZIO layer system. Dependencies: ZIO Test, Example service, Scala types as per Example. Inputs/outputs: Follows Example trait signatures, used for pre-programming expectations in unit tests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// test sources\n\nobject ExampleMock extends Mock[Example] {\n  object Static             extends Effect[Unit, Nothing, String]\n  object ZeroArgs           extends Effect[Unit, Nothing, Int]\n  object ZeroArgsWithParens extends Effect[Unit, Nothing, Long]\n  object SingleArg          extends Effect[Int, Nothing, String]\n  object MultiArgs          extends Effect[(Int, Long), Nothing, String]\n  object MultiParamLists    extends Effect[(Int, Long), Nothing, String]\n  object Command            extends Effect[Int, Nothing, Unit]\n  object Overloaded {\n    object _0 extends Effect[Int, Nothing, String]\n    object _1 extends Effect[Long, Nothing, String]\n  }\n  object Function extends Method[Int, Throwable, String]\n  object Sink     extends Sink[Any, String, Int, Int, List[Int]]\n  object Stream   extends Stream[Any, String, Int]\n\n  val compose: URLayer[Has[Proxy], Example] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Kubernetes ConfigMap Object in Scala\nDESCRIPTION: Example of creating a Kubernetes ConfigMap object using Scala k8s. Demonstrates setting metadata, labels, and data fields with both string and file-based values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/scala-k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport dev.hnaderi.k8s._  // base packages\nimport dev.hnaderi.k8s.implicits._  // implicit coversions and helpers\nimport dev.hnaderi.k8s.manifest._  // manifest syntax\n\nval config = ConfigMap(\n  metadata = ObjectMeta(\n    name = \"example\",\n    namespace = \"staging\",\n    labels = Map(\n      Labels.name(\"example\"),\n      Labels.instance(\"one\")\n    )\n  ),\n  data = DataMap(\n    \"some config\" -> \"some value\",\n    \"config file\" -> Data.file(\"config.json\")\n  ),\n  binaryData = DataMap.binary(\n    \"blob\" -> Data.file(\"blob.dat\"),\n    \"blob2\" -> Paths.get(\"blob2.bin\"),\n    \"other inline data\" -> \"some other data\"\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Creating an Unfolding Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that repeats one time from the specified state and iterator, using a function to unfold the next state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval unfold = Schedule.unfold(0)(_ + 1)\n```\n\n----------------------------------------\n\nTITLE: Creating Streams from Java IO Sources\nDESCRIPTION: Multiple examples of creating ZIO Streams from various Java IO sources including files and input streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nimport java.nio.file.Paths\nval file: ZStream[Blocking, Throwable, Byte] = \n  ZStream.fromFile(Paths.get(\"file.txt\"))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZStream[Blocking, IOException, Byte] = \n  ZStream.fromInputStream(new FileInputStream(\"file.txt\"))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZStream[Blocking, IOException, Byte] = \n  ZStream.fromInputStreamEffect(\n    ZIO.effect(new FileInputStream(\"file.txt\"))\n      .refineToOrDie[IOException]\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Assertion with TestArrow in Scala\nDESCRIPTION: Shows how to create a custom assertion using TestArrow, which is the underlying mechanism for assertions in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ndef sut = 40 + 2\nval assertion: Assertion[Int] = Assertion(TestArrow.fromFunction(_ == 42))\nassertion.test(sut) // true\n```\n\n----------------------------------------\n\nTITLE: Creating Unbounded TQueue in Scala ZIO\nDESCRIPTION: Creates an empty unbounded TQueue with no capacity limit using ZIO STM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueUnbounded: STM[Nothing, TQueue[Int]] = TQueue.unbounded[Int]\n```\n\n----------------------------------------\n\nTITLE: Creating Fresh, Non-shared Versions of ZIO Layers\nDESCRIPTION: This example demonstrates how to create fresh, non-shared versions of layers using ZLayer#fresh, resulting in multiple initializations of the 'a' layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-memoization.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[B & C, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[B]\n      _ <- ZIO.service[C]\n    } yield ()\n\n  def run = myApp.provideLayer((a.fresh >>> b) ++ (a.fresh >>> c))\n}\n// Output:\n// initialized: MainApp$$anon$22@7eb282da\n// initialized: MainApp$$anon$22@6397a26a\n```\n\n----------------------------------------\n\nTITLE: Implementing Baz Service in ZIO 2.x\nDESCRIPTION: Example of implementing the Baz service using Service Pattern 2.0 in ZIO 2.x. It demonstrates the use of constructor-based dependency injection and ZLayer creation using for comprehension.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_63\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 2.x\n\nimport zio._\n\n// Defining the Service Interface\ntrait Baz {\n  def baz(input: String): UIO[Unit]\n}\n\n// Implementation of the Service Interface\ncase class BazLive(fooSrv: Foo, barSrv: Bar) extends Baz {\n  override def baz(input: String): UIO[Unit] =\n    for {\n      _ <- fooSrv.foo(input)\n      _ <- barSrv.bar(input) \n    } yield ()\n}\n\n// Converting the Service Implementation into the ZLayer\nobject BazLive {\n  val layer: URLayer[Foo & Bar, Baz] =\n    ZLayer {\n      for {\n        fooSrv <- ZIO.service[Foo]\n        barSrv <- ZIO.service[Bar]\n      } yield BazLive(fooSrv, barSrv)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Services with Has in Scala ZIO\nDESCRIPTION: Example of combining two Has-wrapped services horizontally using the ++ operator. This demonstrates how to merge multiple service dependencies into a single environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval logger: Has[Logging]   = Has(new Logging{})\nval random: Has[RandomInt] = Has(new RandomInt{})\n\n// Note the use of the infix `++` operator on `Has` to combine two `Has` elements:\nval combined: Has[Logging] with Has[RandomInt] = logger ++ random\n```\n\n----------------------------------------\n\nTITLE: Defining Sealed Trait and Case Classes for Error Subtype Testing (Scala)\nDESCRIPTION: This snippet defines a sealed trait `MyError` extending `Exception` and two case classes `E1` and `E2` that extend `MyError`. These types serve as examples for demonstrating how to test if a ZIO effect fails with any subtype of `MyError`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait MyError extends Exception\ncase class E1(msg: String) extends MyError\ncase class E2(msg: String) extends MyError\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#orElseFail to Unify Error Types in Scala\nDESCRIPTION: This example demonstrates `orElseFail`. A `validate` function (defined silently) fails with specific `AgeValidationException` subtypes. The `orElseFail(\"invalid age\")` call ensures that regardless of which `AgeValidationException` occurs, the resulting effect fails with the simple string \"invalid age\", unifying the error channel to `String`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nsealed trait AgeValidationException extends Exception\ncase class NegativeAgeException(age: Int) extends AgeValidationException\ncase class IllegalAgeException(age: Int)  extends AgeValidationException\n\ndef validate(age: Int): ZIO[Any, AgeValidationException, Int] = {\n  if (age < 0)\n    ZIO.fail(NegativeAgeException(age))\n  else if (age < 18)\n    ZIO.fail(IllegalAgeException(age))\n  else ZIO.succeed(age)\n}\n\nval result: ZIO[Any, String, Int] =\n  validate(3).orElseFail(\"invalid age\")\n```\n\n----------------------------------------\n\nTITLE: Shutting Down a ZIO Queue in Scala\nDESCRIPTION: Demonstrates interrupting all pending offers/takes in a ZIO Queue using shutdown. Forked take is interrupted upon queue shutdown. All subsequent operations complete immediately. No external dependencies are required beyond zio._.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval takeFromShutdownQueue: UIO[Unit] = for {\\n  queue <- Queue.bounded[Int](3)\\n  f <- queue.take.fork\\n  _ <- queue.shutdown // will interrupt f\\n  _ <- f.join // Will terminate\\n} yield ()\\n\n```\n\n----------------------------------------\n\nTITLE: Structured Logging Example with Annotations in ZIO\nDESCRIPTION: Example showing a structured logging pattern that attaches contextual information (user names and fiber IDs) to log messages for concurrent operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  _ <- Logging.log(\"Hello World!\")\n  _ <- ZIO.foreachParDiscard(List(\"Jane\", \"John\")) { name =>\n    Logging.logAnnotate(\"name\", name) {\n      for {\n        _ <- Logging.log(s\"Received request\")\n        fiberId <- ZIO.fiberId.map(_.ids.head)\n        _ <- Logging.logAnnotate(\"fiber_id\", s\"$fiberId\")(\n          Logging.log(\"Processing request\")\n        )\n        _ <- Logging.log(\"Finished processing request\")\n      } yield ()\n    }\n  }\n  _ <- Logging.log(\"All requests processed\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Asserting Boolean is False in Scala\nDESCRIPTION: Creates an assertion `Assertion[Boolean]` that checks if a `Boolean` value is `false`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nisFalse\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compile-Time Dependency Checking in ZIO\nDESCRIPTION: This code snippet shows how ZIO's automatic layer construction provides compile-time dependency checking. It intentionally omits the Logging dependency to demonstrate the compiler error that would occur.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/building-dependency-graph.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval app: ZIO[Any, Throwable, Unit] =\n  myApp.provide(\n    DocRepo.live,\n    BlobStorage.live,\n//    Logging.live,\n    Database.live,\n    UserRepo.live\n  )\n```\n\n----------------------------------------\n\nTITLE: Asserting String Starts With Prefix in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if a `String` starts with the specified `prefix`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nstartsWithString(prefix: String)\n```\n\n----------------------------------------\n\nTITLE: Defining CounterService as Event Sourced Command Router with Edomata (Scala)\nDESCRIPTION: This Scala object defines the domain service for the Counter entity using Edomata's approach to routing commands to actions and publishing notifications. It interprets Inc and Dec commands, updates state accordingly, and, for Inc, emits a notification. Requires Edomata and PureApp infrastructure. Inputs are domain commands, outputs are state updates and notifications; error handling for rejected commands is encapsulated in the logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nobject CounterService extends Counter.Service[Command, Notification] {\n  import App._\n  def apply(): PureApp[Unit] = router {\n    case Command.Inc =>\n      for {\n        counter <- state.decide(_.inc)\n        _ <- publish(Notification(s\"state is going to become ${counter.state}\"))\n      } yield ()\n    case Command.Dec => state.decide(_.dec).void\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Timeout Errors to ZIO Streams (Scala)\nDESCRIPTION: Shows how to use ZStream#timeoutError to fail a stream with a specific error if it doesn't produce values within a certain time period. This adds time-sensitivity to stream processing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_79\n\nLANGUAGE: scala\nCODE:\n```\nstream.timeoutError(new TimeoutException)(10.seconds)\n```\n\n----------------------------------------\n\nTITLE: Lifting ZIO Queue to Cats Effect IO (Cats Effect 2.x, Scala)\nDESCRIPTION: Presents use of zio.interop.Queue to lift the ZIO Queue creation and manipulation effect into Cats Effect IO, allowing queue operations to be managed in a Cats runtime. The snippet creates a bounded queue, enqueues two values, and retrieves all items. Requires cats.effect.IO, zio.Runtime, and interop-cats queue machinery. Key parameters are queue capacity and type, outputs a list of queue elements. Workflow demonstrates safe concurrency interop.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.Queue\nimport cats.effect.IO\n\nimplicit val runtime = Runtime.default\ndef liftedToIO: IO[List[Int]] = for {\n  q <- Queue.bounded[IO, Int](100)\n  _  <- q.offer(1)\n  _  <- q.offer(2)\n  r <- q.takeAll\n} yield (r)\n```\n\n----------------------------------------\n\nTITLE: Setting Seed for Stable Random Values in Scala ZIO Tests\nDESCRIPTION: This snippet demonstrates how to use TestRandom.setSeed to generate a stable sequence of random values in ZIO tests. It sets a seed and then generates three random long values, asserting their equality to predefined values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/random.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\ntest(\"Use setSeed to generate stable values\") {\n  for {\n    _ <- TestRandom.setSeed(27)\n    r1 <- Random.nextLong\n    r2 <- Random.nextLong\n    r3 <- Random.nextLong\n  } yield\n    assertTrue(\n      List(r1, r2, r3) == List[Long](\n        -4947896108136290151L,\n        -5264020926839611059L,\n        -9135922664019402287L\n      )\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining `unrefine` Signature in ZIO Scala\nDESCRIPTION: Shows the type signature of the `unrefine` operator. It broadens the error channel by attempting to convert specific `Throwable` defects, matched by the partial function `pf`, into typed errors of type `E1` (which must be a supertype of the original error type `E`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def unrefine[E1 >: E](pf: PartialFunction[Throwable, E1]): ZIO[R, E1, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Exit Value Succeeds in Scala\nDESCRIPTION: Creates an assertion `Assertion[Exit[Any, A]]` that checks if a ZIO `Exit` value represents a successful completion. It requires the success value `A` to satisfy the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nsucceeds[A](assertion: Assertion[A])\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Config for HostPort in Scala using ZIO\nDESCRIPTION: This snippet shows how to define a custom configuration for a HostPort case class. It combines primitive string and int configs to create a composite config for the custom type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/configuration/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class HostPort(host: String, port: Int)\n\nobject HostPort {\n  implicit val config: Config[HostPort] =\n    (Config.string(\"host\") ++ Config.int(\"port\")).map { case (host, port) =>\n      HostPort(host, port)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching on Specific Test Failures\nDESCRIPTION: Demonstrates advanced usage of the failing aspect with pattern matching on specific failure types. Tests pass only when matching specified failure conditions using TestFailure and Cause pattern matching.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/passing-failed-tests.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"a test that will only pass on a specified failure\") {\n  ZIO.fail(\"Boom!\").map(_ => assertTrue(true))\n} @@ TestAspect.failing[String] {\n  case TestFailure.Assertion(_, _) => true\n  case TestFailure.Runtime(cause: Cause[String], _) => cause match {\n    case Cause.Fail(value, _)\n      if value == \"Boom!\" => true\n    case _ => false\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Tests Using ZIOSpecDefault's Main Method\nDESCRIPTION: These SBT commands demonstrate how to run ZIO tests by invoking the ZIOSpecDefault's main method directly, useful for non-SBT environments or special needs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/running-tests.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsbt Test/run                       // prompt to choose which test to run\nsbt Test/runMain HelloWorldSpec    // run a specific test\n```\n\n----------------------------------------\n\nTITLE: Refining Error Types with refineOrDie in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates using ZStream#refineOrDie to narrow the error type of a stream to a specific subset of errors. This allows handling only certain error types while terminating on others.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_78\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZStream[Any, Throwable, Int] =\n  ZStream.fail(new Throwable)\n\nval res: ZStream[Any, IllegalArgumentException, Int] =\n  stream.refineOrDie { case e: IllegalArgumentException => e }\n```\n\n----------------------------------------\n\nTITLE: Creating a ZLayer from a Function (Scala)\nDESCRIPTION: Demonstrates how to convert a case class constructor to a ZLayer using ZLayer.fromFunction. Requires pre-defined traits and implementations A, B, and C. Inputs are the dependencies, outputs the constructed type C.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait A\ntrait B\ntrait C\ncase class CLive(a: A, b: B) extends C\n\nobject CLive {\n  val layer: ZLayer[A & B, Nothing, C] = \n    ZLayer.fromFunction(CLive.apply _)\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous ZIO Layer Constructor Implementation\nDESCRIPTION: Improved implementation using ZIO Layer to handle blocking operations asynchronously. Uses ZIO.attemptBlocking to properly manage blocking operations in the constructor.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nclass ProducerInput\n\nclass KafkaProducer(input: ProducerInput) {\n    def send(message: String): Task[Unit] = ???\n}\n\nobject KafkaProducer {\n  val layer =\n    ZLayer {\n      for {\n        input <- ZIO.attemptBlocking(doSomeBlockingOperation())\n      } yield (new KafkaProducer(input))\n    }\n\n  private def doSomeBlockingOperation(): ProducerInput = ???\n}\n```\n\n----------------------------------------\n\nTITLE: ZStream Creation from Chunks in Scala\nDESCRIPTION: Shows how to create ZStreams from single and multiple Chunks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream.fromChunk(Chunk(1, 2, 3))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval s2 = ZStream.fromChunks(Chunk(1, 2, 3), Chunk(4, 5, 6))\n```\n\n----------------------------------------\n\nTITLE: Creating Failing ZIO Effects with Strings in Scala\nDESCRIPTION: Demonstrates creating failing ZIO effects using `ZIO.fail` with a String error message. `f1` is a direct failure, while `f2` shows a sequence where a successful effect (`ZIO.succeed`) is followed by a failing effect (`ZIO.fail`), resulting in an overall failing effect. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/failures.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval f1: ZIO[Any, String, Nothing] = ZIO.fail(\"Oh uh!\")\nval f2: ZIO[Any, String, Int]     = ZIO.succeed(5) *> ZIO.fail(\"Oh uh!\")\n```\n\n----------------------------------------\n\nTITLE: ZIO Error Stack Trace for Then Cause - Scala\nDESCRIPTION: This example stack trace output illustrates the result of running the previous ZIO effect. It shows that when both an ordinary failure and a defect (die) occur, the first failure appears as suppressed by the second exception. Reading stack trace details can help diagnose the sequence and suppression relationship of ZIO errors. No dependencies are required to interpret this output as long as the preceding ZIO effect is executed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntimestamp=2022-03-05T13:30:17.335173071Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.String: first\\n\\tat <empty>.MainApp.myApp(MainApp.scala:4)\\n\\tat <empty>.MainApp.myApp(MainApp.scala:5)\\n\\tSuppressed: java.lang.Exception: second\\n\\t\\tat MainApp$.$anonfun$myApp$3(MainApp.scala:5)\\n\\t\\tat zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\\n\\t\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:255)\\n\\t\\tat zio.internal.FiberContext.run(FiberContext.scala:115)\\n\\t\\tat zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\\n\\t\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:538)\\n\\t\\tat <empty>.MainApp.myApp(MainApp.scala:5)\"\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using the Inversion of Control Editor in Scala\nDESCRIPTION: Demonstrates how to use the `Editor` class after applying Inversion of Control. It shows the client code explicitly creating instances of `Formatter` and `Compiler` and then passing them into the `Editor` constructor during its instantiation. Finally, it calls the `formatAndCompile` method on the created `editor` instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nval formatter = new Formatter() // creating formatter\nval compiler  = new Compiler()  // creating compiler\nval editor = new Editor(formatter, compiler) // assembling formatter and compiler into editor\n\neditor.formatAndCompile(\"println(\\\"Hello, world!\\\")\")\n```\n```\n\n----------------------------------------\n\nTITLE: Converting Function to ZIO Effect with ZIO.fromFunction - Scala\nDESCRIPTION: Demonstrates transformation of a pure function A => B (here, Int => Int) into a ZIO effect, preserving dependency injection and environmental contexts. The resulting effect URIO[Int, Int] takes an Int environment and returns its square. No side effects are present.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval zfun: URIO[Int, Int] =\n  ZIO.fromFunction((i: Int) => i * i)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-memoization of Locally Provided ZIO Layers\nDESCRIPTION: This snippet shows that layers provided locally are not memoized by default, resulting in multiple initializations of the 'A' layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-memoization.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val myApp: ZIO[Any, Nothing, Unit] =\n    for {\n      _ <- ZIO.service[A].provide(a) // providing locally\n      _ <- ZIO.service[A].provide(a) // providing locally\n    } yield ()\n\n  def run = myApp\n}\n// The output:\n// initialized: MainApp$$anon$1@cd60bde\n// initialized: MainApp$$anon$1@a984546\n```\n\n----------------------------------------\n\nTITLE: Defining Summary Metrics Factory Methods in Scala\nDESCRIPTION: Defines the factory methods `summary` and `summaryInstant` within the `Metric` object in Scala. These methods create `Summary` instances for tracking Double values or tuples of Double and Instant, respectively, based on specified name, maxAge, maxSize, error margin, and quantiles. These methods are used to initialize summary metrics for monitoring purposes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/summary.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Metric {\n  def summary(\n    name: String,\n    maxAge: Duration,\n    maxSize: Int,\n    error: Double,\n    quantiles: Chunk[Double]\n  ): Summary[Double] = ???\n             \n  def summaryInstant(\n    name: String,\n    maxAge: Duration,\n    maxSize: Int,\n    error: Double,\n    quantiles: Chunk[Double]\n  ): Summary[(Double, java.time.Instant)] =\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Names with ZIO and Recursion in Scala\nDESCRIPTION: A purely functional implementation using ZIO to handle I/O effects, maintaining state through recursive function calls without mutable variables.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef inputNames: ZIO[Any, String, List[String]] = {\n  def loop(names: List[String]): ZIO[Any, String, List[String]] = {\n    Console.readLine(\"Please enter a name or `q` to exit: \").orDie.flatMap {\n      case \"q\" =>\n        ZIO.succeed(names)\n      case name =>\n        loop(names appended name)\n    }\n  }\n\n  loop(List.empty[String])\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Caching with ZIO Cache\nDESCRIPTION: Example showing how to use ZIO Cache for concurrent lookups and cache statistics tracking with a time-consuming effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.cache.{Cache, Lookup}\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.duration.{Duration, durationInt}\nimport zio.{ExitCode, URIO, ZIO}\n\nimport java.io.IOException\n\ndef timeConsumingEffect(key: String): ZIO[Clock, Nothing, Int] =\n  ZIO.sleep(5.seconds) *> ZIO.succeed(key.hashCode)\n\nval myApp: ZIO[Console with Clock, IOException, Unit] =\n  for {\n    cache <- Cache.make(\n      capacity = 100,\n      timeToLive = Duration.Infinity,\n      lookup = Lookup(timeConsumingEffect)\n    )\n    result <- cache.get(\"key1\")\n                .zipPar(cache.get(\"key1\"))\n                .zipPar(cache.get(\"key1\"))\n    _ <- putStrLn(s\"Result of parallel execution three effects with the same key: $result\")\n\n    hits <- cache.cacheStats.map(_.hits)\n    misses <- cache.cacheStats.map(_.misses)\n    _ <- putStrLn(s\"Number of cache hits: $hits\")\n    _ <- putStrLn(s\"Number of cache misses: $misses\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO Sandbox Operator Signature in Scala\nDESCRIPTION: Shows the type signature of the `sandbox` method within the ZIO trait. This operator transforms a ZIO effect `ZIO[R, E, A]` into `ZIO[R, Cause[E], A]`, exposing the full cause of potential failures (including defects and interruptions) in the error channel as a `Cause[E]`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/sandboxing.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def sandbox: ZIO[R, Cause[E], A]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Formatter and Compiler Services in Scala\nDESCRIPTION: Defines two basic service classes, `Formatter` and `Compiler`, using ZIO. Each class has a method (`format` and `compile` respectively) that takes a string and returns a `UIO[String]` with a dummy implementation using `ZIO.succeed`. These serve as the initial dependencies for the subsequent examples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent\nimport zio._\n\nclass Formatter {\n  def format(code: String): UIO[String] = \n    ZIO.succeed(code) // dummy implementation\n}\n\nclass Compiler {\n  def compile(code: String): UIO[String] = \n    ZIO.succeed(code) // dummy implementation\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Retrying Failed Effects with Schedule in ZIO for Scala\nDESCRIPTION: Illustrates retrying a failed effect up to a fixed number of times using a ZIO schedule. The example imports a clock module and retries file opening up to five times on error. Dependencies include zio.clock, Schedule, and IO. The input is a failure-prone effect; the output is a ZIO effect that automatically retries. Key parameter is the retry policy.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.clock._\n\nval retriedOpenFile: ZIO[Clock, IOException, Array[Byte]] = \n  openFile(\"primary.data\").retry(Schedule.recurs(5))\n```\n\n----------------------------------------\n\nTITLE: Acquiring Fresh ZIO Layers\nDESCRIPTION: Shows how to use the ZLayer#fresh operator to create separate instances of a service (InmemoryCache) for different parts of the application, avoiding potential conflicts in shared state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/examples.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Throwable, UserRepo & DocumentRepo] =\n    ((InmemoryCache.layer.fresh ++ DatabaseLive.layer) >>> UserRepoLive.layer) ++\n      ((InmemoryCache.layer.fresh ++ BlobStorageLive.layer) >>> DocumentRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n```\n\n----------------------------------------\n\nTITLE: Running a ZIO Application in Scala.js\nDESCRIPTION: This Scala code defines a main application object (`Main`) that extends `zio.App` for a Scala.js environment. It uses ZIO effects (`IO.effectTotal`, `UIO.effectTotal`, `putStrLn`) and scheduling (`Schedule.spaced`, `Clock.currentTime`) to periodically update a `<pre>` element in the browser's DOM, simulating a progress bar. It depends on the `zio` library and `scala-js-dom` for DOM manipulation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-javascript.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nimport org.scalajs.dom.{document, raw}\nimport zio._\nimport zio.duration._\nimport zio.clock._\n\nobject Main extends App {\n\n  def run(args: List[String]) = {\n    for {\n      _      <- putStrLn(\"Starting progress bar demo.\")  // Outputs on browser console log.\n      target <- IO.effectTotal(document.createElement(\"pre\"))\n      _      <- update(target).repeat(Schedule.spaced(1.seconds))\n      _      <- IO.effectTotal(node.appendChild(target)) // \"node\" is provided in this page by mdoc.\n    } yield ExitCode.success\n  }\n\n  def update(target: raw.Element) = {\n      for {\n        time   <- currentTime(TimeUnit.SECONDS)\n        output <- UIO.effectTotal(progress((time % 11).toInt, 10))\n        _      <- UIO.effectTotal(target.innerHTML = output)\n      } yield ()\n  }\n\n  def progress(tick: Int, size: Int) = {\n      val bar_length = tick\n      val empty_length = size - tick\n      val bar = \"#\" * bar_length + \" \" * empty_length\n      s\"$bar $bar_length%\"\n  }\n\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Example of ZIO and Monix Task Interoperability in Scala\nDESCRIPTION: This example demonstrates converting between ZIO IO and Monix Task in both directions, including running the tasks and printing results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-monix.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport monix.eval.Task\nimport monix.execution.Scheduler.Implicits.global\nimport zio.{ IO, Runtime }\nimport zio.interop.monix._\n\nobject UnsafeExample extends App {\n\n  val runtime = Runtime.default\n\n  def main(args: Array[String]): Unit = {\n    val io1 = IO.succeed(10)\n    val t1  = runtime.unsafeRun(io1.toTask)\n\n    t1.runToFuture.foreach(r => println(s\"IO to task result is $r\"))\n\n    val t2  = Task(10)\n    val io2 = IO.fromTask(t2).map(r => s\"Task to IO result is $r\")\n\n    println(runtime.unsafeRun(io2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Baz Service in ZIO 1.x\nDESCRIPTION: Example of implementing the Baz service that depends on Foo and Bar services using Service Pattern 1.0 in ZIO 1.x. It demonstrates the use of ZLayer and accessor methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_61\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 1.x\nobject baz {\n  // Defining the service type by wrapping the service interface with Has[_] data type\n  type Baz = Has[Baz.Service]\n\n  // Companion object that holds service interface and its live implementation\n  object Baz {\n    trait Service {\n      def baz(input: String): UIO[Unit]\n    }\n    \n    // Live implementation of the Foo service\n    val live: ZLayer[Foo with Bar, Nothing, Baz] =\n      ZLayer.fromServices[Foo.Service, Bar.Service, Baz.Service] {\n        (fooSrv: Foo.Service, barSrv: Bar.Service) =>\n          new Baz.Service {\n            override def baz(input: String): UIO[Unit] =\n              for {\n                _ <- fooSrv.foo(input)\n                _ <- barSrv.bar(input)\n              } yield ()\n          }\n      }\n  }\n\n  // Accessor Methods\n  def baz(input: String): URIO[Baz, Unit] =\n    ZIO.accessM(_.get.baz(input))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Concurrent State Management with Akka Actors\nDESCRIPTION: Demonstrates how to manage concurrent state using Akka actors, with a Counter actor that handles increment, decrement, and get operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.Actor\n\nclass Counter extends Actor {\n  private var state = 0\n\n  override def receive: Receive = {\n    case \"inc\" =>\n      state += 1\n    case \"dec\" =>\n      state -= 1\n    case \"get\" =>\n      sender() ! state\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.{ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.util.Timeout\nimport scala.concurrent.duration.DurationInt\nimport scala.concurrent.{ExecutionContext, ExecutionContextExecutor}\nimport scala.util.{Failure, Success}\n\nobject MainApp extends App {\n  val system = ActorSystem(\"counter-app\")\n  val counterActor = system.actorOf(Props[Counter], \"counter\")\n\n  implicit val ec: ExecutionContextExecutor = ExecutionContext.global\n  implicit val timeout: Timeout = Timeout(1.second)\n\n  counterActor ! \"inc\"\n  counterActor ! \"inc\"\n  counterActor ! \"inc\"\n  counterActor ! \"dec\"\n\n  (counterActor ? \"get\").onComplete {\n    case Success(v) =>\n      println(s\"The current value of counter: $v\")\n    case Failure(e) =>\n      println(s\"Failed to receive the result from the counter: ${e.getMessage}\")\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying TRef Value with Multiple Transactions\nDESCRIPTION: Demonstrates modifying a TRef value and extracting information across multiple transactions. Creates a TRef first, then applies the modify function and gets the result in a separate transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval modifyMultiple: UIO[(String, Int)] = for {\n  tRef <- TRef.makeCommit(10)\n  tuple2 <- tRef.modify(v => (\"Zee-Oh\", v + 10)).zip(tRef.get).commit\n} yield tuple2\n```\n\n----------------------------------------\n\nTITLE: ZIO Task and RIO type definitions\nDESCRIPTION: Type aliases for ZIO that fix the error type to Throwable, making them compatible with Cats Effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntype Task[+A]    = ZIO[Any, Throwable, A]\ntype RIO[-R, +A] = ZIO[  R, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Generic Operation on Object-Oriented Model in Scala\nDESCRIPTION: Shows the limitations of object-oriented modeling when performing generic operations, requiring pattern matching and type casting.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/functional-design-patterns.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef updateTimestamp[E <: Event](event: E, timestamp: Long): E =\n  event match {\n    case e: ClickEvent => e.copy(timestamp = timestamp).asInstanceOf[E]\n    case e: ViewEvent => e.copy(timestamp = timestamp).asInstanceOf[E]\n  }\n```\n\n----------------------------------------\n\nTITLE: ZIO FTP Client Example\nDESCRIPTION: Example demonstrating file operations using ZIO FTP client including listing directory contents, uploading and reading files\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.blocking.Blocking\nimport zio.console.putStrLn\nimport zio.ftp.Ftp._\nimport zio.ftp._\nimport zio.stream.{Transducer, ZStream}\nimport zio.{Chunk, ExitCode, URIO, ZIO}\n\nobject ZIOFTPExample extends zio.App {\n  private val settings =\n    UnsecureFtpSettings(\"127.0.0.1\", 21, FtpCredentials(\"one\", \"1234\"))\n\n  private val myApp = for {\n    _        <- putStrLn(\"List of files at root directory:\")\n    resource <- ls(\"/\").runCollect\n    _        <- ZIO.foreach(resource)(e => putStrLn(e.path))\n    path = \"~/file.txt\"\n    _ <- upload(\n      path,\n      ZStream.fromChunk(\n        Chunk.fromArray(\"Hello, ZIO FTP!\\nHello, World!\".getBytes)\n      )\n    )\n    file <- readFile(path)\n      .transduce(Transducer.utf8Decode)\n      .runCollect\n    _ <- putStrLn(s\"Content of $path file:\")\n    _ <- putStrLn(file.fold(\"\")(_ + _))\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = myApp\n    .provideCustomLayer(\n      unsecure(settings) ++ Blocking.live\n    )\n    .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Account Deposit Function\nDESCRIPTION: Simple implementation of account deposit operation using Ref.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef deposit(accountBalance: Ref[Int], amount: Int) = accountBalance.update(_ + amount)\n```\n\n----------------------------------------\n\nTITLE: Effectfully Transforming Values in a TMap in ZIO STM\nDESCRIPTION: Uses transformValuesSTM to apply an effectful function to every value in the TMap. This allows value transformations that might need to perform additional STM operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformValuesMTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  _    <- tMap.transformValuesSTM(v => STM.succeed(v * v))\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Creating Cartesian Products with zip in Scala\nDESCRIPTION: Shows how to use Gen#zip to create a cartesian product of elements from two generators. Also demonstrates an alternative syntax using the applicative operator <*>.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/operators.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nGen.elements(\"a\", \"b\", \"c\").zip(Gen.elements(\"1\", \"2\", \"3\"))\n  .runCollectN(5)\n(Gen.elements(\"a\", \"b\", \"c\") <*> Gen.elements(\"1\", \"2\", \"3\"))\n  .runCollectN(5)\n  \n// Sample Output: List((a,3), (a,3), (c,3), (b,3), (c,2))\n```\n\n----------------------------------------\n\nTITLE: Zipping Streams in Scala using ZIO\nDESCRIPTION: Demonstrates various ways to zip two ZStreams together, including basic zipping, zipping with default values, and zipping with the latest element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\nval s1: UStream[(Int, String)] =\n  ZStream.zipN(\n    ZStream(1, 2, 3, 4, 5, 6),\n    ZStream(\"a\", \"b\", \"c\")\n  )((a, b) => (a, b))\n\nval s2: UStream[(Int, String)] =\n  ZStream(1, 2, 3, 4, 5, 6).zipWith(ZStream(\"a\", \"b\", \"c\"))((a, b) => (a, b))\n\nval s3: UStream[(Int, String)] = \n  ZStream(1, 2, 3, 4, 5, 6).zip(ZStream(\"a\", \"b\", \"c\"))\n  \n// Output: (1, \"a\"), (2, \"b\"), (3, \"c\")\n```\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3)\n  .zipAll(ZStream(\"a\", \"b\", \"c\", \"d\", \"e\"))(0, \"x\")\nval s2 = ZStream(1, 2, 3).zipAllWith(\n  ZStream(\"a\", \"b\", \"c\", \"d\", \"e\")\n)(_ => 0, _ => \"x\")((a, b) => (a, b))\n\n// Output: (1, a), (2, b), (3, c), (0, d), (0, e)\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef zipAllWithExec[R1 <: R, E1 >: E, O2, O3](\n  that: ZStream[R1, E1, O2]\n)(exec: ExecutionStrategy)(\n  left: O => O3, right: O2 => O3\n)(both: (O, O2) => O3): ZStream[R1, E1, O3] = ???\n```\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3)\n  .schedule(Schedule.spaced(1.second))\n\nval s2 = ZStream(\"a\", \"b\", \"c\", \"d\")\n  .schedule(Schedule.spaced(500.milliseconds))\n  .chunkN(3)\n\ns1.zipWithLatest(s2)((a, b) => (a, b))\n\n// Output: (1, a), (1, b), (1, c), (1, d), (2, d), (3, d)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval stream: UStream[Int] = ZStream.fromIterable(1 to 5)\n\nval s1: UStream[(Option[Int], Int)]              = stream.zipWithPrevious\nval s2: UStream[(Int, Option[Int])]              = stream.zipWithNext\nval s3: UStream[(Option[Int], Int, Option[Int])] = stream.zipWithPreviousAndNext\n```\n\nLANGUAGE: scala\nCODE:\n```\nval indexedStream: ZStream[Any, Nothing, (String, Long)] = \n  ZStream(\"Mary\", \"James\", \"Robert\", \"Patricia\").zipWithIndex\n\n// Output: (\"Mary\", 0L), (\"James\", 1L), (\"Robert\", 2L), (\"Patricia\", 3L)\n```\n\n----------------------------------------\n\nTITLE: Defining IO Type Alias in Scala ZIO\nDESCRIPTION: Demonstrates the definition of IO type alias which represents an effect that has no requirements and may fail with type E or succeed with type A. This is a specialized version of ZIO that requires no environment type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/io.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype IO[+E, +A] = ZIO[Any, E, A]\n```\n\n----------------------------------------\n\nTITLE: Comparing ZIO 1.x and ZIO 2.x Method Names in Scala\nDESCRIPTION: A comprehensive table comparing method and constructor names between ZIO 1.x and ZIO 2.x versions. This table illustrates the naming convention changes, including the removal of underscore suffixes, renaming of effect-related methods, and changes to environment and resource management methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n| ZIO 1.x                        | ZIO 2.x                           |\n|--------------------------------|-----------------------------------|\n| `ZIO#>>=`                      | `ZIO#flatMap`                     |\n| `ZIO#bimap`                    | `ZIO#mapBoth`                     |\n| `ZIO#mapEffect`                | `ZIO#mapAttempt`                  |\n| `ZIO#filterOrElse_`            | `ZIO#filterOrElse`                |\n| `ZIO#foldCauseM`               | `ZIO#foldCauseZIO`                |\n| `ZIO#foldM`                    | `ZIO#foldZIO`                     |\n| `ZIO#foldTraceM`               | `ZIO#foldTraceZIO`                |\n|                                |                                   |\n| `ZIO#get`                      | `ZIO#some`                        |\n| `ZIO#optional`                 | `ZIO#unsome`                    |\n| `ZIO#someOrElseM`              | `ZIO#someOrElseZIO`               |\n|                                |                                   |\n| `ZIO.forkAll_`                 | `ZIO.forkAllDiscard`              |\n| `ZIO#forkInternal`             | `ZIO#fork`                        |\n| `ZIO#forkOn`                   | `ZIO#onExecutionContext(ec).fork` |\n| `ZIO.fromFiberM`               | `ZIO.fromFiberZIO`                |\n| `ZIO.require`                  | `ZIO.someOrFail`                  |\n| `ZIO#on`                       | `ZIO#onExecutionContext`          |\n| `ZIO#rejectM`                  | `ZIO#rejectZIO`                   |\n| `ZIO#run`                      | `ZIO#exit`                        |\n| `ZIO#timeoutHalt`              | `ZIO#timeoutFailCause`            |\n|                                |                                   |\n| `ZIO#to`                       | `ZIO#intoPromise`                 |\n|                                |                                   |\n| `ZIO.access`                   | `ZIO.environmentWith`             |\n| `ZIO.accessM`                  | `ZIO.environmentWithZIO`          |\n| `ZIO.fromFunction`             | `ZIO.environmentWith`             |\n| `ZIO.fromFunctionM`            | `ZIO.environmentWithZIO`          |\n| `ZIO.services`                 | `ZIO.service`                     |\n|                                |                                   |\n| `ZIO.bracket`                  | `ZIO.acquireReleaseWith`          |\n| `ZIO.bracketExit`              | `ZIO.acquireReleaseExitWith`      |\n| `ZIO.bracketAuto`              | `ZIO.acquireReleaseWithAuto`      |\n| `ZIO#bracket`                  | `ZIO#acquireReleaseWith`          |\n| `ZIO#bracket_`                 | `ZIO#acquireRelease`              |\n| `ZIO#bracketExit`              | `ZIO#acquireReleaseExitWith`      |\n| `ZIO#bracketExit`              | `ZIO#acquireReleaseExitWith`      |\n| `ZIO#bracketOnError`           | `ZIO#acquireReleaseOnErrorWith`   |\n|                                |                                   |\n| `ZIO.collectAll_`              | `ZIO.collectAllDiscard`           |\n| `ZIO.collectAllPar_`           | `ZIO.collectAllParDiscard`        |\n| `ZIO.collectAllParN_`          | `ZIO.collectAllParNDiscard`       |\n| `ZIO#collectM`                 | `ZIO#collectZIO`                  |\n|                                |                                   |\n| `ZIO.effect`                   | `ZIO.attempt`                     |\n| `ZIO.effectAsync`              | `ZIO.async`                       |\n| `ZIO.effectAsyncInterrupt`     | `ZIO.asyncInterrupt`              |\n| `ZIO.effectAsyncM`             | `ZIO.asyncZIO`                    |\n| `ZIO.effectAsyncMaybe`         | `ZIO.asyncMaybe`                  |\n| `ZIO.effectBlocking`           | `ZIO.attemptBlocking`             |\n| `ZIO.effectBlockingCancelable` | `ZIO.attemptBlockingCancelable`   |\n| `ZIO.effectBlockingIO`         | `ZIO.attemptBlockingIO`           |\n| `ZIO.effectBlockingInterrupt`  | `ZIO.attemptBlockingInterrupt`    |\n| `ZIO.effectSuspend`            | `ZIO.suspend`                     |\n| `ZIO.effectSuspendTotal`       | `ZIO.suspendSucceed`              |\n| `ZIO.effectTotal`              | `ZIO.succeed`                     |\n|                                |                                   |\n| `ZIO.foreach_`                 | `ZIO.foreachDiscard`              |\n| `ZIO.foreachPar_`              | `ZIO.foreachParDiscard`           |\n| `ZIO.foreachParN_`             | `ZIO.foreachParNDiscard`          |\n| `ZIO#replicateM`               | `ZIO#replicateZIO`                |\n| `ZIO#replicateM_`              | `ZIO#replicateZIODiscard`         |\n|                                |                                   |\n| `ZIO.halt`                     | `ZIO.failCause`                   |\n| `ZIO.haltWith`                 | `ZIO.failCauseWith`               |\n|                                |                                   |\n| `ZIO.ifM`                      | `ZIO.ifZIO`                       |\n| `ZIO.loop_`                    | `ZIO.loopDiscard`                 |\n| `ZIO.whenCaseM`                | `ZIO.whenCaseZIO`                 |\n| `ZIO.whenM`                    | `ZIO.whenZIO`                     |\n| `ZIO.unlessM`                  | `ZIO.unlessZIO`                   |\n| `ZIO#unlessM`                  | `ZIO#unlessZIO`                   |\n| `ZIO#whenM`                    | `ZIO#whenZIO`                     |\n| `ZIO#repeatUntilM`             | `ZIO#repeatUntilZIO`              |\n| `ZIO#repeatWhileM`             | `ZIO#repeatWhileZIO`              |\n| `ZIO#retryUntilM`              | `ZIO#retryUntilZIO`               |\n| `ZIO#retryWhileM`              | `ZIO#retryWhileZIO`               |\n| `ZIO.replicateM`               | `ZIO.replicateZIO`                |\n| `ZIO.replicateM_`              | `ZIO.replicateZIODiscard`         |\n|                                |                                   |\n| `ZIO.validate_`                | `ZIO.validateDiscard`             |\n| `ZIO.validatePar_`             | `ZIO.validateParDiscard`          |\n|                                |                                   |\n| `ZIO.tapCause`                 | `ZIO.tapErrorCause`               |\n```\n\n----------------------------------------\n\nTITLE: Accessing Reloadable Counter Service Example\nDESCRIPTION: Demonstrates how to access and use a Reloadable Counter service from the ZIO environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval app: ZIO[Reloadable[Counter], Nothing, Unit] =\n  for {\n    reloadable <- ZIO.service[Reloadable[Counter]]\n    counter    <- reloadable.get \n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZIO 2.x Layer Elimination for Environmental Effects in Scala\nDESCRIPTION: Example showing how layers can eliminate environmental effects in ZIO 2.x, simplifying context management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_57\n\nLANGUAGE: scala\nCODE:\n```\ntrait Foo\ntrait Bar\n\nval fooLayer   : ZLayer[Any, Nothing, Foo]          = ZLayer.succeed(???)\nval fooWithBar : ZIO[Foo with Bar, Throwable, Unit] = ZIO.succeed(???)\nval bar        : ZIO[Bar, Any, Unit]                = fooLayer(fooWithBar)\n```\n\n----------------------------------------\n\nTITLE: Modeling Dependencies with Explicit Parameters in ZIO\nDESCRIPTION: Shows the simplest way to model dependencies like UserId and CorrelationId using explicit function parameters. This approach is straightforward but can lead to boilerplate in complex applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/faq.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef someEffect(userId: UserId, correlationId: CorrelationId, ...): ZIO[Any, ErrorType, A] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: Logging with Specific Log Levels in ZIO\nDESCRIPTION: Example of logging with specific log levels using ZIO.logLevel combinator to wrap log statements with a particular severity level.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_89\n\nLANGUAGE: scala\nCODE:\n```\nZIO.logLevel(LogLevel.Warning) {\n  ZIO.log(\"The response time exceeded its threshold!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Partitioning Streams in Scala using ZIO\nDESCRIPTION: Demonstrates how to partition ZStreams using predicates and effectful functions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nval partitionResult: ZManaged[Any, Nothing, (ZStream[Any, Nothing, Int], ZStream[Any, Nothing, Int])] =\n  Stream\n    .fromIterable(0 to 100)\n    .partition(_ % 2 == 0, buffer = 50)\n```\n\nLANGUAGE: scala\nCODE:\n```\nabstract class ZStream[-R, +E, +O] {\n  final def partitionEither[R1 <: R, E1 >: E, O2, O3](\n    p: O => ZIO[R1, E1, Either[O2, O3]],\n    buffer: Int = 16\n  ): ZManaged[R1, E1, (ZStream[Any, E1, O2], ZStream[Any, E1, O3])]\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval partitioned: ZManaged[Any, Nothing, (ZStream[Any, Nothing, Int], ZStream[Any, Nothing, Int])] =\n  ZStream\n    .fromIterable(1 to 10)\n    .partitionEither(x => ZIO.succeed(if (x < 5) Left(x) else Right(x)))\n```\n\n----------------------------------------\n\nTITLE: Implementing Platform-specific Tests in ZIO\nDESCRIPTION: Shows how to create JVM-specific tests using ZIO test aspects. Demonstrates accessing JVM properties within a test that only runs on the Java Virtual Machine platform.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/environment-specific-tests.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"Java virtual machine name can be accessed\") {\n  for {\n    vm <- live(System.property(\"java.vm.name\"))\n  } yield\n    assertTrue(vm.get.contains(\"VM\"))\n} @@ TestAspect.jvmOnly\n```\n\n----------------------------------------\n\nTITLE: Feeding Predefined Random Values in Scala ZIO Tests\nDESCRIPTION: This snippet shows how to use TestRandom.feedInts to provide a predefined list of integers for random number generation in ZIO tests. It feeds a sequence of integers and then retrieves them using Random.nextInt, asserting their equality to the original sequence.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/random.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\ntest(\"One can provide its own list of ints\") {\n  for {\n    _ <- TestRandom.feedInts(1, 9, 2, 8, 3, 7, 4, 6, 5)\n    r1 <- Random.nextInt\n    r2 <- Random.nextInt\n    r3 <- Random.nextInt\n    r4 <- Random.nextInt\n    r5 <- Random.nextInt\n    r6 <- Random.nextInt\n    r7 <- Random.nextInt\n    r8 <- Random.nextInt\n    r9 <- Random.nextInt\n  } yield assertTrue(\n    List(1, 9, 2, 8, 3, 7, 4, 6, 5) == List(r1, r2, r3, r4, r5, r6, r7, r8, r9)\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Monix/Cats Effect and ZIO Data Structures in Scala\nDESCRIPTION: This code block presents a table comparing data structure names between Monix/Cats Effect and ZIO. It shows how various Monix and Cats Effect data structures can be mapped to their ZIO counterparts.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-monix.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n| Monix / Cats Effect | ZIO         |\n|---------------------|-------------|\n| `Deferred`          | `Promise`   |\n| `Fiber`             | `Fiber`     |\n| `MVar`              | `Queue`     |\n| `Ref`               | `Ref`       |\n| `Semaphore`         | `Semaphore` |\n| `TaskApp`           | `App`       |\n| `TaskLocal`         | `FiberRef`  |\n| `Task`              | `Task`      |\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Application Using Cake Service\nDESCRIPTION: This snippet demonstrates how to create a ZIO application that uses the Cake service. It shows the type signature indicating the required Cake dependency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/automatic-layer-construction.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nval myApp: ZIO[Cake, IOException, Unit] = for {\n  cake <- ZIO.service[Cake]\n  _    <- Console.printLine(s\"Yay! I baked a cake with flour and chocolate: $cake\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating ZStreams from Effectful Iterables in Scala\nDESCRIPTION: Shows how to create a ZStream from an effect producing an Iterable using ZStream.fromIterableM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ntrait Database {\n  def getUsers: Task[List[User]]\n}\n\nobject Database {\n  def getUsers: ZIO[Has[Database], Throwable, List[User]] = \n    ZIO.serviceWith[Database](_.getUsers)\n}\n\nval users: ZStream[Has[Database], Throwable, User] = \n  ZStream.fromIterableM(Database.getUsers)\n```\n\n----------------------------------------\n\nTITLE: Understanding the `assert` Function Signature in ZIO Test (Scala)\nDESCRIPTION: This snippet displays the signature of the classic `assert` function. It takes a by-name expression `expr` of type `A` and an `Assertion[A]`. It evaluates the expression, applies the assertion, and returns a `TestResult` indicating success or failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef assert[A](expr: => A)(assertion: Assertion[A]): TestResult\n```\n\n----------------------------------------\n\nTITLE: Implementing Guardian Actor for Cluster Sharding\nDESCRIPTION: Defines the Guardian actor that initializes and manages cluster sharding for Counter entities. Sets up entity type key and sharding configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.cluster.sharding.typed.ShardingEnvelope\nimport akka.cluster.sharding.typed.scaladsl._\n\nobject Guardian {\n  def apply(): Behavior[ShardingEnvelope[Counter.Message]] =\n    Behaviors.setup { context =>\n      val TypeKey: EntityTypeKey[Counter.Message] =\n        EntityTypeKey[Counter.Message](\"counter\")\n      val clusterSharding = ClusterSharding(context.system)\n      val shardRegion =\n        clusterSharding.init(Entity(TypeKey)(c => Counter(c.entityId)))\n      Behaviors.receiveMessage { msg =>\n        shardRegion ! msg\n        Behaviors.same\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing zio-interop-cats for Cats Effect 2.x\nDESCRIPTION: Dependency configuration for adding ZIO interoperability with Cats Effect 2.x to your project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-interop-cats\" % \"2.5.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Declaring Logging API in ZIO - Scala\nDESCRIPTION: Defines a basic logging function in ZIO that accepts a lazy message and an implicit Trace parameter. This snippet demonstrates how logging functions can capture implicit context without reflecting it in the environment type, simplifying usage. It produces a ZIO effect that logs a message and returns Unit, with no explicit dependencies or errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zio-environment-use-cases.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject ZIO {\n  def log(message: => String)(implicit trace: Trace): ZIO[Any, Nothing, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Reject Operators (Scala)\nDESCRIPTION: Defines the type signatures for the `reject` and `rejectZIO` methods within the ZIO trait. `reject` takes a partial function mapping a success value `A` to an error `E1`. `rejectZIO` takes a partial function mapping `A` to another ZIO effect that yields an error `E1`, allowing for effectful rejection logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/rejecting-some-success-values.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def reject[E1 >: E](pf: PartialFunction[A, E1]): ZIO[R, E1, A]\n\n  def rejectZIO[R1 <: R, E1 >: E](\n    pf: PartialFunction[A, ZIO[R1, E1, E1]]\n  ): ZIO[R1, E1, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting String Size in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if the length (size) of a `String` satisfies the provided nested assertion for `Int`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nhasSizeString(assertion: Assertion[Int])\n```\n\n----------------------------------------\n\nTITLE: Defining `refineOrDie` Signature in ZIO Scala\nDESCRIPTION: Shows the type signature of the `refineOrDie` operator. It refines the error channel `E` to `E1` using a provided partial function `pf`. Errors of type `E` that are defined for the partial function are mapped to `E1`, while others become defects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def refineOrDie[E1](pf: PartialFunction[E, E1]): ZIO[R, E1, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Cross Product of Streams in Scala using ZIO\nDESCRIPTION: Shows how to compute the Cartesian product of two ZStreams using various cross product operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nval first = ZStream(1, 2, 3)\nval second = ZStream(\"a\", \"b\")\n\nval s1 = first cross second\nval s2 = first <*> second\nval s3 = first.crossWith(second)((a, b) => (a, b))\n// Output: (1,a), (1,b), (2,a), (2,b), (3,a), (3,b)\n\nval s4 = first crossLeft second \nval s5 = first <* second\n// Keep only elements from the left stream\n// Output: 1, 1, 2, 2, 3, 3 \n\nval s6 = first crossRight second\nval s7 = first *> second\n// Keep only elements from the right stream\n// Output: a, b, a, b, a, b\n```\n\n----------------------------------------\n\nTITLE: Creating a Succeeding Channel with ZChannel.succeed in Scala\nDESCRIPTION: Creates a ZChannel that succeeds with a specified done value without producing any data. When run, it produces an empty Chunk and the done value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/creating-channels.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nval channel: ZChannel[Any, Any, Any, Any, Nothing, Nothing, Int] = \n  ZChannel.succeed(42)\n```\n\n----------------------------------------\n\nTITLE: Annotating Effects for Contextual Logging with ZIOAspect in Scala\nDESCRIPTION: This example shows using `ZIOAspect.annotated` to add contextual information (a `correlation_id`) to effects. This annotation is stored in a `FiberRef` and automatically included in log messages generated within that effect's scope and its children, enabling contextual logging across concurrent operations. The sample output demonstrates how different correlation IDs appear alongside log messages from parallel fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def handleRequest(request: String) =\n    for {\n      _ <- ZIO.log(s\"Received request.\")\n      _ <- ZIO.unit // do something with the request\n      _ <- ZIO.log(s\"Finished processing request\")\n    } yield ()\n\n  def run =\n    for {\n      _ <- ZIO.log(\"Hello World!\")\n      _ <- ZIO.foreachParDiscard(List((\"req1\", \"1\"), (\"req2\", \"2\"), (\"req3\", \"3\"))){ case (req, id) =>\n        handleRequest(req) @@ ZIOAspect.annotated(\"correlation_id\", id)\n      }\n      _ <- ZIO.log(\"Goodbye!\")\n    } yield ()\n\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Reading File Contents Using Traditional Scala Approach\nDESCRIPTION: This snippet demonstrates reading a file into a string, splitting it into lines, and printing each line. While simple, this approach may fail for very large files that exceed available memory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor (line <- FileUtils.readFileToString(new File(\"file.txt\")).split('\\n'))\n  println(line)\n```\n\n----------------------------------------\n\nTITLE: Creating Differ for RetryConfig\nDESCRIPTION: Implementation of a Differ for the RetryConfig case class using Differ#transform to convert between tuple and case class representations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval differ: Differ[RetryConfig, (Int => Int, Int => Int)] =\n  Differ\n    .update[Int]\n    .zip(Differ.update[Int])\n    .transform(\n      { case (x, y) => RetryConfig.apply(x, y) },\n      retryConfig => (retryConfig.retries, retryConfig.intervals)\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Test Spec with JUnitRunnableSpec in Scala\nDESCRIPTION: This example demonstrates how to create a ZIO Test specification that extends JUnitRunnableSpec. This allows the spec to be recognized as a JUnit test by build tools and IDEs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/junit-integration.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.junit.JUnitRunnableSpec\n\nobject MySpec extends JUnitRunnableSpec {\n  def spec = suite(\"MySpec\")(\n    test(\"test\") {\n      for {\n        _ <- ZIO.unit\n      } yield assertCompletes\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Specific Defects to Errors using `unrefine` in ZIO Scala\nDESCRIPTION: Demonstrates using `unrefine` to selectively convert specific defects (subtypes of `Throwable`) back into typed errors. It applies `unrefine` to an effect (`effect(\"foo\")`) that might die. The partial function `{ case e: Foo => e; case e: Bar => e }` ensures that if the effect dies due to a `Foo` or `Bar` exception, that defect is converted into a typed error in the broadened error channel `Throwable`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport MainApp._\n```\n\nLANGUAGE: scala\nCODE:\n```\nval unrefined: ZIO[Any, Throwable, String] =\n  effect(\"foo\").unrefine {\n    case e: Foo => e\n    case e: Bar => e\n  }\n```\n\n----------------------------------------\n\nTITLE: Asserting String Properties in Scala\nDESCRIPTION: Creates various assertions for String properties such as containing a substring, ending with a suffix, case-insensitive equality, size, emptiness, regex matching, and starting with a prefix.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_14\n\nLANGUAGE: Scala\nCODE:\n```\ncontainsString(element: String)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nendsWithString(suffix: String)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nequalsIgnoreCase(other: String)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nhasSizeString(assertion: Assertion[Int])\n```\n\nLANGUAGE: Scala\nCODE:\n```\nisEmptyString\n```\n\nLANGUAGE: Scala\nCODE:\n```\nisNonEmptyString\n```\n\nLANGUAGE: Scala\nCODE:\n```\nmatchesRegex(regex: String)\n```\n\nLANGUAGE: Scala\nCODE:\n```\nstartsWithString(prefix: String)\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Failure Effect - Scala\nDESCRIPTION: Demonstrates creating a failed ZIO effect with ZIO.fail, here with a string error message. This is used to encode a failure state in an effectful computation; the error type can be arbitrary (here, a String). The effect will fail with the given message if executed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval f1 = ZIO.fail(\"Uh oh!\")\n```\n\n----------------------------------------\n\nTITLE: Creating ZLayer from Scoped Resource in Scala\nDESCRIPTION: Shows how to convert a scoped resource into a ZLayer using the scoped constructor, managing resource lifetime through the layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef sourceLayer(name: => String): ZLayer[Any, IOException, Source] =\n  ZLayer.scoped(source(name))\n```\n\n----------------------------------------\n\nTITLE: Updating an Element in a TArray in ZIO STM (Scala)\nDESCRIPTION: Updates the element at index 2 by applying a function that adds 10 to the current value. The update method takes an index and a function that transforms the current value at that index.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tArrayUpdateElem: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.update(2, el => el + 10)\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Awaiting a TPromise Completion\nDESCRIPTION: Waits for a TPromise to complete and returns its value. This operation will block the transaction until the promise is completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpromise.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseValue: IO[String, Int] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.succeed(0).commit\n  res      <- tPromise.await.commit\n} yield res\n```\n\n----------------------------------------\n\nTITLE: Creating a Read Channel with ZChannel.read in Scala\nDESCRIPTION: Creates a ZChannel that reads an element from the input port and returns it as a done value. The type parameter specifies what type of elements the channel expects to read.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/creating-channels.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nval read: ZChannel[Any, Any, Int, Any, None.type, Nothing, Int] = \n  ZChannel.read[Int]  \n```\n\n----------------------------------------\n\nTITLE: Sequencing Schedules with andThen\nDESCRIPTION: Demonstrates sequential composition of schedules using andThen. Runs a fixed number of recurrences followed by fixed spacing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval sequential = Schedule.recurs(10) andThen Schedule.spaced(1.second)\n```\n\n----------------------------------------\n\nTITLE: Creating a Resource in Cats Effect\nDESCRIPTION: Function that creates a Cats Effect Resource from the File API, handling resource acquisition and release.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ndef fileResource[F[_]: cats.effect.Sync](name: String): cats.effect.Resource[F, File[F]] =\n  cats.effect.Resource.make(File.open[F](name))(_.close)\n```\n\n----------------------------------------\n\nTITLE: Effectful Folding of Errors and Successes with foldM in ZIO for Scala\nDESCRIPTION: This demonstrates using foldM for effectful handling of errors and successes. The handlers can themselves be ZIO effects, not just pure values. It attempts to open a primary file, using a secondary as fallback on error, or succeeds with the data. Requires ZIO and IO, accepts an error-prone effect, and returns an IO with compositional recovery logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nval primaryOrSecondaryData: IO[IOException, Array[Byte]] = \n  openFile(\"primary.data\").foldM(\n    _    => openFile(\"secondary.data\"),\n    data => ZIO.succeed(data))\n```\n\n----------------------------------------\n\nTITLE: Managing Service Implementations with ZIO ZEnvironment in Scala\nDESCRIPTION: Introduces ZIO's `ZEnvironment` as a type-level map for managing dependencies. It demonstrates creating instances of concrete service implementations (`ScalaFormatter`, `ScalaCompiler`, `EditorLive`) and storing them in a `ZEnvironment`, mapping the service traits (`Formatter`, `Compiler`, `Editor`) to their respective implementations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:silent\nval scalaFormatter = new ScalaFormatter() // Creating Formatter\nval scalaCompiler  = new ScalaCompiler() // Creating Compiler\nval myEditor       = // Assembling Formatter and Compiler into an Editor\n  new EditorLive(\n    scalaFormatter,\n    scalaCompiler\n  )\n\nval environment = ZEnvironment[Formatter, Compiler, Editor](scalaFormatter, scalaCompiler, myEditor)\n// Map(\n//  Formatter -> scalaFormatter,\n//  Compiler  -> scalaCompiler\n//  Editor    -> myEditor\n//)\n```\n```\n\n----------------------------------------\n\nTITLE: Forking a Fiber Interruption Fire-and-Forget in ZIO Scala\nDESCRIPTION: Demonstrates performing a fiber interruption on a separate fiber for fire-and-forget semantics using Fiber#interrupt.fork. This approach allows the current computation to continue immediately without waiting for the interruption to complete. Useful when clean resource release is not a concern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  fiber <- IO.succeed(\"Hi!\").forever.fork\n  _     <- fiber.interrupt.fork // I don't care!\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating ZStreams from Iterables in Scala\nDESCRIPTION: Demonstrates how to create a ZStream from an Iterable collection using ZStream.fromIterable.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval list = ZStream.fromIterable(List(1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: ZIO AWS S3 Integration Example\nDESCRIPTION: Example of using ZIO AWS S3 to create an S3 client and list buckets. The example demonstrates ZIO layers, AWS client creation, and bucket listing operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nimport software.amazon.awssdk.regions.Region\nimport software.amazon.awssdk.services.s3.S3AsyncClient\nimport zio.{ExitCode, URIO, _}\nimport zio_aws_s3.AwsApp.AwsLink\nimport zio_aws_s3.{AwsAgent, AwsApp}\n\nimport scala.jdk.CollectionConverters._\n\nobject ZIOAWSS3Example extends zio.App {\n  val BUCKET = \"<bucket name>\"\n\n  val awsEnv: ZLayer[S3AsyncClient, Throwable, AwsLink] =\n    AwsApp.ExtDeps.live >>> AwsApp.AwsLink.live\n\n  val app: ZIO[Any, Throwable, Unit] = for {\n    s3 <- AwsAgent.createClient(Region.US_WEST_2, \"<endpoint>\")\n    response <- AwsApp.listBuckets().provideLayer(awsEnv).provide(s3)\n    buckets <- Task(response.buckets.asScala.toList.map(_.name))\n    _ = buckets.foreach(println)\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    app.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Awaiting Queue Shutdown in Scala\nDESCRIPTION: Illustrates using awaitShutdown to block until queue is shut down. Launches awaitShutdown in a fiber, initiates shutdown, then synchronizes. Promises are used for context but do not alter main logic. Requires zio._.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval awaitShutdown: UIO[Unit] = for {\\n  queue <- Queue.bounded[Int](3)\\n  p <- Promise.make[Nothing, Boolean]\\n  f <- queue.awaitShutdown.fork\\n  _ <- queue.shutdown\\n  _ <- f.join\\n} yield ()\\n\n```\n\n----------------------------------------\n\nTITLE: Folding Elements of a TSet Effectfully in Scala ZIO STM\nDESCRIPTION: Folds the elements of a TSet using an effectful binary operation (addition in this case) to produce a single result value. The initial value is 0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldSTMTSet: UIO[Int] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  sum  <- tSet.foldSTM(0)((acc, el) => STM.succeed(acc + el))\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: Converting Monix Coeval to ZIO IO in Scala\nDESCRIPTION: This method converts a Monix Coeval[A] to a ZIO Task[A]. It's available as an extension method on the IO companion object.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-monix.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef fromCoeval[A](coeval: eval.Coeval[A]): Task[A]\n```\n\n----------------------------------------\n\nTITLE: Using collectWhile with String Condition in Scala\nDESCRIPTION: Demonstrates the collectWhile method which collects elements until a condition is met. This example collects elements until finding \"Bob\".\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nChunk(\"Sarah\", \"Bob\", \"Jane\").collectWhile { case element if element != \"Bob\" => true }\n// res3: Chunk[Boolean] = IndexedSeq(true)\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for OpenTracing Example\nDESCRIPTION: SBT dependency configuration including versions for HTTP4s, Jaeger, STTP, OpenTracing and other required libraries.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nobject Versions {\n  val http4s         = \"0.21.24\"\n  val jaeger         = \"1.6.0\"\n  val sttp           = \"2.2.9\"\n  val opentracing    = \"0.33.0\"\n  val opentelemetry  = \"1.4.1\"\n  val opencensus     = \"0.28.3\"\n  val zipkin         = \"2.16.3\"\n  val zio            = \"1.0.9\"\n  val zioInteropCats = \"2.5.1.0\"\n}\n\nlazy val openTracingExample = Seq(\n  \"org.typelevel\"                %% \"cats-core\"                     % \"2.6.1\",\n  \"io.circe\"                     %% \"circe-generic\"                 % \"0.14.1\",\n  \"org.http4s\"                   %% \"http4s-core\"                   % Versions.http4s,\n  \"org.http4s\"                   %% \"http4s-blaze-server\"           % Versions.http4s,\n  \"org.http4s\"                   %% \"http4s-dsl\"                    % Versions.http4s,\n  \"org.http4s\"                   %% \"http4s-circe\"                  % Versions.http4s,\n  \"io.jaegertracing\"              % \"jaeger-core\"                   % Versions.jaeger,\n  \"io.jaegertracing\"              % \"jaeger-client\"                 % Versions.jaeger,\n  \"io.jaegertracing\"              % \"jaeger-zipkin\"                 % Versions.jaeger,\n  \"com.github.pureconfig\"        %% \"pureconfig\"                    % \"0.16.0\",\n  \"com.softwaremill.sttp.client\" %% \"async-http-client-backend-zio\" % Versions.sttp,\n  \"com.softwaremill.sttp.client\" %% \"circe\"                         % Versions.sttp,\n  \"dev.zio\"                      %% \"zio-interop-cats\"              % Versions.zioInteropCats,\n  \"io.zipkin.reporter2\"           % \"zipkin-reporter\"               % Versions.zipkin,\n  \"io.zipkin.reporter2\"           % \"zipkin-sender-okhttp3\"         % Versions.zipkin\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Assertion Structure in Scala\nDESCRIPTION: Defines the basic structure of an Assertion class in Scala, showing its core methods for testing and running assertions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Assertion[-A](arrow: TestArrow[A, Boolean]) {\n  def test(value: A): Boolean = ???\n  def run(value: => A): TestResult = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Removing Elements from a TMap with a Predicate in ZIO STM\nDESCRIPTION: Uses removeIf to delete all key-value pairs that satisfy a given predicate. In this example, all entries with even values are removed from the map.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval removedEvenValues: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3), (\"d\", 4))\n  _    <- tMap.removeIf((_, v) => v % 2 == 0)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Money Transfer Between Accounts Using TRef in Scala ZIO STM\nDESCRIPTION: Implements a banking scenario where money is transferred between two accounts represented by TRefs. The transfer happens atomically and only when the sender has sufficient funds, demonstrating STM's retry mechanism.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\ndef transfer(tSender: TRef[Int],\n             tReceiver: TRef[Int],\n             amount: Int): UIO[Int] = {\n  STM.atomically {\n    for {\n      _ <- tSender.get.retryUntil(_ >= amount)\n      _ <- tSender.update(_ - amount)\n      nAmount <- tReceiver.updateAndGet(_ + amount)\n    } yield nAmount\n  }\n}\n\nval transferredMoney: UIO[String] = for {\n  tSender <- TRef.makeCommit(50)\n  tReceiver <- TRef.makeCommit(100)\n  _ <- transfer(tSender, tReceiver, 50).fork\n  _ <- tSender.get.retryUntil(_ == 0).commit\n  tuple2 <- tSender.get.zip(tReceiver.get).commit\n  (senderBalance, receiverBalance) = tuple2\n} yield s\"sender: $senderBalance & receiver: $receiverBalance\"\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Nested Streams\nDESCRIPTION: Examples of unwrapping streams nested within ZIO and ZManaged effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nval wrappedWithZIO: UIO[ZStream[Any, Nothing, Int]] = \n  ZIO.succeed(ZStream(1, 2, 3))\nval s1: ZStream[Any, Nothing, Int] = \n  ZStream.unwrap(wrappedWithZIO)\n\nval wrappedWithZManaged = ZManaged.succeed(ZStream(1, 2, 3))\nval s2: ZStream[Any, Nothing, Int] = \n  ZStream.unwrapManaged(wrappedWithZManaged)\n```\n\n----------------------------------------\n\nTITLE: Interactive, Typed Error Handling with mapAttempt and catchAll - Scala\nDESCRIPTION: Defines a recursive ZIO app that prompts for input, safely parses it as integer using mapAttempt, and on error (e.g., invalid input), retries by catching all exceptions and restarting the app. Requires zio._, Console, and knowledge of recursion in flatMap/catchAll. Demonstrates safe error transformation and handling in an interactive CLI using ZIO, and integrates error handling and branching on parsed integers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[Any, Nothing, Unit] =\n    Console.print(\"Please enter a number: \").orDie *>\n      Console.readLine.orDie\n        .mapAttempt(_.toInt)\n        .map(_ % 2 == 0)\n        .flatMap {\n          case true =>\n            Console.printLine(\"You have entered an even number.\").orDie\n          case false =>\n            Console.printLine(\"You have entered an odd number.\").orDie\n        }.catchAll(_ => myApp)\n\n  def run = myApp\n}\n\n// Please enter a number: five\n// Please enter a number: 4\n// You have entered an even number.\n\n```\n\n----------------------------------------\n\nTITLE: Restoring TestClock State in Repeated ZIO Tests\nDESCRIPTION: This example shows how to use TestAspect.restoreTestClock to reset the TestClock state after each test run, ensuring consistent behavior across repeated executions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/restoring-state-of-test-services.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\nimport java.util.concurrent.TimeUnit\n\nsuite(\"clock suite\")(\n  test(\"adjusting clock\") {\n    for {\n      clock <- ZIO.clock\n      _     <- TestClock.adjust(1.second)\n      time  <- clock.currentTime(TimeUnit.SECONDS).debug(\"current time\")\n    } yield assertTrue(time == 1)\n  } @@ TestAspect.restoreTestClock @@ repeat5\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Fixed-size Keyed Pool with Uniform Size\nDESCRIPTION: Method signature for creating a ZKeyedPool with a fixed size for all keys. The get function defines how to create a new item for a given key, and size specifies the maximum number of items per key.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zkeyedpool.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject ZKeyedPool {\n  def make[Key, Env: EnvironmentTag, Err, Item](\n       get: Key => ZIO[Env, Err, Item],\n       size: => Int\n    ): ZIO[Env with Scope, Nothing, ZKeyedPool[Err, Key, Item]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ZStream to Either with either (Scala)\nDESCRIPTION: Demonstrates how to use ZStream#either to expose the error of a ZStream as part of an Either. The example shows converting a ZStream that reads console input to a stream of Either values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval inputs: ZStream[Any, Nothing, Either[IOException, String]] = \n  ZStream.fromZIO(Console.readLine).either\n```\n\n----------------------------------------\n\nTITLE: Parallel Computation using ZIO and Scalaz Applicative\nDESCRIPTION: Shows how to perform parallel operations using ZIO's tagged Parallel instance with Scalaz's Applicative. Implements a dashboard builder that fetches user details and transaction history concurrently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-scalaz-7x.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport scalaz._, Scalaz._\nimport zio.interop.scalaz72._\n\ncase class Dashboard(details: UserDetails, history: TransactionHistory)\n\ndef getDetails(id: UserId): ZIO[Database, UserError, UserDetails] = ...\ndef getHistory(id: UserId): ZIO[Database, UserError, TransactionHistory] = ...\n\ndef buildDashboard(id: UserId): ZIO[Database, UserError, Dashboard] =\n  Tag.unwrap(^(par(getDetails(id)), par(getHistory(id)))(Dashboard.apply))\n\ndef par[R, E, A](io: ZIO[R, E, A]): scalaz72.ParIO[R, E, A] = Tag(io)\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Application with Local Environment Override in Scala\nDESCRIPTION: This snippet shows how to provide different environments for different parts of a ZIO application. It demonstrates overriding a global environment locally, which is analogous to overriding a method in object-oriented programming.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/overriding-dependency-graph.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def myApp: ZIO[A & B & C, Throwable, Unit] = {\n    def innerApp1: ZIO[A & B & C, Throwable, Unit] = ???\n    def innerApp2: ZIO[A & C,     Throwable, Unit] = ???\n\n    innerApp1.provideSomeLayer[A & B](localC) *> innerApp2\n  }\n\n  def run = myApp.provide(globalA, globalB, globalC)\n}\n```\n\n----------------------------------------\n\nTITLE: Completing Promise with fail in ZIO (Scala)\nDESCRIPTION: This snippet demonstrates how to complete a Promise with a failure in ZIO, resulting in a Boolean flag indicating if completion was successful. It uses ZIO\\'s Promise and UIO types, requires Exception handling, and demonstrates error propagation. The input is the failure Exception; output is UIO[Boolean]. The Promise state must not have already been set.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/promise.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nval ioPromise2: UIO[Promise[Exception, Nothing]] = Promise.make[Exception, Nothing]\\nval ioBooleanFailed: UIO[Boolean] = ioPromise2.flatMap(promise => promise.fail(new Exception(\"boom\")))\n```\n\n----------------------------------------\n\nTITLE: Checking TPriorityQueue Size in Scala ZIO\nDESCRIPTION: Demonstrates how to check the size of a TPriorityQueue after adding elements using the size method within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpriorityqueue.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval size: STM[Nothing, Int] =\n  for {\n    queue <- TPriorityQueue.empty[Int]\n    _     <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n    size  <- queue.size\n  } yield size\n```\n\n----------------------------------------\n\nTITLE: Testing Stream Zipping with TestClock in Scala\nDESCRIPTION: Demonstrates how to use TestClock with ZIO Streams. It tests the zipLatest operation on two streams with different schedules, using a queue to collect results and TestClock to advance time.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/clock.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.stream._\nimport zio.test.Assertion.equalTo\n\ntest(\"zipLatest\") {\n  val s1 = ZStream.iterate(0)(_ + 1).schedule(Schedule.fixed(100.milliseconds))\n  val s2 = ZStream.iterate(0)(_ + 1).schedule(Schedule.fixed(70.milliseconds))\n  val s3 = s1.zipLatest(s2)\n\n  for {\n    q      <- Queue.unbounded[(Int, Int)]\n    _      <- s3.foreach(q.offer).fork\n    fiber  <- ZIO.collectAll(ZIO.replicate(4)(q.take)).fork\n    _      <- TestClock.adjust(1.second)\n    result <- fiber.join\n  } yield assertTrue(result == List(0 -> 0, 0 -> 1, 1 -> 1, 1 -> 2))\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring build.sbt for ZIO Project in Scala\nDESCRIPTION: Scala build configuration specifying Scala version, project name, version, and ZIO dependency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/run-our-first-zio-project-with-vscode.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nscalaVersion := \"2.13.10\"\nname := \"my-zio-project\"\nversion := \"0.0.1\"\n\nlibraryDependencies ++= Seq(\n  \"zio\" %% \"zio\" % \"2.0.5\"\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Counter Actor with ZIO Actors in Scala\nDESCRIPTION: This example demonstrates how to create a simple Counter Actor using ZIO Actors. It includes actor definition, message handling, and usage within a ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.actors.Actor.Stateful\nimport zio.actors._\nimport zio.clock.Clock\nimport zio.console.putStrLn\nimport zio.{ExitCode, UIO, URIO, ZIO}\n\nsealed trait Message[+_]\ncase object Increase extends Message[Unit]\ncase object Get      extends Message[Int]\n\nobject CounterActorExample extends zio.App {\n\n  // Definition of stateful actor\n  val counterActor: Stateful[Any, Int, Message] =\n    new Stateful[Any, Int, Message] {\n      override def receive[A](\n          state: Int,\n          msg: Message[A],\n          context: Context\n      ): UIO[(Int, A)] =\n        msg match {\n          case Increase => UIO((state + 1, ()))\n          case Get      => UIO((state, state))\n        }\n    }\n\n  val myApp: ZIO[Clock, Throwable, Int] =\n    for {\n      system <- ActorSystem(\"MyActorSystem\")\n      actor  <- system.make(\"counter\", Supervisor.none, 0, counterActor)\n      _      <- actor ! Increase\n      _      <- actor ! Increase\n      s      <- actor ? Get\n    } yield s\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp\n      .flatMap(state => putStrLn(s\"The final state of counter: $state\"))\n      .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Basic CyclicBarrier State Check\nDESCRIPTION: Demonstrates checking the initial state of a newly created barrier.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/cyclicbarrier.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  barrier  <- CyclicBarrier.make(100, ZIO.debug(\"This is a release action!\"))\n  isBroken <- barrier.isBroken  \n  waiting  <- barrier.waiting\n} yield assert(!isBroken && waiting == 0)\n```\n\n----------------------------------------\n\nTITLE: Migrating Config Service Usage to ZIO 2.x\nDESCRIPTION: Update the way services are accessed and provided to the application environment in ZIO 2.x, removing Has wrappers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 2.x\nimport zio._\n\ncase class Config(url: String, port: Int)\n\nobject ConfigExample extends ZIOAppDefault {\n  val app: ZIO[Config, Nothing, Unit] = for {\n    config <- ZIO.service[Config]\n    _      <- Console.printLine(s\"application config: $config\").orDie\n  } yield ()\n    \n  def run = \n    app.provideEnvironment(ZEnvironment(Config(\"localhost\", 8080)))\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Nested Assertion on Either and Option Types in Scala\nDESCRIPTION: Shows how to create and use a complex nested assertion to test an Either[Int, Option[Int]] value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.Assertion.{isRight, isSome, equalTo, hasField}\n\ntest(\"either value is right(Some(5))\") {\n  assert(Right(Some(1 + 4)))(isRight(isSome(equalTo(5))))\n}\n```\n\n----------------------------------------\n\nTITLE: Property-Based Testing with `check` and `assert` in ZIO Test (Scala)\nDESCRIPTION: This snippet showcases property-based testing using ZIO Test's `check` function. It generates pairs of strings using `Gen.string` and asserts that for any generated strings `a` and `b`, the length of their concatenation `(a + b).length` is equal to the sum of their individual lengths `a.length + b.length`. The `assert` function with `Assertion.equalTo` is used for the check.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ntest(\"The sum of the lengths of both inputs must equal the length of the output\") {\n  check(Gen.string, Gen.string) { (a, b) =>\n    assert((a + b).length)(Assertion.equalTo(a.length + b.length))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Test Clock in ZIO Test Environment (Scala)\nDESCRIPTION: Demonstrates how Clock.currentTime returns 0L in the test environment, showing that the test version of Clock is used by default.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/live.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\nimport java.util.concurrent.TimeUnit\n\ntest(\"running clock methods in a test environment\") {\n  assertZIO(Clock.currentTime(TimeUnit.MILLISECONDS))(equalTo(0L)) \n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Committing a TRef in Scala ZIO STM\nDESCRIPTION: Creates a TRef with an initial value and immediately commits the transaction, returning a reference that can be stored and passed around in your application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval commitTRef: UIO[TRef[Int]] = TRef.makeCommit(10)\n```\n\n----------------------------------------\n\nTITLE: Accessing Live Clock in ZIO Test Environment (Scala)\nDESCRIPTION: Shows how to use Live.live to access the real Clock service within a test, ensuring the returned time is not 0L.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/live.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\nimport java.util.concurrent.TimeUnit\n\ntest(\"live can access real environment\") {\n  for {\n    live <- Live.live(Clock.currentTime(TimeUnit.MILLISECONDS))\n  } yield assertTrue(live != 0L)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Value Replicator Channel in Scala ZIO\nDESCRIPTION: Implements a channel that duplicates each input value in the output stream, demonstrating how to use ZChannel.readWith with writeAll to transform data.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nobject MainApp extends ZIOAppDefault {\n  lazy val doubler: ZChannel[Any, Any, Int, Any, Nothing, Int, Unit] =\n    ZChannel.readWith(\n      (i: Int) => ZChannel.writeAll(i, i) *> doubler,\n      (_: Any) => ZChannel.unit,\n      (_: Any) => ZChannel.unit\n    )\n  def run = (ZChannel.writeAll(1,2,3,4,5) >>> doubler).runCollect.debug\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Acquire-Release Stream Constructor in Scala\nDESCRIPTION: This snippet shows the signature of the 'acquireReleaseWith' method in ZStream for creating resourceful streams. It takes an acquire action and a release function to manage resources safely.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/resourceful-streams.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject ZStream {\n  def acquireReleaseWith[R, E, A](\n    acquire: ZIO[R, E, A]\n  )(\n    release: A => URIO[R, Any]\n  ): ZStream[R, E, A] = ???\n```\n\n----------------------------------------\n\nTITLE: Example Stack Trace for a Failing ZIO Application\nDESCRIPTION: Illustrates the typical console output when a ZIO application terminates due to an unhandled failure created with `ZIO.fail`. It shows the timestamp, error level, fiber ID, the error message (\"Oh uh!\"), and the location in the code where the failure occurred.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/failures.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntimestamp=2022-03-08T17:55:50.002161369Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.String: Oh uh!\n\tat <empty>.MainApp.run(MainApp.scala:4)\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Case Class Service Implementations in Scala ZIO\nDESCRIPTION: Implementation of service implementations as case classes. This is a common pattern for creating injectable services in ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ncase class LoggingLive() extends Logging {\n  override def log(line: String): UIO[Unit] =\n    ZIO.effectTotal(println(line))\n}\n\ncase class RandomIntLive() extends RandomInt {\n  override def random: UIO[Int] =\n    ZIO.effectTotal(scala.util.Random.nextInt())\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating FiberRef Copy-on-Fork Semantics in ZIO Scala\nDESCRIPTION: This code demonstrates the copy-on-fork behavior of `FiberRef`. A parent fiber creates a `FiberRef` with an initial value (5). It then forks a child fiber which updates the `FiberRef`'s value to 6. The parent waits for the child to complete and then retrieves its own value and the value set by the child (via a `Promise`). The assertion confirms that the parent's value remains unchanged (5), while the child's modification (6) was local to the child fiber.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  promise <- Promise.make[Nothing, Int]\n  _ <- fiberRef\n    .updateAndGet(_ => 6)\n    .flatMap(promise.succeed).fork\n  childValue <- promise.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5 && childValue == 6)\n```\n```\n\n----------------------------------------\n\nTITLE: Checking TPriorityQueue Size in Scala ZIO\nDESCRIPTION: Shows how to check the size of a TPriorityQueue after adding elements using the size method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpriorityqueue.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval size: STM[Nothing, Int] =\n  for {\n    queue <- TPriorityQueue.empty[Int]\n    _     <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n    size  <- queue.size\n  } yield size\n```\n\n----------------------------------------\n\nTITLE: Custom Merge Strategy for FiberRef\nDESCRIPTION: Demonstrates how to create a FiberRef with a custom merge strategy using math.max as the join function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make(initial = 0, join = math.max)\n  child    <- fiberRef.update(_ + 1).fork\n  _        <- fiberRef.update(_ + 2)\n  _        <- child.join\n  value    <- fiberRef.get\n} yield assert(value == 2)\n```\n\n----------------------------------------\n\nTITLE: Simplified `test` Function Signatures in ZIO Test (Scala)\nDESCRIPTION: These conceptual signatures illustrate how the `test` function works for common cases. It takes a label and an assertion that results in either a `TestResult` (for pure values) or a `ZIO[R, E, TestResult]` (for effects), and produces a `Spec[R, E]` which represents the test specification.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef test(label: String)(assertion: => TestResult): Spec[Any, Nothing]\ndef test(label: String)(assertion: => ZIO[R, E, TestResult]): Spec[R, E]\n```\n\n----------------------------------------\n\nTITLE: Composing Fibers with Zip in ZIO Scala\nDESCRIPTION: Uses Fiber#zip to combine two fibers into one whose result is a tuple of both results. If either fiber fails, the composed fiber fails too. Shows forking two successful computations, zipping fibers, and joining to collect both results. Requires ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  fiber1 <- IO.succeed(\"Hi!\").fork\n  fiber2 <- IO.succeed(\"Bye!\").fork\n  fiber   = fiber1.zip(fiber2)\n  tuple  <- fiber.join\n} yield tuple\n```\n\n----------------------------------------\n\nTITLE: Creating a TRef Inside a Transaction in Scala ZIO STM\nDESCRIPTION: Creates a TRef with an initial value of 10 inside an STM transaction. This reference will be used for atomic operations within the STM system.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval createTRef: STM[Nothing, TRef[Int]] = TRef.make(10)\n```\n\n----------------------------------------\n\nTITLE: Automatic Codec Derivation Example\nDESCRIPTION: Demonstration of using macros to automatically derive JSON codecs for case classes\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.json._\n\ntest(\"automatic derivation for case classes\") {\n  case class Person(name: String, age: Int)\n  object Person {\n    implicit val decoder: JsonDecoder[Person] = DeriveJsonDecoder.gen[Person]\n    implicit val encoder: JsonEncoder[Person] = DeriveJsonEncoder.gen[Person]\n  }\n\n  assertTrue((Person(\"John\", 42).toJson == \"{\\\"name\\\":\\\"John\\\",\\\"age\\\":42}\")\n    && (\"{\\\"name\\\":\\\"John\\\",\\\"age\\\":42}\".fromJson[Person] == Right(Person(\"John\", 42)))\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Shared Layer Implementation in ZIO 2.x\nDESCRIPTION: Example demonstrating how separate layer instances are created when using function calls\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_75\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nclass SharedService()\n\nobject LayerBuilder {\n  def createLayer() = ZLayer.succeed(new SharedService())\n}\n\nobject NotUsingSharedLayerA extends ZIOSpec[SharedService]{\n  override def spec =\n    test(\"use the shared layer in test A\") {\n      assertCompletes\n    }\n\n  override def bootstrap = LayerBuilder.createLayer()\n}\n\nobject NotUsingSharedLayerB extends ZIOSpec[SharedService]{\n  override def spec =\n    test(\"use the shared layer in test B\") {\n      assertCompletes\n    }\n\n  override def bootstrap = LayerBuilder.createLayer()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Counter Service in Scala for ZIO\nDESCRIPTION: This snippet defines a Counter service with increment and get operations, along with a ZLayer for initialization and cleanup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/sharing-layers-between-multiple-files.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Counter(value: Ref[Int]) {\n  def inc: UIO[Unit] = value.update(_ + 1)\n  def get: UIO[Int] = value.get\n}\n\nobject Counter {\n  val layer =\n    ZLayer.scoped(\n      ZIO.acquireRelease(\n        Ref.make(0).map(Counter(_)) <* ZIO.debug(\"Counter initialized!\")\n      )(c => c.get.debug(\"Number of tests executed\"))\n    )\n  def inc = ZIO.service[Counter].flatMap(_.inc)\n}\n```\n\n----------------------------------------\n\nTITLE: Failing a TPromise\nDESCRIPTION: Completes a TPromise with a failure. This example creates a TPromise and then fails it with an error message.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpromise.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseFail: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.fail(\"failed\").commit\n} yield tPromise\n```\n\n----------------------------------------\n\nTITLE: Utilizing Transactional Data Structures in Scala\nDESCRIPTION: List of transactional data structures available in ZIO STM, including TArray, TSet, TMap, TRef, TPriorityQueue, TPromise, TQueue, TReentrantLock, and TSemaphore.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nTArray[A]\nTSet\nTMap[A]\nTRef\nTPriorityQueue[A]\nTPromise\nTQueue\nTReentrantLock\nTSemaphore\n```\n\n----------------------------------------\n\nTITLE: Initializing an Int Generator in Scala using ZIO Test\nDESCRIPTION: Creates a generator for Int values using the Gen.int built-in generator from ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nval intGen: Gen[Any, Int] = Gen.int\n```\n\n----------------------------------------\n\nTITLE: Asserting Option is None in Scala\nDESCRIPTION: Creates an assertion `Assertion[Option[Any]]` that checks if an `Option` value is `None`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nisNone\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Differ Trait\nDESCRIPTION: Core trait definition for ZIO's Differ type that enables diffing, combining, and patching values. The trait provides four key operations: combine, diff, empty, and patch.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\ntrait Differ[Value, Patch] {\n  def combine(first: Patch, second: Patch): Patch\n  def diff(oldValue: Value, newValue: Value): Patch\n  def empty: Patch\n  def patch(patch: Patch)(oldValue: Value): Value\n}\n```\n\n----------------------------------------\n\nTITLE: File Resource Management Example\nDESCRIPTION: Shows how to create a scoped file resource using acquireRelease pattern with proper error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef acquire(name: => String): ZIO[Any, IOException, Source] =\n  ZIO.attemptBlockingIO(Source.fromFile(name))\n\ndef release(source: => Source): ZIO[Any, Nothing, Unit] =\n  ZIO.succeedBlocking(source.close())\n\ndef source(name: => String): ZIO[Scope, IOException, Source] =\n  ZIO.acquireRelease(acquire(name))(release(_))\n```\n\n----------------------------------------\n\nTITLE: Recursive State Transformation for List Length Calculation in Scala\nDESCRIPTION: A recursive function that transforms the state by processing list elements one at a time until the list is empty.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class State[T](count: Int, remainder: List[T])\n\ndef loop[T](state: State[T]): State[T] = {\n  state.remainder match {\n    case Nil => state\n    case _ :: tail => loop(State(state.count + 1, tail))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Effectful Constructor with Counter Example\nDESCRIPTION: Demonstration of an effectful constructor using ZIO for a Counter class, which can't be easily modeled with ordinary Scala constructors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Counter(ref: Ref[Int]) {\n  def inc: UIO[Unit] = ref.update(_ + 1)\n  def dec: UIO[Unit] = ref.update(_ - 1)\n  def get: UIO[Int]  = ref.get\n}\n\nobject Counter {\n  // Effectful constructor\n  def make: UIO[Counter] = Ref.make(0).map(new Counter(_))\n}\n\nclass Editor(formatter: Formatter, compiler: Compiler, counter: Counter) {\n  // ...\n}\n\nobject Formatter {\n  def make = new Formatter() \n}\n\nobject Compiler {\n  def make = new Compiler()\n}\n\nval editor    =   \n  new Editor(\n    Formatter.make,\n    Compiler.make,\n    Counter.make // Compiler Error: Type mismatch: expected: Counter, found: UIO[Counter]\n  )\n```\n\n----------------------------------------\n\nTITLE: Pangram Examples in Greek (el)\nDESCRIPTION: Provides example pangrams for the Greek language. Includes English translations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n         '    \n    ( = No more shall I see acacias or myrtles in the golden clearing )\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n       \n    ( = I uncover the soul-destroying abhorrence )\n```\n\n----------------------------------------\n\nTITLE: Creating Ref Instances in Scala\nDESCRIPTION: Demonstrates how to create Ref instances with different types of immutable data using the make method. It shows examples with integer, string, and custom state types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval counterRef = Ref.make(0)\nval stringRef = Ref.make(\"initial\") \n\nsealed trait State\ncase object Active  extends State\ncase object Changed extends State\ncase object Closed  extends State\n\nval stateRef = Ref.make(Active)\n```\n\n----------------------------------------\n\nTITLE: Unsafe Concurrent Counter Example - Scala\nDESCRIPTION: Example showing unsafe concurrent state management that should be avoided\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nobject UnsafeCountRequests extends zio.App {\n  import zio.console._\n\n  def request(counter: Ref[Int]) = for {\n    current <- counter.get\n    _ <- counter.set(current + 1)\n  } yield ()\n\n  private val initial = 0\n  private val program =\n    for {\n      ref <- Ref.make(initial)\n      _ <- request(ref) zipPar request(ref)\n      rn <- ref.get\n      _ <- putStrLn(s\"total requests performed: $rn\")\n    } yield ()\n\n  override def run(args: List[String]) = program.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO for Schedule Usage in Scala\nDESCRIPTION: Basic import statement for ZIO, which is required to use the Schedule functionality. This is a prerequisite for working with ZIO's scheduling features.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n```\n\n----------------------------------------\n\nTITLE: Auto-Blocking Example in ZIO 2.x\nDESCRIPTION: Shows ZIO 2.x's automatic detection and handling of blocking operations to prevent thread pool starvation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_47\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport scala.annotation.tailrec\n\nobject MainApp extends ZIOAppDefault {\n\n  def fib(n: Int): BigInt = {\n    @tailrec\n    def go(n: BigInt, a: BigInt, b: BigInt): BigInt = {\n      if (n == 0) a\n      else go(n - 1, b, a + b)\n    }\n    go(n, 0, 1)\n  }\n\n  def ioBoundWorkflow =\n    ZIO.debug(\"Starting I/O bound workflow\") *>\n      ZIO.foreachParDiscard(1 to 100)(_ =>\n        ZIO.attempt(Thread.sleep(Long.MaxValue))\n      ) *>\n      ZIO.debug(\"Finished I/O bound workflow\")\n\n  def cpuBoundWorkflow =\n    ZIO.debug(\"Starting CPU bound workflow\") *>\n      ZIO.foreachParDiscard(1 to 100)(i => ZIO.attempt(fib(i))) *>\n      ZIO.debug(\"Finished CPU bound workflow\")\n\n  def run = ioBoundWorkflow <&> cpuBoundWorkflow.delay(1.second)\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Value from a TMap by Key in ZIO STM\nDESCRIPTION: Demonstrates getting a value associated with a key from a TMap using the get method. The operation returns an Option that contains the value if the key exists.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval elemGet: UIO[Option[Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  elem <- tMap.get(\"c\")\n} yield elem).commit\n```\n\n----------------------------------------\n\nTITLE: Creating TReentrantLock in Scala\nDESCRIPTION: Demonstrates how to create a new TReentrantLock instance using the make constructor.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/treentrantlock.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stm._\n\nval reentrantLock = TReentrantLock.make\n```\n\n----------------------------------------\n\nTITLE: Merging ZIO Streams Randomly\nDESCRIPTION: This example demonstrates the merge operation which picks elements randomly from two input streams to create a new stream. The operation is non-deterministic and chunks the results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_43\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3).chunkN(1)\nval s2 = ZStream(4, 5, 6).chunkN(1)\n\nval merged = s1 merge s2\n// As the merge operation is not deterministic, it may output the following stream of numbers:\n// Output: 4, 1, 2, 5, 6, 3\n```\n\n----------------------------------------\n\nTITLE: Modeling State with Case Class in Scala\nDESCRIPTION: A case class to encapsulate both the count state and the remainder of the list to be processed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class State[T](count: Int, remainder: List[T])\n```\n\n----------------------------------------\n\nTITLE: Correct Ref Creation Example - Scala\nDESCRIPTION: The correct way to create a Ref using immutable data\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval init = 0\n// init: Int = 0\nval counterRef = Ref.make(init)\n// counterRef: UIO[Ref[Int]] = zio.ZIO$EffectTotal@4dd4c416\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO IO to Monix Coeval in Scala\nDESCRIPTION: This method converts a ZIO IO[A] to a Monix Coeval[A] wrapped in a UIO. It's available as an extension method on IO values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-monix.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef toCoeval: UIO[eval.Coeval[A]]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Correlation ID Logging Aspect in Scala for ZIO\nDESCRIPTION: Defines a custom ZIO Aspect called LogAspect.logAnnotateCorrelationId that extracts a correlation ID from an HTTP request header and annotates logs with it.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http.Request\n\nobject LogAspect {\n  def logAnnotateCorrelationId(\n      req: Request\n  ): ZIOAspect[Nothing, Any, Nothing, Any, Nothing, Any] =\n    new ZIOAspect[Nothing, Any, Nothing, Any, Nothing, Any] {\n      override def apply[R, E, A](\n          zio: ZIO[R, E, A]\n      )(implicit trace: Trace): ZIO[R, E, A] =\n        correlationId(req).flatMap(id => ZIO.logAnnotate(\"correlation-id\", id)(zio))\n\n      def correlationId(req: Request): UIO[String] =\n        ZIO\n          .succeed(req.headers.get(\"X-Correlation-ID\"))\n          .flatMap(id => Random.nextUUID.map(uuid => id.getOrElse(uuid.toString)))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sample Size in ZIO Test Property Checking\nDESCRIPTION: Shows how to configure the number of samples used in property checking tests using the samples test aspect. This example sets the sample size to 10.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/getting-started.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nobject AdditionSpec extends ZIOSpecDefault {\n  def spec =\n    test(\"add is commutative\") {\n      check(Gen.int, Gen.int) { (a, b) =>\n        assertTrue(add(a, b) == add(b, a))\n      }\n    } @@ TestAspect.samples(10)\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Combined Has-Wrapped Services to an Application in Scala ZIO\nDESCRIPTION: Demonstrates providing combined Has-wrapped services to a ZIO application and running it. This shows how to inject dependencies using the Has pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval effect: IO[Nothing, Unit] = myApp.provide(combined)\nzio.Runtime.default.unsafeRun(effect)\n```\n\n----------------------------------------\n\nTITLE: Awaiting ZIO Fiber Completion with await\nDESCRIPTION: This example demonstrates how to use the await operation to inspect whether a fiber succeeded or failed. Unlike join, await always succeeds with Exit information, even if the fiber fails or is interrupted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.Console._\n\nfor {\n  b <- Random.nextBoolean\n  fiber <- (if (b) ZIO.succeed(10) else ZIO.fail(\"The boolean was not true\")).fork\n  exitValue <- fiber.await\n  _ <- exitValue match {\n    case Exit.Success(value) => printLine(s\"Fiber succeeded with $value\")\n    case Exit.Failure(cause) => printLine(s\"Fiber failed\")\n  }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Lifecycle Hooks in ZLayer Derivation\nDESCRIPTION: Demonstrates the use of ZLayer.Derive.AcquireRelease trait for defining distinct initialization and finalization hooks in ZLayer.derive.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/automatic-zlayer-derivation.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport java.io.File\n\ndef acquireLockFile(path: String): ZIO[Any, Throwable, File] = ???\ndef deleteFile(file: File): ZIO[Any, Throwable, Unit] = ???\n\nclass ASingletonService(lockFilePath: String) extends ZLayer.Derive.AcquireRelease[Any, Throwable, File] {\n\n  override def acquire: ZIO[Any, Throwable, File] =\n     acquireLockFile(lockFilePath)\n\n  override def release(lockFile: File): ZIO[Any, Nothing, Any] =\n     deleteFile(lockFile).ignore\n}\n\nobject ASingletonService {\n  // Note: it's for illustrative example. In a real-world application, you will probably want to\n  //       put the `String` in a config.\n  val layer: ZLayer[String, Throwable, ASingletonService] = ZLayer.derive[ASingletonService]\n}\n```\n\n----------------------------------------\n\nTITLE: Helper Functions for Building Console Effects in Scala\nDESCRIPTION: Defines utility functionssucceed, printLine, and readLinefor easily building Console values without direct constructor usage. succeed wraps a computation in Return; printLine creates a PrintLine followed by succeed(()); readLine creates a ReadLine node whose continuation provides the entered string to succeed. These helpers simplify construction and composability of functional console programs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/background.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef succeed[A](a: => A): Console[A] = Return(() => a)\ndef printLine(line: String): Console[Unit] =\n  PrintLine(line, succeed(()))\nval readLine: Console[String] =\n  ReadLine(line => succeed(line))\n```\n\n----------------------------------------\n\nTITLE: Providing TestEnvironment to ZIO Test Program in Scala\nDESCRIPTION: This snippet demonstrates how to provide the TestEnvironment to a ZIO Test program, enabling testable environmental effects like console output and random number generation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nmyProgram.provide(testEnvironment)\n```\n\n----------------------------------------\n\nTITLE: Defining Unsafe API in ZIO 2.x Interfaces\nDESCRIPTION: Define unsafe operations in a separate UnsafeAPI trait within interfaces to clearly indicate unsafe operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait MyInterface {\n  def unsafe: UnsafeAPI\n\n  trait UnsafeAPI {\n    def doSomething()(implicit unsafe: Unsafe): Unit\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Completing ZIO Promises with Success in Scala\nDESCRIPTION: Shows how to create a ZIO Promise and complete it successfully, returning a boolean indicating whether the Promise was set.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/promise.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval ioPromise1: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\nval ioBooleanSucceeded: UIO[Boolean] = ioPromise1.flatMap(promise => promise.succeed(\"I'm done\"))\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Typeclass Instances with Scalaz 7.x Traverse in Scala\nDESCRIPTION: This snippet demonstrates utilizing the ZIO instances for Scalaz 7.2 typeclasses provided by the `zio-interop-scalaz7x` module. It defines a `findUser` function returning a `ZIO` effect and then uses Scalaz's `traverse` function on an `IList[UserId]` to apply `findUser` to each ID. The resulting effects are sequenced due to the default Monad-derived Applicative instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-scalaz-7x.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nimport scalaz._, Scalaz._\nimport zio.interop.scalaz72._\n\ntype Database = IList[User]\n\ndef findUser(id: UserId): ZIO[Database, UserError, User] = ...\ndef findUsers(ids: IList[UserId]): ZIO[Database, UserError, IList[User]] = ids.traverse(findUser(_))\n```\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages with Hub in ZIO\nDESCRIPTION: Example showing how to use Hub for broadcasting messages to multiple subscribers. The code creates a bounded Hub with two subscribers and publishes a message that both receive.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_85\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  hub <- Hub.bounded[String](requestedCapacity = 2)\n  s1 = hub.subscribe\n  s2 = hub.subscribe\n  _ <- ZIO.scoped {\n    s1.zip(s2).flatMap { case (left, right) =>\n      for {\n        _ <- hub.publish(\"Hello from a hub!\")\n        _ <- left.take.flatMap(Console.printLine(_))\n        _ <- right.take.flatMap(Console.printLine(_))\n      } yield ()\n    }\n  }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Collecting User Input with ZIO.iterate in Scala\nDESCRIPTION: Rewrites the `getNames` function using `ZIO.iterate` instead of manual recursion for collecting user input. The state is managed as a tuple `(List[String], Boolean)`, where the list accumulates names and the boolean flag controls continuation (true to continue, false on 'exit'). The iteration uses `Console.print` and `Console.readLine` within the body function to interact with the user and update the state tuple. The final result is extracted using `.map(_._1)`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\nimport zio._\n\ndef getNames: ZIO[Any, IOException, List[String]] =\n  Console.print(\"Please enter all names\") *>\n    Console.printLine(\" (enter \\\"exit\\\" to indicate end of the list):\") *>\n    ZIO.iterate((List.empty[String], true))(_._2) { case (names, _) =>\n      Console.print(s\"${names.length + 1}. \") *>\n        Console.readLine.map {\n          case \"exit\" => (names, false)\n          case name   => (names.appended(name), true)\n        }\n    }\n    .map(_._1)\n    .debug\n// Please enter all names (enter \"exit\" to indicate end of the list):\n// 1. John\n// 2. Jane\n// 3. Joe\n// 4. exit\n// List(John, Jane, Joe)\n```\n\n----------------------------------------\n\nTITLE: Setting Random Seed in ZIO\nDESCRIPTION: Shows how to set a specific seed for the random number generator, which is useful for testing scenarios where reproducible random sequences are needed. The example demonstrates setting seed to 0 and validating specific random values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/random.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  _ <- setSeed(0)\n  nextInts <- (nextInt zip nextInt)\n} yield assert(nextInts == (-1155484576,-723955400))\n```\n\n----------------------------------------\n\nTITLE: Creating ZStreams from Iterators in Scala\nDESCRIPTION: Demonstrates how to create ZStreams from different types of iterators using ZStream.fromIteratorTotal and related methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval s1: ZStream[Any, Throwable, Int] = ZStream.fromIterator(Iterator(1, 2, 3))\nval s2: ZStream[Any, Throwable, Int] = ZStream.fromIterator(Iterator.range(1, 4))\nval s3: ZStream[Any, Throwable, Int] = ZStream.fromIterator(Iterator.continually(0))\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Promise to ZIO Task using ZIO.fromPromiseScala in Scala\nDESCRIPTION: Illustrates converting a `scala.concurrent.Promise[A]` into a `Task[A]` using `ZIO.fromPromiseScala`. The example demonstrates creating a `Promise`, asynchronously attempting to complete it (success or failure) within a forked ZIO effect (`ZIO.attempt{...}.fork`), and then using `ZIO.fromPromiseScala` to create an effect that will complete when the underlying `Promise` is completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport scala.util._\n\nval func: String => String = s => s.toUpperCase\nfor {\n  promise <- ZIO.succeed(scala.concurrent.Promise[String]())\n  _ <- ZIO.attempt {\n    Try(func(\"hello world from future\")) match {\n      case Success(value) => promise.success(value)\n      case Failure(exception) => promise.failure(exception)\n    }\n  }.fork\n  value <- ZIO.fromPromiseScala(promise)\n  _ <- Console.printLine(s\"Hello World in UpperCase: $value\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Installing Tofu ZIO 2 Logging Dependencies\nDESCRIPTION: SBT dependency configurations required for setting up Tofu ZIO 2 logging with optional derivation and layout support.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tofu-zio2-logging.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"tf.tofu\" %% \"tofu-zio2-logging\" % \"version\"\n```\n\n----------------------------------------\n\nTITLE: Creating Service Accessors Using Has in Scala ZIO\nDESCRIPTION: Implementation of accessor methods using ZIO.serviceWith that return effects requiring services wrapped in the Has data type. This is the modern approach with Has.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nobject Logging {\n  def log(line: String): ZIO[Has[Logging], Nothing, Unit] =\n    ZIO.serviceWith[Logging](_.log(line))\n}\n\nobject RandomInt {\n  val random: ZIO[Has[RandomInt], Nothing, Int] =\n    ZIO.serviceWith[RandomInt](_.random)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ZLayer from an Existing Service (Scala)\nDESCRIPTION: Shows how to build a ZLayer from an existing service interface using ZLayer.succeed. Assumes service trait is present. No dependencies on environment, type output is a layer of the service; methods are placeholder (implementation left undefined with ???).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait EmailService {\n  def send(email: String, content: String): UIO[Unit]\n}\n\nobject EmailService {\n  val layer: ZLayer[Any, Nothing, EmailService] = \n    ZLayer.succeed( \n      new EmailService {\n        override def send(email: String, content: String): UIO[Unit] = ???\n      }\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Set Operation Example - Scala\nDESCRIPTION: Example demonstrating how to atomically set new values in a Ref\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  ref   <- Ref.make(\"initial\")\n  _     <- ref.set(\"update\")\n  value <- ref.get\n} yield assert(value == \"update\")\n```\n\n----------------------------------------\n\nTITLE: Adding a Single Element to a TQueue in ZIO STM\nDESCRIPTION: Demonstrates adding a single element to a bounded TQueue using the offer method within an STM transaction. The transaction is committed to execute the operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueOffer: UIO[TQueue[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offer(1)\n} yield tQueue).commit\n```\n\n----------------------------------------\n\nTITLE: Signature Comparison - Division Functions with ZIO.fail vs. ZIO.die - Scala\nDESCRIPTION: Provides function signatures for two division implementations, one using ZIO.fail (typed error channel), and the other using ZIO.die (no error channel, only defects possible). Highlights API documentation and conceptual difference between error modeling strategies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\ndef divide(a: Int, b: Int): ZIO[Any, ArithmeticException, Int]   // using ZIO.fail\ndef divide(a: Int, b: Int): ZIO[Any, Nothing,             Int]   // using ZIO.die\n```\n\n----------------------------------------\n\nTITLE: Defining Gen Data Type in Scala\nDESCRIPTION: This snippet shows the basic structure of the Gen data type, which is implemented as a stream of optional samples. It includes core methods like map, flatMap, and runCollect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/how-generators-work.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Gen[-R, +A](sample: ZStream[R, Nothing, Option[Sample[R, A]]])\n```\n\n----------------------------------------\n\nTITLE: Composing Generators with zipWith in Scala\nDESCRIPTION: Demonstrates the use of Gen#zipWith to create a cartesian product of elements from two generators, combining them with a specified function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/operators.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nGen.elements(\"a\", \"b\", \"c\").zipWith(Gen.elements(\"1\", \"2\", \"3\"))(_ + _)\n  .runCollectN(5)\n// Sample Output: List(b1, a2, c1, b1, b1)\n```\n\n----------------------------------------\n\nTITLE: Updating a TRef Value Across Multiple Transactions in Scala ZIO STM\nDESCRIPTION: Creates a TRef in one transaction and updates its value in another transaction. The updateAndGet method applies a function to the current value and returns the new value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval updateMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  nValue <- tRef.updateAndGet(_ + 20).commit\n} yield nValue\n```\n\n----------------------------------------\n\nTITLE: Shared Layer Implementation in ZIO 2.x\nDESCRIPTION: Example showing how to implement shared layers between test specs in ZIO 2.x\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_74\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nclass SharedService()\n\nobject Layers {\n  val sharedLayer = \n    ZLayer.succeed(new SharedService())\n}\n\nobject UseSharedLayerA extends ZIOSpec[SharedService]{\n  override def spec =\n    test(\"use the shared layer in test A\") {\n      assertCompletes\n    }\n\n  override def bootstrap= Layers.sharedLayer\n}\n\nobject UseSharedLayerB extends ZIOSpec[SharedService]{\n  override def spec =\n    test(\"use the shared layer in test B\") {\n      assertCompletes\n    }\n\n  override def bootstrap = Layers.sharedLayer\n}\n```\n\n----------------------------------------\n\nTITLE: Collecting Numeric Values from a Chunk in Scala\nDESCRIPTION: Demonstrates using collect to extract only numeric values from a mixed-type Chunk.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ncollectChunk.collect { case digit: Double => digit }\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Service with Higher-Kinded Type Parameter F[_]\nDESCRIPTION: Example showing a KeyValueStore service with a higher-kinded type parameter F[_], using the @accessibleM macro to generate accessors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros.accessibleM\n\n@accessibleM[Task]\ntrait KeyValueStore[K, V, F[_]] {\n  def set(key: K, value: V): F[V]\n\n  def get(key: K): F[V]\n}\n\ncase class InmemoryKeyValueStore(map: Ref[Map[String, Int]])\n  extends KeyValueStore[String, Int, Task] {\n  override def set(key: String, value: Int): Task[Int] =\n    map.update(_.updated(key, value)).map(_ => value)\n\n  override def get(key: String): Task[Int] =\n    map.get.map(_.get(key)).someOrFailException\n\n}\n\nobject InmemoryKeyValueStore {\n  val layer: ULayer[KeyValueStore[String, Int, Task]] =\n    ZLayer {\n      for {\n        map <- Ref.make(Map[String, Int]())\n      } yield InmemoryKeyValueStore(map)\n    }\n}\n\n\nobject MainApp extends ZIOAppDefault {\n  val myApp =\n    for {\n      key <- KeyValueStore.set[String, Int](\"key\", 5)\n      _ <- KeyValueStore.get[String, Int](\"key\")\n    } yield key\n\n  def run = myApp.provide(InmemoryKeyValueStore.layer).debug\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Scope Trait and Object\nDESCRIPTION: Core definition of the Scope trait and companion object showing the fundamental operations for managing resource lifecycles.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Scope {\n  def addFinalizerExit(finalizer: Exit[Any, Any] => UIO[Any]): UIO[Unit]\n  def close(exit: => Exit[Any, Any]): UIO[Unit]\n}\n\nobject Scope {\n  def make: UIO[Scope] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Auto-generating Accessors for Pure Methods\nDESCRIPTION: Example showing how accessors are generated for pure methods that return normal values, using ZIO.serviceWith to wrap the result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.macros.accessible\n\n@accessible\ntrait ServiceB {\n  def pureMethod(input: Something): SomethingElse\n}\n\n// below will be autogenerated\nobject ServiceB {\n  def pureMethod(input: Something): ZIO[ServiceB, Nothing, SomethingElse] =\n    ZIO.serviceWith[ServiceB](_.pureMethod(input))\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ConcurrentSet in Scala\nDESCRIPTION: Example demonstrating how to create empty and populated ConcurrentSets using ZIO. Shows initialization with empty constructor and with initial values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/concurrentset.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.ConcurrentSet\n\nfor {\n  emptySet  <- ConcurrentSet.empty[Int] \n  setA      <- ConcurrentSet.make[Int](1, 2, 3, 4)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Accessing Environment in ZIO Effect in Scala\nDESCRIPTION: This snippet shows how to access the whole environment in a ZIO effect using ZIO.environment and then provide the environment to eliminate it from the effect type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._ \nimport java.io.IOException\n\ncase class AppConfig(poolSize: Int)\n\nval myApp: ZIO[AppConfig, IOException, Unit] =\n  ZIO.environment[AppConfig].flatMap { env =>\n    val config  = env.get[AppConfig]\n    Console.printLine(s\"Application started with config: $config\")\n  }\n\nval eliminated: IO[IOException, Unit] =\n  myApp.provideEnvironment(\n    ZEnvironment(AppConfig(poolSize = 10))\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining and Composing Services using ZLayer - Scala\nDESCRIPTION: Illustrates the creation and wiring of service interfaces with ZLayer for dependency injection. It includes abstract traits for high- and low-level services, respective live implementations, and layering via ZLayer. The example highlights how to avoid environment pollution and manage implementations behind service boundaries. Prerequisites include ZIO and ZLayer imports, and services are designed to return ZIO effects with no required environment besides their dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zio-environment-use-cases.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\ntrait HighLevelService {\n  def doSomething: ZIO[Any, Nothing, Unit]\n}\n\nobject HighLevelService {\n  val live: ZLayer[LowLevelService, Nothing, HighLevelService] =\n    ZLayer.fromFunction(HighLevelServiceLive(_))\n\n  final case class HighLevelServiceLive(lowLevelService: LowLevelService) extends HighLevelService {\n    def doSomething: ZIO[Any, Nothing, Unit] =\n      ??? // implemented in terms of `LowLevelService`\n  }\n}\n\ntrait LowLevelService {\n  def doSomethingElse: ZIO[Any, Nothing, Unit]\n}\n\nobject LowLevelService {\n  val live: ZLayer[Any, Nothing, LowLevelService] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO RocksDB to SBT Dependencies\nDESCRIPTION: SBT dependency configuration for adding ZIO RocksDB to a Scala project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-rocksdb\" % \"0.3.0\"\n```\n\n----------------------------------------\n\nTITLE: Constant Value Mapping with as\nDESCRIPTION: Shows how to map all stream elements to a constant value using the as operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nval unitStream: ZStream[Any, Nothing, Unit] = \n  ZStream.range(1, 5).as(())\n```\n\n----------------------------------------\n\nTITLE: Basic FiberRef Usage in Scala\nDESCRIPTION: Demonstrates basic FiberRef creation, setting and getting values. Shows how to create a FiberRef with initial value and perform basic operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make[Int](0)\n  _        <- fiberRef.set(10)\n  v        <- fiberRef.get\n} yield v == 10\n```\n\n----------------------------------------\n\nTITLE: Non-blocking Element Retrieval from a TQueue in ZIO STM\nDESCRIPTION: Demonstrates a non-blocking way to retrieve an element from a TQueue using the poll method. Returns Some(element) if one exists, or None if the queue is empty.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueuePoll: UIO[Option[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  res    <- tQueue.poll\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Mapping Error and Success in Console Program Using mapBoth - Scala\nDESCRIPTION: Shows a practical example where both the error (non-integer input) and the successful result (integer input) are mapped using mapBoth. Dependencies: zio._ and Console. If input is not an integer, the error is mapped to a user-friendly string; on success, the value is mapped to its absolute value. Demonstrates combined error and value transformation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval result: ZIO[Any, String, Int] =\n  Console.readLine.orDie.mapAttempt(_.toInt).mapBoth(\n    _ => \"non-integer input\",\n    n => Math.abs(n)\n  )\n\n```\n\n----------------------------------------\n\nTITLE: Debugging Fibonacci Function with Print Statements\nDESCRIPTION: The Fibonacci function enhanced with print statements to show the intermediate steps of the computation, demonstrating a basic debugging technique in Scala.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/debug-a-zio-application.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef fib(n: Int): Int = {\n  @annotation.tailrec\n  def go(n: Int, a: Int, b: Int): Int =\n    if (n == 0) {\n      println(s\"final result: $a\")\n      a\n    } else {\n      println(s\"go(${n - 1}, $b, ${a + b})\")\n      go(n - 1, b, a + b)\n    }\n  println(s\"go($n, 0, 1)\")\n  go(n, 0, 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding zio-macros Dependency in SBT\nDESCRIPTION: This snippet shows how to add the zio-macros dependency to the build.sbt file, which is required to use the ServiceReloader.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\"dev.zio\" %% \"zio-macros\" % \"<version>\")\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Unsafe Operation in ZIO 1.x (Scala)\nDESCRIPTION: This Scala code demonstrates using `Runtime.default.unsafeRunAsync` in ZIO 1.x. It asynchronously executes a ZIO effect (printing a message after a delay) and provides a callback function to handle the completion result (`Exit`), printing success or failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_40\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 1.x\nimport zio._\nimport zio.console._\nimport zio.duration._\n\nRuntime.default.unsafeRunAsync(\n  console.putStrLn(\"After 3 seconds I will return 5\").delay(3.seconds).as(5)\n)(\n  _.fold(\n    e => println(s\"Failure: $e\"),\n    v => println(s\"Success: $v\")\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Completing a TPromise with the done Combinator in ZIO STM\nDESCRIPTION: Demonstrates using the done combinator to complete a TPromise with either a success or failure. The example shows both success and failure cases by passing Either values to the done method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpromise.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseDoneSucceed: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.done(Right(0)).commit\n} yield tPromise\n\nval tPromiseDoneFail: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.done(Left(\"failed\")).commit\n} yield tPromise\n```\n\n----------------------------------------\n\nTITLE: Validating and Taking Square Root with ZIO.absolve (Scala)\nDESCRIPTION: This code showcases how to use ZIO.absolve for error recovery by mapping a ZIO value to Either within the success channel, then reverting possible errors to ZIO's typed failure. Specifically, it checks for negative input and returns a String error or the square root, encapsulating the logic in a function. It requires ZIO and standard Math; the input is a ZIO effect yielding Double, and the output is a ZIO effect that may fail with a String or return the square root.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-errors-in-the-success-channel.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\ndef sqrt(input: ZIO[Any, Nothing, Double]): ZIO[Any, String, Double] =\n  ZIO.absolve(\n    input.map { value =>\n      if (value < 0.0)\n        Left(\"Value must be >= 0.0\")\n      else\n        Right(Math.sqrt(value))\n    }\n  )\n```\n\n----------------------------------------\n\nTITLE: Testing Semaphore Implementation with Concurrent Access\nDESCRIPTION: Example showing how to use the implemented semaphore in a concurrent scenario simulating a dance floor with multiple dancers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.duration.Duration\nimport zio.clock._\nimport zio.console._\nimport zio.random._\n\nval party = for {\n  dancefloor <- S(10)\n  dancers <- ZIO.foreachPar(1 to 100) { i =>\n    dancefloor.P *> nextDouble.map(d => Duration.fromNanos((d * 1000000).round)).flatMap { d =>\n      putStrLn(s\"${i} checking my boots\") *> sleep(d) *> putStrLn(s\"${i} dancing like it's 99\")\n    } *> dancefloor.V\n  }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining ZStream into Method in Scala\nDESCRIPTION: Defines the 'into' method on ZStream, which allows streaming elements into an Enqueue (which includes Hub).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\ntrait ZStream[-R, +E, +O] {\n  def into(\n    queue: Enqueue[Take[E, O]]\n  ): ZIO[R, E, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Instant Serializer with Serde.inmap in Scala\nDESCRIPTION: Creates a custom serializer/deserializer for Java's Instant type by transforming the built-in Serde.long using the inmap combinator. This demonstrates pure transformations between Long and Instant types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport java.time.Instant\n\nval instantSerde: Serde[Any, Instant] =\n  Serde.long.inmap[Instant](Instant.ofEpochMilli)(_.toEpochMilli)\n```\n\n----------------------------------------\n\nTITLE: Offering Elements to TPriorityQueue in Scala ZIO\nDESCRIPTION: Shows how to offer multiple elements to a TPriorityQueue using offerAll method within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpriorityqueue.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval queue: STM[Nothing, TPriorityQueue[Int]] =\n  for {\n    queue <- TPriorityQueue.empty[Int]\n    _     <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n  } yield queue\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Test Aspects in Scala ZIO\nDESCRIPTION: Demonstrates how to use conditional test aspects in ZIO testing framework. Shows examples of running tests conditionally based on environment variables using ifEnv and ifEnvSet aspects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/conditional-aspects.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest(\"a test that will run if the product is deployed in the testing environment\") {\n  ???\n} @@ ifEnv(\"ENV\")(_ == \"testing\")\n\ntest(\"a test that will run if the java.io.tmpdir property is available\") {\n  ???\n} @@ ifEnvSet(\"java.io.tmpdir\")\n```\n\n----------------------------------------\n\nTITLE: Combining Has-Wrapped Services in Scala ZIO\nDESCRIPTION: Example of combining two Has-wrapped service implementations using the ++ operator. This creates a combined environment that satisfies multiple service dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval combined: Has[Logging] with Has[RandomInt] = Has(LoggingLive) ++ Has(RandomIntLive)\n```\n\n----------------------------------------\n\nTITLE: Defining catchAll for ZIO - Scala\nDESCRIPTION: This snippet defines the catchAll method on the ZIO effect type, allowing recovery from all typed errors via a provided handler function. It captures typed failures and permits effectful recovery that may transform the error or result type. Requires a handler function converting errors to new effects; key parameters are the error handler and the input effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def catchAll[R1 <: R, E2, A1 >: A](h: E => ZIO[R1, E2, A1]): ZIO[R1, E2, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Chunk by Filling with Same Value in Scala\nDESCRIPTION: Creates a Chunk of specified size filled with the same value repeated.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval chunk: Chunk[Int] = Chunk.fill(3)(0)\n```\n\n----------------------------------------\n\nTITLE: Generating Sample Values from Sized Generator in Scala\nDESCRIPTION: Example of generating sample values from a sized generator using the runCollectN method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/sized.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval samples: UIO[List[Int]] = \n  sizedInts.runCollectN(5).debug\n```\n\n----------------------------------------\n\nTITLE: Using ZIO 2.x Unsafe Operations with Scala 2\nDESCRIPTION: This Scala snippet shows the syntax for performing unsafe operations in ZIO 2.x when using Scala 2. It requires the slightly more verbose `Unsafe.unsafe` block, explicitly defining a lambda that receives the `implicit unsafe: Unsafe` parameter. This parameter then enables calls to unsafe methods like `runtime.unsafe.run` within the lambda.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nUnsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe.run(Console.printLine(\"Hello, World!\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Describing an Interactive Console Program Using the Console ADT in Scala\nDESCRIPTION: Defines an immutable value, example1, using the previously declared Console ADT to model a simple interactive console program. This value sequences printing a greeting, reading input, and printing a personalized message based on user input. The program is composed by nesting PrintLine and ReadLine instructions along with a terminal Return. No side effects occur; the structure only describes the intended IO behavior.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/background.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval example1: Console[Unit] = \n  PrintLine(\"Hello, what is your name?\",\n    ReadLine(name =>\n      PrintLine(s\"Good to meet you, ${name}\", Return(() => ())))\n)\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Test Dependencies in SBT for Scala\nDESCRIPTION: This snippet shows how to add the required ZIO Test dependencies to the SBT build file. It includes zio-test, zio-test-sbt, and zio-test-magnolia, all scoped to the Test configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/installation.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  \"dev.zio\" %% \"zio-test\"          % \"${zio.BuildInfo.version.split('+').head}\" % Test,\n  \"dev.zio\" %% \"zio-test-sbt\"      % \"${zio.BuildInfo.version.split('+').head}\" % Test,\n  \"dev.zio\" %% \"zio-test-magnolia\" % \"${zio.BuildInfo.version.split('+').head}\" % Test\n)\n```\n\n----------------------------------------\n\nTITLE: Creating HTTP Routes for Counter Service\nDESCRIPTION: Implements HTTP routes for the Counter service using Akka HTTP. Handles increment and decrement operations through GET endpoints with entity ID and command parameters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.typed.ActorSystem\n\nimport scala.concurrent.duration.DurationInt\nimport akka.actor.typed.scaladsl.AskPattern._\nimport akka.http.scaladsl.server.Directives._\nimport akka.http.scaladsl.server.Route\nimport akka.cluster.sharding.typed.ShardingEnvelope\nimport akka.util.Timeout\n\nobject CounterHttpApp {\n  implicit val timeout: Timeout = 1.seconds\n\n  def routes(implicit\n      system: ActorSystem[ShardingEnvelope[Counter.Message]]\n  ): Route = {\n    path(Segment / Segment) { case (entityId, command) =>\n      get {\n        val response = system.ask[Int](askReplyTo =>\n          ShardingEnvelope(\n            entityId,\n            command match {\n              case \"inc\" => Counter.Increase(askReplyTo)\n              case \"dec\" => Counter.Decrease(askReplyTo)\n            }\n          )\n        )\n        onComplete(response) { value =>\n          complete(value.toString)\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ZIO FoldLeft Test Implementation\nDESCRIPTION: Example of testing ZIO.foldLeft operator using function generators\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\ndef foldLeft[R, E, S, A](in: => Iterable[A])(zero: => S)(f: (S, A) => ZIO[R, E, S]): ZIO[R, E, S]\n```\n\nLANGUAGE: scala\nCODE:\n```\nval func2: Gen[Any, (Int, Int) => Int] = Gen.function2(Gen.int)\n```\n\nLANGUAGE: scala\nCODE:\n```\ntest(\"ZIO.foldLeft should have the same result with List.foldLeft\") {\n  check(Gen.listOf(Gen.int), Gen.int, func2) { case (in, zero, f) =>\n    assertZIO(\n      ZIO.foldLeft(in)(zero)((s, a) => ZIO.attempt(f(s, a)))\n    )(Assertion.equalTo(\n      in.foldLeft(zero)((s, a) => f(s, a)))\n    )\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Ordinary Values with `assert` in ZIO Test (Scala)\nDESCRIPTION: This snippet demonstrates the basic usage of the `assert` function from ZIO Test to verify that a simple Scala expression (`1 + 1`) evaluates to an expected value (`2`). It uses the `Assertion.equalTo` assertion to perform the comparison.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"sum\") {\n  assert(1 + 1)(Assertion.equalTo(2))\n}\n```\n\n----------------------------------------\n\nTITLE: Using withSize Method in Scala\nDESCRIPTION: Example of using the withSize method to run an effect with a specific size.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/sized.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nval effect     : UIO[String] = ZIO.succeed(\"effect\")\nval sizedEffect: UIO[String] = Sized.withSize(10)(effect)\n```\n\n----------------------------------------\n\nTITLE: Creating Effectful Unfolding ZStreams in Scala\nDESCRIPTION: Demonstrates how to create ZStreams using effectful unfolding with ZStream.unfoldM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nval inputs: ZStream[Console, IOException, String] = ZStream.unfoldM(()) { _ =>\n  zio.console.getStrLn.map {\n    case \"exit\"  => None\n    case i => Some((i, ()))\n  } \n}   \n```\n\n----------------------------------------\n\nTITLE: Creating a TSet with Specified Values in Scala ZIO STM\nDESCRIPTION: Creates a TSet with initially specified values (1, 2, 3). This operation is performed within an STM transaction context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval specifiedValuesTSet: STM[Nothing, TSet[Int]] = TSet.make(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating a Bounded TQueue in Scala using ZIO STM\nDESCRIPTION: Creates an empty bounded TQueue with a specified capacity using the ZIO STM library. This queue has a maximum capacity of 5 elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tqueue.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueBounded: STM[Nothing, TQueue[Int]] = TQueue.bounded[Int](5)\n```\n\n----------------------------------------\n\nTITLE: Modifying a TRef Value Across Multiple Transactions in Scala ZIO STM\nDESCRIPTION: Creates a TRef in one transaction and modifies its value in another transaction. The modify method applies a transformation that produces both a result value and a new state for the reference.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval modifyMultiple: UIO[(String, Int)] = for {\n  tRef <- TRef.makeCommit(10)\n  tuple2 <- tRef.modify(v => (\"Zee-Oh\", v + 10)).zip(tRef.get).commit\n} yield tuple2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lazy Evaluation in ZIO 2.x Bracket (Scala)\nDESCRIPTION: Shows ZIO 2.x code (using `bracket` for example consistency, although `acquireReleaseWith` is the modern equivalent) where the by-name parameter for the `acquire` effect ensures lazy evaluation. The random number generation (`scala.util.Random.nextInt()`) is executed anew for each repetition within `repeatN(2)`, producing the desired behavior of different random numbers. Depends on ZIO 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n// Note that in ZIO 2.x, the `bracket` is deprecated and renamed to the `acquireReleaseWith`. In this example to prevent the consistency of our example, we used the `bracket`.\n\nZIO.bracket({\n  val random = scala.util.Random.nextInt()\n  ZIO.succeed(random)\n})(_ => ZIO.unit)(x => console.putStrLn(x.toString)).repeatN(2)\n```\n\n----------------------------------------\n\nTITLE: Acquiring Read Lock in Scala\nDESCRIPTION: Shows how to acquire a read lock and check the lock status using readLocked and writeLocked methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/treentrantlock.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stm._\n\nval program =\n  (for {\n    lock <- TReentrantLock.make\n    _    <- lock.acquireRead\n    rst  <- lock.readLocked  // lock is read-locked once transaction completes\n    wst  <- lock.writeLocked // lock is not write-locked\n  } yield rst && !wst).commit\n```\n\n----------------------------------------\n\nTITLE: Projecting Components from ZLayer in Scala\nDESCRIPTION: Demonstrates how to extract a part of a ZLayer using the project method. This approach allows accessing a specific component (Connection) from a larger configuration object (DBConfig) by providing a projection function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Connection(host: String, port: Int) \ncase class Login(user: String, password: String)\n\ncase class DBConfig(\n  connection: Connection, \n  login: Login\n)\n\nval connection: ZLayer[DBConfig, Nothing, Connection] = \n  ZLayer.service[DBConfig].project(_.connection)\n```\n\n----------------------------------------\n\nTITLE: Examples of Descriptive Compiler Error Messages in ZIO 2.x (Scala)\nDESCRIPTION: Presents the same two Scala code examples as the previous ZIO 1.x snippet, but shows the improved compiler error messages generated by ZIO 2.x. By using more descriptive type evidences (`IsSubtypeOfError`, `IsSubtypeOfOutput`), ZIO 2.x provides clearer feedback, explicitly stating the required type (e.g., `subtype of Throwable`, `subtype of List[B]`) and the actual type found (`String`, `scala.collection.immutable.Set[Int]`), making it easier to understand and fix type errors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nZIO.fail(\"Boom!\").orDie\n// error: This operator requires that the error type be a subtype of Throwable but the actual type was String.\n// ZIO.fail(\"Boom!\").orDie\n// ^^^^^^^^^^^^^^^^^^^^^^^\n\nZIO.succeed(Set(3, 4, 3)).head\n// error: This operator requires that the output type be a subtype of List[B] but the actual type was scala.collection.immutable.Set[Int].\n// ZIO.succeed(Set(3, 4, 3)).head\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Suspended Take Fiber in Scala\nDESCRIPTION: Uses queue.take.fork to demonstrate that consumers suspend when the queue is empty. Once an item is offered, the waiting fiber resumes. Outputs the dequeued String. Requires zio._ and basic Scala setup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval oldestItem: UIO[String] = for {\\n  queue <- Queue.bounded[String](100)\\n  f <- queue.take.fork // will be suspended because the queue is empty\\n  _ <- queue.offer(\"something\")\\n  v <- f.join\\n} yield v\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Live Services in Scala ZIO\nDESCRIPTION: Implementation of concrete service instances for Logging and RandomInt. These provide the actual functionality that will be used at runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval LoggingLive: Logging = new Logging {\n  override def log(line: String): UIO[Unit] =\n    ZIO.effectTotal(println(line))\n}\n\nval RandomIntLive: RandomInt = new RandomInt {\n  override def random: UIO[Int] =\n    ZIO.effectTotal(scala.util.Random.nextInt())\n}\n```\n\n----------------------------------------\n\nTITLE: Composing ZLayers for Editor Construction\nDESCRIPTION: Example of composing ZLayers to create an Editor layer that depends on Formatter and Compiler layers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval editor: ZLayer[Formatter with Compiler, Nothing, Editor] = \n  (Formatter.layer ++ Compiler.layer) >>> Editor.layer\n```\n\n----------------------------------------\n\nTITLE: Implementing NonFlaky Test Aspect in Scala with ZIO\nDESCRIPTION: Demonstrates using the nonFlaky test aspect to verify that a random value generation test consistently passes. The test will run 100 times by default to ensure reliability. Uses ZIO's Random module for generating test data.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/flaky-and-non-flaky-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest(\"random value is always greater than zero\") {\n  for {\n    random <- Random.nextIntBounded(100)\n  } yield assertTrue(random > 0)\n} @@ nonFlaky\n```\n\n----------------------------------------\n\nTITLE: Declaring Unbounded Hub Constructor in Scala\nDESCRIPTION: Defines the signature for creating an unbounded Hub. The actual implementation is not provided in this snippet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef unbounded[A]: UIO[Hub[A]] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: Defining Service Dependencies\nDESCRIPTION: Defines the required dependency interfaces MetadataRepo and BlobStorage for the DocRepo service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/service-pattern.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfinal case class Metadata(\n  title: String,\n  description: String,\n  language: String,\n  format: String\n)\n\ntrait MetadataRepo {\n  def get(id: String): ZIO[Any, Throwable, Metadata]\n\n  def put(id: String, metadata: Metadata): ZIO[Any, Throwable, Unit]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n\n  def findByTitle(title: String): ZIO[Any, Throwable, Map[String, Metadata]]\n}\n\ntrait BlobStorage {\n  def get(id: String): ZIO[Any, Throwable, Array[Byte]]\n\n  def put(content: Array[Byte]): ZIO[Any, Throwable, String]\n\n  def delete(id: String): ZIO[Any, Throwable, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Racing Between ZSinks\nDESCRIPTION: Shows how to race between multiple sinks where they run in parallel and the first one to complete provides the result. Uses the race operator for basic racing functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/concurrency-and-parallelism.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZSink[Any, Throwable, Record, Record, Unit] =\n  kafkaSink race pulsarSink\n```\n\n----------------------------------------\n\nTITLE: Defining Paginated Result Structure in Scala\nDESCRIPTION: Basic structure for paginated API results containing chunk data and pagination status.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\ncase class PageResult(results: Chunk[RowData], isLast: Boolean)\n\ndef listPaginated(pageNumber: Int): ZIO[Console, Throwable, PageResult] = ???\n```\n\n----------------------------------------\n\nTITLE: Printing Numbers with ZIO Loop\nDESCRIPTION: Demonstrates using ZIO's loop operator to print a sequence of numbers, replacing traditional recursion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nobject MainApp extends ZIOAppDefault {\n  def printNumbers(from: Int, to: Int): ZIO[Any, IOException, Unit] = {\n    ZIO.loopDiscard(from)(_ <= to, _ + 1)(i => Console.printLine(i))\n  }\n\n  def run = printNumbers(1, 3)\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Optional Error Types with ZIO in Scala\nDESCRIPTION: This Scala snippet shows how to implement and use ZIO's flattenErrorOption operator to convert a ZIO effect with optional errors (Option[String]) into one with a definite error type (String). The parseInt function parses a string and returns a ZIO effect representing success or various failure scenarios. The flattenErrorOption operator is used to provide a default error message when no specific error is present. Requires the zio library and the Scala language ecosystem. Expects string input and returns a ZIO effect that either succeeds with an integer or fails with a descriptive error message. All examples preserve error context and demonstrate different failure and success cases.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/flattening-optional-error-types.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\\n\\ndef parseInt(input: String): ZIO[Any, Option[String], Int] =\\n  if (input.isEmpty)\\n    ZIO.fail(Some(\"empty input\"))\\n  else\\n    try {\\n      ZIO.succeed(input.toInt)\\n    } catch {\\n      case _: NumberFormatException => ZIO.fail(None)\\n    }\\n\\ndef flattenedParseInt(input: String): ZIO[Any, String, Int] =\\n  parseInt(input).flattenErrorOption(\"non-numeric input\")\\n\\nval r1: ZIO[Any, String, Int] = flattenedParseInt(\"zero\")\\nval r2: ZIO[Any, String, Int] = flattenedParseInt(\"\")\\nval r3: ZIO[Any, String, Int] = flattenedParseInt(\"123\")\n```\n\n----------------------------------------\n\nTITLE: Initializing ConcurrentSet in Scala with ZIO\nDESCRIPTION: Creates empty and populated ConcurrentSet instances using ZIO's for-comprehension. This demonstrates the basic initialization patterns for ConcurrentSet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/concurrentset.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.ConcurrentSet\n\nfor {\n  emptySet  <- ConcurrentSet.empty[Int] \n  setA      <- ConcurrentSet.make[Int](1, 2, 3, 4)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Providing a Test ZIO Service Implementation in Scala\nDESCRIPTION: This snippet shows how to provide the `TestDatabase` implementation to application code (`code`) that requires a `Database` environment. Using `code.provide(TestDatabase)` injects the test service, allowing the code to be run against the in-memory test implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\n```scala\ndef code: RIO[Database, Unit] = ???\n\ndef code2: Task[Unit] = \n  code.provide(TestDatabase)\n```\n```\n\n----------------------------------------\n\nTITLE: Testing Console Interactions with TestConsole in Scala\nDESCRIPTION: This code snippet demonstrates how to use TestConsole to test an application that interacts with the console. It simulates user input, captures console output, and performs assertions on the results. The example shows how to prefill input buffers, read from them, and access the captured output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/console.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\nval consoleSuite = suite(\"ConsoleTest\")(\n  test(\"One can test output of console\") {\n    for {\n      _              <- TestConsole.feedLines(\"Jimmy\", \"37\")\n      _              <- Console.printLine(\"What is your name?\")\n      name           <- Console.readLine\n      _              <- Console.printLine(\"What is your age?\")\n      age            <- Console.readLine.map(_.toInt)\n      questionVector <- TestConsole.output\n      q1             = questionVector(0)\n      q2             = questionVector(1)\n    } yield {\n      assertTrue(name == \"Jimmy\") &&\n        assertTrue(age == 37) &&\n        assertTrue(q1 == \"What is your name?\\n\") &&\n        assertTrue(q2 == \"What is your age?\\n\")\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing an AccountObserver Service with ZIO\nDESCRIPTION: Defines a service for observing account events with its ZIO interface and live implementation. The service has two methods: processEvent for handling account events and runCommand for executing commands. It depends on the Console service for user interaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n// main sources\n\nimport zio._\nimport zio.console.Console\nimport zio.test.mock._\n\ntype AccountObserver = Has[AccountObserver.Service]\n\nobject AccountObserver {\n  trait Service {\n    def processEvent(event: AccountEvent): UIO[Unit]\n    def runCommand(): UIO[Unit]\n  }\n\n  def processEvent(event: AccountEvent) =\n    ZIO.accessM[AccountObserver](_.get.processEvent(event))\n\n  def runCommand() =\n    ZIO.accessM[AccountObserver](_.get.runCommand)\n\n  val live: ZLayer[Console, Nothing, AccountObserver] =\n    ZLayer.fromService[Console.Service, Service] { console =>\n      new Service {\n        def processEvent(event: AccountEvent): UIO[Unit] =\n          for {\n            _    <- console.putStrLn(s\"Got $event\").orDie\n            line <- console.getStrLn.orDie\n            _    <- console.putStrLn(s\"You entered: $line\").orDie\n          } yield ()\n\n        def runCommand(): UIO[Unit] =\n          console.putStrLn(\"Done!\").orDie\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Asynchronous Callback-Based API with ZIO.effectAsync - Scala\nDESCRIPTION: Demonstrates converting a legacy callback-based asynchronous API (login with success/failure callbacks) into a ZIO IO effect using IO.effectAsync. The provided callback must be invoked exactly once; integrates legacy async workflows with ZIO's effect system for improved composability and error handling. Result is IO[AuthError, User].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nobject legacy {\n  def login(\n    onSuccess: User => Unit,\n    onFailure: AuthError => Unit): Unit = ???\n}\n\nval login: IO[AuthError, User] =\n  IO.effectAsync[AuthError, User] { callback =>\n    legacy.login(\n      user => callback(IO.succeed(user)),\n      err  => callback(IO.fail(err))\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Editor Class in Scala\nDESCRIPTION: This snippet demonstrates a simple Editor class that depends on Formatter and Compiler services without using dependency injection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Editor {\n val formatter = new Formatter\n val compiler = new Compiler\n \n def formatAndCompile(code: String): UIO[String] = \n formatter.format(code).flatMap(compiler.compile)\n}\n```\n\n----------------------------------------\n\nTITLE: Lifting ZIO Effects to ZManaged\nDESCRIPTION: Shows different ways to lift ZIO effects into ZManaged context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval managedHello = ZManaged.fromEffect(putStrLn(\"Hello, World!\"))\nval managedHello_ = putStrLn(\"Hello, World!\").toManaged_\n```\n\n----------------------------------------\n\nTITLE: Consuming a Stream with foreach in Scala\nDESCRIPTION: This example shows how to consume a stream by applying an effect to each element using the foreach method. It prints each number from 0 to 100 to the console, returning an effect that completes when all elements are processed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_64\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console._\nimport zio.stream._\n\nval result: RIO[Console, Unit] = Stream.fromIterable(0 to 100).foreach(i => putStrLn(i.toString))\n```\n\n----------------------------------------\n\nTITLE: Mapping and Flattening with mapConcat\nDESCRIPTION: Demonstrates how to map elements to multiple elements and flatten the results using mapConcat.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nval numbers: UStream[Int] = \n  ZStream(\"1-2-3\", \"4-5\", \"6\")\n    .mapConcat(_.split(\"-\"))\n    .map(_.toInt)\n\n// Input:  \"1-2-3\", \"4-5\", \"6\"\n// Output: 1, 2, 3, 4, 5, 6\n```\n\n----------------------------------------\n\nTITLE: Adding Implicit Trace Parameter to ZIO Methods\nDESCRIPTION: Add implicit trace parameters to methods in ZIO ecosystem libraries to prevent messing up user's execution trace.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def map[B](f: A => B)(implicit trace: Trace): ZIO[R, E, B] = \n    flatMap(a => ZIO.succeed(f(a)))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Assertion with hasAt - ZIO Test - Scala\nDESCRIPTION: Demonstrates how to use Assertion.hasAt to create an assertion that checks whether an element at a specific index in a sequence matches a provided Assertion instance. This snippet uses ZIO Test's test constructor and assert macro. Dependencies include ZIO Test framework (zio.test). Relevant parameters: the input sequence xs, the index 3 (fourth element), and an unspecified assertion (???). Output is a ZSpec that describes the single-element test suite.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval xs = Vector(0, 1, 2, 3)\n// xs: Vector[Int] = Vector(0, 1, 2, 3)\n\ntest(\"Fourth value is equal to 5\") {\n  assert(xs)(hasAt(3)(???))\n}\n// res1: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = \"Fourth value is equal to 5\",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(use-test-assertions.md,20)))\n//       )\n//     )\n//   )\n// )\n```\n\n----------------------------------------\n\nTITLE: Defining URIO Type Alias in Scala\nDESCRIPTION: This snippet defines the URIO type alias as a specialization of ZIO. It represents an effect that requires a resource R, cannot fail (Nothing error type), and succeeds with a value A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/urio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype URIO[-R, +A] = ZIO[R, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Auto-Inferring Remaining Types with ZIO#provideSomeAuto in Scala 3\nDESCRIPTION: This snippet demonstrates the use of provideSomeAuto method in Scala 3, which automatically infers the remaining type of the effect after partial dependency injection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-propagation.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval mainEffectSomeAuto =\n  myApp.provideSomeAuto(FooLive.layer) // No need to provide `Bar` anywhere\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple HTTP Server with ZIO HTTP\nDESCRIPTION: Simple example of creating an HTTP server using ZIO HTTP. The example defines routes for text and JSON responses and starts a server on port 8090.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nimport zhttp.http._\nimport zhttp.service.Server\nimport zio._\n\nobject ZIOHTTPExample extends zio.App {\n\n  // Create HTTP route\n  val app: HttpApp[Any, Nothing] = HttpApp.collect {\n    case Method.GET -> Root / \"text\" => Response.text(\"Hello World!\")\n    case Method.GET -> Root / \"json\" => Response.jsonString(\"{\\\"greetings\\\": \\\"Hello World!\\\"}\")\n  }\n\n  // Run it like any simple app\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    Server.start(8090, app.silent).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Effectful Output Mapping with ZQueue#map in Scala\nDESCRIPTION: Demonstrates using map to transform the output type of a ZIO queue (from Int to String). Offers an Int and takes it as a String. No external dependencies beyond zio._. Capacity set to 3.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval mapped: UIO[String] = \\n  for {\\n    queue  <- Queue.bounded[Int](3)\\n    mapped = queue.map(_.toString)\\n    _      <- mapped.offer(1)\\n    s      <- mapped.take\\n  } yield s\\n\n```\n\n----------------------------------------\n\nTITLE: Expanded Cats Effect 3.x integration implementation\nDESCRIPTION: Details of how the Cats Effect 3.x integration is implemented using asyncRuntimeInstance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject ZioCatsEffectInterop extends scala.App {\n  val runtime: zio.Runtime[Any] = zio.Runtime.default\n  \n  val zioApp: zio.Task[Unit] = catsEffectApp[zio.Task](\n    zio.interop.catz.asyncRuntimeInstance(runtime) \n  )\n  \n  runtime.unsafeRun(zioApp.exitCode) \n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Fibers Holding Read Locks in TReentrantLock\nDESCRIPTION: Demonstrates how multiple fibers can simultaneously hold read locks. The example shows two fibers acquiring read locks and tracks the count of read locks held.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval multipleReadLocksProgram: UIO[(Int, Int)] = for {\n  lock          <- TReentrantLock.make.commit\n  fiber0        <- lock.acquireRead.commit.fork // fiber0 acquires a read-lock\n  currentState1 <- fiber0.join                  // 1 read lock held\n  fiber1        <- lock.acquireRead.commit.fork // fiber1 acquires a read-lock\n  currentState2 <- fiber1.join                  // 2 read locks held \n} yield (currentState1, currentState2)\n```\n\n----------------------------------------\n\nTITLE: Scala Query Implementation\nDESCRIPTION: Implementation of query types and resolvers in Scala using Caliban\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ncase class EmployeesArgs(role: Role)\ncase class EmployeeArgs(name: String)\n\ncase class Queries(\n    employees: EmployeesArgs => List[Employee],\n    employee: EmployeeArgs => Option[Employee]\n)\n```\n\n----------------------------------------\n\nTITLE: Testing Either Values with TestLens in Scala\nDESCRIPTION: Shows how to use TestLens operators to test Either values in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ntest(\"TestLens#right\") {\n  val sut: Either[Error, Int] = Right(40 + 2)\n  assertTrue(sut.is(_.right) == 42)\n}\n\ncase class Error(errorMessage: String)\n\ntest(\"TestLens#left\") {\n  val sut: Either[Error, Int] = Left(Error(\"Boom!\"))\n  assertTrue(sut.is(_.left).errorMessage == \"Boom!\")\n}\n\ntest(\"TestLens#anything\") {\n  val sut: Either[Error, Int] = Right(42)\n  assertTrue(sut.is(_.anything))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Logging Span in Scala with ZIO\nDESCRIPTION: Demonstrates how to create a logging span using ZIO.logSpan to measure the execution time of a code block.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.logSpan(\"span name\") {\n  // do some work\n  // log inside the span\n  // do some more work\n  // another log inside the span\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO#orElseOptional Method Signature in Scala\nDESCRIPTION: This snippet presents the `orElseOptional` signature. This combinator is specifically designed for effects where the error type is `Option[E1]`. It executes the fallback effect `that` only if the original effect fails with `None`. An implicit evidence `ev` ensures the original error type `E` is a subtype of `Option[E1]`. The result type remains `ZIO[R1, Option[E1], A1]`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def orElseOptional[R1 <: R, E1, A1 >: A](\n      that: => ZIO[R1, Option[E1], A1]\n    )(implicit ev: E IsSubtypeOfError Option[E1]): ZIO[R1, Option[E1], A1] =\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Random Seed for Reproducible Sequences\nDESCRIPTION: Shows how to set a specific seed for the random generator to produce reproducible sequences of random numbers, which is useful for testing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/random.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  _        <- Random.setSeed(0)\n  nextInts <- (Random.nextInt zip Random.nextInt)\n} yield assert(nextInts == (-1155484576,-723955400))\n```\n\n----------------------------------------\n\nTITLE: Generating Fixed-Length Strings in Scala using ZIO Test\nDESCRIPTION: Shows how to create a generator for strings of a fixed length using alphabetic characters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nGen.stringN(5)(Gen.alphaChar)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(BuywQ, tXCEy, twZli, ffLwI, BPEbz, OKYTi, xeDJW, iDUVn, cuMCr, keQAA)\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements from Chunk in Scala\nDESCRIPTION: Uses the drop method to remove a specified number of elements from the beginning of a Chunk. This example drops the first element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nChunk(\"Sarah\", \"Bob\", \"Jane\").drop(1)\n// res5: Chunk[String] = IndexedSeq(\"Bob\", \"Jane\")\n```\n\n----------------------------------------\n\nTITLE: Property-Based Testing for Integer Addition Associativity in ZIO Test (Scala)\nDESCRIPTION: Illustrates how to use ZIO Test's property-based testing features to check the associativity of integer addition using the 'check' method and 'Gen' class.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/why-zio-test.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nval associativity =\n  check(Gen.int, Gen.int, Gen.int) { (x, y, z) =>\n    assertTrue(((x + y) + z) == (x + (y + z)))\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating an HTTP Server with Akka HTTP\nDESCRIPTION: Shows how to create a simple HTTP server using Akka HTTP. It sets up a route that responds to GET requests on the '/hello' path with an HTML response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.http.scaladsl.Http\nimport akka.http.scaladsl.model._\nimport akka.http.scaladsl.server.Directives._\n\nobject AkkHttpServer extends App {\n  implicit val system = ActorSystem(Behaviors.empty, \"system\")\n  implicit val executionContext = system.executionContext\n\n  Http().newServerAt(\"localhost\", 8080).bind {\n    path(\"hello\") {\n      get {\n        complete(\n          HttpEntity(\n            ContentTypes.`text/html(UTF-8)`,\n            \"<h1>Say hello to akka-http</h1>\"\n          )\n        )\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating CyclicBarrier Instances in Scala\nDESCRIPTION: Shows the constructor methods for creating CyclicBarrier instances with optional release actions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/cyclicbarrier.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject CyclicBarrier {\n  def make(parties: Int)                  : UIO[CyclicBarrier] = ???\n  def make(parties: Int, action: UIO[Any]): UIO[CyclicBarrier] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Bounded Strings in Scala with ZIO Test\nDESCRIPTION: Demonstrates how to create a generator for strings with a specified length range using alphanumeric characters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nGen.stringBounded(1, 5)(Gen.alphaChar)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(b, YJXzY, Aro, y, WMPbj, Abxt, kJep, LKN, kUtr, xJ)\n```\n\n----------------------------------------\n\nTITLE: Account Withdraw with Balance Check\nDESCRIPTION: Implementation of withdraw with balance verification, but still vulnerable to race conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef withdraw(accountBalance: Ref[Int], amount: Int) = for {\n  balance <- accountBalance.get\n  _ <- if (balance < amount) ZIO.fail(\"Insufficient funds in you account\") else\n    accountBalance.update(_ - amount)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Nested Assertion on Option Type in Scala\nDESCRIPTION: Demonstrates how to create and use a nested assertion to test an Option[Int] value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval assertion: Assertion[Option[Int]] = Assertion.isSome(Assertion.equalTo(5))\n\ntest(\"optional value is some(5)\") {\n  assert(Some(1 + 4))(assertion)\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Option to ZIO Effect using ZIO.fromOption in Scala\nDESCRIPTION: Uses `ZIO.fromOption` to convert a `Some` instance into a ZIO effect. The resulting effect (`zoption`) succeeds with the value inside the `Some` (2). If the input were `None`, the effect would fail with an error of type `Option[Nothing]`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval zoption: IO[Option[Nothing], Int] = ZIO.fromOption(Some(2))\n```\n\n----------------------------------------\n\nTITLE: Examples of Obscure Compiler Error Messages in ZIO 1.x (Scala)\nDESCRIPTION: Provides two Scala code snippets that cause compile-time errors in ZIO 1.x due to type mismatches. The first attempts `orDie` on an effect failing with `String` (requires `Throwable`). The second attempts `head` on an effect succeeding with `Set[Int]` (requires `List[B]`). The comments show the corresponding ZIO 1.x error messages, which rely on `<:<` (subtype) evidence and are often less informative for diagnosing the issue.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nZIO.fail(\"Boom!\").orDie\n// error: Cannot prove that String <:< Throwable.\n// ZIO.fail(\"Boom!\").orDie\n// ^^^^^^^^^^^^^^^^^^^^^^^\n\nZIO.succeed(Set(3,4)).head\n// error: Cannot prove that scala.collection.immutable.Set[Int] <:< List[B].\n// ZIO.succeed(Set(3, 4)).head\n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\n----------------------------------------\n\nTITLE: Recovering from Failure with orElse in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates how to use ZStream#orElse to recover from a failed stream by switching to an alternative stream. The example shows two streams combined, where the second stream is used when the first one fails.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/error-handling.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nval s1 = ZStream(1, 2, 3) ++ ZStream.fail(\"Oh! Error!\") ++ ZStream(4, 5)\nval s2 = ZStream(6, 7, 8)\n\nval stream = s1.orElse(s2)\n// Output: 1, 2, 3, 6, 7, 8\n```\n\n----------------------------------------\n\nTITLE: Getting the Size of a TSet in Scala ZIO STM\nDESCRIPTION: Retrieves the number of elements in a TSet using the size method within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSetSize: UIO[Int] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  size <- tSet.size\n} yield size).commit\n```\n\n----------------------------------------\n\nTITLE: Sharing Layers with provideShared in Scala ZIO Tests\nDESCRIPTION: This snippet demonstrates various ways to share layers across multiple tests and suites using the `provideShared` method in ZIO tests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/sharing-layers-within-the-same-file.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n{\n  test(\"test1\")(???) +\n    test(\"test2\")(???)\n}.provideShared(sharedLayer)\n\nsuite(\"suite1\")(\n  test(\"test1\")(???),\n  test(\"test2\")(???)\n).provideShared(sharedLayer)\n\nsuite(\"all suites\")(\n  suite(\"suite1\")(\n    test(\"test1\")(???),\n  ),\n  suite(\"suite2\")(\n    test(\"test1\")(???),\n    test(\"test2\")(???),\n    test(\"test3\")(???)\n  )\n).provideShared(sharedLayer)\n```\n\n----------------------------------------\n\nTITLE: Updating Method Signatures for Lazy Evaluation in ZIO 2.x\nDESCRIPTION: Update method signatures to use by-name parameters and suspend evaluation to prevent double evaluation and side-effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ndef foreachParN[A](n0: => Int)(a0: => Iterable[A]) = \n  ZIO.suspendSucceed {\n    val n = n0 \n    val a = a0\n    ... // The function body\n  }\n```\n\n----------------------------------------\n\nTITLE: Asserting Exit Value is Interrupted in Scala\nDESCRIPTION: Creates an assertion `Assertion[Exit[Any, Any]]` that checks if a ZIO `Exit` value represents an interruption. This confirms the fiber was interrupted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nisInterrupted\n```\n\n----------------------------------------\n\nTITLE: Unsafe Concurrent State Management with Ref in Scala\nDESCRIPTION: Shows an unsafe way to manage state in concurrent environments by composing update and get operations, which can lead to inconsistent results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// Unsafe in Concurrent Environment\ndef request(counter: Ref[Int]) = {\n  for {\n    _  <- counter.update(_ + 1)\n    rn <- counter.get\n    _  <- Console.printLine(s\"request number received: $rn\")\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Deterministic Random Number Generation Test in Scala ZIO\nDESCRIPTION: Demonstrates a ZIO test case using TestRandom with a fixed initial seed, showing how the same sequence of random numbers is generated across multiple test runs using check generator with samples and repeat aspects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/non-deterministic-test-data.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest(\"pseudo-random number generator with fixed initial seed\") {\n  check(Gen.int(0, 100)) { n =>\n    ZIO.attempt(n).debug.map(_ => assertTrue(true))\n  }\n} @@\n  samples(5) @@\n  after(Console.printLine(\"----\").orDie) @@\n  repeat(Schedule.recurs(1))\n```\n\n----------------------------------------\n\nTITLE: Partitioning Results with ZIO.partition in Scala\nDESCRIPTION: This snippet demonstrates ZIO.partition, which creates a tuple of both failures and successes in the success channel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/error-accumulation.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval res: ZIO[Any, Nothing, (Iterable[String], Iterable[Int])] =\n  ZIO.partition(List.range(0, 7)){ n =>\n    if (n % 2 == 0)\n      ZIO.succeed(n)\n    else\n      ZIO.fail(s\"$n is not even\")\n  }\nres.debug\n```\n\n----------------------------------------\n\nTITLE: Repeating Tests with Schedule in ZIO Test (Scala)\nDESCRIPTION: This snippet demonstrates how to use the 'repeat' test aspect in ZIO Test. It repeats a test based on a specified schedule, ensuring the test passes every time. In this case, it uses Schedule.recurs(5) to repeat the test 5 times.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/repeat-and-retry.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\ntest(\"repeating a test based on the scheduler to ensure it passes every time\") {\n  ZIO.debug(\"repeating successful tests\")\n    .map(_ => assertTrue(true))\n} @@ TestAspect.repeat(Schedule.recurs(5))\n```\n\n----------------------------------------\n\nTITLE: Running a Dying Effect - MainApp with ZIOAppDefault - Scala\nDESCRIPTION: Defines a ZIOAppDefault application whose run implementation kills the effect with an ArithmeticException. Demonstrates the impact of a defect on the ZIO runtime; executing this app causes the stack trace to print. Dependencies: zio._, extends ZIOAppDefault.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = ZIO.die(new ArithmeticException(\"divide by zero\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Periodic Task with ZIO Clock Sleep Function\nDESCRIPTION: Example of implementing a periodic task using the sleep function from the Clock service. This function prints the current time, sleeps for one second, and then repeats indefinitely, demonstrating the non-blocking nature of ZIO's sleep operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/clock.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef printTimeForever: ZIO[Console with Clock, Throwable, Nothing] =\n  currentDateTime.flatMap(time => putStrLn(time.toString)) *>\n    sleep(1.seconds) *> printTimeForever\n```\n\n----------------------------------------\n\nTITLE: Cloning and Running ZIO Quickstart Project\nDESCRIPTION: Commands to clone the ZIO Quickstarts repository and run the logging example application using sbt\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/enable-logging-in-a-zio-application.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-restful-webservice-logging\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt run\n```\n\nLANGUAGE: bash\nCODE:\n```\nsbt reStart\n```\n\n----------------------------------------\n\nTITLE: Discarding Left Result with zipRight in ZIO Scala\nDESCRIPTION: Demonstrates using `ZIO#zipRight` to combine two effects sequentially but only keep the success value of the right effect. It executes `putStrLn` first, then `getStrLn`, and the resulting effect succeeds with the value from `getStrLn`, discarding the `Unit` result from `putStrLn`. Assumes `putStrLn` and `getStrLn` are defined ZIO effects for console I/O. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_operations.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval zipRight1 = \n  putStrLn(\"What is your name?\").zipRight(getStrLn)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple ZIO Effect\nDESCRIPTION: A basic example showing how to create a ZIO effect that performs a simple computation, demonstrating that effects are descriptions of computations rather than the computations themselves.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/debug-a-zio-application.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval effect: ZIO[Any, Nothing, Unit] = ZIO.succeed(3).map(_ * 2)\n```\n\n----------------------------------------\n\nTITLE: Using ZIO#orElseOptional for Handling Optional Failures in Scala\nDESCRIPTION: This example uses `orElseOptional`. A helper function `parseInt` attempts to parse a string to an Int, failing with `Some(errorMessage)` for invalid non-integer input and `None` for empty/whitespace input. The code calls `parseInt(\"  \")`, which fails with `None`. Because the failure is `None`, `orElseOptional(ZIO.succeed(0))` triggers, and the final result is a successful effect yielding `0`. The `.debug` prints the result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/fallback.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef parseInt(input: String): ZIO[Any, Option[String], Int] =\n  input.toIntOption match {\n    case Some(value) => ZIO.succeed(value)\n    case None =>\n      if (input.trim.isEmpty)\n        ZIO.fail(None)\n      else\n        ZIO.fail(Some(s\"invalid non-integer input: $input\"))\n  }\n\nval result = parseInt(\"  \").orElseOptional(ZIO.succeed(0)).debug\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO.acquireReleaseWith API in Scala\nDESCRIPTION: This code snippet defines the signature of the ZIO.acquireReleaseWith API. It demonstrates how the 'release' parameter requires an unexceptional effect (URIO), enforcing type safety at compile-time.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/exceptional-and-unexceptional-effects.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject ZIO {\n  def acquireReleaseWith[R, E, A, B](\n    acquire: => ZIO[R, E, A],\n    release: A => URIO[R, Any],\n    use: A => ZIO[R, E, B]\n  ): ZIO[R, E, B]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Application with Global Environment in Scala\nDESCRIPTION: This snippet demonstrates how to create a ZIO application using a global environment. It defines services A, B, C, and D, and provides them to the entire application at once using ZLayer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/overriding-dependency-graph.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val myApp: ZIO[ServiceA & ServiceB & ServiceC & ServiceD, Throwable, Unit] = ???\n    \n  def run = myApp.provide(a, b, c, d)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URLayer Type Alias in Scala for ZIO\nDESCRIPTION: This code snippet defines the URLayer type alias in Scala for the ZIO library. It represents a layer that requires RIn as input, cannot fail (Nothing), and produces ROut as output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/urlayer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype URLayer[-RIn, +ROut] = ZLayer[RIn, Nothing, ROut]\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Scala Constructors\nDESCRIPTION: Example of defining Editor, Compiler, and Formatter classes using traditional Scala constructors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/zlayer-constructor-as-a-value.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nclass Editor(formatter: Formatter, compiler: Compiler) {\n  // ...\n}\n\nclass Compiler() {\n  // ...\n}\n\nclass Formatter() {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Populated ConcurrentMap in ZIO\nDESCRIPTION: Demonstrates two methods for creating a ConcurrentMap with initial values using make and fromIterable\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/concurrentmap.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.ConcurrentMap\n\nval map1 = ConcurrentMap.make((\"foo\", 0), (\"bar\", 1), (\"baz\", 2))\nval map2 = ConcurrentMap.fromIterable(List((\"foo\", 0), (\"bar\", 1), (\"baz\", 2)))\n```\n\n----------------------------------------\n\nTITLE: Interspersing Elements in ZIO Streams\nDESCRIPTION: This example shows how to insert separator elements between stream elements using the intersperse operator. It can insert a single value or a pattern of separator values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_51\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3, 4, 5).intersperse(0)\n// Output: 1, 0, 2, 0, 3, 0, 4, 0, 5\n\nval s2 = ZStream(\"a\", \"b\", \"c\", \"d\").intersperse(\"[\", \"-\", \"]\")\n// Output: [, -, a, -, b, -, c, -, d]\n```\n\n----------------------------------------\n\nTITLE: Setting up Imports and ZIO Runtime for Reactive Streams Interop in Scala\nDESCRIPTION: Imports required classes from Reactive Streams examples (`org.reactivestreams.example.unicast`), ZIO core (`zio`), ZIO streams (`zio.stream`), and the ZIO Reactive Streams interop module (`zio.interop.reactivestreams`). It also initializes the default ZIO `Runtime` required to execute ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-reactive-streams.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nimport org.reactivestreams.example.unicast._\nimport zio._\nimport zio.interop.reactivestreams._\nimport zio.stream._\n\nval runtime = Runtime.default\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing List Length Function with Tail Recursion in Scala\nDESCRIPTION: A complete implementation of the length function using a nested recursive helper function that accumulates the count.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ndef length[T](list: List[T]): Int = {\n  def loop(list: List[T], count: Int): Int = {\n    list match {\n      case Nil => count\n      case _ :: tail => loop(tail, count + 1)\n    }\n  }\n\n  loop(list, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Generators from Random Effects in Scala with ZIO Test\nDESCRIPTION: Shows how to create generators using random effects and custom shrinking strategies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval gen: Gen[Any, Int] = Gen.fromRandom(_.nextInt) \n```\n\nLANGUAGE: scala\nCODE:\n```\nval gen: Gen[Any, Int] =\n  Gen.fromRandomSample(\n    _.nextIntBounded(20).map(Sample.shrinkIntegral(0))\n  )\n```\n\n----------------------------------------\n\nTITLE: Asserting String Ends With Suffix in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if a `String` ends with the specified `suffix`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nendsWithString(suffix: String)\n```\n\n----------------------------------------\n\nTITLE: Converting FS2 Stream to ZStream with interop-cats (Scala)\nDESCRIPTION: Demonstrates conversion of FS2 Stream to ZIO ZStream using the fs2z extension method. By importing zio.stream.interop.fs2z._, fs2.Stream#toZStream can be invoked, yielding a ZStream that can be composed with ZIO streaming operations. Inputs are integer range boundaries; output is a ZStream of integers from FS2 source. Dependencies required are zio.stream, zio.stream.interop.fs2z, and fs2.Stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream.ZStream\nimport zio.stream.interop.fs2z._\nval zstream: ZStream[Any, Throwable, Int] = fs2.Stream.range(1, 10).toZStream()\n```\n\n----------------------------------------\n\nTITLE: Defining RIO Type Alias in Scala\nDESCRIPTION: This code defines the RIO type alias as a specialization of ZIO with a Throwable error channel. It represents an effect that requires an environment R, may fail with a Throwable, or succeed with a value A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/rio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntype RIO[-R, +A]  = ZIO[R, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Using Counter Service in ZIO Test Suites\nDESCRIPTION: This example demonstrates how to use the custom Counter service within ZIO test suites. It increments the counter after each test execution and shares the Counter layer across all tests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/sharing-layers-within-the-same-file.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nobject MySpecs extends ZIOSpecDefault {\n  def spec = {\n    suite(\"Spec1\")(\n      test(\"test1\") {\n        assertTrue(true)\n      } @@ TestAspect.after(Counter.inc),\n      test(\"test2\") { assertTrue(true)\n      } @@ TestAspect.after(Counter.inc)\n    ) +\n      suite(\"Spec2\") {\n        test(\"test1\") {\n          assertTrue(true)\n        } @@ TestAspect.after(Counter.inc)\n      }\n  }.provideShared(Counter.layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a TReentrantLock using STM in Scala\nDESCRIPTION: Creates a new reentrant lock instance using the TReentrantLock.make factory method in ZIO STM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stm._\n\nval reentrantLock = TReentrantLock.make\n```\n\n----------------------------------------\n\nTITLE: Using LogStage with ZIO in Scala\nDESCRIPTION: This example demonstrates how to use LogStage with ZIO. It shows logging within the same fiber and in a new fiber, using LogZIO and IzLogger. The code includes imports, a ZIO application structure, and a custom logger layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/logstage.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport izumi.fundamentals.platform.uuid.UUIDGen\nimport logstage.LogZIO.log\nimport logstage.{IzLogger, LogIO2, LogZIO}\nimport zio.{Has, URIO, _}\n\nobject LogStageExample extends zio.App {\n  val myApp = for {\n    _ <- log.info(\"I'm logging with logstage!\")\n    userId = UUIDGen.getTimeUUID()\n    _ <- log.info(s\"Current $userId\")\n    _ <- log.info(\"I'm logging within the same fiber!\")\n    f <- log.info(\"I'm logging within a new fiber!\").fork\n    _ <- f.join\n  } yield ()\n\n  val loggerLayer: ULayer[Has[LogIO2[IO]]] =\n    ZLayer.succeed(LogZIO.withFiberId(IzLogger()))\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provide(loggerLayer).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Expectations for Methods Without Input Arguments\nDESCRIPTION: Shows how to set up expectations for methods that don't take input parameters, focusing only on defining the expected output or return value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nval exp02 = ExampleMock.ZeroArgs(value(42))\n```\n\n----------------------------------------\n\nTITLE: Generating Weighted Boolean Values in Scala with ZIO Test\nDESCRIPTION: Demonstrates how to create a generator that produces boolean values with specified weights.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nval trueFalse = Gen.weighted((Gen.const(true), 9), (Gen.const(false), 1))\ntrueFalse.runCollectN(10).debug\n// Sample Output: List(false, false, false, false, false, false, false, false, true, false)\n```\n\n----------------------------------------\n\nTITLE: Asserting Try is Success with Condition in Scala\nDESCRIPTION: Creates an assertion `Assertion[Try[A]]` that checks if a `scala.util.Try[A]` is a `Success`. It requires the value `A` within the `Success` to satisfy the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nisSuccess[A](assertion: Assertion[A])\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis for ZIO Shardcake Storage\nDESCRIPTION: This code sets up a Redis connection for use with Shardcake as a storage backend. It defines a live layer for Redis integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nimport com.devsisters.shardcake.StorageRedis.Redis\nimport dev.profunktor.redis4cats.Redis\nimport dev.profunktor.redis4cats.connection.RedisClient\nimport dev.profunktor.redis4cats.data.RedisCodec\nimport dev.profunktor.redis4cats.effect.Log\nimport dev.profunktor.redis4cats.pubsub.PubSub\nimport zio.interop.catz._\nimport zio._\n\nobject RedisLive {\n  val layer: ZLayer[Any, Throwable, Redis] =\n    ZLayer.scopedEnvironment {\n      implicit val runtime: zio.Runtime[Any] = zio.Runtime.default\n      \n      implicit val logger: Log[Task] = new Log[Task] {\n        override def debug(msg: => String): Task[Unit] = ZIO.logDebug(msg)\n        override def error(msg: => String): Task[Unit] = ZIO.logError(msg)\n        override def info(msg: => String): Task[Unit]  = ZIO.logInfo(msg)\n      }\n\n      (for {\n        client   <- RedisClient[Task].from(\"redis://localhost\")\n        commands <- Redis[Task].fromClient(client, RedisCodec.Utf8)\n        pubSub   <- PubSub.mkPubSubConnection[Task, String, String](client, RedisCodec.Utf8)\n      } yield ZEnvironment(commands, pubSub)).toScopedZIO\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Bounded Collections in Scala with ZIO Test\nDESCRIPTION: Demonstrates how to create a generator for collections (in this case, strings) with a specified size range.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nGen.bounded(2, 5)(Gen.stringN(_)(Gen.alphaChar))\n  .runCollectN(5)\n// Sample Output: List(jU, tqwQ, VBTlQ, lH, JAH)\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Application in Scala\nDESCRIPTION: Scala code for a simple ZIO application that reads a name from console input and prints a greeting.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/run-our-first-zio-project-with-vscode.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = \n    for {\n      name <- Console.readLine(\"What is your name? \")\n      _    <- Console.printLine(s\"Hello, $name!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Job Processing with Akka Actors\nDESCRIPTION: Demonstrates how to achieve parallelism in Akka by creating a JobRunner actor and using a RoundRobinPool to distribute jobs across multiple actor instances.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor._\n\ncase class Job(n: Int)\n\nclass JobRunner extends Actor {\n  override def receive = { case Job(n) =>\n    println(s\"job$n  started\")\n    Thread.sleep(1000)\n    println(s\"job$n  finished\")\n  }\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor._\nimport akka.routing.RoundRobinPool\n\nobject MainApp extends scala.App {\n  val actorSystem = ActorSystem(\"parallel-app\")\n  val jobRunner = actorSystem.actorOf(\n    Props[JobRunner].withRouter(RoundRobinPool(4)),\n    \"job-runner\"\n  )\n\n  for (job <- (1 to 10).map(Job)) {\n    jobRunner ! job\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fallback Layer Composition with ZLayer.orElse (Scala)\nDESCRIPTION: Uses ZLayer.orElse to provide a fallback layer in case the primary layer fails. Requires trait definitions and two candidate ZLayers. Output is a single ZLayer that tries the first and falls back to the second if needed. Useful for fault tolerance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Database\n\nval postgresDatabaseLayer: ZLayer[Any, Throwable, Database] = ???\nval inmemoryDatabaseLayer: ZLayer[Any, Throwable, Database] = ???\n\nval databaseLayer: ZLayer[Any, Throwable, Database] =\n  postgresDatabaseLayer.orElse(inmemoryDatabaseLayer)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Client Function Using ZStream\nDESCRIPTION: A client implementation that consumes a stream of Long values, collecting a random number of elements. This shows how clients can observe changes without knowing about the SubscriptionRef source.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/subscriptionref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef client(changes: ZStream[Any, Nothing, Long]): UIO[Chunk[Long]] =\n  for {\n    n     <- Random.nextLongBetween(1, 200)\n    chunk <- changes.take(n).runCollect\n  } yield chunk\n```\n\n----------------------------------------\n\nTITLE: Testing Generated Commands on a Stack in Scala with ZIO Test\nDESCRIPTION: Shows how to use the generated commands to test a mutable stack implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.{ test, _ }\n\ntest(\"unfoldGen\") {\n  check(genCommands) { commands =>\n    val stack = scala.collection.mutable.Stack.empty[Int]\n    commands.foreach {\n      case Pop => stack.pop()\n      case Push(value) => stack.push(value)\n    }\n    assertCompletes\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Option is Some with Condition in Scala\nDESCRIPTION: Creates an assertion `Assertion[Option[A]]` that checks if an `Option[A]` is a `Some`. It requires the value `A` inside the `Some` to satisfy the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nisSome[A](assertion: Assertion[A])\n```\n\n----------------------------------------\n\nTITLE: Basic Logging in ZIO with ZIO.log\nDESCRIPTION: Example of using ZIO's built-in logging facade with the basic ZIO.log function to log messages in applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_88\n\nLANGUAGE: scala\nCODE:\n```\nZIO.log(\"Application started!\")\n```\n\n----------------------------------------\n\nTITLE: Iterating Over TArray Elements with STM Effects in ZIO (Scala)\nDESCRIPTION: Performs an STM effect for each element in the TArray. This example creates a TArray and a TQueue, then offers each element from the array to the queue using the foreach method to apply the effect to each element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foreachTArray = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  tQueue <- TQueue.unbounded[Int]\n  _      <- tArray.foreach(a => tQueue.offer(a).unit)\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Creating ZStreams from Effectful Iterators in Scala\nDESCRIPTION: Shows how to create a ZStream from an effectful iterator that may throw an exception, using ZStream.fromIteratorEffect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.Source\nval lines: ZStream[Any, Throwable, String] = \n  ZStream.fromIteratorEffect(Task(Source.fromFile(\"file.txt\").getLines()))\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Config Provider in Scala ZIO Application\nDESCRIPTION: This snippet demonstrates how to set a custom config provider (console provider) for a ZIO application. It overrides the default config provider using Runtime.setConfigProvider.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/configuration/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainAppScoped extends ZIOAppDefault {\n  override val bootstrap: ZLayer[Any, Nothing, Unit] =\n    Runtime.setConfigProvider(ConfigProvider.consoleProvider)\n\n  def run =\n    for {\n      host <- ZIO.config(Config.string(\"host\"))\n      port <- ZIO.config(Config.int(\"port\"))\n      _ <- Console.printLine(s\"Application started: http://$host:$port\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZKeyedPool Interface in Scala\nDESCRIPTION: The core interface of ZKeyedPool with two fundamental operations: get for retrieving an item from the pool by its key, and invalidate for removing an item from the pool to cause reallocation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zkeyedpool.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZKeyedPool[+Err, -Key, Item] {\n  def get(key: Key): ZIO[Scope, Err, Item]\n  def invalidate(item: Item): UIO[Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Using a BlobStorage Service with Accessor Methods\nDESCRIPTION: Example of how to use the BlobStorage service with accessor methods, showing how the service appears in the environment requirement.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n  BlobStorage.get(\"blob-id\")  // returns a ZIO[BlobStorage, Throwable, Array[Byte]]\n```\n\n----------------------------------------\n\nTITLE: Cloning ZIO Quickstarts Repository\nDESCRIPTION: Commands to clone the ZIO Quickstarts project and navigate to the Kafka example directory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-kafka\n```\n\n----------------------------------------\n\nTITLE: Fiber Type Parameters Structure\nDESCRIPTION: Definition of Fiber type parameters where E represents the error channel and A represents the success value type. This typing enables compile-time safety and composition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nFiber[E, A]\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application with SBT\nDESCRIPTION: Command to run the ZIO application using SBT (Scala Build Tool).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/hello-world.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsbt run\n```\n\n----------------------------------------\n\nTITLE: Reading File Lines with Try/Finally Resource Management in Scala\nDESCRIPTION: An improved version of the file reading example using try/finally to ensure resources are properly closed even if an exception occurs during the file processing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef lines(file: String): Task[Long] = Task.effect {\n  def countLines(br: BufferedReader): Long = br.lines().count()\n  val bufferedReader = new BufferedReader(\n    new InputStreamReader(new FileInputStream(\"file.txt\")),\n    2048\n  )\n  try countLines(bufferedReader)\n  finally bufferedReader.close()\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Left or Failing with Mapping from ZIO[R, E, Either[A, B]] in Scala\nDESCRIPTION: Transforms a `ZIO[R, E, Either[A, B]]` into a `ZIO[R, E, A]`. If the `Either` is `Left(a)`, the effect succeeds with `a`. If it's `Right(b)`, the function `f` maps the value `b` to an error of type `E`, and the effect fails with that mapped error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nfrom.leftOrFailWith(f)\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Effect as Future\nDESCRIPTION: Demonstrates executing a ZIO effect asynchronously and obtaining a Future using Runtime.unsafe.runToFuture. Requires explicit unsafe handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-future.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{Runtime, Task, Unsafe}\n...\nval zio: Task[String] = ...\nval runtime = Runtime.default\nval fut: Future[String] = Unsafe.unsafe { implicit unsafe =>\n  runtime.unsafe.runToFuture(zio)\n}\n```\n\n----------------------------------------\n\nTITLE: Log Output for Parallel ZIO Failures (Log)\nDESCRIPTION: This log output corresponds to the parallel failure example. It shows two distinct exceptions (\"Oh!\" and \"Uh!\") originating from different fibers (`zio-fiber-13` and `zio-fiber-14`), demonstrating that both parallel computations failed independently.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala\ntimestamp=2022-03-09T08:05:48.703035927Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-13\\\" java.lang.String: Oh!\\n\\tat <empty>.MainApp.run(MainApp.scala:4)\\nException in thread \\\"zio-fiber-14\\\" java.lang.String: Uh!\\n\\tat <empty>.MainApp.run(MainApp.scala:4)\"\n```\n```\n\n----------------------------------------\n\nTITLE: Complete ZIO Example for Listing Kubernetes Nodes\nDESCRIPTION: A runnable ZIO application that demonstrates connecting to a Kubernetes cluster, listing nodes, and printing their names. Requires kubectl proxy to be running for authentication.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/scala-k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport dev.hnaderi.k8s.client._\nimport zio.http.Client\nimport zio._\n\n//NOTE run `kubectl proxy` before running this example\nobject ZIOExample extends ZIOAppDefault {\n  private val app = ZIO.scoped {\n    for {\n      n <- ZIOKubernetesClient.send(APIs.nodes.list())\n      _ <- ZIO.foreach(n.items.map(_.metadata.flatMap(_.name)))(Console.printLine(_))\n    } yield ()\n  }\n\n  override def run =\n    app.provide(\n      Client.default,\n      ZIOBackend.make,\n      ZIOKubernetesClient.make(\"http://localhost:8001\")\n    )\n\n}\n```\n\n----------------------------------------\n\nTITLE: Updating a TRef Value in a Single Transaction in Scala ZIO STM\nDESCRIPTION: Creates a TRef and updates its value using a function that adds 20 to the current value. The updateAndGet method both updates the value and returns the new value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval updateSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  nValue <- tRef.updateAndGet(_ + 20)\n} yield nValue).commit\n```\n\n----------------------------------------\n\nTITLE: Creating Sliding ZIO Queue in Scala\nDESCRIPTION: Creates a sliding ZIO Queue, which discards old items to make room when full. Requires zio._, with capacity 100. Returns a Queue[Int] ready for asynchronous use.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval slidingQueue: UIO[Queue[Int]] = Queue.sliding[Int](100)\\n\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO#retryWhile and ZIO#retryWhileZIO Signatures in Scala\nDESCRIPTION: Defines the signatures for `retryWhile` and `retryWhileZIO` methods on the ZIO trait. These methods retry a failed effect indefinitely as long as the error produced satisfies a given predicate (`f`). `retryWhile` uses a simple predicate, while `retryWhileZIO` uses an effectful predicate (`URIO`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def retryWhile(f: E => Boolean): ZIO[R, E, A]\n  def retryWhileZIO[R1 <: R](f: E => URIO[R1, Boolean]): ZIO[R1, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Exit Value Fails with Cause in Scala\nDESCRIPTION: Creates an assertion `Assertion[Exit[E, Any]]` that checks if a ZIO `Exit` value represents a failure. It requires the failure `Cause[E]` to satisfy the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfailsCause[E](assertion: Assertion[Cause[E]])\n```\n\n----------------------------------------\n\nTITLE: Thread-safe Counter Implementation\nDESCRIPTION: Improved implementation using atomic updateAndGet operation to prevent race conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef inc(counter: Ref[Int], amount: Int) = counter.updateAndGet(_ + amount)\n```\n\n----------------------------------------\n\nTITLE: Composable Timer Example with ZIO and Cats Effect 3.x (Scala)\nDESCRIPTION: This snippet integrates Cats Effect 3.0 typeclass instances with ZIO, using Async and Temporal to construct a composable timer application. The function catsEffectTimerApp performs time measurement and a sleep for demonstration, printing the difference. Dependencies required are cats.effect.Async, cats.effect.Clock, cats.effect.Temporal, and zio.interop.catz._. Inputs are the effect type and arguments; output is a ZIO or Cats IO app printing a measured time difference. Demonstrates generic programming with abstract effect types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.implicits._\nimport zio.interop.catz._\nimport scala.concurrent.duration.DurationInt\n\nobject ZioCatsEffectInterop extends zio.interop.catz.CatsApp {\n\n  def catsEffectTimerApp[F[_]: cats.effect.Async]: F[Unit] = for {\n    t2 <- cats.effect.Clock[F].monotonic\n    _  <- cats.effect.Temporal[F].sleep(2.seconds)\n    t1 <- cats.effect.Clock[F].monotonic\n    _  <- cats.effect.Sync[F].delay(println(t1 - t2))\n  } yield ()\n  \n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] = {\n    catsEffectTimerApp[zio.Task].exitCode\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fixed-Interval Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that recurs on a fixed interval, returning the number of repetitions so far.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval fixed = Schedule.fixed(10.seconds)\n```\n\n----------------------------------------\n\nTITLE: Defining foldTraceZIO with Trace Access in ZIO - Scala\nDESCRIPTION: Presents the foldTraceZIO definition, which enables handlers to access both the error and associated trace information on failure. This is useful for debugging and diagnostic purposes. The code requires ZIO and familiarity with ZIO's tracing infrastructure. Includes CanFail context bound to ensure the effect can fail.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def foldTraceZIO[R1 <: R, E2, B](\n    failure: ((E, Trace)) => ZIO[R1, E2, B],\n    success: A => ZIO[R1, E2, B]\n  )(implicit ev: CanFail[E]): ZIO[R1, E2, B]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Chunk from Collections in Scala\nDESCRIPTION: Creates Chunk instances from existing collections. The examples show creating Chunks from a List and an Array of integers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval fromIterableChunk: Chunk[Int] = Chunk.fromIterable(List(1, 2, 3))\n// fromIterableChunk: Chunk[Int] = IndexedSeq(1, 2, 3)\nval fromArrayChunk: Chunk[Int] = Chunk.fromArray(Array(1, 2, 3))\n// fromArrayChunk: Chunk[Int] = IndexedSeq(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Service Access Methods in Scala\nDESCRIPTION: Shows how to define service access methods using ZIO.serviceWithZIO for A and B services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject A {\n  def foo: ZIO[A, Nothing, String] = ZIO.serviceWithZIO[A](_.foo) \n}\n\nobject B {\n  def bar: ZIO[B, Nothing, Int] = ZIO.serviceWithZIO[B](_.bar)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring mapBoth in ZIO Trait - Scala\nDESCRIPTION: Adds the mapBoth method to the ZIO trait, allowing simultaneous transformation of both the error and the success channels. The function parameters f and g are applied to the error and success values respectively. Requires understanding of ZIO effect polymorphism and error/success typing. Useful for consistent effect transformation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def mapBoth[E2, B](f: E => E2, g: A => B): ZIO[R, E2, B]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Thread-Safe HashMap in Scala\nDESCRIPTION: Example showing inconsistent results when using mutable HashMap in concurrent operations, incrementing a value 100 times in parallel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/concurrentmap.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport scala.collection.mutable\n\nobject MainApp extends ZIOAppDefault {\n\n  def inc(ref: Ref[mutable.HashMap[String, Int]], key: String) =\n    for {\n      _ <- ref.get\n      _ <- ref.update { map =>\n        map.updateWith(key)(_.map(_ + 1))\n        map\n      }\n    } yield ()\n\n  def run =\n    for {\n      ref <- Ref.make(mutable.HashMap((\"foo\", 0)))\n      _ <- ZIO.foreachParDiscard(1 to 100)(_ => inc(ref, \"foo\"))\n      _ <- ref.get.map(_.get(\"foo\")).debug(\"The final value of foo is\")\n    } yield ()\n\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Names with Mutable Variables in Scala\nDESCRIPTION: A function using mutable variables to collect names from user input until a specific termination command is entered.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn._\n\ndef getNames: List[String] = {\n  def getName() = readLine(\"Please enter a name or 'q' to exit: \")\n  var names = List.empty[String]\n  var input = getName()\n  while (input != \"q\") {\n    names = names appended input\n    input = getName()\n  }\n  names\n} \n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Schema to SBT Dependencies\nDESCRIPTION: SBT dependency configuration for adding ZIO Schema to a Scala project. ZIO Schema is used for modeling data structure schemas as first-class values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-schema\" % \"0.0.6\"\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple TestAspects Example\nDESCRIPTION: Shows how to compose multiple test aspects for JVM-specific non-flaky testing with timeout.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest(\"a test with two aspects composed together\") {\n  ???\n} @@ jvm(nonFlaky) @@ timeout(60.seconds)\n```\n\n----------------------------------------\n\nTITLE: Handling Errors with Either in ZIO Scala\nDESCRIPTION: Demonstrates how to convert a failing ZIO effect into an Either type, effectively handling the error and preventing failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval error: Task[String] = ZIO.fail(new RuntimeException(\"Some Error\"))\nval errorEither: ZIO[Any, Nothing, Either[Throwable, String]] = error.either\n```\n\n----------------------------------------\n\nTITLE: Composing ZIO Effects with Multiple Service Dependencies in Scala\nDESCRIPTION: Shows how to compose ZIO effects that require multiple services, demonstrating type inference for the combined environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait ServiceA\ntrait ServiceB\ntrait ServiceC\n\n// Requires ServiceA and produces a value of type Int\ndef foo: ZIO[ServiceA, Nothing, Int] = ???\n\n// Requires ServiceB and ServiceC and produces a value of type String\ndef bar: ZIO[ServiceB & ServiceC, Throwable, String] = ???\n\n// Requires ServicB and produces a value of type Double\ndef baz(a: Int, b: String): ZIO[ServiceB, Nothing, Double] = ???\n\n// Requires ServiceA and ServiceB and ServiceC and produces a value of type Double\nval myApp: ZIO[ServiceA & ServiceB & ServiceC, Throwable, Double] =\n  for {\n    a <- foo\n    b <- bar\n    c <- baz(a, b)\n  } yield c\n```\n\n----------------------------------------\n\nTITLE: Configuring Sequential Test Execution in ZIO Test\nDESCRIPTION: Shows how to configure sequential test execution using TestAspect.sequential. Tests will be executed one after another in the order they are defined.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/execution-strategy.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\nsuite(\"Sequential\")(\n  test(\"A\")(Live.live(ZIO.attempt(\"Running Test A\").delay(1.second)).debug.map(_ => assertTrue(true))),\n  test(\"B\")(ZIO.attempt(\"Running Test B\").debug.map(_ => assertTrue(true))),\n  test(\"C\")(Live.live(ZIO.attempt(\"Running Test C\").delay(500.millis)).debug.map(_ => assertTrue(true)))\n) @@ TestAspect.sequential\n```\n\n----------------------------------------\n\nTITLE: Polling Promise State Without Suspension in ZIO (Scala)\nDESCRIPTION: This snippet shows how to use poll to check if a Promise has been completed without suspending the fiber. poll returns an Option-wrapped IO, representing the presence or absence of completion, with a second example using Option.get that will fail if not completed. Dependencies include ZIO core types. Key input is the Promise, output is a UIO[Option[IO[Exception, String]]] or IO with Option failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/promise.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nval ioPromise4: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\\nval ioIsItDone: UIO[Option[IO[Exception, String]]] = ioPromise4.flatMap(p => p.poll)\\nval ioIsItDone2: IO[Option[Nothing], IO[Exception, String]] = ioPromise4.flatMap(p => p.poll.get)\n```\n\n----------------------------------------\n\nTITLE: Converting Java Future to ZIO Fiber - Scala\nDESCRIPTION: This function transforms a Java Future into a ZIO Fiber in Scala using Fiber.fromFutureJava. This allows async results from Java code to be awaited or cancelled via ZIO fiber semantics. Dependencies are ZIO, Fiber, and Java Futures; output is a Fiber[Throwable, HttpResponse] suitable for advanced concurrency patterns.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-java.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef execute(client: HttpAsyncClient, request: HttpUriRequest): Fiber[Throwable, HttpResponse] =\n    Fiber.fromFutureJava {\n        client.execute(request, null)\n    }\n```\n\n----------------------------------------\n\nTITLE: Adding Tamer Dependencies in SBT for Different Data Sources\nDESCRIPTION: SBT dependency declarations for Tamer modules including database, OCI object storage, REST API, and S3 connectors. Each dependency corresponds to a different data source that Tamer can connect to.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tamer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-db\"                % \"0.16.1\"\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-oci-objectstorage\" % \"0.16.1\"\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-rest\"              % \"0.16.1\"\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-s3\"                % \"0.16.1\"\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO 1.x Runtime unsafeRun Method in Scala\nDESCRIPTION: This Scala snippet shows the signature of the `unsafeRun` method within the ZIO 1.x `Runtime` trait. This method was used to synchronously execute a ZIO effect and extract its result, potentially throwing exceptions or blocking indefinitely, breaking referential transparency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\ntrait Runtime[+R] {\n  def unsafeRun[E, A](zio: => ZIO[R, E, A]): A\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO acquireRelease Method Signature\nDESCRIPTION: Shows the method signature for ZIO's acquireRelease operation, which is used for managing resources and ensuring proper cleanup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/gracefully-shutdown-zio-application.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def acquireRelease[R, R1, E, A](\n      acquire: => ZIO[R, E, A]\n    )(\n      release: A => ZIO[R1, Nothing, Any]\n    ): ZIO[R with R1 with Scope, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Concurrent and Parallel Effect Generators\nDESCRIPTION: Generators for concurrent and parallel ZIO effects\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval random  : Gen[Any, UIO[Int]] = Gen.successes(Gen.int).flatMap(Gen.concurrent)\nval constant: Gen[Any, UIO[Int]]    = Gen.concurrent(ZIO(3))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval random: Gen[Any, UIO[String]] =\n    Gen.successes(Gen.string).flatMap(Gen.parallel)\n    \nval constant: Gen[Any, UIO[String]] =\n    Gen.parallel(ZIO(\"Hello\"))\n```\n\n----------------------------------------\n\nTITLE: Ordering Assertions for Iterables\nDESCRIPTION: Functions for testing ordering properties of Iterable collections.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_6\n\nLANGUAGE: Scala\nCODE:\n```\nisSorted[A](implicit ord: Ordering[A]): Assertion[Iterable[A]]\nisSortedReverse[A](implicit ord: Ordering[A]): Assertion[Iterable[A]]\n```\n\n----------------------------------------\n\nTITLE: Function Generator with Custom Hash\nDESCRIPTION: Function generator that allows custom hash function for equality comparison\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ndef functionWith[R, A, B](gen: Gen[R, B])(hash: A => Int): Gen[R, A => B]\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Diff Instance for Percentage Type in Scala\nDESCRIPTION: Demonstrates how to create a custom Diff instance for a domain-specific Percentage type by using contramap on an existing Diff[Double] instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/difference.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// somewhere defined in your domain package\ncase class Percentage(repr: Int)\n\nimplicit val diffPercentage: Diff[Percentage] = Diff[Double].contramap(_.repr)\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Instances of HttpApp for ZIO Shardcake\nDESCRIPTION: These bash commands run multiple instances of the HttpApp application using sbt, each with different port configurations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\nsbt -DHTTP_PORT=8081 -DPORT=8091 \"runMain HttpApp\"\nsbt -DHTTP_PORT=8082 -DPORT=8092 \"runMain HttpApp\"\nsbt -DHTTP_PORT=8083 -DPORT=8093 \"runMain HttpApp\"\n```\n\n----------------------------------------\n\nTITLE: Defining ZPool Trait in Scala\nDESCRIPTION: Core trait definition for ZPool showing the fundamental get and invalidate operations for resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zpool.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZPool[+Error, Item] {\n  def get: ZIO[Scope, Error, Item]\n  def invalidate(item: Item): UIO[Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Retaining Elements in a TMap with a Predicate in ZIO STM\nDESCRIPTION: Uses retainIf to keep only the key-value pairs that match a given predicate. In this example, only entries with even values are kept in the map.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval retainedEvenValues: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3), (\"d\", 4))\n  _    <- tMap.retainIf((_, v) => v % 2 == 0)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Chained Effect Examples\nDESCRIPTION: Examples of chained ZIO effects and their generators\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nval effect1 = ZIO(2).flatMap(x => ZIO(x * 2))\nval effect2 = ZIO(1) *> ZIO(2)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval chained : Gen[Any, ZIO[Any, Nothing, Int]] = \n    Gen.chained(Gen.successes(Gen.int))\n    \nval chainedN: Gen[Any, ZIO[Any, Nothing, Int]] = \n    Gen.chainedN(5)(Gen.successes(Gen.int))\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Test Aspect for Repeating Tests in Scala\nDESCRIPTION: This code snippet defines a custom test aspect called 'repeat5' that repeats a test 5 times. It's used to demonstrate the need for state restoration in repeated tests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/restoring-state-of-test-services.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef repeat5 =\n  new PerTest[Nothing, Any, Nothing, Any] {\n    override def perTest[R, E](test: ZIO[R, TestFailure[E], TestSuccess])(\n      implicit trace: Trace\n    ): ZIO[R, TestFailure[E], TestSuccess] =\n      test.repeatN(5)\n  }\n```\n\n----------------------------------------\n\nTITLE: Awaiting Fiber Completion with ZIO Fibers in Scala\nDESCRIPTION: Illustrates how to use Fiber#await to wait for a fiber to complete and inspect its Exit value. Requires ZIO. Forks an effect and then awaits the Exit status, yielding success, failure, or interruption info. Output is an Exit value rather than only the success case.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_concurrency.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nfor {\n  fiber <- IO.succeed(\"Hi!\").fork\n  exit  <- fiber.await\n} yield exit\n```\n\n----------------------------------------\n\nTITLE: Illustrating Flattened Tuple Type from Zipping in ZIO 2.x (Scala)\nDESCRIPTION: Shows the result of zipping the same `UIO` effects (`x1` through `x4`) using `<*>` in ZIO 2.x. The comment highlights the improved ergonomics: the resulting type is a flattened tuple `ZIO[Any, Nothing, (Int, String, Boolean)]`, and the `Unit` type from `x2` is automatically excluded from the final tuple.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval zipped = x1 <*> x2 <*> x3 <*> x4\n// zipped: ZIO[Any, Nothing, (Int, String, Boolean)] = ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Layer with Multiple AppConfig Instances in Scala\nDESCRIPTION: This snippet demonstrates how to create a ZLayer containing multiple instances of AppConfig, keyed by environment names.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(host: String, port: Int)\n\nobject AppConfig {\n  val layer: ULayer[Map[String, AppConfig]] =\n    ZLayer.succeedEnvironment(\n      ZEnvironment(\n        Map(\n          \"prod\" -> AppConfig(\"production.myapp\", 80),\n          \"dev\" -> AppConfig(\"development.myapp\", 8080)\n        )\n      )\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO#flatMapError Combinator in Scala\nDESCRIPTION: This snippet shows the signature of the ZIO#flatMapError combinator, which chains two effects based on the error channel of the first effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/chaining-effects-based-on-errors.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def flatMapError[R1 <: R, E2](\n    f: E => ZIO[R1, Nothing, E2]\n  ): ZIO[R1, E2, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Storage Service with Union Types for Errors in Scala\nDESCRIPTION: This snippet defines a Storage trait with upload, download, and delete operations. Each operation uses union types to specify multiple possible error types, allowing for more precise error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/union-types.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntype Name = String\n\nenum StorageError extends Exception {\n  case ObjectExist(name: Name)            extends StorageError\n  case ObjectNotExist(name: Name)         extends StorageError\n  case PermissionDenied(cause: String)    extends StorageError\n  case StorageLimitExceeded(limit: Int)   extends StorageError\n  case BandwidthLimitExceeded(limit: Int) extends StorageError\n}\n\nimport StorageError.*\n\ntrait Storage {\n  def upload(\n      name: Name,\n      obj: Array[Byte]\n  ): ZIO[Any, ObjectExist | StorageLimitExceeded, Unit]\n\n  def download(\n      name: Name\n  ): ZIO[Any, ObjectNotExist | BandwidthLimitExceeded, Array[Byte]]\n\n  def delete(name: Name): ZIO[Any, ObjectNotExist | PermissionDenied, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Using check Function for Property Testing in ZIO Test\nDESCRIPTION: Illustrates how to use the check function to test properties. It shows a general pattern and a specific example testing the commutativity of addition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/getting-started.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef property[T1, T2](input1: T1, input2: T2, ...): Boolean = ???\n\nval input1Gen: Gen[_, T1] = ???\nval input2Gen: Gen[_, T2] = ???\n\ncheck(input1Gen, input2Gen, ...) { (input1, input2, ...) =>\n  assertTrue(property(input1, input2, ...))   \n}\n```\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = ???\n\ntest(\"add is commutative\") {\n  check(Gen.int, Gen.int) { (a, b) =>\n    assertTrue(add(a, b) == add(b, a))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Acquiring Write Lock in Scala\nDESCRIPTION: Demonstrates acquiring a write lock and verifying the lock status using writeLocked and readLocked methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/treentrantlock.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval writeLockProgram: UIO[Boolean] =\n  (for {\n    lock <- TReentrantLock.make\n    _    <- lock.acquireWrite\n    wst  <- lock.writeLocked // lock is write-locked once transaction completes\n    rst  <- lock.readLocked  // lock is not read-locked\n  } yield !rst && wst).commit\n```\n\n----------------------------------------\n\nTITLE: Converting a TMap to a List of Tuples in ZIO STM\nDESCRIPTION: Converts a TMap to a List of key-value tuples using the toList method. This is useful for processing the map contents outside the transactional context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tMapTuplesList: UIO[List[(String, Int)]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  list <- tMap.toList\n} yield list).commit\n```\n\n----------------------------------------\n\nTITLE: Reading Names with Recursion in Scala\nDESCRIPTION: Refactoring the name collection function to use recursion instead of mutable variables, still using side-effectful I/O operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.io.StdIn._\n\ndef getNames: Seq[String] = {\n  def loop(names: List[String]): List[String] = {\n    val name = readLine(\"Please enter a name or 'q' to exit: \")\n    if (name == \"q\") names else loop(names appended name)\n  }\n  loop(List.empty[String])\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Implementation with Compare-and-Swap\nDESCRIPTION: Internal implementation of Ref's modify method using compare-and-swap for atomic operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfinal case class Ref[A](value: AtomicReference[A]) { self =>\n  def modify[B](f: A => (B, A)): UIO[B] = ZIO.succeed {\n    var loop = true\n    var b: B = null.asInstanceOf[B]\n    while (loop) {\n      val current = value.get\n      val tuple   = f(current)\n      b = tuple._1\n      loop = !value.compareAndSet(current, tuple._2)\n    }\n    b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Pulsar Dependency in SBT for Scala 3\nDESCRIPTION: This snippet shows how to add the ZIO Pulsar library as a dependency in a Scala 3 project's build.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-pulsar.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.github.jczuchnowski\" %% \"zio-pulsar\" % \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Dynamic-size Keyed Pool with Key-dependent Configuration\nDESCRIPTION: Method signature for creating a dynamic-sized ZKeyedPool where both the size range and time-to-live depend on the key. This allows for fine-grained control over how different keys manage their resources.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zkeyedpool.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n  def make[Key, Env: EnvironmentTag, Err, Item](\n    get: Key => ZIO[Env, Err, Item],\n    range: Key => Range,\n    timeToLive: Key => Duration\n  ): ZIO[Env with Scope, Nothing, ZKeyedPool[Err, Key, Item]] = ???\n```\n\n----------------------------------------\n\nTITLE: Simple On/Off Latch Example using CountdownLatch in Scala ZIO\nDESCRIPTION: Alternative implementation of the on/off latch using CountdownLatch instead of Promise.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/countdownlatch.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.concurrent._\n\nobject MainApp extends ZIOAppDefault {\n\n  def consume(queue: Queue[Int]): UIO[Nothing] =\n    queue.take\n      .flatMap(i => ZIO.debug(s\"consumed: $i\"))\n      .forever\n\n  def produce(queue: Queue[Int], latch: CountdownLatch): UIO[Nothing] =\n    (Random\n      .nextIntBounded(100)\n      .tap(i => queue.offer(i))\n      .tap(i => ZIO.when(i == 50)(latch.countDown)) *> ZIO.sleep(500.millis)).forever\n\n  def run =\n    for {\n      latch <- CountdownLatch.make(1)\n      queue <- Queue.unbounded[Int]\n      _     <- produce(queue, latch) <&> (latch.await *> consume(queue))\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Acquiring a Write Lock with TReentrantLock in Scala\nDESCRIPTION: Shows how to acquire a write lock that prevents other fibers from acquiring either read or write locks. The transaction returns the lock state after acquisition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval writeLockProgram: UIO[Boolean] =\n  (for {\n    lock <- TReentrantLock.make\n    _    <- lock.acquireWrite\n    wst  <- lock.writeLocked // lock is write-locked once transaction completes\n    rst  <- lock.readLocked  // lock is not read-locked\n  } yield !rst && wst).commit\n```\n\n----------------------------------------\n\nTITLE: Upgrading and Downgrading Locks with TReentrantLock in Scala\nDESCRIPTION: Shows how to upgrade from a read lock to a write lock and downgrade back. The transition is allowed when no other readers hold locks during the upgrade process.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval upgradeDowngradeProgram: UIO[(Boolean, Boolean, Boolean, Boolean)] = for {\n  lock               <- TReentrantLock.make.commit\n  _                  <- lock.acquireRead.commit\n  _                  <- lock.acquireWrite.commit  // upgrade\n  isWriteLocked      <- lock.writeLocked.commit   // now write-locked\n  isReadLocked       <- lock.readLocked.commit    // and read-locked\n  _                  <- lock.releaseWrite.commit  // downgrade\n  isWriteLockedAfter <- lock.writeLocked.commit   // no longer write-locked\n  isReadLockedAfter  <- lock.readLocked.commit    // still read-locked\n} yield (isWriteLocked, isReadLocked, isWriteLockedAfter, isReadLockedAfter)\n```\n\n----------------------------------------\n\nTITLE: Defining Sample UIO Effects for Zipping Examples (Scala)\nDESCRIPTION: Initializes four sample ZIO effects (`x1` to `x4`) using `ZIO.succeed(???)`. These effects have different success value types (`Int`, `Unit`, `String`, `Boolean`) but share the `UIO` type (no requirements, no failure). They serve as inputs for demonstrating changes in zipping behavior between ZIO 1.x and ZIO 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nval x1: UIO[Int]     = ZIO.succeed(???)\nval x2: UIO[Unit]    = ZIO.succeed(???)\nval x3: UIO[String]  = ZIO.succeed(???)\nval x4: UIO[Boolean] = ZIO.succeed(???)\n```\n\n----------------------------------------\n\nTITLE: Creating Chunk with Specified Values in Scala\nDESCRIPTION: Creates a Chunk with explicitly specified values. The example shows creating a Chunk containing integers 1, 2, and 3.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval specifiedValuesChunk = Chunk(1,2,3)\n// specifiedValuesChunk: Chunk[Int] = IndexedSeq(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Creating Empty TPriorityQueue in Scala ZIO\nDESCRIPTION: Demonstrates creating an empty TPriorityQueue using the default ordering for integers. The queue is created within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpriorityqueue.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval minQueue: STM[Nothing, TPriorityQueue[Int]] =\n  TPriorityQueue.empty\n```\n\n----------------------------------------\n\nTITLE: Converting Scala Future to ZIO Effect in Scala\nDESCRIPTION: This snippet defines a function that takes a function from ExecutionContext to Future and returns a ZIO effect representing the same computation. It leverages ZIO.fromFuture to encapsulate the Future, and demonstrates how to map the future's result and log success. Dependencies include an implicit ExecutionContext and ZIO library. The input is a function producing a Future, the output is a UIO of Task with the Future's result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-future.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ndef loggedFuture[A](future: ExecutionContext => Future[A]): UIO[Task[A]] = {\n  ZIO.fromFuture { implicit ec =>\n    future(ec).flatMap { result =>\n      Future(println(\"Future succeeded with \" + result)).map(_ => result)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Defects and Interruptions with ZIO Absorb in Scala\nDESCRIPTION: Illustrates how `ZIO#absorb` can convert both defects (created by `ZIO.dieMessage`) and interruptions (created by `ZIO.interrupt`) into `Throwable` failures. In this example, these failures are subsequently ignored, allowing the application to exit successfully.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/converting-defects-to-failures.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val effect1 =\n    ZIO.dieMessage(\"Boom!\") // ZIO[Any, Nothing, Nothing]\n      .absorb               // ZIO[Any, Throwable, Nothing]\n      .ignore\n  val effect2 =\n    ZIO.interrupt           // ZIO[Any, Nothing, Nothing]\n      .absorb               // ZIO[Any, Throwable, Nothing]\n      .ignore\n\n  def run =\n    (effect1 <*> effect2)\n      .debug(\"application exited successfully\")\n}\n```\n\n----------------------------------------\n\nTITLE: Submerging Failures with ZIO.absolve in Scala\nDESCRIPTION: This example illustrates converting an effect with an Either error/success result back into a standard effect using 'absolve'. It maps a double input into a sqrt if positive or a custom error if negative, then turns that into an IO effect. Dependencies include ZIO and Math, and input is a UIO[Double]. The output is an IO[String, Double] that fails on invalid input. This approach inverts the 'either' operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef sqrt(io: UIO[Double]): IO[String, Double] =\n  ZIO.absolve(\n    io.map(value =>\n      if (value < 0.0) Left(\"Value must be >= 0.0\")\n      else Right(Math.sqrt(value))\n    )\n  )\n```\n\n----------------------------------------\n\nTITLE: Using the `typeCheck` Macro for Compile-Time Checks in ZIO Test (Scala)\nDESCRIPTION: This example demonstrates using the `typeCheck` macro within `assertZIO` to verify that a given string of Scala code compiles successfully without actually running it. The macro returns an `Either[String, Unit]`, and the test asserts that the result `isRight`. The `@@ TestAspect.exceptScala212` annotation excludes this test on Scala 2.12 due to `LazyList` being introduced in 2.13.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.Assertion._\n\ntest(\"lazy list\") {\n  assertZIO(typeCheck(\n    \"\"\"\n      |val lazyList: LazyList[Int] = LazyList(1, 2, 3, 4, 5)\n      |lazyList.foreach(println)\n      |\"\"\".stripMargin))(isRight)\n\n} @@ TestAspect.exceptScala212\n```\n\n----------------------------------------\n\nTITLE: Database Integration with Doobie and ZIO\nDESCRIPTION: Example showing how to integrate Doobie with ZIO for database operations using tamer library. Includes setup for JSON encoding/decoding and database query configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport tamer._\nimport tamer.db._\n\nimport doobie.implicits.legacy.instant._\nimport doobie.syntax.string._\nimport zio._\nimport zio.duration._\nimport zio.json._\n\nimport java.time.Instant\n\ncase class Row(id: String, name: String, description: Option[String], modifiedAt: Instant)\n    extends tamer.db.Timestamped(modifiedAt)\n\nobject Row {\n  implicit val rowJsonCodec = DeriveJsonCodec.gen[Row]\n}\n\nobject DatabaseSimple extends zio.App {\n  implicit val stateKeyJsonCodec = DeriveJsonCodec.gen[tamer.Tamer.StateKey]\n  implicit val windowJsonCodec = DeriveJsonCodec.gen[tamer.db.Window]\n\n  val program: RIO[ZEnv, Unit] = tamer.db.DbSetup\n    .tumbling(window =>\n      sql\"\"\"SELECT id, name, description, modified_at \n           |FROM users \n           |WHERE modified_at > ${window.from} AND modified_at <= ${window.to}\"\"\".stripMargin\n        .query[Row]\n    )(\n      recordKey = (_, v) => v.id,\n      from = Instant.parse(\"2020-01-01T00:00:00.00Z\"),\n      tumblingStep = 5.days\n    )\n    .runWith(dbLayerFromEnvironment ++ tamer.kafkaConfigFromEnvironment)\n\n  override final def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    program.exitCode\n\n  implicit lazy val stateKeyCodec: Codec[Tamer.StateKey] = Codec.optionalZioJsonCodec\n  implicit lazy val windowCodec: Codec[tamer.db.Window] = Codec.optionalZioJsonCodec\n  implicit lazy val stringCodec: Codec[String] = Codec.optionalZioJsonCodec\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Blocking Service in Scala\nDESCRIPTION: This example creates a custom BlockingService that doesn't respect Thread#interrupt but provides its own cancellation mechanism through an atomic flag. It demonstrates how some blocking operations may swallow InterruptedException.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/blocking.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.concurrent.atomic.AtomicReference\nfinal case class BlockingService() {\n  private val released = new AtomicReference(false)\n\n  def start(): Unit = {\n    while (!released.get()) {\n      println(\"Doing some blocking operation\")\n      try Thread.sleep(1000)\n      catch {\n        case _: InterruptedException => () // Swallowing InterruptedException\n      }\n    }\n    println(\"Blocking operation closed.\")\n  }\n\n  def close(): Unit = {\n    println(\"Releasing resources and ready to be closed.\")\n    released.getAndSet(true)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting IO to Monix Coeval - Scala Extension Method\nDESCRIPTION: Provides an extension method for ZIO IO to convert it into a Monix Coeval, resulting in a UIO effect. Requires the interop-monix module. Produces a UIO that, when run, produces a Monix Coeval encapsulating the original computation. Useful for cases where lazy or synchronous evaluation is desired.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-monix.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ndef toCoeval: UIO[eval.Coeval[A]]\n```\n\n----------------------------------------\n\nTITLE: Generating Mock Layers with @mockable Annotation (Scala)\nDESCRIPTION: Illustrates using @mockable[A] to annotate an object for automatic generation of capability tags and a mock layer, supporting test-driven development. Requires zio-test.mock.mockable, the base Service trait, and enables the creation of fully mockable service modules for testing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.mock.mockable\n\n@mockable[AccountObserver.Service]\nobject AccountObserverMock\n```\n\n----------------------------------------\n\nTITLE: Service Implementations\nDESCRIPTION: Implementation of live Logging service and mock Email service\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ncase class LoggingLive() extends Logging {\n  override def log(line: String): UIO[Unit] =\n    ZIO.effectTotal(print(line))\n}\n\ncase class EmailMock() extends Email {\n  override def send(user: String, content: String): Task[Unit] =\n    ZIO.effect(println(s\"sending email to $user\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using ZIO 2.x Unsafe Operations with Scala 3\nDESCRIPTION: This Scala snippet demonstrates the concise syntax for performing unsafe operations in ZIO 2.x using Scala 3's implicit function types. The `Unsafe.unsafely` block automatically provides the required `Unsafe` capability to the enclosed scope, allowing direct calls to methods like `runtime.unsafe.run`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nUnsafe.unsafely {\n  Runtime.default.unsafe.run(Console.printLine(\"Hello, World!\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Simple On/Off Latch Example using Promise in Scala ZIO\nDESCRIPTION: Implementation of a simple on/off latch using Promise, demonstrating producer-consumer pattern with a condition trigger.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/countdownlatch.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  def consume(queue: Queue[Int]): UIO[Nothing] =\n    queue.take\n      .flatMap(i => ZIO.debug(s\"consumed: $i\"))\n      .forever\n\n  def produce(queue: Queue[Int], latch: Promise[Nothing, Unit]): UIO[Nothing] =\n    (Random\n      .nextIntBounded(100)\n      .tap(i => queue.offer(i))\n      .tap(i => ZIO.when(i == 50)(latch.succeed(()))) *> ZIO.sleep(500.millis)).forever\n\n  def run =\n    for {\n      latch <- Promise.make[Nothing, Unit]\n      queue <- Queue.unbounded[Int]\n      _     <- produce(queue, latch) <&> (latch.await *> consume(queue))\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Robust Long-Running Application using ZManaged and raceAll\nDESCRIPTION: This snippet shows a more robust approach to implement a long-running application using ZManaged and raceAll. This ensures that if any component fails, all other components are properly shut down.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nval managedApp = for {\n  kafka <- kafkaConsumer.runDrain.forkManaged\n  http  <- httpServer.forkManaged\n  jobs  <- scheduledJobRunner.forkManaged\n} yield ZIO.raceAll(kafka.await, List(http.await, jobs.await))\n\nval mainApp = managedApp.use(identity).exitCode\n```\n\n----------------------------------------\n\nTITLE: Executing Asynchronous Unsafe Operation in ZIO 2.x (Scala)\nDESCRIPTION: This Scala code shows the ZIO 2.x equivalent for asynchronous unsafe execution. It uses `Unsafe.unsafe` to provide the capability, then `Runtime.default.unsafe.fork` to start the effect asynchronously, obtaining a `Fiber.Runtime`. Finally, `fiber.unsafe.addObserver` attaches the callback function to handle the result upon completion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 2.x\nimport zio._\n\nUnsafe.unsafe { implicit unsafe =>\n  Runtime.default.unsafe\n    .fork(\n      Console\n        .printLine(\"After 3 seconds I will return 5\")\n        .delay(3.second)\n        .as(5)\n    )\n    .unsafe\n    .addObserver(\n      _.fold(\n        e => println(s\"Failure: $e\"),\n        v => println(s\"Success: $v\")\n      )\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Interpreting the Console ADT into Real Effects in Scala\nDESCRIPTION: Implements an interpreter function, interpret, which recursively evaluates a Console program by pattern matching and executing side effects: println for output, StdIn.readLine for input, and direct value computation for Return. The function accepts a Console[A] and produces the resulting value of type A, translating the pure model into actual effectful operations. This bridges the gap between the pure ADT and the real world.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/background.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\ndef interpret[A](program: Console[A]): A = program match {\n  case Return(value) => \n    value()\n  case PrintLine(line, next) => \n    println(line)\n    interpret(next)\n  case ReadLine(next) =>\n    interpret(next(scala.io.StdIn.readLine()))\n}\n```\n\n----------------------------------------\n\nTITLE: Executing ZIO 1.x Workflow Unsafely in Scala\nDESCRIPTION: This Scala code demonstrates how to use `Runtime.default.unsafeRun` in ZIO 1.x to execute a `zioWorkflow` and pass its result to a hypothetical `legacyApplication`. This pattern is common when integrating ZIO code with existing non-functional codebases.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp {\n  val zioWorkflow: ZIO[Any, Nothing, Int] = ???\n  \n  def legacyApplication(input: Int): Unit = ???\n  \n  def zioApplication: Int = \n    Runtime.default.unsafeRun(zioWorkflow)\n  \n\n  def main(args: Array[String]): Unit = {\n    legacyApplication(zioApplication)\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fiber from Java CompletionStage - Scala\nDESCRIPTION: This snippet converts a Java CompletionStage into a synthetic ZIO Fiber in Scala using Fiber.fromCompletionStage. It allows interacting with Java futures as lightweight ZIO concurrency constructs. Dependencies are ZIO (Fiber) and Java\\'s CompletionStage. The function takes a by-name CompletionStage and returns a Fiber without identity, encapsulating asynchronous Java work into ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-java.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef stageToFiber[A](stage: => CompletionStage[A]): Fiber[Throwable, A] = \n  Fiber.fromCompletionStage(future)\n```\n\n----------------------------------------\n\nTITLE: Creating a Frequency Metric Instance in ZIO (Scala)\nDESCRIPTION: This snippet shows how to instantiate a Frequency metric called 'MySet' using ZIO's Metric.frequency method. The resulting freq variable is ready to be applied for tracking frequencies of String values. This requires the zio.metrics._ import for access to the Metric class. No additional dependencies beyond ZIO core and metrics modules are needed, and freq can be used as a tag for effectful operations that yield String results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/frequency.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.metrics._\n\nval freq = Metric.frequency(\"MySet\")\n```\n\n----------------------------------------\n\nTITLE: Supervising ZIO Effect with Supervisor\nDESCRIPTION: Demonstrates how to supervise a ZIO effect using the supervised method with a supervisor instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/supervisor.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval supervised = supervisor.flatMap(s => fib(20).supervised(s))\n```\n\n----------------------------------------\n\nTITLE: FiberRef Await Operation\nDESCRIPTION: Shows how await differs from join by not merging FiberRef values back to the parent fiber.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  child <- fiberRef.set(6).fork\n  _ <- child.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5)\n```\n\n----------------------------------------\n\nTITLE: Converting Twitter Future to ZIO Task in Scala\nDESCRIPTION: This Scala code demonstrates converting a Twitter `Future` to a ZIO `Task` using `Task.fromTwitterFuture`. It defines a simple ZIO application (`Example`) that interacts with the console, calls a function (`greet`) returning a Twitter `Future`, converts this future to a ZIO `Task`, and prints the result. Dependencies include `zio`, `zio.console`, `zio.interop.twitter`, and `com.twitter.util.Future`. The `greet` function simulates an asynchronous operation returning a Twitter `Future` containing a personalized greeting.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-twitter.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.twitter.util.Future\nimport zio.{ App, Task }\nimport zio.console._\nimport zio.interop.twitter._\n\nobject Example extends App {\n  def run(args: List[String]) = {\n    val program =\n      for {\n        _        <- putStrLn(\"Hello! What is your name?\")\n        name     <- getStrLn\n        greeting <- Task.fromTwitterFuture(Task(greet(name)))\n        _        <- putStrLn(greeting)\n      } yield ()\n\n    program.exitCode\n  }\n\n  private def greet(name: String): Future[String] = Future.value(s\"Hello, $name!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Reading File Contents Using Traditional Scala Approach\nDESCRIPTION: This snippet demonstrates reading a file into a string, splitting it into lines, and printing each line using traditional Scala methods. However, this approach may fail for very large files that exceed available memory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nfor (line <- FileUtils.readFileToString(new File(\"file.txt\")).split('\\n'))\n  println(line)\n```\n\n----------------------------------------\n\nTITLE: Exposing ZStream Errors as Either Values (Scala)\nDESCRIPTION: Demonstrates using ZStream#either to expose stream errors as Either values in the output stream. This converts errors into data that can be processed within the stream pipeline.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_76\n\nLANGUAGE: scala\nCODE:\n```\nval inputs: ZStream[Console, Nothing, Either[IOException, String]] = \n  ZStream.fromEffect(zio.console.getStrLn).either\n```\n\n----------------------------------------\n\nTITLE: Modifying Sized Generator Size in ZIO Test (Scala)\nDESCRIPTION: This code snippet demonstrates how to use the 'size' test aspect to change the default size of a sized generator in ZIO Test. It generates small lists of alphanumeric characters and verifies that the size is set to 50. The test is configured to run 5 samples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/sized.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\ntest(\"generating small list of characters\") {\n  check(Gen.small(Gen.listOfN(_)(Gen.alphaNumericChar))) { n =>\n    ZIO.attempt(n).debug *> Sized.size.map(s => assertTrue(s == 50))\n  }\n} @@ TestAspect.size(50) @@ TestAspect.samples(5)\n```\n\n----------------------------------------\n\nTITLE: Creating Assertion for Sequence Element in Scala\nDESCRIPTION: Demonstrates how to create an assertion to check the fourth element of a Vector[Int] using hasAt and equalTo assertions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest(\"Fourth value is equal to 5\") {\n  assert(xs)(hasAt(3)(equalTo(5)))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Committing TRef\nDESCRIPTION: Creates a TRef and immediately commits the transaction, returning a UIO effect that resolves to the reference. This allows you to store and pass the reference.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval commitTRef: UIO[TRef[Int]] = TRef.makeCommit(10)\n```\n\n----------------------------------------\n\nTITLE: Effectfully Transforming Entries in a TMap in ZIO STM\nDESCRIPTION: Uses transformSTM to apply an effectful function to every entry in the TMap. This allows transformations that might need to perform additional STM operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformSTMTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  _    <- tMap.transformSTM((k, v) => STM.succeed(k -> v * v))\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Taking All Elements from TQueue in Scala ZIO\nDESCRIPTION: Retrieves and removes all elements from a TQueue in a single transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueTakeAll: UIO[List[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](4)\n  _      <- tQueue.offerAll(List(1, 2))\n  res    <- tQueue.takeAll\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: ZIO 1.x App Implementation\nDESCRIPTION: Example showing how applications were implemented in ZIO 1.x using the App trait.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.App\nimport zio.Console._\n\nobject MyApp extends zio.App {\n  def run(args: List[String]) = \n    startMyApp(args).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Command Enum with Scala\nDESCRIPTION: This Scala enum defines the domain commands which the counter entity can handle: Inc (increment) and Dec (decrement). These enums are central to command handling and interpreted as triggers for state transitions driven by events. No dependencies are needed, but the enum is integral to the command routing logic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nenum Command {\n  case Inc, Dec\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing CyclicBarrier\nDESCRIPTION: Demonstrates basic construction of a CyclicBarrier and checking its initial state. Creates a barrier for 100 parties and verifies it's not broken and has no waiting parties.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/cyclicbarrier.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.CyclicBarrier\n\nfor {\n  barrier  <- CyclicBarrier.make(100)\n  isBroken <- barrier.isBroken  \n  waiting  <- barrier.waiting\n} yield assert(!isBroken && waiting == 0)\n```\n\n----------------------------------------\n\nTITLE: Conceptual Representation of ZIO Effect in Scala\nDESCRIPTION: This snippet illustrates a conceptual representation of a ZIO effect as a function. While not precise, it helps understand the basic structure of ZIO effects, showing how they take an environment R and produce either a failure E or a success A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/summary.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nR => Either[E, A]\n```\n\n----------------------------------------\n\nTITLE: Asserting String Matches Regex in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if a `String` matches the provided regular expression `regex`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nmatchesRegex(regex: String)\n```\n\n----------------------------------------\n\nTITLE: Using attemptBlockingCancelable with Custom Service\nDESCRIPTION: Example of using attemptBlockingCancelable to properly handle cancellation of a custom blocking service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval myApp =\n  for {\n    service <- ZIO.attempt(BlockingService())\n    fiber   <- ZIO.attemptBlockingCancelable(\n      effect = service.start()\n    )(\n      cancel = ZIO.succeed(service.close())\n    ).fork\n    _       <- fiber.interrupt.schedule(\n      Schedule.delayed(\n        Schedule.duration(3.seconds)\n      )\n    )\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Converting a TSet to a List in Scala ZIO STM\nDESCRIPTION: Converts the elements of a TSet to a List using the toList method within an STM transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSetToList: UIO[List[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  list <- tSet.toList\n} yield list).commit\n```\n\n----------------------------------------\n\nTITLE: Testing Console Output with ZIO Test and TestConsole\nDESCRIPTION: This snippet demonstrates how to test a function that uses the Console service in ZIO. It uses the TestConsole service to capture and assert on the output of the sayHello function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/spec.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.Assertion._\n\nimport java.io.IOException\n\ndef sayHello: ZIO[Any, IOException, Unit] =\n  Console.printLine(\"Hello, World!\")\n\nsuite(\"HelloWorldSpec\")(\n  test(\"sayHello correctly displays output\") {\n    for {\n      _      <- sayHello\n      output <- TestConsole.output\n    } yield assertTrue(output == Vector(\"Hello, World!\\n\"))\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Creating an Identity Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that always decides to continue, recurring forever without any delay. It consumes input and emits the same as output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval identity = Schedule.identity[Int]\n```\n\n----------------------------------------\n\nTITLE: Database Access Layer API Functions for ZIO Query\nDESCRIPTION: Defines two example functions that would be used with ZIO Query: one to get all user IDs and another to get a username by ID. These represent the typical database access methods that ZIO Query would optimize.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\ndef getAllUserIds: ZIO[Any, Nothing, List[Int]] = {\n  // Get all user IDs e.g. SELECT id FROM users\n  ZIO.succeed(???)\n}\n\ndef getUserNameById(id: Int): ZIO[Any, Nothing, String] = {\n  // Get user by ID e.g. SELECT name FROM users WHERE id = $id\n  ZIO.succeed(???)\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Batching with Fixed Schedule in Scala\nDESCRIPTION: This example shows a time-capped batching strategy that collects up to 2000 elements but emits after 30 seconds even if fewer elements are collected. This approach provides a basic balance between throughput and latency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_61\n\nLANGUAGE: scala\nCODE:\n```\ndataStream.aggregateAsyncWithin(\n   ZTransducer.collectAllN(2000),\n   Schedule.fixed(30.seconds)\n )\n```\n\n----------------------------------------\n\nTITLE: Defining a File API and Resource Management with Cats Effect (Scala)\nDESCRIPTION: This snippet defines a File type parameterized over an effect type F with Sync constraint, supporting read and close operations, and an open factory method returning an effect of File instantiation. It uses Cats Effect syntax and demonstrates how to structure resource creation and management supporting effectful functional programming. Required dependencies include cats.effect.Sync and cats.syntax.apply._. Input is a filename (String), output is a File[F] instance or read data. The code is designed to be used in a managed resource context and assumes a concrete effect type providing Sync.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\ncase class File[F[_]: cats.effect.Sync]() {\n  import cats.syntax.apply._\n  def read: F[String] =\n    cats.effect.Sync[F].delay(println(\"Reading file.\")) *>\n      cats.effect.Sync[F].pure(\"Hello, World!\")\n  def close: F[Unit]  =\n    cats.effect.Sync[F].delay(println(\"Closing file.\"))\n}\n\nobject File {\n  import cats.syntax.apply._\n  def open[F[_]: cats.effect.Sync](name: String): F[File[F]] =\n    cats.effect.Sync[F].delay(println(s\"opening $name file\")) *>\n      cats.effect.Sync[F].delay(File())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Reloadable Service Class in Scala\nDESCRIPTION: Implements the Reloadable class that wraps services with reloading capabilities. Provides get and reload operations for managing service lifecycle.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ncase class Reloadable[Service](scopedRef: ScopedRef[Service], reload: IO[Any, Unit]) {\n  def get: UIO[Service] = scopedRef.get\n  def reloadFork: UIO[Unit] = reload.ignoreLogged.forkDaemon.unit\n}\n```\n\n----------------------------------------\n\nTITLE: Providing Combined Service to Application in Scala ZIO\nDESCRIPTION: Demonstrates providing a combined service implementation to a ZIO application. This shows the manual approach to dependency injection without Has.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval mainApp: IO[Nothing, Unit] = myApp.provide(LoggingWithRandomIntLive)\n```\n\n----------------------------------------\n\nTITLE: Generating Random Elements from a Set in Scala with ZIO Test\nDESCRIPTION: Demonstrates how to create a generator that randomly selects elements from a predefined set of values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport java.time._\n\nGen.elements(\n  DayOfWeek.MONDAY,\n  DayOfWeek.TUESDAY,\n  DayOfWeek.WEDNESDAY,\n  DayOfWeek.THURSDAY,\n  DayOfWeek.FRIDAY,\n  DayOfWeek.SATURDAY,\n  DayOfWeek.SUNDAY\n).runCollectN(3).debug\n// Sample Output: List(WEDNESDAY, THURSDAY, SUNDAY)\n```\n\n----------------------------------------\n\nTITLE: Manually Generating ZIO Dependency Graph\nDESCRIPTION: Shows how to manually create a dependency graph for a ZIO application with multiple services including UserRepo, DocumentRepo, Database, BlobStorage, and Cache. The example demonstrates vertical and horizontal layer composition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/examples.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n\n  val layers: ZLayer[Any, Any, DocumentRepo with UserRepo] =\n    (BlobStorageLive.layer ++ InmemoryCache.layer ++ DatabaseLive.layer) >>>\n      (DocumentRepoLive.layer >+> UserRepoLive.layer)\n\n  def run = myApp.provideLayer(layers)\n}\n```\n\n----------------------------------------\n\nTITLE: Dropping Elements from a Chunk in Scala\nDESCRIPTION: Shows how to drop a specified number of elements from the beginning of a Chunk.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nChunk(\"Sarah\", \"Bob\", \"Jane\").drop(1)\n```\n\n----------------------------------------\n\nTITLE: Defining Gauge Metric with ZIO Metric API in Scala\nDESCRIPTION: This snippet demonstrates the definition of a gauge metric using the ZIO metrics API. It provides a method to create a Gauge of type Double with a given name, supporting tracking of numeric point-in-time metrics. There are no external dependencies apart from the ZIO metrics module; the function signature shows intended extensibility. The key parameter is the metric name as a String. The snippet is abstract (\"???\") and meant to illustrate API structure, not concrete implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/gauge.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Metric {\n  def gauge(name: String): Gauge[Double] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application with Automatic Layer Construction\nDESCRIPTION: Shows how to run a ZIO application using automatic layer construction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(A.layer, B.layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Using collectWhile with Numeric Condition in Scala\nDESCRIPTION: Demonstrates using collectWhile with a numeric condition. This example collects elements as long as they are greater than or equal to 2.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nChunk(9, 2, 5, 1, 6).collectWhile { case element if element >= 2 => true }\n// res4: Chunk[Boolean] = IndexedSeq(true, true, true)\n```\n\n----------------------------------------\n\nTITLE: Transforming Elements of a TSet in Scala ZIO STM\nDESCRIPTION: Transforms each element in a TSet by applying a function (squaring each value in this example). This is a destructive operation that modifies the original collection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformTSet: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  _    <- tSet.transform(a => a * a)\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: Building Complex Mock Environments with Combined Expectations\nDESCRIPTION: Demonstrates how to create a mock environment with multiple sequential expectations. This example shows a complete interaction flow for the AccountObserver service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nval event = new AccountEvent {}\nval app: URIO[AccountObserver, Unit] = AccountObserver.processEvent(event)\nval mockEnv: ULayer[Console] = (\n  MockConsole.PutStrLn(equalTo(s\"Got $event\"), unit) ++\n  MockConsole.GetStrLn(value(\"42\")) ++\n  MockConsole.PutStrLn(equalTo(\"You entered: 42\"))\n)\n```\n\n----------------------------------------\n\nTITLE: Automatic TSemaphore Permit Management in Scala ZIO\nDESCRIPTION: Shows how to use withPermit for automatic permit management when executing an STM action.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tsemaphore.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreWithPermit: STM[Nothing, Unit] = for {\n  sem <- TSemaphore.make(1L)\n  a   <- sem.withPermit(yourSTMAction)\n} yield a\n\ntSemaphoreWithPermit.commit\n```\n\n----------------------------------------\n\nTITLE: Non-interruptible Blocking Operation in Scala ZIO\nDESCRIPTION: This example demonstrates that using effectBlocking alone doesn't make the operation interruptible. Even after attempting to interrupt the fiber, the blocking operation continues to run until the JVM stops.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/blocking.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  _ <- putStrLn(\"Starting a blocking operation\")\n  fiber <- effectBlocking {\n    while (true) {\n      Thread.sleep(1000)\n      println(\"Doing some blocking operation\")\n    }\n  }.ensuring(\n    putStrLn(\"End of a blocking operation\").orDie\n  ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(1.seconds)\n    )\n  )\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Multiple FiberRef Join Behavior\nDESCRIPTION: Demonstrates how multiple child fibers' FiberRef values are merged when joining with parent fiber.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiberRef <- FiberRef.make(5)\n  child1 <- fiberRef.set(6).fork\n  child2 <- fiberRef.set(7).fork\n  _ <- child2.join\n  _ <- child1.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n```\n\n----------------------------------------\n\nTITLE: Getting TQueue Size in Scala ZIO\nDESCRIPTION: Retrieves the current number of elements in a TQueue within a transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueSize: UIO[Int] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offerAll(List(1, 2))\n  size   <- tQueue.size\n} yield size).commit\n```\n\n----------------------------------------\n\nTITLE: Creating ZSink from Hub in Scala\nDESCRIPTION: Defines a method to create a ZSink that publishes values to a specified Hub. This allows for easy integration of Hubs into sink-based workflows.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nobject ZSink {\n  def fromHub[I](\n    hub: Hub[I]\n  ): ZSink[Any, Nothing, I, Nothing, Unit] =\n    ???\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZIO 2.x Layer-based DSL for Contextual Environments in Scala\nDESCRIPTION: Example of using ZIO 2.x layers to create a DSL-like syntax for managing contextual environments.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_59\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait Connection\n\nval dbTransaction: ZLayer[Any, Throwable, Connection] = ZLayer.succeed(???)\nval effect: ZIO[Connection, Throwable, Unit] = ZIO.succeed(???)\n\nval result: ZIO[Any, Throwable, Unit] =\n  dbTransaction {\n    effect\n  }\n```\n\n----------------------------------------\n\nTITLE: Creating a SubscriptionRef Object with Constructor Method\nDESCRIPTION: The SubscriptionRef companion object with a make constructor that creates a new SubscriptionRef with a specified initial value. The implementation is not shown (indicated by ???).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/subscriptionref.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject SubscriptionRef {\n  def make[A](a: A): UIO[SubscriptionRef[A]] =\n    ???\n}\n```\n\n----------------------------------------\n\nTITLE: Example Prometheus Output for a ZIO Timer Histogram Metric\nDESCRIPTION: Shows sample output in Prometheus text format for the 'timer' histogram metric created in the previous Scala example. It displays cumulative counts for each bucket (`timer_bucket` with `le` label for upper bound), the total sum of observed durations (`timer_sum`), the total count of observations (`timer_count`), the minimum observed duration (`timer_min`), and the maximum observed duration (`timer_max`). Timestamps are included for each metric line.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/histogram.md#2025-04-23_snippet_4\n\nLANGUAGE: csv\nCODE:\n```\n# TYPE timer histogram\n# HELP timer\ntimer_bucket{time_unit=\"millis\",le=\"1.0\",} 6.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"2.0\",} 16.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"3.0\",} 27.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"4.0\",} 41.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"5.0\",} 49.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"6.0\",} 60.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"7.0\",} 70.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"8.0\",} 85.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"9.0\",} 99.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"10.0\",} 99.0 1686581577320\ntimer_bucket{time_unit=\"millis\",le=\"+Inf\",} 100.0 1686581577320\n\ntimer_sum{time_unit=\"millis\",} 603.0 1686581577320\ntimer_count{time_unit=\"millis\",} 100.0 1686581577320\ntimer_min{time_unit=\"millis\",} 1.0 1686581577320\ntimer_max{time_unit=\"millis\",} 66.0 1686581577320\n```\n\n----------------------------------------\n\nTITLE: Defining Akka Actor Type in Scala\nDESCRIPTION: A type definition showing how Akka actors are modeled as a partial function from Any to Unit, illustrating their untyped nature which makes composition difficult.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Actor = PartialFunction[Any, Unit]\n```\n\n----------------------------------------\n\nTITLE: ZStream Creation from Option Effects in Scala\nDESCRIPTION: Shows how to create ZStreams from effects that may or may not produce values using fromEffectOption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nobject ZStream {\n  def fromEffectOption[R, E, A](fa: ZIO[R, Option[E], A]): ZStream[R, E, A] = ???\n}\n```\n\nLANGUAGE: scala\nCODE:\n```\nval userInput: ZStream[Console, IOException, String] = \n  ZStream.fromEffectOption(\n    zio.console.getStrLn.mapError(Option(_)).flatMap {\n      case \"EOF\" => ZIO.fail[Option[IOException]](None)\n      case o     => ZIO.succeed(o)\n    }\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Service Helper Accessors in Scala\nDESCRIPTION: This snippet defines helper functions (`lookup`, `update`) within an object `db` to simplify accessing the `Database` service capabilities from the ZIO environment. These helpers use `ZIO.accessM` to call the corresponding methods on the `Database.Service` obtained from the environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nobject db {\n  def lookup(id: UserID): RIO[Database, UserProfile] =\n    ZIO.accessM(_.database.lookup(id))\n\n  def update(id: UserID, profile: UserProfile): RIO[Database, Unit] =\n    ZIO.accessM(_.database.update(id, profile))\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Custom Assertions in ZIO Test with Scala\nDESCRIPTION: This snippet defines a sealed trait Book with three case classes (Novel, Comic, Textbook) and creates a custom assertion named subject using CustomAssertion.make. The custom assertion extracts the subject from the Textbook case class or returns an error message otherwise. It then demonstrates usage in a ZIO test suite where the assertion checks the subject value for a given Book instance. Dependencies include zio.test._, and the relevant context is that the code operates within ZIO Test to enable custom domain-specific assertions for test validation. Inputs are Book instances, and the custom assertion returns the subject string if present, or fails otherwise. All code should be placed within a ZIO test project with the required library imports.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.test._\\n\\n// Define the sealed trait and case classes\\nsealed trait Book\\ncase class Novel(pageCount: Int) extends Book\\ncase class Comic(illustrations: Int) extends Book\\ncase class Textbook(subject: String) extends Book\\n\\n// Custom assertion for Book\\nval subject =\\n  CustomAssertion.make[Book] {\\n    case Textbook(subject) => Right(subject)\\n    case other => Left(s\\\"Expected $other to be Textbook\\\")\\n  }\\n\\n// Usage\\nsuite(\\\"custom assertions\\\")(\\n  test(\\\"subject assertion\\\") {\\n    val book: Option[Book] = Some(Textbook(\\\"Mathematics\\\"))\\n    assertTrue(book.is(_.some.custom(subject)) == \\\"Mathematics\\\")\\n  }\\n)\\n\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query for Filtering Employees by Role\nDESCRIPTION: Example GraphQL query to retrieve all employees with the SoftwareDeveloper role, showing the name and role fields in the response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/caliban.md#2025-04-23_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery{\n  employees(role: SoftwareDeveloper){\n    name\n    role\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO.die Constructor - ZIO API - Scala\nDESCRIPTION: Defines the ZIO.die method, which produces an effect that results in a 'defect' (an untyped, unrecoverable error) by accepting a Throwable. This static method is part of the ZIO object and returns an effect that cannot succeed or fail in the normal sense. Requires ZIO library dependency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nobject ZIO {\n  def die(t: => Throwable): ZIO[Any, Nothing, Nothing]\n}\n```\n\n----------------------------------------\n\nTITLE: Awaiting ZIO Promises in Scala\nDESCRIPTION: Shows how to create a ZIO Promise and await its completion, suspending the fiber until the Promise is completed with a value or an error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/promise.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval ioPromise3: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\nval ioGet: IO[Exception, String] = ioPromise3.flatMap(promise => promise.await)\n```\n\n----------------------------------------\n\nTITLE: Testing Exit Values with TestLens in Scala\nDESCRIPTION: Demonstrates how to use TestLens operators to test Exit values in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.Exit\nimport zio.test._\n\ntest(\"TestLens#success\") {\n  val sut: Exit[Error, Int] = Exit.succeed(42)\n  assertTrue(sut.is(_.success) == 42)\n}\n\ncase class Error(errorMessage: String)\n\ntest(\"TestLens#failure\") {\n  val sut: Exit[Error, Int] = Exit.fail(Error(\"Boom!\"))\n  assertTrue(sut.is(_.failure).errorMessage == \"Boom!\")\n}\n\ntest(\"TestLens#die\") {\n  val sut: Exit[Error, Int] = Exit.die(new RuntimeException(\"Boom!\"))\n  assertTrue(sut.is(_.die).getMessage == \"Boom!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Map Has Key in Scala\nDESCRIPTION: Creates an assertion `Assertion[Map[K, V]]` that checks if a `Map` contains a specific key `K`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nhasKey[K, V](key: K)\n```\n\n----------------------------------------\n\nTITLE: Converting Cats Effect Resource to ZManaged\nDESCRIPTION: Example of converting a Cats Effect Resource to ZIO's ZManaged using the toManaged extension method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nval resource: zio.ZManaged[Any, Throwable, File[zio.Task]] =\n  fileResource[zio.Task](\"log.txt\").toManaged\n```\n\n----------------------------------------\n\nTITLE: Defining Service Traits in Scala ZIO\nDESCRIPTION: Declaration of service trait interfaces for Logging and RandomInt services. These traits define the contract that implementations must satisfy.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait Logging {\n  def log(line: String): UIO[Unit]\n}\n\ntrait RandomInt {\n  def random: UIO[Int]\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering DocCardList Component in JSX\nDESCRIPTION: A JSX code snippet that imports and renders the DocCardList component, which likely displays a list of documentation cards for ZIO libraries.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/officials/index.md#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n <DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Publishing Docker Image to Remote Registry (Bash)\nDESCRIPTION: Commands to set environment variables and publish the Docker image to a remote registry using sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ export DOCKER_USERNAME=<username>  // e.g: johndoe\n$ export DOCKER_REGISTRY=<registry>  // e.g: docker.io\n$ sbt -Ddocker.username=$NAMESPACE -Ddocker.registry=$DOCKER_REGISTRY docker:publish\n```\n\n----------------------------------------\n\nTITLE: Refining Error Type with ZIO#refineToOrDie - Scala\nDESCRIPTION: Shows the use of refineToOrDie to narrow the error type of a ZIO effect (here, to IOException) from the more general Throwable. Useful for precise error processing and letting unexpected errors propagate fatally. Requires java.io.IOException.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\n\nval getStrLn2: IO[IOException, String] =\n  ZIO.effect(StdIn.readLine()).refineToOrDie[IOException]\n```\n\n----------------------------------------\n\nTITLE: Adding Doobie Dependencies for TranzactIO in Scala SBT\nDESCRIPTION: This snippet demonstrates how to add Doobie core and H2 database dependencies to a Scala project using SBT. These are required for Doobie integration with TranzactIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tranzactio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.tpolecat\" %% \"doobie-core\" % \"0.13.4\"\nlibraryDependencies += \"org.tpolecat\" %% \"doobie-h2\"   % \"0.13.4\"\n```\n\n----------------------------------------\n\nTITLE: Converting Reactive Streams Publisher to ZIO Stream in Scala\nDESCRIPTION: Demonstrates converting a Reactive Streams `Publisher` to a ZIO `Stream` using the `toStream` extension method provided by `zio.interop.reactivestreams`. The `qSize` parameter controls the internal buffer size (default 16). The resulting stream is then executed using the ZIO runtime to collect all emitted elements into a list via `Sink.collectAll`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-reactive-streams.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval streamFromPublisher = publisher.toStream(qSize = 16)\nruntime.unsafeRun(\n  streamFromPublisher.run(Sink.collectAll[Integer])\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Ordinary Values with assertTrue in Scala\nDESCRIPTION: Demonstrates how to use the assertTrue method to assert simple ordinary values in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"sum\"){\n  assertTrue(1 + 1 == 2)\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple FiberRef Configuration Example\nDESCRIPTION: Shows how to manage multiple configuration values using separate FiberRefs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Main extends ZIOAppDefault {\n  val retries: FiberRef[Int] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(3)\n    }\n\n  def run =\n    for {\n      _ <- ZIO.unit\n      f1 = retries.set(10).debug(\"set 10\").delay(2.seconds)\n      f2 = retries.set(5).debug(\"set 5\")\n      _ <- f1 <&> f2\n      _ <- retries.get.debug(\"final retries value\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Service Dependency Mapping with ZLayer (Scala)\nDESCRIPTION: Presents a simple, type-conceptual mapping for illustrating how ZLayer can combine or transform dependencies. No functional code or explicit dependencies, intended to explain the role of ZLayer in expressing service requirements and outputs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zlayer.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n(Socket, Persistence) => Database\n```\n\n----------------------------------------\n\nTITLE: Virtual Coin Flip with ZIO IfZIO\nDESCRIPTION: Shows how to use ZIO's ifZIO operator to create a simple virtual coin flip function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport java.io.IOException\nimport zio._\n\ndef flipTheCoin: ZIO[Any, IOException, Unit] =\n  ZIO.ifZIO(Random.nextBoolean)(\n    onTrue = Console.printLine(\"Head\"),\n    onFalse = Console.printLine(\"Tail\")\n  )\n```\n\n----------------------------------------\n\nTITLE: Converting Twitter Future to ZIO Task in Scala\nDESCRIPTION: This example demonstrates how to use the interop-twitter module to convert Twitter's Future into ZIO Task. It creates a simple interactive greeting application that reads a name from the console, processes it using a Twitter Future, and prints the result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-twitter.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport com.twitter.util.Future\nimport zio.{ App, Task }\nimport zio.Console._\nimport zio.interop.twitter._\n\nobject Example extends App {\n  def run(args: List[String]) = {\n    val program =\n      for {\n        _        <- printLine(\"Hello! What is your name?\")\n        name     <- readLine\n        greeting <- Task.fromTwitterFuture(Task(greet(name)))\n        _        <- printLine(greeting)\n      } yield ()\n\n    program.exitCode\n  }\n\n  private def greet(name: String): Future[String] = Future.value(s\"Hello, $name!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Doobie Transactor for Cats Effect 3\nDESCRIPTION: Implementation of a custom HikariCP transactor for Doobie with Cats Effect 3, using the new Dispatcher pattern instead of Blocker.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nimport doobie.hikari.HikariTransactor\nimport zio.interop.catz._\nimport zio.{Task, ZIO, ZManaged}\n\nimplicit val zioRuntime: zio.Runtime[Any] =\n  zio.Runtime.default\n\nimplicit val dispatcher: cats.effect.std.Dispatcher[zio.Task] =\n  zioRuntime\n    .unsafeRun(\n      cats.effect.std\n        .Dispatcher[zio.Task]\n        .allocated\n    )\n    ._1\n\ndef transactor: ZManaged[Any, Throwable, HikariTransactor[Task]] =\n  for {\n    rt <- ZIO.runtime[Any].toManaged\n    xa <-\n      HikariTransactor\n        .newHikariTransactor[Task](\n          \"org.h2.Driver\",                             \n          \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\",        \n          \"sa\",                                        \n          \"\",                                         \n          rt.runtimeConfig.executor.asExecutionContext \n        )\n        .toManaged\n  } yield xa\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Fiber to Future\nDESCRIPTION: Shows how to convert a ZIO Fiber into a Scala Future using the toFuture method on Fiber.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-future.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef fiberToFuture[A](fiber: Fiber[Throwable, A]): UIO[Future[A]] = \n  fiber.toFuture\n```\n\n----------------------------------------\n\nTITLE: Polling a TPromise for Completion Status\nDESCRIPTION: Retrieves the result from a TPromise if it has been completed, or None if it hasn't been completed yet. This allows checking the state without blocking.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpromise.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseOptionValue: UIO[Option[Either[String, Int]]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.succeed(0).commit\n  res      <- tPromise.poll.commit\n} yield res\n```\n\n----------------------------------------\n\nTITLE: Non-Deterministic Random Generator Example in Scala\nDESCRIPTION: This code shows how to use the TestAspect.nondeterministic to change the default deterministic behavior of random generators to non-deterministic.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/how-generators-work.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.TestAspect._\n\nobject ExampleSpec extends ZIOSpecDefault {\n  def spec =\n    test(\"example test\") {\n      check(Gen.int(0, 10)) { n =>\n        println(n)\n        assertTrue(n + n == 2 * n)\n      }\n    } @@ samples(5) @@ nondeterministic\n}\n```\n\n----------------------------------------\n\nTITLE: Wrapping Synchronous Side Effect with ZIO.effectTotal - Scala\nDESCRIPTION: Illustrates wrapping a synchronous, total (exception-free) side effectcalling System.currentTimeMillis()in a ZIO effect. This ensures the side effect is only executed when needed, integrates with the ZIO runtime, and avoids unintended eager evaluation. Only safe functions should be wrapped this way. Returns the current timestamp as a Long when effect is run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval now = ZIO.effectTotal(System.currentTimeMillis())\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Dependencies to build.sbt\nDESCRIPTION: Scala build file configuration to add ZIO, ZIO Streams, ZIO Kafka, and ZIO JSON dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += Seq(\n  \"dev.zio\" %% \"zio\"         % \"2.1.15\",\n  \"dev.zio\" %% \"zio-streams\" % \"2.1.15\",\n  \"dev.zio\" %% \"zio-kafka\"   % \"2.10.0\",\n  \"dev.zio\" %% \"zio-json\"    % \"0.7.16\"\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Service Trait in Scala\nDESCRIPTION: Example of a BlobStorage service trait definition with get and put methods that return ZIO values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/accessor-methods.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ntrait BlobStorage {\n  def get(id: String): ZIO[Any, Throwable, Array[Byte]]\n\n  def put(content: Array[Byte]): ZIO[Any, Throwable, String]\n}\n```\n\n----------------------------------------\n\nTITLE: Example of ZIO and Monix Coeval Interoperability in Scala\nDESCRIPTION: This example demonstrates converting between ZIO IO and Monix Coeval in both directions, including running the computations and printing results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-monix.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport monix.eval.Coeval\nimport zio.{ IO, Runtime }\nimport zio.interop.monix._\n\nobject UnsafeExample extends App {\n\n  val runtime = Runtime.default\n\n  def main(args: Array[String]): Unit = {\n    val io1 = IO.succeed(10)\n    val c1  = runtime.unsafeRun(io1.toCoeval) \n\n    println(s\"IO to coeval result is ${c1.value}\")\n\n    val c2  = Coeval(10)\n    val io2 = IO.fromCoeval(c2).map(r => s\"Coeval to IO result is $r\")\n\n    println(runtime.unsafeRun(io2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: File Transfer Using ZIO Scope\nDESCRIPTION: Implementation of file transfer using ZIO's Scope for composable resource management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(from: String, to: String): ZIO[Any, Throwable, Unit] = {\n  val resource = for {\n    from <- ZIO.acquireRelease(is(from))(close)\n    to   <- ZIO.acquireRelease(os(to))(close)\n  } yield (from, to)\n\n  ZIO.scoped {\n    resource.flatMap { case (in, out) =>\n      copy(in, out)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Log Level-Specific Functions in ZIO\nDESCRIPTION: Example showing how to use specific logging functions in ZIO for different log levels, which is an alternative to using the ZIO.logLevel combinator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_90\n\nLANGUAGE: scala\nCODE:\n```\nZIO.logError(\"File does not exist: ~/var/www/favicon.ico\")\n```\n\n----------------------------------------\n\nTITLE: Exporting HTTP Request Duration Metrics for Prometheus in ZIO\nDESCRIPTION: This snippet shows the Prometheus-formatted output for HTTP request duration metrics. It includes histogram buckets, sum, count, min, and max values for both POST and GET requests to the '/users' endpoint. The metrics are broken down by method, path, and status code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_7\n\nLANGUAGE: prometheus\nCODE:\n```\n# HELP http_request_duration_seconds\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.005\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.01\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.025\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.05\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.075\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.1\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.25\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.5\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"0.75\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"1.0\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"2.5\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"5.0\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"7.5\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"10.0\",} 2.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"POST\",path=\"/users\",status=\"200\",le=\"+Inf\",} 2.0 1714503503829\n\nhttp_request_duration_seconds_sum{method=\"POST\",path=\"/users\",status=\"200\",} 0.100570365 1714503503829\nhttp_request_duration_seconds_count{method=\"POST\",path=\"/users\",status=\"200\",} 2.0 1714503503829\nhttp_request_duration_seconds_min{method=\"POST\",path=\"/users\",status=\"200\",} 0.00120463 1714503503829\nhttp_request_duration_seconds_max{method=\"POST\",path=\"/users\",status=\"200\",} 0.099365735 1714503503829\n# TYPE http_request_duration_seconds histogram\n# HELP http_request_duration_seconds\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.005\",} 0.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.01\",} 0.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.025\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.05\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.075\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.1\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.25\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.5\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"0.75\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"1.0\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"2.5\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"5.0\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"7.5\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"10.0\",} 1.0 1714503503829\nhttp_request_duration_seconds_bucket{method=\"GET\",path=\"/users\",status=\"200\",le=\"+Inf\",} 1.0 1714503503829\n\nhttp_request_duration_seconds_sum{method=\"GET\",path=\"/users\",status=\"200\",} 0.017157212 1714503503829\nhttp_request_duration_seconds_count{method=\"GET\",path=\"/users\",status=\"200\",} 1.0 1714503503829\nhttp_request_duration_seconds_min{method=\"GET\",path=\"/users\",status=\"200\",} 0.017157212 1714503503829\nhttp_request_duration_seconds_max{method=\"GET\",path=\"/users\",status=\"200\",} 0.017157212 1714503503829\n```\n\n----------------------------------------\n\nTITLE: Removing Has Data Type in ZIO 2.x Layer Definitions\nDESCRIPTION: Update layer definitions to remove the Has data type wrapper for services in ZIO 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval userRepo: ZLayer[Logging with Random with Database, Throwable, UserRepo] = ???\n```\n\n----------------------------------------\n\nTITLE: Reservation Type Definition\nDESCRIPTION: Definition of the Reservation data type used in makeReserve constructor.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nfinal case class Reservation[-R, +E, +A](acquire: ZIO[R, E, A], release: Exit[Any, Any] => URIO[R, Any])\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Query in SBT\nDESCRIPTION: Adds the ZIO Query library dependency to a Scala project's build.sbt file. ZIO Query provides functionality for writing optimized queries to data sources with batching, pipelining, and caching capabilities.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-query\" % \"0.2.9\"\n```\n\n----------------------------------------\n\nTITLE: Pulling and Merging Changes from Upstream Master with Git - Bash\nDESCRIPTION: Illustrates fetching changes from the official ZIO repository's master branch and merging them with the local copy. This helps resolve conflicts and keep the local branch up to date. SSH access to upstream is required.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit pull git@github.com:zio/zio.git master\n```\n\n----------------------------------------\n\nTITLE: Selective Defect Recovery with catchSomeCause in ZIO Streams (Scala)\nDESCRIPTION: Demonstrates ZStream#catchSomeCause for recovering from specific causes of failure based on pattern matching. This allows handling of specific types of defects while letting others propagate.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_72\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3) ++ ZStream.dieMessage(\"Oh! Boom!\") ++ ZStream(4, 5)\nval s2 = ZStream(7, 8, 9)\nval stream = s1.catchSomeCause { case Die(value) => s2 }\n```\n\n----------------------------------------\n\nTITLE: Squashing Git Commits for ZIO Pull Request\nDESCRIPTION: This bash snippet demonstrates how to squash the last 5 commits in a Git repository before pushing the final version of code for a ZIO pull request. It uses git reset, commit, and force push commands.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ngit reset --soft HEAD~5\ngit commit -am \"add feature X\"\ngit push --force\n```\n\n----------------------------------------\n\nTITLE: Implementing Streaming with Akka Streams\nDESCRIPTION: Demonstrates how to use Akka Streams to create a streaming pipeline that generates factorials and writes them to a file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.ActorSystem\nimport akka.stream.scaladsl._\nimport akka.util.ByteString\n\nimport java.nio.file.Paths\nimport scala.concurrent._\n\nobject AkkaStreamApp extends App {\n  implicit val system: ActorSystem = ActorSystem(\"stream\")\n  implicit val ec: ExecutionContextExecutor = system.dispatcher\n\n  val source = Source(1 to 100)\n  val factorial = Flow[Int].scan(BigInt(1))((acc, next) => acc * next)\n  val serialize = Flow[BigInt].map(num => ByteString(s\"$num\\n\"))\n  val sink = FileIO.toPath(Paths.get(\"factorials.txt\"))\n\n  source\n    .via(factorial)\n    .via(serialize)\n    .runWith(sink)\n    .onComplete(_ => system.terminate())\n}\n```\n\n----------------------------------------\n\nTITLE: Using Timer instance with Cats Effect 2.x\nDESCRIPTION: Example of using the cats.effect.Timer with ZIO, requiring an additional import for the implicit Timer instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.concurrent.TimeUnit\n\nimport cats.implicits._\nimport zio.interop.catz._\nimport zio.interop.catz.implicits._ // Provides `zio.Task instance` for `cats.effect.Time` type class\nimport zio.{ ExitCode, Task, URIO }\n\nimport scala.concurrent.duration.DurationInt\n\nobject ZioCatsEffectTimerInterop extends zio.interop.catz.CatsApp {\n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] =\n    catsEffectTimerApp[zio.Task].exitCode\n\n  def catsEffectTimerApp[F[_]: cats.effect.Clock: cats.effect.Timer: cats.effect.Sync]: F[Unit] = for {\n    t2 <- cats.effect.Clock[F].monotonic(TimeUnit.SECONDS)\n    _  <- cats.effect.Timer[F].sleep(2.seconds)\n    t1 <- cats.effect.Clock[F].monotonic(TimeUnit.SECONDS)\n    _  <- cats.effect.Sync[F].delay(println(t1 - t2))\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sink Type Alias in Scala ZIO\nDESCRIPTION: This code snippet defines the `Sink` type as an alias for `ZSink[Any, E, A, L, B]`. This represents a sink that doesn't require any specific environment, can fail with error type E, consumes elements of type A, leaves leftovers of type L, and produces a result of type B.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/sink.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Sink[+E, A, +L, +B] = ZSink[Any, E, A, L, B]\n```\n\n----------------------------------------\n\nTITLE: Asserting String is Empty in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if a `String` is empty (\"\").\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nisEmptyString\n```\n\n----------------------------------------\n\nTITLE: Multiple Child Fibers Join Operation\nDESCRIPTION: Shows how multiple child fibers interact when joining their parent, with the last joined fiber's value taking precedence.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make(5)\n  child1 <- fiberRef.set(6).fork\n  child2 <- fiberRef.set(7).fork\n  _ <- child2.join\n  _ <- child1.join\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 6)\n```\n\n----------------------------------------\n\nTITLE: Mapping Monix/Cats Effect Data Structures to ZIO in Scala\nDESCRIPTION: This reference table maps popular concurrency and effect data structures from Monix and Cats Effect to their ZIO analogs for Scala users. It clarifies the new types developers should use post-migration while maintaining original semantics. No external code or computation is involved; the table serves as a type-mapping summary.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/migrate/from-monix.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\n| Monix / Cats Effect | ZIO |\n|-------|-----|\n| `Deferred` | `Promise` |\n| `Fiber` | `Fiber` |\n| `MVar` | `Queue` |\n| `Ref` | `Ref` |\n| `Resource` | `ZManaged` |\n| `Semaphore` | `Semaphore` |\n| `TaskApp` | `App` |\n| `TaskLocal` | `FiberRef` |\n| `Task` | `Task` |\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Messages to Assertions in Scala\nDESCRIPTION: Shows how to add custom messages to assertions using the ?? operator in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nassertTrue(1 + 1 == 3) ?? \"1 + 1 should be equal to 2\"\n```\n\n----------------------------------------\n\nTITLE: Using collectWhile on a Chunk in Scala\nDESCRIPTION: Shows how to collect elements until a condition is no longer met using collectWhile.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nChunk(\"Sarah\", \"Bob\", \"Jane\").collectWhile { case element if element != \"Bob\" => true }\n```\n\n----------------------------------------\n\nTITLE: Log Output for Sequential Errors with Ensuring (Log)\nDESCRIPTION: This log output shows the result of running the `ensuring` example. It displays the initial failure (\"Oh uh!\") from the main effect. Crucially, it also shows the defect (\"Boom!\") from the finalizer, indicating it as a suppressed exception, highlighting how ZIO tracks sequential errors in resource-safe operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n```scala\ntimestamp=2022-03-09T08:30:56.563179230Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.String: Oh uh!\\n\\tat <empty>.MainApp.run(MainApp.scala:4)\\n\\tSuppressed: java.lang.RuntimeException: Boom!\\n\\t\\tat <empty>.MainApp.run(MainApp.scala:4)\"\n```\n```\n\n----------------------------------------\n\nTITLE: Creating and Completing Promises in ZIO (Scala)\nDESCRIPTION: This snippet demonstrates multiple ways of completing a ZIO Promise, including succeed, fail, complete, completeWith, done, die, halt, and interrupt, and shows how fibers can be synchronized using these actions. It requires ZIO as a dependency, leveraging core effect types (Promise, IO, Exit, Cause). The key parameters include the error type E and the success type A for the Promise. Inputs are impure effects and various completion methods, and the output is an IO effect representing the result of awaiting the Promise. The example shows forking, effect composition, and Promise completion semantics.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/promise.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\\n\\nval race: IO[String, Int] = for {\\n    p     <- Promise.make[String, Int]\\n    _     <- p.succeed(1).fork\\n    _     <- p.complete(ZIO.succeed(2)).fork\\n    _     <- p.completeWith(ZIO.succeed(3)).fork\\n    _     <- p.done(Exit.succeed(4)).fork\\n    _     <- p.fail(\"5\")\\n    _     <- p.halt(Cause.die(new Error(\"6\")))\\n    _     <- p.die(new Error(\"7\"))\\n    _     <- p.interrupt.fork\\n    value <- p.await\\n  } yield value\n```\n\n----------------------------------------\n\nTITLE: Manually providing Runtime for Cats Effect interop\nDESCRIPTION: Example showing how to manually create and provide a ZIO Runtime for Cats Effect interoperability, with a simple Sync effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.implicits._\nimport zio.interop.catz._\n\nobject ZioCatsEffectInterop extends scala.App {\n  def catsEffectApp[F[_]: cats.effect.Sync]: F[Unit] =\n    cats.effect.Sync[F].delay(\n        println(\"Hello from Cats Effect World!\")\n      )\n      \n  implicit val runtime: zio.Runtime[Any] = zio.Runtime.default\n\n  val zioApp: zio.Task[Unit] = catsEffectApp[zio.Task]\n  runtime.unsafeRun(zioApp.exitCode)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Scala Project Dependencies for Logging\nDESCRIPTION: This snippet shows how to add dependencies for ZIO Logging and ZIO JSON in a Scala sbt build. These dependencies are required for structured and typed log annotation functionality demonstrated in subsequent code examples. Inputs: none. Outputs: enhances sbt configuration for typed logging support.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\\n  \\\"dev.zio\\\" %% \\\"zio-logging\\\" % \\\"@ZIO_CONFIG_VERSION@\\\",\\n  \\\"dev.zio\\\" %% \\\"zio-json\\\"    % \\\"@ZIO_JSON_VERSION@\\\"\\n)\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Test Specifications in Scala\nDESCRIPTION: This code snippet shows how to write ZIO test specifications using ZIOSpecDefault. It includes two test cases: one that passes and one that fails, demonstrating the basic structure of ZIO tests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/running-our-first-zio-project-with-intellij-idea.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nobject ExampleSpec extends ZIOSpecDefault {\n  def spec =\n    suite(\"spec\")(\n      test(\"test1\") {\n        assertTrue(true)\n      },\n      test(\"test2\") {\n        assertTrue(false)\n      }\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Case Classes for Assertion Examples in Scala\nDESCRIPTION: These case class definitions (`Address` and `User`) provide the data structures used in the subsequent ZIO Test example demonstrating field-level assertions. `User` contains basic information and embeds an `Address` object.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.Assertion.{isRight, isSome,equalTo, isGreaterThanEqualTo, not, hasField}\n\nfinal case class Address(country:String, city:String)\nfinal case class User(name:String, age:Int, address: Address)\n```\n\n----------------------------------------\n\nTITLE: Basic ZIO Effect Examples in Scala\nDESCRIPTION: Demonstrates basic ZIO effects showing different value types and failure scenarios. Shows how ZIO effects always produce exactly one value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval failedEffect: ZIO[Any, String, Nothing]       = ZIO.fail(\"fail!\")\nval oneIntValue : ZIO[Any, Nothing, Int]          = ZIO.succeed(3)\nval oneListValue: ZIO[Any, Nothing, List[Int]]    = ZIO.succeed(List(1, 2, 3))\nval oneOption   : ZIO[Any, Nothing , Option[Int]] = ZIO.succeed(None)\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty TArray in ZIO STM (Scala)\nDESCRIPTION: Creates an empty TArray instance that can store Integer values. This operation returns an STM effect that will create the array when executed within a transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval emptyTArray: STM[Nothing, TArray[Int]] = TArray.empty[Int]\n```\n\n----------------------------------------\n\nTITLE: Structuring ZIO Tests with For-Comprehension and `assert` (Scala)\nDESCRIPTION: This snippet shows a common and readable way to structure ZIO tests. A for-comprehension is used to sequence ZIO effects (creating and updating a `Ref`, getting its value). The final `yield` statement returns the result of an `assert` call, comparing the retrieved value `v`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"updating ref\") {\n  for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield assert(v)(Assertion.equalTo(v))\n} \n```\n\n----------------------------------------\n\nTITLE: Defining Foo and Bar Services in ZIO 1.x\nDESCRIPTION: Example of defining Foo and Bar services using Service Pattern 1.0 in ZIO 1.x. It shows the use of Has[_] data type and trait Service for service definitions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_60\n\nLANGUAGE: scala\nCODE:\n```\n// ZIO 1.x\nobject foo {\n  type Foo = Has[Foo.Service]\n\n  object Foo {\n    trait Service {\n      def foo: UIO[String]\n    }\n  }\n}\n\nobject bar {\n  type Bar = Has[Bar.Service]\n\n  object Bar {\n    trait Service {\n      def bar: UIO[String]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Exit/Cause/Throwable Assertions\nDESCRIPTION: Assertions for testing error handling and exit conditions in ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\ncontainsCause[E](cause: Cause[E]): Assertion[Cause[E]]\ndies(assertion: Assertion[Throwable]): Assertion[Exit[Any, Any]]\nfailsCause[E](assertion: Assertion[Cause[E]]): Assertion[Exit[E, Any]]\nhasMessage(message: Assertion[String]): Assertion[Throwable]\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Assertion Using TestArrow in Scala\nDESCRIPTION: Demonstrates the internal implementation of a complex nested assertion using TestArrow compositions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.Assertion\n\ndef isRight[A]: TestArrow[Either[Any, A], A] =\n  TestArrow.fromFunction(_.toOption.get)\n\ndef isSome[A]: TestArrow[Option[A], A] =\n  TestArrow.fromFunction(_.get)\n\ndef equalTo[A, B](expected: B): TestArrow[B, Boolean] =\n  TestArrow.fromFunction((actual: B) => actual == expected)\n\nval assertion: Assertion[Either[Any, Option[Int]]] = {\n  val arrow: TestArrow[Either[Any, Option[Int]], Boolean] =\n    isRight >>>        // Either[Any, Option[Int]] => Option[Int]\n      isSome[Int] >>>  // Option[Int] => Int\n      equalTo(5)       // Int => Boolean\n  Assertion(arrow)\n}\n```\n\n----------------------------------------\n\nTITLE: FiberRef InheritAll Example\nDESCRIPTION: Demonstrates how to inherit all FiberRef values from an existing fiber using inheritAll.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  fiberRef <- FiberRef.make[Int](0)\n  latch    <- Promise.make[Nothing, Unit]\n  fiber    <- (fiberRef.set(10) *> latch.succeed(())).fork\n  _        <- latch.await\n  _        <- fiber.inheritAll\n  v        <- fiberRef.get\n} yield v == 10\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote and Fetching Tags for ZIO\nDESCRIPTION: Commands to add the original ZIO repository as a remote upstream and fetch tags needed for project versioning. This ensures you can sync with the main project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add upstream git@github.com:zio/zio.git\ngit fetch --tags upstream\n```\n\n----------------------------------------\n\nTITLE: Collecting String Elements from Mixed Chunk in Scala\nDESCRIPTION: Uses the collect method to filter and transform elements of a Chunk. This example extracts only String elements from a Chunk containing mixed types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval collectChunk = Chunk(\"Hello ZIO\", 1.5, \"Hello ZIO NIO\", 2.0, \"Some string\", 2.5)\n// collectChunk: Chunk[Any] = IndexedSeq(\n//   \"Hello ZIO\",\n//   1.5,\n//   \"Hello ZIO NIO\",\n//   2.0,\n//   \"Some string\",\n//   2.5\n// )\n\ncollectChunk.collect { case string: String => string }\n// res1: Chunk[String] = IndexedSeq(\n//   \"Hello ZIO\",\n//   \"Hello ZIO NIO\",\n//   \"Some string\"\n// )\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Image Publishing (Scala)\nDESCRIPTION: SBT configuration to set up Docker username and repository for publishing to a remote registry in the build.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndockerUsername := sys.props.get(\"docker.username\")\ndockerRepository := sys.props.get(\"docker.registry\")\n```\n\n----------------------------------------\n\nTITLE: Combining ZEnvironments in Scala\nDESCRIPTION: This snippet shows how to combine two or more ZEnvironments using the union or ++ operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval app: ZEnvironment[AppConfig] =\n  ZEnvironment.empty ++ ZEnvironment(AppConfig(\"localhost\", 8080))\n```\n\n----------------------------------------\n\nTITLE: Implementing Incorrect Reverse Function in Scala\nDESCRIPTION: This snippet shows an incorrect implementation of a reverse function in Scala. The function incorrectly drops the last element for lists longer than 6 elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/shrinking.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef reverse[T](list: List[T]): List[T] =\n  if (list.length > 6) list.reverse.dropRight(1) else list.reverse\n```\n\n----------------------------------------\n\nTITLE: Adding and Retrieving Services in ZEnvironment in Scala\nDESCRIPTION: This snippet demonstrates how to add a service to a ZEnvironment and retrieve it using the get method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class AppConfig(host: String, port: Int)\n\nval app: ZEnvironment[AppConfig] =\n  ZEnvironment.empty.add(AppConfig(\"localhost\", 8080))\n\nval appConfig: AppConfig = app.get[AppConfig]\n```\n\n----------------------------------------\n\nTITLE: Scoped Runtime Configuration Example in Scala\nDESCRIPTION: Demonstrates how runtime configurations inherit workflow context and logging settings in ZIO 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val workflow1 = ZIO.debug(\"workflow1 is running\") *> ZIO.log(\"This line will never get logged\")\n  val workflow2 = ZIO.debug(\"workflow2 is running\") *> ZIO.log(\"This line will get logged\")\n  val workflow3 = ZIO.debug(\"workflow3 is running\") *> ZIO.log(\"This line will never get logged\")\n\n  def run =\n    ZIO.provideLayer(Runtime.removeDefaultLoggers) {\n      ZIO.runtime[Any].flatMap(_.run(workflow1)) *>\n        ZIO.provideLayer(Runtime.addLogger(Runtime.defaultLoggers.head)) {\n          ZIO.runtime[Any].flatMap(_.run(workflow2))\n        } *> workflow3\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Resource to Scoped ZIO (Scala)\nDESCRIPTION: Demonstrates the use of the toScoped extension to convert a Cats Effect Resource into a ZIO effect within a Scope environment. This enables resource-safe, effectful computations using ZIO with Cats-style resource acquisition and release. Dependencies include zio.Task, cats.effect.Resource, and the interop-cats bridge. Input is a resource constructor and resource name, and the output is a ZIO effect acquiring a File within a scope. Proper error handling and cleanup are handled by the scope machinery.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nval scoped: ZIO[Scope, Throwable, File[zio.Task]] =\n  fileResource[zio.Task](\"log.txt\").toScoped\n```\n\n----------------------------------------\n\nTITLE: Modifying Schedule Delays\nDESCRIPTION: Shows how to modify the delay between schedule recurrences using delayed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nval boosted = Schedule.spaced(1.second).delayed(_ => 100.milliseconds)\n```\n\n----------------------------------------\n\nTITLE: Asserting Numeric Approximate Equality with approximatelyEquals - ZIO Test - Scala\nDESCRIPTION: Illustrates using Assertion.hasAt and Assertion.approximatelyEquals to check whether a sequence element is numerically close to a reference value within a given tolerance. The snippet tests if the fourth value in the vector xs is approximately 5 (with a tolerance of 2), using ZIO Test's test and assert mechanisms. Dependencies: ZIO Test framework and an implicit Numeric for the sequence type. Outputs a ZSpec describing this numeric proximity test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval xs = Vector(0, 1, 2, 3)\n// xs: Vector[Int] = Vector(0, 1, 2, 3)\n\ntest(\"Fourth value is approximately equal to 5\") {\n  assert(xs)(hasAt(3)(approximatelyEquals(5, 2)))\n}\n// res5: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = \"Fourth value is approximately equal to 5\",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(use-test-assertions.md,60)))\n//       )\n//     )\n//   )\n// )\n```\n\n----------------------------------------\n\nTITLE: Using dropWhile on a Chunk in Scala\nDESCRIPTION: Demonstrates how to drop elements from a Chunk while a condition is true.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nChunk(9, 2, 5, 1, 6).dropWhile(_ >= 2)\n```\n\n----------------------------------------\n\nTITLE: Either Type Assertions\nDESCRIPTION: Functions for testing Either type values and their contents.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nisLeft[A](assertion: Assertion[A]): Assertion[Either[A, Any]]\nisLeft: Assertion[Either[Any, Any]]\nisRight[A](assertion: Assertion[A]): Assertion[Either[Any, A]]\nisRight: Assertion[Either[Any, Any]]\n```\n\n----------------------------------------\n\nTITLE: Consuming and Printing Events from Kafka Topic\nDESCRIPTION: Helper function to consume records from Kafka topics and print them to the console using zio-kafka Consumer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef consumeAndPrintEvents(consumer: Consumer, groupId: String, topic: String, topics: String*): RIO[Any, Unit] =\n  consumer.consumeWith(\n    settings = ConsumerSettings(BOOSTRAP_SERVERS).withGroupId(groupId),\n    subscription = Subscription.topics(topic, topics: _*),\n    keyDeserializer = Serde.long,\n    valueDeserializer = Serde.string,\n  ) { (k, v) =>\n    Console.printLine(s\"Consumed key: $k, value: $v\").orDie\n  }\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Runtime for ZIO Effects in Scala\nDESCRIPTION: This snippet shows how to access the default ZIO Runtime, which can be used to execute effects in non-ZIO contexts or when integrating with legacy code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/running-effects.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval runtime = Runtime.default\n```\n\n----------------------------------------\n\nTITLE: Automatic Dependency Construction in ZIO 2.x\nDESCRIPTION: This snippet shows how ZIO 2.x simplifies dependency management by automatically constructing dependencies using the ZIO#provide operator. It demonstrates that the order of dependencies doesn't matter and provides friendly compile-time hints.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_50\n\nLANGUAGE: scala\nCODE:\n```\nval res: ZIO[Any, Nothing, Unit] =\n  myApp.provide(\n    Logging.live,\n    Database.live,\n    BlobStorage.live,\n    DocRepo.live,\n    UserRepo.live\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Number Generation with DIStage and ZIO\nDESCRIPTION: Example showing how to create a RandomApp using DIStage for dependency injection with ZIO. Demonstrates service binding and initialization using ModuleDef.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport distage.{Activation, Injector, ModuleDef, Roots}\nimport izumi.distage.model.Locator\nimport izumi.distage.model.definition.Lifecycle\nimport zio.{ExitCode, Task, UIO, URIO, ZIO}\n\nimport java.time.LocalDateTime\n\ntrait Random {\n  def nextInteger: UIO[Int]\n}\n\nfinal class ScalaRandom extends Random {\n  override def nextInteger: UIO[Int] =\n    ZIO.effectTotal(scala.util.Random.nextInt())\n}\n\ntrait Logger {\n  def log(name: String): Task[Unit]\n}\n\nfinal class ConsoleLogger extends Logger {\n  override def log(line: String): Task[Unit] = {\n    val timeStamp = LocalDateTime.now()\n    ZIO.effect(println(s\"$timeStamp: $line\"))\n  }\n}\n\nfinal class RandomApp(random: Random, logger: Logger) {\n  def run: Task[Unit] = for {\n    random <- random.nextInteger\n    _ <- logger.log(s\"random number generated: $random\")\n  } yield ()\n}\n\nobject DistageExample extends zio.App {\n  def RandomAppModule: ModuleDef = new ModuleDef {\n    make[Random].from[ScalaRandom]\n    make[Logger].from[ConsoleLogger]\n    make[RandomApp] // `.from` is not required for concrete classes\n  }\n  \n  val resource: Lifecycle[Task, Locator] = Injector[Task]().produce(\n    plan = Injector[Task]().plan(\n      bindings = RandomAppModule,\n      activation = Activation.empty,\n      roots = Roots.target[RandomApp]\n    )\n  )\n\n  val myApp: Task[Unit] = resource.use(locator => locator.get[RandomApp].run)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Application Logic with Multiple Service Dependencies in Scala ZIO\nDESCRIPTION: Example of writing a ZIO application that depends on multiple services (Logging and RandomInt). The application generates a random number and logs it.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[Logging with RandomInt, Nothing, Unit] = \n  for {\n    _       <- Logging.log(\"Application Started!\")\n    nextInt <- RandomInt.random\n    -       <- Logging.log(s\"Random number generated: ${nextInt.toString}\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating MainApp.scala File in Bash\nDESCRIPTION: Commands to create the directory structure and file for the main ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/run-our-first-zio-project-with-vscode.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ mkdir src/main/scala\n$ touch src/main/scala/MainApp.scala\n```\n\n----------------------------------------\n\nTITLE: Creating CountdownLatch in Scala ZIO\nDESCRIPTION: Constructor method for creating a new CountdownLatch instance with an initial counter value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/countdownlatch.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject CountdownLatch {\n  def make(n: Int): IO[Option[Nothing], CountdownLatch]\n}\n```\n\n----------------------------------------\n\nTITLE: ZIO Effect Examples\nDESCRIPTION: Demonstrates different types of ZIO effects including failed effects, single value effects, and container effects with List and Option.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval failedEffect: ZIO[Any, String, Nothing]       = ZIO.fail(\"fail!\")\nval oneIntValue : ZIO[Any, Nothing, Int]          = ZIO.succeed(3)\nval oneListValue: ZIO[Any, Nothing, List[Int]]    = ZIO.succeed(List(1, 2, 3))\nval oneOption   : ZIO[Any, Nothing , Option[Int]] = ZIO.succeed(None)\n```\n\n----------------------------------------\n\nTITLE: Compiling ZIO Source Code in SBT\nDESCRIPTION: SBT command to compile the production source code of the ZIO project. This verifies that the code builds correctly in your environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncompile\n```\n\n----------------------------------------\n\nTITLE: Acquiring a Read Lock with TReentrantLock in Scala\nDESCRIPTION: Demonstrates acquiring a read lock and checking the lock status. The lock allows multiple readers but prevents writers from accessing the protected resource.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stm._\n\nval program =\n  (for {\n    lock <- TReentrantLock.make\n    _    <- lock.acquireRead\n    rst  <- lock.readLocked  // lock is read-locked once transaction completes\n    wst  <- lock.writeLocked // lock is not write-locked\n  } yield rst && !wst).commit\n```\n\n----------------------------------------\n\nTITLE: Asserting ZIO Effects with assertTrue in Scala\nDESCRIPTION: Illustrates how to use assertTrue to assert ZIO effects in a test scenario involving a Ref.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"updating ref\") {\n  for {\n    r <- Ref.make(0)\n    _ <- r.update(_ + 1)\n    v <- r.get\n  } yield assertTrue(v == 1)\n}\n```\n\n----------------------------------------\n\nTITLE: Folding Elements of a TArray in ZIO STM (Scala)\nDESCRIPTION: Combines all elements of a TArray using a binary operator. This example sums all elements of the array starting with an initial value of 0, using the fold method which applies the associative binary operator to each element and an accumulator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldTArray: UIO[Int] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  sum    <- tArray.fold(0)(_ + _)\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: Using Logical NOT Operator with assertTrue in Scala\nDESCRIPTION: Demonstrates the use of the ! operator to negate assertions in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nsuite(\"unary !\") (\n    test(\"negate true\") {\n        !assertTrue(true) // this will fail\n    },\n    test(\"negate false\") {\n        !assertTrue(false) // this will pass\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Defining an Empty ZIO Layer in Scala\nDESCRIPTION: This invisible code snippet defines an empty ZIO layer (`ZLayer.empty`). This layer is used in the subsequent example demonstrating the creation of a top-level runtime from a layer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/runtime.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nval layer = ZLayer.empty\n```\n\n----------------------------------------\n\nTITLE: Example: IO and Task Interoperability - Scala Application\nDESCRIPTION: A complete Scala application showing usage of the conversion methods between ZIO IO and Monix Task. Demonstrates converting IO to Monix Task and vice versa, running the effects using ZIO's runtime and Monix's runToFuture. Depends on zio, monix, and the interop-monix module. Inputs are simple integer computations, and outputs are printed to the console. This illustrates real-world integration patterns and the need for a Scheduler.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-monix.md#2025-04-23_snippet_2\n\nLANGUAGE: Scala\nCODE:\n```\nimport monix.eval.Task\nimport monix.execution.Scheduler.Implicits.global\nimport zio.{ IO, Runtime }\nimport zio.interop.monix._\n\nobject UnsafeExample extends App {\n\n  val runtime = Runtime.default\n\n  def main(args: Array[String]): Unit = {\n    val io1 = IO.succeed(10)\n    val t1  = runtime.unsafeRun(io1.toTask)\n\n    t1.runToFuture.foreach(r => println(s\"IO to task result is $r\"))\n\n    val t2  = Task(10)\n    val io2 = IO.fromTask(t2).map(r => s\"Task to IO result is $r\")\n\n    println(runtime.unsafeRun(io2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Empty and Simple ZEnvironment in Scala\nDESCRIPTION: This snippet demonstrates how to create an empty ZEnvironment and a ZEnvironment from a simple value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval empty: ZEnvironment[Any] = ZEnvironment.empty\n\ncase class AppConfig(host: String, port: Int)\nval config: ZEnvironment[AppConfig] = ZEnvironment(AppConfig(\"localhost\", 8080))\n```\n\n----------------------------------------\n\nTITLE: Creating a TArray from an Iterable Collection in ZIO STM (Scala)\nDESCRIPTION: Creates a TArray by converting an existing iterable collection (in this case a List) to a TArray. This allows initializing a TArray from any collection that implements the Iterable interface.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval iterableTArray: STM[Nothing, TArray[Int]] = TArray.fromIterable(List(1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application with Live Terminal Service in Scala\nDESCRIPTION: Demonstrates how to run a ZIO application by providing the live Terminal service implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def myApp(c: Terminal): Task[Unit] =\n    for {\n      _    <- c.print(\"Please enter your name: \")\n      name <- c.readLine\n      _    <- c.printLine(s\"Hello, $name!\")\n    } yield ()\n\n  def run = myApp(TerminalLive)\n}\n```\n\n----------------------------------------\n\nTITLE: Utility Object for Source File Printing - Scala\nDESCRIPTION: This is a utility object, only for documentation usage, to print source file fragments in documentation rendering pipelines. It defines helper methods to read files, extract lines, determine file extensions, and print formatted code blocks. Uses Scala standard library and is not meant for inclusion in applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport scala.io.Source\n\n// NOTE: Code copied from the zio-docs module to avoid circular dependency in SBT modules.\n// This code does not show up on the website since we are using `mdoc:passthrough`.\nobject utils {\n\n  def readSource(path: String, lines: Seq[(Int, Int)]): String = {\n    def readFile(path: String) =\n      try {\n        Source.fromFile(\"../\" + path)\n      } catch {\n        case _ => Source.fromFile(path)\n      }\n\n    if (lines.isEmpty) {\n      val content = readFile(path).getLines().mkString(\"\\n\")\n      content\n    } else {\n      val chunks = for {\n        (from, to) <- lines\n      } yield readFile(path)\n        .getLines()\n        .toArray[String]\n        .slice(from - 1, to)\n        .mkString(\"\\n\")\n\n      chunks.mkString(\"\\n\\n\")\n    }\n  }\n\n  def fileExtension(path: String): String = {\n    val javaPath      = java.nio.file.Paths.get(path)\n    val fileExtension =\n      javaPath.getFileName.toString\n        .split('.')\n        .lastOption\n        .getOrElse(\"\")\n    fileExtension\n  }\n\n  def printSource(\n    path: String,\n    lines: Seq[(Int, Int)] = Seq.empty,\n    comment: Boolean = true,\n    showLineNumbers: Boolean = false,\n  ) = {\n    val title     = if (comment) s\"\"\"title=\\\"$path\\\"\"\" else \"\"\n    val showLines = if (showLineNumbers) \"showLineNumbers\" else \"\"\n    println(s\"\"\"```$fileExtension(path) $title $showLines\"\"\")\n    println(readSource(path, lines))\n    println(\"```\")\n  }\n\n}\n\nutils.printSource(\"documentation/guides/tutorials/make-a-zio-app-configurable/src/main/scala/dev/zio/quickstart/MainApp.scala\")\n```\n\n----------------------------------------\n\nTITLE: Testing ZIO Effect Failure with Error Subtype using `assertZIO` (Scala)\nDESCRIPTION: This test demonstrates checking if a ZIO effect fails with any subtype of a given error type (`MyError`). It defines an effect that fails with `E1` (a subtype of `MyError`). `assertZIO` is used with the effect's `.exit` value and the combined assertion `fails(isSubtype[MyError](anything))` to verify the failure condition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\nimport zio.test.Assertion._\n\nval effect = ZIO.fail(E1(\"my error msg\"))\n\ntest(\"Test if a ZIO effect fails with a MyError\") {\n  assertZIO(effect.exit)(fails(isSubtype[MyError](anything)))\n}\n```\n\n----------------------------------------\n\nTITLE: Expected Output for ZIO Absorb Example\nDESCRIPTION: Shows the console output when running the ZIO application that uses `absorb` to handle both a defect (`dieMessage`) and an interruption. The output confirms that the application runs to completion and prints the success message because `absorb` converted both terminal events into ignored failures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/converting-defects-to-failures.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\napplication exited successfully: ()\n```\n\n----------------------------------------\n\nTITLE: Exception Translation in Mapped Effects - ZIO map/flatMap - Scala\nDESCRIPTION: Illustrates how exceptions thrown inside a map operation on a ZIO effect are translated into defects automatically. Both 'defect4' and 'defect5' show mapping over effects with code that throws an exception, causing those to become ZIO defects. Dependencies: zio._. Highlights a subtle case where user code can introduce defects in mapped computations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval defect4 = ZIO.succeed(???).map(_ => throw new Exception(\"Boom!\"))\nval defect5 = ZIO.attempt(???).map(_ => throw new Exception(\"Boom!\"))\n```\n\n----------------------------------------\n\nTITLE: Defining catchAllTrace and catchSomeTrace for ZIO - Scala\nDESCRIPTION: Extends ZIO to handle typed errors along with their stack traces using catchAllTrace and catchSomeTrace. These operators provide recovery logic that additionally receives execution traces (for debugging or analytics). Requires functions consuming both error and stack trace.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def catchAllTrace[R1 <: R, E2, A1 >: A](\n    h: ((E, Trace)) => ZIO[R1, E2, A1]\n  ): ZIO[R1, E2, A1]\n\n  def catchSomeTrace[R1 <: R, E1 >: E, A1 >: A](\n    pf: PartialFunction[(E, Trace), ZIO[R1, E1, A1]]\n  ): ZIO[R1, E1, A1]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Fixed-Repetition Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that only recurs a specified number of times (5 in this example).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval recurs = Schedule.recurs(5)\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Dependency to build.sbt\nDESCRIPTION: This snippet shows how to add the core ZIO library as a dependency in a Scala project's build.sbt file. It uses a variable to dynamically insert the version number.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio\" % \"${zio.BuildInfo.version.split('+').head}\"\n```\n\n----------------------------------------\n\nTITLE: Acquiring TSemaphore Permit in Scala ZIO\nDESCRIPTION: Shows how to acquire a permit from a TSemaphore, reducing the number of available permits. This operation blocks semantically when no permits are available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tsemaphore.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreAcq: STM[Nothing, TSemaphore] = for {\n  tSem <- TSemaphore.make(2L)\n  _    <- tSem.acquire\n} yield tSem\n\ntSemaphoreAcq.commit\n```\n\n----------------------------------------\n\nTITLE: Asserting Boolean Values in Scala\nDESCRIPTION: Creates assertions that check if a Boolean value is true or false.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_15\n\nLANGUAGE: Scala\nCODE:\n```\nisFalse\n```\n\nLANGUAGE: Scala\nCODE:\n```\nisTrue\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to Forked ZIO Repository\nDESCRIPTION: Git command to push your local commits to your forked repository on GitHub. This makes your changes available online.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit push\n```\n\n----------------------------------------\n\nTITLE: Creating Application with Has-Wrapped Services in Scala ZIO\nDESCRIPTION: Refactored application using Has-wrapped services. The effect now requires services wrapped in the Has data type, enabling composition of services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[Has[Logging] with Has[RandomInt], Nothing, Unit] =\n  for {\n    _ <- Logging.log(\"Application Started!\")\n    nextInt <- RandomInt.random\n    - <- Logging.log(s\"Random number generated: ${nextInt.toString}\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Asserting Map Keys and Values in Scala\nDESCRIPTION: Creates assertions that check the keys or values of a Map against specified assertions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_13\n\nLANGUAGE: Scala\nCODE:\n```\nhasKeys[K, V](assertion: Assertion[Iterable[K]])\n```\n\nLANGUAGE: Scala\nCODE:\n```\nhasValues[K, V](assertion: Assertion[Iterable[V]])\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Apache Parquet in Scala\nDESCRIPTION: This snippet shows how to add the ZIO Apache Parquet dependency to a Scala project using sbt. It specifies the library dependency for the core module.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-apache-parquet.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"me.mnedokushev\" %% \"zio-apache-parquet-core\" % \"0.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Generating Capability Accessors With @accessible Macro (Scala)\nDESCRIPTION: Illustrates defining a service trait within an object annotated with @accessible, enabling ZIO to auto-generate capability accessor methods. This reduces boilerplate by automating access to service methods via the ZIO environment. Requires zio-macros dependency and expects a Service trait inside the object. Input: AccountEvent, Output: UIO[Unit]. Limitation: only available for Scala 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{ Has, ZIO }\nimport zio.macros.accessible\n\n@accessible\nobject AccountObserver {\n  trait Service {\n    def processEvent(event: AccountEvent): UIO[Unit]\n  }\n\n  // below will be autogenerated\n  def processEvent(event: AccountEvent) =\n    ZIO.accessM[Has[AccountObserver.Service]](_.get[Service].processEvent(event))\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Lossy Error Handling in Try-Catch Blocks\nDESCRIPTION: Illustrates how try-catch-finally blocks can lead to loss of error information in imperative error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n try {\n    try throw new Error(\"e1\")\n    finally throw new Error(\"e2\")\n } catch {\n   case e: Error => println(e)\n }\n\n// Output:\n// e2\n```\n\n----------------------------------------\n\nTITLE: Custom Runtime Creation for Mixed Applications in Scala\nDESCRIPTION: Shows how to create and use custom runtimes in mixed ZIO/non-ZIO applications using Runtime.unsafe.fromLayer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp {\n  val sl4jlogger: ZLogger[String, Any] = ???\n\n  def legacyApplication(input: Int): Unit = ???\n\n  val zioWorkflow: ZIO[Any, Nothing, Int] = ???\n\n  def zioApplication(): Int =\n      Unsafe.unsafe { implicit unsafe =>\n        Runtime\n          .unsafe\n          .fromLayer(\n            Runtime.removeDefaultLoggers ++ Runtime.addLogger(sl4jlogger)\n          )\n          .unsafe\n          .run(zioWorkflow)\n          .getOrThrowFiberFailure()\n      }\n\n  def main(args: Array[String]): Unit = {\n    val result = zioApplication()\n    legacyApplication(result)\n  }  \n\n}\n```\n\n----------------------------------------\n\nTITLE: Smart Assertions in ZIO 2.x\nDESCRIPTION: Example of simplified test assertions using ZIO 2.x smart assertions\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_77\n\nLANGUAGE: scala\nCODE:\n```\nsuite(\"ZIO 2.x SmartAssertions\")(\n  test(\"contains\")(assertTrue(list.contains(5))),\n  test(\"forall\")(assertTrue(list.forall(_ % 2 == 0))),\n  test(\"less than\")(assertTrue(number < 0)),\n  test(\"isSome\")(assertTrue(option.get == 3))\n)\n```\n\n----------------------------------------\n\nTITLE: ZIO Application with Custom Logger Integration\nDESCRIPTION: Complete ZIO application example showing how to integrate a custom logger and remove default loggers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/create-custom-logger-for-a-zio-application.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject MainApp extends ZIOAppDefault {\n\n  val logger: ZLogger[String, Unit] =\n    new ZLogger[String, Unit] {\n      override def apply(\n        trace: Trace,\n        fiberId: FiberId,\n        logLevel: LogLevel,\n        message: () => String,\n        cause: Cause[Any],\n        context: FiberRefs,\n        spans: List[LogSpan],\n        annotations: Map[String, String]\n      ): Unit =\n        println(s\"${java.time.Instant.now()} - ${logLevel.label} - ${message()}\")\n    }\n\n  override val bootstrap = Runtime.removeDefaultLoggers ++ Runtime.addLogger(logger)\n\n  def run =\n    for {\n      _ <- ZIO.log(\"Application started!\")\n      _ <- ZIO.log(\"Another log message.\")\n      _ <- ZIO.log(\"Application stopped!\")\n    } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving a TRef Value in a Single Transaction in Scala ZIO STM\nDESCRIPTION: Creates a TRef and retrieves its value within a single atomic transaction. The transaction is committed to execute the operations and obtain the final integer value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval retrieveSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  value <- tRef.get\n} yield value).commit\n```\n\n----------------------------------------\n\nTITLE: Collecting Elements from a Chunk in Scala\nDESCRIPTION: Shows how to use collect to filter and transform Chunk elements based on pattern matching.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval collectChunk = Chunk(\"Hello ZIO\", 1.5, \"Hello ZIO NIO\", 2.0, \"Some string\", 2.5)\n\ncollectChunk.collect { case string: String => string }\n```\n\n----------------------------------------\n\nTITLE: Basic Mapping in ZIO Streams\nDESCRIPTION: Demonstrates basic mapping operation to transform stream elements from one type to another.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream._\n\nval intStream: UStream[Int] = Stream.fromIterable(0 to 100)\nval stringStream: UStream[String] = intStream.map(_.toString)\n```\n\n----------------------------------------\n\nTITLE: Filtering Generated Values in Scala\nDESCRIPTION: Shows how to use Gen#filter to discard values that don't meet a specified predicate. Also includes a performance note and a recommended alternative using map.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/operators.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nGen.int(-10, +10).filter(_ % 2 == 0).runCollectN(5) \n// Sample Output: List(-6, 10, 0, -8, 4)\n```\n\nLANGUAGE: scala\nCODE:\n```\nGen.int(-10, +10).map(_ * 2).runCollectN(5)\n// Sample Output: List(2, 6, -6, 20, -14)\n```\n\n----------------------------------------\n\nTITLE: Executing GraphQL Query via CURL\nDESCRIPTION: Example of how to execute a GraphQL query using curl command\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl 'http://localhost:8088/api/graphql' --data-binary '{\"query\":\"query{\\n employees(role: SoftwareDeveloper){\\n name\\n role\\n}\\n}\"}'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Exhaustivity Checking in ZIO Error Handling\nDESCRIPTION: Shows how ZIO's typed errors enable compiler-assisted exhaustivity checking for error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/declarative.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nvalidate(17).catchAll {\n  case NegativeAgeException(age) => ???\n}\n\n// match may not be exhaustive.\n// It would fail on the following input: IllegalAgeException(_)\n```\n\n----------------------------------------\n\nTITLE: Stateful Mapping with mapAccum\nDESCRIPTION: Shows how to use mapAccum for stateful transformations of stream elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\ndef runningTotal(stream: UStream[Int]): UStream[Int] =\n  stream.mapAccum(0)((acc, next) => (acc + next, acc + next))\n\n// input:  0, 1, 2, 3,  4,  5\n// output: 0, 1, 3, 6, 10, 15\n```\n\n----------------------------------------\n\nTITLE: ScopedRef Constructors in Scala\nDESCRIPTION: Defines two constructor methods for creating ScopedRef instances. The make method creates a ref from a simple value, while fromAcquire creates a ref from a resourceful effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scopedref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject ScopedRef {\n  def make[A](a: => A): ZIO[Scope, Nothing, ScopedRef[A]] = ???\n  def fromAcquire[R, E, A](acquire: ZIO[R, E, A]): ZIO[R with Scope, E, ScopedRef[A]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Effects for Each Element in a TSet in Scala ZIO STM\nDESCRIPTION: Demonstrates how to perform an STM effect for each element in a TSet using the foreach method. In this example, each element is offered to a TQueue.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foreachTSet = (for {\n  tSet   <- TSet.make(1, 2, 3, 4)\n  tQueue <- TQueue.unbounded[Int]\n  _      <- tSet.foreach(a => tQueue.offer(a).unit)\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: Declaring Bounded Hub Constructor in Scala\nDESCRIPTION: Defines the signature for creating a bounded Hub with a specified capacity. The actual implementation is not provided in this snippet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef bounded[A](requestedCapacity: Int): UIO[Hub[A]] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: Polling TQueue in Scala ZIO\nDESCRIPTION: Non-blocking attempt to retrieve the first element from a TQueue, returning None if empty.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueuePoll: UIO[Option[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  res    <- tQueue.poll\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO S3 to SBT Dependencies\nDESCRIPTION: SBT dependency configuration for adding ZIO S3 to a Scala project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-s3\" % \"0.3.5\"\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO Metrics with Prometheus\nDESCRIPTION: An example using ZIO Metrics with Prometheus integration. It demonstrates initializing default exports, registering a counter with labels, and making metrics available via an HTTP endpoint.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.Runtime\nimport zio.console.{Console, putStrLn}\nimport zio.metrics.prometheus._\nimport zio.metrics.prometheus.exporters._\nimport zio.metrics.prometheus.helpers._\n\nobject ZIOMetricsExample extends scala.App {\n\n  val myApp =\n    for {\n      r <- getCurrentRegistry()\n      _ <- initializeDefaultExports(r)\n      c <- counter.register(\"ServiceA\", Array(\"Request\", \"Region\"))\n      _ <- c.inc(1.0, Array(\"GET\", \"us-west-*\"))\n      _ <- c.inc(2.0, Array(\"POST\", \"eu-south-*\"))\n      _ <- c.inc(3.0, Array(\"GET\", \"eu-south-*\"))\n      s <- http(r, 9090)\n      _ <- putStrLn(s\"The application's metric endpoint: http://localhost:${s.getPort()}/\")\n    } yield s\n\n  Runtime\n    .unsafeFromLayer(\n      Registry.live ++ Exporters.live ++ Console.live\n    )\n    .unsafeRun(myApp)\n}\n```\n\n----------------------------------------\n\nTITLE: ZIO AMQP Installation Configuration\nDESCRIPTION: SBT dependency configuration for ZIO AMQP client library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"nl.vroste\" %% \"zio-amqp\" % \"0.2.0\"\n```\n\n----------------------------------------\n\nTITLE: Defining TaskLayer Type Alias in Scala\nDESCRIPTION: Creates a type alias called TaskLayer which represents a ZLayer that requires no input (Any), may fail with a Throwable, and produces an output of type ROut. This simplifies the creation of layers that don't depend on other services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/task-layer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype TaskLayer[+ROut] = ZLayer[Any, Throwable, ROut]\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Streams Dependency to build.sbt\nDESCRIPTION: This snippet demonstrates how to include the ZIO streams library as a dependency in a Scala project's build.sbt file. It uses a variable to dynamically insert the version number.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-streams\" % \"${zio.BuildInfo.version.split('+').head}\"\n```\n\n----------------------------------------\n\nTITLE: Using Logical Implies Operator with assertTrue in Scala\nDESCRIPTION: Shows how to use the implies operator for conditional assertions in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nsuite(\"implies\") (\n  test(\"true implies true\")(\n    assertTrue(true) implies assertTrue(true) // this will pass\n  ),\n  test(\"true implies false\")(\n    assertTrue(true) implies assertTrue(false) // this will fail\n  ),\n  test(\"false implies true\")(\n    assertTrue(false) implies assertTrue(true) // this will pass\n  ),\n  test(\"false implies false\")(\n    assertTrue(false) implies assertTrue(false) // this will pass\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Mapping and Filtering with collect in Scala\nDESCRIPTION: Illustrates the use of Gen#collect to map values produced by a generator using a partial function, discarding values not defined in the function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/operators.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nGen.int(-10, +10)\n  .collect { case n if n % 2 == 0 => n }\n  .runCollectN(5)\n  .debug\n// Smaple Output: List(-6, -8, -2, 4, -6)\n```\n\n----------------------------------------\n\nTITLE: Main Application Setup for Akka Cluster\nDESCRIPTION: Main application entry point that initializes the actor system, loads configuration, and starts the HTTP server. Wires together all components of the sharded counter service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.typed.ActorSystem\nimport akka.cluster.sharding.typed.ShardingEnvelope\nimport akka.http.scaladsl.Http\nimport com.typesafe.config.ConfigFactory\n\nobject AkkaClusterShardingExample extends App {\n  val config = ConfigFactory.load(\"application.conf\")\n\n  implicit val system: ActorSystem[ShardingEnvelope[Counter.Message]] =\n    ActorSystem(Guardian(), \"system\", config)\n\n  Http()\n    .newServerAt(\n      config.getString(\"webservice.host\"),\n      config.getInt(\"webservice.port\")\n    )\n    .bind(CounterHttpApp.routes)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Temporal via SBT Dependency\nDESCRIPTION: SBT dependency configuration for adding ZIO Temporal to a Scala project. This adds the core library needed to use ZIO Temporal functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-temporal.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.vhonta\" %% \"zio-temporal-core\" % \"0.4.0\"\n```\n\n----------------------------------------\n\nTITLE: Interruptible ZManaged Creation\nDESCRIPTION: Type signature for creating ZManaged resources with interruptible acquire operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZManaged[-R, +E, +A] {\n  def makeInterruptible[R, E, A](\n    acquire: ZIO[R, E, A]\n  )(release: A => URIO[R, Any]): ZManaged[R, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Element from TArray in Scala ZIO STM\nDESCRIPTION: Shows how to access an element at a specific index from a TArray using STM transactions\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tArrayGetElem: UIO[Int] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  elem   <- tArray(2)\n} yield elem).commit\n```\n\n----------------------------------------\n\nTITLE: ZManagedSyntax class for Resource conversion\nDESCRIPTION: Method signature for converting ZManaged to Cats Effect Resource using the toResource extension method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nfinal class ZManagedSyntax[R, E, A](private val managed: ZManaged[R, E, A]) {\n  def toResource[F[_]](implicit\n      F: Async[F],\n      ev: Effect[ZIO[R, E, *]]\n  ): Resource[F, A] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Sum Type Case in Scala\nDESCRIPTION: Creates an assertion `Assertion[Sum]` for a sum type (like sealed traits/ADTs). It checks if the value matches a specific case (`termName`), extracts the value using the provided projection function (`term`), and applies a nested assertion (`assertion`) to the extracted value (`Proj`). The projection function should return `Some[Proj]` if it's the correct case, `None` otherwise.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nisCase[Sum, Proj]( termName: String, term: Sum => Option[Proj], assertion: Assertion[Proj])\n```\n\n----------------------------------------\n\nTITLE: Compiling ZIO Test Source Code\nDESCRIPTION: SBT command to compile the test source code of the ZIO project. This ensures tests can be executed after making changes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nTest/compile\n```\n\n----------------------------------------\n\nTITLE: Implementing Live Terminal Service in Scala\nDESCRIPTION: Provides a live implementation of the Terminal service interface using ZIO's attemptBlocking for IO operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject TerminalLive extends Terminal {\n  override def print(line: Any): Task[Unit] =\n    ZIO.attemptBlocking(scala.Predef.print(line))\n\n  override def printLine(line: Any): Task[Unit] =\n    ZIO.attemptBlocking(scala.Predef.println(line))\n\n  override def readLine: Task[String] =\n    ZIO.attemptBlocking(scala.io.StdIn.readLine())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter Actor in Scala with Akka\nDESCRIPTION: Defines a Counter actor that handles Increase and Decrease messages, maintaining state for each entity instance. The actor logs operations and responds with updated counter values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.typed.scaladsl.Behaviors\nimport akka.actor.typed.{ActorRef, Behavior}\n\nobject Counter {\n  sealed trait Message\n  case class Increase(replyTo: ActorRef[Int]) extends Message\n  case class Decrease(replyTo: ActorRef[Int]) extends Message\n\n  def apply(entityId: String): Behavior[Message] = {\n    def updated(value: Int): Behavior[Message] = {\n      Behaviors.receive { (context, command) =>\n        val log = context.log\n        val address = context.system.address\n        command match {\n          case Increase(replyTo) =>\n            log.info(s\"executing inc msg for $entityId entity inside $address\")\n            val state = value + 1\n            replyTo ! state\n            updated(state)\n          case Decrease(replyTo) =>\n            log.info(s\"executing dec msg for $entityId entity inside $address\")\n            val state = value - 1\n            replyTo ! state\n            updated(state)\n        }\n      }\n    }\n    updated(0)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO IO to CompletableFuture\nDESCRIPTION: Shows how to convert any ZIO IO to a CompletableFuture with custom error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-java.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef ioToStage[E, A](io: IO[E, A])(toThrowable: E => Throwable): UIO[CompletableFuture[A]] =\n    io.toCompletableFutureWith(toThrowable)\n```\n\n----------------------------------------\n\nTITLE: Running Specific ZIO Tests by Label with SBT\nDESCRIPTION: These commands show how to run specific ZIO tests by their labels using SBT, both in the SBT console and directly from the shell.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/running-tests.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntestOnly ExampleSpec -- -t \"bar\"\n\nsbt \"testOnly ExampleSpec -- -t \\\"bar\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Non-interruptible Blocking Operation in ZIO\nDESCRIPTION: Demonstrates a non-interruptible blocking operation using ZIO.attemptBlocking. This example shows how the operation continues running even after interruption.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/interruption/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  _ <- Console.printLine(\"Starting a blocking operation\")\n  fiber <- ZIO.attemptBlocking {\n    while (true) {\n      Thread.sleep(1000)\n      println(\"Doing some blocking operation\")\n    }\n  }.ensuring(\n    Console.printLine(\"End of a blocking operation\").orDie\n  ).fork\n  _ <- fiber.interrupt.schedule(\n    Schedule.delayed(\n      Schedule.duration(1.seconds)\n    )\n  )\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Creating a Constant Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that repeats once and produces a specified constant value (5 in this example).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval constant = Schedule.succeed(5)\n```\n\n----------------------------------------\n\nTITLE: Defining Command Generators for Testing in Scala with ZIO Test\nDESCRIPTION: Demonstrates how to create generators for testing command-based systems, such as a stack implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Command\ncase object Pop                    extends Command\nfinal case class Push(value: Char) extends Command\n\nval genPop:  Gen[Any, Command]    = Gen.const(Pop)\ndef genPush: Gen[Any, Command] = Gen.alphaChar.map(Push)\n\nval genCommands: Gen[Any, List[Command]] =\n  Gen.unfoldGen(0) { n =>\n    if (n <= 0)\n      genPush.map(command => (n + 1, command))\n    else\n      Gen.oneOf(\n        genPop.map(command => (n - 1, command)),\n        genPush.map(command => (n + 1, command))\n      )\n  }\n```\n\n----------------------------------------\n\nTITLE: Checking Available TSemaphore Permits in Scala ZIO\nDESCRIPTION: Shows how to query the number of remaining permits in a TSemaphore using the available method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tsemaphore.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreAvailable: STM[Nothing, Long] = for {\n  tSem <- TSemaphore.make(2L)\n  _    <- tSem.acquire\n  cap  <- tSem.available\n} yield cap\n\ntSemaphoreAvailable.commit\n```\n\n----------------------------------------\n\nTITLE: Writing an Akka HTTP Route Test with ZIO Test\nDESCRIPTION: This example demonstrates how to create a test specification for an Akka HTTP route using ZIO Test. It shows the basic structure of a test spec that extends AkkaZIOSpecDefault and tests an HTTP endpoint response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-test-akka-http.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.http.scaladsl.model.HttpResponse\nimport akka.http.scaladsl.server.Directives.complete\nimport zio.test.Assertion._\nimport zio.test._\nimport zio.test.akkahttp.AkkaZIOSpecDefault\n\nobject MySpec extends AkkaZIOSpecDefault {\n  def spec =\n    suite(\"MySpec\")(\n      test(\"my test\") {\n        assertZIO(Get() ~> complete(HttpResponse()))(\n          handled(\n            response(equalTo(HttpResponse()))\n          )\n        )\n      }\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Function Generator Definition\nDESCRIPTION: Basic function generator that produces functions from type A to B based on hashCode equality\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ndef function[R, A, B](gen: Gen[R, B]): Gen[R, A => B]\n```\n\n----------------------------------------\n\nTITLE: ZLayer Construction in ZIO 2.x\nDESCRIPTION: Demonstrates the simplified layer construction pattern in ZIO 2.x using for-comprehension instead of fromServices.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\ntrait FooService {\n  def foo: UIO[Unit]\n}\n\ntrait BarService {\n  def bar: UIO[Unit]\n}\n\ntrait BazService {\n  def baz: UIO[Unit]\n}\n\ncase class BazServiceImpl(fooService: FooService, barService: BarService) extends BazService {\n  override def baz: UIO[Unit] =\n    for {\n      _ <- fooService.foo\n      _ <- barService.bar\n    } yield ()\n}\n\nobject LoggingLive {\n  val layer: ZLayer[FooService & BarService, Nothing, BazService] =\n    ZLayer {\n      for {\n        fooService <- ZIO.service[FooService]\n        barService <- ZIO.service[BarService]\n      } yield BazServiceImpl(fooService, barService)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with AWS ElasticBeanstalk and EC2 using ZIO AWS\nDESCRIPTION: Comprehensive example showing how to use ZIO AWS to interact with ElasticBeanstalk and EC2 services. The code retrieves application information, environment details, and EC2 instance data using ZIO streams and ZIO's dependency injection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nimport io.github.vigoo.zioaws.core.AwsError\nimport io.github.vigoo.zioaws.ec2.Ec2\nimport io.github.vigoo.zioaws.ec2.model._\nimport io.github.vigoo.zioaws.elasticbeanstalk.ElasticBeanstalk\nimport io.github.vigoo.zioaws.elasticbeanstalk.model._\nimport io.github.vigoo.zioaws.{core, ec2, elasticbeanstalk, netty}\nimport zio.console._\nimport zio.stream._\nimport zio.{console, _}\n\nobject ZIOAWSExample extends zio.App {\n  val program: ZIO[Console with Ec2 with ElasticBeanstalk, AwsError, Unit] =\n    for {\n      appsResult <- elasticbeanstalk.describeApplications(\n        DescribeApplicationsRequest(applicationNames = Some(List(\"my-service\")))\n      )\n      app <- appsResult.applications.map(_.headOption)\n      _ <- app match {\n        case Some(appDescription) =>\n          for {\n            applicationName <- appDescription.applicationName\n            _ <- console.putStrLn(\n              s\"Got application description for $applicationName\"\n            ).ignore\n\n            envStream = elasticbeanstalk.describeEnvironments(\n              DescribeEnvironmentsRequest(applicationName =\n                Some(applicationName)\n              )\n            )\n\n            _ <- envStream.run(Sink.foreach { env =>\n              env.environmentName.flatMap { environmentName =>\n                (for {\n                  environmentId <- env.environmentId\n                  _ <- console.putStrLn(\n                    s\"Getting the EB resources of $environmentName\"\n                  ).ignore\n\n                  resourcesResult <-\n                    elasticbeanstalk.describeEnvironmentResources(\n                      DescribeEnvironmentResourcesRequest(environmentId =\n                        Some(environmentId)\n                      )\n                    )\n                  resources <- resourcesResult.environmentResources\n                  _ <- console.putStrLn(\n                    s\"Getting the EC2 instances in $environmentName\"\n                  ).ignore\n                  instances <- resources.instances\n                  instanceIds <- ZIO.foreach(instances)(_.id)\n                  _ <- console.putStrLn(\n                    s\"Instance IDs are ${instanceIds.mkString(\", \")}\"\n                  ).ignore\n\n                  reservationsStream = ec2.describeInstances(\n                    DescribeInstancesRequest(instanceIds = Some(instanceIds))\n                  )\n                  _ <- reservationsStream.run(Sink.foreach { reservation =>\n                    reservation.instances\n                      .flatMap { instances =>\n                        ZIO.foreach(instances) { instance =>\n                          for {\n                            id <- instance.instanceId\n                            typ <- instance.instanceType\n                            launchTime <- instance.launchTime\n                            _ <- console.putStrLn(s\"  instance $id:\").ignore\n                            _ <- console.putStrLn(s\"    type: $typ\").ignore\n                            _ <- console.putStrLn(\n                              s\"    launched at: $launchTime\"\n                            ).ignore\n                          } yield ()\n                        }\n                      }\n                  })\n                } yield ()).catchAll { error =>\n                  console.putStrLnErr(\n                    s\"Failed to get info for $environmentName: $error\"\n                  ).ignore\n                }\n              }\n            })\n          } yield ()\n        case None =>\n          ZIO.unit\n      }\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = { //\n    val httpClient = netty.default\n    val awsConfig  = httpClient >>> core.config.default\n    val aws        = awsConfig >>> (ec2.live ++ elasticbeanstalk.live)\n\n    program\n      .provideCustomLayer(aws)\n      .either\n      .flatMap {\n        case Left(error) =>\n          console.putStrErr(s\"AWS error: $error\").ignore.as(ExitCode.failure)\n        case Right(_) =>\n          ZIO.unit.as(ExitCode.success)\n      }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Optional ZIO Effects with ZIO.some/ZIO.none in Scala\nDESCRIPTION: Illustrates using `ZIO.some` and `ZIO.none` as convenient constructors to directly create ZIO effects that succeed with an `Option` value. `ZIO.some(3)` creates an effect succeeding with `Some(3)`, and `ZIO.none` creates an effect succeeding with `None`. These effects do not fail (`Nothing` error type).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval someInt: ZIO[Any, Nothing, Option[Int]]     = ZIO.some(3)\nval noneInt: ZIO[Any, Nothing, Option[Nothing]] = ZIO.none\n```\n\n----------------------------------------\n\nTITLE: GraphQL Query for Filtering Employees by Role\nDESCRIPTION: A GraphQL query that filters employees with the role of SoftwareDeveloper and returns their name and role.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/graphql-webservice.md#2025-04-23_snippet_3\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  employees(role: SoftwareDeveloper) {\n    name\n    role\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Empty TArray in Scala ZIO STM\nDESCRIPTION: Demonstrates how to create an empty TArray instance for storing integers using STM transactions\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval emptyTArray: STM[Nothing, TArray[Int]] = TArray.empty[Int]\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO Dependency in Scala.js (sbt)\nDESCRIPTION: This sbt configuration snippet adds the ZIO library as a dependency to a Scala.js project. It also sets `scalaJSUseMainModuleInitializer` to true, which is often required for Scala.js applications that define a main method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-javascript.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```\nscalaJSUseMainModuleInitializer := true\nlibraryDependencies += \"dev.zio\" %%% \"zio\" % \"1.0.18\"\n```\n```\n\n----------------------------------------\n\nTITLE: Decoder Mapping Example\nDESCRIPTION: Example of mapping an existing decoder to create a new decoder for a custom type\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.json._\n\ntest(\"mapping decoders\") {\n  case class Person(name: String, age: Int)\n  object Person {\n    implicit val decoder = JsonDecoder[(String, Int)].map { case (name, age) => Person(name, age) }\n  }\n\n  val person = \"[\\\"John\\\",42]\".fromJson[Person]\n\n  assertTrue(person == Right(Person(\"John\", 42)))\n}\n```\n\n----------------------------------------\n\nTITLE: Default Runtime Implementation\nDESCRIPTION: Default ZIO Runtime implementation with standard environment and platform configuration\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nobject Runtime {\n  lazy val default: Runtime[ZEnv] = Runtime(ZEnv.Services.live, Platform.default)\n}\n```\n\n----------------------------------------\n\nTITLE: Suite Composition in ZIO 1.x\nDESCRIPTION: Example of composing test suites in ZIO 1.x using nested suites\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_78\n\nLANGUAGE: scala\nCODE:\n```\nval fooSuite = suite(\"Foo\")(fooSpec)\nval barSuite = suite(\"Bar\")(barSpec)\nval bazSuite = suite(\"Baz\")(bazSpec)\n\nval bigSuite = suite(\"big suite\")(fooSuite, barSuite, bazSuite)\n```\n\n----------------------------------------\n\nTITLE: Performing Key-Value Operations with ZIO RocksDB\nDESCRIPTION: Example of using ZIO RocksDB for key-value operations, including basic get/put operations and transactional operations with concurrent updates to ensure data consistency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console._\nimport zio.rocksdb.{RocksDB, Transaction, TransactionDB}\nimport zio.{URIO, ZIO}\n\nimport java.nio.charset.StandardCharsets._\n\nobject ZIORocksDBExample extends zio.App {\n\n  private def bytesToString(bytes: Array[Byte]): String = new String(bytes, UTF_8)\n  private def bytesToInt(bytes: Array[Byte]): Int = bytesToString(bytes).toInt\n\n  val job1: ZIO[Console with RocksDB, Throwable, Unit] =\n    for {\n      _ <- RocksDB.put(\n        \"Key\".getBytes(UTF_8),\n        \"Value\".getBytes(UTF_8)\n      )\n      result <- RocksDB.get(\"Key\".getBytes(UTF_8))\n      stringResult = result.map(bytesToString)\n      _ <- putStrLn(s\"value: $stringResult\")\n    } yield ()\n\n\n  val job2: ZIO[Console with TransactionDB, Throwable, Unit] =\n    for {\n      key <- ZIO.succeed(\"COUNT\".getBytes(UTF_8))\n      _ <- TransactionDB.put(key, 0.toString.getBytes(UTF_8))\n      _ <- ZIO.foreachPar(0 until 10) { _ =>\n        TransactionDB.atomically {\n          Transaction.getForUpdate(key, exclusive = true) >>= { iCount =>\n            Transaction.put(key, iCount.map(bytesToInt).map(_ + 1).getOrElse(-1).toString.getBytes(UTF_8))\n          }\n        }\n      }\n      value <- TransactionDB.get(key)\n      counterValue = value.map(bytesToInt)\n      _ <- putStrLn(s\"The value of counter: $counterValue\") // Must be 10\n    } yield ()\n\n  private val transactional_db =\n    TransactionDB.live(new org.rocksdb.Options().setCreateIfMissing(true), \"tr_db\")\n\n  private val rocks_db =\n    RocksDB.live(new org.rocksdb.Options().setCreateIfMissing(true), \"rocks_db\")\n\n  override def run(args: List[String]): URIO[zio.ZEnv, Int] =\n    (job1 <*> job2)\n      .provideCustomLayer(transactional_db ++ rocks_db)\n      .foldCauseM(cause => putStrLn(cause.prettyPrint) *> ZIO.succeed(1), _ => ZIO.succeed(0))\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming TArray Elements in Scala ZIO STM\nDESCRIPTION: Demonstrates how to transform all elements in a TArray using a mapping function\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformTArray: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.transform(a => a * a)\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Filtering Schedule Outputs\nDESCRIPTION: Demonstrates filtering schedule outputs using whileOutput. Collects outputs until a condition is met.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/combinators.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval res = Schedule.unfold(0)(_ + 1).whileOutput(_ < 5).collectAll\n```\n\n----------------------------------------\n\nTITLE: Defining `unrefineTo` Signature in ZIO Scala\nDESCRIPTION: Shows the type signature of the `unrefineTo` operator. It broadens the error channel from `E` to a supertype `E1` (`E1 >: E`). This operation primarily changes the type signature and can potentially convert some related defects (subtypes of E1 that were defects) back into the typed error channel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def unrefineTo[E1 >: E]: ZIO[R, E1, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Manually Reloadable Services in a ZIO Application\nDESCRIPTION: Example of a ZIO application that uses a manually reloadable Counter service, demonstrating service acquisition, interaction, and explicit reloading.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nimport java.util.UUID\n\nobject ReloadableExample extends ZIOAppDefault {\n  val app: ZIO[Reloadable[Counter], Any, Unit] =\n    for {\n      reloadable <- ZIO.service[Reloadable[Counter]]\n      counter <- reloadable.get\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug(\"Counter value is\")\n      _ <- reloadable.reload *> ZIO.sleep(1.second)\n      counter <- reloadable.get\n      _ <- counter.increment\n      _ <- counter.increment\n      _ <- counter.get.debug(\"Counter value is\")\n    } yield ()\n\n  def run = app.provide(Counter.reloadable)\n}\n```\n\n----------------------------------------\n\nTITLE: Higher-kinded Type Decoding Examples\nDESCRIPTION: Test cases showing JSON decoding for Option and Array types\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.json._\nimport zio.test._\nimport zio.test.Assertion._\n\ntest(\"decode from optional value\") {\n  val json = \"null\"\n  val decoded = JsonDecoder[Option[Int]].decodeJson(json)\n  assertTrue(decoded == Right(None))\n} +\ntest(\"decode from array of ints\") {\n  val json    = \"[1, 2, 3]\"\n  val decoded = json.fromJson[Array[Int]]\n\n  assert(decoded)(isRight(equalTo(Array(1, 2, 3))))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating UIO Effect for Side Effect using ZIO.effectTotal - Scala\nDESCRIPTION: Illustrates converting an inherently side-effecting operation (printing a line) into a UIO (unexceptional effect) using ZIO.effectTotal, under the assumption that no exception will be thrown. Provides a safe wrapper for effects such as println.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\ndef putStrLn(line: String): UIO[Unit] =\n  ZIO.effectTotal(println(line))\n```\n\n----------------------------------------\n\nTITLE: Executable Encoding for Effect System in Scala\nDESCRIPTION: Implements an effect system using executable encoding, where operators directly execute the desired operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/functional-design-patterns.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nfinal case class IO[+A](private val thunk: () => A) {\n  def map[B](f: A => B): IO[B]         = IO.succeed(f(thunk()))\n  def flatMap[B](f: A => IO[B]): IO[B] = IO.succeed(f(thunk()).unsafeRunSync())\n  def unsafeRunSync(): A               = thunk()\n}\n\nobject IO {\n  def succeed[A](value: => A): IO[A] = IO(() => value)\n}\n```\n\n----------------------------------------\n\nTITLE: Write Lock Acquisition in Contentious Scenarios in TReentrantLock\nDESCRIPTION: Demonstrates how a fiber must wait for other readers to release their locks before acquiring a write lock. The example shows semantic blocking when trying to upgrade to a write lock with other active readers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.clock._\nimport zio.console._\nimport zio.stm._\nimport zio.duration._\n\nval writeLockDemoProgram: URIO[Console with Clock, Unit] = for {\n  l  <- TReentrantLock.make.commit\n  _  <- putStrLn(\"Beginning test\").orDie\n  f1 <- (l.acquireRead.commit *> ZIO.sleep(5.seconds) *> l.releaseRead.commit).fork\n  f2 <- (l.acquireRead.commit *> putStrLn(\"read-lock\").orDie *> l.acquireWrite.commit *> putStrLn(\"I have upgraded!\").orDie).fork\n  _  <- (f1 zip f2).join\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Using withPermit for Automatic TSemaphore Resource Management\nDESCRIPTION: Shows how to use the withPermit method for cleaner resource management. This approach automatically acquires a permit before executing the provided action and releases it afterwards, simplifying the code and reducing the chance of leaking permits.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tsemaphore.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreWithPermit: IO[Nothing, Unit] =\n  for {\n    sem <- TSemaphore.make(1L).commit\n    a   <- sem.withPermit(yourSTMAction.commit)\n  } yield a\n```\n\n----------------------------------------\n\nTITLE: Collecting Double Elements from Mixed Chunk in Scala\nDESCRIPTION: Uses the collect method to filter and extract only Double values from a Chunk containing mixed types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ncollectChunk.collect { case digit: Double => digit }\n// res2: Chunk[Double] = IndexedSeq(1.5, 2.0, 2.5)\n```\n\n----------------------------------------\n\nTITLE: Importing Cats interop package\nDESCRIPTION: Import statement for accessing ZIO interoperability features with Cats Effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.catz._\n```\n\n----------------------------------------\n\nTITLE: Initializing Counter App Cluster Nodes\nDESCRIPTION: Creates two nodes for the distributed counter application cluster, running on different ports.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject CounterApp1 extends zio.App {\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = \n    CounterApp(\"2551\").counterApp.exitCode\n}\n\nobject CounterApp2 extends zio.App {\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] = \n    CounterApp(\"2552\").counterApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Docusaurus Plugins for Docs Generation  JavaScript\nDESCRIPTION: This JavaScript snippet shows the configuration of the Docusaurus 2 presets array for use in the site generator. It sets up the documentation root, sidebar structure, and includes the Blended Include Code Plugin and the Remark Kroki Plugin for handling code inclusions and generating images from DSL code blocks, respectively. Requires dependencies '@docusaurus/preset-classic', 'blended-include-code-plugin', and 'remark-kroki-plugin', as well as the necessary CSS and sidebar files. Intended to be placed in the Docusaurus configuration file (e.g., docusaurus.config.js).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/README.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\npresets: [\n  [\n    '@docusaurus/preset-classic',\n    {\n      docs: {\n        routeBasePath: '/',\n        sidebarPath: require.resolve('./sidebars.js'),\n        remarkPlugins: [\n          [require('blended-include-code-plugin'), { marker: 'CODE_INCLUDE' }],\n          [require('remark-kroki-plugin'), { krokiBase: 'https://kroki.io', lang: \"kroki\", imgRefDir: \"/img/kroki\", imgDir: \"static/img/kroki\" }]\n        ],\n      },\n      theme: {\n        customCss: [require.resolve('./src/css/custom.css')],\n      },\n    },\n  ],\n],\n```\n\n----------------------------------------\n\nTITLE: Offering Single Element to TQueue in Scala ZIO\nDESCRIPTION: Demonstrates how to add a single element to a bounded TQueue in a transactional context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueOffer: UIO[TQueue[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offer(1)\n} yield tQueue).commit\n```\n\n----------------------------------------\n\nTITLE: Adding scala-java-time Dependencies for Scala.js\nDESCRIPTION: This snippet shows how to add the necessary scala-java-time dependencies for ZIO to work with Scala.js. These dependencies provide implementations for java.time methods that are absent in Scala.js.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/platforms.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  \"io.github.cquiroz\" %%% \"scala-java-time\" % \"2.2.0\",\n  \"io.github.cquiroz\" %%% \"scala-java-time-tzdb\" % \"2.2.0\"\n)\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image (Bash)\nDESCRIPTION: Command to build the Docker image using sbt-native-packager.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt docker:publishLocal\n```\n\n----------------------------------------\n\nTITLE: Stream-based Parallel Processing\nDESCRIPTION: Improved version using ZIO Streams for better pipelining and memory efficiency when processing prime numbers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef prime(number: Int): Task[(Boolean, Int)] = ZIO.succeed(???)\n\nZStream.fromIterable(numbers)\n  .mapZIOParUnordered(20)(prime(_))\n  .filter(_._1).map(_._2)\n  .mapZIOParUnordered(20)(moreHardWork(_))\n```\n\n----------------------------------------\n\nTITLE: Using ZIO's run Method to Handle Exit States in Scala\nDESCRIPTION: This code demonstrates how to use ZIO's run method to convert an effect into an Exit value, and then pattern match on the result to handle both success and failure cases. The example shows how to access the success value or the failure cause.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/exit.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console._\nfor {\n  successExit <- ZIO.succeed(1).run\n  _ <- successExit match {\n    case Exit.Success(value) =>\n      putStrLn(s\"exited with success value: ${value}\")\n    case Exit.Failure(cause) =>\n      putStrLn(s\"exited with failure state: $cause\")\n  }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Completing a TPromise with Failure in ZIO STM\nDESCRIPTION: Shows how to fail a TPromise with an error. The example creates a TPromise and then completes it with a failure using the fail method with a string error message.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpromise.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseFail: UIO[TPromise[String, Int]] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.fail(\"failed\").commit\n} yield tPromise\n```\n\n----------------------------------------\n\nTITLE: Cloning ZIO Quickstarts Repository (Bash)\nDESCRIPTION: Commands to clone the ZIO Quickstarts repository and navigate to the specific project directory for the restful webservice dockerization example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-restful-webservice-dockerize\n```\n\n----------------------------------------\n\nTITLE: Updating TArray Element in Scala ZIO STM\nDESCRIPTION: Demonstrates updating an element at a specific index in a TArray using a transformation function\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tArrayUpdateElem: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.update(2, el => el + 10)\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Composing TestAspects with @@ Operator\nDESCRIPTION: Shows how to compose multiple test aspects using the @@ operator for more concise syntax.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\ntest(\"test\") {\n  assertTrue(true)\n} @@ jvmOnly @@ repeat(Schedule.recurs(5))\n```\n\n----------------------------------------\n\nTITLE: Converting a Chunk to a Seq in Scala\nDESCRIPTION: Shows how to convert a Chunk to a standard Scala Sequence (Seq).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nChunk(1,2,3).toSeq\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Absorb/Resurrect Methods in Scala\nDESCRIPTION: Defines the signatures for `absorb`, `absorbWith`, and `resurrect` methods within the ZIO trait. These methods are used to convert defects back into failures in the error channel, specifically converting them to `Throwable` type. An implicit evidence `E IsSubtypeOfError Throwable` is required for `absorb` and `resurrect`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/converting-defects-to-failures.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def absorb(implicit ev: E IsSubtypeOfError Throwable): ZIO[R, Throwable, A]\n  def absorbWith(f: E => Throwable): ZIO[R, Throwable, A]\n  def resurrect(implicit ev1: E IsSubtypeOfError Throwable): ZIO[R, Throwable, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Individual ZIO Test\nDESCRIPTION: Shows how to ignore a single test case using the TestAspect.ignore annotation. The test will be skipped during test execution regardless of its assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/ignoring-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"an ignored test\") {\n  assertTrue(false)\n} @@ TestAspect.ignore\n```\n\n----------------------------------------\n\nTITLE: Running ShardManager Application for ZIO Shardcake\nDESCRIPTION: This bash command runs the ShardManager application using sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\nsbt \"runMain ShardManagerApp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a Database Connector with Tamer and Doobie\nDESCRIPTION: A complete example of using Tamer to connect to a database, query data with time-based windows, and produce it to Kafka. The code demonstrates defining a data model, setting up JSON encoding/decoding, and configuring a tumbling window for incremental data extraction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tamer.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport tamer._\nimport tamer.db._\n\nimport doobie.implicits.legacy.instant._\nimport doobie.syntax.string._\nimport zio._\nimport zio.duration._\nimport zio.json._\n\nimport java.time.Instant\n\ncase class Row(id: String, name: String, description: Option[String], modifiedAt: Instant)\n    extends tamer.db.Timestamped(modifiedAt)\n\nobject Row {\n  implicit val rowJsonCodec = DeriveJsonCodec.gen[Row]\n}\n\nobject DatabaseSimple extends zio.App {\n  // Here we'll go with zio-json codec, you can use avro, circe and jsoniter\n  // out-of-the box or plug yours!\n  implicit val stateKeyJsonCodec = DeriveJsonCodec.gen[tamer.Tamer.StateKey]\n  implicit val windowJsonCodec = DeriveJsonCodec.gen[tamer.db.Window]\n\n  val program: RIO[ZEnv, Unit] = tamer.db.DbSetup\n    .tumbling(window =>\n      sql\"\"\"SELECT id, name, description, modified_at \n           |FROM users \n           |WHERE modified_at > ${window.from} AND modified_at <= ${window.to}\"\"\".stripMargin\n        .query[Row]\n    )(\n      recordKey = (_, v) => v.id,\n      from = Instant.parse(\"2020-01-01T00:00:00.00Z\"),\n      tumblingStep = 5.days\n    )\n    .runWith(dbLayerFromEnvironment ++ tamer.kafkaConfigFromEnvironment)\n\n  override final def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    program.exitCode\n\n  // If you have other codecs like circe in the classpath you have to disambiguate\n  implicit lazy val stateKeyCodec: Codec[Tamer.StateKey] = Codec.optionalZioJsonCodec\n  implicit lazy val windowCodec: Codec[tamer.db.Window] = Codec.optionalZioJsonCodec\n  implicit lazy val stringCodec: Codec[String] = Codec.optionalZioJsonCodec\n}\n```\n\n----------------------------------------\n\nTITLE: Converting a Chunk to an Array in Scala\nDESCRIPTION: Demonstrates how to convert a Chunk to a standard Scala Array.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nChunk(1,2,3).toArray\n```\n\n----------------------------------------\n\nTITLE: Executing a ZIO Effect with unsafeRun using Default Runtime in Scala\nDESCRIPTION: Illustrates how to execute a ZIO effect (`ZIO(println(\"Hello World!\"))`) synchronously using the `unsafeRun` method on a `Runtime` instance (typically the `Runtime.default` obtained previously). This method is intended for integration points with non-ZIO code and should be used cautiously as it blocks the calling thread until the effect completes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/running_effects.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nruntime.unsafeRun(ZIO(println(\"Hello World!\")))\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Service Accessors in Scala ZIO\nDESCRIPTION: Implementation of accessor methods that allow accessing services from the ZIO environment using ZIO.accessM. These methods provide a convenient way to use services in ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject Logging {\n  def log(line: String): ZIO[Logging, Nothing, Unit] = ZIO.accessM[Logging](_.log(line))\n}\n\nobject RandomInt {\n  val random: ZIO[RandomInt, Nothing, Int] = ZIO.accessM[RandomInt](_.random)\n}\n```\n\n----------------------------------------\n\nTITLE: Scope Usage Interface Definition in Scala\nDESCRIPTION: Defines the interface for using scopes, showing the relationship between Closeable trait and ZIO.scoped operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/scope.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ntrait Closeable extends Scope {\n  def use[R, E, A](zio: => ZIO[R with Scope, E, A]): ZIO[R, E, A]\n}\n\nobject ZIO {\n  def scoped[R, E, A](zio: => ZIO[R with Scope, E, A]): ZIO[R, E, A] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with SBT\nDESCRIPTION: Required dependencies for building a GraphQL service with ZIO and Caliban\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_0\n\nLANGUAGE: sbt\nCODE:\n```\nlibraryDependencies ++= Seq(\n  \"dev.zio\"               %% \"zio\"              % \"2.1.7\",\n  \"com.github.ghostdogpr\" %% \"caliban-quick\"    % \"2.8.1\"\n)\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Tests with SBT Commands\nDESCRIPTION: These commands demonstrate how to run all tests or a specific test using SBT with ZTestFramework.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/running-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsbt test                      // run all tests\nsbt testOnly HelloWorldSpec   // run a specific test\n```\n\n----------------------------------------\n\nTITLE: ZIO Kafka Producer/Consumer Example\nDESCRIPTION: Example demonstrating Kafka producer and consumer implementation using ZIO Kafka with ZIO Streams\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console.putStrLn\nimport zio.duration.durationInt\nimport zio.kafka.consumer.{Consumer, ConsumerSettings, _}\nimport zio.kafka.producer.{Producer, ProducerSettings}\nimport zio.kafka.serde._\nimport zio.stream.ZStream\n\nobject ZIOKafkaProducerConsumerExample extends zio.App {\n  val producer =\n    ZStream\n      .repeatEffect(zio.random.nextIntBetween(0, Int.MaxValue))\n      .schedule(Schedule.fixed(2.seconds))\n      .mapM { random =>\n        Producer.produce[Any, Long, String](\n          topic = \"random\",\n          key = random % 4,\n          value = random.toString,\n          keySerializer = Serde.long,\n          valueSerializer = Serde.string\n        )\n      }\n      .drain\n\n  val consumer =\n    Consumer\n      .subscribeAnd(Subscription.topics(\"random\"))\n      .plainStream(Serde.long, Serde.string)\n      .tap(r => putStrLn(r.value))\n      .map(_.offset)\n      .aggregateAsync(Consumer.offsetBatches)\n      .mapM(_.commit)\n      .drain\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    producer\n      .merge(consumer)\n      .runDrain\n      .provideCustomLayer(appLayer)\n      .exitCode\n\n  def producerLayer = ZLayer.fromManaged(\n    Producer.make(\n      settings = ProducerSettings(List(\"localhost:29092\"))\n    )\n  )\n\n  def consumerLayer = ZLayer.fromManaged(\n    Consumer.make(\n      ConsumerSettings(List(\"localhost:29092\")).withGroupId(\"group\")\n    )\n  )\n\n  def appLayer = producerLayer ++ consumerLayer\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Quill ZIO Dependencies to build.sbt\nDESCRIPTION: SBT dependencies for adding Quill ZIO integration to a project. These libraries provide Quill contexts for ZIO that can execute queries for various databases inside ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_50\n\nLANGUAGE: scala\nCODE:\n```\n// Provides Quill contexts for ZIO.\nlibraryDependencies += \"io.getquill\" %% \"quill-zio\" % \"3.9.0\"\n\n// Provides Quill context that execute MySQL, PostgreSQL, SQLite, H2, SQL Server and Oracle queries inside of ZIO.\nlibraryDependencies += \"io.getquill\" %% \"quill-jdbc-zio\" % \"3.9.0\" \n\n// Provides Quill context that executes Cassandra queries inside of ZIO.\nlibraryDependencies += \"io.getquill\" %% \"quill-cassandra-zio\" % \"3.9.0\"\n```\n\n----------------------------------------\n\nTITLE: Defining sized Method in Gen Object\nDESCRIPTION: Signature of the sized method in the Gen object, used to create sized generators.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/sized.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject Gen {\n  def sized[R, A](f: Int => Gen[R, A]): Gen[R, A] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO AMQP Dependency in SBT\nDESCRIPTION: Shows how to add the ZIO AMQP library dependency to a Scala project's build.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-amqp.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"nl.vroste\" %% \"zio-amqp\" % \"0.3.0\"\n```\n\n----------------------------------------\n\nTITLE: Implementing withSize Method in Sized Object\nDESCRIPTION: Signature of the withSize method in the Sized object, used to run an effect with a specific size.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/sized.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nobject Sized {\n  def withSize[R, E, A](size: Int)(zio: ZIO[R, E, A]): ZIO[R, E, A] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring build.sbt for ZIO gRPC\nDESCRIPTION: Build configuration for a ZIO gRPC project. Sets up code generation targets and adds necessary dependencies for gRPC and ScalaPB runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-grpc.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nPB.targets in Compile := Seq(\n  scalapb.gen(grpc = true) -> (sourceManaged in Compile).value / \"scalapb\",\n  scalapb.zio_grpc.ZioCodeGenerator -> (sourceManaged in Compile).value / \"scalapb\"\n)\n\nlibraryDependencies ++= Seq(\n  \"io.grpc\" % \"grpc-netty\" % \"1.39.0\",\n  \"com.thesamet.scalapb\" %% \"scalapb-runtime-grpc\" % scalapb.compiler.Version.scalapbVersion\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a gRPC Service with Protocol Buffers\nDESCRIPTION: Protocol Buffer definition for a simple greeting service. Defines the service interface, request and response messages for a 'Greeter' service with a 'SayHello' RPC method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-grpc.md#2025-04-23_snippet_2\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\n// The greeting service definition.\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Supervisor with Initial Fibers in Scala\nDESCRIPTION: Creates a new supervisor with an initial sorted set of fibers using fibersIn method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/supervisor.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef fiberListSupervisor = for { \n  ref <- Ref.make(SortedSet.from(fibers))\n  s <- Supervisor.fibersIn(ref)\n} yield (s)\n```\n\n----------------------------------------\n\nTITLE: Creating TArray with Specified Values in Scala ZIO STM\nDESCRIPTION: Shows how to initialize a TArray with predefined integer values using STM transactions\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval specifiedValuesTArray: STM[Nothing, TArray[Int]] = TArray.make(1, 2, 3)\n```\n\n----------------------------------------\n\nTITLE: Writing Property-Based Test for Reverse Function in ZIO Test\nDESCRIPTION: This snippet demonstrates how to write a property-based test using ZIO Test. It checks if reversing a list twice returns the original list.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/shrinking.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nsuite(\"ReverseSpec\"){\n  //  xs. reverse(reverse(xs)) == xs\n  test(\"reversing a list twice must give the original list\")(\n    check(Gen.listOf(Gen.int)) { list =>\n      assertTrue(reverse(reverse(list)) == list)\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Dying Effect Idioms - Recommended and Not Recommended Usages - Scala\nDESCRIPTION: Shows idiomatic and non-idiomatic ways to create a dying effect. 'defect1' directly constructs an ArithmeticException and passes it to ZIO.die (recommended). 'defect2' throws an exception in the constructor argument (not recommended). Requires zio._. Demonstrates best practices for using ZIO.die.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval defect1 = ZIO.die(new ArithmeticException(\"divide by zero\"))       // recommended\nval defect2 = ZIO.die(throw new ArithmeticException(\"divide by zero\")) // not recommended\n```\n\n----------------------------------------\n\nTITLE: Defining UManaged Type Alias in Scala\nDESCRIPTION: The definition of `UManaged[A]` as a type alias for `ZManaged[Any, Nothing, A]`, representing an unexceptional managed resource that doesn't require any specific environment and cannot fail, but can succeed with a value of type A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/umanaged.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype UManaged[+A] = ZManaged[Any, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Taking Elements from ZIO Streams\nDESCRIPTION: Shows different ways to take elements from a stream using take, takeWhile, takeUntil, and takeRight operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_27\n\nLANGUAGE: scala\nCODE:\n```\nval stream = ZStream.iterate(0)(_ + 1)\nval s1 = stream.take(5)\n// Output: 0, 1, 2, 3, 4\n\nval s2 = stream.takeWhile(_ < 5)\n// Output: 0, 1, 2, 3, 4\n\nval s3 = stream.takeUntil(_ == 5)\n// Output: 0, 1, 2, 3, 4, 5\n\nval s4 = s3.takeRight(3)\n// Output: 3, 4, 5\n```\n\n----------------------------------------\n\nTITLE: Configuring Parallel Test Execution in ZIO Test\nDESCRIPTION: Demonstrates how to explicitly configure parallel test execution using TestAspect.parallel. Tests are executed concurrently by default, with different delay times to show asynchronous execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/execution-strategy.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\nsuite(\"Parallel\")(\n  test(\"A\")(Live.live(ZIO.attempt(\"Running Test A\").delay(1.second)).debug.map(_ => assertTrue(true))),\n  test(\"B\")(ZIO.attempt(\"Running Test B\").debug.map(_ => assertTrue(true))),\n  test(\"C\")(Live.live(ZIO.attempt(\"Running Test C\").delay(500.millis)).debug.map(_ => assertTrue(true)))\n) @@ TestAspect.parallel\n```\n\n----------------------------------------\n\nTITLE: Custom Encoder/Decoder Implementation\nDESCRIPTION: Example of manually implementing JSON encoder and decoder for a Person class\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.json._\nimport zio.json.internal.{Write, RetractReader}\n\ncase class Person(name: String, age: Int)\n\nobject Person {\n  implicit val encoder: JsonEncoder[Person] =\n    new JsonEncoder[Person] {\n      override def unsafeEncode(a: Person, indent: Option[Int], out: Write): Unit = ???\n    }\n  implicit val decoder: JsonDecoder[Person] =\n    new JsonDecoder[Person] {\n      override def unsafeDecode(trace: List[JsonError], in: RetractReader): Person = ???\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Debugging Stackless Cause in Scala\nDESCRIPTION: Shows examples of Stackless causes in ZIO, comparing the stack trace output of ZIO.dieMessage (which uses Stackless) and ZIO.die.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/cause.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nZIO.dieMessage(\"Boom!\").cause.debug\n// Stackless(Die(java.lang.RuntimeException: Boom!,Trace(Runtime(2,1646477970),Chunk(<empty>.MainApp.run(MainApp.scala:3)))),true)\n\nZIO.die(new Throwable(\"Boom!\")).cause.debug\n// Die(java.lang.Exception: Boom!,Trace(Runtime(2,1646479093),Chunk(<empty>.MainApp.run(MainApp.scala:3))))\n```\n\n----------------------------------------\n\nTITLE: Custom FiberRef Merge Strategy\nDESCRIPTION: Shows how to customize the merge behavior when joining fibers using a custom join function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiberRef <- FiberRef.make(initial = 0, join = math.max)\n  child    <- fiberRef.update(_ + 1).fork\n  _        <- fiberRef.update(_ + 2)\n  _        <- child.join\n  value    <- fiberRef.get\n} yield assert(value == 2)\n```\n\n----------------------------------------\n\nTITLE: Contentious Write Lock Acquisition in Scala\nDESCRIPTION: Shows how write lock acquisition blocks when other readers hold the lock, demonstrating lock contention handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/treentrantlock.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.Console._\nimport zio.stm._\n\nval writeLockDemoProgram: UIO[Unit] = for {\n  l  <- TReentrantLock.make.commit\n  _  <- printLine(\"Beginning test\").orDie\n  f1 <- (l.acquireRead.commit *> ZIO.sleep(5.seconds) *> l.releaseRead.commit).fork\n  f2 <- (l.acquireRead.commit *> printLine(\"read-lock\").orDie *> l.acquireWrite.commit *> printLine(\"I have upgraded!\").orDie).fork\n  _  <- (f1 zip f2).join\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining Impure Command with Future in Scala\nDESCRIPTION: This snippet demonstrates how to define a command-like method in Scala using the standard library's Future to encapsulate an impure operation (printing to the console). It shows the function signature returning Future[Unit] to represent asynchronous side effects. Requires Scala's concurrency runtime. Inputs: 'event' of type Event. Output: Future[Unit], encapsulating the effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport scala.concurrent.Future\n\ndef processEvent(event: Event): Future[Unit] = Future(println(s\"Got $event\"))\n```\n\n----------------------------------------\n\nTITLE: ZIO 1.x Default Services Example\nDESCRIPTION: Example showing how default services were used in ZIO 1.x, demonstrating the environment requirements for Clock, Console and Random services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.clock.Clock\nimport zio.duration.durationInt\nimport zio.random.Random\nimport java.io.IOException\nimport zio.console._\n\nobject MainApp extends App {\n  val myApp: ZIO[Clock with Console with Random, IOException, Unit] =\n    for {\n      rnd <- random.nextIntBounded(100)\n      _   <- console.putStrLn(s\"Random number: $rnd\")\n      _   <- clock.sleep(1.second)\n    } yield ()\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.forever.exitCode  \n    // or we can provide our own implementation \n    // myApp.forever.provideLayer(Console.live ++ Clock.live ++ Random.live).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Counter HTTP API with Sample Requests (HTTP)\nDESCRIPTION: These HTTP requests simulate user interactions with the REST API, sending Inc and Dec commands to the FooCounter entity with unique command IDs. Each GET request triggers a command via the HTTP/ZIO backend, and demonstrates idempotency and backend command deduplication. Inputs are the API routes; outputs are effects handled by the ZIO/Edomata backend.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_20\n\nLANGUAGE: http\nCODE:\n```\nGET /FooCounter/inc/cf2209c9-6b41-44da-8c52-7e0dce109dc3\nGET /FooCounter/inc/11aa920d-254e-4aa7-86f2-8002df80533b\nGET /FooCounter/dec/b2e8a02c-77db-463d-8213-d462fc5a9439\nGET /FooCounter/inc/9ac51e44-36d0-4daa-ac23-28e624bec174\n```\n\n----------------------------------------\n\nTITLE: Declaring Error Mapping Methods in ZIO Trait - Scala\nDESCRIPTION: Declares the ZIO trait methods mapError and mapErrorCause, which enable transformation of the error channel or the entire error cause in ZIO effects. No concrete implementation is provided; only the method signatures are shown. Dependencies: None explicitly required for the trait, but the Cause type is referenced; Affects the ZIO effect's typing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def mapError[E2](f: E => E2): ZIO[R, E2, A]\n  def mapErrorCause[E2](h: Cause[E] => Cause[E2]): ZIO[R, E2, A]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Inefficient User Data Retrieval in ZIO\nDESCRIPTION: Demonstrates a typical but inefficient approach to retrieving user data from a database. This code would result in N+1 queries, which ZIO Query can optimize.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nval userNames = for {\n  ids   <- getAllUserIds\n  names <- ZIO.foreachPar(ids)(getUserNameById)\n} yield names\n```\n\n----------------------------------------\n\nTITLE: Defining URLayer Type Alias in Scala\nDESCRIPTION: Defines URLayer as a type alias for ZLayer that represents a layer with input type RIn, no failure case (Nothing), and output type ROut. This type is used for layers that cannot fail during their execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/urlayer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype URLayer[-RIn, +ROut] = ZLayer[RIn, Nothing, ROut]\n```\n\n----------------------------------------\n\nTITLE: Creating ZStreams from Managed Iterators in Scala\nDESCRIPTION: Demonstrates how to convert a managed iterator to a ZIO Stream using ZStream.fromIteratorManaged.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval lines: ZStream[Any, Throwable, String] = \n  ZStream.fromIteratorManaged(\n    ZManaged.fromAutoCloseable(\n      Task(scala.io.Source.fromFile(\"file.txt\"))\n    ).map(_.getLines())\n  )\n```\n\n----------------------------------------\n\nTITLE: Defining Domain Error Types Using Sealed Traits and Case Classes - Scala\nDESCRIPTION: Defines a sealed supertype for domain error modeling using ADTs in Scala. The snippet declares a sealed trait 'UserServiceError' extending Exception, and two error case classes 'InvalidUserId' and 'ExpiredAuth' with an ID parameter. Dependencies: knowledge of Scala, sealed traits, and case classes. Inputs are IDs for the error instances. Outputs are strongly-typed error values that can be handled exhaustively in match statements. This pattern constrains error handling to known types within the domain and improves compile-time safety.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/algebraic-data-types.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait UserServiceError extends Exception\n\ncase class InvalidUserId(id: ID) extends UserServiceError\ncase class ExpiredAuth(id: ID)   extends UserServiceError\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Test as a Library Dependency (Scala)\nDESCRIPTION: Shows how to add the zio-test library to project dependencies for enabling macro-generated mocks and capability tags, a prerequisite for using @mockable annotation for testing. This prepares the project for mock layer generation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-test\" % \"<zio-version>\"\n```\n\n----------------------------------------\n\nTITLE: Asserting Try is Failure with Condition in Scala\nDESCRIPTION: Creates an assertion `Assertion[Try[Any]]` that checks if a `scala.util.Try` is a `Failure`. It requires the `Throwable` within the `Failure` to satisfy the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nisFailure(assertion: Assertion[Throwable])\n```\n\n----------------------------------------\n\nTITLE: Implementing Retrying Money Transfer using STM.retry\nDESCRIPTION: Shows how to implement a money transfer that retries until sufficient funds are available instead of failing immediately. Uses STM.retry for blocking until conditions are met.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/stm.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef transferMoneyNoMatterWhat(from: TRef[Long], to: TRef[Long], amount: Long): STM[String, Long] =\n  for {\n    senderBal <- from.get\n    _         <- if (senderBal < amount) STM.retry else STM.unit\n    _         <- from.update(existing => existing - amount)\n    _         <- to.update(existing => existing + amount)\n    recvBal   <- to.get\n  } yield recvBal\n```\n\n----------------------------------------\n\nTITLE: Mutable State Counter Example in Scala\nDESCRIPTION: Demonstrates a traditional mutable state approach using var for generating unique variable names with a counter.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nvar idCounter = 0\ndef freshVar: String = {\n  idCounter += 1\n  s\"var${idCounter}\"\n}\nval v1 = freshVar\nval v2 = freshVar\nval v3 = freshVar\n```\n\n----------------------------------------\n\nTITLE: Updating an Element in a TArray with STM Effect in ZIO (Scala)\nDESCRIPTION: Updates the element at index 2 using an STM effect. The updateSTM method allows for more complex transactional updates where the new value depends on the result of other transactional operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tarray.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tArrayUpdateMElem: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.updateSTM(2, el => STM.succeed(el + 10))\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Configuring sbt-protoc Plugin for ZIO gRPC in project/plugins.sbt\nDESCRIPTION: SBT plugin configuration required for ZIO gRPC. Adds the protoc plugin and the ZIO gRPC code generator dependency to enable gRPC code generation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-grpc.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"com.thesamet\" % \"sbt-protoc\" % \"1.0.2\")\n\nlibraryDependencies +=\n  \"com.thesamet.scalapb.zio-grpc\" %% \"zio-grpc-codegen\" % \"0.5.0\"\n```\n\n----------------------------------------\n\nTITLE: Getting Current Time with ZIO Clock Service\nDESCRIPTION: Demonstrates how to use the Clock service to get the current time in different time units. The examples show retrieving time in milliseconds and days using the currentTime function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/clock.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval inMiliseconds: URIO[Clock, Long] = currentTime(TimeUnit.MILLISECONDS)\nval inDays: URIO[Clock, Long] = currentTime(TimeUnit.DAYS)\n```\n\n----------------------------------------\n\nTITLE: Checking Element Membership in a TSet in Scala ZIO STM\nDESCRIPTION: Checks whether a specific element is present in a TSet using the contains method. Returns a boolean result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSetContainsElem: UIO[Boolean] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  res  <- tSet.contains(3)\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Creating Example Reactive Streams Publisher and Subscriber in Scala\nDESCRIPTION: Defines a `RangePublisher` that emits integers from 3 up to (but not including) 10 and a `SyncSubscriber` that prints received integers to the console. These instances serve as basic Reactive Streams components for use in subsequent interoperability examples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-reactive-streams.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval publisher = new RangePublisher(3, 10)\nval subscriber = new SyncSubscriber[Int] {\n  override protected def whenNext(v: Int): Boolean = {\n    print(s\"$v, \")\n    true\n  }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Console Output for NumberFormatException Defect - Scala\nDESCRIPTION: Provides sample console output showing the crash and stack trace when a non-integer string (\"five\") is parsed using String#toInt in a ZIO effect with error type Nothing. Intended to exemplify the program crash and defect reporting behavior. This output is not executable code but represents what a user would see in the terminal.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nPlease enter a number: five\ntimestamp=2022-03-17T14:01:33.323639073Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.NumberFormatException: For input string: \\\"five\\\"\n\\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)\n\\tat java.base/java.lang.Integer.parseInt(Integer.java:660)\n\\tat java.base/java.lang.Integer.parseInt(Integer.java:778)\n\\tat scala.collection.StringOps$.toInt$extension(StringOps.scala:910)\n\\tat MainApp$.$anonfun$myApp$3(MainApp.scala:7)\n\\tat MainApp$.$anonfun$myApp$3$adapted(MainApp.scala:7)\n\\tat zio.ZIO.$anonfun$map$1(ZIO.scala:1168)\n\\tat zio.ZIO$FlatMap.apply(ZIO.scala:6182)\n\\tat zio.ZIO$FlatMap.apply(ZIO.scala:6171)\n\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:885)\n\\tat zio.internal.FiberContext.run(FiberContext.scala:115)\n\\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\n\\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)\n\\tat java.base/java.lang.Thread.run(Thread.java:831)\n\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:538)\n\\tat <empty>.MainApp.myApp(MainApp.scala:8)\n\\tat <empty>.MainApp.myApp(MainApp.scala:9)\"\n\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty Chunk in Scala\nDESCRIPTION: Creates an empty Chunk instance with no elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval emptyChunk = Chunk.empty\n```\n\n----------------------------------------\n\nTITLE: ZIO Effect Generators\nDESCRIPTION: Various generators for ZIO effects including successes, failures, and died effects\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval gen: Gen[Any, UIO[Int]] = Gen.successes(Gen.int(-10, 10))\n```\n\nLANGUAGE: scala\nCODE:\n```\nval gen: Gen[Any, IO[String, Nothing]] = Gen.failures(Gen.string)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval gen: Gen[Any, UIO[Nothing]] = Gen.died(Gen.throwable)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval causes: Gen[Any, Cause[String]] = \n    Gen.causes(Gen.string, Gen.throwable)\n```\n\n----------------------------------------\n\nTITLE: Creating a TMap from an Iterable Collection in ZIO STM\nDESCRIPTION: Creates a TMap from an iterable collection of key-value tuples. This allows initializing a transactional map from an existing collection like a List.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval iterableTMap: STM[Nothing, TMap[String, Int]] = TMap.fromIterable(List((\"a\", 1), (\"b\", 2), (\"c\", 3)))\n```\n\n----------------------------------------\n\nTITLE: Cycling CyclicBarrier\nDESCRIPTION: Shows how to reuse a CyclicBarrier after it has been released. Creates a barrier for 2 parties and demonstrates it can be used for multiple cycles.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/cyclicbarrier.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.CyclicBarrier\n\nfor {\n  barrier <- CyclicBarrier.make(2)\n  f1      <- barrier.await.fork\n  _       <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  f2      <- barrier.await.fork\n  ticket1 <- f1.join\n  ticket2 <- f2.join\n  f3      <- barrier.await.fork\n  _       <- f3.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  f4      <- barrier.await.fork\n  ticket3 <- f3.join\n  ticket4 <- f4.join\n} yield assert(ticket1 == 1 && ticket2 == 0 && ticket3 == 1 && ticket4 == 0)\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Process in SBT\nDESCRIPTION: Adds the ZIO Process library dependency to a Scala project's build.sbt file. ZIO Process provides functionality for interacting with external processes and command-line programs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_29\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-process\" % \"0.5.0\" \n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Test JUnit Runner Dependency in Scala\nDESCRIPTION: This snippet shows how to add the ZIO Test JUnit runner dependency to the build tool configuration. It's necessary for integrating ZIO Test with JUnit.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/junit-integration.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-test-junit\" % zioVersion % \"test\"\n```\n\n----------------------------------------\n\nTITLE: Tagging Tests in ZIO Test Framework\nDESCRIPTION: Demonstrates how to tag tests with custom labels for categorization and selective execution. The example shows tagging tests with 'slow' and 'math' tags and creating a test suite that can be filtered by these tags.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/annotating-tests.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\nobject TaggedSpecsExample extends ZIOSpecDefault {\n  def spec =\n    suite(\"a suite containing tagged tests\")(\n      test(\"a slow test\") {\n        longRunningAssertion\n      } @@ TestAspect.tag(\"slow\", \"math\"),\n      test(\"a simple test\") {\n        assertTrue(1 + 1 == 2)\n      } @@ TestAspect.tag(\"math\"),\n      test(\"another slow test\") {\n        anotherLongRunningAssertion\n      } @@ TestAspect.tag(\"slow\")\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO gRPC in Scala Build\nDESCRIPTION: Shows how to configure ZIO gRPC in a Scala build.sbt file, including adding the necessary plugins and dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"com.thesamet\" % \"sbt-protoc\" % \"1.0.2\")\n\nlibraryDependencies +=\n  \"com.thesamet.scalapb.zio-grpc\" %% \"zio-grpc-codegen\" % \"0.5.0\"\n\nPB.targets in Compile := Seq(\n  scalapb.gen(grpc = true) -> (sourceManaged in Compile).value / \"scalapb\",\n  scalapb.zio_grpc.ZioCodeGenerator -> (sourceManaged in Compile).value / \"scalapb\"\n)\n\nlibraryDependencies ++= Seq(\n  \"io.grpc\" % \"grpc-netty\" % \"1.39.0\",\n  \"com.thesamet.scalapb\" %% \"scalapb-runtime-grpc\" % scalapb.compiler.Version.scalapbVersion\n)\n```\n\n----------------------------------------\n\nTITLE: Creating build.sbt File in Bash\nDESCRIPTION: Command to create an empty build.sbt file for the Scala project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/run-our-first-zio-project-with-vscode.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ntouch build.sbt\n```\n\n----------------------------------------\n\nTITLE: Custom Clock Implementation in ZIO 2.x\nDESCRIPTION: Example showing how to implement and use a custom Clock service in ZIO 2.x using withClock combinator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MyClockLive extends Clock {\n  ... \n}\n\nZIO.withClock(MyClockLive)(effect)\n```\n\n----------------------------------------\n\nTITLE: ZStream Success and Failure Examples in Scala\nDESCRIPTION: Demonstrates creating ZStreams using fail and succeed methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval s1: ZStream[Any, String, Nothing] = ZStream.fail(\"Uh oh!\")\nval s2: ZStream[Any, Nothing, Int]    = ZStream.succeed(5)\n```\n\n----------------------------------------\n\nTITLE: Viewing Workflow Execution with Temporal CLI\nDESCRIPTION: Example of using the Temporal CLI (tctl) to view the details of a completed workflow execution. Shows the workflow timeline and results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-temporal.md#2025-04-23_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n tctl workflow observe --workflow_id echo-81ef73da-d54d-492a-8f91-78e888dcebc8\nProgress:\n  1, 2023-04-18T20:34:00Z, WorkflowExecutionStarted\n  2, 2023-04-18T20:34:00Z, WorkflowTaskScheduled\n  3, 2023-04-18T20:34:00Z, WorkflowTaskStarted\n  4, 2023-04-18T20:34:00Z, WorkflowTaskCompleted\n  5, 2023-04-18T20:34:00Z, WorkflowExecutionCompleted\n\nResult:\n  Run Time: 1 seconds\n  Status: COMPLETED\n  Output: [\"ACK: testMsg\"]\n```\n\n----------------------------------------\n\nTITLE: Making a GraphQL Request Using cURL\nDESCRIPTION: A curl command to execute a GraphQL query against the Caliban server endpoint, demonstrating how to structure the HTTP request for the API.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/caliban.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl 'http://localhost:8088/api/graphql' --data-binary '{\"query\":\"query{\\n employees(role: SoftwareDeveloper){\\n name\\n role\\n}\\n}\"}\n```\n\n----------------------------------------\n\nTITLE: Retrieving System Properties with ZIO\nDESCRIPTION: This snippet shows how to use the `property` function to retrieve a system property named 'LOG_LEVEL'. It handles both cases where the property exists or is not set.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/services/system.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  user <- property(\"LOG_LEVEL\")\n  _ <- user match {\n    case Some(value) => putStr(s\"The LOG_LEVEL property is: $value\")\n    case None => putStr(\"Oops! The LOG_LEVEL property is not set\")\n  }\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Taking Multiple Elements from TQueue in Scala ZIO\nDESCRIPTION: Retrieves up to a specified number of elements from a TQueue in a single transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueTakeUpTo: UIO[List[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](4)\n  _      <- tQueue.offerAll(List(1, 2))\n  res    <- tQueue.takeUpTo(3)\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: Creating TSemaphore in Scala ZIO\nDESCRIPTION: Demonstrates how to create a TSemaphore instance with a specified number of permits using STM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tsemaphore.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreCreate: STM[Nothing, TSemaphore] = TSemaphore.make(10L)\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO for URIO Definition in Scala\nDESCRIPTION: This snippet imports the ZIO class, which is necessary for defining the URIO type alias.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/urio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.ZIO\n```\n\n----------------------------------------\n\nTITLE: Creating Successful ZIO Effects with ZIO.succeed in Scala\nDESCRIPTION: Illustrates using `ZIO.succeed` to create a ZIO effect that immediately succeeds with the provided value (42). This effect has no requirements for its environment (`Any`) and is guaranteed not to fail (`Nothing`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/zio.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval s1 = ZIO.succeed(42)\n```\n\n----------------------------------------\n\nTITLE: Selecting the Core JVM Project in SBT\nDESCRIPTION: SBT command to focus on the coreJVM project, which is the main JVM implementation of ZIO. This narrows your build context to work specifically on the core library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nproject coreJVM\n```\n\n----------------------------------------\n\nTITLE: JsonEncoder and JsonDecoder Trait Definitions\nDESCRIPTION: Core trait definitions for JSON encoding and decoding functionality\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait JsonDecoder[A] {\n  def decodeJson(str: CharSequence): Either[String, A]\n}\n\ntrait JsonEncoder[A] {\n  def encodeJson(a: A): CharSequence\n}\n```\n\n----------------------------------------\n\nTITLE: Adding an Element to a TSet in Scala ZIO STM\nDESCRIPTION: Demonstrates how to add a new element to a TSet. If the set already contains the element, no modification occurs. The operation is committed to make it execute.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval putElem: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2)\n  _    <- tSet.put(3)\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: CountdownLatch Core Operations in Scala ZIO\nDESCRIPTION: Core operations available on CountdownLatch including countDown to decrement the counter and await to wait for zero count.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/countdownlatch.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nclass CountdownLatch {\n  val countDown: UIO[Unit]\n  val await: UIO[Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: File Reading with use Method\nDESCRIPTION: Example of using the use method to safely read from a file using ZManaged.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef firstLine(file: String): ZIO[Console, Throwable, Unit] =\n  ZManaged.fromAutoCloseable(ZIO.effect(fromFile(file))).use { reader =>\n    putStrLn(reader.bufferedReader().readLine())\n  }\n```\n\n----------------------------------------\n\nTITLE: Manual TSemaphore Permit Management in Scala ZIO\nDESCRIPTION: Demonstrates manual acquire and release of permits when executing an STM action.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tsemaphore.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\ndef yourSTMAction: STM[Nothing, Unit] = STM.unit\n\nval tSemaphoreWithoutPermit: STM[Nothing, Unit] = \n  for {\n    sem <- TSemaphore.make(1L)\n    _   <- sem.acquire\n    a   <- yourSTMAction\n    _   <- sem.release\n  } yield a\n\ntSemaphoreWithoutPermit.commit\n```\n\n----------------------------------------\n\nTITLE: Redis Operations with ZIO Redis\nDESCRIPTION: Example of using ZIO Redis to interact with a Redis database. It demonstrates providing the RedisExecutor layer and performing various Redis operations like set, get, hash sets, and list/set operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_35\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console.{Console, putStrLn}\nimport zio.duration._\nimport zio.logging.Logging\nimport zio.redis._\nimport zio.redis.codec.StringUtf8Codec\nimport zio.schema.codec.Codec\nimport zio.{ExitCode, URIO, ZIO, ZLayer}\n\nobject ZIORedisExample extends zio.App {\n\n  val myApp: ZIO[Console with RedisExecutor, RedisError, Unit] = for {\n    _ <- set(\"myKey\", 8L, Some(1.minutes))\n    v <- get[String, Long](\"myKey\")\n    _ <- putStrLn(s\"Value of myKey: $v\").orDie\n    _ <- hSet(\"myHash\", (\"k1\", 6), (\"k2\", 2))\n    _ <- rPush(\"myList\", 1, 2, 3, 4)\n    _ <- sAdd(\"mySet\", \"a\", \"b\", \"a\", \"c\")\n  } yield ()\n\n  val layer: ZLayer[Any, RedisError.IOError, RedisExecutor] =\n    Logging.ignore ++ ZLayer.succeed(RedisConfig.Default) ++ ZLayer.succeed(StringUtf8Codec) >>> RedisExecutor.live\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideCustomLayer(layer).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Updating ZIO Dependencies to 2.x in build.sbt\nDESCRIPTION: Update ZIO library dependencies in build.sbt to version 2.0.0 after running the Scalafix migration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio\"         % \"2.0.0\"\nlibraryDependencies += \"dev.zio\" %% \"zio-streams\" % \"2.0.0\"\nlibraryDependencies += \"dev.zio\" %% \"zio-test\"    % \"2.0.0\"\n```\n\n----------------------------------------\n\nTITLE: Direct Usage of ZIO Environment for Business Logic - Scala\nDESCRIPTION: Presents an alternative to encapsulating business logic as a service, showing how to write business logic directly as a ZIO workflow dependent on HighLevelService. Uses serviceWithZIO to access service methods and provides implementation wiring directly in the run value of the ZIOAppDefault object. Dependencies are supplied directly via provide, illustrating flexible composition. Note: The code contains a presumed typo (HighLevelSevice instead of HighLevelService) and assumes presence of otherLogicHere.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zio-environment-use-cases.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nobject Main extends ZIOAppDefault {\n\n  val myProgramLogic: ZIO[HighLevelService, Nothing, Unit] =\n    for {\n      _ <- ZIO.serviceWithZIO[HighLevelService](_.doSomething)\n      - <- otherLogicHere\n    } yield ()\n\n  val run =\n    myProgramLogic.provide(\n      HighLevelSevice.live,\n      LowLevelService.live\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Unsafe State Management in Concurrent Scala Applications\nDESCRIPTION: Demonstrates an unsafe way to manage state in concurrent applications by composing get and set operations, which can lead to race conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n// Unsafe State Management\nobject UnsafeCountRequests extends ZIOAppDefault {\n\n  def request(counter: Ref[Int]) = for {\n    current <- counter.get\n    _ <- counter.set(current + 1)\n  } yield ()\n\n  private val initial = 0\n  private val myApp =\n    for {\n      ref <- Ref.make(initial)\n      _ <- request(ref) zipPar request(ref)\n      rn <- ref.get\n      _ <- Console.printLine(s\"total requests performed: $rn\")\n    } yield ()\n\n  def run = myApp\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Services from Combined Has Environment in Scala ZIO\nDESCRIPTION: Demonstrates how to extract individual service implementations from a combined Has environment using the get method. This shows the type-safe retrieval of services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// get back the Logging and RandomInt services from the combined values:\nval logger: Logging   = combined.get[Logging]\nval random: RandomInt = combined.get[RandomInt]\n```\n\n----------------------------------------\n\nTITLE: Comparing Chunks in Scala\nDESCRIPTION: Demonstrates how to compare two Chunks for equality using the == operator. Chunks are equal if they contain the same elements in the same order.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nChunk(\"A\",\"B\") == Chunk(\"A\", \"C\")\n// res7: Boolean = false\n```\n\n----------------------------------------\n\nTITLE: Implementing Fibonacci Function with ZIO\nDESCRIPTION: A recursive implementation of the Fibonacci function using ZIO effects, demonstrating how to build a computation using functional effects in ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/debug-a-zio-application.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef fib(n: Int): ZIO[Any, Nothing, Int] = {\n  if (n <= 1) ZIO.succeed(n)\n  else fib(n - 1).zipWith(fib(n - 2))(_ + _)\n}\n```\n\n----------------------------------------\n\nTITLE: Failed Dependency Injection Example in Scala\nDESCRIPTION: Demonstrates an incorrect approach to dependency injection that fails due to type mismatch between Counter and UIO[Counter].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/motivation.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval scalaFormatter = new ScalaFormatter() // Creating Formatter\nval scalaCompiler  = new ScalaCompiler()  // Creating Compiler\nval myEditor       =                      // Assembling Formatter and Compiler into an Editor\n  new EditorLive(\n    scalaFormatter,\n    scalaCompiler,\n    CounterLive.make // Compiler Error: Type mismatch: expected: Counter, found: UIO[Counter]\n  )\n```\n\n----------------------------------------\n\nTITLE: Asserting Map Has Key with Value Condition in Scala\nDESCRIPTION: Creates an assertion `Assertion[Map[K, V]]` that checks if a `Map` contains a specific key `K` and that the corresponding value `V` satisfies the provided nested assertion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nhasKey[K, V](key: K, assertion: Assertion[V])\n```\n\n----------------------------------------\n\nTITLE: Buffering Workloads with Akka Actors\nDESCRIPTION: Demonstrates how Akka actors' mailboxes can be used to buffer high volumes of incoming requests, processing them one at a time.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.{Actor, ActorSystem, Props}\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration.Duration\n\nobject MainApp extends scala.App {\n  val actorSystem = ActorSystem(\"parallel-app\")\n  val worker = actorSystem.actorOf(Props[JobRunner], \"worker\")\n\n  val jobs = (1 to 1000).map(Job)\n\n  for (job <- jobs) {\n    worker ! job\n  }\n\n  println(\"All messages were sent to the actor!\")\n\n  Await.result(actorSystem.whenTerminated, Duration.Inf)\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Try is Failure in Scala\nDESCRIPTION: Creates an assertion `Assertion[Try[Any]]` that simply checks if a `scala.util.Try` value is a `Failure`, without inspecting the underlying `Throwable`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nisFailure\n```\n\n----------------------------------------\n\nTITLE: Taking Elements from TPriorityQueue in Scala ZIO\nDESCRIPTION: Demonstrates taking all elements from a TPriorityQueue using takeAll method, returning them in sorted order based on the queue's ordering.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpriorityqueue.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval sorted: STM[Nothing, Chunk[Int]] =\n  for {\n    queue  <- TPriorityQueue.empty[Int]\n    _      <- queue.offerAll(List(2, 4, 6, 3, 5, 6))\n    sorted <- queue.takeAll\n  } yield sorted\n```\n\n----------------------------------------\n\nTITLE: Building and Validating the Project with a Single SBT Command - Bash\nDESCRIPTION: The 'sbt build' command formats the code, compiles sources, and runs all tests in sequence, streamlining development. This should be used before submitting code to ensure all validations pass.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsbt build\n```\n\n----------------------------------------\n\nTITLE: Defining UStream Type Alias in Scala for ZIO\nDESCRIPTION: UStream is a type alias for ZStream that doesn't require any services (Any), cannot fail (Nothing), and may emit zero or more values of type A. This provides a simplified interface for working with streams in scenarios where failure handling and service dependencies aren't needed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/ustream.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype UStream[+A] = ZStream[Any, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Testing for Equality with equalTo - ZIO Test - Scala\nDESCRIPTION: Shows how to use Assertion.hasAt in combination with Assertion.equalTo to assert that a specific sequence element is equal to an expected value. This utilizes ZIO Test's test and assert to define the test, providing the fourth element (index 3) as the tested position, and 5 as the expected value. The output is a ZSpec instance for this fixed test. Requires the ZIO Test dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval xs = Vector(0, 1, 2, 3)\n// xs: Vector[Int] = Vector(0, 1, 2, 3)\n\ntest(\"Fourth value is equal to 5\") {\n  assert(xs)(hasAt(3)(equalTo(5)))\n}\n// res3: ZSpec[Any, Nothing] = Spec(\n//   caseValue = LabeledCase(\n//     label = \"Fourth value is equal to 5\",\n//     spec = Spec(\n//       caseValue = TestCase(\n//         test = <function1>,\n//         annotations = Map(zio.test.TestAnnotation@fa40ba79 -> List(SourceLocation(use-test-assertions.md,40)))\n//       )\n//     )\n//   )\n// )\n```\n\n----------------------------------------\n\nTITLE: Another Example of collectWhile on a Chunk in Scala\nDESCRIPTION: Demonstrates collectWhile with a numeric condition on a Chunk of integers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nChunk(9, 2, 5, 1, 6).collectWhile { case element if element >= 2 => true }\n```\n\n----------------------------------------\n\nTITLE: ZQueue#mapM: Effectful Mapping of Output in Scala\nDESCRIPTION: Uses mapM to effectfully transform dequeued elements, annotating each with its dequeue timestamp. Imports zio.clock._ and java.util.concurrent.TimeUnit for time operations. Requires ZIO Clock in the environment. Returns a new queue delivering (Long, String) tuples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.concurrent.TimeUnit\\nimport zio.clock._\\n\\nval currentTimeMillis = currentTime(TimeUnit.MILLISECONDS)\\n\\nval annotatedOut: UIO[ZQueue[Any, Clock, Nothing, Nothing, String, (Long, String)]] =\\n  for {\\n    queue <- Queue.bounded[String](3)\\n    mapped = queue.mapM { el =>\\n      currentTimeMillis.map((_, el))\\n    }\\n  } yield mapped\\n\n```\n\n----------------------------------------\n\nTITLE: Rewriting Error-Handling Combinators in ZStream - Scala\nDESCRIPTION: This snippet contains rewrite equivalences for ZStream error-handling combinators when errors cannot occur, showing how to eliminate redundant handling and adopt simpler alternatives. It applies to stream processing with ZStream or similar typed FP libraries and does not require dependencies beyond ZIO core.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/canfail.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nustream.catchAll(f)\nustream.either\nustream.mapBoth(f, g)\nustream.mapError(f)\nustream.orElse(zstream)\n```\n\n----------------------------------------\n\nTITLE: Creating a Voting Application with ZIO Prelude\nDESCRIPTION: Demonstrates using ZIO Prelude's NewTypes and Associative type class to create a type-safe voting application. The example creates custom types for Topics and Votes with the ability to combine vote states.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.prelude._\n\nobject VotingExample extends scala.App {\n\n  object Votes extends Subtype[Int] {\n    implicit val associativeVotes: Associative[Votes] =\n      new Associative[Votes] {\n        override def combine(l: => Votes, r: => Votes): Votes =\n          Votes(l + r)\n      }\n  }\n  type Votes = Votes.Type\n\n  object Topic extends Subtype[String]\n  type Topic = Topic.Type\n\n  final case class VoteState(map: Map[Topic, Votes]) { self =>\n    def combine(that: VoteState): VoteState =\n      VoteState(self.map combine that.map)\n  }\n\n  val zioHttp    = Topic(\"zio-http\")\n  val uziHttp    = Topic(\"uzi-http\")\n  val zioTlsHttp = Topic(\"zio-tls-http\")\n\n  val leftVotes  = VoteState(Map(zioHttp -> Votes(4), uziHttp -> Votes(2)))\n  val rightVotes = VoteState(Map(zioHttp -> Votes(2), zioTlsHttp -> Votes(2)))\n\n  println(leftVotes combine rightVotes)\n  // Output: VoteState(Map(zio-http -> 6, uzi-http -> 2, zio-tls-http -> 2))\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Constant Samples in Scala using ZIO Test\nDESCRIPTION: Shows how to create a generator that always produces the same sample value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nGen.constSample(Sample.noShrink(false)).runCollectN(5)\n// Output: List(true, true, true, true, true)\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO JSON Dependency\nDESCRIPTION: SBT dependency configuration for including ZIO JSON library\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-json\" % \"0.3.0-RC10\"\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Optics in SBT\nDESCRIPTION: Adds the ZIO Optics library dependency to a Scala project's build.sbt file. ZIO Optics provides utilities for working with nested data structures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_25\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-optics\" % \"0.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Accessing the ZIO Environment Value in Scala\nDESCRIPTION: This snippet demonstrates accessing the entire environment value within a ZIO effect using `ZIO.environment[Int]`. The effect requires an `Int` environment and prints its value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nfor {\n  env <- ZIO.environment[Int]\n  _   <- putStrLn(s\"The value of the environment is: $env\")\n} yield env\n```\n```\n\n----------------------------------------\n\nTITLE: Measuring Test Execution Time with ZIO Test\nDESCRIPTION: Shows how to use the timed test aspect to measure and display execution time for test suites and individual tests. The example creates a suite with three tests, including one with an artificial delay.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/annotating-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\n\nsuite(\"a timed suite\")(\n  test(\"A\")(Live.live(ZIO.sleep(100.millis)).map(_ => assertTrue(true))),\n  test(\"B\")(assertTrue(true)),\n  test(\"C\")(assertTrue(true))\n) @@ TestAspect.timed\n```\n\n----------------------------------------\n\nTITLE: Adding HTTP Client Backend Dependencies for ZIO K8s\nDESCRIPTION: Configuration for adding the required STTP HTTP client backend dependencies to work with ZIO K8s.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n\"com.softwaremill.sttp.client3\" %% \"httpclient-backend-zio\" % \"3.1.1\",\n\"com.softwaremill.sttp.client3\" %% \"slf4j-backend\"          % \"3.1.1\"\n```\n\n----------------------------------------\n\nTITLE: Running Annotated ZIO Test Spec Using sbt in Bash\nDESCRIPTION: This bash snippet demonstrates running the annotated ZIO Test specification using sbt. It shows the output of a successful test run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/junit-integration.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsbt:zio-quickstart-junit> test\n+ MySpec\n  + test\n[info] Passed: Total 1, Failed 0, Errors 0, Passed 1\n[success] Total time: 1 s, completed Jun 13, 2023, 4:37:32 PM\n```\n\n----------------------------------------\n\nTITLE: Defining TaskManaged Type Alias in Scala\nDESCRIPTION: Defines a type alias TaskManaged[A] that represents a ZManaged resource with Any requirement, Throwable error type, and generic success type A. This simplifies the type signature for managed resources that don't have specific environmental requirements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/task-managed.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype TaskManaged[+A] = ZManaged[Any, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Folding Elements of a TSet in Scala ZIO STM\nDESCRIPTION: Folds the elements of a TSet using a specified associative binary operator (addition in this case) to produce a single result value. The initial value is 0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldTSet: UIO[Int] = (for {\n  tSet <- TSet.make(1, 2, 3, 4)\n  sum  <- tSet.fold(0)(_ + _)\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Kinesis in SBT\nDESCRIPTION: SBT dependency configuration for including the ZIO Kinesis library in a Scala project. This adds the necessary dependency to the build file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-kinesis.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"nl.vroste\" %% \"zio-kinesis\" % \"0.20.0\"\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO Application with Prometheus Metrics\nDESCRIPTION: Scala code showing how to configure a ZIO application with Prometheus metrics, including the necessary layers and routes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http._\nimport zio.metrics.connectors.{MetricsConfig, prometheus}\n\nobject MainApp extends ZIOAppDefault {\n  private val metricsConfig = ZLayer.succeed(MetricsConfig(1.seconds))\n\n  def run =\n    Server.serve(\n      GreetingRoutes() ++ DownloadRoutes() ++ CounterRoutes() ++ UserRoutes() ++ PrometheusPublisherRoutes()\n    ).provide(\n      Server.default,\n\n      // An layer responsible for storing the state of the `counterApp`\n      ZLayer.fromZIO(Ref.make(0)),\n\n      // To use the persistence layer, provide the `PersistentUserRepo.layer` layer instead\n      InmemoryUserRepo.layer,\n\n      // configs for metric backends\n      metricsConfig,\n\n      // The prometheus reporting layer\n      prometheus.publisherLayer,\n      prometheus.prometheusLayer,\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Bounded TQueue in Scala ZIO\nDESCRIPTION: Creates an empty bounded TQueue with a specified capacity of 5 elements using ZIO STM.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueBounded: STM[Nothing, TQueue[Int]] = TQueue.bounded[Int](5)\n```\n\n----------------------------------------\n\nTITLE: Offering Multiple Elements to TQueue in Scala ZIO\nDESCRIPTION: Shows how to add multiple elements to a bounded TQueue in a single transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tqueue.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tQueueOfferAll: UIO[TQueue[Int]] = (for {\n  tQueue <- TQueue.bounded[Int](3)\n  _      <- tQueue.offerAll(List(1, 2))\n} yield tQueue).commit\n```\n\n----------------------------------------\n\nTITLE: Lifting Pure Values to ZManaged\nDESCRIPTION: Demonstrates how to lift pure values into the ZManaged context using succeed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval managedString = ZManaged.succeed(\"Hello, World!\")\nval managedBoolean = ZManaged.succeed(true)\n```\n\n----------------------------------------\n\nTITLE: Parallel Processing with ZIO Operators\nDESCRIPTION: Demonstrates parallel processing of numbers using ZIO's filterPar and foreachParN operators. Shows batch processing approach with limitations in latency and memory usage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef isPrime(number: Int): Task[Boolean] = Task.succeed(???)\ndef moreHardWork(i: Int): Task[Boolean] = Task.succeed(???)\n\nval numbers = 1 to 1000\n\nfor {\n  primes <- ZIO.filterPar(numbers)(isPrime)\n  _      <- ZIO.foreachParN(20)(primes)(moreHardWork)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Comparing Monix and ZIO Companion Object Methods in Scala\nDESCRIPTION: This code block presents a table comparing companion object method names between Monix and ZIO. It shows how various Monix companion object methods can be translated to their ZIO equivalents.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-monix.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n| Monix          | ZIO              |\n|----------------|------------------|\n| `apply`        | `apply`          |\n| `asyncF`       | `asyncZIO`       |\n| `async`        | `async`          |\n| `cancelable`   | `asyncInterrupt` |\n| `deferFuture`  | `fromFuture`     |\n| `defer`        | `suspend`        |\n| `delay`        | `attempt`        |\n| `eval`         | `attempt`        |\n| `fromEither`   | `fromEither`     |\n| `fromFuture`   | `fromFuture`     |\n| `fromTry`      | `fromTry`        |\n| `map2`         | `mapN`           |\n| `mapBoth`      | `mapParN`        |\n| `never`        | `never`          |\n| `now`          | `succeed`        |\n| `parMap2`      | `mapParN`        |\n| `parSequenceN` | `collectAllParN` |\n| `parSequence`  | `collectAllPar`  |\n| `parTraverseN` | `foreachParN`    |\n| `parTraverse`  | `foreachPar`     |\n| `parZip2`      | `tupledPar`      |\n| `pure`         | `succeed`        |\n| `racePair`     | `raceWith`       |\n| `race`         | `raceFirst`      |\n| `raiseError`   | `fail`           |\n| `sequence`     | `collectAll`     |\n| `shift`        | `yield`          |\n| `sleep`        | `sleep`          |\n| `suspend`      | `suspend`        |\n| `traverse`     | `foreach`        |\n| `unit`         | `unit`           |\n```\n\n----------------------------------------\n\nTITLE: Creating Dropping ZIO Queue in Scala\nDESCRIPTION: Creates a dropping variant of ZIO Queue, which discards new items when full. Requires only zio._. Returns a Queue[Int] with a specified capacity of 100.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval droppingQueue: UIO[Queue[Int]] = Queue.dropping[Int](100)\\n\n```\n\n----------------------------------------\n\nTITLE: Compiling ZIO Test Code in SBT\nDESCRIPTION: SBT command to compile the test source code of the ZIO project. This ensures that all tests can be properly built before running them.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nTest/compile\n```\n\n----------------------------------------\n\nTITLE: Implementing the Saga Pattern with ZIO Saga\nDESCRIPTION: Example demonstrating how to implement the Saga Pattern using ZIO Saga. This pattern manages distributed transactions by sequencing local transactions with compensating actions that run in case of failure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nimport com.vladkopanev.zio.saga.Saga\nimport zio.{IO, UIO, URIO, ZIO}\n\nimport com.vladkopanev.zio.saga.Saga._\n\nval transaction: Saga[Any, String, Unit] =\n  for {\n    _ <- bookHotel compensate cancelHotel\n    _ <- bookTaxi compensate cancelTaxi\n    _ <- bookFlight compensate cancelFlight\n  } yield ()\n\nval myApp: ZIO[Any, String, Unit] = transaction.transact\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO 2.x Runtime Unsafe Sync/Async Methods in Scala\nDESCRIPTION: This Scala snippet shows the primary methods within ZIO 2.x's `Runtime.UnsafeAPI` for unsafe execution. `run` executes the ZIO effect synchronously, returning an `Exit` value. `fork` executes the effect asynchronously, returning a `Fiber.Runtime` which represents the running computation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\ntrait Runtime {\n  def unsafe: UnsafeAPI\n  \n  trait UnsafeAPI {\n    def run[E, A](zio: ZIO[R, E, A])(implicit unsafe: Unsafe): Exit[E, A]\n\n    def fork[E, A](zio: ZIO[R, E, A])(implicit unsafe: Unsafe): Fiber.Runtime[E, A]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding sbt-native-packager Plugin (Scala)\nDESCRIPTION: SBT configuration to add the sbt-native-packager plugin to the project/plugins.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\naddSbtPlugin(\"com.github.sbt\" % \"sbt-native-packager\" % \"1.9.9\")\n```\n\n----------------------------------------\n\nTITLE: Fiber Data Types\nDESCRIPTION: Core data types in the ZIO fiber system including Fiber, FiberRef, Fiber.Status, and Fiber.Id for managing concurrent operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n- Fiber\n- FiberRef[A]\n- Fiber.Status\n- Fiber.Id\n```\n\n----------------------------------------\n\nTITLE: Streamlined Pipeline with ZIO Streams\nDESCRIPTION: Shows a simplified pipeline implementation using ZIO Streams with buffering and processing steps, demonstrating cleaner high-level API usage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef generateElement: Task[Int]    = Task.succeed(???)\ndef process(i: Int): Task[Int]    = Task.succeed(???)\ndef printElem(i: Int): Task[Unit] = Task.succeed(???)\n\nZStream\n  .repeatEffect(generateElement)\n  .buffer(16)\n  .mapM(process(_))\n  .buffer(16)\n  .mapM(process(_))\n  .buffer(16)\n  .tap(printElem(_))\n```\n\n----------------------------------------\n\nTITLE: Running a Test with Repeated Execution in ZIO Test\nDESCRIPTION: This example demonstrates a test that adjusts the TestClock and then checks the current time. When run with the repeat5 aspect, it fails on subsequent runs due to state pollution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/restoring-state-of-test-services.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{ test, _ }\nimport java.util.concurrent.TimeUnit\n\nsuite(\"clock suite\")(\n  test(\"adjusting clock\") {\n    for {\n      clock <- ZIO.clock\n      _     <- TestClock.adjust(1.second)\n      time  <- clock.currentTime(TimeUnit.SECONDS).debug(\"current time\")\n    } yield assertTrue(time == 1)\n  } @@ repeat5\n)\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Logging via SBT\nDESCRIPTION: SBT dependency for adding ZIO Logging to a project. This library provides a ZIO native logging solution with support for various backends.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-logging\" % \"0.5.13\" \n```\n\n----------------------------------------\n\nTITLE: Starting RabbitMQ Docker Container\nDESCRIPTION: Docker command to start a RabbitMQ instance with management console on specified ports.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-amqp.md#2025-04-23_snippet_1\n\nLANGUAGE: docker\nCODE:\n```\ndocker run -d --name some-rabbit -p 5672:5672 -p 5673:5673 -p 15672:15672 rabbitmq:3-management\n```\n\n----------------------------------------\n\nTITLE: Join vs InheritRefs Comparison\nDESCRIPTION: Demonstrates equivalent behavior between join and inheritRefs for FiberRef value propagation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nval withJoin =\n  for {\n    fiberRef <- FiberRef.make[Int](0)\n    fiber    <- fiberRef.set(10).fork\n    _        <- fiber.join\n    v        <- fiberRef.get\n  } yield assert(v == 10)\n```\n\nLANGUAGE: scala\nCODE:\n```\nval withoutJoin =\n  for {\n    fiberRef <- FiberRef.make[Int](0)\n    fiber    <- fiberRef.set(10).fork\n    _        <- fiber.inheritRefs\n    v        <- fiberRef.get\n  } yield assert(v == 10)\n```\n\n----------------------------------------\n\nTITLE: Embedding Zymposiums YouTube Playlist\nDESCRIPTION: HTML iframe element for embedding the Zymposiums YouTube playlist containing recordings of weekly ZIO-focused live streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/events/index.md#2025-04-23_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/videoseries?list=PLvdARMfvom9C8ss18he1P5vOcogawm5uC\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n```\n\n----------------------------------------\n\nTITLE: ZMX Monitoring Integration\nDESCRIPTION: Example showing how to integrate ZMX monitoring into a ZIO application\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console._\nimport zio.zmx._\nimport zio.zmx.diagnostics._\n\nval program: ZIO[Console, Throwable, Unit] =\n  for {\n    _ <- putStrLn(\"Waiting for input\")\n    a <- getStrLn\n    _ <- putStrLn(\"Thank you for \" + a)\n  } yield ()\n\nval diagnosticsLayer: ZLayer[ZEnv, Throwable, Has[Diagnostics]] =\n  Diagnostics.make(\"localhost\", 1111)\n\nval runtime: Runtime[ZEnv] =\n  Runtime.default.mapPlatform(_.withSupervisor(ZMXSupervisor))\n\nruntime.unsafeRun(program.provideCustomLayer(diagnosticsLayer))\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO 2.x Fiber Runtime Unsafe Observer Method in Scala\nDESCRIPTION: This Scala snippet defines the `UnsafeAPI` within `Fiber.Runtime` in ZIO 2.x. It contains the `addObserver` method, which allows adding a callback function (`Exit[E, A] => Unit`) to be executed when the fiber completes. This is used for handling results of asynchronously forked effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_39\n\nLANGUAGE: scala\nCODE:\n```\nobject Fiber {\n  sealed abstract class Runtime[+E, +A] extends Fiber[E, A] {\n    def unsafe: UnsafeAPI\n\n    trait UnsafeAPI {\n      def addObserver(observer: Exit[E, A] => Unit)(implicit unsafe: Unsafe): Unit\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Error Tapping Operators in ZIO Trait - Scala\nDESCRIPTION: This snippet defines the ZIO trait with various tap-style operators for inspecting error values, causes, and defects asynchronously. Each method (e.g., tapError, tapErrorCause, tapErrorTrace, tapDefect, tapBoth, tapEither) accepts a callback or handler for peeking into respective error structures during effectful computations. No runtime dependencies are required beyond the ZIO effect system's type signatures, and the key parameters are higher-order functions receiving error details or both error and success values. The trait is designed to be extended by effectful workflows needing side-effects or debugging on error paths.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/tapping-errors.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def tapError[R1 <: R, E1 >: E](f: E => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapErrorCause[R1 <: R, E1 >: E](f: Cause[E] => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapErrorTrace[R1 <: R, E1 >: E](f: ((E, Trace)) => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapDefect[R1 <: R, E1 >: E](f: Cause[Nothing] => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapBoth[R1 <: R, E1 >: E](f: E => ZIO[R1, E1, Any], g: A => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n  def tapEither[R1 <: R, E1 >: E](f: Either[E, A] => ZIO[R1, E1, Any]): ZIO[R1, E1, A]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining URIO Type Alias in Scala\nDESCRIPTION: Definition of URIO type alias which represents a specialized version of ZIO that cannot fail. It requires an environment type R and produces a success value of type A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/urio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype URIO[-R, +A] = ZIO[R, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Using a Buffered Channel with Empty Buffer in Scala ZIO\nDESCRIPTION: Demonstrates how a buffered channel behaves when its buffer is empty - passing the input value directly to the output port.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n(ZChannel.write(1) >>> buffered(0)).runCollect.debug\n// Output: (Chunk(1),())\n```\n\n----------------------------------------\n\nTITLE: Defining Event Enum with Scala\nDESCRIPTION: This Scala snippet defines the domain events for the counter using an enum, supporting two event types: Increased and Decreased. These events are used to capture changes applied to the counter state and are referenced throughout the event-sourced logic. No external dependencies are required, but the enum values are linked to the system's domain transitions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nenum Event {\n  case Increased, Decreased\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning ZIO Quickstarts Repository\nDESCRIPTION: Commands to clone and navigate to the JSON encoding/decoding example project\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-encode-decode-json-data\n```\n\n----------------------------------------\n\nTITLE: Awaiting a TPromise Completion in ZIO STM\nDESCRIPTION: Demonstrates how to wait for a TPromise to complete and get its value. The await method suspends the transaction until the promise is completed and then returns the success value or fails with the error.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpromise.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromiseValue: IO[String, Int] = for {\n  tPromise <- TPromise.make[String, Int].commit\n  _        <- tPromise.succeed(0).commit\n  res      <- tPromise.await.commit\n} yield res\n```\n\n----------------------------------------\n\nTITLE: Committing Changes to ZIO Project\nDESCRIPTION: Git command to commit all changes with a descriptive message. The format references the issue number and describes the changes made.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \"Fixed #94211 - Optimized race for lists of effects\"\n```\n\n----------------------------------------\n\nTITLE: Rewriting Error-Handling Combinators in ZManaged - Scala\nDESCRIPTION: This snippet lists equivalent rewrite patterns for error-handling combinators on ZManaged resources where errors cannot be raised, allowing simplification to non-error variants. Intended for developers using ZManaged, it directs elimination of unnecessary combinator invocations. Implementation requires only the ZIO environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/canfail.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\numanaged <> zmanaged\numanaged.catchAll(f)\numanaged.catchSome(pf)\numanaged.either\numanaged.flatMapError(f)\numanaged.fold(f, g)\numanaged.foldM(f, g)\numanaged.mapBoth(f, g)\numanaged.mapError(f)\numanaged.option\numanaged.orDie\numanaged.orDieWith(f)\numanaged.orElse(zmanaged)\numanaged.orElseEither(zmanaged)\numanaged.orElseFail(e)\numanaged.asElseSucceed(a)\numanaged.refineOrDie(pf)\numanaged.refineToOrDie\numanaged.refineToOrDieWith(pf)(f)\numanaged.retry(s)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Long-Running Application with forked components (Ineffective approach)\nDESCRIPTION: This snippet shows an ineffective approach to implementing a long-running application by forking multiple background components. This approach doesn't properly handle component failures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nval main = \n  kafkaConsumer.runDrain.fork *>\n  httpServer.fork *>\n  scheduledJobRunner.fork *>\n  ZIO.never\n```\n\n----------------------------------------\n\nTITLE: Auto-Blocking Example in ZIO 1.x\nDESCRIPTION: Demonstrates the potential starvation issues in ZIO 1.x when blocking operations are not properly managed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.duration.durationInt\n\nimport scala.annotation.tailrec\n\nobject MainApp extends App {\n\n  def fib(n: Int): BigInt = {\n    @tailrec\n    def go(n: BigInt, a: BigInt, b: BigInt): BigInt = {\n      if (n == 0) a\n      else go(n - 1, b, a + b)\n    }\n    go(n, 0, 1)\n  }\n\n  def ioBoundWorkflow =\n    ZIO.debug(\"Starting I/O bound workflow\") *>\n      ZIO.foreachPar_(1 to 100)(_ => ZIO.effect(Thread.sleep(Long.MaxValue))) *>\n      ZIO.debug(\"Finished I/O bound workflow\")\n\n  def cpuBoundWorkflow =\n    ZIO.debug(\"Starting CPU bound workflow\") *>\n      ZIO.foreachPar_(1 to 100)(i => ZIO.effect(fib(i))) *>\n      ZIO.debug(\"Finished CPU bound workflow\")\n\n  def run(args: List[String]) =\n    (ioBoundWorkflow <&> cpuBoundWorkflow.delay(1.second)).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a ZIO Histogram to Track Random Double Values in Scala\nDESCRIPTION: Illustrates applying a pre-defined `histogram` metric to a ZIO effect. The effect `Random.nextDoubleBetween(0.0d, 120.0d)` generates a random Double. The `@@` operator applies the `histogram` metric to this effect, recording the generated Double value into the appropriate bucket of the histogram. Requires `zio`, `zio.metrics`, and an existing `histogram` metric instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/histogram.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.metrics._\n\nRandom.nextDoubleBetween(0.0d, 120.0d) @@ histogram\n```\n\n----------------------------------------\n\nTITLE: Taking Up To N Items from Queue in Scala\nDESCRIPTION: Uses takeUpTo to consume a specified maximum number of items (here, 5), returning what's available in the queue as List[Int]. Shows that it does not suspend if not enough elements exist. Requires zio._.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval taken: UIO[List[Int]] = for {\\n  queue <- Queue.bounded[Int](100)\\n  _ <- queue.offer(10)\\n  _ <- queue.offer(20)\\n  list  <- queue.takeUpTo(5)\\n} yield list\\n\n```\n\n----------------------------------------\n\nTITLE: Launching SBT from the Terminal to Build the Project - Bash\nDESCRIPTION: This snippet shows how to start the custom sbt build tool using a script provided in the repository root. Prerequisites include having SBT installed and ensuring the script's execute permissions. Running this will read the build file and start downloading required dependencies.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./sbt\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO Config Dependencies\nDESCRIPTION: SBT dependency configuration for ZIO Config modules including core, magnolia, typesafe and refined\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-config\"          % \"1.0.6\"\nlibraryDependencies += \"dev.zio\" %% \"zio-config-magnolia\" % \"1.0.6\"\nlibraryDependencies += \"dev.zio\" %% \"zio-config-typesafe\" % \"1.0.6\"\nlibraryDependencies += \"dev.zio\" %% \"zio-config-refined\"  % \"1.0.6\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZIO NebulaGraph Application\nDESCRIPTION: Complete example showing how to use NebulaSessionClient in a ZIO application, including initialization, executing graph queries, and providing the necessary layers. Demonstrates inserting vertices and edges, and querying the graph.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-nebula.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.nebula._\n\nfinal class NebulaSessionClientExample(sessionClient: NebulaSessionClient) {\n\n  def execute(stmt: String): ZIO[Any, Throwable, NebulaResultSet] = {\n    // your business logic\n    sessionClient.execute(stmt)\n  }\n}\n\nobject NebulaSessionClientExample {\n  lazy val layer = ZLayer.fromFunction(new NebulaSessionClientExample(_))\n}\n\nobject NebulaSessionClientMain extends ZIOAppDefault {\n\n  override def run = (for {\n    _ <- ZIO.serviceWithZIO[NebulaSessionClient](_.init()) // since 0.1.1, no need to call it manually. \n    _ <- ZIO.serviceWithZIO[NebulaSessionClientExample](\n             _.execute(\"\"\"\n                         |INSERT VERTEX person(name, age) VALUES \n                         |'Bob':('Bob', 10), \n                         |'Lily':('Lily', 9),'Tom':('Tom', 10),\n                         |'Jerry':('Jerry', 13),\n                         |'John':('John', 11);\"\"\".stripMargin)\n           )\n    _ <- ZIO.serviceWithZIO[NebulaSessionClientExample](\n             _.execute(\"\"\"\n                         |INSERT EDGE like(likeness) VALUES\n                         |'Bob'->'Lily':(80.0),\n                         |'Bob'->'Tom':(70.0),\n                         |'Lily'->'Jerry':(84.0),\n                         |'Tom'->'Jerry':(68.3),\n                         |'Bob'->'John':(97.2);\"\"\".stripMargin)\n           )\n    _ <- ZIO.serviceWithZIO[NebulaSessionClientExample](\n             _.execute(\"\"\"\n                         |USE test;\n                         |MATCH (p:person) RETURN p LIMIT 4;\n                         |\"\"\".stripMargin)\n           )\n  } yield ())\n    .provide(\n      Scope.default,\n      NebulaSessionClientExample.layer,\n      SessionClientEnv\n    )\n\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Kafka Dependency\nDESCRIPTION: SBT dependency configuration for ZIO Kafka module\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-kafka\" % \"0.15.0\"\n```\n\n----------------------------------------\n\nTITLE: Simple MUnit ZIO Test Example\nDESCRIPTION: Basic example of writing tests using MUnit with ZIO integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nimport munit._\nimport zio._\n\nclass SimpleZIOSpec extends ZSuite {\n  testZ(\"1 + 1 = 2\") {\n    for {\n      a <- ZIO(1)\n      b <- ZIO(1)\n    }\n    yield assertEquals(a + b, 2)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TranzactIO Database Example Implementation\nDESCRIPTION: Complete example of using TranzactIO with Doobie for database operations, including connection setup and query implementations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_20\n\nLANGUAGE: scala\nCODE:\n```\nimport doobie.implicits._\nimport io.github.gaelrenoux.tranzactio.doobie\nimport io.github.gaelrenoux.tranzactio.doobie.{Connection, Database, TranzactIO, tzio}\nimport org.h2.jdbcx.JdbcDataSource\nimport zio.blocking.Blocking\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.{ExitCode, Has, URIO, ZIO, ZLayer, blocking}\n\nimport javax.sql.DataSource\n\nobject TranzactIOExample extends zio.App {\n\n  val query: ZIO[Connection with Console, Throwable, Unit] = for {\n    _ <- PersonQuery.setup\n    _ <- PersonQuery.insert(Person(\"William\", \"Stewart\"))\n    _ <- PersonQuery.insert(Person(\"Michelle\", \"Streeter\"))\n    _ <- PersonQuery.insert(Person(\"Johnathon\", \"Martinez\"))\n    users <- PersonQuery.list\n    _ <- putStrLn(users.toString)\n  } yield ()\n\n  val myApp: ZIO[zio.ZEnv, Throwable, Unit] =\n    Database.transactionOrWidenR(query).provideCustomLayer(services.database)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n\ncase class Person(firstName: String, lastName: String)\n\nobject PersonQuery {\n  def list: TranzactIO[List[Person]] = tzio {\n    sql\"\"\"SELECT first_name, last_name FROM person\"\"\".query[Person].to[List]\n  }\n\n  def setup: TranzactIO[Unit] = tzio {\n    sql\"\"\"\n        CREATE TABLE person (\n          first_name VARCHAR NOT NULL,\n          last_name VARCHAR NOT NULL\n        )\n        \"\"\".update.run.map(_ => ())\n  }\n\n  def insert(p: Person): TranzactIO[Unit] = tzio {\n    sql\"\"\"INSERT INTO person (first_name, last_name) VALUES (${p.firstName}, ${p.lastName})\"\"\".update.run\n      .map(_ => ())\n  }\n}\n\nobject services {\n  val datasource: ZLayer[Blocking, Throwable, Has[DataSource]] =\n    ZLayer.fromEffect(\n      blocking.effectBlocking {\n        val ds = new JdbcDataSource\n        ds.setURL(s\"jdbc:h2:mem:mydb;DB_CLOSE_DELAY=10\")\n        ds.setUser(\"sa\")\n        ds.setPassword(\"sa\")\n        ds\n      }\n    )\n\n  val database: ZLayer[Any, Throwable, doobie.Database.Database] =\n    (Blocking.live >>> datasource ++ Blocking.live ++ Clock.live) >>> Database.fromDatasource\n}\n```\n\n----------------------------------------\n\nTITLE: Division Implicit Defect Translation with ZIO.succeed - Scala\nDESCRIPTION: Defines a division function that doesn't explicitly handle division by zero. If b is zero, the JVM throws ArithmeticException, which is automatically converted into a defect by ZIO.succeed. Illustrates that not all defects must be constructed manually. Requires zio._. Inputs: two integers; Output: ZIO effect with possible defect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\ndef divide(a: Int, b: Int): ZIO[Any, Nothing, Int] =\n  ZIO.succeed(a / b)\n```\n\n----------------------------------------\n\nTITLE: CI Job for Notifying Main Repository of Documentation Release\nDESCRIPTION: YAML configuration for a GitHub Actions workflow job that notifies the main ZIO repository about a new release of the documentation package.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nnotify-docs-release:\n  name: Notify Docs Release\n  runs-on: ubuntu-latest\n  continue-on-error: false\n  needs:\n  - release-docs\n  if: ${{ (github.event_name == 'release') && (github.event.action == 'published') }}\n  steps:\n  - name: Git Checkout\n    uses: actions/checkout@v4.1.1\n    with:\n      fetch-depth: '0'\n  - name: notify the main repo about the new release of docs package\n    run: |\n      PACKAGE_NAME=$(cat docs/package.json | grep '\"name\"' | awk -F'\"' '{print $4}')\n      PACKAGE_VERSION=$(npm view $PACKAGE_NAME version)\n      curl -L \\\n        -X POST \\\n        -H \"Accept: application/vnd.github+json\" \\\n        -H \"Authorization: token ${{ secrets.PAT_TOKEN }}\"\\\n          https://api.github.com/repos/zio/zio/dispatches \\\n          -d '{\n                \"event_type\":\"update-docs\",\n                \"client_payload\":{\n                  \"package_name\":\"'\"${PACKAGE_NAME}\"'\",\n                  \"package_version\": \"'\"${PACKAGE_VERSION}\"'\"\n                }\n              }'\n```\n\n----------------------------------------\n\nTITLE: Incorrect Accessor Methods Without Tag Context Bounds\nDESCRIPTION: An attempt to define accessor methods for the KeyValueStore service that fails because it lacks Tag context bounds for the polymorphic type parameters K, V, and E. This causes compile-time errors because the ZIO environment system needs runtime type information.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/defining-polymorphic-services-in-zio.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject KeyValueStore {\n  def get[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n\n  def set[K, V, E](key: K, value: V): ZIO[KeyValueStore[K, V, E, IO], E, V] =\n    ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n\n  def remove[K, V, E](key: K): ZIO[KeyValueStore[K, V, E, IO], E, Unit] =\n    ZIO.serviceWithZIO(_.remove(key))\n}\n\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.get(key))\n//                                                   ^\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO[KeyValueStore[K, V, E, IO]](_.set(key, value))\n//                                                   ^\n// error: could not find implicit value for izumi.reflect.Tag[K]. Did you forget to put on a Tag, TagK or TagKK context bound on one of the parameters in K? e.g. def x[T: Tag, F[_]: TagK] = ...\n// \n// \n// <trace>: \n//   deriving Tag for K, dealiased: K:\n//   could not find implicit value for Tag[K]: K is a type parameter without an implicit Tag!\n//     ZIO.serviceWithZIO(_.remove(key))\n//                       ^\n```\n\n----------------------------------------\n\nTITLE: Defining RManaged Type Alias in Scala\nDESCRIPTION: Defines RManaged as a type alias for ZManaged with fixed error type of Throwable. The type takes two parameters: R for environment requirements and A for success value type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/rmanaged.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype RManaged[-R, +A] = ZManaged[R, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Placeholder for ZIO Metrics Dependencies in build.sbt\nDESCRIPTION: This empty Scala code block serves as a placeholder within the documentation. It indicates the section within a `build.sbt` file where users should add the necessary library dependencies required for using ZIO Metrics and potentially ZIO Metrics Connectors, as mentioned in the surrounding text.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\n\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Optional LogStage Modules in Scala\nDESCRIPTION: This snippet demonstrates how to add optional LogStage modules to a Scala project using sbt. It includes dependencies for JSON output, SLF4J adapters, DIStage integration, and SLF4J sink.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/logstage.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  // Json output\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe\" % \"1.0.8\",\n  // Router from Slf4j to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j\" % \"1.0.8\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"distage-extension-logstage\" % \"1.0.8\",\n  // Router from LogStage to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"1.0.8\",\n)\n```\n\n----------------------------------------\n\nTITLE: Reload4j Logger Configuration\nDESCRIPTION: Configuration file for Reload4j logging framework showing pattern layout and console appender setup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/create-custom-logger-for-a-zio-application.md#2025-04-23_snippet_4\n\nLANGUAGE: properties\nCODE:\n```\nlog4j.rootLogger = Info, consoleAppender\nlog4j.appender.consoleAppender=org.apache.log4j.ConsoleAppender\nlog4j.appender.consoleAppender.layout=org.apache.log4j.PatternLayout\nlog4j.appender.consoleAppender.layout.ConversionPattern=[%p] %d %c %M - %m%n\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Successful Effect from Value - Scala\nDESCRIPTION: Demonstrates use of ZIO.succeed to wrap a pure value (42) in a ZIO effect, ensuring it is lazily evaluated and free of side effects. Recommended for safe, deterministic value construction within ZIO; requires dependency on the ZIO library. No input or external parameters; output is a successful ZIO effect yielding 42 when run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZIO.succeed(42)\n```\n\n----------------------------------------\n\nTITLE: Concurrent Counter Test\nDESCRIPTION: Demonstration of race condition in the increment function when used concurrently across multiple fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  counter <- Ref.make(0)\n  _ <- ZIO.collectAllPar(ZIO.replicate(10)(inc(counter, 1)))\n  value <- counter.get\n} yield (value)\n```\n\n----------------------------------------\n\nTITLE: Creating Managed from Pure Value\nDESCRIPTION: Demonstrates creating a Managed resource from a pure value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/managed.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nval managedFromValue: Managed[Nothing, Int] = Managed.succeed(3)\n```\n\n----------------------------------------\n\nTITLE: Providing TRandom Implementation to STM Transaction\nDESCRIPTION: This snippet demonstrates how to commit a transactional operation that uses TRandom and then provide the live implementation to the resulting effect. It shows the pattern of first creating an STM transaction with TRandom, committing it to a ZIO effect, and then providing the implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/trandom.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nmyApp.provide(TRandom.live)\n```\n\n----------------------------------------\n\nTITLE: Logback Configuration XML\nDESCRIPTION: XML configuration for Logback logging framework with console appender and pattern layout.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/create-custom-logger-for-a-zio-application.md#2025-04-23_snippet_5\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<configuration>\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder>\n            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>\n        </encoder>\n    </appender>\n    <root level=\"info\">\n        <appender-ref ref=\"STDOUT\"/>\n    </root>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Implementing Distribution with ZStream#distributedWith in Scala\nDESCRIPTION: The distributedWith operator distributes elements into multiple downstream streams based on a decision function. It takes parameters for the number of streams, maximum lag allowed, and a function that decides which streams receive each element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_53\n\nLANGUAGE: scala\nCODE:\n```\nabstract class ZStream[-R, +E, +O] {\n  final def distributedWith[E1 >: E](\n    n: Int,\n    maximumLag: Int,\n    decide: O => UIO[Int => Boolean]\n  ): ZManaged[R, Nothing, List[Dequeue[Exit[Option[E1], O]]]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Squashing Commits in Git for ZIO Contributions\nDESCRIPTION: This bash snippet demonstrates how to squash the last 5 commits in Git, which is useful when iterating on a feature for a ZIO pull request. It resets the HEAD, creates a new commit with all changes, and force pushes to update the pull request.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ngit reset --soft HEAD~5\ngit commit -am \"add feature X\"\ngit push --force\n```\n\n----------------------------------------\n\nTITLE: Copy-on-Fork FiberRef Behavior\nDESCRIPTION: Demonstrates how FiberRef values are copied when forking fibers and how modifications in child fibers don't affect parent fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiberRef <- FiberRef.make(5)\n  promise <- Promise.make[Nothing, Int]\n  _ <- fiberRef\n    .updateAndGet(_ => 6)\n    .flatMap(promise.succeed).fork\n  childValue <- promise.await\n  parentValue <- fiberRef.get\n} yield assert(parentValue == 5 && childValue == 6)\n```\n\n----------------------------------------\n\nTITLE: Creating Managed from Effect\nDESCRIPTION: Shows how to create a Managed resource from an effect without explicit release handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/managed.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\ndef acquire: IO[Throwable, Int] = IO.effect(???)\n\nval managedFromEffect: Managed[Throwable, Int] = Managed.fromEffect(acquire)\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Streams Dependency in SBT (Scala)\nDESCRIPTION: This snippet demonstrates how to add the ZIO Streams library dependency to an SBT project. This module provides tools for asynchronous stream processing and is added similarly to the core ZIO dependency.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/getting_started.md#2025-04-23_snippet_1\n\nLANGUAGE: sbt\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-streams\" % \"1.0.18\"\n```\n\n----------------------------------------\n\nTITLE: Installing Distage Dependency in SBT\nDESCRIPTION: SBT dependency configuration for adding Distage core library to a Scala project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/distage.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-core\" % \"1.0.8\"\n```\n\n----------------------------------------\n\nTITLE: Integrating ZIO into Existing Applications\nDESCRIPTION: This snippet demonstrates how to create and use a ZIO runtime in an existing application or when you don't control the main function. It shows how to execute a ZIO effect using the runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject IntegrationExample {\n  val runtime = Runtime.default\n\n  Unsafe.unsafe { implicit unsafe =>\n    runtime.unsafe.run(ZIO.attempt(println(\"Hello World!\"))).getOrThrowFiberFailure()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sharding for ZIO Shardcake\nDESCRIPTION: This code sets up the configuration layer for Shardcake sharding. It reads the port from an environment variable and creates a Config object.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport com.devsisters.shardcake.Config\n\nobject ShardConfig {\n  val layer: ZLayer[Any, SecurityException, Config] =\n    ZLayer(\n      System\n        .env(\"PORT\")\n        .map(\n          _.flatMap(_.toIntOption)\n            .fold(Config.default)(port => Config.default.copy(shardingPort = port))\n        )\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Test Akka HTTP Dependency to build.sbt\nDESCRIPTION: SBT dependency for adding ZIO Test Akka HTTP to a project. This library provides an Akka-HTTP Route TestKit for zio-test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"info.senia\" %% \"zio-test-akka-http\" % \"1.0.2\"\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO and Defining Sample Utilities in Scala\nDESCRIPTION: This snippet imports the necessary ZIO modules and defines a sealed trait representing analysis results, some sample data, and utility functions (`analyzeData` and `validateData`) that return ZIO effects. It is used as a foundational context for other examples, demonstrating how to set up data and basic effect operations. Dependencies: the ZIO library, and the functions expect generic data types as input.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/fiber/fiber.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n```\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Analysis\ncase object Analyzed extends Analysis\n\nval data: String = \"tut\"\n\ndef analyzeData[A](data: A): UIO[Analysis] = ZIO.succeed(Analyzed)\ndef validateData[A](data: A): UIO[Boolean] = ZIO.succeed(true)\n```\n\n----------------------------------------\n\nTITLE: Expanded code for Cats Effect 2.x interop\nDESCRIPTION: Expanded version of the code showing how Cats Effect 2.x integration works under the hood with taskConcurrentInstance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nobject ZioCatsEffectInterop extends scala.App {\n  val runtime: zio.Runtime[Any] = zio.Runtime.default\n\n  val zioApp = catsEffectApp[zio.Task](zio.interop.catz.taskConcurrentInstance)\n  runtime.unsafeRun(zioApp.exitCode)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RLayer Type Alias in Scala for ZIO\nDESCRIPTION: This snippet defines the RLayer type alias as a specialized version of ZLayer. It represents a layer that requires RIn as input, may fail with a Throwable, and returns ROut as output.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/rlayer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype RLayer[-RIn, +ROut]  = ZLayer[RIn, Throwable, ROut]\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO 1.x Bracket Signature with By-Value Parameter (Scala)\nDESCRIPTION: Presents the Scala signature for `ZIO.bracket` in ZIO 1.x. It highlights that the `acquire` parameter is of type `ZIO[R, E, A]` and is passed by value, which causes the effect provided to `acquire` to be evaluated eagerly before the `bracket` operation begins.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ndef bracket[R, E, A](acquire: ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n```\n\n----------------------------------------\n\nTITLE: Defining Additional Hub Methods in Scala\nDESCRIPTION: Extends the Hub trait with additional methods including publishAll for publishing multiple values, and size and capacity for checking the Hub's state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ntrait Hub[A] {\n  def publishAll(as: Iterable[A]): UIO[Boolean]\n}\n\ntrait Hub[A] {\n  def capacity: Int\n  def size: UIO[Int]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URManaged Type Alias in Scala\nDESCRIPTION: Defines URManaged as a type alias for ZManaged with a Nothing error type, representing a managed resource that cannot fail. The type takes two type parameters: R for environment requirements and A for the success value type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/urmanaged.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype URManaged[-R, +A] = ZManaged[R, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Removing an Element from a TSet in Scala ZIO STM\nDESCRIPTION: Demonstrates how to remove a specific element from a TSet using the delete method. The operation is committed to make it execute.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval deleteElem: UIO[TSet[Int]] = (for {\n  tSet <- TSet.make(1, 2, 3)\n  _    <- tSet.delete(1)\n} yield tSet).commit\n```\n\n----------------------------------------\n\nTITLE: Adding Optional Caliban Integration Modules\nDESCRIPTION: SBT configuration for Caliban's optional modules that provide integration with various libraries including HTTP servers, effect systems, and Apollo Federation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/caliban.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-http4s\"     % \"2.8.1\" // routes for http4s\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-akka-http\"  % \"2.8.1\" // routes for akka-http\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-play\"       % \"2.8.1\" // routes for play\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-finch\"      % \"2.8.1\" // routes for finch\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-cats\"       % \"2.8.1\" // interop with cats effect\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-monix\"      % \"2.8.1\" // interop with monix\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-tapir\"      % \"2.8.1\" // interop with tapir\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-federation\" % \"2.8.1\" // interop with apollo federation\n```\n\n----------------------------------------\n\nTITLE: Creating a Non-Recurring Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that does not recur, just stops and returns one Unit element.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval stop = Schedule.stop\n```\n\n----------------------------------------\n\nTITLE: Pulling Changes from ZIO Main Repository\nDESCRIPTION: Git command to pull changes from the main ZIO repository into your local branch. This synchronizes your fork with the latest updates from the 2.x series branch.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit pull git@github.com:zio/zio.git series/2.x\n```\n\n----------------------------------------\n\nTITLE: Defining ULayer Type Alias in Scala for ZIO\nDESCRIPTION: This code snippet defines the ULayer type alias in Scala for the ZIO library. ULayer[+ROut] is a specialized ZLayer that takes Any as input, has Nothing as its error type, and produces ROut as output. This represents a layer that doesn't require any services, can't fail, and returns a specific output type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/ulayer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype ULayer[+ROut] = ZLayer[Any, Nothing, ROut]\n```\n\n----------------------------------------\n\nTITLE: Defining Scope Trait in Scala\nDESCRIPTION: Definition of the Scope trait, which represents a first-class value for managing resources and finalizers in ZIO 2.0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_64\n\nLANGUAGE: scala\nCODE:\n```\ntrait Scope {\n  def addFinalizerExit(finalizer: Exit[Any, Any] => UIO[Any]): UIO[Unit]\n  def close(exit: Exit[Any, Any]): UIO[Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: ZPool Fixed-Size Constructor\nDESCRIPTION: Constructor signature for creating fixed-size resource pools with ZPool.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zpool.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject ZPool {\n  def make[E, A](get: ZIO[Scope, E, A], size: Int): ZIO[Scope, Nothing, ZPool[E, A]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Query Parameters in ZIO HTTP\nDESCRIPTION: This code shows how to access query parameters from a request in ZIO HTTP. It demonstrates handling a GET request with an optional 'name' query parameter and returning appropriate responses.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http._\n\nval httpApp: Route[Any, Response] =\n  Method.GET / \"greet\" ->\n    handler { (req: Request) =>\n      if (req.url.queryParams.nonEmpty)\n        ZIO.succeed(Response.text(s\"Hello ${req.url.queryParams(\"name\").mkString(\" and \")}!\"))\n      else\n        ZIO.fail(Response.badRequest(\"Missing query parameter 'name'\"))\n    }\n```\n\n----------------------------------------\n\nTITLE: Banking Operations with Balance Check\nDESCRIPTION: Enhanced withdraw function with balance checking, still susceptible to race conditions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef withdraw(accountBalance: Ref[Int], amount: Int) = for {\n  balance <- accountBalance.get\n  _ <- if (balance < amount) ZIO.fail(\"Insufficient funds in you account\") else\n    accountBalance.update(_ - amount)\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Converting Monix Task to ZIO IO in Scala\nDESCRIPTION: This method converts a Monix Task[A] to a ZIO Task[A]. It requires an implicit Scheduler to be in scope for the conversion.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-monix.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef fromTask[A](task: eval.Task[A])(implicit scheduler: Scheduler): Task[A]\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Cache Dependency\nDESCRIPTION: Demonstrates how to add ZIO Cache dependency to an SBT project for caching functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-cache\" % \"0.1.0\" // Check the repo for the latest version\n```\n\n----------------------------------------\n\nTITLE: Creating Person Table in H2 Database\nDESCRIPTION: SQL script for creating the Person table in an H2 database. This is used for database initialization in the Quill example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_51\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE IF NOT EXISTS Person(\n    name VARCHAR(255),\n    age int\n);\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Service in Protocol Buffers\nDESCRIPTION: Demonstrates how to define a simple gRPC service using Protocol Buffers syntax. Includes service definition and message types for a 'Greeter' service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_6\n\nLANGUAGE: protobuf\nCODE:\n```\nsyntax = \"proto3\";\n\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\noption objc_class_prefix = \"HLW\";\n\npackage helloworld;\n\n// The greeting service definition.\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Generators from ZIO Effects in Scala\nDESCRIPTION: Demonstrates how to create generators from ZIO effects, including random number generation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nval gen: Gen[Any, Int] = Gen.fromZIO(Random.nextInt) \n```\n\nLANGUAGE: scala\nCODE:\n```\nval gen: Gen[Any, Int] =\n  Gen.fromZIOSample(\n    Random.nextInt.map(Sample.shrinkIntegral(0))\n  )\n```\n\n----------------------------------------\n\nTITLE: Running Apache Pulsar in Docker for Development\nDESCRIPTION: This Docker command runs a standalone Apache Pulsar instance for local development and testing with necessary port mappings and volume mounts.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-pulsar.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it \\\n  -p 6650:6650 \\\n  -p 8080:8080 \\\n  --mount source=pulsardata,target=/pulsar/data \\\n  --mount source=pulsarconf,target=/pulsar/conf \\\n  --network pulsar \\\n  apachepulsar/pulsar:2.7.0 \\\n  bin/pulsar standalone\n```\n\n----------------------------------------\n\nTITLE: Creating ShardManager Application for ZIO Shardcake\nDESCRIPTION: This code defines the ShardManager application for ZIO Shardcake. It sets up the necessary layers for managing sharding across multiple instances.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport com.devsisters.shardcake.interfaces._\n\nobject ShardManagerApp extends ZIOAppDefault {\n  def run: Task[Nothing] =\n     com.devsisters.shardcake.Server.run.provide(\n      ZLayer.succeed(ManagerConfig.default),\n      ZLayer.succeed(GrpcConfig.default),\n      ZLayer.succeed(RedisConfig.default),\n      RedisLive.layer,\n      StorageRedis.live, // store data in Redis\n      PodsHealth.local,  // just ping a pod to see if it's alive\n      GrpcPods.live,     // use gRPC protocol\n      ShardManager.live  // Shard Manager logic\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Example: IO and Coeval Interoperability - Scala Application\nDESCRIPTION: Shows a full Scala application that demonstrates conversions between ZIO IO and Monix Coeval. Uses interop-monix to create a Coeval from IO and vice versa, and executes them using ZIO's runtime. Dependencies include zio, monix, and the interop-monix module. Outcomes are simple integer computations displayed via println, exemplifying bidirectional interoperability.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-monix.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport monix.eval.Coeval\nimport zio.{ IO, Runtime }\nimport zio.interop.monix._\n\nobject UnsafeExample extends App {\n\n  val runtime = Runtime.default\n\n  def main(args: Array[String]): Unit = {\n    val io1 = IO.succeed(10)\n    val c1  = runtime.unsafeRun(io1.toCoeval) \n\n    println(s\"IO to coeval result is ${c1.value}\")\n\n    val c2  = Coeval(10)\n    val io2 = IO.fromCoeval(c2).map(r => s\"Coeval to IO result is $r\")\n\n    println(runtime.unsafeRun(io2))\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Expanded code for Cats Effect 3.x interop\nDESCRIPTION: Expanded version of the code showing how Cats Effect 3.x integration works under the hood with the asyncRuntimeInstance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport ZioCatsEffectInterop.catsEffectApp\n```\n\n----------------------------------------\n\nTITLE: Asserting String is Non-Empty in Scala\nDESCRIPTION: Creates an assertion `Assertion[String]` that checks if a `String` is not empty.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_24\n\nLANGUAGE: scala\nCODE:\n```\nisNonEmptyString\n```\n\n----------------------------------------\n\nTITLE: Configuring Advanced sidebars.js with Sections for ZIO Documentation\nDESCRIPTION: An extended sidebars.js configuration that organizes documentation into sections and subsections. Shows how to add standalone pages and nested categories with their own pages.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst sidebars = {\n  sidebar: [\n    {\n      type: \"category\",\n      label: \"ZIO XYZ\", // Project Name\n      collapsed: false,\n      link: { type: \"doc\", id: \"index\" },\n      items: [\n        `installation`,\n        `getting-started`,\n        `basics`,\n        {\n          type: \"category\",\n          label: \"Examples\",\n          collapsed: false,\n          link: { type: \"doc\", id: \"examples/index\" },\n          items: [\n            `examples/example-1`,\n            `examples/example-2`\n          ]\n        }\n      ]\n    }\n  ]\n};\n\nmodule.exports = sidebars;\n```\n\n----------------------------------------\n\nTITLE: Asserting Option is Some in Scala\nDESCRIPTION: Creates an assertion `Assertion[Option[Any]]` that simply checks if an `Option` value is a `Some`, without inspecting the contained value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_31\n\nLANGUAGE: scala\nCODE:\n```\nisSome\n```\n\n----------------------------------------\n\nTITLE: Modeling ZIO as a Pure Function in Scala\nDESCRIPTION: This Scala code snippet conceptually models the ZIO effect type, ZIO[R, E, A], as a pure function from environment 'R' to an Either of 'E' (failure) or 'A' (success). It is used for illustrative purposes to help explain how ZIO abstracts computation that may require dependencies and could fail. No external dependencies are required to understand this pattern, but it is not actual executable code; instead, it provides an intuition for ZIO's signature. Input is of type 'R' and output is Either[E, A], matching the ZIO parameters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nR => Either[E, A]\n```\n\n----------------------------------------\n\nTITLE: Enabling Docker Plugins (Scala)\nDESCRIPTION: SBT configuration to enable JavaAppPackaging and DockerPlugin in the build.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nenablePlugins(JavaAppPackaging)\nenablePlugins(DockerPlugin)\n```\n\n----------------------------------------\n\nTITLE: Releasing TSemaphore Permit in Scala ZIO\nDESCRIPTION: Demonstrates how to release a previously acquired permit back to the TSemaphore, allowing other parties to acquire it.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tsemaphore.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreRelease: STM[Nothing, TSemaphore] = for {\n  tSem <- TSemaphore.make(1L)\n  _    <- tSem.acquire\n  _    <- tSem.release\n} yield tSem\n\ntSemaphoreRelease.commit\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Macros as a Library Dependency (Scala)\nDESCRIPTION: Demonstrates including the zio-macros library in your project dependencies to enable the use of ZIO macro annotations, such as @accessible. This step is necessary for any Scala project wishing to generate capability accessors and leverage ZIO's macro-powered features.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-macros\" % \"<zio-version>\"\n```\n\n----------------------------------------\n\nTITLE: Synchronous Aggregation with ZStream#transduce and ZStream#aggregate in Scala\nDESCRIPTION: Synchronous aggregation collects elements into chunks using transducers. Both transduce and aggregate operations produce the same output, collecting elements in groups of 3 and emitting them as chunks to downstream processors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_57\n\nLANGUAGE: scala\nCODE:\n```\nval stream = ZStream(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\nval s1 = stream.transduce(ZTransducer.collectAllN(3))\n// Output Chunk(1,2,3), Chunk(4,5,6), Chunk(7,8,9), Chunk(10)\n\nval s2 = stream.aggregate(ZTransducer.collectAllN(3))\n// Output Chunk(1,2,3), Chunk(4,5,6), Chunk(7,8,9), Chunk(10)\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation with mdoc\nDESCRIPTION: Command to generate documentation site from type-checked markdown files using mdoc\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-documentation.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsbt docs/mdoc\n```\n\n----------------------------------------\n\nTITLE: Implementing OS-specific Tests with ZIO Test Aspects\nDESCRIPTION: Demonstrates how to create tests that run on specific operating systems using ZIO test aspects. Shows usage of unix and mac-specific test aspects along with the generic os aspect for custom OS targeting.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/environment-specific-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\nsuite(\"os\")(\n  test(\"unix test\") {\n    ZIO.attempt(\"running on unix/linux os\")\n      .debug\n      .map(_ => assertTrue(true))\n  } @@ TestAspect.unix,\n  test(\"macos test\") {\n    ZIO.attempt(\"running on macos\")\n      .debug\n      .map(_ => assertTrue(true))\n  } @@ TestAspect.os(_.isMac)\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Expectations for Methods with No Input that Return Unit\nDESCRIPTION: Shows the simplified syntax for creating expectations for methods that take no input and return Unit, where both input assertions and output specifications can be omitted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval exp05 = AccountObserverMock.RunCommand()\n```\n\n----------------------------------------\n\nTITLE: Running Scala MDoc in Watch Mode for Live Preprocessing  Shell\nDESCRIPTION: This shell command starts the Scala MDoc processor in watch mode, monitoring markdown files for changes and automatically re-processing them. Must be executed within an active sbt shell in the project root. Requires sbt and Scala MDoc plugin set up. Ensures documentation is always up-to-date during local development.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ndocs/mdoc --watch\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Concurrent Dependencies in SBT\nDESCRIPTION: SBT dependency configuration for adding the zio-concurrent module to a Scala project. The 2.x.x version pattern indicates compatibility with ZIO 2.x releases.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-concurrent\" % \"2.x.x\"\n```\n\n----------------------------------------\n\nTITLE: Surfacing Failures with ZIO#either in Scala\nDESCRIPTION: This snippet demonstrates surfacing errors from an effect with the 'either' combinator, converting a failing ZIO into one that exposes its error or success as an Either value. It requires the ZIO environment and, for this example, uses IO.fail. No extra dependencies are required beyond ZIO. The input is a standard effect that may fail, and the output is an unfailed effect containing an Either[String, Int]. This pattern preserves the error in a right-biased container and eliminates it from the type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/handling_errors.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nval zeither: UIO[Either[String, Int]] = \n  IO.fail(\"Uh oh!\").either\n```\n\n----------------------------------------\n\nTITLE: Calculating List Length Using Mutable Variable in Scala\nDESCRIPTION: A traditional approach using a mutable variable to track the count of elements while iterating through a list.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef length[T](list: List[T]): Int = {\n  var count = 0\n  for (_ <- list) count += 1\n  count\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Slick Interop Dependency in Scala SBT\nDESCRIPTION: This snippet shows how to add the ZIO Slick Interop library dependency to a Scala project's build.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-slick-interop.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.scalac\" %% \"zio-slick-interop\" % \"0.4.0\"\n```\n\n----------------------------------------\n\nTITLE: Testing Optional Values with TestLens in Scala\nDESCRIPTION: Demonstrates how to use TestLens operators to test optional values in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\ntest(\"optional value is some(42)\") {\n  val sut: Option[Int] = Some(40 + 2)\n  assertTrue(sut.is(_.some) == 42)\n}\n\ntest(\"optional value is anything\") {\n  val sut: Option[Int] = Some(42)\n  assertTrue(sut.is(_.anything))\n}\n```\n\n----------------------------------------\n\nTITLE: Chunk Mapping in ZIO Streams\nDESCRIPTION: Demonstrates how to map chunks of data in a stream using mapChunks operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nval chunked = \n  ZStream\n    .fromChunks(Chunk(1, 2, 3), Chunk(4, 5), Chunk(6, 7, 8, 9))\n\nval stream = chunked.mapChunks(x => x.tail)\n\n// Input:  1, 2, 3, 4, 5, 6, 7, 8, 9\n// Output:    2, 3,    5,    7, 8, 9\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Test Spec Using sbt in Bash\nDESCRIPTION: This bash snippet shows the command to run the ZIO Test specification using sbt. It demonstrates the output of a successful test run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/junit-integration.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsbt:zio-quickstart-junit> test\n+ MySpec\n  + test\n1 tests passed. 0 tests failed. 0 tests ignored.\n\nExecuted in 215 ms\n\n[info] Completed tests\n[success] Total time: 1 s, completed Jun 13, 2023, 4:39:27 PM\n```\n\n----------------------------------------\n\nTITLE: Replacing ZManaged.use with ZIO.scoped in Scala\nDESCRIPTION: Example of replacing ZManaged.use with ZIO.scoped for resource management in ZIO 2.0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_69\n\nLANGUAGE: scala\nCODE:\n```\n- ZManaged\n-  .fromAutoCloseable(zio.blocking.effectBlockingIO(scala.io.Source.fromFile(\"file.txt\")))\n-  .use(x => ZIO.succeed(x.getLines().length))\n+ ZIO.scoped {\n+   ZIO\n+    .fromAutoCloseable(ZIO.attemptBlockingIO(scala.io.Source.fromFile(\"file.txt\")))\n+    .flatMap(x => ZIO.succeed(x.getLines().length))\n+ }\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Sink to Subscriber\nDESCRIPTION: Shows how to convert a ZIO Sink to a Reactive Streams Subscriber with configurable queue size and result handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-reactive-streams.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval sink = Sink.collectAll[Integer]\nruntime.unsafeRun(\n  sink.toSubscriber(qSize = 16).flatMap { case (subscriber, result) => \n    UIO(publisher.subscribe(subscriber)) *> result\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Installing TranzactIO Dependency in Scala SBT\nDESCRIPTION: This snippet shows how to add the TranzactIO library dependency to a Scala project using SBT. It specifies the library coordinates and version.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tranzactio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.github.gaelrenoux\" %% \"tranzactio\" % \"2.1.0\"\n```\n\n----------------------------------------\n\nTITLE: Creating a TSet from an Iterable Collection in Scala ZIO STM\nDESCRIPTION: Creates a TSet from an iterable collection (List) of values. If duplicates are provided, the last one is kept. This operation is performed within an STM transaction context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tset.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval iterableTSet: STM[Nothing, TSet[Int]] = TSet.fromIterable(List(1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Installing Caliban and Required Dependencies with SBT\nDESCRIPTION: SBT configuration to add Caliban core and optional quick module to a Scala project. This snippet shows the required library dependencies for using Caliban with ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/caliban.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban\"       % \"2.8.1\"\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-quick\" % \"2.8.1\" // Optional: HTTP routes via ZIO HTTP\n```\n\n----------------------------------------\n\nTITLE: Creating an Infinite Schedule in Scala ZIO\nDESCRIPTION: Creates a schedule that always recurs and produces the number of recurrences at each run.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/built-in-schedules.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval forever = Schedule.forever\n```\n\n----------------------------------------\n\nTITLE: Generating Site with Docusaurus using SBT  Shell\nDESCRIPTION: This shell command triggers the Docusaurus site generation process via sbt. It first runs the Scala MDoc processor and then generates static HTML files for the documentation site. Requires the project to have Docusaurus and SBT properly configured. The command is typically run after documentation markup changes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsbt docs/docusaurusCreateSite\n```\n\n----------------------------------------\n\nTITLE: Adding UZHttp Dependency for Scala HTTP Server\nDESCRIPTION: This snippet demonstrates how to add the UZHttp library dependency to the Scala project. UZHttp is used to create an HTTP server in the example application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_54\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.polynote\" %% \"uzhttp\" % \"0.2.7\"\n```\n\n----------------------------------------\n\nTITLE: Queue Usage with Chunk in ZIO 2.x\nDESCRIPTION: Updated example showing Queue operations returning Chunk in ZIO 2.x\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_73\n\nLANGUAGE: scala\nCODE:\n```\nval taken: UIO[Chunk[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _     <- queue.offer(10)\n  _     <- queue.offer(20)\n  chunk <- queue.takeUpTo(5)\n} yield chunk\n```\n\n----------------------------------------\n\nTITLE: Migrating Type Alias Usage in ZIO 2.x\nDESCRIPTION: Update usage of type alias companion objects to their corresponding full types in ZIO 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval effect: UIO[Int] = Exit.succeed(1)\n\n// another example:\nval stream: UStream[Int] = ZStream.succeed(1)\n```\n\n----------------------------------------\n\nTITLE: Creating a Function-based Handler in ZIO HTTP\nDESCRIPTION: This snippet shows how to create a Handler from a function in ZIO HTTP. It uses Handler.fromFunction to create a handler that takes an Int and returns a Double.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.http._\n\nval app: Handler[Any, Nothing, Int, Double] = Handler.fromFunction[Int](_ / 2.0)\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in Polish (pl)\nDESCRIPTION: Provides an example pangram for the Polish language, designed to include Polish-specific characters. Includes an English translation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n    Pchn w t d jea lub om skrzy fig\n    ( = To push a hedgehog or eight bins of figs in this boat )\n```\n\n----------------------------------------\n\nTITLE: Converting Monix Task to ZIO Task - Scala Companion Object Method\nDESCRIPTION: Defines an extension method on the ZIO IO companion object to convert a Monix Task into a ZIO Task, requiring an implicit Monix Scheduler. The function takes a Monix Task and returns a ZIO Task, enabling integration in Scala codebases using both libraries. Scheduler dependency ensures proper execution context for Monix effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-monix.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ndef fromTask[A](task: eval.Task[A])(implicit scheduler: Scheduler): Task[A]\n```\n\n----------------------------------------\n\nTITLE: Extracting Left or Failing from ZIO[R, E, Either[A, E]] in Scala\nDESCRIPTION: Transforms a `ZIO[R, E, Either[A, E]]` into a `ZIO[R, E, A]`. This treats the `Either`'s `Left` case as success and `Right` as failure. If the `Either` is `Left(a)`, the effect succeeds with `a`. If it's `Right(e)`, the effect fails with the error `e`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nfrom.leftOrFail\n```\n\n----------------------------------------\n\nTITLE: Adding Optional ZIO Actors Modules in Scala\nDESCRIPTION: This snippet shows how to add optional ZIO Actors modules for persistence and Akka integration to a Scala project using sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-actors-persistence\" % zioActorsVersion\nlibraryDependencies += \"dev.zio\" %% \"zio-actors-persistence-jdbc\" % zioActorVersion\nlibraryDependencies += \"dev.zio\" %% \"zio-actors-akka-interop\" % zioActorVersion\n```\n\n----------------------------------------\n\nTITLE: Demonstration of Recursive State Transformation Calls in Scala\nDESCRIPTION: A sequence of function calls showing how the state is transformed recursively when calculating list length.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nloop(State(0, List(\"a\", \"b\", \"c\", \"d\")))\nloop(State(1, List(\"b\", \"c\", \"d\")))\nloop(State(2, List(\"c\", \"d\")))\nloop(State(3, List(\"d\")))\nloop(State(4, List()))\n// Output:\n// State(4, List())\n```\n\n----------------------------------------\n\nTITLE: Reading HOCON Config with ZIO Config\nDESCRIPTION: Example demonstrating how to read and validate HOCON configuration using ZIO Config with type derivation and refined types\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport eu.timepit.refined.W\nimport eu.timepit.refined.api.Refined\nimport eu.timepit.refined.collection.NonEmpty\nimport eu.timepit.refined.numeric.GreaterEqual\nimport zio.config.magnolia.{describe, descriptor}\nimport zio.config.typesafe.TypesafeConfigSource\nimport zio.console.putStrLn\nimport zio.{ExitCode, URIO, ZIO}\n\nsealed trait DataSource\n\nfinal case class Database(\n    @describe(\"Database Host Name\")\n    host: Refined[String, NonEmpty],\n    @describe(\"Database Port\")\n    port: Refined[Int, GreaterEqual[W.`1024`.T]]\n) extends DataSource\n\nfinal case class Kafka(\n    @describe(\"Kafka Topics\")\n    topicName: String,\n    @describe(\"Kafka Brokers\")\n    brokers: List[String]\n) extends DataSource\n\nobject ZIOConfigExample extends zio.App {\n  import zio.config._\n  import zio.config.refined._\n\n  val json =\n    s\"\"\"\n       |\"Database\" : {\n       |  \"port\" : \"1024\",\n       |  \"host\" : \"localhost\"\n       |}\n       |\"\"\".stripMargin\n\n  val myApp =\n    for {\n      source <- ZIO.fromEither(TypesafeConfigSource.fromHoconString(json))\n      desc = descriptor[DataSource] from source\n      dataSource <- ZIO.fromEither(read(desc))\n      // Printing Auto Generated Documentation of Application Config\n      _ <- putStrLn(generateDocs(desc).toTable.toGithubFlavouredMarkdown)\n      _ <- dataSource match {\n        case Database(host, port) =>\n          putStrLn(s\"Start connecting to the database: $host:$port\")\n        case Kafka(_, brokers) =>\n          putStrLn(s\"Start connecting to the kafka brokers: $brokers\")\n      }\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Generator Derivation using ZIO Test Magnolia (Scala)\nDESCRIPTION: Demonstrates how to use ZIO Test Magnolia module for automatic derivation of generators for custom case classes and sealed traits.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/why-zio-test.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\nimport zio.test.magnolia._\n\ncase class Point(x: Double, y: Double)\n\nval genPoint: Gen[Any, Point] = DeriveGen[Point]\n \nsealed trait Color\ncase object Red   extends Color\ncase object Green extends Color\ncase object Blue  extends Color\n \nval genColor: Gen[Any, Color] = DeriveGen[Color]\n```\n\n----------------------------------------\n\nTITLE: Running Cluster Nodes\nDESCRIPTION: Shell commands for starting multiple cluster nodes with different ports. Shows how to start the seed node and additional cluster members.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nsbt -DHTTP_PORT=8081 -DPORT=2551 \"runMain AkkaClusterShardingExample\"\nsbt -DHTTP_PORT=8082 -DPORT=2552 \"runMain AkkaClusterShardingExample\"\nsbt -DHTTP_PORT=8083 -DPORT=2553 \"runMain AkkaClusterShardingExample\"\n```\n\n----------------------------------------\n\nTITLE: ADT Definition for JSON Encoding/Decoding\nDESCRIPTION: Definition of a sealed trait hierarchy for representing different types of Fruit\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait Fruit extends Product with Serializable\ncase class Banana(curvature: Double) extends Fruit\ncase class Apple (poison: Boolean)   extends Fruit\n```\n\n----------------------------------------\n\nTITLE: Customizing ZIO 1.x Runtime using Platform in Scala\nDESCRIPTION: This Scala snippet demonstrates runtime customization in ZIO 1.x using the `Platform` object within a `zio.App`. It retrieves the current runtime, maps its platform to use a custom `Executor`, and then uses this modified runtime to unsafely run the application logic (`myApp`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.internal.Executor\n\nobject MainApp extends zio.App {\n  val customExecutor: Executor = ???\n\n  val myApp: UIO[Unit] =\n    ZIO.debug(\"Application started\")\n\n  def run(args: List[String]): URIO[ZEnv, ExitCode] =\n    ZIO\n      .runtime[ZEnv]\n      .map { runtime =>\n        Unsafe.unsafe { implicit unsafe =>\n          runtime\n            .mapPlatform(_.withExecutor(customExecutor))\n            .unsafe\n            .run(myApp)\n            .getOrThrowFiberFailure()\n        }\n      }\n      .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Mapping Monix Task Companion Methods to ZIO Task Companion Methods in Scala\nDESCRIPTION: This table enumerates the mappings between static/companion object methods in Monix Task and their equivalents in ZIO Task, for Scala codebases. It aids automatic or manual code translations by documenting one-to-one correspondences for common construction and combinator methods. No code is executed, but all relevant methods are included for migration completeness.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/migrate/from-monix.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\n| Monix  | ZIO |\n|-------|-----|\n| `apply` | `apply` |\n| `asyncF` | `effectAsyncM` |\n| `async` | `effectAsync` |\n| `cancelable` | `effectAsyncInterrupt` |\n| `deferFuture` | `fromFuture` |\n| `defer` | `effectSuspend` |\n| `delay` | `effect` |\n| `eval` | `effect` |\n| `fromEither` | `fromEither` |\n| `fromFuture` | `fromFuture` |\n| `fromTry` | `fromTry` |\n| `map2` | `mapN` |\n| `mapBoth` | `mapParN` |\n| `never` | `never` |\n| `now` | `succeed` |\n| `parMap2` | `mapParN` |\n| `parSequenceN` | `collectAllParN` |\n| `parSequence` | `collectAllPar` |\n| `parTraverseN` | `foreachParN` |\n| `parTraverse` | `foreachPar` |\n| `parZip2` | `tupledPar` |\n| `pure` | `succeed` |\n| `racePair` | `raceWith` |\n| `race` | `raceFirst` |\n| `raiseError` | `fail` |\n| `sequence` | `collectAll` |\n| `shift` | `yield` |\n| `sleep` | `sleep` |\n| `suspend` | `effectSuspend` |\n| `traverse` | `foreach` |\n| `unit` | `unit` |\n```\n\n----------------------------------------\n\nTITLE: Using Approximate Equality Assertion in Scala\nDESCRIPTION: Shows how to use the approximatelyEquals assertion to check if a value is near a reference number within a specified tolerance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.Assertion._\n\nval xs = Vector(0, 1, 2, 3)\n\ntest(\"Fourth value is approximately equal to 5\") {\n  assert(xs)(hasAt(3)(approximatelyEquals(5, 2)))\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying SBT Version in Properties File\nDESCRIPTION: Content for the build.properties file specifying the SBT version to use.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/run-our-first-zio-project-with-vscode.md#2025-04-23_snippet_4\n\nLANGUAGE: properties\nCODE:\n```\nsbt.version = 1.8.0\n```\n\n----------------------------------------\n\nTITLE: Running Docker Container (Bash)\nDESCRIPTION: Command to create and run a new Docker container from the built image, mapping port 80 to 800.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ docker run -p 80:800 zio-quickstart-restful-webservice:0.1.0\n```\n\n----------------------------------------\n\nTITLE: Setting Up Expectations with Mock Capability Tags\nDESCRIPTION: Demonstrates how to create expectations for mock method calls. Shows examples for methods with and without arguments, and explains how to specify expected inputs and return values using Expectation combinators.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.Assertion._\nimport zio.test.mock.Expectation._\nimport zio.test.mock.MockSystem\n\nval exp01 = ExampleMock.SingleArg( // capability to build an expectation for\n  equalTo(42), // assertion of the expected input argument\n  value(\"bar\") // result, that will be returned\n)\n```\n\n----------------------------------------\n\nTITLE: File API example for Resource conversion\nDESCRIPTION: Example implementation of a File API using Cats Effect's Sync type class, to be used in Resource conversion examples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ncase class File[F[_]: cats.effect.Sync]() {\n  import cats.syntax.apply._\n  def read: F[String] =\n    cats.effect.Sync[F].delay(println(\"Reading file.\")) *>\n      cats.effect.Sync[F].pure(\"Hello, World!\")\n  def close: F[Unit]  =\n    cats.effect.Sync[F].delay(println(\"Closing file.\"))\n}\n\nobject File {\n  import cats.syntax.apply._\n  def open[F[_]: cats.effect.Sync](name: String): F[File[F]] =\n    cats.effect.Sync[F].delay(println(s\"opening $name file\")) *>\n      cats.effect.Sync[F].delay(File())\n}\n```\n\n----------------------------------------\n\nTITLE: Example GraphQL Query\nDESCRIPTION: Sample GraphQL query to fetch software developers\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-graphql-webservice.md#2025-04-23_snippet_6\n\nLANGUAGE: graphql\nCODE:\n```\nquery {\n  employees(role: SoftwareDeveloper) {\n    name\n    role\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Akka Cluster Library in Scala\nDESCRIPTION: This snippet demonstrates how to add the ZIO Akka Cluster library dependency to a Scala project using sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-akka-cluster\" % \"0.2.0\" // Check the repo for the latest version\n```\n\n----------------------------------------\n\nTITLE: Test Assertions in ZIO 1.x\nDESCRIPTION: Example of test assertions using ZIO 1.x style\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_76\n\nLANGUAGE: scala\nCODE:\n```\nval list   = List(1, 2, 3, 4, 5)\nval number = 3\nval option = Option.empty[Int]\n\nsuite(\"ZIO 1.x Test Assertions\")(\n  test(\"contains\")(assert(list)(Assertion.contains(5))),\n  test(\"forall\")(assert(list)(Assertion.forall(Assertion.assertion(\"even\")(actual => actual % 2 == 0)))),\n  test(\"less than\")(assert(number)(Assertion.isLessThan(0))),\n  test(\"isSome\")(assert(option)(Assertion.equalTo(Some(3))))\n)\n```\n\n----------------------------------------\n\nTITLE: Serving Documentation Site Locally\nDESCRIPTION: Commands to install dependencies and start local documentation server using npm\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-documentation.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd website\nnpm install\nnpm run start --watch\n```\n\n----------------------------------------\n\nTITLE: ZIO Arrow Installation Configuration\nDESCRIPTION: SBT dependency configuration for ZIO Arrow library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.github.neurodyne\" %% \"zio-arrow\" % \"0.2.1\"\n```\n\n----------------------------------------\n\nTITLE: Defining RLayer Type Alias in Scala\nDESCRIPTION: Defines RLayer as a type alias for ZLayer with generic input type RIn, fixed Throwable error type, and generic output type ROut. This type represents a layer that requires RIn input and produces ROut output, with potential Throwable failures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/rlayer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype RLayer[-RIn, +ROut]  = ZLayer[RIn, Throwable, ROut]\n```\n\n----------------------------------------\n\nTITLE: Defining Frequency Metric API in ZIO (Scala)\nDESCRIPTION: This snippet defines a factory method for creating a Frequency metric in ZIO. The function Metric.frequency accepts a metric name (String) and returns a Frequency[String] type, where each unique String value will have its own automatically managed counter. The implementation is not shown (uses ???), indicating that this is an API declaration. This requires the ZIO Metrics module to be available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/frequency.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nobject Metric {\n  def frequency(name: String): Frequency[String] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Saga in SBT\nDESCRIPTION: SBT dependency configuration for adding the ZIO Saga library, which provides a distributed transaction manager using the Saga Pattern for managing compensating actions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_41\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.vladkopanev\" %% \"zio-saga-core\" % \"0.4.0\"\n```\n\n----------------------------------------\n\nTITLE: Understanding the `test` Function Signature in ZIO Test (Scala)\nDESCRIPTION: This snippet shows the generic signature of the `test` function in ZIO Test. It accepts a label (String) and a by-name assertion parameter `assertion`. It uses path-dependent types (`testConstructor.Out`) to handle different input types (pure values, ZIO effects, ZSTM effects) yielding a test result.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ndef test[In](label: String)(assertion: => In)(implicit testConstructor: TestConstructor[Nothing, In]): testConstructor.Out\n```\n\n----------------------------------------\n\nTITLE: Using Logical IFF Operator with assertTrue in Scala\nDESCRIPTION: Demonstrates the use of the iff operator for bidirectional conditional assertions in ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/smart-assertions.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\n\nsuite(\"iff\") (\n  test(\"true iff true\")(\n    assertTrue(true) iff assertTrue(true) // this will pass\n  ),\n  test(\"true iff false\")(\n    assertTrue(true) iff assertTrue(false) // this will fail\n  ),\n  test(\"false iff true\")(\n    assertTrue(false) iff assertTrue(true) // this will fail\n  ),\n  test(\"false iff false\")(\n    assertTrue(false) iff assertTrue(false) // this will pass\n  )\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Distage in Scala\nDESCRIPTION: Shows how to add Distage as a dependency in a Scala build.sbt file for dependency injection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.7mind.izumi\" %% \"distage-core\" % \"1.0.8\"\n```\n\n----------------------------------------\n\nTITLE: Enabling ZIO SBT Ecosystem Plugin in Scala SBT Build\nDESCRIPTION: This Scala snippet shows how to enable the `ZioSbtEcosystemPlugin` within a project's `build.sbt` file after adding it as a dependency in `project/plugins.sbt`. Enabling this plugin automatically applies various global and project-specific settings, tasks, and helper functions common to the ZIO ecosystem, standardizing the build configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nenablePlugins(ZioSbtEcosystemPlugin)\n```\n\n----------------------------------------\n\nTITLE: Installing LogStage Core Library in Scala\nDESCRIPTION: This snippet shows how to add the LogStage core library dependency to a Scala project using sbt. It specifies the library coordinates for the logstage-core module.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/logstage.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// LogStage core library\nlibraryDependencies += \"io.7mind.izumi\" %% \"logstage-core\" % \"1.0.8\"\n```\n\n----------------------------------------\n\nTITLE: Queue Usage with Chunk in ZIO 1.x\nDESCRIPTION: Example showing Queue operations returning List in ZIO 1.x\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_72\n\nLANGUAGE: scala\nCODE:\n```\nval taken: UIO[List[Int]] = for {\n  queue <- Queue.bounded[Int](100)\n  _     <- queue.offer(10)\n  _     <- queue.offer(20)\n  list  <- queue.takeUpTo(5)\n} yield list\n```\n\n----------------------------------------\n\nTITLE: Adding a New File to Git Staging Area - Bash\nDESCRIPTION: Shows how to stage a specific new file for commit using 'git add'. This makes the file part of the next commit. The file path should match a file relative to the git repository root.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit add core/src/shared/zio/zio/NewFile.scala\n```\n\n----------------------------------------\n\nTITLE: Sending Requests to ZIO Shardcake HttpApp Instances\nDESCRIPTION: These curl commands demonstrate how to send requests to different instances of the HttpApp to increment counters for different entities.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8081/foo/inc\ncurl http://localhost:8082/foo/inc\ncurl http://localhost:8083/foo/inc\n\ncurl http://localhost:8081/bar/inc\ncurl http://localhost:8082/bar/inc\ncurl http://localhost:8083/bar/inc\n```\n\n----------------------------------------\n\nTITLE: Multiple Read Locks with Fibers in Scala\nDESCRIPTION: Shows how multiple fibers can acquire read locks simultaneously and track the number of read locks held.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/treentrantlock.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval multipleReadLocksProgram: UIO[(Int, Int)] = for {\n  lock          <- TReentrantLock.make.commit\n  fiber0        <- lock.acquireRead.commit.fork // fiber0 acquires a read-lock\n  currentState1 <- fiber0.join                  // 1 read lock held\n  fiber1        <- lock.acquireRead.commit.fork // fiber1 acquires a read-lock\n  currentState2 <- fiber1.join                  // 2 read locks held \n} yield (currentState1, currentState2)\n```\n\n----------------------------------------\n\nTITLE: Basic Test Inversion with failing Aspect\nDESCRIPTION: Demonstrates how to use the failing aspect to make a passing test fail. This example shows applying the failing aspect to a test that would normally pass.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/passing-failed-tests.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"failing a passing test\") {\n  assertTrue(true)\n} @@ TestAspect.failing\n```\n\n----------------------------------------\n\nTITLE: Defining the ZState Trait in Scala\nDESCRIPTION: Definition of the ZState trait introduced in ZIO 2.0, which provides get, set, and update operations for stateful programming within ZIO effects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_83\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait ZState[S] {\n  def get: UIO[S]\n  def set(s: S): UIO[Unit]\n  def update(f: S => S): UIO[Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Mock for the AccountObserver Service\nDESCRIPTION: Implementation of a mock AccountObserver service for testing. It defines capability tags for each service method (ProcessEvent and RunCommand) and composes them into a layer that can be used in tests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n// test sources\n\nobject AccountObserverMock extends Mock[AccountObserver] {\n\n  object ProcessEvent extends Effect[AccountEvent, Nothing, Unit]\n  object RunCommand   extends Effect[Unit, Nothing, Unit]\n\n  val compose: URLayer[Has[Proxy], AccountObserver] =\n    ZLayer.fromService { proxy =>\n      new AccountObserver.Service {\n        def processEvent(event: AccountEvent) = proxy(ProcessEvent, event)\n        def runCommand(): UIO[Unit]           = proxy(RunCommand)\n      }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: CI Steps for Checking Website Build\nDESCRIPTION: Additional YAML configuration steps to add to the 'build' phase of a GitHub Actions workflow for checking the website build process.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\n- name: Setup NodeJs\n  uses: actions/setup-node@v4\n  with:\n    node-version: 16.x\n    registry-url: https://registry.npmjs.org\n- name: Check Website Build Process\n  run: sbt docs/clean; sbt docs/buildWebsite\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO OpenTelemetry Dependency to Scala Project\nDESCRIPTION: This snippet shows how to add the ZIO Telemetry library dependency to a Scala project for using the OpenTelemetry client. ZIO Telemetry provides a purely functional and type-safe API for distributed tracing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-telemetry\" % \"0.8.1\"\n```\n\n----------------------------------------\n\nTITLE: Suite Composition in ZIO 2.x\nDESCRIPTION: Example of composing test suites in ZIO 2.x using binary composition operator\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_79\n\nLANGUAGE: scala\nCODE:\n```\nval bigSuite = fooSuite + barSuite + bazSuite\n```\n\n----------------------------------------\n\nTITLE: Retrieving Value from TRef in a Single Transaction\nDESCRIPTION: Demonstrates how to retrieve a value from a TRef within a single transaction. The transaction creates the TRef, gets its value, and then commits the entire operation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval retrieveSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  value <- tRef.get\n} yield value).commit\n```\n\n----------------------------------------\n\nTITLE: Configuring NebulaGraph in HOCON\nDESCRIPTION: HOCON configuration for zio-nebula defining connection parameters for graph, meta, storage, and connection pool settings. Includes host addresses, authentication credentials, timeout settings, and connection pool properties.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-nebula.md#2025-04-23_snippet_2\n\nLANGUAGE: hocon\nCODE:\n```\n{\n  graph {\n    address = [\n      {\n        host = \"127.0.0.1\",\n        port = 9669\n      }\n    ]\n    auth {\n      username = \"root\"\n      password = \"nebula\"\n    }\n    spaceName = \"test\"\n    reconnect = true\n  }\n\n  meta {\n    address = [\n      {\n        host = \"127.0.0.1\",\n        port = 9559\n      }\n    ]\n    timeoutMills = 30000\n    connectionRetry = 3\n    executionRetry = 1\n    enableSSL = false\n  }\n\n  storage {\n    address = [\n      {\n        host = \"127.0.0.1\",\n        port = 9559\n      }\n    ]\n    timeoutMills = 30000\n    connectionRetry = 3\n    executionRetry = 1\n    enableSSL = false\n  }\n\n  pool {\n    timeoutMills = 60000\n    enableSsl = false\n    minConnsSize = 10\n    maxConnsSize = 10\n    intervalIdleMills = 100\n    waitTimeMills = 100\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Feature Display Component in React/JSX\nDESCRIPTION: Defines a React functional component `Feature` that takes a `feature` object (with `title` and `content` properties) as props. It renders a styled `div` containing an `h2` for the title and a `p` tag for the content, using CSS modules (`styles`) for styling. This component is used to display individual feature blocks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// How a single feature block is displayed \nfunction Feature(feature) {\n  return (\n    <div className='container col col--3'>\n      <h2 className={styles.featureTitle}>{feature.title}</h2>\n      <p className={styles.featureText}>{feature.content}</p>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Scala k8s Dependencies in SBT\nDESCRIPTION: SBT configuration for adding Scala k8s core and integration modules to a project. Includes options for different Scala versions and platforms (JVM, JS, Native).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/scala-k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  \"dev.hnaderi\" %% \"scala-k8s-objects\" % \"[VERSION]\", // JVM, JS, Native ; raw k8s objects\n  \"dev.hnaderi\" %% \"scala-k8s-client\" % \"[VERSION]\", // JVM, JS, Native ; k8s client kernel and requests\n  )\n```\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  \"dev.hnaderi\" %% \"scala-k8s-http4s\" % \"[VERSION]\", // JVM, JS, Native ; http4s and fs2 integration\n  \"dev.hnaderi\" %% \"scala-k8s-zio\" % \"[VERSION]\", // JVM ; ZIO native integration using zio-http and zio-json \n  \"dev.hnaderi\" %% \"scala-k8s-sttp\" % \"[VERSION]\", // JVM, JS, Native ; sttp integration using jawn parser\n  \"dev.hnaderi\" %% \"scala-k8s-circe\" % \"[VERSION]\", // JVM, JS ; circe integration\n  \"dev.hnaderi\" %% \"scala-k8s-json4s\" % \"[VERSION]\", // JVM, JS, Native; json4s integration\n  \"dev.hnaderi\" %% \"scala-k8s-spray-json\" % \"[VERSION]\", // JVM ; spray-json integration\n  \"dev.hnaderi\" %% \"scala-k8s-play-json\" % \"[VERSION]\", // JVM ; play-json integration\n  \"dev.hnaderi\" %% \"scala-k8s-zio-json\" % \"[VERSION]\", // JVM, JS ; zio-json integration\n  \"dev.hnaderi\" %% \"scala-k8s-jawn\" % \"[VERSION]\", // JVM, JS, Native ; jawn integration\n  \"dev.hnaderi\" %% \"scala-k8s-manifests\" % \"[VERSION]\", // JVM ; yaml manifest generation\n  \"dev.hnaderi\" %% \"scala-k8s-scalacheck\" % \"[VERSION]\" // JVM, JS, Native; scalacheck instances\n)\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO Type in Scala\nDESCRIPTION: This Scala snippet imports the `ZIO` data type from the `zio` package. This import is a prerequisite for defining or using ZIO effects, including the `IO` type alias discussed in the document, although marked as 'invisible' in the original documentation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/io.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.ZIO\n```\n\n----------------------------------------\n\nTITLE: Adding Scalafix SBT Plugin for ZIO 2.x Migration\nDESCRIPTION: Add the Scalafix SBT plugin to project/plugins.sbt to enable automatic migration from ZIO 1.x to 2.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n// project/plugins.sbt\naddSbtPlugin(\"ch.epfl.scala\" % \"sbt-scalafix\" % \"<version>\")\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Task and RIO type aliases for Cats Effect interop\nDESCRIPTION: Importing ZIO type aliases with Throwable error type for better compatibility with Cats Effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{ZIO, Task, RIO}\n```\n\n----------------------------------------\n\nTITLE: Custom Loggable Implementation Example\nDESCRIPTION: Example of implementing custom Loggable instance with field annotations for masking and hiding sensitive data.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tofu-zio2-logging.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport tofu.logging.derivation._\nimport tofu.logging.derivation.loggable.generate\nimport tofu.logging.zlogs._\nimport zio._\n\ncase class User(\n  id: Int,\n  @hidden\n  password: String,\n  @masked(MaskMode.ForLength(3))\n  login: String,\n  godMode: Boolean = false\n)\n\nval user = User(100, \"secret\", \"username\")\nval userAnnotation: ZLogAnnotation[User] = ZLogAnnotation.make(\"user\")\n\nval program: UIO[Unit] =\n  ZIO.log(\"Hello, ZIO logging!\") @@ userAnnotation(user)\n```\n\n----------------------------------------\n\nTITLE: Creating ZStreams using Unfold in Scala\nDESCRIPTION: Shows how to create ZStreams using the unfold operation, which generates a recursive data structure from an initial value and a state function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval nats: ZStream[Any, Nothing, Int] = ZStream.unfold(1)(n => Some((n, n + 1)))\n\ndef countdown(n: Int) = ZStream.unfold(n) {\n  case 0 => None\n  case s => Some((s, s - 1))\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Markdown Links and Badges for ZIO Documentation\nDESCRIPTION: Collection of markdown reference-style link definitions and badge definitions for ZIO project documentation. Includes links to documentation, metrics, community resources and sponsor information.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[Link-Codecov]: https://codecov.io/gh/zio/zio?branch=master \"Codecov\"\n[Link-IsItMaintained]: http://isitmaintained.com/project/zio/zio \"Average time to resolve an issue\"\n[Link-Scaladoc]: https://javadoc.io/doc/dev.zio/zio_3/latest/zio/index.html\n[Link-Scaladex-page]: https://index.scala-lang.org/zio/zio/zio \"Scaladex\"\n[Link-SonatypeReleases]: https://oss.sonatype.org/content/repositories/releases/dev/zio/zio_3/ \"Sonatype Releases\"\n[Link-SonatypeSnapshots]: https://oss.sonatype.org/content/repositories/snapshots/dev/zio/zio_3/ \"Sonatype Snapshots\"\n[Link-Ziverge]: https://ziverge.com \"Ziverge\"\n[Link-Scalac]: https://scalac.io \"Scalac\"\n[Link-SeptimalMind]: https://7mind.io \"Septimal Mind\"\n[Link-YourKit]: https://www.yourkit.com \"YourKit\"\n[Link-Discord]: https://discord.gg/2ccFBr4 \"Discord\"\n[Link-Twitter]: https://twitter.com/zioscala\n\n[Badge-CI]: https://github.com/zio/zio/workflows/CI/badge.svg\n[Badge-Codecov]: https://codecov.io/gh/zio/zio/coverage.svg?branch=master \"Codecov\"\n[Badge-IsItMaintained]: http://isitmaintained.com/badge/resolution/zio/zio.svg \"Average time to resolve an issue\"\n[Badge-Scaladex-page]: https://index.scala-lang.org/zio/zio/zio/latest.svg \"Scaladex\"\n[Badge-SonatypeReleases]: https://img.shields.io/nexus/r/https/oss.sonatype.org/dev.zio/zio_3.svg \"Sonatype Releases\"\n[Badge-SonatypeSnapshots]: https://img.shields.io/nexus/s/https/oss.sonatype.org/dev.zio/zio_3.svg \"Sonatype Snapshots\"\n[Badge-Discord]: https://img.shields.io/discord/629491597070827530?logo=discord \"chat on discord\"\n[Badge-Twitter]: https://img.shields.io/twitter/follow/zioscala.svg?style=plastic&label=follow&logo=twitter\n[Badge-Stage]: https://img.shields.io/badge/Project%20Stage-Production%20Ready-brightgreen.svg\n[Badge-Stage-Page]: https://github.com/zio/zio/wiki/Project-Stages\n\n[Image-Ziverge]: ./website/static/img/ziverge.png \"Ziverge\"\n[Image-SeptimalMind]: ./website/static/img/septimal_mind.svg \"Septimal Mind\"\n[Image-YourKit]: ./website/static/img/yourkit.png \"YourKit\"\n```\n\n----------------------------------------\n\nTITLE: Interop with Cats Core for zio.Chunk (Scala)\nDESCRIPTION: Shows usage of zio.Chunk with Cats Core data type instances like Traverse, via zio.interop.catz.core._ and cats.implicits. The example constructs a chunk of strings, defines a safe integer parser, and traverses the chunk, collecting Option[Int] results. Required dependencies are cats.Traverse and zio.interop.catz.core. Inputs are chunk elements; output is the result of traversing and printing the parsed sequence. Demonstrates generic data type interoperability.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nimport cats.implicits._\nimport zio.interop.catz.core._\n\nobject ZioInteropWithCatsCore extends cats.effect.IOApp {\n  val chunk = zio.Chunk(\"1\", \"2\", \"3\", \"4\", \"5\")\n\n  def parseInt(s: String): Option[Int] =\n    Either.catchOnly[NumberFormatException](s.toInt).toOption\n\n  val parseAll = cats.Traverse[zio.Chunk].traverse(chunk)(parseInt)\n\n  override def run(args: List[String]): cats.effect.IO[cats.effect.ExitCode] =\n    cats.effect.IO.println(parseAll).as(cats.effect.ExitCode.Success)\n}\n```\n\n----------------------------------------\n\nTITLE: Application Output Showing MatchError for Unhandled Cause - Scala\nDESCRIPTION: Shows sample output when a MatchError occurs due to non-exhaustive patterns in foldCauseZIO. This is a diagnostic output, useful for identifying pattern matching issues in error handling logic. Does not require code execution context, shown for illustration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/folding.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ntimestamp=2022-02-24T11:05:40.241436257Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" scala.MatchError: Interrupt(Runtime(2,1645700739),Trace(Runtime(2,1645700739),Chunk(<empty>.MainApp.exceptionalEffect(MainApp.scala:6),<empty>.MainApp.myApp(MainApp.scala:9)))) (of class zio.Cause$Interrupt)\n\\tat MainApp$.$anonfun$myApp$1(MainApp.scala:10)\n\\tat zio.ZIO$TracedCont$$anon$33.apply(ZIO.scala:6167)\n\\tat zio.ZIO$TracedCont$$anon$33.apply(ZIO.scala:6165)\n\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:885)\n\\tat zio.internal.FiberContext.run(FiberContext.scala:115)\n\\tat zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:538)\"\n```\n\n----------------------------------------\n\nTITLE: Compiling ZIO Production Source Code\nDESCRIPTION: SBT command to compile the main production source code of the ZIO project. This verifies that the code builds successfully.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncompile\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Chunk in Scala\nDESCRIPTION: Creates an empty Chunk instance with no elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval emptyChunk = Chunk.empty\n```\n\n----------------------------------------\n\nTITLE: Launching SBT for ZIO Project Build\nDESCRIPTION: Command to launch SBT build tool with increased heap size. The -J-Xmx8g flag allocates 8GB of memory to prevent slowdowns with default settings.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsbt -J-Xmx8g\n```\n\n----------------------------------------\n\nTITLE: Cloning ZIO Quickstarts Repository\nDESCRIPTION: Commands to clone the ZIO Quickstarts project and navigate to the relevant directory for the metrics example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-restful-webservice-metrics\n```\n\n----------------------------------------\n\nTITLE: Creating Sponsor Display Component in React/JSX\nDESCRIPTION: Defines a React functional component `Sponsor` that accepts a `sponsor` object (with `imageLink`, `image`, `imageAlt`, and `content` properties) as props. It renders a styled `div` containing a linked image of the sponsor's logo and a paragraph with their description, using CSS modules (`styles`). This component displays individual sponsor information.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// How a single sponsor block is being displayed \nfunction Sponsor(sponsor) {\n  return (\n    <div class='container col col--6'>\n      <div className={styles.sponsorImageContainer}>\n        <a href={`${sponsor.imageLink}`}>\n          <img className={styles.sponsorImage} src={`${sponsor.image}`} alt={`${sponsor.imageAlt}`} />\n        </a>\n      </div>\n      <p class={styles.sponsorText}>{sponsor.content}</p>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Signature of ZIO.fail Constructor in Scala\nDESCRIPTION: Defines the type signature for the `ZIO.fail` constructor. It takes an error value of type `E` by name (`=> E`) and returns a `ZIO` effect that fails with that error, having an environment type `Any`, error type `E`, and success type `Nothing`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/failures.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO {\n  def fail[E](error: => E): ZIO[Any, E, Nothing]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing MUnit ZIO Dependencies in Scala SBT\nDESCRIPTION: Add these library dependencies to your build.sbt file to use MUnit ZIO. For sbt versions below 1.5.0, an additional test framework configuration is required.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/munit-zio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.scalameta\" %% \"munit\" % \"0.7.27\" % Test\nlibraryDependencies += \"com.github.poslegm\" %% \"munit-zio\" % \"0.0.2\" % Test\n```\n\nLANGUAGE: scala\nCODE:\n```\ntestFrameworks += new TestFramework(\"munit.Framework\")\n```\n\n----------------------------------------\n\nTITLE: Mapping Monix Task Methods to ZIO Task Methods in Scala\nDESCRIPTION: This table documents the correspondence between Monix's Task methods and their ZIO equivalents, assisting Scala developers transitioning between libraries. It assumes both Monix and ZIO are available as dependencies and organizes method replacements by trait methods. Each entry lists a Monix method and its direct ZIO analog for easy lookup during migration. No executable code is included, but formatting is preserved as in the guide.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/migrate/from-monix.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\n| Monix | ZIO |\n|-------|-----|\n| `attempt` | `either` |\n| `bracketCase` | `bracketExit` |\n| `bracketE` | `bracketExit` |\n| `bracket` | `bracket` |\n| `delayExecution` | `delay` |\n| `dematerialize` | `absolve` |\n| `doOnCancel` | `onInterrupt` |\n| `doOnFinish` | `onExit` |\n| `failed` | `flip` |\n| `flatMap` | `flatMap` |\n| `flatten` | `flatten` |\n| `guaranteeCase` | `ensuringExit` |\n| `guarantee` | `ensuring` |\n| `loopForever` | `forever` |\n| `materialize` | `either` |\n| `memoize` | `memoize` |\n| `onErrorFallbackTo` | `orElse` |\n| `onErrorHandleWith` | `catchAll` |\n| `onErrorRecoverWith` | `catchSome` |\n| `onErrorRestart` | `retryN` |\n| `redeemWith` | `foldM` |\n| `redeem` | `fold` |\n| `restartUntil` | `repeatUntil` |\n| `start` | `fork` |\n| `timed` | `timed` |\n| `timeout` | `timeout` |\n| `uncancelable` | `uninterruptible` |\n```\n\n----------------------------------------\n\nTITLE: Inverting Failed Test Result\nDESCRIPTION: Shows how the failing aspect converts a failing test into a passing one. The test assertion is deliberately false to demonstrate the inversion behavior.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/passing-failed-tests.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\ntest(\"passing a failing test\") {\n  assertTrue(false)\n} @@ TestAspect.failing\n```\n\n----------------------------------------\n\nTITLE: CI Job for Publishing Documentation to npm Registry\nDESCRIPTION: YAML configuration for a GitHub Actions workflow job that publishes the documentation package to the npm registry using the ZIO SBT Website plugin.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nrelease-docs:\n  name: Release Docs\n  runs-on: ubuntu-latest\n  continue-on-error: false\n  needs:\n  - release\n  if: ${{ ((github.event_name == 'release') && (github.event.action == 'published')) }}\n  steps:\n  - name: Git Checkout\n    uses: actions/checkout@v4.1.1\n    with:\n      fetch-depth: '0'\n  - name: Setup NodeJs\n    uses: actions/setup-node@v4\n    with:\n      node-version: 20.x\n      registry-url: https://registry.npmjs.org\n  - name: Publish Docs to NPM Registry\n    run: sbt docs/publishToNpm\n    env:\n      NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}\n```\n\n----------------------------------------\n\nTITLE: Rewriting ZStreamChunk Error Handling Combinators for Infallible Effects\nDESCRIPTION: This table shows how to rewrite ZStreamChunk error handling combinators when dealing with chunk streams that cannot fail (UStream). It provides equivalent expressions that preserve the original behavior without unnecessary error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/canfail.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nustream.either | ustream\nustream.orElse(zstream) | ustream\n```\n\n----------------------------------------\n\nTITLE: Committing Changes with a Commit Message in Git - Bash\nDESCRIPTION: This snippet stages and commits all tracked changes with a specific commit message, using the -a and -m options. Prior staging with 'git add' is required for new files.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \\\"Fixed #94211 - Optimized race for lists of effects\\\"\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO AWS dependencies to build.sbt\nDESCRIPTION: SBT dependency configuration for ZIO AWS integration with core functionality, EC2, ElasticBeanstalk, and Netty HTTP client.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_26\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.github.vigoo\" %% \"zio-aws-core\"             % \"3.17.8.4\",\nlibraryDependencies += \"io.github.vigoo\" %% \"zio-aws-ec2\"              % \"3.17.8.4\",\nlibraryDependencies += \"io.github.vigoo\" %% \"zio-aws-elasticbeanstalk\" % \"3.17.8.4\",\nlibraryDependencies += \"io.github.vigoo\" %% \"zio-aws-netty\"            % \"3.17.8.4\"\n```\n\n----------------------------------------\n\nTITLE: Tamer Dependencies Configuration\nDESCRIPTION: SBT dependency configuration for Tamer Kafka connector with various source modules.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-db\"                % \"0.16.1\"\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-oci-objectstorage\" % \"0.16.1\"\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-rest\"              % \"0.16.1\"\nlibraryDependencies += \"io.laserdisc\" %% \"tamer-s3\"                % \"0.16.1\"\n```\n\n----------------------------------------\n\nTITLE: Atomic Money Transfer with STM\nDESCRIPTION: Final implementation of transfer function using STM to guarantee atomic operations across multiple accounts.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/index.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(from: TRef[Int], to: TRef[Int], amount: Int): IO[String, Unit] =\n  STM.atomically {\n    for {\n      _ <- withdraw(from, amount)\n      _ <- deposit(to, amount)\n    } yield ()\n  }\n```\n\n----------------------------------------\n\nTITLE: ZIO Arrow Example Implementation\nDESCRIPTION: Example demonstrating ZIO Arrow usage for composing operations on standard input/output with power calculations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.arrow.ZArrow\nimport zio.arrow.ZArrow._\nimport zio.console._\nimport zio.{ExitCode, URIO}\n\nimport java.io.IOException\n\nobject ArrowExample extends zio.App {\n\n  val isPositive : ZArrow[Nothing, Int, Boolean]     = ZArrow((_: Int) > 0)\n  val toStr      : ZArrow[Nothing, Any, String]      = ZArrow((i: Any) => i.toString)\n  val toInt      : ZArrow[Nothing, String, Int]      = ZArrow((i: String) => i.toInt)\n  val getLine    : ZArrow[IOException, Any, String]  = ZArrow.liftM((_: Any) => getStrLn.provideLayer(Console.live))\n  val printStr   : ZArrow[IOException, String, Unit] = ZArrow.liftM((line: String) => putStr(line).provideLayer(Console.live))\n  val printLine  : ZArrow[IOException, String, Unit] = ZArrow.liftM((line: String) => putStrLn(line).provideLayer(Console.live))\n  val power2     : ZArrow[Nothing, Int, Double]      = ZArrow((i: Int) => Math.pow(i, 2))\n  val enterNumber: ZArrow[Nothing, Unit, String]     = ZArrow((_: Unit) => \"Enter positive number (-1 to exit): \")\n  val goodbye    : ZArrow[Nothing, Any, String]      = ZArrow((_: Any) => \"Goodbye!\")\n\n  val app: ZArrow[IOException, Unit, Boolean] =\n    enterNumber >>> printStr >>> getLine >>> toInt >>>\n      ifThenElse(isPositive)(\n        power2 >>> toStr >>> printLine >>> ZArrow((_: Any) => true)\n      )(\n        ZArrow((_: Any) => false)\n      )\n\n  val myApp = whileDo(app)(ZArrow(_ => ())) >>> goodbye >>> printLine\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.run(()).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Referencing Guava Interop Module in Markdown\nDESCRIPTION: This snippet provides a link to the interop-guava module on GitHub, which allows conversion of Guava's ListenableFuture to ZIO Task. It also includes a link to Guava's documentation for ListenableFuture.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-guava.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[`interop-guava`](https://github.com/zio/interop-guava) module provide capibility to convert [Guava's `com.google.common.util.concurrent.ListenableFuture`](https://github.com/google/guava/wiki/ListenableFutureExplained) into ZIO `Task`.\n```\n\n----------------------------------------\n\nTITLE: Creating a Dynamic-size Keyed Pool with Uniform Configuration\nDESCRIPTION: Method signature for creating a dynamic-sized ZKeyedPool with range parameters and timeToLive. The pool can grow and shrink within the specified size range, and shrinks after the specified time-to-live period.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zkeyedpool.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nobject ZKeyedPool {\n  def make[Key, Env: EnvironmentTag, Err, Item](\n    get: Key => ZIO[Env, Err, Item],\n    range: Key => Range,\n    timeToLive: Duration\n  ): ZIO[Env with Scope, Nothing, ZKeyedPool[Err, Key, Item]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO SBT Website Plugin\nDESCRIPTION: SBT configuration to add the ZIO SBT Website plugin to a project. This plugin enables type-checked code snippets, README.md generation, and documentation deployment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n// replace <version> with the latest version currently 0.4.0-alpha.22\naddSbtPlugin(\"dev.zio\" % \"zio-sbt-website\" % \"<version>\") \n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Actors Library in Scala\nDESCRIPTION: This snippet shows how to add the ZIO Actors library dependency to a Scala project using sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-actors\" % \"0.0.9\"\n```\n\n----------------------------------------\n\nTITLE: Generating Dockerfile (Bash)\nDESCRIPTION: Command to generate the Dockerfile using sbt-native-packager.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt docker:stage\n```\n\n----------------------------------------\n\nTITLE: Adding HikariCP Integration for Slick in Scala SBT\nDESCRIPTION: This snippet demonstrates how to add the HikariCP integration for Slick as a dependency in the build.sbt file, which is required for the example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-slick-interop.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.typesafe.slick\" %% \"slick-hikaricp\" % \"3.3.3\"\n```\n\n----------------------------------------\n\nTITLE: Deploying RabbitMQ container with Docker\nDESCRIPTION: Docker command to start a RabbitMQ container with management plugin exposed on ports 5672, 5673, and 15672.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -d --name some-rabbit -p 5672:5672 -p 5673:5673 -p 15672:15672 rabbitmq:3-management\n```\n\n----------------------------------------\n\nTITLE: Using foreach to Process Stream Elements in Scala\nDESCRIPTION: This example shows how to process each element of a stream using the foreach operator. It applies the provided effect function to each element, in this case printing each number to the console, and returns an effect that completes when all elements are processed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_67\n\nLANGUAGE: scala\nCODE:\n```\nZStream(1, 2, 3).foreach(x => putStrLn(x.toString))\n```\n\n----------------------------------------\n\nTITLE: TestAspect Order Example 2\nDESCRIPTION: Shows different behavior when changing the order of nonFlaky and repeats aspects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\nsuite(\"suite\")(\n  test(\"A\") {\n    ZIO.debug(\"executing test\")\n      .map(_ => assertTrue(true))\n  },\n) @@ repeats(2) @@ nonFlaky\n```\n\n----------------------------------------\n\nTITLE: Running Tests Command\nDESCRIPTION: Command to execute all JSON-related tests in the project\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt Test/runMain dev.zio.quickstart.JsonSpec\n```\n\n----------------------------------------\n\nTITLE: Executing ZIO Effects in Parallel with Scalaz 7.x Applicative in Scala\nDESCRIPTION: This example illustrates how to run ZIO effects concurrently using the parallel `Applicative` instance from `zio-interop-scalaz7x`. It defines two ZIO effects, `getDetails` and `getHistory`. The `par` helper function tags these effects with `Parallel`, allowing Scalaz's applicative builder `^` to execute them in parallel when constructing a `Dashboard`. This overcomes the sequential nature of the default Monad-derived Applicative.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-scalaz-7x.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nimport scalaz._, Scalaz._\nimport zio.interop.scalaz72._\n\ncase class Dashboard(details: UserDetails, history: TransactionHistory)\n\ndef getDetails(id: UserId): ZIO[Database, UserError, UserDetails] = ...\ndef getHistory(id: UserId): ZIO[Database, UserError, TransactionHistory] = ...\n\ndef buildDashboard(id: UserId): ZIO[Database, UserError, Dashboard] =\n  Tag.unwrap(^(par(getDetails(id)), par(getHistory(id)))(Dashboard.apply))\n\ndef par[R, E, A](io: ZIO[R, E, A]): scalaz72.ParIO[R, E, A] = Tag(io)\n```\n```\n\n----------------------------------------\n\nTITLE: Logback XML Configuration for JSON Logging\nDESCRIPTION: Logback configuration file setup for JSON-formatted logging output using logstash-logback-encoder.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tofu-zio2-logging.md#2025-04-23_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<configuration>\n    <appender name=\"logstash\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">\n            <providers>\n                <pattern>\n                    <pattern>\n                        { \"env\": \"prod\" }\n                    </pattern>\n                </pattern>\n                <timestamp/>\n                <logLevel/>\n                <loggerName/>\n                <message/>\n                <provider class=\"tofu.logging.TofuLoggingProvider\"/>\n            </providers>\n        </encoder>\n    </appender>\n\n    <root level=\"info\">\n        <appender-ref ref=\"logstash\"/>\n    </root>\n\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Schema for Diffing and Protobuf Encoding in Scala\nDESCRIPTION: This example demonstrates creating a schema for a Person case class, running a diff operation between two instances, and encoding data using Protobuf protocol. It shows how to derive schemas automatically and use them for various operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_42\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console.putStrLn\nimport zio.schema.codec.ProtobufCodec._\nimport zio.schema.{DeriveSchema, Schema}\nimport zio.stream.ZStream\nimport zio.{Chunk, ExitCode, URIO}\n\nfinal case class Person(name: String, age: Int, id: String)\nobject Person {\n  implicit val schema: Schema[Person] = DeriveSchema.gen[Person]\n}\n\nPerson.schema\n// res5: Schema[Person] = CaseClass3(\n//   annotations = IndexedSeq(),\n//   field1 = Field(\n//     label = \"name\",\n//     schema = Lazy(\n//       schema0 = zio.schema.DeriveSchema$$$Lambda$4805/0x000000080181bc40@590f88d4\n//     ),\n//     annotations = IndexedSeq()\n//   ),\n//   field2 = Field(\n//     label = \"age\",\n//     schema = Lazy(\n//       schema0 = zio.schema.DeriveSchema$$$Lambda$4806/0x000000080181c840@306f30d3\n//     ),\n//     annotations = IndexedSeq()\n//   ),\n//   field3 = Field(\n//     label = \"id\",\n//     schema = Lazy(\n//       schema0 = zio.schema.DeriveSchema$$$Lambda$4807/0x000000080181cc40@109bfdcb\n//     ),\n//     annotations = IndexedSeq()\n//   ),\n//   construct = zio.schema.DeriveSchema$$$Lambda$4808/0x000000080181d040@1e2c2f73,\n//   extractField1 = zio.schema.DeriveSchema$$$Lambda$4809/0x000000080181d840@3b404d4a,\n//   extractField2 = zio.schema.DeriveSchema$$$Lambda$4810/0x000000080181e840@72e00b59,\n//   extractField3 = zio.schema.DeriveSchema$$$Lambda$4811/0x000000080181f040@3ddad56b\n// )\n\nimport zio.schema.syntax._\n\nPerson(\"Alex\", 31, \"0123\").diff(Person(\"Alex\", 31, \"124\"))\n// res6: schema.Diff = Record(\n//   differences = ListMap(\n//     \"name\" -> Identical,\n//     \"age\" -> Identical,\n//     \"id\" -> Myers(\n//       edits = IndexedSeq(\n//         Delete(s = \"0\"),\n//         Keep(s = \"1\"),\n//         Keep(s = \"2\"),\n//         Insert(s = \"4\"),\n//         Delete(s = \"3\")\n//       )\n//     )\n//   )\n// )\n\ndef toHex(chunk: Chunk[Byte]): String =\n  chunk.toArray.map(\"%02X\".format(_)).mkString\n\nzio.Runtime.default.unsafeRun(\n  ZStream\n    .succeed(Person(\"Thomas\", 23, \"2354\"))\n    .transduce(\n      encoder(Person.schema)\n    )\n    .runCollect\n    .flatMap(x => putStrLn(s\"Encoded data with protobuf codec: ${toHex(x)}\"))\n)\n// Encoded data with protobuf codec: 0A0654686F6D617310171A0432333534\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO IO to Monix Task in Scala\nDESCRIPTION: This method converts a ZIO IO[A] to a Monix Task[A] wrapped in a UIO. It's available as an extension method on IO values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-monix.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef toTask: UIO[eval.Task[A]]\n```\n\n----------------------------------------\n\nTITLE: Example of ZIO 1.x Execution Tracing\nDESCRIPTION: An example application showing how execution tracing worked in ZIO 1.x, where tracing information contained internal operators and was less precise about error locations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_92\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console.Console\n\nobject TracingExample extends zio.App {\n\n  def doSomething(input: Int): ZIO[Console, String, Unit] =\n    for {\n      _ <- console.putStrLn(s\"Do something $input\").orDie // line number 8\n      _ <- ZIO.fail(\"Boom!\")\n      _ <- console.putStrLn(\"Finished my job\").orDie\n    } yield ()\n\n  def myApp: ZIO[Console, String, Unit] =\n    for {\n      _ <- console.putStrLn(\"Hello!\").orDie\n      _ <- doSomething(5)\n      _ <- console.putStrLn(\"Bye Bye!\").orDie\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Exponentially Distributed Values in Scala with ZIO Test\nDESCRIPTION: Shows how to create a generator for exponentially distributed double values and round them for display.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/built-in-generators.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nGen.exponential.map(x => math.round(x * 100) / 100.0)\n  .runCollectN(10)\n  .debug\n// Sample Output: List(0.22, 3.02, 1.96, 1.13, 0.81, 0.92, 1.7, 1.47, 1.55, 0.46)\n```\n\n----------------------------------------\n\nTITLE: Installing NPM Packages for Documentation Site  Shell\nDESCRIPTION: This shell command installs all Node.js project dependencies listed in package.json for the documentation website using npm. Required for the initial setup before running the local Docusaurus server. Needs Node.js and npm installed. Run after cloning the repository or whenever package dependencies change.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO SBT Ecosystem Plugin Dependency in Scala SBT\nDESCRIPTION: This Scala snippet demonstrates adding the `zio-sbt-ecosystem` plugin dependency to an SBT project's `project/plugins.sbt` file. Replace `<version>` with the target plugin version (e.g., 0.4.0-alpha.22). This plugin helps configure common settings (build info, tests, docs, Scala versions, etc.) across ZIO ecosystem projects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\n// replace <version> with the latest version currently 0.4.0-alpha.22\naddSbtPlugin(\"dev.zio\" % \"zio-sbt-ecosystem\" % \"<version>\")\n```\n\n----------------------------------------\n\nTITLE: Object-Oriented Data Modeling in Scala\nDESCRIPTION: Demonstrates the traditional object-oriented approach to modeling data using inheritance and subclassing for different event types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/functional-design-patterns.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nabstract class Event {\n  def id: String\n  def timestamp: Long\n}\n\ncase class ClickEvent(id: String, timestamp: Long, element: String) extends Event\ncase class ViewEvent(id: String, timestamp: Long, page: String) extends Event\n```\n\n----------------------------------------\n\nTITLE: Extracting Some or Failing from ZIO[R, E, Option[A]] in Scala\nDESCRIPTION: Transforms a `ZIO[R, E, Option[A]]` into a `ZIO[R, E, A]`. If the resulting `Option` is `Some(a)`, the effect succeeds with `a`. If it's `None`, the effect fails with the provided `ifEmpty` error of type `E`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nfrom.someOrFail(ifEmpty)\n```\n\n----------------------------------------\n\nTITLE: Running the ZIO Application with SBT\nDESCRIPTION: Commands to run the ZIO application using SBT, including an alternative command for hot-reloading.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt run\n```\n\nLANGUAGE: bash\nCODE:\n```\nsbt reStart\n```\n\n----------------------------------------\n\nTITLE: Focusing on the coreJVM SBT Project - Bash\nDESCRIPTION: Shows how to switch to the 'coreJVM' subproject within sbt, which is the main ZIO module for the JVM platform. Requires an active sbt session. Other subprojects like 'coreJS' are available for different targets.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nproject coreJVM\n```\n\n----------------------------------------\n\nTITLE: CyclicBarrier with Action\nDESCRIPTION: Demonstrates using a CyclicBarrier with an action that executes when the barrier is released. Creates a barrier with a promise that completes when all parties arrive.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/cyclicbarrier.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.CyclicBarrier\nimport zio._\n\nfor {\n  promise <- Promise.make[Nothing, Unit]\n  barrier <- CyclicBarrier.make(2, promise.succeed(()))\n  f1      <- barrier.await.fork\n  _       <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  f2      <- barrier.await.fork\n  _       <- f1.join\n  _       <- f2.join\n  isComplete <- promise.isDone\n} yield assert(isComplete)\n```\n\n----------------------------------------\n\nTITLE: Unrecoverable ZIO Die Example with catchAll - Scala\nDESCRIPTION: Shows that ZIO#catchAll cannot recover from dying effects (defects), only from failures. A ZIO effect first dies via dieMessage, then attempts a failure, with catchAll applied. The output illustrates that only failures are handled, not defects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/catching.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  val die: ZIO[Any, String, Nothing] =\n    ZIO.dieMessage(\"Boom!\") *> ZIO.fail(\"Oh uh!\")\n\n  def run = die.catchAll(_ => ZIO.unit)\n}\n\n// Output:\n// timestamp=2022-03-03T11:04:41.209169849Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.RuntimeException: Boom!\n//  \\tat <empty>.MainApp.die(MainApp.scala:6)\n//\\tat <empty>.MainApp.run(MainApp.scala:8)\"\n```\n\n----------------------------------------\n\nTITLE: LogStage Dependencies Configuration\nDESCRIPTION: SBT dependency configuration for LogStage core and optional modules including JSON output, SLF4J adapters, and DIStage integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\n// LogStage core library\nlibraryDependencies += \"io.7mind.izumi\" %% \"logstage-core\" % \"1.0.8\"\n```\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies ++= Seq(\n  // Json output\n  \"io.7mind.izumi\" %% \"logstage-rendering-circe\" % \"1.0.8\",\n  // Router from Slf4j to LogStage\n  \"io.7mind.izumi\" %% \"logstage-adapter-slf4j\" % \"1.0.8\",\n  // LogStage integration with DIStage\n  \"io.7mind.izumi\" %% \"distage-extension-logstage\" % \"1.0.8\",\n  // Router from LogStage to Slf4J\n  \"io.7mind.izumi\" %% \"logstage-sink-slf4j \" % \"1.0.8\",\n)\n```\n\n----------------------------------------\n\nTITLE: Listing ZIO 1.x Runtime Unsafe Methods in Scala\nDESCRIPTION: This Scala snippet lists various unsafe methods available on the `Runtime` trait in ZIO 1.x. These methods provided different ways to execute ZIO effects outside the standard ZIO application structure, including synchronous, asynchronous, and Future-based execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\ntrait Runtime[+R] {\n  def unsafeRun[E, A](zio: => ZIO[R, E, A]): A\n  def unsafeRunTask[A](task: => RIO[R, A]): A\n  def unsafeRunSync[E, A](zio: => ZIO[R, E, A]): Exit[E, A]\n  def unsafeRunAsync[E, A](zio: => ZIO[R, E, A])(k: Exit[E, A] => Any): Unit\n  def unsafeRunAsyncCancelable[E, A](zio: => ZIO[R, E, A])(k: Exit[E, A] => Any): Fiber.Id => Exit[E, A]\n  def unsafeRunAsync_[E, A](zio: ZIO[R, E, A]): Unit\n  def unsafeRunToFuture[E <: Throwable, A](zio: ZIO[R, E, A]): CancelableFuture[A]\n}\n```\n\n----------------------------------------\n\nTITLE: Rewriting Error-Handling Combinators in ZIO - Scala\nDESCRIPTION: This snippet presents a table of standard error-handling combinator usages on ZIO types where the error channel is Nothing, along with their correct, value-preserving rewrites. It clarifies semantic equivalence and transformation strategies, helping developers refactor unnecessary error-handling layers. No external dependencies required except core ZIO library and idiomatic usage presumes knowledge of error types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/canfail.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nuio <> zio\nuio.catchAll(f)\nuio.catchSome(pf)\nuio.either\nuio.eventually\nuio.flatMapError(f)\nuio.fold(f, g)\nuio.foldM(f, g)\nuio.mapBoth(f, g)\nuio.mapError(f)\nuio.option\nuio.orDie\nuio.orDieWith(f)\nuio.orElse(zio)\nuio.orElseEither(zio)\nuio.orElseFail(e)\nuio.asElseSucceed(a)\nuio.refineOrDie(pf)\nuio.refineOrDieWith(pf)(f)\nuio.refineToOrDie\nuio.retry(s)\nuio.retryOrElse(s, f)\nuio.retryOrElseEither(s, f)\nuio.tapBoth(f, g)\nuio.tapError(f)\nZIO.partitionM(in)(f)\nZIO.partitionMPar(in)(f)\nZIO.partitionMParN(n)(in)(f)\nZIO.validateM(in)(f)\nZIO.validateFirstM(in)(f)\n```\n\n----------------------------------------\n\nTITLE: Creating Task Effect using Task.succeed - Scala\nDESCRIPTION: Shows how to produce a Task effect (type alias for ZIO[Any, Throwable, A]) using Task.succeed for a pure value. No side effects are expected; value is 42. Task is suited for effects that may potentially throw exceptions of type Throwable. Outcome is a successful effect yielding 42.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval s2: Task[Int] = Task.succeed(42)\n```\n\n----------------------------------------\n\nTITLE: H2 Database Configuration for Quill Example\nDESCRIPTION: HOCON configuration for setting up an in-memory H2 database for the Quill example. It includes the URL configuration and initialization script reference.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_52\n\nLANGUAGE: hocon\nCODE:\n```\nmyH2DB {\n  dataSourceClassName = org.h2.jdbcx.JdbcDataSource\n  dataSource {\n    url = \"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;INIT=RUNSCRIPT FROM 'classpath:h2-schema.sql'\"\n    user = sa\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Sample Publisher and Subscriber\nDESCRIPTION: Creates example Publisher and Subscriber implementations for demonstration purposes. The Publisher generates a range of numbers, and the Subscriber prints received values.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-reactive-streams.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval publisher = new RangePublisher(3, 10)\nval subscriber = new SyncSubscriber[Int] {\n  override protected def whenNext(v: Int): Boolean = {\n    print(s\"$v, \")\n    true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TranzactIO Dependencies Configuration\nDESCRIPTION: SBT dependency configuration for TranzactIO library and its Doobie integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_19\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.github.gaelrenoux\" %% \"tranzactio\" % \"2.1.0\"\n\nlibraryDependencies += \"org.tpolecat\" %% \"doobie-core\" % \"0.13.4\"\nlibraryDependencies += \"org.tpolecat\" %% \"doobie-h2\"   % \"0.13.4\"\n```\n\n----------------------------------------\n\nTITLE: Defining UIO Type Alias in Scala\nDESCRIPTION: This snippet shows the definition of the UIO type alias in Scala. It represents a ZIO effect that doesn't require any specific environment, cannot fail, and succeeds with a value of type A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/uio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype UIO[+A] = ZIO[Any, Nothing, A]\n```\n\n----------------------------------------\n\nTITLE: Defining Transducer Type Alias in Scala\nDESCRIPTION: This code defines a type alias Transducer[+E, -A, +B] that simplifies ZTransducer by fixing the environment type parameter to Any. This allows for creating stream transducers that don't require any specific services.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/transducer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Transducer[+E, -A, +B] = ZTransducer[Any, E, A, B]\n```\n\n----------------------------------------\n\nTITLE: Running the GraphQL Web Service Application\nDESCRIPTION: Command to run the application using SBT.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/graphql-webservice.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsbt run\n```\n\n----------------------------------------\n\nTITLE: Embedding ZIO World 2022 Playlist\nDESCRIPTION: HTML iframe element for embedding the ZIO World 2022 conference recordings playlist.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/events/index.md#2025-04-23_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/videoseries?list=PLvdARMfvom9CK_nXP41eioIXZLHvME5gB\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n```\n\n----------------------------------------\n\nTITLE: Adding New Files to Git in ZIO Project\nDESCRIPTION: Git command to add a new file to version control. This stages the file for the next commit, enabling you to track its changes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit add core/src/shared/zio/zio/NewFile.scala\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO NebulaGraph with SBT\nDESCRIPTION: SBT dependency configuration for adding zio-nebula to a Scala project. Users should replace <version> with the appropriate version number based on the compatibility table provided.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-nebula.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.github.jxnu-liguobin\" %% \"zio-nebula\" % <version>\n```\n\n----------------------------------------\n\nTITLE: Running Minio S3-compatible Server with Docker\nDESCRIPTION: Docker command to run a Minio server for S3-compatible object storage locally.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -p 9000:9000 -e MINIO_ACCESS_KEY=MyKey -e MINIO_SECRET_KEY=MySecret minio/minio  server --compat /data\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Test Framework to SBT for Scala (Pre-1.8.0)\nDESCRIPTION: For SBT versions older than 1.8.0, this snippet demonstrates how to manually add the ZIO Test framework to the SBT configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/installation.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntestFrameworks += new TestFramework(\"zio.test.sbt.ZTestFramework\")\n```\n\n----------------------------------------\n\nTITLE: Defining Addition Function Signature in Scala\nDESCRIPTION: Defines the signature of an addition function that takes two integers and returns their sum.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/index.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef add(a: Int, b: Int): Int = ???\n```\n\n----------------------------------------\n\nTITLE: Implementing Resiliency with ZIO Retry and Schedule in Scala\nDESCRIPTION: This snippet showcases ZIO's retry functionality for building resilient applications. It defines a custom retry policy using Schedule combinators to handle specific error types and implement exponential backoff.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/architecture/non-functional-requirements.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  sealed trait DownloadError    extends Throwable\n  case object BandwidthExceeded extends DownloadError\n  case object NetworkError      extends DownloadError\n\n  // flaky api\n  def download(id: String): ZIO[Any, DownloadError, Array[Byte]] = ???\n\n  def isRecoverable(e: DownloadError): Boolean =\n    e match {\n      case BandwidthExceeded => false\n      case NetworkError      => true\n    }\n\n  val policy =\n    (Schedule.recurs(20) &&\n      Schedule.exponential(100.millis))\n      .whileInput(isRecoverable)\n\n  def run = download(\"123\").retry(policy)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Metrics Modules via SBT\nDESCRIPTION: SBT dependencies for adding ZIO Metrics modules (Prometheus, Dropwizard, or StatsD/DogStatsD) to a project. These provide purely-functional approaches to application instrumentation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\n// Prometheus\nlibraryDependencies += \"dev.zio\" %% \"zio-metrics-prometheus\" % \"1.0.12\"\n\n// Dropwizard\nlibraryDependencies += \"dev.zio\" %% \"zio-metrics-dropwizard\" % \"1.0.12\"\n\n// StatsD/DogStatsD\nlibraryDependencies += \"dev.zio\" %% \"zio-metrics-statsd\" % \"1.0.12\"\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Benchmarks JAR from Console\nDESCRIPTION: This command executes the benchmarks JAR file from the console. Replace 'YourClassWithBenchmarks' with the actual benchmark class name. This method provides a more isolated environment for benchmark execution.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/benchmarks/README.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\njava -jar benchmarks/target/scala-2.13/benchmarks.jar .*YourClassWithBenchmarks\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Config Dependencies to build.sbt - Scala\nDESCRIPTION: This snippet lists the `libraryDependencies` lines needed in your Scala sbt build file to include ZIO Config, the Typesafe provider, and Magnolia support. Required for using typed configuration and support for HOCON files in your Scala/ZIO project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-config\"          % \"4.0.2\"\nlibraryDependencies += \"dev.zio\" %% \"zio-config-typesafe\" % \"4.0.2\"\nlibraryDependencies += \"dev.zio\" %% \"zio-config-magnolia\" % \"4.0.2\"\n```\n\n----------------------------------------\n\nTITLE: Combined FiberRef Configuration with Map\nDESCRIPTION: Demonstrates using a Map to combine multiple configuration values into a single FiberRef.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/fiberref.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject Main extends ZIOAppDefault {\n  val retryConfig: FiberRef[Map[String, Int]] =\n    Unsafe.unsafe { implicit unsafe =>\n      FiberRef.unsafe.make(\n        Map(\n          \"retries\" -> 3,\n          \"intervals\" -> 2\n        )\n      )\n    }\n\n  def withRetry(n: Int) = retryConfig.update(_.updated(\"retries\", n))\n\n  def withIntervals(n: Int) = retryConfig.update(_.updated(\"intervals\", n))\n\n  def run =\n    for {\n      - <- withRetry(5) <&> withIntervals(3)\n      _ <- retryConfig.get.debug(\"retryConfig\")\n    } yield ()\n\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rezilience Library Dependencies\nDESCRIPTION: SBT dependency configuration for adding Rezilience to a Scala project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/rezilience.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"nl.vroste\" %% \"rezilience\" % \"<version>\"\n```\n\n----------------------------------------\n\nTITLE: Testing Web Service (Bash)\nDESCRIPTION: cURL command to test the deployed web service by sending a GET request to the greet endpoint.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -i \"http://localhost/greet?name=Jane&name=John\"\n```\n\n----------------------------------------\n\nTITLE: Encoder Mapping Example\nDESCRIPTION: Example of using contramap to create a new encoder from an existing one\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.json._\n\ntest(\"mapping encoders (contramap)\") {\n  case class Person(name: String, age: Int)\n  object Person {\n    implicit val encoder: JsonEncoder[Person] =\n      JsonEncoder[(String, Int)].contramap((p: Person) => (p.name, p.age))\n  }\n\n  val json = Person(\"John\", 42).toJson\n\n  assertTrue(json == \"[\\\"John\\\",42]\")\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ZparkIO Dependency to build.sbt\nDESCRIPTION: SBT dependency for adding ZparkIO to a project. ZparkIO is a framework for using Spark and ZIO together, allowing for ZIO features in Spark jobs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_48\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.leobenkel\" %% \"zparkio\" % \"[SPARK_VERSION]_[VERSION]\"\n```\n\n----------------------------------------\n\nTITLE: Completing Promise with succeed in ZIO (Scala)\nDESCRIPTION: This snippet shows how to create a Promise in ZIO and complete it successfully with a value, returning a Boolean to signal if completion occurred. It depends on ZIO\\'s UIO and Promise. The code creates a Promise of type [Exception, String], and when succeed is called, the Boolean result indicates if the Promise was set. Input is the success value; output is a UIO[Boolean]. The Promise must not be already completed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/promise.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\nval ioPromise1: UIO[Promise[Exception, String]] = Promise.make[Exception, String]\\nval ioBooleanSucceeded: UIO[Boolean] = ioPromise1.flatMap(promise => promise.succeed(\"I'm done\"))\n```\n\n----------------------------------------\n\nTITLE: Illustrating Nested Tuple Type from Zipping in ZIO 1.x (Scala)\nDESCRIPTION: Demonstrates zipping the previously defined `UIO` effects (`x1` through `x4`) using the `<*>` operator (an alias for `zip`) in ZIO 1.x. The comment indicates the resulting effect's type is a deeply nested tuple `ZIO[Any, Nothing, (((Int, Unit), String), Boolean)]`, which can become cumbersome.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval zipped = x1 <*> x2 <*> x3 <*> x4\n// zipped: ZIO[Any, Nothing, (((Int, Unit), String), Boolean)] = ...\n```\n\n----------------------------------------\n\nTITLE: Defining Base URL Constant in JavaScript\nDESCRIPTION: Declares a constant `baseUrl` initialized to '/'. This is likely used as a prefix for constructing relative URLs within the application, ensuring paths work correctly regardless of deployment context.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst baseUrl = '/';\n```\n\n----------------------------------------\n\nTITLE: Reading Parquet File with ZparkIO and ZIO Features\nDESCRIPTION: An example of using ZparkIO to read a Parquet file with ZIO features like retrying and timeouts. This demonstrates how ZIO capabilities can enhance Spark operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nimport com.leobenkel.zparkio.Services.SparkModule\nimport com.leobenkel.zparkio.Services.SparkModule.SparkModule\nimport com.leobenkel.zparkio.ZparkioApplicationTimeoutException\nimport org.apache.spark.sql.DataFrame\nimport zio.clock.Clock\nimport zio.duration.durationInt\nimport zio.{Schedule, Task, ZIO}\n\ndef readParquetFile[A](parquetPath: String): ZIO[Clock with SparkModule, Throwable, DataFrame] =\n  for {\n    spark <- SparkModule()\n    dataset <- Task(spark.read.parquet(parquetPath))\n      .retry(\n        Schedule.recurs(3) && Schedule.exponential(2.seconds)\n      )\n      .timeoutFail(ZparkioApplicationTimeoutException())(5.minutes)\n  } yield dataset\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Kinesis in SBT\nDESCRIPTION: SBT dependency configuration for adding the ZIO Kinesis library, which provides a ZIO-based interface to Amazon Kinesis Data Streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_36\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"nl.vroste\" %% \"zio-kinesis\" % \"0.20.0\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Prometheus Metrics via Curl Command\nDESCRIPTION: This bash command demonstrates how to access the exposed Prometheus metrics from the ZIO application using curl. It sends a GET request to the localhost on port 8080.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_56\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X GET localhost:8080\n```\n\n----------------------------------------\n\nTITLE: Querying Caliban GraphQL API using GraphQL\nDESCRIPTION: Shows a GraphQL query to retrieve all software developers from the Caliban API defined in the previous example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_2\n\nLANGUAGE: graphql\nCODE:\n```\nquery{\n  employees(role: SoftwareDeveloper){\n    name\n    role\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Docusaurus Documentation Server with Yarn  Shell\nDESCRIPTION: This shell command runs the local Docusaurus development server using yarn, serving the static documentation site on port 3000. It enables live reloading when documentation source files change, making it ideal for local development. Requires Docusaurus and yarn to be set up, and typically run from the `website` directory after dependencies are installed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/README.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO SBT CI Plugin Dependency in Scala SBT\nDESCRIPTION: This Scala snippet shows how to add the `zio-sbt-ci` plugin as a dependency to an SBT project. Add this line to `project/plugins.sbt`, replacing `<version>` with the desired plugin version (e.g., 0.4.0-alpha.22). This plugin enables automatic generation of GitHub Actions CI workflows via the `sbt ciGenerateGithubWorkflow` command.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\n// replace <version> with the latest version currently 0.4.0-alpha.22\naddSbtPlugin(\"dev.zio\" % \"zio-sbt-ci\" % \"<version>\") \n```\n\n----------------------------------------\n\nTITLE: Concatenating Chunks in Scala\nDESCRIPTION: Demonstrates how to concatenate two Chunks using the ++ operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nChunk(1,2,3) ++ Chunk(4,5,6)\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO for Repetition\nDESCRIPTION: Imports the necessary ZIO package for using repetition functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/schedule/repetition.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n```\n\n----------------------------------------\n\nTITLE: Rewriting Error-Handling Combinators in ZStreamChunk - Scala\nDESCRIPTION: This snippet provides equivalence guidance for ZStreamChunk combinators, showing rewrite patterns for code where the underlying stream cannot fail. Use cases include stream chunk processing pipelines in ZIO and similar systems, requiring only ZIO library as a prerequisite.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/canfail.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nustream.either\nustream.orElse(zstream)\n```\n\n----------------------------------------\n\nTITLE: Implementing Event Sourcing with Akka Persistence\nDESCRIPTION: Shows how to implement event sourcing using Akka Persistence. It creates a PersistentCounter actor that can increment, decrement, and retrieve its state, while persisting events to storage for recovery.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nimport akka.actor.{ActorSystem, Props}\nimport akka.pattern.ask\nimport akka.persistence._\nimport akka.util.Timeout\n\nimport scala.concurrent.duration.DurationInt\nimport scala.concurrent.{ExecutionContext, ExecutionContextExecutor}\nimport scala.util.{Failure, Success}\n\nclass PersistentCounter extends PersistentActor {\n  private var state: Int = 0\n\n  override def receive = {\n    case \"inc\" => persist(\"inc\")(_ => state += 1)\n    case \"dec\" => persist(\"dec\")(_ => state -= 1)\n    case \"get\" => sender() ! state\n  }\n\n  override def receiveRecover = {\n    case \"inc\" => state += 1\n    case \"dec\" => state -= 1\n  }\n\n  override def receiveCommand: Receive = _ => ()\n\n  override def persistenceId: String = \"my-persistence-id\"\n}\n\nobject MainApp extends App {\n  val system = ActorSystem(\"counter-app\")\n  val counter = system.actorOf(Props[PersistentCounter], \"counter\")\n\n  implicit val ec: ExecutionContextExecutor = ExecutionContext.global\n  implicit val timeout: Timeout = Timeout(1.second)\n\n  counter ! \"inc\"\n  counter ! \"inc\"\n  counter ! \"inc\"\n  counter ! \"dec\"\n\n  (counter ? \"get\").onComplete {\n    case Success(v) =>\n      println(s\"Current value of the counter: $v\")\n    case Failure(e) =>\n      println(s\"Failed to receive the result from the counter: ${e.getMessage}\")\n  }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in Spanish (es)\nDESCRIPTION: Provides an example pangram for the Spanish language. Includes a note stating it contains every letter and accent, but not necessarily every combination of vowel + acute accent.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n    El pingino Wenceslao hizo kilmetros bajo exhaustiva lluvia y\n    fro, aoraba a su querido cachorro.\n    ( Contains every letter and every accent, but not every combination\n    of vowel + acute. )\n```\n\n----------------------------------------\n\nTITLE: Configuring Macro-Annotated Compilation in Scala (Scala)\nDESCRIPTION: Shows how to add the required compiler options or plugins for enabling macro expansions in projects using Scala 2.x. The first snippet adds the -Ymacro-annotations option required for Scala >=2.13, while the second adds the macro-paradise plugin for Scala <2.13. These configurations are prerequisites for using macro annotations such as @accessible or @mockable with ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nscalacOptions += \"-Ymacro-annotations\"\n```\n\nLANGUAGE: scala\nCODE:\n```\ncompilerPlugin((\"org.scalamacros\" % \"paradise\"  % \"2.1.1\") cross CrossVersion.full)\n```\n\n----------------------------------------\n\nTITLE: Declaring Record Class\nDESCRIPTION: Simple case class declaration for a Record type used in the examples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zsink/concurrency-and-parallelism.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ncase class Record()\n```\n\n----------------------------------------\n\nTITLE: Defining Feature Data for ZIO Homepage in JavaScript\nDESCRIPTION: Defines a constant array `features` containing objects, each representing a key feature of the ZIO library. Each object has a `title` and `content` property, intended for display on the homepage to highlight ZIO's capabilities.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst features = [\n  {\n    title: 'High-performance',\n    content: 'Build scalable applications with minimal runtime overhead',\n  },\n  {\n    title: 'Type-safe',\n    content: 'Use the full power of the Scala compiler to catch bugs at compile time',\n  },\n  {\n    title: 'Concurrent',\n    content: 'Easily build concurrent apps without deadlocks, race conditions, or complexity',\n  },\n  {\n    title: 'Asynchronous',\n    content: 'Write sequential code that looks the same whether its asynchronous or synchronous',\n  },\n  {\n    title: 'Resource-safe',\n    content: 'Build apps that never leak resources (including threads!), even when they fail',\n  },\n  {\n    title: 'Testable',\n    content: 'Inject test services into your app for fast, deterministic, and type-safe testing',\n  },\n  {\n    title: 'Resilient',\n    content: 'Build apps that never lose errors, and which respond to failure locally and flexibly',\n  },\n  {\n    title: 'Functional',\n    content: 'Rapidly compose solutions to complex problems from simple building blocks',\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Building ZIO Documentation Site\nDESCRIPTION: SBT command to rebuild the documentation site. This ensures that your API changes don't break the documentation examples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nsbt docs/docusaurusCreateSite\n```\n\n----------------------------------------\n\nTITLE: Type-level Assertion Constructor with hasAt - ZIO Test API Signature - Scala\nDESCRIPTION: Documents the function signature for Assertion.hasAt, showing its usage as a higher-order function that accepts an index and an assertion for the targeted element type. This API requires the ZIO Test framework, where pos specifies the zero-based position to check within a sequence, and assertion is composed on the targeted element. Returns an Assertion applicable to entire sequences. Applicability is subject to A being the type held by the Seq.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nAssertion.hasAt[A](pos: Int)(assertion: Assertion[A]): Assertion[Seq[A]]\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO NIO via SBT\nDESCRIPTION: SBT dependencies for adding ZIO NIO to a project. It provides two options: a core module for low-level NIO operations and a high-level module with deeper ZIO integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_23\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-nio-core\" % \"1.0.0-RC11\"\nlibraryDependencies += \"dev.zio\" %% \"zio-nio\"      % \"1.0.0-RC11\" \n```\n\n----------------------------------------\n\nTITLE: Installing ZIO K8s Client in SBT\nDESCRIPTION: SBT dependency configuration for adding the ZIO K8s client library. This dependency provides access to the Kubernetes API using ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.coralogix\" %% \"zio-k8s-client\" % \"1.3.3\"\n```\n\n----------------------------------------\n\nTITLE: Running Composed Assertion in Scala\nDESCRIPTION: Shows how to run a composed assertion on an expression to get a TestResult.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval result: TestResult = assertion.run(10)\n```\n\n----------------------------------------\n\nTITLE: Testing Metrics with cURL Commands\nDESCRIPTION: Bash commands to test the metrics functionality by sending requests to the application and fetching the metrics.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/monitor-a-zio-application-using-zios-built-in-metric-system.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -i http://localhost:8080/users -d '{\"name\": \"John\", \"age\": 42}'\n$ curl -i http://localhost:8080/users -d '{\"name\": \"Jane\", \"age\": 43}'\n$ curl -i http://localhost:8080/users\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ curl -i http://localhost:8080/metrics\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application (Bash)\nDESCRIPTION: Commands to run the ZIO application using sbt, including an alternative command for hot-reloading.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsbt run\n```\n\nLANGUAGE: bash\nCODE:\n```\nsbt reStart\n```\n\n----------------------------------------\n\nTITLE: Converting Option to ZIO Effect with ZIO.fromOption - Scala\nDESCRIPTION: Shows conversion of an Option[Int] into a ZIO effect using ZIO.fromOption. The resulting effect will succeed with the value if Some, or fail with an Option[Nothing] if None. Inputs are Options; output is an IO (String, Int)-typed effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nval zoption: IO[Option[Nothing], Int] = ZIO.fromOption(Some(2))\n```\n\n----------------------------------------\n\nTITLE: Cloning ZIO Quickstarts Repository and Changing Directory\nDESCRIPTION: Commands to clone the ZIO Quickstarts repository and navigate to the hello-world project directory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/hello-world.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-hello-world\n```\n\n----------------------------------------\n\nTITLE: Akka Cluster Configuration\nDESCRIPTION: HOCON configuration for Akka cluster setup, defining cluster seed nodes and network settings. Includes web service configuration with configurable ports.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_25\n\nLANGUAGE: hocon\nCODE:\n```\nakka {\n  actor {\n    allow-java-serial ization =true \n    provider = \"cluster\"\n  }\n  remote.artery.canonical {\n    hostname = \"127.0.0.1\" \n    port = 2551\n    port=${?PORT}\n  }\n  cluster.seed-nodes= [\"akka://system@127.0.0.1:2551\"]\n}\n\nwebservice {\n  host = \"127.0.0.1\"\n  port = 8082\n  port = ${?HTTP_PORT}\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Value from TRef with Multiple Transactions\nDESCRIPTION: Shows how to retrieve a value from a TRef using multiple transactions. First, it creates and commits a TRef, then it retrieves the value in a separate transaction.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval retrieveMultiple: UIO[Int] = for {\n  tRef <- TRef.makeCommit(10)\n  value <- tRef.get.commit\n} yield value\n```\n\n----------------------------------------\n\nTITLE: Example Test Failure Output for `hasField` Assertion (Bash)\nDESCRIPTION: This snippet shows the console output generated by ZIO Test when a `hasField` assertion fails. It clearly indicates the object being tested, the specific assertion that failed (`hasField(\"age\", ..., isGreaterThanEqualTo(45))`), and the value (`26`) that did not satisfy the condition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n[info]       User(Jonny,26,Address(Denmark,Copenhagen)) did not satisfy (hasField(\"age\", _.age, isGreaterThanEqualTo(45)) && hasField(\"country\", _.country, not(equalTo(USA))))\n[info]       26 did not satisfy isGreaterThanEqualTo(45)\n```\n\n----------------------------------------\n\nTITLE: Kafka Docker Compose Configuration\nDESCRIPTION: Docker Compose configuration for setting up Kafka and Zookeeper for testing\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_17\n\nLANGUAGE: docker\nCODE:\n```\nversion: '2'\nservices:\n  zookeeper:\n    image: confluentinc/cp-zookeeper:latest\n    environment:\n      ZOOKEEPER_CLIENT_PORT: 2181\n      ZOOKEEPER_TICK_TIME: 2000\n    ports:\n      - 22181:2181\n  \n  kafka:\n    image: confluentinc/cp-kafka:latest\n    depends_on:\n      - zookeeper\n    ports:\n      - 29092:29092\n    environment:\n      KAFKA_BROKER_ID: 1\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092\n      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT\n      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT\n      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n```\n\n----------------------------------------\n\nTITLE: Creating Chunk by Filling with Same Element in Scala\nDESCRIPTION: Creates a Chunk by filling it with multiple copies of the same element. The example creates a Chunk with three zeros.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nval chunk: Chunk[Int] = Chunk.fill(3)(0)\n// chunk: Chunk[Int] = IndexedSeq(0, 0, 0)\n```\n\n----------------------------------------\n\nTITLE: Defining Notification Case Class with Scala\nDESCRIPTION: This Scala case class models a notification data type with a single string message payload. Notifications are used to convey side-effectful or external information resulting from domain operations. This class requires no dependencies and acts as a simple DTO within the system.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ncase class Notification(message: String)\n```\n\n----------------------------------------\n\nTITLE: Continuously Testing ZIO Scalafix Rules with sbt\nDESCRIPTION: This shell command uses sbt to continuously run tests (`tests/test`) for the ZIO project. The `~` prefix enables watch mode, automatically re-running tests whenever source files change, facilitating the development of Scalafix rules like the example `CurriedAssert.scala` mentioned in the accompanying comment. Requires sbt to be installed and configured for the ZIO project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/scalafix/readme.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsbt ~tests/test\n# edit rules/src/main/scala/fix/CurriedAssert.scala\n```\n\n----------------------------------------\n\nTITLE: Converting Reactive Streams Subscriber to ZIO Sink in Scala\nDESCRIPTION: Shows how to convert a Reactive Streams `Subscriber` to a ZIO `Sink` using the `toSink` extension method. This method returns a tuple containing a `Promise[Throwable, Nothing]` for error signaling and the `Sink` itself. The example runs a potentially failing ZIO `Stream` into this `Sink` and ensures that if the stream fails, the error is propagated to the `Subscriber` via the `Promise`. The type parameter `[Throwable]` on `toSink` specifies the error type expected from the stream.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-reactive-streams.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval asSink = subscriber.toSink[Throwable]\nval failingStream = Stream.range(3, 13) ++ Stream.fail(new RuntimeException(\"boom!\"))\nruntime.unsafeRun(\n  asSink.flatMap { case (errorP, sink) =>\n    failingStream.run(sink).catchAll(errorP.fail)\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: ZIO Logging with Custom Annotations\nDESCRIPTION: Demonstration of using ZLogAnnotation and TofuDefaultContext for typed, structured logging data.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/tofu-zio2-logging.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nval httpCode: ZLogAnnotation[Int] = ZLogAnnotation.make(\"httpCode\")\n\nval program: UIO[Unit] = {\n  for {\n    _ <- ZIO.log(\"Hello, ZIO logging!\")\n    maybeCode <- ZIO.serviceWithZIO[TofuDefaultContext](_.getValue(httpCode)) // Some(204)\n  } yield ()\n}.provide(TofuDefaultContext.layerZioContextOn) @@ httpCode(204) @@ ZLogAnnotation.loggerName(\"MyLogger\")\n```\n\n----------------------------------------\n\nTITLE: Log Output for Single ZIO Failure (Log)\nDESCRIPTION: This log output shows the result of running the preceding ZIO application. It indicates an ERROR level message from fiber `zio-fiber-2`, displaying the exception type (`java.lang.String`) and the failure message (\"Oh uh!\") along with the stack trace pointing to the `fail` definition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\ntimestamp=2022-03-09T09:50:22.067072131Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.String: Oh uh!\\n\\tat <empty>.MainApp.fail(MainApp.scala:4)\"\n```\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Tests in SBT\nDESCRIPTION: SBT command to run all tests for the ZIO project. This verifies that your changes don't break existing functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsbt test\n```\n\n----------------------------------------\n\nTITLE: Running Redis Docker Container for ZIO Shardcake\nDESCRIPTION: This bash command starts a Redis Docker container to be used as the storage backend for Shardcake.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-akka.md#2025-04-23_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -d -p 6379:6379 --name sampleredis redis\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Slick Interop in SBT\nDESCRIPTION: SBT dependency configuration for adding the ZIO Slick Interop library, which provides integration between Slick database access library and ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_43\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.scalac\" %% \"zio-slick-interop\" % \"0.4.0\"\n```\n\n----------------------------------------\n\nTITLE: Converting Either[B, A] to ZIO[Any, E, A] in Scala\nDESCRIPTION: Transforms a `scala.util.Either[B, A]` into a `ZIO[Any, E, A]` effect. The `mapError` function is used to convert the `Left` value of type `B` into the ZIO error type `E` using the provided `ifLeft` function.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nZIO.fromEither(from).mapError(ifLeft)\n```\n\n----------------------------------------\n\nTITLE: Structuring index.md for ZIO Documentation\nDESCRIPTION: Template for the index.md file that serves as the main documentation page. Includes frontmatter with ID and title, project description, badges placeholder, features list, installation instructions, and example usage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n---\nid: index\ntitle: \"Introduction to ZIO XYZ\"\nsidebar_title: \"ZIO XYZ\"\n---\n\nZIO XYZ is a ZIO Scala library that ...\n\n@PROJECT_BADGES@\n\n## Introduction\n\nKey features of ZIO XYZ are:\n  - Feature 1\n  - Feature 2\n  - ...\n\n## Installation\n\nIn order to use this library, we need to add the following line in our `build.sbt` file:\n\n```scala\nlibraryDependencies += \"dev.zio\" %% \"zio-xyz\" % \"@VERSION@\"\n```\n\n## Example\n\nLet's see an example of how to use this library:\n\n....\n```\n\n----------------------------------------\n\nTITLE: Using Safe Resource Management with TReentrantLock in Scala\nDESCRIPTION: Shows the safer readLock and writeLock methods which use ZIO's Managed to automatically acquire and release locks. This approach helps prevent resource leaks and improper lock handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/treentrantlock.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.clock._\nimport zio.console._\nimport zio.stm._\nimport zio.duration._\n\nval saferProgram: URIO[Console with Clock, Unit] = for {\n  lock <- TReentrantLock.make.commit\n  f1   <- lock.readLock.use_(ZIO.sleep(5.seconds) *> putStrLn(\"Powering down\").orDie).fork\n  f2   <- lock.readLock.use_(lock.writeLock.use_(putStrLn(\"Huzzah, writes are mine\").orDie)).fork\n  _    <- (f1 zip f2).join\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Converting Monix Coeval to ZIO Task - Scala Companion Object Method\nDESCRIPTION: Defines an IO companion object method for converting a Monix Coeval to a ZIO Task. No special implicit dependencies are needed. This enables wrapping a lazily-evaluated Monix Coeval in a ZIO Task effect, supporting integration between the two effect systems in Scala applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-monix.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\ndef fromCoeval[A](coeval: eval.Coeval[A]): Task[A]\n```\n\n----------------------------------------\n\nTITLE: Defining Sponsor Data for ZIO Homepage in JavaScript\nDESCRIPTION: Defines a constant array `sponsors` containing objects, each representing a project sponsor. Each object includes properties for the sponsor's logo (`image`, `imageAlt`), a link to their website (`imageLink`), and a short description (`content`). The `baseUrl` constant is used to construct image paths.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst sponsors = [\n  {\n    image: `${baseUrl}img/ziverge.png`,\n    imageAlt: 'Ziverge',\n    imageLink: 'https://ziverge.com',\n    content: 'Brilliant solutions for innovative companies'\n  },\n  {\n    image: `${baseUrl}img/septimal_mind.svg`,\n    imageAlt: 'Septimal Mind',\n    imageLink: 'https://7mind.io/',\n    content: 'Inventing productivity'\n  },\n  {\n    image: `https://files.softwaremill.com/logo/logo_vertical.png`,\n    imageAlt: 'SoftwareMill',\n    imageLink: 'https://softwaremill.com/',\n    content: 'Custom software by true engineers'\n  },\n];\n```\n\n----------------------------------------\n\nTITLE: Comparing Monix and ZIO Method Equivalents in Scala\nDESCRIPTION: This code block presents a table comparing method names between Monix and ZIO. It shows how various Monix methods can be translated to their ZIO counterparts.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/from-monix.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n| Monix                | ZIO                          |\n|----------------------|------------------------------|\n| `attempt`            | `either`                     |\n| `bracketCase`        | `acquireReleaseExitWith`     |\n| `bracketE`           | `acquireReleaseExitWith`     |\n| `bracket`            | `acquireReleaseWith`         |\n| `delayExecution`     | `delay`                      |\n| `dematerialize`      | `absolve`                    |\n| `doOnCancel`         | `onInterrupt`                |\n| `doOnFinish`         | `onExit`                     |\n| `failed`             | `flip`                       |\n| `flatMap`            | `flatMap`                    |\n| `flatten`            | `flatten`                    |\n| `guaranteeCase`      | `ensuringExit`               |\n| `guarantee`          | `ensuring`                   |\n| `loopForever`        | `forever`                    |\n| `materialize`        | `either`                     |\n| `memoize`            | `memoize`                    |\n| `onErrorFallbackTo`  | `orElse`                     |\n| `onErrorHandleWith`  | `catchAll`                   |\n| `onErrorRecoverWith` | `catchSome`                  |\n| `onErrorRestart`     | `retryN`                     |\n| `redeemWith`         | `foldZIO`                    |\n| `redeem`             | `fold`                       |\n| `restartUntil`       | `repeatUntil`                |\n| `start`              | `fork`                       |\n| `timed`              | `timed`                      |\n| `timeout`            | `timeout`                    |\n| `uncancelable`       | `uninterruptible`            |\n```\n\n----------------------------------------\n\nTITLE: Creating TArray from Iterable in Scala ZIO STM\nDESCRIPTION: Illustrates creating a TArray from an existing collection using STM transactions\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval iterableTArray: STM[Nothing, TArray[Int]] = TArray.fromIterable(List(1, 2, 3))\n```\n\n----------------------------------------\n\nTITLE: Configuring Scala Steward GitHub Action Workflow in YAML\nDESCRIPTION: This YAML snippet defines a GitHub Actions workflow named 'Scala Steward' designed to automatically manage project dependencies. The workflow triggers daily at midnight (`cron: '0 0 * * *'`) or can be run manually (`workflow_dispatch`). It uses the official `scala-steward-action` (version v2.61.0) and authenticates using GitHub App credentials stored as secrets (`SCALA_STEWARD_GITHUB_APP_ID`, `SCALA_STEWARD_GITHUB_APP_INSTALLATION_ID`, `SCALA_STEWARD_GITHUB_APP_PRIVATE_KEY`). This setup is typically used for projects requiring the ZIO organization's Scala Steward instance.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\nname: Scala Steward\n\n# This workflow will launch everyday at 00:00\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch: {}\n\njobs:\n  scala-steward:\n    timeout-minutes: 45\n    runs-on: ubuntu-latest\n    name: Scala Steward\n    steps:\n      - name: Scala Steward\n        uses: scala-steward-org/scala-steward-action@v2.61.0\n        with:\n          github-app-id: ${{ secrets.SCALA_STEWARD_GITHUB_APP_ID }}\n          github-app-installation-id: ${{ secrets.SCALA_STEWARD_GITHUB_APP_INSTALLATION_ID }}\n          github-app-key: ${{ secrets.SCALA_STEWARD_GITHUB_APP_PRIVATE_KEY }}\n          github-app-auth-only: true\n```\n\n----------------------------------------\n\nTITLE: JSON Response from Caliban GraphQL API\nDESCRIPTION: Shows the expected JSON response from the Caliban GraphQL API when querying for software developers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\" : {\n    \"employees\" : [\n      {\n        \"name\" : \"Maria\",\n        \"role\" : \"SoftwareDeveloper\"\n      },\n      {\n        \"name\" : \"Peter\",\n        \"role\" : \"SoftwareDeveloper\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Showing Documentation File Structure in ZIO Ecosystem Projects\nDESCRIPTION: Tree view of the minimum required structure for documentation files in a ZIO ecosystem project. Shows the basic directory layout with index.md, package.json, and sidebars.js.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n~/zio-xyz > tree docs\ndocs\n index.md\n package.json\n sidebars.js\n```\n\n----------------------------------------\n\nTITLE: Validating Weight with ZIO Error Channel\nDESCRIPTION: Shows how to use ZIO's error channel to handle invalid inputs when validating a weight value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ndef validateWeightOrFail(weight: Double): ZIO[Any, String, Double] =\n  if (weight >= 0)\n    ZIO.succeed(weight)\n  else\n    ZIO.fail(s\"negative input: $weight\")\n```\n\n----------------------------------------\n\nTITLE: Defining a Polymorphic Service Interface\nDESCRIPTION: Example of a polymorphic service interface that uses generic types. The service methods have type parameters that require Tag evidence, which is necessary for mocking polymorphic methods with ZIO Test.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/mock-services.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\n// main sources\ntype PolyExample = Has[PolyExample.Service]\n\nobject PolyExample {\n  trait Service {\n    def polyInput[I: Tag](input: I): Task[String]\n    def polyError[E: Tag](input: Int): IO[E, String]\n    def polyOutput[A: Tag](input: Int): Task[A]\n    def polyAll[I: Tag, E: Tag, A: Tag](input: I): IO[E, A]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DocRepo Service with ZIO Dependencies\nDESCRIPTION: Implements the DocRepo trait with DocRepoImpl class that depends on MetadataRepo and BlobStorage services, following the second law of ZIO Environment by accepting dependencies through the constructor.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ncase class DocRepoImpl(\n    metadataRepo: MetadataRepo,\n    blobStorage: BlobStorage\n) extends DocRepo {\n  override def get(id: String): ZIO[Any, Throwable, Doc] =\n    for {\n      metadata <- metadataRepo.get(id)\n      content <- blobStorage.get(id)\n    } yield Doc(\n      metadata.title,\n      metadata.description,\n      metadata.language,\n      metadata.format,\n      content\n    )\n\n  override def save(document: Doc): ZIO[Any, Throwable, String] =\n    for {\n      id <- blobStorage.put(document.content)\n      _ <- metadataRepo.put(\n        id,\n        Metadata(\n          document.title,\n          document.description,\n          document.language,\n          document.format\n        )\n      )\n    } yield id\n\n  override def delete(id: String): ZIO[Any, Throwable, Unit] =\n    for {\n      _ <- blobStorage.delete(id)\n      _ <- metadataRepo.delete(id)\n    } yield ()\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] =\n    for {\n      map <- metadataRepo.findByTitle(title)\n      content <- ZIO.foreach(map)((id, metadata) =>\n        for {\n          content <- blobStorage.get(id)\n        } yield id -> Doc(\n          metadata.title,\n          metadata.description,\n          metadata.language,\n          metadata.format,\n          content\n        )\n      )\n    } yield content.values.toList\n}\n```\n\n----------------------------------------\n\nTITLE: Repeat Combinator Implementation - Scala\nDESCRIPTION: Example showing how to implement a repeat combinator using Ref\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\ndef repeat[E, A](n: Int)(io: IO[E, A]): IO[E, Unit] =\n  Ref.make(0).flatMap { iRef =>\n    def loop: IO[E, Unit] = iRef.get.flatMap { i =>\n      if (i < n)\n        io *> iRef.update(_ + 1) *> loop\n      else\n        IO.unit\n    }\n    loop\n  }\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in English (en)\nDESCRIPTION: Provides the classic English pangram.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n    The quick brown fox jumps over the lazy dog\n```\n\n----------------------------------------\n\nTITLE: Running the Application with Hot-Reloading\nDESCRIPTION: Alternative command to run the application with hot-reloading enabled using sbt-revolver.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/graphql-webservice.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsbt reStart\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ZIO 2.x Layer Warnings for Unnecessary Layers in Scala\nDESCRIPTION: Example of ZIO 2.x application with extra layers, showing warnings for unnecessary layer provisions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_56\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class Config(host: String, port: Int)\n\ntrait Logger {\n  def log(line: Any): Task[Unit]\n}\n\ncase class LoggerLive(console: Console) extends Logger {\n  override def log(line: Any): Task[Unit] =\n    console.printLine(line)\n}\n\nobject LoggerLive {\n  val layer =\n    ZLayer {\n      for {\n        console <- ZIO.service[Console]\n      } yield LoggerLive(console)\n    }\n}\n\nobject MainApp extends ZIOAppDefault {\n  val myApp = for {\n    config <- ZIO.service[Config]\n    _ <- Console.printLine(s\"Application started with the following config: $config\")\n  } yield ()\n\n  def run =\n    myApp.provide(\n      Random.live,\n      ZLayer.succeed(Config(\"localhost\", 8080)),\n      LoggerLive.layer\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Live ZIO Service in Scala\nDESCRIPTION: This snippet shows a 'live' implementation of the `Database` module (`DatabaseLive`) intended for production use. It extends the `Database` trait and provides a concrete instance of `Database.Service` where actual database interactions would occur (indicated by `???`). An object `DatabaseLive` is created extending the trait for easy provision.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n```scala\ntrait DatabaseLive extends Database {\n  def database: Database.Service = \n    new Database.Service {\n      def lookup(id: UserID): Task[UserProfile] = ???\n      def update(id: UserID, profile: UserProfile): Task[Unit] = ???\n    }\n}\nobject DatabaseLive extends DatabaseLive\n```\n```\n\n----------------------------------------\n\nTITLE: Running All Tests in SBT - Bash\nDESCRIPTION: Runs the 'test' suite using sbt, either from the terminal or from an active sbt session. This command verifies that all code and tests compile and pass before proceeding to formatting or submission.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsbt test\n```\n\n----------------------------------------\n\nTITLE: Implementing Logger with Clock Service in ZIO 1.x\nDESCRIPTION: Example of implementing a Logger service in ZIO 1.x that requires explicitly providing the Clock environment for retry operations, showing the common anti-pattern that was addressed in ZIO 2.0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_80\n\nLANGUAGE: scala\nCODE:\n```\ntrait Journal {\n  def append(log: String): ZIO[Any, Throwable, Unit]\n}\n\ntrait Logger {\n  def log(line: String): UIO[Unit]\n}\n\ncase class JournalLoggerLive(clock: Clock, journal: Journal) extends Logger {\n  override def log(line: String): UIO[Unit] = {\n    for {\n      current <- clock.currentDateTime\n      _ <- journal.append(s\"$current--$line\")\n        .retry(Schedule.exponential(2.seconds))\n        .provideEnvironment(ZEnvironment(clock))\n        .orDie\n    } yield ()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rezilience Dependency Configuration\nDESCRIPTION: SBT dependency configuration for Rezilience library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"nl.vroste\" %% \"rezilience\" % \"0.7.0\"\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Project Directory in Bash\nDESCRIPTION: Commands to create a new directory for the ZIO project and navigate into it.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/run-our-first-zio-project-with-vscode.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir my-zio-project\ncd my-zio-project\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO in Scala for Task Alias\nDESCRIPTION: This snippet imports the ZIO type from the zio.ZIO package, which is necessary for defining the Task type alias. The ZIO data type forms the foundation for all effectful computations in the ZIO library. There are no parameters or return values, but the import is required to use ZIO, and thus Task, in the code that follows.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/task.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio.ZIO\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO Test Akka HTTP Dependency in SBT\nDESCRIPTION: This snippet shows how to add the ZIO Test Akka HTTP library dependency to a Scala project using SBT build configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-test-akka-http.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"info.senia\" %% \"zio-test-akka-http\" % \"2.0.0-RC5\"\n```\n\n----------------------------------------\n\nTITLE: Building ZIO Documentation Site in SBT\nDESCRIPTION: SBT command to rebuild the ZIO documentation site. This is necessary when your changes alter the API to ensure that documentation remains accurate.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nsbt docs/docusaurusCreateSite\n```\n\n----------------------------------------\n\nTITLE: Converting Chunk to Array in Scala\nDESCRIPTION: Shows how to convert a Chunk to a native Array using the toArray method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nChunk(1,2,3).toArray\n```\n\n----------------------------------------\n\nTITLE: Creating ZIO Benchmarks JAR\nDESCRIPTION: This command assembles the benchmarks into a JAR file for standalone execution. It's part of the process to minimize noise in benchmark measurements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/benchmarks/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsbt benchmarks/assembly\n```\n\n----------------------------------------\n\nTITLE: Exposing Container Ports (Scala)\nDESCRIPTION: SBT configuration to expose specific ports for the Docker container in the build.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ndockerExposedPorts := Seq(8080)\n```\n\n----------------------------------------\n\nTITLE: Starting Jaeger Backend Container\nDESCRIPTION: Docker command to start the Jaeger all-in-one container with appropriate port mappings for collecting traces.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -d --name jaeger \\\n  -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\\n  -p 5775:5775/udp \\\n  -p 6831:6831/udp \\\n  -p 6832:6832/udp \\\n  -p 5778:5778 \\\n  -p 16686:16686 \\\n  -p 14268:14268 \\\n  -p 9411:9411 \\\n  jaegertracing/all-in-one:1.6\n```\n\n----------------------------------------\n\nTITLE: Formatting ZIO Project Code\nDESCRIPTION: SBT command to format the code according to project standards. This ensures consistent code style before submission.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsbt fmt\n```\n\n----------------------------------------\n\nTITLE: Sample Output of ZIO Temporal Execution\nDESCRIPTION: Console output showing the successful execution of the ZIO Temporal workflow example. Displays log messages from both the workflow client and worker components.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-temporal.md#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n scli zio-temporal.scala\ntimestamp=2023-06-28T09:27:21.171306+02:00 level=INFO thread=zio-fiber-4 message=\"ZWorkerFactory started\"\ntimestamp=2023-06-28T09:27:21.238575+02:00 level=INFO thread=zio-fiber-4 message=\"Will submit message \"testMsg\" with workflow ID echo-82026831-91df-4138-b862-710d87b3ebb4\"\ntimestamp=2023-06-28T09:27:21.5684+02:00   level=INFO thread=zio-fiber-183 message=\"Worker: Received \"testMsg\"\"\ntimestamp=2023-06-28T09:27:21.645988+02:00 level=INFO thread=zio-fiber-4 message=\"Greeting received: ACK: testMsg\"\ntimestamp=2023-06-28T09:27:21.6473+02:00   level=INFO thread=zio-fiber-4 message=\"The workflow result: ACK: testMsg\"\ntimestamp=2023-06-28T09:27:21.705634+02:00 level=INFO thread=zio-fiber-4 message=\"ZWorkerFactory shutdownNow initiated...\"\n```\n\n----------------------------------------\n\nTITLE: Adding HikariCP Integration for Slick in build.sbt\nDESCRIPTION: SBT dependency for adding HikariCP integration for Slick to a project. This is required for connection pooling with Slick.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_44\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.typesafe.slick\" %% \"slick-hikaricp\" % \"3.3.3\"\n```\n\n----------------------------------------\n\nTITLE: Kafka Cluster Docker Compose Configuration\nDESCRIPTION: Docker Compose file to set up a single-node Kafka cluster for testing purposes.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_3\n\nLANGUAGE: docker-compose\nCODE:\n```\nservices:\n  broker:\n    image: apache/kafka:3.9.0\n    container_name: broker\n    ports:\n      - \"9092:9092\"\n    environment:\n      KAFKA_NODE_ID: 1\n      KAFKA_BROKER_ID: 1\n      KAFKA_PROCESS_ROLES: broker,controller\n      KAFKA_LISTENERS: PLAINTEXT://broker:29092,CONTROLLER://broker:29093,PLAINTEXT_HOST://0.0.0.0:9092\n      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:29092,PLAINTEXT_HOST://localhost:9092\n      KAFKA_CONTROLLER_LISTENER_NAMES: CONTROLLER\n      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT,CONTROLLER:PLAINTEXT\n      KAFKA_CONTROLLER_QUORUM_VOTERS: 1@broker:29093\n      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1\n      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1\n      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0\n      KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT\n```\n\n----------------------------------------\n\nTITLE: ADT Codec Derivation\nDESCRIPTION: Automatic derivation of JSON codecs for the Fruit ADT\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/encode-and-decode-json-data.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.json._\n\nobject Fruit {\n  implicit val decoder: JsonDecoder[Fruit] =\n    DeriveJsonDecoder.gen[Fruit]\n\n  implicit val encoder: JsonEncoder[Fruit] =\n    DeriveJsonEncoder.gen[Fruit]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cause Exposure and Inversion Methods in ZIO Trait - Scala\nDESCRIPTION: This snippet defines the ZIO trait with the operations for exposing errors via cause and reversing the operation with uncause. The cause method provides access to the root Cause of an error without triggering failure, while uncause allows treating a Cause as a failure. Dependencies include the zio library and a proper definition of IsSubtypeOfOutput and Cause. Inputs and outputs are type-parameterized, and usage is intended as part of custom effectful computations. This snippet forms the low-level API enabling fine-grained error observation and manipulation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/exposing-the-cause-in-the-succcess-channel.md#2025-04-23_snippet_0\n\nLANGUAGE: Scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def cause: URIO[R, Cause[E]]\n  def uncause[E1 >: E](implicit ev: A IsSubtypeOfOutput Cause[E1]): ZIO[R, E1, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a User Case Class for Typed Annotations (Scala)\nDESCRIPTION: This snippet defines a simple User case class with firstName and lastName fields. It is used in subsequent examples to illustrate typed log annotations in ZIO Logging. Dependencies: none. Inputs/Outputs: class declaration. Used for structured logging.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/logging.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\ncase class User(firstName: String, lastName: String)\n```\n\n----------------------------------------\n\nTITLE: Committing Changes with Issue Reference in Bash\nDESCRIPTION: Git command to commit all staged changes with a message that references the issue number. The -am flag adds all tracked files and includes a commit message.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \"Fixed #94211 - Optimized race for lists of effects\"\n```\n\n----------------------------------------\n\nTITLE: Setting up FTP Server with Docker\nDESCRIPTION: Docker command to run an FTP server for testing ZIO FTP client\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -d \\\n    -p 21:21 \\\n    -p 21000-21010:21000-21010 \\\n    -e USERS=\"one|1234\" \\\n    -e ADDRESS=localhost \\\n    delfer/alpine-ftp-server\n```\n\n----------------------------------------\n\nTITLE: Docker Command for Running Apache Pulsar\nDESCRIPTION: Docker command to start an Apache Pulsar instance locally for development and testing. This configuration exposes the necessary ports and mounts volumes for data persistence.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it \\\n  -p 6650:6650 \\\n  -p 8080:8080 \\\n  --mount source=pulsardata,target=/pulsar/data \\\n  --mount source=pulsarconf,target=/pulsar/conf \\\n  --network pulsar \\\n  apachepulsar/pulsar:2.7.0 \\\n  bin/pulsar standalone\n```\n\n----------------------------------------\n\nTITLE: Compiling Production Source Code with SBT - Bash\nDESCRIPTION: The snippet illustrates running the 'compile' command within an sbt session to compile the main source code. The sbt environment must be running. No parameters are needed, and output will be compiled class files in the target directory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncompile\n```\n\n----------------------------------------\n\nTITLE: Exception Translation to Defects with ZIO.succeed - Scala\nDESCRIPTION: Demonstrates that exceptions thrown within ZIO.succeed are automatically translated to ZIO defects. 'defect3' uses ZIO.succeed with a thrown exception, which becomes a defect in the ZIO runtime. Dependency: zio._. Shows how pure shortcuts can mask defects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_8\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval defect3 = ZIO.succeed(throw new Exception(\"boom!\"))\n```\n\n----------------------------------------\n\nTITLE: Checking Current Changes with Git Status - Bash\nDESCRIPTION: Demonstrates using 'git status' to show uncommitted changes, new files, and changes staged for commit. Git must be installed and initialized in the current directory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit status\n```\n\n----------------------------------------\n\nTITLE: Using CatsApp trait for simplified Runtime handling\nDESCRIPTION: Example using the CatsApp trait which automatically provides an implicit Runtime[Any] for easier Cats Effect integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/interop/with-cats-effect.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.interop.catz._\nimport cats.implicits._\n\nobject ZioCatsEffectInteropWithCatsApp extends CatsApp {\n  def catsEffectApp[F[_]: cats.effect.Sync]: F[Unit] =\n    cats.effect.Sync[F].delay(println(\"Hello from Cats Effect World!\"))\n\n  override def run(args: List[String]): zio.URIO[Any, zio.ExitCode] = \n    catsEffectApp[zio.Task].exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Pangram Examples in Icelandic (is)\nDESCRIPTION: Provides two example pangrams or near-pangrams for the Icelandic language. One notes that some ASCII letters might be missing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n    Kmi n xi hr ykist jfum n bi vl og drepa\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n    Svar r grt  v lpan var nt\n    ( some ASCII letters missing )\n```\n\n----------------------------------------\n\nTITLE: Unsafe String to Int Conversion with map - Scala\nDESCRIPTION: Illustrates the use of ZIO's map with an operation that may throw an unchecked exception (String#toInt), resulting in effect defects instead of caught failures. Requires zio._ and a Console service for reading input. Intended to show that unhandled exceptions in map will crash the program if not managed safely, as with mapAttempt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/map-operations.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nval result: ZIO[Any, Nothing, Int] =\n  Console.readLine.orDie.map(_.toInt)\n\n```\n\n----------------------------------------\n\nTITLE: Interleaving ZIO Streams Deterministically\nDESCRIPTION: This example shows how to interleave two streams deterministically using the interleave operator, which pulls an element from each stream in alternating fashion until one is exhausted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 2, 3)\nval s2 = ZStream(4, 5, 6, 7, 8)\n\nval interleaved = s1 interleave s2\n\n// Output: 1, 4, 2, 5, 3, 6, 7, 8\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO onExit Method Signature\nDESCRIPTION: Shows the method signature for ZIO's onExit operation, used to specify finalizers that require the exit status of the effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/gracefully-shutdown-zio-application.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  final def onExit[R1 <: R](cleanup: Exit[E, A] => URIO[R1, Any]): ZIO[R1, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Functional Scala 2021 Playlist\nDESCRIPTION: HTML iframe element for embedding the Functional Scala 2021 conference recordings playlist.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/events/index.md#2025-04-23_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/videoseries?list=PLvdARMfvom9COGPlva4OnTkFEXzXhhqNH\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Project Tests\nDESCRIPTION: SBT command to run all tests in the ZIO project. This verifies that your changes don't break existing functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsbt test\n```\n\n----------------------------------------\n\nTITLE: Executing a ZIO Effect Unsafely for Debugging\nDESCRIPTION: An example showing how to unsafely execute a ZIO effect to see its result for debugging purposes, although this approach is not idiomatic for ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/debug-a-zio-application.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval effect: ZIO[Any, Nothing, Int] = \n  ZIO.succeed(3).map(_ * 2)\n\nval executedEffect: Int =\n  Unsafe.unsafe { implicit unsafe =>\n    Runtime.default.unsafe.run(effect).getOrThrowFiberFailure()\n  }\n  \nprintln(s\"executedEffect: $executedEffect\")\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application with Multiple Service Dependencies\nDESCRIPTION: Demonstrates how to run a ZIO application that requires multiple services (A, B, and C).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/dependency-injection-in-zio.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MainApp extends ZIOAppDefault {\n  def run = myApp.provide(A.layer, B.layer, C.layer)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ZIO SBT Website Plugin in build.sbt\nDESCRIPTION: Complete configuration for enabling the ZIO SBT Website plugin in build.sbt. Creates a separate docs submodule with settings for project name, main module name, and project stage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nlazy val root = (project in file(\".\"))\n  .settings(publish / skip := true)\n  .aggregate(core, docs)\n\nlazy val core = (project in file(\"zio-xyz\"))\n\nlazy val docs = (project in file(\"zio-xyz-docs\"))\n  .enablePlugins(WebsitePlugin)\n  .settings(projectName := \"ZIO XYZ\")\n  .settings(mainModuleName := (core / moduleName).value)\n  .settings(projectStage := ProjectStage.ProductionReady)\n```\n\n----------------------------------------\n\nTITLE: Defining TaskLayer Type Alias in Scala for ZIO\nDESCRIPTION: This code snippet defines the TaskLayer type alias as a ZLayer that takes Any as input, may fail with Throwable, and produces ROut as output. It represents a layer that doesn't require any services as input and can potentially fail.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/task-layer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype TaskLayer[+ROut] = ZLayer[Any, Throwable, ROut]\n```\n\n----------------------------------------\n\nTITLE: Adding Async HTTP Client Backend for ZIO K8s\nDESCRIPTION: SBT dependency configuration for the asynchronous HTTP client backend for ZIO K8s, providing non-blocking HTTP requests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_34\n\nLANGUAGE: scala\nCODE:\n```\n\"com.softwaremill.sttp.client3\" %% \"async-http-client-backend-zio\" % \"3.1.1\"\n\"com.softwaremill.sttp.client3\" %% \"slf4j-backend\"                 % \"3.1.1\"\n```\n\n----------------------------------------\n\nTITLE: Git Clone Commands for ZIO Quickstarts Project\nDESCRIPTION: Commands to clone and navigate to the ZIO Quickstarts project repository containing the logging examples.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/create-custom-logger-for-a-zio-application.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-restful-webservice-custom-logger\n```\n\n----------------------------------------\n\nTITLE: Comparing Chunks in Scala\nDESCRIPTION: Shows how to compare two Chunks for equality using the == operator.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nChunk(\"A\",\"B\") == Chunk(\"A\", \"C\")\n```\n\n----------------------------------------\n\nTITLE: Constructing ZIO Homepage Layout in React/JSX\nDESCRIPTION: Defines the main `Home` React component for the ZIO project website using Docusaurus. It utilizes `useDocusaurusContext` to fetch site configuration (`siteConfig`), renders the overall page `Layout` with title and description, includes a header with tagline and 'Get Started' `Link`, integrates the `Newsletter` component, and dynamically renders sections for features and sponsors by mapping over the `features` and `sponsors` data arrays and using the `Feature` and `Sponsor` components respectively. CSS modules (`styles`) are used throughout for styling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Construct the home page from all components \nfunction Home() {\n  const context = useDocusaurusContext();\n  const { siteConfig = {} } = context;\n  return (\n    <Layout\n      title={`${siteConfig.title}`}\n      description={`${siteConfig.tagline}`}\n      image='/img/navbar_brand2x.png'>\n      <header className={styles.headerContainer}>\n        <div className={styles.headerRelative}>\n          <div className={styles.newsInnerContainer}>\n            <Newsletter />\n          </div>\n          <div className={`container {styles.headerInnerContainer}`}>\n            <img className={styles.headerImage} src=\"/img/jumbotron_pattern.png\" alt={`${siteConfig.title}`} />\n            <div className={styles.headerDetailContainer}>\n              <p className={styles.headerTagline}>{siteConfig.tagline}</p>\n              <div className={styles.headerButtonContainer}>\n                <Link\n                  className={`${styles.headerButton}`}\n                  to={useBaseUrl('getting_started')}>\n                  Get Started\n                </Link>\n              </div>\n            </div>\n          </div>\n        </div>\n      </header >\n      <main>\n        {features && features.length > 0 && (\n          <section className={styles.featureSection}>\n            <div class='container'>\n              <div class='row'>\n                {features.map((f, idx) => (\n                  <Feature key={idx} {...f} />\n                ))}\n              </div>\n            </div>\n          </section>\n        )}\n\n        {sponsors && sponsors.length > 0 && (\n          <section className={styles.sponsorSection}>\n            <div class='container'>\n              <div class='row'>\n                {sponsors.map((s, idx) => (\n                  <Sponsor key={idx} {...s} />\n                ))}\n              </div>\n            </div>\n          </section>\n        )}\n      </main>\n    </Layout >\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO FTP Dependency\nDESCRIPTION: SBT dependency configuration for ZIO FTP client module\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-ftp\" % \"0.3.0\"\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO for RIO Definition in Scala\nDESCRIPTION: This code snippet imports the ZIO class, which is necessary for defining the RIO type alias.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/core/zio/rio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.ZIO\n```\n\n----------------------------------------\n\nTITLE: Changing ZIO Bracket Signature to By-Name Parameter (Diff/Scala)\nDESCRIPTION: Displays a diff comparing the ZIO 1.x and potential ZIO 2.x signatures for `bracket` (or its equivalent like `acquireReleaseWith`). It illustrates the change of the `acquire` parameter from a standard by-value parameter (`acquire: ZIO[R, E, A]`) to a by-name parameter (`acquire: => ZIO[R, E, A]`), enabling lazy evaluation of the acquire effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\n- def bracket[R, E, A](acquire: ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n+ def bracket[R, E, A](acquire: => ZIO[R, E, A]): ZIO.BracketAcquire[R, E, A]\n```\n\n----------------------------------------\n\nTITLE: Generating Pure Capability Accessors With @accessible (Scala)\nDESCRIPTION: Presents a module object annotated with @accessible and a Service trait containing a pure method. ZIO automatically generates an accessor function (with Nothing error type) for use in effectful code. Requires zio-macros and ZIO environment. Input: Something, Output: SomethingElse inside a ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{ Has, ZIO }\nimport zio.macros.accessible\n\n@accessible\nobject Module {\n  trait Service {\n    def pureMethod(v: Something): SomethingElse\n  }\n\n  // below will be autogenerated\n  def pureMethod(v: Something): ZIO[Service, Nothing, SomethingElse] =\n    ZIO.access[Has[Module.Service]](_.get[Service].pureMethod(v))\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO-managed Dependency in SBT\nDESCRIPTION: SBT configuration to add the zio-managed dependency for backward compatibility with ZIO 1.x ZManaged.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_67\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-managed\" % \"<2.x version>\"\n```\n\n----------------------------------------\n\nTITLE: Configuring README Credits in Scala Build File\nDESCRIPTION: Example of how to customize the credits section in the README.md file by modifying the build.sbt file for a ZIO library project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nlazy val docs = (project in file(\"zio-xyz-docs\"))\n  .enablePlugins(WebsitePlugin)\n  .settings(projectName := \"ZIO XYZ\")\n  .settings(mainModuleName := (core / moduleName).value)\n  .settings(projectStage := ProjectStage.ProductionReady)\n  .settings(\n    readmeCredits :=\n      \"\"\"\n        |The creation of this library is deeply influenced by the exploration and  \n        | implementation conducted at ABC corporation.\"\"\".stripMargin,\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing ZIO gRPC Server in Scala\nDESCRIPTION: Shows how to implement a ZIO gRPC server in Scala based on the previously defined Protocol Buffers service. Includes service implementation and server configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport io.grpc.ServerBuilder\nimport io.grpc.examples.helloworld.helloworld.ZioHelloworld.ZGreeter\nimport io.grpc.examples.helloworld.helloworld.{HelloReply, HelloRequest}\nimport io.grpc.protobuf.services.ProtoReflectionService\nimport scalapb.zio_grpc.{ServerLayer, ServiceList}\nimport zio.console.putStrLn\nimport zio.{ExitCode, URIO, ZEnv, ZIO}\n\nobject HelloWorldServer extends zio.App {\n\n  val helloService: ZGreeter[ZEnv, Any] =\n    (request: HelloRequest) =>\n      putStrLn(s\"Got request: $request\") *>\n        ZIO.succeed(HelloReply(s\"Hello, ${request.name}\"))\n\n\n  val myApp = for {\n    _ <- putStrLn(\"Server is running. Press Ctrl-C to stop.\")\n    _ <- ServerLayer\n      .fromServiceList(\n        ServerBuilder\n          .forPort(9000)\n          .addService(ProtoReflectionService.newInstance()),\n        ServiceList.add(helloService))\n      .build.useForever\n  } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Rebuilding Microsite Documentation with SBT - Bash\nDESCRIPTION: This snippet invokes the 'docs/docusaurusCreateSite' command in sbt to build the project's microsite documentation. This is necessary when API changes may impact compiled documentation. It may require resolving Jekyll warnings.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsbt docs/docusaurusCreateSite\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO SQS Dependency to Scala Project\nDESCRIPTION: This snippet shows how to add the ZIO SQS library dependency to a Scala project. ZIO SQS is a ZIO-powered client for AWS SQS built on top of the AWS SDK for Java 2.0.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_43\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-sqs\" % \"0.4.2\"\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in Turkish (tr)\nDESCRIPTION: Provides an example pangram for the Turkish language. Includes an English translation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_14\n\nLANGUAGE: plaintext\nCODE:\n```\n    Pijamal hasta, yaz ofre abucak gvendi.\n    ( = Patient with pajamas, trusted swarthy driver quickly )\n```\n\n----------------------------------------\n\nTITLE: Creating Basic sidebars.js for ZIO Documentation\nDESCRIPTION: A basic sidebars.js configuration for organizing documentation structure. Defines a single category with a link to the index page and an empty items array for additional pages.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst sidebars = {\n  sidebar: [\n    {\n      type: \"category\",\n      label: \"ZIO XYZ\", // Project Name\n      collapsed: false,\n      link: { type: \"doc\", id: \"index\" },\n      items: [ ]\n    }\n  ]\n};\n\nmodule.exports = sidebars;\n```\n\n----------------------------------------\n\nTITLE: Viewing Running Containers (Bash)\nDESCRIPTION: Command to list running Docker containers and their exposed ports.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ docker ps\n```\n\n----------------------------------------\n\nTITLE: Initializing TestConfig with Default Values in Scala\nDESCRIPTION: This code snippet shows the default configuration for TestConfig in ZIO Test. It sets the number of repeats, retries, samples, and shrinks used by the test runner.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/test-config.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nTestConfig.live(\n  repeats0 = 100,\n  retries0 = 100,\n  samples0 = 200,\n  shrinks0 = 1000\n)\n```\n\n----------------------------------------\n\nTITLE: Maven Dependency Configuration for FHIR Indexer\nDESCRIPTION: Maven configuration snippet showing how to include the FHIR indexer library as a dependency in a Maven project. Uses version v0.0.2 of the library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/fhir-indexer.md#2025-04-23_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n   <dependency>\n        <groupId>io.github.royashcenazi</groupId>\n        <artifactId>fhir-indexer</artifactId>\n        <version>v0.0.2</version>\n    </dependency>\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO K8s Client Library Dependency in SBT\nDESCRIPTION: Configuration for adding the ZIO K8s client library dependency to a Scala project's build.sbt file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.coralogix\" %% \"zio-k8s-client\" % \"1.3.3\"\n```\n\n----------------------------------------\n\nTITLE: Running mdoc in Watch Mode\nDESCRIPTION: Commands to run mdoc in watch mode within sbt shell for live reloading during development\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-documentation.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsbt\nsbt:docs> docs/mdoc --watch\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO HTTP dependencies to build.sbt\nDESCRIPTION: SBT dependency configuration for integrating ZIO with HTTP using the zhttp library for both main and test code.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_30\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.d11\" %% \"zhttp\"      % \"1.0.0.0-RC13\"\nlibraryDependencies += \"io.d11\" %% \"zhttp-test\" % \"1.0.0.0-RC13\" % Test\n```\n\n----------------------------------------\n\nTITLE: Pushing Local Changes to the Remote Repository with Git - Bash\nDESCRIPTION: Shows how to upload committed changes from the local repository to the corresponding remote fork on GitHub. The 'git push' command is used with the current branch. Remote configuration must be set up.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit push\n```\n\n----------------------------------------\n\nTITLE: Composing an Interactive Console Program with For-Comprehension in Scala\nDESCRIPTION: Creates example2, a Console[String] value, using for-comprehension and the provided map/flatMap. The program prompts for a name, captures input via readLine, and prints a personalized greeting, returning the entered name. This composition showcases idiomatic pure program design in functional Scala using the Console effect system, with no side effects until interpreted.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/background.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nval example2: Console[String] =\n  for {\n    _    <- printLine(\"What's your name?\")\n    name <- readLine\n    _    <- printLine(s\"Hello, ${name}, good to meet you!\")\n  } yield name\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Stream to Reactive Streams Publisher in Scala\nDESCRIPTION: Illustrates converting a ZIO `Stream` (containing integers from 3 to 12) into a Reactive Streams `Publisher` using the `toPublisher` extension method. The conversion itself is an effect (`UIO[Publisher[Int]]`). The resulting `Publisher` is then subscribed to by the previously defined `subscriber` within the ZIO effect, which is executed by the runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-reactive-streams.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval stream = Stream.range(3, 13)\nruntime.unsafeRun(\n  stream.toPublisher.flatMap { publisher =>\n    UIO(publisher.subscribe(subscriber))\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Defining ZQueue Type Parameters in Scala\nDESCRIPTION: Shows the expanded trait definition of ZQueue, spelling out its environment and error parameterization. This is a type signature, not an executable code block, and is essential for understanding advanced queue transformations and compositions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZQueue[RA, RB, EA, EB, A, B]\\n\n```\n\n----------------------------------------\n\nTITLE: Transforming ZIO Failure to Either in Scala\nDESCRIPTION: Demonstrates how to use the ZIO#either method to transform a failing effect into an infallible effect that places both failure and success into Scala's Either type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/overview/handling-errors.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval zeither: ZIO[Any, Nothing, Either[String, Nothing]] = \n  ZIO.fail(\"Uh oh!\").either\n```\n\n----------------------------------------\n\nTITLE: Custom Interleaving of ZIO Streams with interleaveWith\nDESCRIPTION: This snippet demonstrates using interleaveWith which allows custom interleaving logic by providing a stream of boolean values that control which source stream to pull from next.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_50\n\nLANGUAGE: scala\nCODE:\n```\nval s1 = ZStream(1, 3, 5, 7, 9)\nval s2 = ZStream(2, 4, 6, 8, 10)\n\nval interleaved = s1.interleaveWith(s2)(ZStream(true, false, false).forever)\n// Output: 1, 2, 4, 3, 6, 8, 5, 10, 7, 9\n```\n\n----------------------------------------\n\nTITLE: Creating a Chunk Using unfold Method in Scala\nDESCRIPTION: Creates a Chunk by repeatedly applying a function until it returns None.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/chunk.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nval unfolded = Chunk.unfold(0)(n => if (n < 8) Some((n*2, n+2)) else None)\n```\n\n----------------------------------------\n\nTITLE: Formatting Code Using SBT - Bash\nDESCRIPTION: Executes the 'fmt' command in sbt to format all source files according to the project's style guidelines. Ensures code consistency before a pull request. Can be run from the command line or inside sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsbt fmt\n```\n\n----------------------------------------\n\nTITLE: Committing Merged Changes in Bash\nDESCRIPTION: Git command to commit changes after resolving merge conflicts with the upstream repository. This preserves both your changes and the changes from other contributors.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \"merged upstream changes\"\n```\n\n----------------------------------------\n\nTITLE: Importing DeriveDiff for Case Classes and ADTs in Scala\nDESCRIPTION: Shows how to import the DeriveDiff object to enable automatic derivation of Diff instances for case classes and algebraic data types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/difference.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.magnolia.DeriveDiff._\n```\n\n----------------------------------------\n\nTITLE: ZManaged with Environment Requirements\nDESCRIPTION: Example of using ZManaged with environmental requirements, specifically the Console environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/managed.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console._\n\nval zManagedResource: ZManaged[Console, Nothing, Unit] = ZManaged.make(console.putStrLn(\"acquiring\").orDie)(_ => console.putStrLn(\"releasing\").orDie)\nval zUsedResource: URIO[Console, Unit] = zManagedResource.use { _ => console.putStrLn(\"running\").orDie }\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO.iterate Combinator in Scala\nDESCRIPTION: Defines the signature of the `ZIO.iterate` combinator. It takes an initial state `S`, a continuation predicate `cont` determining if the loop should continue, and an effectful `body` function that transforms the state in each iteration. The combinator returns a ZIO effect that yields the final state `S` after the loop terminates based on the `cont` condition.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/control-flow/index.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nobject ZIO {\n  def iterate[R, E, S](\n    initial: => S\n  )(cont: S => Boolean)(body: S => ZIO[R, E, S]): ZIO[R, E, S]\n}\n```\n\n----------------------------------------\n\nTITLE: Launching SBT with Increased Heap Size in Bash\nDESCRIPTION: Command to launch SBT build tool with increased JVM heap size to improve build performance. The -J-Xmx8g flag allocates 8GB of memory to prevent slowdowns on default settings.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsbt -J-Xmx8g\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Parameters for Contextual Values in ZIO\nDESCRIPTION: Demonstrates using Scala's implicit parameters to pass contextual values like UserId and CorrelationId. This approach is generally not recommended for contextual values in ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/faq.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ndef someEffect(...)(implicit userId: UserId, correlationId: CorrelationId): ZIO[Any, ErrorType, A] =\n  ???\n```\n\n----------------------------------------\n\nTITLE: Adding STTP HTTP Client Backend for ZIO K8s\nDESCRIPTION: SBT dependency configuration for the STTP HTTP client backend needed by ZIO K8s. This adds the standard HTTP client implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_33\n\nLANGUAGE: scala\nCODE:\n```\n\"com.softwaremill.sttp.client3\" %% \"httpclient-backend-zio\" % \"3.1.1\",\n\"com.softwaremill.sttp.client3\" %% \"slf4j-backend\"          % \"3.1.1\"\n```\n\n----------------------------------------\n\nTITLE: Using Mutable Vars for State Management in Scala\nDESCRIPTION: This snippet demonstrates naive direct state mutation using a global variable (idCounter). It shows a function that increments this counter and returns a string, illustrating the non-functional, impure approach. No dependencies are required beyond standard Scala, and the use of a global var limits composability and thread safety.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/ref.md#2025-04-23_snippet_9\n\nLANGUAGE: Scala\nCODE:\n```\nvar idCounter = 0\ndef freshVar: String = {\n  idCounter += 1\n  s\"var${idCounter}\"\n}\nval v1 = freshVar\nval v2 = freshVar\nval v3 = freshVar\n\n```\n\n----------------------------------------\n\nTITLE: Committing Merged Changes After Conflict Resolution - Bash\nDESCRIPTION: After resolving merge conflicts, this snippet records the merge with a commit message. All changes must be staged before running this command to ensure that the conflict resolution is committed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \\\"merged upstream changes\\\"\n```\n\n----------------------------------------\n\nTITLE: Exporting the Home Component in JavaScript\nDESCRIPTION: Exports the `Home` React component as the default export of the module. This makes the `Home` component, which renders the ZIO project homepage, available for use by the Docusaurus framework or other parts of the application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nexport default Home;\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Core Dependency in SBT (Scala)\nDESCRIPTION: This snippet shows how to add the core ZIO library dependency to a Scala project using the SBT build tool. It specifies the organization `dev.zio`, artifact `zio`, and version `1.0.18`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/getting_started.md#2025-04-23_snippet_0\n\nLANGUAGE: sbt\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio\" % \"1.0.18\"\n```\n\n----------------------------------------\n\nTITLE: Installing Caliban and Optional Modules in Scala\nDESCRIPTION: Shows how to add Caliban and its optional modules as dependencies in a Scala build.sbt file. Includes the core Caliban library and various interoperability modules for different frameworks and libraries.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban\" % \"1.1.0\"\n\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-http4s\"     % \"1.1.0\" // routes for http4s\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-akka-http\"  % \"1.1.0\" // routes for akka-http\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-play\"       % \"1.1.0\" // routes for play\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-finch\"      % \"1.1.0\" // routes for finch\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-zio-http\"   % \"1.1.0\" // routes for zio-http\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-cats\"       % \"1.1.0\" // interop with cats effect\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-monix\"      % \"1.1.0\" // interop with monix\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-tapir\"      % \"1.1.0\" // interop with tapir\nlibraryDependencies += \"com.github.ghostdogpr\" %% \"caliban-federation\" % \"1.1.0\" // interop with apollo federation\n```\n\n----------------------------------------\n\nTITLE: GraphQL Response in JSON Format\nDESCRIPTION: Example JSON response from the GraphQL API showing software developers with their names and roles.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/graphql-webservice.md#2025-04-23_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"employees\": [\n      {\n        \"name\": \"Maria\",\n        \"role\": \"SoftwareDeveloper\"\n      },\n      {\n        \"name\": \"Peter\",\n        \"role\": \"SoftwareDeveloper\"\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Temporal Server for Development\nDESCRIPTION: Shell command to start a local Temporal development server. This command starts the server on all network interfaces and specifies a database file location.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zio-temporal.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ntemporal server start-dev --ip 0.0.0.0 --db-filename /tmp/temporal.db\n```\n\n----------------------------------------\n\nTITLE: Creating package.json for ZIO Documentation Project\nDESCRIPTION: Example of a package.json file for a ZIO ecosystem documentation project. Specifies the package name (using @zio.dev scope), description, and license information.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": \"@zio.dev/zio-prelude\",\n  \"description\": \"ZIO Prelude Documentation\",\n  \"license\": \"Apache-2.0\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Failing Handler in ZIO HTTP\nDESCRIPTION: This code demonstrates how to create a Handler that always returns a failed response in ZIO HTTP. It uses the ZIO.fail constructor to create a handler that returns an internal server error response.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/build-a-restful-webservice.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.http._\n\nval app: Handler[Any, Response, Any, Nothing] =\n  handler(ZIO.fail(Response.internalServerError(\"Something went wrong\")))\n```\n\n----------------------------------------\n\nTITLE: CI Job for Automating README Generation\nDESCRIPTION: YAML configuration for a GitHub Actions workflow job that automatically generates and updates the README.md file after changes to the docs/index.md file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-zio-ecosystem-projects.md#2025-04-23_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nupdate-readme:\n  name: Update README\n  runs-on: ubuntu-latest\n  continue-on-error: false\n  if: ${{ github.event_name == 'push' }}\n  steps:\n  - name: Git Checkout\n    uses: actions/checkout@v4.1.1\n    with:\n      fetch-depth: '0'\n  - name: Setup Scala\n    uses: actions/setup-java@v4.2.1\n    with:\n      distribution: temurin\n      java-version: 17\n      check-latest: true\n  - name: Cache Dependencies\n    uses: coursier/cache-action@v6\n  - name: Generate Readme\n    run: sbt docs/generateReadme\n  - name: Commit Changes\n    run: |\n      git config --local user.email \"zio-assistant[bot]@users.noreply.github.com\"\n      git config --local user.name \"ZIO Assistant\"\n      git add README.md\n      git commit -m \"Update README.md\" || echo \"No changes to commit\"\n  - name: Generate Token\n    id: generate-token\n    uses: zio/generate-github-app-token@v1.0.0\n    with:\n      app_id: ${{ secrets.APP_ID }}\n      app_private_key: ${{ secrets.APP_PRIVATE_KEY }}\n  - name: Create Pull Request\n    id: cpr\n    uses: peter-evans/create-pull-request@v5.0.2\n    with:\n      body: |-\n        Autogenerated changes after running the `sbt docs/generateReadme` command of the [zio-sbt-website](https://zio.dev/zio-sbt) plugin.\n\n        I will automatically update the README.md file whenever there is new change for README.md, e.g.\n          - After each release, I will update the version in the installation section.\n          - After any changes to the \"docs/index.md\" file, I will update the README.md file accordingly.\n      branch: zio-sbt-website/update-readme\n      commit-message: Update README.md\n      token: ${{ steps.generate-token.outputs.token }}\n      delete-branch: true\n      title: Update README.md\n  - name: Approve PR\n    if: ${{ steps.cpr.outputs.pull-request-number }}\n    run: gh pr review \"$PR_URL\" --approve\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      PR_URL: ${{ steps.cpr.outputs.pull-request-url }}\n  - name: Enable Auto-Merge\n    if: ${{ steps.cpr.outputs.pull-request-number }}\n    run: gh pr merge --auto --squash \"$PR_URL\" || gh pr merge --squash \"$PR_URL\"\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      PR_URL: ${{ steps.cpr.outputs.pull-request-url }}\n```\n\n----------------------------------------\n\nTITLE: Cloning ZIO Repository\nDESCRIPTION: Commands to clone the ZIO repository and navigate to the project directory\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributing-to-documentation.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio.git\n$ cd zio\n```\n\n----------------------------------------\n\nTITLE: Checking Key Existence in a TMap in ZIO STM\nDESCRIPTION: Demonstrates checking whether a key is present in a TMap using the contains method. Returns a boolean indicating presence of the key.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_18\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tMapContainsValue: UIO[Boolean] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  res  <- tMap.contains(\"a\")\n} yield res).commit\n```\n\n----------------------------------------\n\nTITLE: MUnit ZIO Test Dependencies\nDESCRIPTION: SBT dependency configuration for MUnit ZIO testing framework integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"org.scalameta\" %% \"munit\" % \"0.7.27\" % Test\nlibraryDependencies += \"com.github.poslegm\" %% \"munit-zio\" % \"0.0.2\" % Test\n```\n\nLANGUAGE: scala\nCODE:\n```\ntestFrameworks += new TestFramework(\"munit.Framework\")\n```\n\n----------------------------------------\n\nTITLE: Rendering Company Table in Markdown\nDESCRIPTION: This snippet shows the Markdown syntax used to create the table of ZIO adopters. It demonstrates how to format a table with company names, links, and logo images.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/adopters.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Company                                                          | Logo                                                              |\n| :--------------------------------------------------------------: | :---------------------------------------------------------------: |\n| [AdGear / Samsung Ads](https://adgear.com/en/)                   | <img src=\"/img/users/adgear.png\" width=\"60%\"/>                    |\n| [Adidas](https://www.adidas.com/)                                | <img src=\"/img/users/adidas.svg\" width=\"40%\"/>                    |\n| [adpulse.io](https://www.adpulse.io/)                            | <img src=\"/img/users/adpulse.svg\" width=\"100%\"/>                  |\n| [adsquare](https://www.adsquare.com/)                            | ![Adsquare](/img/users/adsquare.svg)                              |\n```\n\n----------------------------------------\n\nTITLE: Pulling Latest Changes from ZIO Repository in Bash\nDESCRIPTION: Git command to pull the latest changes from the official ZIO repository's 2.x branch. This helps keep your fork synchronized with the upstream project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit pull git@github.com:zio/zio.git series/2.x\n```\n\n----------------------------------------\n\nTITLE: Building ZIO Project Completely in SBT\nDESCRIPTION: SBT command that formats the code, compiles it, and runs tests in a single operation. This is a convenience command for ensuring your changes are ready for submission.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsbt build\n```\n\n----------------------------------------\n\nTITLE: Creating a Manual Reloadable Service with ZLayer Extension Method in Scala\nDESCRIPTION: Converting a standard ZLayer to a manually reloadable service using the ZLayer#reloadableManual extension method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/reloadable-services.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nobject Counter {\n  val live: ZLayer[Any, Nothing, Counter] = ???\n\n  val reloadable: ZLayer[Any, Nothing, Reloadable[Counter]] =\n    live.reloadableManual\n}\n```\n\n----------------------------------------\n\nTITLE: Complete ZIOAppDefault Example with Configured Workflow - Scala\nDESCRIPTION: This is a full application using ZIOAppDefault, which loads server configuration via ZIO Config and prints it on startup. It includes the case class, configuration descriptor (using Magnolia), and wiring of the workflow. The effect (`workflow`) is executed by run for application startup. Assumes necessary dependencies: zio, zio-config, zio-config-magnolia, and Typesafe Config for resource loading.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_5\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\nimport zio.config.magnolia._\n\nimport java.io.IOException\n\ncase class HttpServerConfig(host: String, port: Int)\n\nobject HttpServerConfig {\n  implicit val config: Config[HttpServerConfig] = deriveConfig[HttpServerConfig].nested(\"HttpServerConfig\")\n}\n\nobject MainApp extends ZIOAppDefault {\n\n  val workflow: Task[Unit] =\n    ZIO.config[HttpServerConfig].flatMap { config =>\n      Console.printLine(\n        \"Application started with following configuration:\\n\" +\n          s\"\\thost: ${config.host}\\n\" +\n          s\"\\tport: ${config.port}\"\n      )\n    }\n\n  def run = workflow\n}\n```\n\n----------------------------------------\n\nTITLE: ZRef Type Definition\nDESCRIPTION: Shows the type signature of the polymorphic ZRef type that underlies Ref implementations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZRef[+EA, +EB, -A, +B]\n```\n\n----------------------------------------\n\nTITLE: Asserting Unit Value in Scala\nDESCRIPTION: Creates an assertion that checks if a value is the Unit value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_17\n\nLANGUAGE: Scala\nCODE:\n```\nisUnit\n```\n\n----------------------------------------\n\nTITLE: Asserting Sum Type Case in Scala\nDESCRIPTION: Creates an assertion that checks if a sum type matches a specified term. It takes a term name, a function to extract the projection, and an assertion for the projection.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\nisCase[Sum, Proj]( termName: String, term: Sum => Option[Proj], assertion: Assertion[Proj])\n```\n\n----------------------------------------\n\nTITLE: Checking Git Status in Bash\nDESCRIPTION: Git command to view the status of your working directory, showing which files have been modified, added, or deleted. This helps you prepare your changes for committing.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit status\n```\n\n----------------------------------------\n\nTITLE: ZQueue#contramapM: Effectful Mapping of Input in Scala\nDESCRIPTION: Applies contramapM to annotate incoming elements with their enqueue timestamp, effectfully transforming the offered value. Involves time computations as dependencies, requiring ZIO Clock. Returns a queue that takes String, produces (Long, String).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_17\n\nLANGUAGE: scala\nCODE:\n```\nval annotatedIn: UIO[ZQueue[Clock, Any, Nothing, Nothing, String, (Long, String)]] =\\n  for {\\n    queue <- Queue.bounded[(Long, String)](3)\\n    mapped = queue.contramapM { el: String =>\\n      currentTimeMillis.map((_, el))\\n    }\\n  } yield mapped\\n\n```\n\n----------------------------------------\n\nTITLE: Running Scala MDoc Documentation Processor  Shell\nDESCRIPTION: This shell command invokes the Scala MDoc processor using sbt to process all markdown documentation files. It compiles Scala code blocks within the documentation to ensure correctness and writes the processed files to an output directory used by Docusaurus. Requires sbt and the Scala MDoc plugin to be installed and configured. The command should be run from the project root.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nsbt docs/mdoc\n```\n\n----------------------------------------\n\nTITLE: ZIO Runtime Output for Defective Effect - Stack Trace Example - Scala\nDESCRIPTION: Presents a sample error stack trace output triggered from running a ZIO effect that dies. Illustrates what is logged by the runtime when a defect is encountered. Output only; no code to execute. Useful for understanding the logging side-effects of ZIO defects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/types/defects.md#2025-04-23_snippet_3\n\nLANGUAGE: Scala\nCODE:\n```\ntimestamp=2022-02-16T13:02:44.057191215Z level=ERROR thread=#zio-fiber-0 message=\"Exception in thread \\\"zio-fiber-2\\\" java.lang.ArithmeticException: divide by zero\n\\tat MainApp$.$anonfun$run$1(MainApp.scala:4)\n\\tat zio.ZIO$.$anonfun$die$1(ZIO.scala:3384)\n\\tat zio.internal.FiberContext.runUntil(FiberContext.scala:255)\n\\tat zio.internal.FiberContext.run(FiberContext.scala:115)\n\\tat zio.internal.ZScheduler$$anon$1.run(ZScheduler.scala:151)\n\\tat <empty>.MainApp.run(MainApp.scala:4)\"\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application with Hot-Reloading\nDESCRIPTION: Command to run the ZIO application with hot-reloading enabled using SBT Revolver.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/hello-world.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsbt reStart\n```\n\n----------------------------------------\n\nTITLE: Rebooting to Console for Benchmark Execution\nDESCRIPTION: This command sets the system to boot into a multi-user console mode, which helps in reducing background noise for more accurate benchmark measurements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/benchmarks/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsystemctl set-default multi-user.target\nreboot\n```\n\n----------------------------------------\n\nTITLE: Adding New Files to Git Repository in Bash\nDESCRIPTION: Git command to stage a new file for commit. This example shows adding a specific Scala file in the ZIO codebase to be included in the next commit.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit add core/src/shared/zio/zio/NewFile.scala\n```\n\n----------------------------------------\n\nTITLE: Pangram Examples in French (fr)\nDESCRIPTION: Provides several complex pangram examples for the French language, designed to include accented characters and less common letters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n    Portez ce vieux whisky au juge blond qui fume sur son le intrieure, \n    ct de l'alcve ovode, o les bches se consument dans l'tre, ce\n    qui lui permet de penser  la cnogense de l'tre dont il est question\n    dans la cause ambigu entendue  Mo, dans un capharnam qui,\n    pense-t-il, diminue  et l la qualit de son uvre.\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n    l'le exigu\n    O l'obse jury mr\n    Fte l'ha volapk,\n    ne ex quo au whist,\n    tez ce vu du.\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n    Le cur du mais l'me plutt nave, Lois rva de crapater en\n    cano au del des les, prs du mlstrm o brlent les nov.\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in Danish (da)\nDESCRIPTION: Provides an example pangram for the Danish language. A pangram is a sentence that contains all letters of the alphabet. Includes an English translation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n    Quizdeltagerne spiste jordbr med flde, mens cirkusklovnen\n    Wolther spillede p xylofon.\n    ( = Quiz contestants were eating strawberry with cream while Wolther\n    the circus clown played on xylophone. )\n```\n\n----------------------------------------\n\nTITLE: Cloning ZIO Quickstarts Repository and Navigating to Project Directory\nDESCRIPTION: Commands to clone the ZIO Quickstarts repository from GitHub and navigate to the graphql-webservice project directory.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/quickstarts/graphql-webservice.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone https://github.com/zio/zio-quickstarts.git\n$ cd zio-quickstarts/zio-quickstart-graphql-webservice\n```\n\n----------------------------------------\n\nTITLE: Committing Merged Changes in ZIO Project\nDESCRIPTION: Git command to commit merged changes after resolving conflicts. This preserves both your changes and upstream changes in a single commit.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -am \"merged upstream changes\"\n```\n\n----------------------------------------\n\nTITLE: Running the Kafka Example Application\nDESCRIPTION: Command to run the Kafka example application using sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sbt run\n```\n\n----------------------------------------\n\nTITLE: Defining Sized Trait in Scala\nDESCRIPTION: Definition of the Sized trait with two methods: size for accessing the current size, and withSize for running an effect with a specific size.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/sized.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntrait Sized extends Serializable {\n  def size: UIO[Int]\n  def withSize[R, E, A](size: Int)(zio: ZIO[R, E, A]): ZIO[R, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming Amazon Kinesis Stream with ZIO Kinesis\nDESCRIPTION: Complete example demonstrating how to consume data from an Amazon Kinesis stream using ZIO Kinesis. This example shows stream consumption with checkpointing configuration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_37\n\nLANGUAGE: scala\nCODE:\n```\nimport nl.vroste.zio.kinesis.client.serde.Serde\nimport nl.vroste.zio.kinesis.client.zionative.Consumer\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.duration._\nimport zio.logging.Logging\nimport zio.{ExitCode, URIO, _}\n\nobject ZIOKinesisConsumerExample extends zio.App {\n  val loggingLayer: ZLayer[Any, Nothing, Logging] =\n    (Console.live ++ Clock.live) >>>\n      Logging.console() >>>\n      Logging.withRootLoggerName(getClass.getName)\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    Consumer\n      .consumeWith(\n        streamName = \"my-stream\",\n        applicationName = \"my-application\",\n        deserializer = Serde.asciiString,\n        workerIdentifier = \"worker1\",\n        checkpointBatchSize = 1000L,\n        checkpointDuration = 5.minutes\n      )(record => putStrLn(s\"Processing record $record\"))\n      .provideCustomLayer(Consumer.defaultEnvironment ++ loggingLayer)\n      .exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning the ZIO Repository Locally with Git - Bash\nDESCRIPTION: This snippet demonstrates how to create a local directory for the ZIO project, change into it, and clone a forked repository using SSH. Users must pre-install Git and have forked the repository via GitHub. The result is a local copy of the project to make modifications safely.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir zio\\ncd zio\\ngit clone git@github.com:your-user-name/zio.git .\n```\n\n----------------------------------------\n\nTITLE: Building and Testing ZIO Project\nDESCRIPTION: SBT command that formats code, compiles it, and runs tests in one step. This is a convenient way to prepare your changes for submission.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsbt build\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO Config Dependency\nDESCRIPTION: Shows how to add the ZIO Config library dependency to an SBT project for configuration management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-config\" % <version>\n```\n\n----------------------------------------\n\nTITLE: Defining `unrefineWith` Signature in ZIO Scala\nDESCRIPTION: Shows the type signature for the `unrefineWith` operator. It takes a partial function `pf` to convert specific `Throwable` defects into typed errors `E1`. It also takes a function `f` (`E => E1`) to map any existing typed errors `E` into the new error type `E1`. This provides comprehensive control over broadening the error channel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/error-refinement.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def unrefineWith[E1](pf: PartialFunction[Throwable, E1])(f: E => E1): ZIO[R, E1, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Try is Success in Scala\nDESCRIPTION: Creates an assertion `Assertion[Try[Any]]` that simply checks if a `scala.util.Try` value is a `Success`, without inspecting the underlying value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nisSuccess\n```\n\n----------------------------------------\n\nTITLE: Using Multiple AppConfig Instances in a ZIO Application\nDESCRIPTION: This snippet shows how to use different AppConfig instances from the ZIO environment based on an environment variable in a ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/zenvironment.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject MultipleConfigExample extends ZIOAppDefault {\n\n  val myApp: ZIO[Map[String, AppConfig], String, Unit] = for {\n    env <- System.env(\"APP_ENV\")\n      .flatMap(x => ZIO.fromOption(x))\n      .orElseFail(\"The environment variable APP_ENV cannot be found.\")\n    config <- ZIO.serviceAt[AppConfig](env)\n      .flatMap(x => ZIO.fromOption(x))\n      .orElseFail(s\"The $env config cannot be found in the ZIO environment\")\n    _ <- ZIO.logInfo(s\"Application started with: $config\")\n  } yield ()\n\n  def run =\n    myApp.provide(AppConfig.layer)\n\n}\n```\n\n----------------------------------------\n\nTITLE: Adding JUnit Interface Dependency in Scala\nDESCRIPTION: This snippet shows how to add the JUnit Interface dependency to the build.sbt file. This is required for running JUnit tests using sbt.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/junit-integration.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.github.sbt\" % \"junit-interface\" % \"0.13.3\" % Test\n```\n\n----------------------------------------\n\nTITLE: Adding scala-java-time Dependency for ZIO Scala.js\nDESCRIPTION: This Scala (sbt) snippet demonstrates how to add the `scala-java-time` and `scala-java-time-tzdb` libraries as dependencies in a build file. These are required for ZIO applications targeting Scala.js because the platform lacks complete implementations of `java.time` methods, which ZIO may rely on. Adding these ensures proper date and time functionality.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/platforms.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nlibraryDependencies ++= Seq(\n  \"io.github.cquiroz\" %%% \"scala-java-time\" % \"2.2.0\",\n  \"io.github.cquiroz\" %%% \"scala-java-time-tzdb\" % \"2.2.0\"\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Pangram Examples in Russian (ru)\nDESCRIPTION: Provides two example pangrams for the Russian language (Cyrillic script). Includes English translations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\n    ,       ? ,   !\n    ( = Would a citrus live in the bushes of south? Yes, but only a fake one! )\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n             \n    ( = Eat some more of these fresh French loafs and have some tea )\n```\n\n----------------------------------------\n\nTITLE: Defining application.conf Configuration in HOCON Format - json\nDESCRIPTION: Shows the content of the `application.conf` file in HOCON format for the HttpServerConfig. Contains fallback defaults and supports environment-variable substitutions using HOCON syntax. Required to let ZIO Config load values at runtime from a config file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n# application.conf\n\nHttpServerConfig {\n  # The port to listen on.\n  port = 8080\n  port = ${?PORT}\n\n  # The hostname to listen on.\n  host = \"localhost\"\n  host = ${?HOST}\n\n  nThreads = 0\n  nThreads = ${?N_THREADS}\n}\n```\n\n----------------------------------------\n\nTITLE: Pangram Examples in German (de)\nDESCRIPTION: Provides several example pangrams and near-pangrams for the German language. Includes English translations and notes about missing letters or specific features (like containing all non-ASCII German letters).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n    Falsches ben von Xylophonmusik qult jeden greren Zwerg\n    ( = Wrongful practicing of xylophone music tortures every larger dwarf )\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n    Zwlf Boxkmpfer jagten Eva quer ber den Sylter Deich\n    ( = Twelve boxing fighters hunted Eva across the dike of Sylt )\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n    Heizlrckstoabdmpfung\n    ( = fuel oil recoil absorber )\n    ( j q v w x y missing, but all non-ASCII letters in one word )\n```\n\n----------------------------------------\n\nTITLE: Creating Newsletter Subscription Form Component in React/JSX\nDESCRIPTION: Defines a React functional component `Newsletter` that renders an HTML form for subscribing to the ZIO newsletter via Revue. It includes an email input field (`member_email`) and a submit button, styled using CSS modules (`styles`). The form submits data to the specified Revue endpoint when the user clicks 'Subscribe'.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Newsletter() {\n  return (\n    <form id=\"revue-form\" name=\"revue-form\" target=\"_blank\" action=\"https://www.getrevue.co/profile/zio/add_subscriber\" method=\"post\">\n      <div className={styles.newsFormContainer}>\n        <label className={styles.newsLabel} htmlFor=\"member_email\">Subscribe to ZIO News:</label>\n        <div className={styles.newsSubscribe}>\n          <input className={styles.newsInput} type=\"email\" name=\"member[email]\" id=\"member_email\" required=\"\" placeholder=\"Your eMail address...\" />\n          <div>\n            <input className={styles.newsButton} type=\"submit\" value=\"Subscribe\" name=\"member[subscribe]\" id=\"member_submit\" />\n          </div>\n        </div>\n      </div>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Database-agnostic Slick Repository with ZIO Integration\nDESCRIPTION: A complete example of creating a database-agnostic Slick repository with ZIO integration. It demonstrates defining a data model, repository interface, and implementation using ZIO and Slick integration.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_45\n\nLANGUAGE: scala\nCODE:\n```\nimport com.typesafe.config.ConfigFactory\nimport slick.interop.zio.DatabaseProvider\nimport slick.interop.zio.syntax._\nimport slick.jdbc.H2Profile.api._\nimport slick.jdbc.JdbcProfile\nimport zio.console.Console\nimport zio.interop.console.cats.putStrLn\nimport zio.{ExitCode, Has, IO, URIO, ZIO, ZLayer}\n\nimport scala.jdk.CollectionConverters._\n\ncase class Item(id: Long, name: String)\n\ntrait ItemRepository {\n  def add(name: String): IO[Throwable, Long]\n\n  def getById(id: Long): IO[Throwable, Option[Item]]\n\n  def upsert(name: String): IO[Throwable, Long]\n}\n\nobject ItemsTable {\n  class Items(tag: Tag) extends Table[Item](\n    _tableTag = tag,\n    _tableName = \"ITEMS\"\n  ) {\n    def id = column[Long](\"ID\", O.PrimaryKey, O.AutoInc)\n\n    def name = column[String](\"NAME\")\n\n    def * = (id, name) <> ((Item.apply _).tupled, Item.unapply _)\n  }\n\n  val table = TableQuery[ItemsTable.Items]\n}\n\nobject SlickItemRepository {\n  val live: ZLayer[Has[DatabaseProvider], Throwable, Has[ItemRepository]] =\n    ZLayer.fromServiceM { db =>\n      db.profile.flatMap { profile =>\n        import profile.api._\n\n        val initialize = ZIO.fromDBIO(ItemsTable.table.schema.createIfNotExists)\n\n        val repository = new ItemRepository {\n          private val items = ItemsTable.table\n\n          def add(name: String): IO[Throwable, Long] =\n            ZIO\n              .fromDBIO((items returning items.map(_.id)) += Item(0L, name))\n              .provide(Has(db))\n\n          def getById(id: Long): IO[Throwable, Option[Item]] = {\n            val query = items.filter(_.id === id).result\n\n            ZIO.fromDBIO(query).map(_.headOption).provide(Has(db))\n          }\n\n          def upsert(name: String): IO[Throwable, Long] =\n            ZIO\n              .fromDBIO { implicit ec =>\n                (for {\n                  itemOpt <- items.filter(_.name === name).result.headOption\n                  id <- itemOpt.fold[DBIOAction[Long, NoStream, Effect.Write]](\n                    (items returning items.map(_.id)) += Item(0L, name)\n                  )(item => (items.map(_.name) update name).map(_ => item.id))\n                } yield id).transactionally\n              }\n              .provide(Has(db))\n        }\n\n        initialize.as(repository).provide(Has(db))\n      }\n    }\n}\n\n\nobject Main extends zio.App {\n\n  private val config = ConfigFactory.parseMap(\n    Map(\n      \"url\" -> \"jdbc:h2:mem:test1;DB_CLOSE_DELAY=-1\",\n      \"driver\" -> \"org.h2.Driver\",\n      \"connectionPool\" -> \"disabled\"\n    ).asJava\n  )\n\n  private val env: ZLayer[Any, Throwable, Has[ItemRepository]] =\n    (ZLayer.succeed(config) ++ ZLayer.succeed[JdbcProfile](\n      slick.jdbc.H2Profile\n    )) >>> DatabaseProvider.live >>> SlickItemRepository.live\n\n  val myApp: ZIO[Console with Has[ItemRepository], Throwable, Unit] =\n    for {\n      repo <- ZIO.service[ItemRepository]\n      aId1 <- repo.add(\"A\")\n      _ <- repo.add(\"B\")\n      a <- repo.getById(1L)\n      b <- repo.getById(2L)\n      aId2 <- repo.upsert(\"A\")\n      _ <- putStrLn(s\"$aId1 == $aId2\")\n      _ <- putStrLn(s\"A item: $a\")\n      _ <- putStrLn(s\"B item: $b\")\n    } yield ()\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideCustomLayer(env).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in Thai (th)\nDESCRIPTION: Provides an example pangram for the Thai language. Includes a note about the copyright holder for this specific example.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\n    [----------------------------------------|----------------------------------------]\n    \n\n    \n\n    [ The copyright for the Thai example is owned by The Computer\n    Association of Thailand under the Royal Patronage of His Majesty the\n    King. ]\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in Hebrew (iw)\nDESCRIPTION: Provides an example pangram for the Hebrew language.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n    ?        \n```\n\n----------------------------------------\n\nTITLE: Referencing ZIO Methods in Scaladoc using Links\nDESCRIPTION: This Scala snippet exemplifies the recommended practice for documenting ZIO code by using Scaladoc links (`[[...]]`). It shows how to reference another member (`zio.ZIO.absolve`) within a Scaladoc comment using the `@see` tag and double square brackets, facilitating easier navigation and ensuring reference correctness within the generated documentation. The function `absolve` itself simply delegates the call to `ZIO.absolve`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/coding_guidelines.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\n  /**\\n   * @see See [[zio.ZIO.absolve]]\\n   */\\n  def absolve[R, A](v: RIO[R, Either[Throwable, A]]): RIO[R, A] =\\n    ZIO.absolve(v)\n```\n\n----------------------------------------\n\nTITLE: Embedding Functional Scala 2022 Playlist\nDESCRIPTION: HTML iframe element for embedding the Functional Scala 2022 conference recordings playlist.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/events/index.md#2025-04-23_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/videoseries?list=PLvdARMfvom9A0L97KNywK1lWEeHYDLX0P\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n```\n\n----------------------------------------\n\nTITLE: Selecting Core JVM Project in SBT\nDESCRIPTION: SBT command to switch to the core JVM project. This focuses build commands on the main JVM implementation of ZIO.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nproject coreJVM\n```\n\n----------------------------------------\n\nTITLE: Implementing a Client that Consumes Value Changes\nDESCRIPTION: A client function that takes a stream of changes and collects a random number of values from it. This demonstrates the consuming side of a SubscriptionRef pattern.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/subscriptionref.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.random._\n\ndef client(changes: ZStream[Any, Nothing, Long]): URIO[Random, Chunk[Long]] =\n  for {\n    n     <- random.nextLongBetween(1, 200)\n    chunk <- changes.take(n).runCollect\n  } yield chunk\n```\n\n----------------------------------------\n\nTITLE: Rendering Documentation Card List in JSX for ZIO Ecosystem Libraries\nDESCRIPTION: A React component that renders a list of documentation cards for ZIO ecosystem libraries. The component uses the DocCardList from the Docusaurus theme to display the library cards.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/index.md#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport DocCardList from '@theme/DocCardList';\n\n<DocCardList />\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote and Fetching Tags in Bash\nDESCRIPTION: Commands to add the original ZIO repository as a remote upstream and fetch tags for proper versioning. This allows you to stay synchronized with the main repository.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add upstream git@github.com:zio/zio.git\ngit fetch --tags upstream\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to Fork in Bash\nDESCRIPTION: Git command to push your committed changes to your fork of the ZIO repository on GitHub. This uploads your local commits to your remote repository.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit push\n```\n\n----------------------------------------\n\nTITLE: Implementing FooLibrary with Implicit Trace Parameters\nDESCRIPTION: Example of implementing a library (FooLibrary) with implicit trace parameters to improve error tracing for users.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nobject FooLibrary {\n  def foo(implicit trace: Trace) = bar.flatMap(x => ZIO.succeed(x * 2))\n  private def bar(implicit trace: Trace) = baz.flatMap(x => ZIO.succeed(x * x))\n  private def baz(implicit trace: Trace) = ZIO.fail(\"Oh uh!\").as(5)\n}\n\nobject MainApp extends ZIOAppDefault {\n  def run = FooLibrary.foo // line 10\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ZIO Application Dependent on the Logging Service Scala\nDESCRIPTION: Defines a ZIO application (`myApp`) in Scala that requires the `Logging` service defined previously. It uses the `Logging.log` helper method to log messages indicating the application's start and end points. This effect needs a `Logging` implementation provided to it at runtime.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/di/providing-different-implementation-of-a-service.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval myApp: ZIO[Logging, IOException, Unit] =\n  for {\n    _ <- Logging.log(\"Application started.\")\n    _ <- Logging.log(\"Application ended.\")\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO Managed Type Alias\nDESCRIPTION: Basic type alias definition for Managed, representing a managed resource with no requirements that may fail with type E or succeed with type A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/managed.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Managed[+E, +A] = ZManaged[Any, E, A]\n```\n\n----------------------------------------\n\nTITLE: Cloning the ZIO Repository in Bash\nDESCRIPTION: Commands to create a directory for ZIO, navigate to it, and clone your forked repository. This is the first step to getting a local copy of the ZIO codebase that you can modify.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir zio\ncd zio\ngit clone git@github.com:your-user-name/zio.git .\n```\n\n----------------------------------------\n\nTITLE: Embedding ZIO World 2021 Playlist\nDESCRIPTION: HTML iframe element for embedding the ZIO World 2021 conference recordings playlist.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/events/index.md#2025-04-23_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/videoseries?list=PLvdARMfvom9COFgVauwWQ9PsCBOsDmHJm\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Benchmarks via sbt Terminal\nDESCRIPTION: This command executes a set of benchmarks from a specific class using the sbt-jmh plugin within the sbt terminal. Replace 'YourClassWithBenchmarks' with the actual benchmark class name.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/benchmarks/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbenchmarks/jmh:run .*YourClassWithBenchmarks\n```\n\n----------------------------------------\n\nTITLE: Converting ZIO Sink to Reactive Streams Subscriber in Scala\nDESCRIPTION: Demonstrates converting a ZIO `Sink` (specifically `Sink.collectAll[Integer]`) to a Reactive Streams `Subscriber` using the `toSubscriber` method. This method returns a tuple containing the `Subscriber` and an `IO[Throwable, Chunk[Integer]]` representing the eventual result (or failure) of running the `Sink`. The example subscribes the created `Subscriber` to the `publisher` and then awaits the `Sink`'s completion result (`result`) using the ZIO runtime. The `qSize` parameter controls the buffer size (default 16).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/interop/with-reactive-streams.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval sink = Sink.collectAll[Integer]\nruntime.unsafeRun(\n  sink.toSubscriber(qSize = 16).flatMap { case (subscriber, result) => \n    UIO(publisher.subscribe(subscriber)) *> result\n  }\n)\n```\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Pattern Matching on Sealed Error Types - Scala\nDESCRIPTION: Illustrates pattern matching on a sealed trait error hierarchy to exhaustively handle all error cases. The snippet shows a match expression on a 'userServiceError' reference with cases for 'InvalidUserId' and 'ExpiredAuth'. No dependencies outside standard Scala and the error definitions above. The input is a 'UserServiceError', and the output is determined by the match arm logic. Limitations: if a new case is added to 'UserServiceError', the compiler will indicate a missing match unless all cases are covered, enhancing safety.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/best-practices/algebraic-data-types.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nuserServiceError match {\n  case InvalidUserId(id) => ???\n  case ExpiredAuth(id)   => ???\n}\n```\n\n----------------------------------------\n\nTITLE: Providing a Live ZIO Service Implementation in Scala\nDESCRIPTION: This snippet demonstrates providing the `DatabaseLive` implementation to an effect `main` that requires a `Database` environment. Using `main.provide(DatabaseLive)` satisfies the environment requirement, resulting in an effect `main2` of type `Task[Unit]` which no longer requires the `Database` module.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\n```scala\ndef main: RIO[Database, Unit] = ???\n\ndef main2: Task[Unit] = \n  main.provide(DatabaseLive)\n```\n```\n\n----------------------------------------\n\nTITLE: Collecting Parallel Failures with parallelErrors in ZIO (Scala)\nDESCRIPTION: This Scala snippet demonstrates the `parallelErrors` combinator. It's applied to a parallel computation (`<&>`) of two failing effects. The result type `ZIO[Any, ::[String], Nothing]` indicates that any parallel failures (of type `String` in this case) are collected into a non-empty list (`::`) within the ZIO effect's error channel. This operator specifically targets failures, not defects or interruptions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/sequential-and-parallel-errors.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\n```scala mdoc:compile-only\nimport zio._\n\nval result: ZIO[Any, ::[String], Nothing] =\n  (ZIO.fail(\"Oh uh!\") <&> ZIO.fail(\"Oh Error!\")).parallelErrors\n```\n```\n\n----------------------------------------\n\nTITLE: Asserting Throwable Cause in Scala\nDESCRIPTION: Creates an assertion `Assertion[Throwable]` that checks if a `Throwable` has a cause (another `Throwable`) that satisfies the provided nested assertion. Allows checking nested exceptions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nhasThrowableCause(cause: Assertion[Throwable])\n```\n\n----------------------------------------\n\nTITLE: Illustrating Lossy Either Projection with ZIO.left in ZIO 1.x (Scala)\nDESCRIPTION: Shows an example in ZIO 1.x where an effect `effect` produces a `Left[Int, String]`. Applying the `.left` operator projects the `Left` value (`Int`) into the success channel, but the error channel becomes `Option[Throwable]`. This loses the type information (`String`) associated with the potential `Right` case, making it impossible to fully reconstruct the original `Either` structure.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_22\n\nLANGUAGE: scala\nCODE:\n```\nval effect         = Task.effect(Left[Int, String](5))\n// effect: ZIO[Any, Throwable, Left[Int, String]]\nval leftProjection = effect.left\n// leftProjection: ZIO[Any, Option[Throwable], Int]\n```\n\n----------------------------------------\n\nTITLE: Config-Driven Workflow Printing Application Configuration - Scala\nDESCRIPTION: This effectful workflow loads the `HttpServerConfig` from ZIO's configuration, then prints the host and port values to the console. It demonstrates flatMapping over the effect to use the loaded config, and is a classical example of configuration-driven initialization in ZIO applications. Requires ZIO, ZIO Config, and Java IO imports. Expected inputs are environment-provided configuration or defaults.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_4\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\n\nimport java.io.IOException\n\nval workflow: ZIO[Any, Exception, Unit] =\n  ZIO.config[HttpServerConfig].flatMap { config =>\n    Console.printLine(\n      \"Application started with following configuration:\\n\" +\n        s\"\\thost: ${config.host}\\n\" +\n        s\"\\tport: ${config.port}\"\n    )\n  }\n```\n\n----------------------------------------\n\nTITLE: Polymorphic Ref Usage Example\nDESCRIPTION: Demonstrates how to create and use read-only and write-only views of a Ref.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  ref       <- Ref.make(false)\n  readOnly  = ref.readOnly\n  writeOnly = ref.writeOnly\n  _         <- writeOnly.set(true)\n  value     <- readOnly.get\n} yield value\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO JSON Dependency\nDESCRIPTION: SBT dependency configuration for ZIO JSON module\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-json\" % \"0.1.5\"\n```\n\n----------------------------------------\n\nTITLE: Reversing Error Order Using Flip Operators in ZIO - Scala\nDESCRIPTION: Demonstrates three ways to reverse the order of errors in a ZIO effect: using mapError directly, flipping the channels and mapping, and using flipWith with a transformation function. All examples act on a ZIO effect that accumulates a list of string errors, showing different approaches to error channel manipulation. Requires zio._ import and assumes evens is a predefined ZIO effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/operations/flipping-the-error-and-success-channel.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nval r1: ZIO[Any, List[String], List[Int]] = evens.mapError(_.reverse)\nval r2: ZIO[Any, List[String], List[Int]] = evens.flip.map(_.reverse).flip\nval r3: ZIO[Any, List[String], List[Int]] = evens.flipWith(_.map(_.reverse))\n```\n\n----------------------------------------\n\nTITLE: Broadcasting a ZIO Stream to Multiple Consumers\nDESCRIPTION: This comprehensive example demonstrates broadcasting a stream of random numbers to two consumers: one computing the maximum value and another logging values with a delay. It shows how the upstream stream adjusts its speed to match the slowest consumer.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_52\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZIO[Console with Random with Clock, IOException, Unit] =\n  ZStream\n    .fromIterable(1 to 20)\n    .mapM(_ => zio.random.nextInt)\n    .map(Math.abs)\n    .map(_ % 100)\n    .tap(e => putStrLn(s\"Emit $e element before broadcasting\"))\n    .broadcast(2, 5)\n    .use {\n      case s1 :: s2 :: Nil =>\n        for {\n          out1 <- s1.fold(0)((acc, e) => Math.max(acc, e))\n                    .flatMap(x => putStrLn(s\"Maximum: $x\"))\n                    .fork\n          out2 <- s2.schedule(Schedule.spaced(1.second))\n                    .foreach(x => putStrLn(s\"Logging to the Console: $x\"))\n                    .fork\n          _    <- out1.join.zipPar(out2.join)\n        } yield ()\n\n      case _ => ZIO.dieMessage(\"unhandled case\")\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO Kafka Streaming Consumer API Interface in Scala\nDESCRIPTION: This Scala code snippet presents the definition of the `plainStream` method within the ZIO Kafka `Consumer` trait. This method creates a `ZStream` that consumes records from Kafka based on the provided `Subscription`. It requires `Deserializer` instances for the key and value to convert raw bytes into desired types, emitting `CommittableRecord[K, V]` objects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/produce-consume-data-to-from-kafka-topics.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\ntrait Consumer {\n  def plainStream[R, K, V](\n    subscription: Subscription,\n    keyDeserializer: Deserializer[R, K],\n    valueDeserializer: Deserializer[R, V]\n  ): ZStream[R, Throwable, CommittableRecord[K, V]]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ZIO ZMX Library in Scala SBT Project\nDESCRIPTION: This snippet shows how to add the ZIO ZMX library dependency to a Scala project using SBT (Scala Build Tool). It specifies the library coordinates and version.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_53\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-zmx\" % \"0.0.6\"\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Example with Rezilience\nDESCRIPTION: Example of implementing a Circuit Breaker pattern using Rezilience for handling external service calls.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nimport nl.vroste.rezilience.CircuitBreaker.{CircuitBreakerCallError, State}\nimport nl.vroste.rezilience._\nimport zio._\nimport zio.clock.Clock\nimport zio.console.{Console, putStrLn}\nimport zio.duration._\n\nobject CircuitBreakerExample extends zio.App {\n\n  def callExternalSystem: ZIO[Console, String, Nothing] =\n    putStrLn(\"External service called, but failed!\").orDie *>\n      ZIO.fail(\"External service failed!\")\n\n  val myApp: ZIO[Console with Clock, Nothing, Unit] =\n    CircuitBreaker.withMaxFailures(\n      maxFailures = 10,\n      resetPolicy = Schedule.exponential(1.second),\n      onStateChange = (state: State) =>\n        ZIO(println(s\"State changed to $state\")).orDie\n    ).use { cb =>\n      for {\n        _ <- ZIO.foreach_(1 to 10)(_ => cb(callExternalSystem).either)\n        _ <- cb(callExternalSystem).catchAll(errorHandler)\n        _ <- ZIO.sleep(2.seconds)\n        _ <- cb(callExternalSystem).catchAll(errorHandler)\n      } yield ()\n    }\n\n  def errorHandler: CircuitBreakerCallError[String] => URIO[Console, Unit] = {\n    case CircuitBreaker.CircuitBreakerOpen =>\n      putStrLn(\"Circuit breaker blocked the call to our external system\").orDie\n    case CircuitBreaker.WrappedError(error) =>\n      putStrLn(s\"External system threw an exception: $error\").orDie\n  }\n  \n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Impure Methods with @throwing Annotation (Scala)\nDESCRIPTION: Demonstrates how to annotate impure methods with @throwing in a ZIO service module. The macro generates an accessor that wraps exceptions into ZIO's error channel. Requires zio-macros, ZIO, and the annotated Service trait. Input: Something, Output: SomethingElse, with exceptions lifted to ZIO's failure channel (Throwable).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/howto-macros.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.{ Has, ZIO }\nimport zio.macros.accessible\n\n@accessible\nobject Module {\n  trait Service {\n    @throwing\n    def impureMethod(v: Something): SomethingElse\n  }\n\n  // below will be autogenerated\n  def impureMethod(v: Something): ZIO[Service, Throwable, SomethingElse] =\n    ZIO.accessM[Has[Module.Service]](s => ZIO(s.get[Service].impureMethod(v)))\n}\n```\n\n----------------------------------------\n\nTITLE: Using Symbolic Alias *> for zipRight in ZIO Scala\nDESCRIPTION: Shows the symbolic alias `*>` for `ZIO#zipRight`. This code achieves the same result as using `zipRight`: it executes `putStrLn` followed by `getStrLn` and keeps only the success value of `getStrLn`. Some developers prefer this operator syntax for readability. Assumes `putStrLn` and `getStrLn` are defined ZIO effects for console I/O. Requires the ZIO library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/basic_operations.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval zipRight2 = \n  putStrLn(\"What is your name?\") *>\n  getStrLn\n```\n```\n\n----------------------------------------\n\nTITLE: Using a Buffered Channel with Full Buffer in Scala ZIO\nDESCRIPTION: Shows how a buffered channel behaves when its buffer is full - it outputs the buffer content followed by the input value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zchannel/composing-channels.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\n(ZChannel.write(1) >>> buffered(0)).runCollect.debug\n// Output: (Chunk(2,1),())\n```\n\n----------------------------------------\n\nTITLE: ZIO JSON Encoding/Decoding Example\nDESCRIPTION: Example showing JSON encoding and decoding using ZIO JSON with ADTs and derived codecs\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_15\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.json._\n\nsealed trait Fruit                   extends Product with Serializable\ncase class Banana(curvature: Double) extends Fruit\ncase class Apple(poison: Boolean)    extends Fruit\n\nobject Fruit {\n  implicit val decoder: JsonDecoder[Fruit] =\n    DeriveJsonDecoder.gen[Fruit]\n\n  implicit val encoder: JsonEncoder[Fruit] =\n    DeriveJsonEncoder.gen[Fruit]\n}\n\nval json1         = \"\"\"{ \"Banana\":{ \"curvature\":0.5 }}\"\"\"\n// json1: String = \"{ \\\"Banana\\\":{ \\\"curvature\\\":0.5 }}\"\nval json2         = \"\"\"{ \"Apple\": { \"poison\": false }}\"\"\"\n// json2: String = \"{ \\\"Apple\\\": { \\\"poison\": false }}\"\nval malformedJson = \"\"\"{ \"Banana\":{ \"curvature\": true }}\"\"\"\n// malformedJson: String = \"{ \\\"Banana\\\":{ \\\"curvature\\\": true }}\"\n\njson1.fromJson[Fruit]\n// res0: Either[String, Fruit] = Right(value = Banana(curvature = 0.5))\njson2.fromJson[Fruit]\n// res1: Either[String, Fruit] = Right(value = Apple(poison = false))\nmalformedJson.fromJson[Fruit]\n// res2: Either[String, Fruit] = Left(\n//   value = \".Banana.curvature(expected a number, got t)\"\n// )\n\nList(Apple(false), Banana(0.4)).toJsonPretty\n```\n\n----------------------------------------\n\nTITLE: Using Semaphore with Single Permit in ZIO (Scala)\nDESCRIPTION: This example demonstrates how to create and use a Semaphore with one permit to limit concurrent execution of tasks. It creates a semaphore with one permit and runs three identical tasks in parallel, with the semaphore ensuring only one task runs at a time.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/semaphore.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport java.util.concurrent.TimeUnit\nimport zio._\nimport zio.console._\nimport zio.duration.Duration\n\nval task = for {\n  _ <- putStrLn(\"start\")\n  _ <- ZIO.sleep(Duration(2, TimeUnit.SECONDS))\n  _ <- putStrLn(\"end\")\n} yield ()\n\nval semTask = (sem: Semaphore) => for {\n  _ <- sem.withPermit(task)\n} yield ()\n\nval semTaskSeq = (sem: Semaphore) => (1 to 3).map(_ => semTask(sem))\n\nval program = for {\n\n  sem <- Semaphore.make(permits = 1)\n\n  seq <- ZIO.effectTotal(semTaskSeq(sem))\n\n  _ <- ZIO.collectAllPar(seq)\n\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Partitioning Elements with ZStream#distributedWith in Scala\nDESCRIPTION: This example partitions integers into three streams based on their remainder when divided by 3. The distributedWith operator is used to create a modulo-based partitioning system with each element going to exactly one destination queue.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_54\n\nLANGUAGE: scala\nCODE:\n```\nval partitioned: ZManaged[Clock, Nothing, (UStream[Int], UStream[Int], UStream[Int])] =\n  ZStream\n    .iterate(1)(_ + 1)\n    .fixed(1.seconds)\n    .distributedWith(3, 10, x => ZIO.succeed(q => x % 3 == q))\n    .flatMap { case q1 :: q2 :: q3 :: Nil =>\n      ZManaged.succeed(\n        ZStream.fromQueue(q1).flattenExitOption,\n        ZStream.fromQueue(q2).flattenExitOption,\n        ZStream.fromQueue(q3).flattenExitOption\n      )\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Backend Server with Tracing\nDESCRIPTION: Backend HTTP server implementation using HTTP4s with OpenTracing integration to capture incoming requests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_49\n\nLANGUAGE: scala\nCODE:\n```\nobject BackendServer extends CatsApp {\n  type AppTask[A] = ZIO[Clock, Throwable, A]\n\n  val dsl: Http4sDsl[AppTask] = Http4sDsl[AppTask]\n  import dsl._\n\n  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] =\n    ZIO.runtime[Clock].flatMap { implicit runtime =>\n      BlazeServerBuilder[AppTask](runtime.platform.executor.asEC)\n        .bindHttp(port = 9000, host = \"0.0.0.0\")\n        .withHttpApp(\n          Router[AppTask](mappings = \"/\" ->\n            HttpRoutes.of[AppTask] { case request@GET -> Root =>\n              ZIO.unit\n                .spanFrom(\n                  format = HttpHeadersFormat,\n                  carrier = new TextMapAdapter(request.headers.toList.map(h => h.name.value -> h.value).toMap.asJava),\n                  operation = \"GET /\"\n                )\n                .provideLayer(makeJaegerTracer(host = \"0.0.0.0:9411\", serviceName = \"backend-service\")) *> Ok(\"Ok!\")\n            }\n          ).orNotFound\n        )\n        .serve\n        .compile\n        .drain\n    }.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the ZIO#retryOrElse Method Signature in Scala\nDESCRIPTION: Defines the signature for the `retryOrElse` method on the ZIO trait. It allows specifying a retry policy (`Schedule`) and a fallback effect (`orElse`) to execute if the retries according to the policy are exhausted. The `orElse` function receives the last error and the schedule's output state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  def retryOrElse[R1 <: R, A1 >: A, S, E1](\n    policy: => Schedule[R1, E, S],\n    orElse: (E, S) => ZIO[R1, E1, A1]\n  ): ZIO[R1, E1, A1] =\n}\n```\n\n----------------------------------------\n\nTITLE: Using Predefined Assertion in Scala\nDESCRIPTION: Demonstrates how to use a predefined assertion (equalTo) from the Assertion companion object to test a simple integer value.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/index.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.Assertion\n\ndef sut = 40 + 2\nval assertion: Assertion[Int] = Assertion.equalTo[Int, Int](42)\nassertion.test(sut) // true\n```\n\n----------------------------------------\n\nTITLE: Accessing the Default ZIO Runtime in Scala\nDESCRIPTION: Shows how to obtain the default ZIO `Runtime` instance using `Runtime.default`. This predefined runtime bundles production implementations of standard ZIO modules (like `Console`, `System`, `Clock`, etc.) and is suitable for running effects within applications that integrate with legacy code or procedural frameworks where a full `zio.App` structure isn't used.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/running_effects.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval runtime = Runtime.default\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Service Errors and Remote Service for Retry Examples in Scala\nDESCRIPTION: Defines custom error types (`ServiceError`, `TemporarilyUnavailable`, `DataCorrupted`) extending `Exception` and a placeholder `remoteService` function returning a `ZIO[Any, ServiceError, Unit]`. This setup provides context for demonstrating conditional retry logic using `retryUntil` and `retryWhile`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/error-management/recovering/retrying.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait  ServiceError extends Exception\ncase object TemporarilyUnavailable extends ServiceError\ncase object DataCorrupted          extends ServiceError\n\ndef remoteService: ZIO[Any, ServiceError, Unit] = ???\n```\n\n----------------------------------------\n\nTITLE: Implementing Atomic Money Transfer using ZIO STM\nDESCRIPTION: Demonstrates a basic atomic money transfer between accounts using STM transactions. The transaction ensures atomic updates to both accounts and fails if sender has insufficient funds.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/stm.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\ndef transferMoney(from: TRef[Long], to: TRef[Long], amount: Long): STM[String, Long] =\n  for {\n    senderBal <- from.get\n    _         <- if (senderBal < amount) STM.fail(\"Not enough money\")\n                 else STM.unit\n    _         <- from.update(existing => existing - amount)\n    _         <- to.update(existing => existing + amount)\n    recvBal   <- to.get\n  } yield recvBal\n\nval program: IO[String, Long] = for {\n  sndAcc  <- STM.atomically(TRef.make(1000L))\n  rcvAcc  <- STM.atomically(TRef.make(0L))\n  recvAmt <- STM.atomically(transferMoney(sndAcc, rcvAcc, 500L))\n} yield recvAmt\n```\n\n----------------------------------------\n\nTITLE: Reading Environment Variables with ZIO System in Scala\nDESCRIPTION: Demonstrates using `system.env(\"VAR_NAME\")` to safely retrieve the value of a specified environment variable (e.g., \"JAVA_HOME\"). The result is a ZIO effect (`ZIO[System, SecurityException, Option[String]]`) that yields an `Option[String]`, indicating whether the variable exists, and may fail with a `SecurityException` if access is denied.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/access-system-information.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\n// Read an environment variable\nsystem.env(\"JAVA_HOME\")\n// res0: zio.ZIO[system.package.System, SecurityException, Option[String]] = zio.ZIO$Read@2111d7b9\n```\n\n----------------------------------------\n\nTITLE: Accessing Java Properties with ZIO System in Scala\nDESCRIPTION: Illustrates how to use `system.property(\"PROP_NAME\")` to safely access a Java system property (e.g., \"java.version\"). It returns a ZIO effect (`ZIO[System, Throwable, Option[String]]`) yielding an `Option[String]` containing the property value if found, and can fail with a `Throwable` for various reasons (e.g., security restrictions).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/access-system-information.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Read a system property\nsystem.property(\"java.version\")\n// res1: zio.ZIO[system.package.System, Throwable, Option[String]] = zio.ZIO$Read@7a023e34\n```\n\n----------------------------------------\n\nTITLE: Using Smart Constructors in ZIO 2.0\nDESCRIPTION: Demonstration of ZIO 2.0's smart constructors which intelligently choose the appropriate constructor based on input type, allowing more concise code compared to the explicit constructor methods in ZIO 1.x.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_82\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream.ZStream\n\nZIO.fromOption(Some(\"Ok!\"))\nZIO.from(Some(\"Ok!\"))\n\nZIO.fromEither(Right(3))\nZIO.from(Right(3))\n\nZIO.fromFiber(Fiber.succeed(\"Ok!\"))\nZIO.from(Fiber.succeed(\"Ok!\"))\n\nZStream.fromIterable(List(1,2,3)) \nZStream.from(List(1,1,3))\n\nZStream.fromChunk(Chunk(1,2,3))\nZStream.from(Chunk(1,2,3))\n\nZStream.fromIterableZIO(ZIO.succeed(List(1,2,3)))\nZStream.from(ZIO.succeed(List(1,2,3)))\n```\n\n----------------------------------------\n\nTITLE: Asserting Value is Unit in Scala\nDESCRIPTION: Creates an assertion `Assertion[Unit]` that checks if a value is `Unit` (the singleton value `()`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_32\n\nLANGUAGE: scala\nCODE:\n```\nisUnit\n```\n\n----------------------------------------\n\nTITLE: Defining Configuration Data Type for HTTP Server - Scala\nDESCRIPTION: This Scala snippet defines a case class `HttpServerConfig` with fields for the host, port, and number of threads. It is intended to represent the application's configuration data structure required for the server settings. This ADT will be used later for mapping configuration sources to typed Scala objects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_1\n\nLANGUAGE: Scala\nCODE:\n```\ncase class HttpServerConfig(host: String, port: Int, nThreads: Int)\n```\n\n----------------------------------------\n\nTITLE: Creating and Initializing ConcurrentMap in Scala/ZIO\nDESCRIPTION: Demonstrates various ways to create and initialize a ConcurrentMap including empty map creation, initialization from iterables, and direct key-value pair creation. Shows different initialization patterns using ZIO's concurrent data structures.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/concurrentmap.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.ConcurrentMap\nimport zio.{Chunk, UIO}\n\nfor {\n  emptyMap <- ConcurrentMap.empty[Int, String]\n  data     <- UIO(Chunk(1 -> \"A\", 2 -> \"B\", 3 -> \"C\"))\n  mapA     <- ConcurrentMap.fromIterable(data)\n  map100   <- ConcurrentMap.make(1 -> 100)\n  mapB     <- ConcurrentMap.make((\"A\", 1), (\"B\", 2), (\"C\", 3))\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Parallel Effectful Updates with RefM in Scala\nDESCRIPTION: Shows how to use RefM for parallel effectful updates in a real-world scenario. This example calculates the mean age of users by querying an API in parallel while atomically updating a shared counter, demonstrating RefM's ability to maintain state consistency during concurrent operations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/refm.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval meanAge =\n  for {\n    ref <- RefM.make(0)\n    _ <- IO.foreachPar(users) { user =>\n      ref.update(sumOfAges =>\n        api.getAge(user).map(_ + sumOfAges)\n      )\n    }\n    v <- ref.get\n  } yield (v / users.length)\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Tracing in ZIO Runtime\nDESCRIPTION: Demonstrates different ways to configure execution tracing in ZIO Runtime. Shows how to disable tracing completely, enable stack-only tracing, and set up detailed tracing configuration with custom parameters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.internal.Tracing\nimport zio.internal.tracing.TracingConfig\n\nval rt1 = Runtime.default.mapPlatform(_.withTracing(Tracing.disabled))\nval rt2 = Runtime.default.mapPlatform(_.withTracing(Tracing.enabledWith(TracingConfig.stackOnly)))\n\nval config = TracingConfig(\n  traceExecution = true,\n  traceEffectOpsInExecution = true,\n  traceStack = true,\n  executionTraceLength = 100,\n  stackTraceLength = 100,\n  ancestryLength = 10,\n  ancestorExecutionTraceLength = 10,\n  ancestorStackTraceLength = 10\n)\nval rt3 = Runtime.default.mapPlatform(_.withTracingConfig(config))\n```\n\n----------------------------------------\n\nTITLE: Incorrect Service Implementation Violating Second Law\nDESCRIPTION: Shows an incorrect DocRepoImpl implementation that violates the second law of ZIO Environment by not accepting dependencies in the constructor and instead trying to access them from the environment within methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/service-pattern/the-three-laws-of-zio-environment.md#2025-04-23_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\ncase class DocRepoImpl() extends DocRepo {\n  override def delete(id: String): ZIO[Any, Throwable, Unit] =\n    for {\n      blobStorage  <- ZIO.service[BlobStorage]\n      metadataRepo <- ZIO.service[MetadataRepo]\n      _            <- blobStorage.delete(id)\n      _            <- metadataRepo.delete(id)\n    } yield ()\n\n  override def get(id: String): ZIO[Any, Throwable, Doc] = ???\n\n  override def save(document: Doc): ZIO[Any, Throwable, String] = ???\n\n  override def findByTitle(title: String): ZIO[Any, Throwable, List[Doc]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Squashing Multiple Commits for Final PR Submission in Git\nDESCRIPTION: This bash snippet demonstrates how to squash the last 5 commits into a single commit before pushing the final version of code to a pull request. This keeps the commit history clean when a feature has gone through multiple iterations.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/about/contributing.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ngit reset --soft HEAD~5\ngit commit -am \"add feature X\"\ngit push --force\n```\n\n----------------------------------------\n\nTITLE: Setting Typesafe ConfigProvider for ZIO Configuration - Scala\nDESCRIPTION: This code demonstrates how to set the configuration provider in a ZIO application to use Typesafe's HOCON-based provider, which reads configuration from application.conf on the classpath. This must be done before attempting to load configurations from the HOCON file source.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nimport zio._\nimport zio.config.typesafe.TypesafeConfigProvider\n\nRuntime.setConfigProvider(\n  TypesafeConfigProvider.fromResourcePath()\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Configuration via Environment Variables - Bash\nDESCRIPTION: This shell snippet demonstrates passing environment variables to sbt to provide configuration to the ZIO application. Variables map to the application config fields, overriding missing values. This is required for ZIO Config to successfully load values when not using file-based providers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nHTTPSERVERCONFIG_HOST=localhost HTTPSERVERCONFIG_PORT=8080 HTTPSERVERCONFIG_NTHREADS=0 sbt \"runMain dev.zio.quickstart.MainApp\"\n```\n\n----------------------------------------\n\nTITLE: Asserting Boolean is True in Scala\nDESCRIPTION: Creates an assertion `Assertion[Boolean]` that checks if a `Boolean` value is `true`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/built-in-assertions.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nisTrue\n```\n\n----------------------------------------\n\nTITLE: Checking Blocking Fiber Status in Scala ZIO\nDESCRIPTION: Example demonstrating how to fork a never-ending fiber, await its completion in another fiber, and check which fiber ID is being blocked. The code uses pattern matching on Fiber.Status.Suspended to determine blocking relationships between fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberstatus.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.console._\nfor {\n  f1 <- ZIO.never.fork\n  f2 <- f1.await.fork\n  blockingOn <- f2.status\n    .collect(()) { case Fiber.Status.Suspended(_, _, _, blockingOn, _) =>\n      blockingOn\n    }\n    .eventually\n} yield (assert(blockingOn == List(f1.id)))\n```\n\n----------------------------------------\n\nTITLE: Rewriting ZStream Error Handling Combinators for Infallible Effects\nDESCRIPTION: This table demonstrates how to rewrite ZStream error handling combinators when working with streams that cannot fail (UStream). It provides equivalent expressions that maintain the original behavior without unnecessary error handling.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/canfail.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nustream.catchAll(f) | ustream\nustream.either | ustream\nustream.mapBoth(f, g) | ustream.map(g)\nustream.mapError(f) | ustream\nustream.orElse(zstream) | ustream\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for ZIO Homepage in React/JSX\nDESCRIPTION: Imports React, utility functions (`clsx`), Docusaurus components (`Layout`, `Link`), hooks (`useDocusaurusContext`, `useBaseUrl`), and local CSS modules (`styles`) required for building and styling the ZIO project homepage.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/src/pages/version2-only-index.js.txt#2025-04-23_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport React from 'react';\nimport clsx from 'clsx';\nimport Layout from '@theme/Layout';\nimport Link from '@docusaurus/Link';\nimport useDocusaurusContext from '@docusaurus/useDocusaurusContext';\nimport useBaseUrl from '@docusaurus/useBaseUrl';\nimport styles from './index.module.css';\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Bracket Pattern for Resource Management\nDESCRIPTION: Example demonstrating the ZIO bracket pattern with generic resource handling. The bracket pattern requires three actions: acquiring, using, and releasing resources, providing strong guarantees for resource cleanup.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ndef use(resource: Resource): Task[Any] = Task.effect(???)\ndef release(resource: Resource): UIO[Unit] = Task.effectTotal(???)\ndef acquire: Task[Resource]                = Task.effect(???)\n\nval result1: Task[Any] = acquire.bracket(release, use)\nval result2: Task[Any] = acquire.bracket(release)(use) // More ergonomic API\n\nval result3: Task[Any] = Task.bracket(acquire, release, use)\nval result4: Task[Any] = Task.bracket(acquire)(release)(use) // More ergonomic API\n```\n\n----------------------------------------\n\nTITLE: LogStage Integration Example with ZIO\nDESCRIPTION: Example demonstrating LogStage usage with ZIO, showing logging within different fibers and UUID generation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nimport izumi.fundamentals.platform.uuid.UUIDGen\nimport logstage.LogZIO.log\nimport logstage.{IzLogger, LogIO2, LogZIO}\nimport zio.{Has, URIO, _}\n\nobject LogStageExample extends zio.App {\n  val myApp = for {\n    _ <- log.info(\"I'm logging with logstage!\")\n    userId = UUIDGen.getTimeUUID()\n    _ <- log.info(s\"Current $userId\")\n    _ <- log.info(\"I'm logging within the same fiber!\")\n    f <- log.info(\"I'm logging within a new fiber!\").fork\n    _ <- f.join\n  } yield ()\n\n  val loggerLayer: ULayer[Has[LogIO2[IO]]] =\n    ZLayer.succeed(LogZIO.withFiberId(IzLogger()))\n\n  override def run(args: List[String]): URIO[zio.ZEnv, ExitCode] =\n    myApp.provideLayer(loggerLayer).exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: ZLayer Derivation with Config in Scala\nDESCRIPTION: Shows how ZLayer.derive can automatically load configuration using ZIO.config when there's an implicit Config[B] instance available.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/contextual/automatic-zlayer-derivation.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\ncase class APIClientConfig(appKey: String, secretKey: Config.Secret)\nobject APIClientConfig {\n  // Because we have an implicit `Config[APIClientConfig]` in scope...\n  implicit val config: Config[APIClientConfig] =\n    (Config.string(\"appKey\") ++ Config.secret(\"secretKey\")).map {\n      case (uri, key) => APIClientConfig(uri, key)\n    }\n}\n\nclass APIClient(config: APIClientConfig) { /* ... */ }\nobject APIClient {\n\n  // `APIClientConfig` is automatically loaded using `ZIO.config` by `ZLayer.derive`,\n  // instead of being required as a layer input.\n  val layer: ZLayer[Any, Config.Error, APIClient] = ZLayer.derive[APIClient]\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Summary Metric to a ZIO Effect in Scala\nDESCRIPTION: Illustrates how to apply the previously defined `summary` metric aspect to a ZIO effect (`Random.nextDoubleBetween`). The `@@` operator is used to observe the Double value produced by the effect (a random double between 100 and 500) with the configured summary metric, effectively recording it for quantile calculation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/observability/metrics/summary.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nRandom.nextDoubleBetween(100, 500) @@ summary\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Config Values via Environment Variables in sbt - Scala\nDESCRIPTION: This snippet runs the application and supplies HOST and PORT variables, demonstrating how default values in HOCON can be overridden by environment variables. It is an example of customizing runtime configuration for a ZIO app in development and production environments.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_11\n\nLANGUAGE: Scala\nCODE:\n```\n$ HOST=localhost PORT=8081 sbt run\n```\n\n----------------------------------------\n\nTITLE: Using TestAspect.size in ZIO Test Spec\nDESCRIPTION: Example of using the TestAspect.size to run a test with a specific size in a ZIO Test specification.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/services/sized.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test._\n\nobject SizedSpec extends ZIOSpecDefault {\n  def spec =\n    suite(\"sized\") {\n      test(\"bounded int generator shouldn't cross its boundaries\") {\n        check(Gen.sized(Gen.int(0, _))) { n =>\n          assertTrue(n >= 0 && n <= 200)\n        }\n      } @@ TestAspect.size(200)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a TRef Value in a Single Transaction in Scala ZIO STM\nDESCRIPTION: Creates a TRef, sets its value to 20, and then retrieves the new value, all within a single atomic transaction. This shows how to modify a TRef and confirm the change.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tref.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval setSingle: UIO[Int] = (for {\n  tRef <- TRef.make(10)\n  _ <- tRef.set(20)\n  nValue <- tRef.get\n} yield nValue).commit\n```\n\n----------------------------------------\n\nTITLE: Converting Option[A] to ZIO[Any, E, A] in Scala\nDESCRIPTION: Transforms a `scala.Option[A]` into a `ZIO[Any, E, A]`. If the `Option` is `Some(a)`, the effect succeeds with `a`. If it's `None`, the effect fails with the provided `ifEmpty` error of type `E` using `orElseFail`.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/handle-errors.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nZIO.fromOption(from).orElseFail(ifEmpty)\n```\n\n----------------------------------------\n\nTITLE: Mapping Error of ZIO Option Effect with mapError - Scala\nDESCRIPTION: Demonstrates converting an effect's Option error into a descriptive String error using mapError, enhancing error reporting for absent Option values. Input is the zoption effect; the output effect now errors with a String instead of Option[Nothing].\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/creating_effects.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval zoption2: IO[String, Int] = zoption.mapError(_ => \"It wasn't there!\")\n```\n\n----------------------------------------\n\nTITLE: Scheduling ZStream Output with Fixed Time Interval in Scala\nDESCRIPTION: This code snippet demonstrates how to create a ZStream and schedule its output using a fixed time interval. It uses the Schedule.spaced method to introduce a 1-second delay between each emission of the stream elements.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stream/zstream/scheduling.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stream._\n\nval stream = ZStream(1, 2, 3, 4, 5).schedule(Schedule.spaced(1.second))\n```\n\n----------------------------------------\n\nTITLE: Debugging ZIO Applications with debug Method\nDESCRIPTION: Example of using the debug method introduced in ZIO 2.x for printing values to the console during development without additional environmental requirements or error types.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_87\n\nLANGUAGE: scala\nCODE:\n```\nval myApp: ZIO[Random, Nothing, String] =\n  ZIO\n    .ifZIO(\n      Random.nextIntBounded(10) debug(\"random\") map (_ % 2 == 0)\n    )(\n      onTrue = ZIO.succeed(\"Hello!\"),\n      onFalse = ZIO.succeed(\"Good Bye!\")\n    )\n    .debug(\"result\")\n// Sample Output\n// random: 2\n// result: Hello!\n```\n\n----------------------------------------\n\nTITLE: TestAspect Order Example 1\nDESCRIPTION: Demonstrates how test aspect ordering affects behavior with nonFlaky and repeats aspects.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/index.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\nimport zio.test.TestAspect._\n\nsuite(\"suite\")(\n  test(\"A\") {\n    ZIO.debug(\"executing test\")\n      .map(_ => assertTrue(true))\n  },\n) @@ nonFlaky @@ repeats(2)\n```\n\n----------------------------------------\n\nTITLE: Using ZIO Service Helpers for Environmental Effects in Scala\nDESCRIPTION: This snippet demonstrates how to use the previously defined helper function `db.lookup` to interact with the `Database` service. The resulting effect `lookedupProfile` requires a `Database` module in its environment.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/overview/testing_effects.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\n```scala\nval lookedupProfile: RIO[Database, UserProfile] = \n  for {\n    profile <- db.lookup(userId)\n  } yield profile\n```\n```\n\n----------------------------------------\n\nTITLE: Transforming Entries in a TMap in ZIO STM\nDESCRIPTION: Uses transform to apply a function to every entry in the TMap. This function receives both the key and value, and can modify both elements of each entry.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval transformTMap: UIO[TMap[String, Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  _    <- tMap.transform((k, v) => k -> v * v)\n} yield tMap).commit\n```\n\n----------------------------------------\n\nTITLE: Taking All Elements from Queue in Scala\nDESCRIPTION: Retrieves and consumes all currently available items from the queue using takeAll. Yields a List[Int] and will return Nil if the queue is empty. Helps batch processing consumers rapidly.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/queue.md#2025-04-23_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nval all: UIO[List[Int]] = for {\\n  queue <- Queue.bounded[Int](100)\\n  _ <- queue.offer(10)\\n  _ <- queue.offer(20)\\n  list  <- queue.takeAll\\n} yield list\\n\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Aggregation with ZStream#aggregateAsync in Scala\nDESCRIPTION: Asynchronous aggregation with aggregateAsync emits elements whenever the downstream pulls, regardless of whether the transducer has collected its target number of elements. This allows for more dynamic batching based on downstream consumption rates.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_59\n\nLANGUAGE: scala\nCODE:\n```\nval myApp = \n  source.aggregateAsync(ZTransducer.collectAllN[Int](5)).run(sink)\n```\n\n----------------------------------------\n\nTITLE: File Transfer with ZManaged for Composable Resource Management\nDESCRIPTION: Rewriting the file transfer example using ZManaged for better resource composition, showing how multiple resources can be managed in a more readable, functional way.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(from: String, to: String): ZIO[Any, Throwable, Unit] = {\n  val resource = for {\n    from <- ZManaged.make(is(from))(close)\n    to   <- ZManaged.make(os(to))(close)\n  } yield (from, to)\n\n  resource.use { case (in, out) =>\n    copy(in, out)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: File Transfer with Parallel Resource Acquisition in ZIO\nDESCRIPTION: An improved file transfer example using zipPar to acquire resources in parallel rather than sequentially, avoiding nested brackets for a more efficient implementation.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef transfer(src: String, dst: String): ZIO[Any, Throwable, Unit] = {\n  is(src)\n    .zipPar(os(dst))\n    .bracket { case (in, out) =>\n      Task\n        .effectTotal(in.close())\n        .zipPar(Task.effectTotal(out.close()))\n    } { case (in, out) =>\n      copy(in, out)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating ZIO Streams using ++ and concat operators\nDESCRIPTION: This snippet demonstrates how to concatenate two ZIO streams using the ++ and concat operators. Both operations append the elements of the second stream after the first stream has been fully consumed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_38\n\nLANGUAGE: scala\nCODE:\n```\nval a = ZStream(1, 2, 3)\nval b = ZStream(4, 5)\nval c1 = a ++ b\nval c2 = a concat b\n```\n\n----------------------------------------\n\nTITLE: Basic RefM Usage in Scala with ZIO\nDESCRIPTION: Demonstrates the basic usage of RefM by creating a reference, defining an update effect, and applying it to the reference. This shows how RefM differs from Ref by allowing effectful updates to the shared state.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/refm.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nfor {\n  refM   <- RefM.make(\"current\")\n  updateEffect = IO.effectTotal(\"update\")\n  _ <- refM.update(_ => updateEffect)\n  value <- refM.get\n} yield assert(value == \"update\")\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Ignored Tests in Test Suite\nDESCRIPTION: Demonstrates how to ignore multiple tests within a test suite and use TestAspect.success to fail all ignored tests. This pattern is useful for ensuring ignored tests are addressed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/ignoring-tests.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.test.{test, _}\n\nsuite(\"sample tests\")(\n  test(\"an ignored test\") {\n    assertTrue(false)\n  } @@ TestAspect.ignore,\n  test(\"another ignored test\") {\n    assertTrue(true)\n  } @@ TestAspect.ignore\n) @@ TestAspect.success\n```\n\n----------------------------------------\n\nTITLE: Defining Task Type Alias in Scala for ZIO\nDESCRIPTION: This code snippet shows the definition of Task as a type alias for ZIO[Any, Throwable, A]. It represents an effect that has no environmental requirements, may fail with a Throwable exception, and may succeed with a value of type A.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/task.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Task[+A] = ZIO[Any, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Generating Various Random Values with ZIO Random\nDESCRIPTION: Demonstrates generating random integers, printable characters, and doubles within a specific range using ZIO's Random service.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/services/random.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\n\nfor {\n  randomInt    <- Random.nextInt\n  _            <- Console.printLine(s\"A random Int: $randomInt\")\n  randomChar   <- Random.nextPrintableChar\n  _            <- Console.printLine(s\"A random Char: $randomChar\")\n  randomDouble <- Random.nextDoubleBetween(1.0, 5.0)\n  _            <- Console.printLine(s\"A random double between 1.0 and 5.0: $randomDouble\")\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: ZStream Creation Examples in Scala\nDESCRIPTION: Shows different ways to create ZStreams including empty, single value, finite, and infinite streams.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.stream.ZStream\nval emptyStream         : ZStream[Any, Nothing, Nothing]   = ZStream.empty\nval oneIntValueStream   : ZStream[Any, Nothing, Int]       = ZStream.succeed(4)\nval oneListValueStream  : ZStream[Any, Nothing, List[Int]] = ZStream.succeed(List(1, 2, 3))\nval finiteIntStream     : ZStream[Any, Nothing, Int]       = ZStream.range(1, 10)\nval infiniteIntStream   : ZStream[Any, Nothing, Int]       = ZStream.iterate(1)(_ + 1)\n```\n\n----------------------------------------\n\nTITLE: Defining Layer Type Alias in Scala\nDESCRIPTION: Defines a Layer type alias for ZLayer that requires no input (Any), may fail with error E, and produces output ROut. This simplifies the ZLayer type for cases where no input dependencies are needed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/layer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype Layer[+E, +ROut] = ZLayer[Any, E, ROut]\n```\n\n----------------------------------------\n\nTITLE: Creating a Fixed-size Keyed Pool with Key-dependent Size\nDESCRIPTION: Method signature for creating a ZKeyedPool where the pool size varies based on the key. The size function maps from a key to the desired pool size for that key.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/resource/zkeyedpool.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nobject ZKeyedPool {\n  def make[Key, Env: EnvironmentTag, Err, Item](\n    get: Key => ZIO[Env, Err, Item],\n    size: Key => Int\n  ): ZIO[Env with Scope, Nothing, ZKeyedPool[Err, Key, Item]] = ???\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RIO Type Alias in Scala\nDESCRIPTION: Definition of the RIO type alias that specializes ZIO for workflows that may fail with Throwable. The type alias makes the API more expressive while maintaining the same functionality as ZIO with a Throwable error channel.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/rio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype RIO[-R, +A]  = ZIO[R, Throwable, A]\n```\n\n----------------------------------------\n\nTITLE: Example of Deterministic Random Generator in Scala\nDESCRIPTION: This snippet demonstrates how to use a random generator (Gen.int) within a test case, showing that it produces deterministic values by default for reproducibility.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/property-testing/how-generators-work.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test._\nimport zio.test.TestAspect._\n\nobject ExampleSpec extends ZIOSpecDefault {\n  def spec =\n    test(\"example test\") {\n      check(Gen.int(0, 10)) { n =>\n        println(n)\n        assertTrue(n + n == 2 * n)\n      }\n    } @@ samples(5)\n}\n```\n\n----------------------------------------\n\nTITLE: Ref Modify Implementation\nDESCRIPTION: Internal implementation of Ref's modify function using compare-and-swap operations for atomic updates.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\n  final case class Ref[A](value: AtomicReference[A]) { self =>\n    def modify[B](f: A => (B, A)): UIO[B] = UIO.effectTotal {\n      var loop = true\n      var b: B = null.asInstanceOf[B]\n      while (loop) {\n        val current = value.get\n        val tuple   = f(current)\n        b = tuple._1\n        loop = !value.compareAndSet(current, tuple._2)\n      }\n      b\n    }\n }\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO OpenTracing Dependency to Scala Project\nDESCRIPTION: This snippet shows how to add the ZIO OpenTracing library dependency to a Scala project. This is an alternative to the OpenTelemetry client, providing OpenTracing integration for distributed tracing in ZIO applications.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_46\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"dev.zio\" %% \"zio-opentracing\" % \"0.8.1\"\n```\n\n----------------------------------------\n\nTITLE: Logging Spans for Performance Tracking in ZIO\nDESCRIPTION: Example demonstrating logging spans in ZIO, which automatically calculate and include the running duration of operations in logging data associated with a span label.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_91\n\nLANGUAGE: scala\nCODE:\n```\nZIO.logSpan(\"myspan\") {\n  ZIO.sleep(1.second) *> ZIO.log(\"The job is finished!\")\n}\n```\n\n----------------------------------------\n\nTITLE: Concatenating Chunks in Scala\nDESCRIPTION: Demonstrates how to concatenate two Chunks using the ++ operator. This creates a new Chunk containing all elements from both original Chunks.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nChunk(1,2,3) ++ Chunk(4,5,6)\n// res0: Chunk[Int] = IndexedSeq(1, 2, 3, 4, 5, 6)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using ZManaged Resources\nDESCRIPTION: Basic example showing how to create a managed resource using ZManaged.make constructor and use it with the use method, providing a more composable way to handle resources.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/index.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nval managed = ZManaged.make(acquire)(release)\n```\n\n----------------------------------------\n\nTITLE: Resetting CyclicBarrier\nDESCRIPTION: Demonstrates how resetting a barrier breaks waiting parties. Creates a barrier and shows how reset affects waiting fibers.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/sync/cyclicbarrier.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.CyclicBarrier\n\nfor {\n  barrier <- CyclicBarrier.make(100)\n  f1      <- barrier.await.fork\n  f2      <- barrier.await.fork\n  _       <- f1.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  _       <- f2.status.repeatWhile(!_.isInstanceOf[Fiber.Status.Suspended])\n  _       <- barrier.reset\n  res1    <- f1.await\n  res2    <- f2.await\n} yield ()\n```\n\n----------------------------------------\n\nTITLE: Cloning a Forked ZIO Repository with Git\nDESCRIPTION: Commands to create a directory for ZIO, navigate to it, and clone your forked repository. This is the first step after forking the repository on GitHub.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir zio\ncd zio\ngit clone git@github.com:your-user-name/zio.git .\n```\n\n----------------------------------------\n\nTITLE: Installing ZparkIO dependency in SBT\nDESCRIPTION: This snippet shows how to add the ZparkIO library dependency to a Scala project's build.sbt file. The version numbers for Spark and ZparkIO need to be specified.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/ecosystem/community/zparkio.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"com.leobenkel\" %% \"zparkio\" % \"[SPARK_VERSION]_[VERSION]\"\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO ensuring Method Signature\nDESCRIPTION: Shows the method signature for ZIO's ensuring operation, used to specify finalizers that don't require the exit status of the effect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/gracefully-shutdown-zio-application.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZIO[-R, +E, +A] {\n  final def ensuring[R1 <: R](finalizer: => URIO[R1, Any]): ZIO[R1, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Repeating ZStreams in Scala\nDESCRIPTION: Demonstrates various methods to create repeating ZStreams, including ZStream.repeat, ZStream.repeatWith, and ZStream.repeatEffect.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nval repeatZero: ZStream[Any, Nothing, Int] = ZStream.repeat(0)\n\nimport zio.clock._\nimport zio.duration._\nimport zio.random._\nimport zio.Schedule\nval repeatZeroEverySecond: ZStream[Clock, Nothing, Int] = \n  ZStream.repeatWith(0, Schedule.spaced(1.seconds))\n\nval randomInts: ZStream[Random, Nothing, Int] =\n  ZStream.repeatEffect(zio.random.nextInt)\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO System Package in Scala\nDESCRIPTION: Imports the `zio.system` package, which is necessary to access system-related functionalities like environment variables and properties within a ZIO application.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/access-system-information.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.system\n```\n\n----------------------------------------\n\nTITLE: ZManaged makeExit Constructor Definition\nDESCRIPTION: Shows the type signature for makeExit constructor that allows different release logic based on exit status.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait ZManaged[-R, +E, +A] {\n  def makeExit[R, R1 <: R, E, A](\n    acquire: ZIO[R, E, A]\n  )(release: (A, Exit[Any, Any]) => ZIO[R1, Nothing, Any]): ZManaged[R1, E, A]\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple TSemaphore Permits in Scala ZIO\nDESCRIPTION: Demonstrates how to acquire and release multiple permits at once using acquireN and releaseN methods.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tsemaphore.md#2025-04-23_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tSemaphoreAcquireNReleaseN: STM[Nothing, Boolean] = for {\n  sem <- TSemaphore.make(3L)\n  _   <- sem.acquireN(3L)\n  cap <- sem.available \n  _   <- sem.releaseN(3L)\n} yield cap == 0\n\ntSemaphoreAcquireNReleaseN.commit\n```\n\n----------------------------------------\n\nTITLE: Near-Pangram Example in Hungarian (hu)\nDESCRIPTION: Provides a Hungarian phrase containing all non-ASCII letters used in the language. An English translation is included.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n    rvztr tkrfrgp\n    ( = flood-proof mirror-drilling machine, only all non-ASCII letters )\n```\n\n----------------------------------------\n\nTITLE: Creating a TPromise in ZIO STM\nDESCRIPTION: Creates a new TPromise instance within a software transactional memory context. The TPromise is parameterized with a String error type and an Int success type.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tpromise.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tPromise: STM[Nothing, TPromise[String, Int]] = TPromise.make[String, Int]\n```\n\n----------------------------------------\n\nTITLE: Defining ULayer Type Alias in Scala\nDESCRIPTION: Defines the ULayer type alias, which represents a ZLayer that has no input requirements (Any), cannot fail (Nothing), and produces an output of type ROut.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/ulayer.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ntype ULayer[+ROut] = ZLayer[Any, Nothing, ROut]\n```\n\n----------------------------------------\n\nTITLE: ZIO Ref Implementation of State Counter\nDESCRIPTION: Shows how to implement the same counter functionality using ZIO's Ref for purely functional state management.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nRef.make(0).flatMap { idCounter =>\n  def freshVar: UIO[String] =\n    idCounter.modify(cpt => (s\"var${cpt + 1}\", cpt + 1))\n\n  for {\n    v1 <- freshVar\n    v2 <- freshVar\n    v3 <- freshVar\n  } yield ()\n}\n```\n\n----------------------------------------\n\nTITLE: Complex UserRepository Creation with ZManaged\nDESCRIPTION: Example of combining multiple managed resources and effects to create a UserRepository.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/resource/zmanaged.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ndef userRepository: ZManaged[Blocking with Console, Throwable, UserRepository] = for {\n  cfg <- dbConfig.toManaged_\n  _ <- putStrLn(\"Read database config\").toManaged_\n  _ <- initializeDb(cfg).toManaged_\n  _ <- putStrLn(\"Database initialized\").toManaged_\n  xa <- makeTransactor(cfg)\n  _ <- putStrLn(\"Created new blocking transactor\").toManaged_\n} yield new UserRepository(xa)\n```\n\n----------------------------------------\n\nTITLE: Creating Track Supervisor in Scala\nDESCRIPTION: Creates a new supervisor that tracks child fibers in a set. The weak parameter determines if children should be tracked in a WeakSet.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/supervisor.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nval supervisor = Supervisor.track(true)\n// supervisor: zio.package.UIO[Supervisor[zio.Chunk[zio.Fiber.Runtime[Any, Any]]]] = zio.ZIO$EffectTotal@1fab7211\n```\n\n----------------------------------------\n\nTITLE: Importing ZIO Console Functions (Scala)\nDESCRIPTION: This snippet demonstrates how to import all functions from the `zio.console` module using a wildcard import. This allows direct access to console-related effects like `putStrLn` and `getStrLn` without needing to qualify them (e.g., `console.putStrLn`).\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/getting_started.md#2025-04-23_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.console._\n```\n\n----------------------------------------\n\nTITLE: STM-based Withdraw Implementation\nDESCRIPTION: Thread-safe implementation of withdraw using STM's TRef for atomic transactions.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/index.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ndef withdraw(accountBalance: TRef[Int], amount: Int): STM[String, Unit] =\n  for {\n    balance <- accountBalance.get\n    _ <- if (balance < amount)\n      STM.fail(\"Insufficient funds in you account\")\n    else\n      accountBalance.update(_ - amount)\n  } yield ()\n```\n\n----------------------------------------\n\nTITLE: Constructing an Assertion for Subtype Failure in ZIO Test (Scala)\nDESCRIPTION: This code shows how to build a ZIO Test assertion to check if an effect's failure is a subtype of a specified type (`MyError`). It uses `Assertion.fails` combined with `Assertion.isSubtype`, where `anything` is used as the assertion for the value within the subtype.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/assertions/classic-assertions.md#2025-04-23_snippet_13\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.test.Assertion._\n\nAssertion.fails(isSubtype[MyError](anything))\n```\n\n----------------------------------------\n\nTITLE: Inheriting FiberRef Values\nDESCRIPTION: Shows how to inherit FiberRef values from another fiber using inheritRefs.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/fiber/fiberref.md#2025-04-23_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nfor {\n  fiberRef <- FiberRef.make[Int](0)\n  latch    <- Promise.make[Nothing, Unit]\n  fiber    <- (fiberRef.set(10) *> latch.succeed(())).fork\n  _        <- latch.await\n  _        <- fiber.inheritRefs\n  v        <- fiberRef.get\n} yield v == 10\n```\n\n----------------------------------------\n\nTITLE: Defining ZIO App Entry Point Interface\nDESCRIPTION: Core trait definition for ZIO applications showing the main entry point method signature\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\npackage zio\ntrait App {\n  def run(args: List[String]): URIO[ZEnv, ExitCode]\n}\n```\n\n----------------------------------------\n\nTITLE: Asserting Option Values in Scala\nDESCRIPTION: Creates assertions for Option types, checking if they are None, Some with a specific value, or just Some.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_16\n\nLANGUAGE: Scala\nCODE:\n```\nisNone\n```\n\nLANGUAGE: Scala\nCODE:\n```\nisSome[A](assertion: Assertion[A])\n```\n\nLANGUAGE: Scala\nCODE:\n```\nisSome\n```\n\n----------------------------------------\n\nTITLE: Effectful Update of TArray Element in Scala ZIO STM\nDESCRIPTION: Shows how to perform an effectful update of a TArray element using updateM\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tArrayUpdateMElem: UIO[TArray[Int]] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  _      <- tArray.updateM(2, el => STM.succeed(el + 10))\n} yield tArray).commit\n```\n\n----------------------------------------\n\nTITLE: Try Type Assertions\nDESCRIPTION: Functions for testing Try monad values and their success/failure states.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_10\n\nLANGUAGE: Scala\nCODE:\n```\nisFailure(assertion: Assertion[Throwable]): Assertion[Try[Any]]\nisFailure: Assertion[Try[Any]]\nisSuccess[A](assertion: Assertion[A]): Assertion[Try[A]]\nisSuccess: Assertion[Try[Any]]\n```\n\n----------------------------------------\n\nTITLE: Sending GraphQL Query to Caliban API using cURL\nDESCRIPTION: Demonstrates how to send a GraphQL query to the Caliban API using a cURL command in bash.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl 'http://localhost:8088/api/graphql' --data-binary '{\"query\":\"query{\\n employees(role: SoftwareDeveloper){\\n name\\n role\\n}\\n}\"}\n```\n\n----------------------------------------\n\nTITLE: Folding TArray Elements in Scala ZIO STM\nDESCRIPTION: Demonstrates how to fold elements of a TArray using an associative binary operator\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stm/tarray.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval foldTArray: UIO[Int] = (for {\n  tArray <- TArray.make(1, 2, 3, 4)\n  sum    <- tArray.fold(0)(_ + _)\n} yield sum).commit\n```\n\n----------------------------------------\n\nTITLE: Incorrect Ref Creation Example - Scala\nDESCRIPTION: Example showing improper Ref creation with mutable data that should be avoided\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\n// Compiles but don't work properly\nvar init = 0\n// init: Int = 0\nval counterRef = Ref.make(init)\n// counterRef: UIO[Ref[Int]] = zio.ZIO$EffectTotal@7a7980cf\n```\n\n----------------------------------------\n\nTITLE: Running ZIO Application with Runtime in Scala\nDESCRIPTION: Example of running a ZIO application using the ZIO Runtime system. This executes the ZIO effect and handles the results.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/contextual/has.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\nRuntime.default.unsafeRun(mainApp)\n```\n\n----------------------------------------\n\nTITLE: Adding ZIO AWS S3 dependency to build.sbt\nDESCRIPTION: SBT dependency configuration for integrating ZIO with AWS S3 using the zio-aws-s3 library.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/community.md#2025-04-23_snippet_28\n\nLANGUAGE: scala\nCODE:\n```\nlibraryDependencies += \"io.github.neurodyne\" %% \"zio-aws-s3\" % \"0.4.13\"\n```\n\n----------------------------------------\n\nTITLE: Pangram Example in Irish Gaelic (ga)\nDESCRIPTION: Provides an example pangram for the Irish Gaelic language.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n    D'fhuascail osa, rmhac na highe Beannaithe, pin dhaimh agus abha\n```\n\n----------------------------------------\n\nTITLE: Defining Directory Deletion Helper Function in Scala\nDESCRIPTION: A helper function that takes an optional string directory path and returns a Task[Unit]. This is used for cleanup operations in tests.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/test/aspects/before-after-around.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef deleteDir(dir: Option[String]): Task[Unit] = ZIO.attempt{\n  val _ = dir\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Timed ZStreams in Scala\nDESCRIPTION: Demonstrates how to create a ZStream that emits values at regular intervals using ZStream.tick.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/stream/zstream.md#2025-04-23_snippet_16\n\nLANGUAGE: scala\nCODE:\n```\nval stream: ZStream[Clock, Nothing, Unit] = \n  ZStream.tick(1.seconds)\n```\n\n----------------------------------------\n\nTITLE: Testing the Tracing Setup\nDESCRIPTION: Example curl command to test the distributed tracing setup by sending a request to the proxy server.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/resources/ecosystem/officials.md#2025-04-23_snippet_52\n\nLANGUAGE: scala\nCODE:\n```\ncurl -X GET http://0.0.0.0:8080/\n```\n\n----------------------------------------\n\nTITLE: Sequential State Transformation with Mutable Variables in Scala\nDESCRIPTION: Example showing a series of operations with a mutable state variable.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/state-management/state-management-using-recursion.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nvar state = 5\nstate = state + 1\nstate = state * 2\nstate = state * state\n\nprintln(state)\n// Output: 144\n```\n\n----------------------------------------\n\nTITLE: Creating SBT Properties File in Bash\nDESCRIPTION: Commands to create a directory for SBT properties and an empty properties file.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/run-our-first-zio-project-with-vscode.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmkdir project\ntouch project/build.properties\n```\n\n----------------------------------------\n\nTITLE: Pangram Examples in Japanese (jp)\nDESCRIPTION: Provides examples relevant to Japanese character sets: the Iroha poem in Hiragana (which uses each kana character exactly once) and a sequence of Katakana characters.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/streams-tests/jvm/src/test/resources/zio/stream/bom/quickbrown-UTF-16BE-with-BOM.txt#2025-04-23_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n    Hiragana: ( Iroha )\n\n    \n    \n    \n    \n```\n\nLANGUAGE: plaintext\nCODE:\n```\n    Katakana:\n\n         \n         \n```\n\n----------------------------------------\n\nTITLE: Creating Ref Constructor - Scala\nDESCRIPTION: The make constructor signature for creating new Ref instances that contain immutable values\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/concurrency/ref.md#2025-04-23_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\ndef make[A](a: A): UIO[Ref[A]]\n```\n\n----------------------------------------\n\nTITLE: Converting Chunk to Seq in Scala\nDESCRIPTION: Shows how to convert a Chunk to a Scala Seq using the toSeq method.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/misc/chunk.md#2025-04-23_snippet_14\n\nLANGUAGE: scala\nCODE:\n```\nChunk(1,2,3).toSeq\n```\n\n----------------------------------------\n\nTITLE: ZIO App Implementation Example\nDESCRIPTION: Example showing how to implement a ZIO App to run effects\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/reference/core/runtime.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nobject MyApp extends zio.App {\n  final def run(args: List[String]) =\n    myAppLogic.exitCode\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing Docker Images (Bash)\nDESCRIPTION: Command to list available Docker images in the local registry.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/tutorials/deploy-a-zio-application-using-docker.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ docker images\n```\n\n----------------------------------------\n\nTITLE: Creating TPriorityQueue with Custom Ordering in Scala ZIO\nDESCRIPTION: Shows how to create a TPriorityQueue with a reversed ordering for integers, effectively creating a max priority queue instead of the default min priority queue.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tpriorityqueue.md#2025-04-23_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\nval maxQueue: STM[Nothing, TPriorityQueue[Int]] =\n  TPriorityQueue.empty(Ordering[Int].reverse)\n```\n\n----------------------------------------\n\nTITLE: Creating Empty ConcurrentMap in ZIO\nDESCRIPTION: Shows how to create an empty ConcurrentMap using ConcurrentMap.empty\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/sync/concurrentmap.md#2025-04-23_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport zio.concurrent.ConcurrentMap\n\nval empty = ConcurrentMap.empty[String, Int]\n```\n\n----------------------------------------\n\nTITLE: Getting a List of Values from a TMap in ZIO STM\nDESCRIPTION: Extracts a List of values from a TMap using the values method. This provides access to all the values in the map as a List.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/stm/tmap.md#2025-04-23_snippet_21\n\nLANGUAGE: scala\nCODE:\n```\nimport zio._\nimport zio.stm._\n\nval tMapValuesList: UIO[List[Int]] = (for {\n  tMap <- TMap.make((\"a\", 1), (\"b\", 2), (\"c\", 3))\n  list <- tMap.values\n} yield list).commit\n```\n\n----------------------------------------\n\nTITLE: Illustrating Eager Evaluation Issue in ZIO 1.x Bracket (Scala)\nDESCRIPTION: Shows ZIO 1.x code using `ZIO.bracket` where a side effect (`scala.util.Random.nextInt()`) inside the `acquire` block is evaluated only once due to the by-value parameter. When combined with `repeatN(2)`, this leads to the same random number being printed multiple times, demonstrating an anti-pattern related to eager evaluation that ZIO 2.x aims to fix.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/guides/migrate/migration-guide.md#2025-04-23_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nZIO.bracket({\n  val random = scala.util.Random.nextInt()\n  ZIO.succeed(random)\n})(_ => ZIO.unit)(x => console.putStrLn(x.toString)).repeatN(2)\n```\n\n----------------------------------------\n\nTITLE: Extending Hub from Enqueue in Scala\nDESCRIPTION: Shows that Hub extends from Enqueue, allowing it to be used wherever an Enqueue is expected.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/reference/concurrency/hub.md#2025-04-23_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait Hub[A] extends Enqueue[A]\n```\n\n----------------------------------------\n\nTITLE: Cloning and Running the ZIO RESTful Web Service Quickstart - Bash\nDESCRIPTION: These commands clone the ZIO RESTful Web Service Quickstart repository and run the application using sbt. This is meant as a starting point for the tutorial, setting up the baseline non-configurable server.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/documentation/guides/tutorials/make-a-zio-app-configurable/docs/make-a-zio-application-configurable.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/zio/zio-quickstarts.git\ncd zio-quickstarts/zio-quickstart-restful-webservice\nsbt run\n```\n\n----------------------------------------\n\nTITLE: Checking Git Status in ZIO Project\nDESCRIPTION: Git command to check the status of your local repository. This shows modified files and untracked changes that need to be committed.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/docs/contributor-guidelines.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit status\n```\n\n----------------------------------------\n\nTITLE: Sequence-Specific Assertions\nDESCRIPTION: Assertion functions specifically for testing properties of Seq types like List and Vector.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/website/versioned_docs/version-1.0.18/guides/use-test-assertions.md#2025-04-23_snippet_7\n\nLANGUAGE: Scala\nCODE:\n```\nendsWith[A](suffix: Seq[A]): Assertion[Seq[A]]\nhasAt[A](pos: Int)(assertion: Assertion[A]): Assertion[Seq[A]]\nstartsWith[A](prefix: Seq[A]): Assertion[Seq[A]]\n```\n\n----------------------------------------\n\nTITLE: Formatting ZIO Code in SBT\nDESCRIPTION: SBT command to format the ZIO codebase according to project standards. This ensures consistent code style across the project.\nSOURCE: https://github.com/zio/zio/blob/series/2.x/CONTRIBUTING.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsbt fmt\n```"
  }
]