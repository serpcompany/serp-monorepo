[
  {
    "owner": "zheksoon",
    "repo": "dioma",
    "content": "TITLE: Basic Dependency Injection with Singleton and Transient Scopes (TypeScript)\nDESCRIPTION: Demonstrates the fundamental usage of Dioma for dependency injection. It defines a `Garage` class with a `Singleton` scope (one instance application-wide) and a `Car` class with a `Transient` scope (new instance per injection). The `inject` function is used to obtain instances, automatically handling dependencies like injecting `Garage` into `Car`'s constructor.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject, Scopes } from \"dioma\";\n\nclass Garage {\n  open() {\n    console.log(\"garage opened\");\n  }\n\n  // Single instance of the class for the entire application\n  static scope = Scopes.Singleton();\n}\n\nclass Car {\n  // injects instance of Garage\n  constructor(private garage = inject(Garage)) {}\n\n  park() {\n    this.garage.open();\n    console.log(\"car parked\");\n  }\n\n  // New instance of the class on every injection\n  static scope = Scopes.Transient();\n}\n\n// Creates a new Car and injects Garage\nconst car = inject(Car);\n\ncar.park();\n```\n\n----------------------------------------\n\nTITLE: Injecting Classes with Constructor Arguments (TypeScript)\nDESCRIPTION: Demonstrates passing arguments to a class constructor during dependency injection using Dioma. The `Pet` class, scoped as `Transient`, accepts a `name` argument in its constructor. When injecting `Pet` using `inject(Pet, \"Fluffy\")`, the string \"Fluffy\" is passed as the `name` argument. This feature is supported for `Transient` and `Resolution` scopes.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject, Scopes } from \"dioma\";\n\nclass Owner {\n  static scope = Scopes.Singleton();\n\n  petSomebody(pet: Pet) {\n    console.log(`${pet.name} petted`);\n  }\n}\n\nclass Pet {\n  constructor(public name: string, public owner = inject(Owner)) {}\n\n  pet() {\n    this.owner.petSomebody(this);\n  }\n\n  static scope = Scopes.Transient();\n}\n\nconst pet = inject(Pet, \"Fluffy\");\n\npet.pet(); // Fluffy petted\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Transient Scope Injection (TypeScript)\nDESCRIPTION: Illustrates the behavior of the `Transient` scope in Dioma. An `Engine` class is defined as a `Singleton`, while the `Vehicle` class is `Transient`. Each call to `inject(Vehicle)` creates a new `Vehicle` instance, but all created vehicles will share the same single `Engine` instance.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject, Scopes } from \"dioma\";\n\nclass Engine {\n  start() {\n    console.log(\"Engine started\");\n  }\n\n  static scope = Scopes.Singleton();\n}\n\nclass Vehicle {\n  constructor(private engine = inject(Engine)) {}\n\n  drive() {\n    this.engine.start();\n    console.log(\"Vehicle driving\");\n  }\n\n  static scope = Scopes.Transient();\n}\n\n// New vehicle every time\nconst vehicle = inject(Vehicle);\n\nvehicle.drive();\n```\n\n----------------------------------------\n\nTITLE: Using Container Scope with Custom Containers (TypeScript)\nDESCRIPTION: Shows how to use the `Container` scope for dependencies that should be singletons relative to a specific container instance. A custom `Container` is created. The `Garage` class, scoped as `Container`, is explicitly registered with this container using `container.register`. Injection is then performed using `container.inject` instead of the global `inject` function. `Car` remains `Transient`.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Container, Scopes } from \"dioma\";\n\nconst container = new Container();\n\nclass Garage {\n  open() {\n    console.log(\"garage opened\");\n  }\n\n  // Single instance of the class for the container\n  static scope = Scopes.Container();\n}\n\n// Register Garage on the container\ncontainer.register({ class: Garage });\n\nclass Car {\n  // Use inject method of the container for Garage\n  constructor(private garage = container.inject(Garage)) {}\n\n  park() {\n    this.garage.open();\n    console.log(\"car parked\");\n  }\n\n  // New instance on every injection\n  static scope = Scopes.Transient();\n}\n\nconst car = container.inject(Car);\n\ncar.park();\n```\n\n----------------------------------------\n\nTITLE: Ensuring Type Safety with Injectable Interface in Dioma (TypeScript)\nDESCRIPTION: Demonstrates leveraging TypeScript for type safety with Dioma. It shows how implementing the `Injectable` interface enforces the definition of a static `scope` property (e.g., `Scopes.Singleton()`) on classes intended for injection (`Database`). The example also highlights compile-time errors that occur if the `scope` is missing (`Repository`) or when trying to inject a class without a defined scope.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject, Scopes, Injectable } from \"dioma\";\n\n// Injectable interface makes sure the static scope is defined\nclass Database implements Injectable<typeof Database> {\n  constructor(private url: string) {}\n\n  connect() {\n    console.log(`Connected to ${this.url}`);\n  }\n\n  static scope = Scopes.Singleton();\n}\n\n// Error, scope is not specified\nclass Repository implements Injectable<typeof Repository> {\n  constructor(private db = inject(Database)) {}\n}\n\ninject(Repository); // Also type error, scope is not specified\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Resolution Scope Behavior (TypeScript)\nDESCRIPTION: Illustrates the `Resolution` scope, where a new instance is created for each resolution process, but the same instance is reused within that specific resolution chain. Both `Query` and `RequestHandler` use `Resolution` scope. When `RequestUser` (which is `Transient`) is injected, it gets instances of `RequestHandler` and `Query`. The example verifies that the `Query` instance injected directly into `RequestUser` is the same instance as the one injected into the `RequestHandler` dependency within the same `inject(RequestUser)` call.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject, Scopes } from \"dioma\";\n\nclass Query {\n  static scope = Scopes.Resolution();\n}\n\nclass RequestHandler {\n  constructor(public query = inject(Query)) {}\n\n  static scope = Scopes.Resolution();\n}\n\nclass RequestUser {\n  constructor(\n    public request = inject(RequestHandler),\n    public query = inject(Query)\n  ) {}\n\n  static scope = Scopes.Transient();\n}\n\nconst requestUser = inject(RequestUser);\n\n// The same instance of Query is used for each of them\nrequestUser.query === requestUser.request.query;\n```\n\n----------------------------------------\n\nTITLE: Registering and Unregistering Classes with Containers (TypeScript)\nDESCRIPTION: Explains how to explicitly register a class with a specific container, overriding the default 'sticky' behavior for `Container` scope. A `FooBar` class (`Container` scope) is registered with a parent `container`. Even when injected via a `child` container, the instance originates from and is cached in the parent `container`. The snippet also shows how to override the scope during registration and how to remove a registration using `container.unregister(FooBar)`.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst container = new Container();\n\nconst child = container.childContainer();\n\nclass FooBar {\n  static scope = Scopes.Container();\n}\n\n// Register the Foo class in the parent container\ncontainer.register({ class: FooBar });\n\n// Returns and cache the instance on parent container\nconst foo = container.inject(FooBar);\n\n// Returns the FooBar instance from the parent container\nconst bar = child.inject(FooBar);\n\nfoo === bar; // true\n```\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.register({ class: FooBar, scope: Scopes.Transient() });\n```\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.unregister(FooBar);\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Child Containers in Dioma (TypeScript)\nDESCRIPTION: Demonstrates how to create a child container from a parent container using `container.childContainer()`. It shows how classes registered in parent (`ParentClass`) and child (`ChildClass`) containers are resolved hierarchically using `child.inject()`, with Dioma searching top-down from the child to the root container. Instances are created in the container where the class was registered if not found during the search.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Container, Scopes } from \"dioma\";\n\nconst container = new Container(null, \"Parent\");\n\nconst child = container.childContainer(\"Child\");\n\nclass ParentClass {\n  static scope = Scopes.Container();\n}\n\nclass ChildClass {\n  static scope = Scopes.Container();\n}\n\ncontainer.register({ class: ParentClass });\n\nchild.register({ class: ChildClass });\n\n// Returns ParentClass instance from the parent container\nconst parentInstance = child.inject(ParentClass);\n\n// Returns ChildClass instance from the child container\nconst childInstance = child.inject(ChildClass);\n```\n\n----------------------------------------\n\nTITLE: Injecting Interface Implementations using Class Tokens (TypeScript)\nDESCRIPTION: Demonstrates using `Token` for injecting specific implementations of an interface (`IAnimal`). An `animalToken` is created. Different implementations (`Dog`, `Cat`) are registered with this token in different child containers (`wild`, `zoo`). Injecting the `animalToken` via `wild.inject(animalToken)` resolves to a `Dog` instance, while `zoo.inject(animalToken)` resolves to a `Cat` instance, respecting the container hierarchy and registrations.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Token, Scopes, globalContainer } from \"dioma\";\n\nconst wild = globalContainer.childContainer(\"Wild\");\n\nconst zoo = wild.childContainer(\"Zoo\");\n\ninterface IAnimal {\n  speak(): void;\n}\n\nclass Dog implements IAnimal {\n  speak() {\n    console.log(\"Woof\");\n  }\n\n  static scope = Scopes.Container();\n}\n\nclass Cat implements IAnimal {\n  speak() {\n    console.log(\"Meow\");\n  }\n\n  static scope = Scopes.Container();\n}\n\nconst animalToken = new Token<IAnimal>(\"Animal\");\n\n// Register Dog class with the token\nwild.register({ token: animalToken, class: Dog });\n\n// Register Cat class with the token\nzoo.register({ token: animalToken, class: Cat });\n\n// Returns Dog instance\nconst wildAnimal = wild.inject(animalToken);\n\n// Returns Cat instance\nconst zooAnimal = zoo.inject(animalToken);\n```\n\n----------------------------------------\n\nTITLE: Overriding Scope During Class Token Registration (TypeScript)\nDESCRIPTION: Shows how to override the default scope defined within a class when registering it using a class token. The `wild.register` call associates the `animalToken` with the `Dog` class but explicitly sets its scope to `Transient` for injections via this token in the `wild` container, overriding the `Scopes.Container` defined in the `Dog` class itself.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nwild.register({ token: animalToken, class: Dog, scope: Scopes.Transient() });\n```\n\n----------------------------------------\n\nTITLE: Injecting Constant Values using Value Tokens (TypeScript)\nDESCRIPTION: Illustrates how to inject simple constant values using Dioma tokens. A `Token<string>` is created and registered with a specific string value (`'Value'`) using `container.register({ token, value: 'Value' })`. Subsequent injections using `container.inject(token)` will resolve to this registered string value.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Token } from \"dioma\";\n\nconst token = new Token<string>(\"Value token\");\n\ncontainer.register({ token, value: \"Value\" });\n\nconst value = container.inject(token);\n\nconsole.log(value); // Value\n```\n\n----------------------------------------\n\nTITLE: Injecting Values via Factory Functions using Factory Tokens (TypeScript)\nDESCRIPTION: Demonstrates registering and injecting values produced by a factory function using Dioma tokens. A `Token<string>` is created and registered with a factory function `(container) => 'Value'` using `container.register({ token, factory: ... })`. When `container.inject(token)` is called, the factory function is executed, and its return value (`'Value'`) is injected. The factory receives the current container as an argument.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Token } from \"dioma\";\n\nconst token = new Token<string>(\"Factory token\");\n\ncontainer.register({ token, factory: (container) => \"Value\" });\n\nconst value = container.inject(token);\n\nconsole.log(value); // Value\n```\n\n----------------------------------------\n\nTITLE: Injecting Values via Factory Functions with Arguments (TypeScript)\nDESCRIPTION: Shows how to use factory tokens where the factory function accepts additional arguments passed during injection. A factory `(container, a: string, b): string => a + b` is registered with a token. When injecting using `container.inject(token, \"Hello, \", \"world!\")`, the additional arguments are passed to the factory function after the container argument, allowing dynamic value creation based on injection-time parameters.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst token = new Token<string>(\"Factory token\");\n\ncontainer.register({\n  token,\n  factory: (container, a: string, b): string => a + b,\n});\n\nconst value = container.inject(token, \"Hello, \", \"world!\");\n\nconsole.log(value); // Hello, world!\n```\n\n----------------------------------------\n\nTITLE: Using Tokens for Async Injection in Dioma (TypeScript)\nDESCRIPTION: Shows how to use a `Token` for asynchronous dependency injection with `injectAsync`. Class `B` asynchronously injects an instance associated with the `token` (representing class `A`), resolving the promise within the constructor similarly to direct class async injection. This demonstrates flexibility in identifying dependencies for async resolution.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Token, Scopes } from \"dioma\";\n\nconst token = new Token<A>(\"A\");\n\nclass B {\n  private declare instanceA: A;\n\n  // token in used for async injection\n  constructor(private promiseA = injectAsync(token)) {\n    this.promiseA.then((instance) => {\n      this.instanceA = instance;\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Circular Dependencies with Async Injection in Dioma (TypeScript)\nDESCRIPTION: Provides an example of a circular dependency between classes `A` and `B`. It demonstrates resolving this using `injectAsync`, which returns a Promise, allowing dependencies (`instanceA` in `B`) to be resolved asynchronously after the instance is constructed. It also shows the necessity of `globalContainer.waitAsync()` or waiting for the next tick to ensure all asynchronous injections are fully resolved before using the instances.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inject, injectAsync, Scopes } from \"dioma\";\n\nclass A {\n  constructor(private instanceB = inject(B)) {}\n\n  doWork() {\n    console.log(\"doing work A\");\n    this.instanceB.help();\n  }\n\n  static scope = Scopes.Singleton();\n}\n\nclass B {\n  private declare instanceA: A;\n\n  // injectAsync returns a promise of the A instance\n  constructor(private promiseA = injectAsync(A)) {\n    this.promiseA.then((instance) => {\n      this.instanceA = instance;\n    });\n  }\n\n  help() {\n    console.log(\"helping with work\");\n  }\n\n  doAnotherWork() {\n    console.log(\"doing work B\");\n    this.instanceA.doWork();\n  }\n\n  static scope = Scopes.Singleton();\n}\n\nconst a = await injectAsync(A);\nconst b = await injectAsync(B);\n\n// Wait until all promises are resolved\nawait globalContainer.waitAsync();\n\na.doWork();\nb.doAnotherWork();\n```\n\n----------------------------------------\n\nTITLE: Using Injection Hooks (beforeInject, beforeCreate) in Dioma (TypeScript)\nDESCRIPTION: Illustrates how to define `beforeInject` and `beforeCreate` lifecycle hooks when registering a class using `container.register()`. These hooks allow executing custom logic with access to the container, descriptor, and arguments before an instance is injected or created, respectively.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.register({\n  class: MyClass,\n  beforeInject: (container, descriptor, args) => {\n    console.log(\"Before inject\");\n  },\n  beforeCreate: (container, descriptor, args) => {\n    console.log(\"Before create\");\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Dioma Library using Package Managers (Shell)\nDESCRIPTION: Provides commands to install the 'dioma' dependency injection library using either npm or yarn package managers.\nSOURCE: https://github.com/zheksoon/dioma/blob/main/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install --save dioma\n\nyarn add dioma\n```"
  }
]