[
  {
    "owner": "everweij",
    "repo": "typescript-result",
    "content": "TITLE: Reading and Validating JSON Config File with Result Type\nDESCRIPTION: Example demonstrating how to use the Result type to handle file operations, JSON parsing, and data validation with proper error handling. This shows the complete flow from reading a file to processing its contents safely.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Result } from \"typescript-result\";\nimport fs from \"node:fs/promises\";\n\nclass IOError extends Error {\n  readonly type = \"io-error\";\n}\n\nclass ParseError extends Error {\n  readonly type = \"parse-error\";\n}\n\nclass ValidationError extends Error {\n  readonly type = \"validation-error\";\n}\n\nfunction readFile(path: string) {\n  return Result.try(\n    () => fs.readFile(path, \"utf-8\"),\n    (error) => new IOError(`Unable to read file '${path}'`, { cause: error })\n  );\n}\n\nconst isObject = (value: unknown): value is Record<string, unknown> =>\n  typeof value === \"object\" && value !== null;\n\nconst isString = (value: unknown): value is string => typeof value === \"string\";\n\nfunction getConfig(value: unknown) {\n  if (!isObject(value)) {\n    return Result.error(new ValidationError(\"Invalid config file\"));\n  }\n  if (!value.name || !isString(value.name)) {\n    return Result.error(new ValidationError(\"Missing or invalid 'name' field\"));\n  }\n  if (!value.version || !isString(value.version)) {\n    return Result.error(\n      new ValidationError(\"Missing or invalid 'version' field\")\n    );\n  }\n\n  return Result.ok({ name: value.name, version: value.version });\n}\n\nconst message = await readFile(\"./config.json\")\n  .mapCatching(\n    (contents) => JSON.parse(contents),\n    (error) => new ParseError(\"Unable to parse JSON\", { cause: error })\n  )\n  .map((json) => getConfig(json))\n  .fold(\n    (config) =>\n      `Successfully read config: name => ${config.name}, version => ${config.version}`,\n\n    (error) => {\n      switch (error.type) {\n        case \"io-error\":\n          return \"Please check if the config file exists and is readable\";\n        case \"parse-error\":\n          return \"Please check if the config file contains valid JSON\";\n        case \"validation-error\":\n          return error.message;\n      }\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: Fluent API Pattern with Result Type for Async Operations\nDESCRIPTION: Example showing how to use the fluent API pattern with Result type to simplify async operation chains, avoiding nested conditionals and improving code readability.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = await Result.fromAsync(someAsyncFunction1())\n  .map((value) => someAsyncFunction2(value))\n  .map((value) => someAsyncFunction3(value))\n  .fold(\n    (value) => {\n      // do something on success\n    },\n    (error) => {\n      // handle error\n    }\n  );\n```\n\n----------------------------------------\n\nTITLE: Using Result.try for Error Handling in File Operations\nDESCRIPTION: This snippet demonstrates how to use Result.try to handle potential errors in file operations. It shows both a traditional try-catch approach and the Result.try method for comparison.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// Using try-catch\nlet result: Result<void, Error>;\ntry {\n  fs.writeFileSync(\"file.txt\", \"Hello, World!\", \"utf-8\");\n  result = Result.ok();\n} catch (error) {\n  result = Result.error(error);\n}\n\n// Using Result.try\nconst result = Result.try(() => fs.writeFileSync(\"file.txt\", \"Hello, World!\", \"utf-8\"));\n```\n\n----------------------------------------\n\nTITLE: Chaining Operations on Results in TypeScript\nDESCRIPTION: This snippet compares traditional error handling with chained operations using the Result type. It demonstrates how chaining can lead to more concise and readable code when dealing with multiple operations that may fail.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Without chaining\nconst resultA = someOperation();\nif (resultA.isOk()) {\n  const resultB = anotherOperation(resultA.value);\n  if (resultB.isOk()) {\n    const resultC = yetAnotherOperation(resultB.value);\n    if (resultC.isOk()) {\n      // do something\n    } else {\n      // handle error\n    }\n  } else {\n    // handle error\n  }\n} else {\n  // handle error\n}\n\n// With chaining\nconst result = someOperation()\n  .map((value) => anotherOperation(value))\n  .map((value) => yetAnotherOperation(value))\n\nif (result.isOk()) {\n  // do something\n} else {\n  // handle error\n}\n```\n\n----------------------------------------\n\nTITLE: Async Operations with Result Type and Type Inference\nDESCRIPTION: Example demonstrating automatic conversion between Result and AsyncResult types, showing how the library handles promises and maintains type safety throughout the chain of operations.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// start with a sync value -> Result<number, never>\nconst result = await Result.ok(12)\n  // map the value to a Promise -> AsyncResult<number, never>\n  .map((value) => Promise.resolve(value * 2)) // \n  // map async to another result -> AsyncResult<string, ValidationError>\n  .map(async (value) => {\n    if (value < 10) {\n      return Result.error(new ValidationError(\"Value is too low\"));\n    }\n\n    return Result.ok(\"All good!\");\n  })\n  // unwrap the result -> Promise<string>;\n  .getOrElse((error) => error.message);\n```\n\n----------------------------------------\n\nTITLE: Creating a Result for Division Operation\nDESCRIPTION: This snippet shows how to create a Result using Result.ok and Result.error methods. It demonstrates error handling for a division operation, returning either the result or a DivisionByZeroError.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nfunction divide(a: number, b: number) {\n  if (b === 0) {\n    return Result.error(new DivisionByZeroError(`Cannot divide ${a} by zero`));\n  }\n\n  return Result.ok(a / b);\n}\n```\n\n----------------------------------------\n\nTITLE: Traditional Error Handling vs Result Type Pattern\nDESCRIPTION: Comparison showing how the Result type can improve code readability by avoiding nested conditional checks. This example illustrates the traditional approach with multiple nested if-statements.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst firstAsyncResult = await someAsyncFunction1();\nif (firstAsyncResult.isOk()) {\n  const secondAsyncResult = await someAsyncFunction2(firstAsyncResult.value);\n  if (secondAsyncResult.isOk()) {\n    const thirdAsyncResult = await someAsyncFunction3(secondAsyncResult.value);\n    if (thirdAsyncResult.isOk()) {\n      // do something\n    } else {\n      // handle error\n    }\n  } else {\n    // handle error\n  }\n} else {\n  // handle error\n}\n```\n\n----------------------------------------\n\nTITLE: Type Safety Enforcement with Result Type in Order Processing\nDESCRIPTION: Example showing how the TypeScript compiler enforces complete error handling when using the Result type, highlighting a case where a switch statement doesn't handle all possible error types.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass NotEnoughStockError extends Error {\n  readonly type = \"not-enough-stock\";\n}\n\nclass InsufficientBalanceError extends Error {\n  readonly type = \"insufficient-balance\";\n}\n\nfunction order(basket: Basket, stock: Stock, account: Account) {\n  if (basket.getTotalPrice() > account.balance) {\n    return Result.error(new InsufficientBalanceError());\n  }\n\n  if (!stock.hasEnoughStock(basket.getProducts())) {\n    return Result.error(new NotEnoughStockError());\n  }\n\n  const order: Order = { /* skipped for brevity */ }\n\n  return Result.ok(order);\n}\n\nfunction handleOrder(products: Product[], userId: number) {\n  /* skipped for brevity  */\n\n  return order(basket, stock, account).fold(\n    () => ({\n      status: 200,\n      body: \"Order placed successfully\",\n    }),\n    (error) => { // TS-Error: Not all code paths return a value\n      switch(error.type) {\n        case \"insufficient-balance\":\n          return {\n            status: 400,\n            body: \"Insufficient balance\",\n          }\n      }\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Web API with Result Type\nDESCRIPTION: Example of handling different error types in a web API route using Result type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nfunction handleRoute(id: number) {\n  const [value, error] = performOperation(id).toTuple();\n\n  if (error) {\n    switch (error.type) {\n      case \"not-found\":\n        return {\n          status: 404,\n          body: \"Not found\",\n        };\n      case \"unauthorized\":\n        return {\n          status: 401,\n          body: \"Unauthorized\",\n        };\n      default:\n        return {\n          status: 500,\n          body: \"Internal server error\",\n        };\n    }\n  }\n\n  return {\n    status: 200,\n    body: value,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Recovery with recover Method in TypeScript\nDESCRIPTION: Demonstrates using the recover method to handle failure cases by providing a fallback operation. This example shows falling back to local persistence when database persistence fails.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_63\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function persistInDB(item: Item): AsyncResult<Item, DbError>;\ndeclare function persistLocally(item: Item): AsyncResult<Item, IOError>;\n\npersistInDB(item).recover(() => persistLocally(item)); // AsyncResult<Item, IOError>\n```\n\n----------------------------------------\n\nTITLE: Using Result.try for Exception Handling\nDESCRIPTION: Demonstrates how to use Result.try to execute a function that might throw exceptions and encapsulate the result. This provides a try-catch block that returns a Result instance.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function saveFileToDisk(filename: string): void; // might throw an error\n\nconst result = Result.try(() => saveFileToDisk(\"file.txt\")); // Result<void, Error>\n```\n\n----------------------------------------\n\nTITLE: Error Recovery with Result Type in TypeScript\nDESCRIPTION: Example of using recover to implement fallback behavior when a database operation fails.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nfunction persistInDB(item: Item): Result<Item, DbError> {\n  // implementation\n};\nfunction persistLocally(item: Item): Result<Item, IOError> {\n  // implementation\n};\n\npersistInDB(item).recover(() => persistLocally(item)); // Result<Item, IOError>\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Results with Result.all Method\nDESCRIPTION: Demonstrates how to combine multiple independent Result operations into a single Result using the Result.all method, which returns success only if all operations succeed.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function createTask(name: string): Result<Task, IOError>;\n\nconst tasks = [\"task-a\", \"task-b\", \"task-c\"];\nconst result = Result.all(...tasks.map(createTask)); // Result<Task[], IOError>\n```\n\n----------------------------------------\n\nTITLE: Wrapping Functions with Result.wrap\nDESCRIPTION: Shows how to use Result.wrap to convert a function that might throw exceptions into one that returns a Result. This is useful for safely handling operations from external libraries.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function divide(a: number, b: number): number;\n\nconst safeDivide = Result.wrap(divide);\nconst result = safeDivide(10, 0); // Result<number, Error>\n```\n\n----------------------------------------\n\nTITLE: Type Guards with Result Type in TypeScript\nDESCRIPTION: Demonstrates using isOk and isError type guards for type narrowing with Result type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nif (result.isOk()) {\n  // TS infers that result.value is defined\n  console.log(result.value);\n} else if (result.isError()) {\n  // TS infers that result.error is defined\n  console.error(result.error);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Result.wrap for Function Error Handling\nDESCRIPTION: This snippet demonstrates the use of Result.wrap to create a new function that returns a Result. It wraps the fs.writeFileSync function to handle potential errors safely.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nconst safeWriteFile = Result.wrap(fs.writeFileSync);\n\nconst result = safeWriteFile(\"file.txt\", \"Hello, World!\", \"utf-8\"); // Result<void, Error>\n```\n\n----------------------------------------\n\nTITLE: Functional Result Handling with fold in TypeScript\nDESCRIPTION: Shows how to use the fold method for handling Result types in a functional way with route handling example.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nfunction handleRoute(id: number) {\n  return performOperation(id).fold(\n    (value) => ({\n      status: 200,\n      body: value,\n    }),\n    (error) => {\n      switch (error.type) {\n        case \"not-found\":\n          return {\n            status: 404,\n            body: \"Not found\",\n          };\n        case \"unauthorized\":\n          return {\n            status: 401,\n            body: \"Unauthorized\",\n          };\n        default:\n          return {\n            status: 500,\n            body: \"Internal server error\",\n          };\n      }\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Response Objects with AsyncResult.fold\nDESCRIPTION: Example of using the fold method to transform a result into a response-like object, handling different error types appropriately in a web application context.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_54\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<User, NotFoundError | UserDeactivatedError>;\n\nconst response = await result.fold(\n  (user) => ({ status: 200, body: user }),\n  (error) => {\n    switch (error.type) {\n      case \"not-found\":\n        return { status: 404, body: \"User not found\" };\n      case \"user-deactivated\":\n        return { status: 403, body: \"User is deactivated\" };\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Obtaining Value or Throwing Error in TypeScript Result\nDESCRIPTION: Demonstrates the use of getOrThrow method to retrieve the value of a Result or throw an error if it's a failure.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nconst value = result.getOrThrow(); // number\n```\n\n----------------------------------------\n\nTITLE: Transforming Results with mapCatching in TypeScript\nDESCRIPTION: Demonstrates error handling with mapCatching to transform file contents while providing custom error handling for exceptions.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nreadFile(\"source.txt\")\n  .mapCatching(\n    (contents) => writeFile(\"destination.txt\", contents.toUpperCase()),\n    (error) => new IOError(\"Failed to write file\", { cause: error })\n  )\n```\n\n----------------------------------------\n\nTITLE: Converting Promises to AsyncResult with Result.fromAsync\nDESCRIPTION: Example showing how to use Result.fromAsync to transform a Promise into an AsyncResult instance. This is useful for immediately chaining operations after an async function call.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function someAsyncOperation(): Promise<Result<number, Error>>;\n\n// without 'Result.fromAsync'\nconst result = (await someAsyncOperation()).map((value) => value 2); // Result<number, Error>\n\n// with 'Result.fromAsync'\nconst asyncResult = Result.fromAsync(someAsyncOperation()).map((value) => value 2); // AsyncResult<number, Error>\n```\n\n----------------------------------------\n\nTITLE: Using Async Callback with onSuccess Method in TypeScript\nDESCRIPTION: Demonstrates using an async callback with the onSuccess method. The example shows how to await the result when performing asynchronous operations within the success handler.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_57\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResultResult<number, Error>;\n\nconst asyncResult = await result.onSuccess(async (value) => someAsyncOperation(value));\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Result.all with Task Creation\nDESCRIPTION: Demonstrates how to use Result.all to combine multiple task creation operations into a single result. This method will combine all successful results into an array, but will fail if any operation fails.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function createTask(name: string): Result<Task, IOError>;\n\nconst tasks = [\"task-a\", \"task-b\", \"task-c\"];\nconst result = Result.all(...tasks.map(createTask)); // Result<Task[], IOError>\n```\n\n----------------------------------------\n\nTITLE: Transforming Errors with Result.try in TypeScript\nDESCRIPTION: This snippet shows how to use Result.try with a custom error transformation function. It demonstrates wrapping a file write operation and converting any caught errors into a custom IOError type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = Result.try(\n\t() => fs.writeFileSync(\"file.txt\", \"Hello, World!\", \"utf-8\"),\n\t(error) => new IOError(\"Failed to save file\", { cause: error }),\n);\n```\n\n----------------------------------------\n\nTITLE: Transforming Errors with mapError Method in TypeScript\nDESCRIPTION: Shows how to transform error types using the mapError method. This is useful for converting error types or adding context to errors, particularly when working with external APIs.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_62\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = Result.try(() => fetch(\"https://example.com\"))\n  .mapCatching((response) => response.json() as Promise<Data>)\n  .mapError((error) => new FetchDataError(\"Failed to fetch data\", { cause: error }));\n  // AsyncResult<Data, FetchDataError>;\n```\n\n----------------------------------------\n\nTITLE: Handling Custom Error Types with Exhaustive Checks in TypeScript\nDESCRIPTION: Demonstrates how to handle different error types using switch statements with TypeScript's noImplicitReturns compiler option to ensure exhaustive checking of error types.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nclass ErrorA extends Error {\n  readonly type = \"error-a\";\n}\n\nclass ErrorB extends Error {\n  readonly type = \"error-b\";\n}\n\ndeclare const result: Result<number, ErrorA | ErrorB>;\n\nresult.fold(\n  (value) => /* do something */,\n  (error) => { // TS-Error: Not all code paths return a value\n    switch (error.type) {\n      case \"error-a\":\n        return /* something */;\n    }\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Result Destructuring with toTuple in TypeScript\nDESCRIPTION: Shows how to destructure and handle Result values using toTuple with TypeScript type narrowing.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, IOError>;\n\nconst [value, error] = result.toTuple();\n\nif (value) {\n  // at this point the value must be a number\n} else {\n  // error must be an instance of IOError\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Value in TypeScript Result\nDESCRIPTION: Shows how to use the map method to transform the value of a successful Result.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nconst transformed = result.map((value) => value * 2); // Result<number, Error>\n```\n\n----------------------------------------\n\nTITLE: Converting Promises to AsyncResult for Easier Chaining\nDESCRIPTION: Shows how to convert a Promise containing a Result to an AsyncResult using the fromAsync method, allowing for easier chaining of operations without frequent awaits.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\nasync function someAsyncOperation(): Promise<Result<number, Error>> {\n  return Result.ok(42);\n}\n\nconst result = await Result.fromAsync(someAsyncOperation())\n  .map((value) => value * 2)\n  // etc...\n```\n\n----------------------------------------\n\nTITLE: Error Mapping with Result Type in TypeScript\nDESCRIPTION: Shows how to transform and enhance errors using mapError while handling file operations.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nResult.try(() => fs.readFileSync(\"source.txt\", \"utf-8\"))\n  .mapCatching(contents => fs.writeFileSync(\"destination.txt\", contents.toUpperCase(), \"utf-8\"))\n  .mapError((error) => new IOError(\"Failed to transform file\", { cause: error }));\n  // Result<void, IOError>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Default Values with AsyncResult.getOrDefault\nDESCRIPTION: Examples of using getOrDefault method to obtain the value from a successful result or a default value if the result is a failure. Shows both same-type and different-type default values.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nconst value = await result.getOrDefault(0); // number\n```\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nconst value = await result.getOrDefault(\"default\"); // number | string\n```\n\n----------------------------------------\n\nTITLE: Folding Result to Response Object in TypeScript\nDESCRIPTION: Shows how to use the fold method to transform a Result into a response-like object based on success or failure.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<User, NotFoundError | UserDeactivatedError>;\n\nconst response = result.fold(\n  (user) => ({ status: 200, body: user }),\n  (error) => {\n    switch (error.type) {\n      case \"not-found\":\n        return { status: 404, body: \"User not found\" };\n      case \"user-deactivated\":\n        return { status: 403, body: \"User is deactivated\" };\n    }\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Result Transformation Patterns in TypeScript\nDESCRIPTION: Shows different ways to transform Result types using map operations, including synchronous and asynchronous transformations.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nsomeOperation() // Result<number, Error>\n  .map((value) => value * 2) // Result<number, Error> \n  .map((value) => Result.ok(value * 2)) // Result<number, Error>\n  .map((value) => Promise.resolve(value * 2)) // AsyncResult<number, Error>;\n  .map(async (value) => value * 2) // AsyncResult<number, Error>;\n  .map(async (value) => Result.ok(value * 2)) // AsyncResult<number, Error>;\n```\n\n----------------------------------------\n\nTITLE: Returning AsyncResult Instance from map Method in TypeScript\nDESCRIPTION: Demonstrates returning an AsyncResult instance from the map method. This allows for chaining asynchronous operations that return AsyncResult instances while maintaining proper error handling.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_61\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\ndeclare function storeValue(value: number): AsyncResult<boolean, Error>;\n\nconst transformed = result.map((value) => storeValue(value)); // AsyncResult<boolean, Error>\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Operations with Result.all\nDESCRIPTION: Example showing how Result.all can handle different types of inputs including literals, Promises, Result instances, and functions. The result combines all successful values into a tuple.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = Result.all(\n  \"a\",\n  Promise.resolve(\"b\"),\n  Result.ok(\"c\"),\n  Result.try(async () => \"d\"),\n  () => \"e\",\n  () => Result.try(async () => \"f\"),\n  () => Result.ok(\"g\"),\n  async () => \"h\",\n); // AsyncResult<[string, string, string, string, string, string, string, string], Error>\n```\n\n----------------------------------------\n\nTITLE: Error Transformation with Result.try\nDESCRIPTION: Shows how to use Result.try with a transform function to convert generic errors into more specific error types. This helps create more meaningful error objects.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function saveFileToDisk(filename: string): void; // might throw an error\n\nconst result = Result.try(\n  () => saveFileToDisk(\"file.txt\"),\n  (error) => new IOError(\"Failed to save file\", { cause: error })\n); // Result<void, IOError>\n```\n\n----------------------------------------\n\nTITLE: Creating Successful Result in TypeScript\nDESCRIPTION: Shows how to create a new Result instance representing a successful outcome using the ok static method.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = Result.ok(42); // Result<number, never>\n```\n\n----------------------------------------\n\nTITLE: Side Effects with Result Type in TypeScript\nDESCRIPTION: Demonstrates handling side effects using onSuccess and onFailure callbacks without modifying the result.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nsomeOperation()\n  .onSuccess((value) => console.log(\"Operation succeeded with value\", value))\n  .onFailure((error) => console.error(\"Operation failed with error\", error));\n```\n\n----------------------------------------\n\nTITLE: Improving Error Type Inference with Discriminant Fields\nDESCRIPTION: This snippet demonstrates how to improve TypeScript's error type inference by adding a discriminant field to custom Error classes. This allows TypeScript to distinguish between different error types.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nclass ErrorA extends Error {\n  readonly type = \"error-a\";\n}\nclass ErrorB extends Error {\n  readonly type = \"error-b\";\n}\n\nfunction example() {\n  if (condition) {\n    return Result.error(new ErrorA());\n  }\n\n  return Result.error(new ErrorB());\n}\n\nconst result = example();\nif (result.isError()) {\n  console.error(result.error); // ErrorA | ErrorB\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Exhaustive Checking with Never Type in TypeScript\nDESCRIPTION: Shows how to perform manual exhaustive type checking using the never type in TypeScript to ensure all error types are handled properly in if-else statements.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nclass ErrorA extends Error {\n  readonly type = \"error-a\";\n}\n\nclass ErrorB extends Error {\n  readonly type = \"error-b\";\n}\n\ndeclare const result: Result<number, ErrorA | ErrorB>;\n\nif (result.isError()) {\n  const error = result.error;\n  if (error.type === \"error-a\") {\n    // handle error-a\n  } else if (error.type === \"error-b\") {\n    // handle error-b\n  } else {\n    error satisfies never;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Success Values with map Method in TypeScript\nDESCRIPTION: Shows how to transform the value of a successful result using the map method. The method applies a transformation function to the value when the result is successful, and returns a new AsyncResult instance with the transformed value.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_58\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nconst transformed = result.map((value) => value 2); // AsyncResult<number, Error>\n```\n\n----------------------------------------\n\nTITLE: Extracting Value or Throwing with AsyncResult.getOrThrow\nDESCRIPTION: Shows how to use getOrThrow to extract the value from a successful result or throw the encapsulated error if the result is a failure.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nconst value = await result.getOrThrow(); // number\n```\n\n----------------------------------------\n\nTITLE: Returning Result Instance in map Method\nDESCRIPTION: Demonstrates returning a Result instance from the map method's callback function.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\ndeclare function multiplyByTwo(value: number): Result<number, Error>;\n\nconst transformed = result.map((value) => multiplyByTwo(value)); // Result<number, Error>\n```\n\n----------------------------------------\n\nTITLE: Type Narrowing with AsyncResult.toTuple\nDESCRIPTION: Demonstrates how to use the toTuple method of AsyncResult to destructure the result and leverage TypeScript's type narrowing capabilities for better type safety.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, ErrorA>;\n\nconst [value, error] = result.toTuple();\n\nif (error) {\n  // error is ErrorA\n} else {\n  // at this point the value must be a number\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Result Instance from map Method in TypeScript\nDESCRIPTION: Demonstrates how the map method can return another Result instance, which will be returned as-is. This example shows how to chain Result operations while preserving the error types.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_59\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\ndeclare function multiplyByTwo(value: number): Result<number, Error>;\n\nconst transformed = result.map((value) => multiplyByTwo(value)); // AsyncResult<number, Error>\n```\n\n----------------------------------------\n\nTITLE: AsyncResult Declaration\nDESCRIPTION: Class declaration for AsyncResult which represents the asynchronous outcome of an operation that can either succeed or fail. It provides a generic type for both the success value and error type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nclass AsyncResult<Value, Error> {}\n```\n\n----------------------------------------\n\nTITLE: Using assertUnreachable Utility for Exhaustive Error Checking\nDESCRIPTION: Demonstrates the use of the assertUnreachable utility function from the typescript-result library to ensure all error cases are handled at compile time and runtime.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\nimport { assertUnreachable } from \"typescript-result\";\n\nif (result.isError()) {\n  const error = result.error;\n  if (error.type === \"error-a\") {\n    // handle error-a\n  } else if (error.type === \"error-b\") {\n    // handle error-b\n  } else {\n    assertUnreachable(error)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Error Recovery in TypeScript Result Chain\nDESCRIPTION: Demonstrates using the recover method to transform a failed Result into a successful one, changing the error type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare function persistInDB(item: Item): Result<Item, DbError>;\ndeclare function persistLocally(item: Item): Result<Item, IOError>;\n\npersistInDB(item).recover(() => persistLocally(item)); // Result<Item, IOError>\n```\n\n----------------------------------------\n\nTITLE: Using Async Transformation with map Method in TypeScript\nDESCRIPTION: Shows how to perform asynchronous transformations with the map method. The map method can accept async functions that return promises, and will properly handle the asynchronous operation.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_60\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nconst transformed = result.map(async (value) => value 2); // AsyncResult<number, Error>\n```\n\n----------------------------------------\n\nTITLE: Adding Logging on Failure with onFailure Method in TypeScript\nDESCRIPTION: Demonstrates how to use the onFailure method to add logging when a result represents a failure. The method takes a callback that runs only when the result is a failure, and returns the original result instance to allow method chaining.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_55\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nresult\n  .onFailure((error) => console.error(\"I'm failing!\", error))\n  .map((value) => value 2); // proceed with other operations\n```\n\n----------------------------------------\n\nTITLE: Adding Logging on Success with onSuccess Method in TypeScript\nDESCRIPTION: Shows how to use the onSuccess method to add logging when a result represents a success. The method takes a callback that runs only when the result is successful, and returns the original result instance for chaining.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_56\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nresult\n  .onSuccess((value) => console.log(\"I'm a success!\", value))\n  .map((value) => value 2); // proceed with other operations\n```\n\n----------------------------------------\n\nTITLE: Transforming Errors with AsyncResult.getOrElse\nDESCRIPTION: Examples of using getOrElse to transform errors into valid values. Shows both synchronous and asynchronous error handling callbacks.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: AsyncResult<number, Error>;\n\nconst value = await result.getOrElse((error) => 0); // number\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst value = await result.getOrElse(async (error) => 0); // number\n```\n\n----------------------------------------\n\nTITLE: Transforming Error in TypeScript Result\nDESCRIPTION: Shows how to use the mapError method to transform the error of a failed Result into a different error type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nresult.mapError((error) => new ErrorB(error.message)); // Result<number, ErrorB>\n```\n\n----------------------------------------\n\nTITLE: Transforming Error to Value in TypeScript Result\nDESCRIPTION: Demonstrates how to use the getOrElse method to transform an error into a default value when working with a Result type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nconst value = result.getOrElse((error) => 0); // number\n```\n\n----------------------------------------\n\nTITLE: Logging on Failure in TypeScript Result Chain\nDESCRIPTION: Demonstrates using onFailure method for logging errors between operations in a Result chain.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nresult\n  .onFailure((error) => console.error(\"I'm failing!\", error))\n  .map((value) => value * 2); // proceed with other operations\n```\n\n----------------------------------------\n\nTITLE: Logging on Success in TypeScript Result Chain\nDESCRIPTION: Shows how to use onSuccess method for logging successful values between operations in a Result chain.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nresult\n  .onSuccess((value) => console.log(\"I'm a success!\", value))\n  .map((value) => value * 2); // proceed with other operations\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Type Inference in TypeScript Result\nDESCRIPTION: This snippet shows how TypeScript infers error types when using custom Error classes with the Result type. It illustrates a limitation where TypeScript unifies similar error types.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nclass ErrorA extends Error {}\nclass ErrorB extends Error {}\n\nfunction example() {\n  if (condition) {\n    return Result.error(new ErrorA());\n  }\n\n  return Result.error(new ErrorB());\n}\n\nconst result = example();\nif (result.isError()) {\n  // TypeScript infers that result.error is of type Error, and not ErrorA | ErrorB\n  console.error(result.error);\n}\n```\n\n----------------------------------------\n\nTITLE: Async Transformation in TypeScript Result\nDESCRIPTION: Shows how to perform an async transformation using the map method, returning an AsyncResult.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nconst transformed = result.map(async (value) => value * 2); // AsyncResult<number, Error>\n```\n\n----------------------------------------\n\nTITLE: Returning AsyncResult in map Method\nDESCRIPTION: Demonstrates returning an AsyncResult instance from the map method's callback function.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\ndeclare function storeValue(value: number): AsyncResult<boolean, Error>;\n\nconst transformed = result.map((value) => storeValue(value)); // AsyncResult<boolean, Error>\n```\n\n----------------------------------------\n\nTITLE: Using Async Callback with onSuccess in TypeScript Result\nDESCRIPTION: Demonstrates using an async callback with the onSuccess method, returning an AsyncResult.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare const result: Result<number, Error>;\n\nconst asyncResult = await result.onSuccess(async (value) => someAsyncOperation(value));\n```\n\n----------------------------------------\n\nTITLE: Using Async Callback with getOrElse in TypeScript Result\nDESCRIPTION: Shows how to use an async callback with the getOrElse method, returning a Promise of the result type.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\nconst value = await result.getOrElse(async (error) => 0); // Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Creating Failed Result in TypeScript\nDESCRIPTION: Demonstrates creating a new Result instance representing a failed outcome using the error static method.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = Result.error(new NotFoundError()); // Result<never, NotFoundError>\n```\n\n----------------------------------------\n\nTITLE: Configuring tsconfig.json for TypeScript Result\nDESCRIPTION: Required TypeScript configuration to enable strict type checking, which is necessary for the typescript-result library to function properly.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript Result Library with npm\nDESCRIPTION: Command to install the typescript-result library using npm package manager.\nSOURCE: https://github.com/everweij/typescript-result/blob/master/readme.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install typescript-result\n```"
  }
]