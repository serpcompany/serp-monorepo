[
  {
    "owner": "ivy-llc",
    "repo": "ivy",
    "content": "TITLE: PyTorch to TensorFlow Model Translation Example\nDESCRIPTION: Demonstrates how to use the ivy.transpile() function to convert a PyTorch model to TensorFlow. The example shows a simple linear model conversion with source and target framework specifications.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/README.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport torch\n\ndef torch_model(x):\n    return torch.nn.functional.linear(10, 5)(x)\n\n# Convert PyTorch model to TensorFlow\ntf_model = ivy.transpile(\n    torch_model,\n    source=\"torch\", \n    target=\"tensorflow\",\n    output_dir=\"transpiled_models\"\n)\n```\n\n----------------------------------------\n\nTITLE: Complete Usage Example of Graph Tracer with Ivy and PyTorch\nDESCRIPTION: A comprehensive example showing how to use the Graph Tracer to compile a function with multiple operations, and demonstrating the significant performance improvement achieved through compilation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/README.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nfrom tracer.tracer import trace_graph\nivy.set_backend(\"torch\")\n\n# Define a function with multiple operations\ndef fn(x):\n    y = ivy.sum(x)\n    z = ivy.prod(x)\n    a = ivy.sin(y)\n    b = ivy.cos(z)\n    c = ivy.tan(z)\n    i = ivy.round(a)\n    j = ivy.floor(b)\n    k = ivy.ceil(c)\n    return i, j, k\n\n# Compile the function\nx = ivy.array([1.])\ncomp_fn = trace_graph(fn, args=(x,), to=\"torch\")\n\n# Compare performance\nimport time\n\n# Original function\nstart = time.time()\nfn(x)\nprint(f\"Original: {time.time() - start:.4f}s\")  # ~0.4957s\n\n# Compiled function\nstart = time.time()\ncomp_fn(x)\nprint(f\"Compiled: {time.time() - start:.4f}s\")  # ~0.0006s\n```\n\n----------------------------------------\n\nTITLE: Numpy matrix any method implementation\nDESCRIPTION: Implementation of the any method for numpy.matrix class in Ivy's frontend.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef any(self, axis=None, out=None):\n    if ivy.exists(axis):\n        return any(self.A, axis=axis, keepdims=True, out=out)\n    return any(self.A, axis=axis, out=out)\n```\n\n----------------------------------------\n\nTITLE: Transpiling PyTorch code to TensorFlow\nDESCRIPTION: Example of using Ivy to transpile a PyTorch function to TensorFlow. The function performs multiplication and mean operations which are converted to equivalent TensorFlow operations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport torch\nimport tensorflow as tf\n\ndef torch_fn(x):\n    a = torch.mul(x, x)\n    b = torch.mean(x)\n    return x * a + b\n\ntf_fn = ivy.transpile(torch_fn, source=\"torch\", target=\"tensorflow\")\n\ntf_x = tf.convert_to_tensor([1., 2., 3.])\nret = tf_fn(tf_x)\n```\n\n----------------------------------------\n\nTITLE: Using ivy.transpile() for Code Conversion in RST\nDESCRIPTION: Illustrates the use of ivy.transpile() function, which converts code (such as classes, functions, or modules) from one source framework to another. This powerful one-liner facilitates cross-framework code translation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners.rst#2025-04-23_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n``ivy.transpile()``\n```\n\n----------------------------------------\n\nTITLE: Tracing a computational graph with Ivy\nDESCRIPTION: Example of using Ivy to trace the computational graph of a PyTorch function. This creates an optimized graph-based representation of the function that can be executed with PyTorch tensors.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport torch\n\ndef torch_fn(x):\n    a = torch.mul(x, x)\n    b = torch.mean(x)\n    return x * a + b\n\ntorch_x = torch.tensor([1., 2., 3.])\ngraph = ivy.trace_graph(jax_fn, to=\"torch\", args=(torch_x,))\nret = graph(torch_x)\n```\n\n----------------------------------------\n\nTITLE: Executing PyTorch Model\nDESCRIPTION: Initializes and runs the PyTorch model with random input data. The model is compiled using torch.compile() for improved performance, and returns both the model and the output shape.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntorch_model = torch.compile(TorchModel())\ninp2 = np.random.random((10, 10)).astype(np.float32)\nx2 = torch.from_numpy(inp2)\ntorch_model, torch_model(x2).shape\n```\n\n----------------------------------------\n\nTITLE: Implementing Tan Function in Ivy and PyTorch Backends\nDESCRIPTION: Comparison of the tan function implementation between Ivy's API and PyTorch backend. The Ivy implementation handles exceptions, nestable arrays, array-like types, out arguments, and native array conversions, while the PyTorch implementation is simpler and works with torch.Tensor types.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_arguments.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Ivy\n@handle_exceptions\n@handle_nestable\n@handle_array_like_without_promotion\n@handle_out_argument\n@to_native_arrays_and_back\n@handle_array_function\ndef tan(\n    x: Union[ivy.Array, ivy.NativeArray],\n    /,\n    *,\n    out: Optional[ivy.Array] = None\n) -> ivy.Array:\n\n# PyTorch\n@handle_numpy_arrays_in_specific_backend\ndef tan(\n    x: torch.Tensor,\n    /,\n    *,\n    out: Optional[torch.Tensor] = None\n) -> torch.Tensor:\n```\n\n----------------------------------------\n\nTITLE: Transpiling JAX Function to NumPy with Ivy\nDESCRIPTION: This snippet shows how to transpile a JAX loss function to NumPy using Ivy's transpile function. It imports necessary libraries, defines the loss function, transpiles it, and then applies it to NumPy arrays.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport jax.numpy as jnp\nimport numpy as np\n\ndef loss(predictions, targets):\n    return jnp.sqrt(jnp.mean((predictions - targets) ** 2))\n\n# transpile any function from jax to numpy\nnp_loss = ivy.transpile(loss, source=\"jax\", to=\"numpy\")\n\n# get some arrays\np = np.array([3.0, 2.0, 1.0])\nt = np.array([0.0, 0.0, 0.0])\n\n# and use the transpiled version!\nout = np_loss(p, t)\n```\n\n----------------------------------------\n\nTITLE: Framework-Specific Function Tracing in Ivy (Pure PyTorch)\nDESCRIPTION: Example of tracing a function written with PyTorch operations. The trace_graph function extracts a computational graph equivalent to the PyTorch operations, demonstrating framework interoperability.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef pure_torch(x):\n    y = torch.mean(x)\n    z = torch.sum(x)\n    f = torch.var(y)\n    k = torch.cos(z)\n    m = torch.sin(f)\n    o = torch.tan(y)\n    return torch.cat(\n        [k, m, o], -1)\n\n# input\nx = torch.tensor([[1., 2., 3.]])\n\n# create graph\ngraph = ivy.trace_graph(\n    pure_torch, x)\n\n# call graph\nret = graph(x)\n```\n\n----------------------------------------\n\nTITLE: TensorFlow to PyTorch Library Transpilation\nDESCRIPTION: Demonstrates transpiling a TensorFlow-based segmentation models library to PyTorch. Shows how to convert and use library functions across frameworks.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport torch\nimport os\nos.environ[\"SM_FRAMEWORK\"] = \"tf.keras\"\nimport segmentation_models as sm\n\ntorch_sm = ivy.transpile(sm, source=\"tensorflow\", to=\"torch\")\n\noutput = torch.rand((1, 3, 512, 512))\ntarget = torch.rand((1, 3, 512, 512))\n\nout = torch_sm.metrics.iou_score(output, target)\n```\n\n----------------------------------------\n\nTITLE: Executing TensorFlow Model\nDESCRIPTION: Initializes and runs the TensorFlow model with random input data. The model is wrapped with tf.function for improved performance and includes a summary of the model architecture.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntf_model = tf.function(TFModel())  \ninp = np.random.random((10, 10))\nx = tf.convert_to_tensor(inp, dtype=tf.float32)\ntf_model(x)\n\ntf_model.summary()\n```\n\n----------------------------------------\n\nTITLE: Implementing Roll Function in Ivy and NumPy Backends\nDESCRIPTION: Comparison of the roll function implementation between Ivy's API and NumPy backend. The Ivy implementation includes decorators for handling various array operations, while the NumPy implementation directly works with np.ndarray types but maintains the same signature pattern.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_arguments.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Ivy\n@handle_exceptions\n@handle_nestable\n@handle_array_like_without_promotion\n@handle_out_argument\n@to_native_arrays_and_back\n@handle_array_function\ndef roll(\n    x: Union[ivy.Array, ivy.NativeArray],\n    /,\n    shift: Union[int, Sequence[int]],\n    *,\n    axis: Optional[Union[int, Sequence[int]]] = None,\n    out: Optional[ivy.Array] = None,\n) -> ivy.Array:\n\n# NumPy\ndef roll(\n    x: np.ndarray,\n    /,\n    shift: Union[int, Sequence[int]],\n    *,\n    axis: Optional[Union[int, Sequence[int]]] = None,\n    out: Optional[np.ndarray] = None,\n) -> np.ndarray:\n```\n\n----------------------------------------\n\nTITLE: Matrix Operation Function Tracing in Ivy\nDESCRIPTION: Example demonstrating how to trace a function that performs matrix operations (diagonal matrix creation and matrix multiplication) in Ivy. The trace_graph function produces a computational graph that can be executed with various inputs.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef ivy_func(x, y):\n    w = ivy.diag(x)\n    z = ivy.matmul(w, y)\n    return z\n\n# input\nx = ivy.array([[1., 2., 3.]])\ny = ivy.array([[2., 3., 4.]])\n# create graph\ngraph = ivy.trace_graph(\n    ivy_func, x, y)\n\n# call graph\nret = graph(x, y)\n```\n\n----------------------------------------\n\nTITLE: JAX to PyTorch Loss Function Transpilation\nDESCRIPTION: Shows how to transpile JAX-based loss functions to PyTorch. Includes example of basic array operations and loss computation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport rax\nimport torch\n\ntorch_rax = ivy.transpile(rax, source=\"jax\", to=\"torch\")\n\nscores = torch.tensor([2.2, 1.3, 5.4])\nlabels = torch.tensor([1.0, 0.0, 0.0])\n\nout = torch_rax.poly1_softmax_loss(scores, labels)\n```\n\n----------------------------------------\n\nTITLE: Framework-Agnostic Function Tracing in Ivy (Pure Ivy)\nDESCRIPTION: Example of tracing a function written purely with Ivy operations. The trace_graph function extracts a computational graph that can be independently executed, preserving the same operations in the same order.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef pure_ivy(x):\n    y = ivy.mean(x)\n    z = ivy.sum(x)\n    f = ivy.var(y)\n    k = ivy.cos(z)\n    m = ivy.sin(f)\n    o = ivy.tan(y)\n    return ivy.concatenate(\n        [k, m, o], -1)\n\n# input\nx = ivy.array([[1., 2., 3.]])\n\n# create graph\ngraph = ivy.trace_graph(\n    pure_ivy, x)\n\n# call graph\nret = graph(x)\n```\n\n----------------------------------------\n\nTITLE: Using ivy.transpile() Function to Convert Between Frameworks\nDESCRIPTION: The ivy.transpile() function converts a given object (function, class, or module) from one deep learning framework to another, preserving all logic. It supports specifying source and target frameworks, and includes optional performance profiling.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/transpile.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nivy.transpile(object, source=\"torch\", target=\"tensorflow\", profiling=False,)\n```\n\n----------------------------------------\n\nTITLE: Forcing Operations on Specific Device in Ivy (Python)\nDESCRIPTION: This snippet demonstrates how to use the ivy.DefaultDevice context manager to force operations onto a specific device, regardless of the original array devices.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nx = ivy.array([1], device=\"gpu:0\")\ny = ivy.array([34], device=\"gpu:0\")\nwith ivy.DefaultDevice(\"cpu\"):\n    z = ivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: JAX to PyTorch Model Transpilation with Perceiver IO\nDESCRIPTION: Transpiles a JAX-based Perceiver IO model to PyTorch and builds a classifier around it. Shows how to handle model initialization and parameter conversion between frameworks.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport jax\nimport torch\n\n# Get a pretrained haiku model\nfrom deepmind_perceiver_io import key, perceiver_backbone\n\ndummy_input = jax.random.uniform(key, shape=(1, 3, 224, 224))\nparams = perceiver_backbone.init(rng=key, images=dummy_input)\nivy.set_backend(\"jax\")\nbackbone = ivy.transpile(\n    perceiver_backbone, source=\"jax\", to=\"torch\", params_v=params, kwargs={\"images\": dummy_input}\n)\n\nclass PerceiverIOClassifier(torch.nn.Module):\n    def __init__(self, num_classes=20):\n        super().__init__()\n        self.backbone = backbone\n        self.max_pool = torch.nn.MaxPool2d((512, 1))\n        self.flatten = torch.nn.Flatten()\n        self.fc = torch.nn.Linear(1024, num_classes)\n\n    def forward(self, x):\n        x = self.backbone(images=x)\n        x = self.flatten(self.max_pool(x))\n        return self.fc(x)\n\nclassifier = PerceiverIOClassifier()\nret = classifier(torch.rand((1, 3, 224, 224)))\n```\n\n----------------------------------------\n\nTITLE: Implementing Cross Entropy with Out Argument in Python\nDESCRIPTION: Example implementation of cross_entropy function showing proper out argument handling for memory efficiency. The function supports inplace updates and backend-specific optimizations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef cross_entropy(\n    true: Union[ivy.Array, ivy.NativeArray],\n    pred: Union[ivy.Array, ivy.NativeArray],\n    /,\n    *,\n    axis: int = -1,\n    epsilon: float = 1e-7,\n    reduction: str = \"mean\",\n    out: Optional[ivy.Array] = None,\n) -> ivy.Array:\n    ivy.utils.assertions.check_elem_in_list(reduction, [\"none\", \"sum\", \"mean\"])\n    pred = ivy.clip(pred, epsilon, 1 - epsilon)\n    log_pred = ivy.log(pred)\n    return _reduce_loss(reduction, log_pred * true, axis, out=out)\n```\n\n----------------------------------------\n\nTITLE: Transpiling TensorFlow Function to NumPy with Ivy\nDESCRIPTION: This snippet demonstrates how to transpile a TensorFlow loss function to NumPy using Ivy's transpile function. It then applies the transpiled function to NumPy arrays.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# transpile any function from tf to numpy\nnp_loss = ivy.transpile(loss, source=\"tensorflow\", to=\"numpy\")\n\n# get some arrays\np = np.array([3.0, 2.0, 1.0])\nt = np.array([0.0, 0.0, 0.0])\n\n# and use the transpiled version!\nout = np_loss(p, t)\n```\n\n----------------------------------------\n\nTITLE: Example Function Demonstrating Graph Construction in Ivy\nDESCRIPTION: Shows a simple function with two operations and explains how the graph construction process works by starting from the output and linking backward through nodes to the input.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/README.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef example_function(x):\n    y = ivy.mean(x)     # Node 1\n    z = ivy.sqrt(y)     # Node 2\n    return z\n\n# Graph construction starts from z, links to sqrt node,\n# then to mean node, and finally to input x\n```\n\n----------------------------------------\n\nTITLE: Tracing Model with Ivy\nDESCRIPTION: Demonstrates how to trace and compile the model using Ivy's graph tracing functionality for improved performance.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Compiling the model\ntraced_graph = ivy.trace_graph(model, args=(**inputs,))\n\n# Using the traced function\nlogits = traced_graph(**inputs).logits\n```\n\n----------------------------------------\n\nTITLE: Implementing Primary Function (ivy.tan) in the Ivy Module\nDESCRIPTION: Example of a primary function implementation in Ivy's main module. Primary functions defer to backend-specific implementations through the current_backend mechanism.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_types.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef tan(\n    x: Union[ivy.Array, ivy.NativeArray],\n    /,\n    *,\n    out: Optional[ivy.Array] = None,\n) -> ivy.Array:\n    return ivy.current_backend(x).tan(x, out=out)\n```\n\n----------------------------------------\n\nTITLE: Building PyTorch Classifier from EfficientNet Encoder\nDESCRIPTION: Creates a PyTorch classifier by transpiling and using a pre-trained encoder model. Demonstrates basic model composition with a linear classification head.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Classifier(torch.nn.Module):\n    def __init__(self, num_classes=20):\n        super().__init__()\n        self.encoder = torch_eff_encoder\n        self.fc = torch.nn.Linear(1280, num_classes)\n\n    def forward(self, x):\n        x = self.encoder(x)\n        return self.fc(x)\n\n# Initialize a trainable, customizable, torch.nn.Module\nclassifier = Classifier()\nret = classifier(torch.rand((1, 244, 244, 3)))\n```\n\n----------------------------------------\n\nTITLE: Tracing Ivy Module Class with Graph Tracer\nDESCRIPTION: Example of tracing an Ivy Module class. This demonstrates how Ivy can extract the computational graph from higher-level abstractions like neural network modules, focusing only on the operations relevant to the computation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Network(ivy.module)\n\n    def __init__(self):\n        self._layer = ivy.Linear(3, 3)\n        super().__init__()\n\n    def _forward(self, x):\n        return self._layer(x)\n\n# build network\nnet = Network()\n\n# input\nx = ivy.array([1., 2., 3.])\n\n# trace graph\nnet.trace_graph(x)\n\n# execute graph\nnet(x)\n```\n\n----------------------------------------\n\nTITLE: Basic Function Tracing Example in Python\nDESCRIPTION: Demonstrates basic usage of ivy.trace_graph() to create an optimized computation graph from a simple function that performs array operations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\n\nivy.set_backend(\"torch\")\n\ndef fn(x, y):\n    z = x**y\n    print(z)\n    k = x * y\n    j = ivy.concat([x, z, y])\n    sum_j = ivy.sum(j)\n    return z\n\nx = ivy.array([1, 2, 3])\ny = ivy.array([2, 3, 4])\n\n# Trace the function\ntraced_fn = ivy.trace_graph(fn, args=(x, y))\n```\n\n----------------------------------------\n\nTITLE: Applying Transpiled Loss Function to NumPy Arrays\nDESCRIPTION: Creates NumPy arrays and applies the transpiled loss function to them, demonstrating the usage of the TensorFlow function in a NumPy environment.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# get some arrays\np = np.array([3.0, 2.0, 1.0])\nt = np.array([0.0, 0.0, 0.0])\n\n# and use the transpiled version!\nout = np_loss(p, t)\n```\n\n----------------------------------------\n\nTITLE: Binding Custom Gradient Functions in Ivy with Python\nDESCRIPTION: Example of using ivy.bind_custom_gradient_function to define custom gradient computation rules for a function, useful for numerical stability, smoothing, and clipping of computed gradients.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/gradients.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\n\nivy.set_backend(\"torch\")\nx = ivy.array(50.0)\ninter_func = lambda x: ivy.log1p(ivy.exp(x))\n\n# args –> ((xs, ret), upstream)\ndef custom_grad_fn(*args):\n    args1 = (1 - 10 / (1 + args[0][0]))\n    return (args[1] * args)\n\ninter_func = ivy.bind_custom_gradient_function(\ninter_func, custom_grad_fn\n)\nfunc = lambda x: ivy.sum(inter_func(x) ** 2)\n\nret, grad = ivy.execute_with_gradients(func, x)\n```\n\n----------------------------------------\n\nTITLE: Tracing Clean Function Implementation with Graph Tracer\nDESCRIPTION: Example of tracing a simple, clean function implementation that computes w*x + b. The trace_graph extracts only the essential computation graph without any unnecessary operations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef clean(x, w, b):\n    return w*x + b\n\n# input\nx = ivy.array([1., 2., 3.])\nw = ivy.random_uniform(\n    -1, 1, (3, 3))\nb = ivy.zeros((3,))\n\n# trace graph\ngraph = ivy.trace_graph(\n    clean, x, w, b)\n\n# execute graph\ngraph(x, w, b)\n```\n\n----------------------------------------\n\nTITLE: Transforming Python While Loop with If-Statement using to_functional_form\nDESCRIPTION: Example showing how a simple Python function with a while loop and if-statement is transformed into functional form using Autograph_Ivy. The input function is processed by to_functional_form() to produce a closure-less functional equivalent.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/README.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom control_flow_experimental.autograph_ivy.core.api import to_functional_form\nimport inspect\n\ndef while_with_if(i, x,w,b):\n  while i <= 10:\n    if i == 7:\n      i += 1\n    res = x*w+b\n    i += 1\n  return res\n\nconverted_fn = to_functional_form(while_with_if)\nprint(inspect.getsource(converted_fn))\n```\n\n----------------------------------------\n\nTITLE: Tracing Unoptimized Function with Graph Tracer\nDESCRIPTION: Example showing how Ivy traces only the relevant operations in an unoptimized function containing extraneous computations and print statements. The resulting graph captures only the operations that contribute to the return value.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef unclean(x, w, b):\n    y = b + w + x\n    print('message')\n    wx = w * x\n    ret = wx + b\n    temp = y * wx\n    return ret\n\n# input\nx = ivy.array([1., 2., 3.])\nw = ivy.random_uniform(\n    -1, 1, (3, 3))\nb = ivy.zeros((3,))\n\n# trace graph\ngraph = ivy.trace_graph(\n    unclean, x, w, b)\n\n# execute graph\ngraph(x, w, b)\n```\n\n----------------------------------------\n\nTITLE: Basic Backend Inference Example with NumPy and PyTorch\nDESCRIPTION: Demonstrates how Ivy automatically infers the backend framework from input arrays, showing interactions with NumPy and PyTorch backends.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/backend_setting.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = ivy.array([[2., 3.]])\nivy.current_backend()\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Shared Nested Structure in Python with Ivy Containers\nDESCRIPTION: This snippet shows how to create and operate on Ivy Containers with shared nested structures, demonstrating broadcasting behavior for non-identical but shared structures.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/containers.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nx = ivy.Container(a={'b': 2, 'c': 4}, d={'e': 6, 'f': 9})\ny = ivy.Container(a=2, d=3)\n\nprint(x / y)\n{\n    a: {\n      b: 1.0,\n      c: 2.0\n    },\n    d: {\n      e: 2.0,\n      f: 3.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Inplace Updates in NumPy\nDESCRIPTION: NumPy implementation of inplace_update function. NumPy natively supports inplace updates, so this implementation updates both the native array and the ivy.Array instance if provided.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef inplace_update(\n    x: Union[ivy.Array, np.ndarray],\n    val: Union[ivy.Array, np.ndarray],\n    /,\n    *,\n    ensure_in_backend: bool = False,\n    keep_input_dtype: bool = False,\n) -> ivy.Array:\n    ivy.utils.assertions.check_inplace_sizes_valid(x, val)\n    if ivy.is_array(x) and ivy.is_array(val):\n        if keep_input_dtype:\n            val = ivy.astype(val, x.dtype)\n        (x_native, val_native), _ = ivy.args_to_native(x, val)\n\n        # make both arrays contiguous if not already\n        if not x_native.flags.c_contiguous:\n            x_native = np.ascontiguousarray(x_native)\n        if not val_native.flags.c_contiguous:\n            val_native = np.ascontiguousarray(val_native)\n\n        if val_native.shape == x_native.shape:\n            if x_native.dtype != val_native.dtype:\n                x_native = x_native.astype(val_native.dtype)\n            np.copyto(x_native, val_native)\n        else:\n            x_native = val_native\n        if ivy.is_ivy_array(x):\n            x.data = x_native\n        else:\n            x = ivy.Array(x_native)\n        return x\n    else:\n        return val\n```\n\n----------------------------------------\n\nTITLE: JAX Backend Setting and Switching Example\nDESCRIPTION: Demonstrates explicit backend setting with JAX, performing matrix multiplication, and switching between backends using previous_backend().\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/backend_setting.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nivy.set_backend('jax')\nz = ivy.matmul(jax.numpy.array([[2.,3.]]), jax.numpy.array([[5.],[6.]]))\nivy.current_backend()\nivy.previous_backend()\nivy.current_backend()\n```\n\n----------------------------------------\n\nTITLE: Function Wrapping for Operation Logging in Python\nDESCRIPTION: Demonstrates how primitive functions are wrapped for operation logging during the tracing process. This wrapper logs function calls, stores them in the graph, and executes the original function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef _wrap_function_for_op_logging(fn: Callable, graph: Graph, ...) -> Callable:\n    def _tracing_function(*args, **kwargs):\n        # Log function call information\n        # Store in graph\n        # Execute original function\n        return result\n    return _tracing_function\n```\n\n----------------------------------------\n\nTITLE: View Handling and Indexing in Ivy Functions\nDESCRIPTION: Wrappers like handle_view and handle_view_indexing are used to implement Ivy's policy for handling views and indexing operations across different backends.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nhandle_view\nhandle_view_indexing\n```\n\n----------------------------------------\n\nTITLE: NumPy One-Hot Backend Implementation\nDESCRIPTION: Backend implementation of one_hot function for NumPy, using numpy's eye function to create one-hot encodings.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef one_hot(\n    indices: np.ndarray, depth: int, *, device: str, out: Optional[np.ndarray] = None\n) -> np.ndarray:\n   res = np.eye(depth)[np.array(indices).reshape(-1)]\n   return res.reshape(list(indices.shape) + [depth])\n```\n\n----------------------------------------\n\nTITLE: LSTM Update Implementation\nDESCRIPTION: Implementation of LSTM update function using composable Ivy operations, demonstrating framework-agnostic implementation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n@to_native_arrays_and_back\n@handle_nestable\ndef lstm_update(\n    x: Union[ivy.Array, ivy.NativeArray],\n    init_h: Union[ivy.Array, ivy.NativeArray],\n    init_c: Union[ivy.Array, ivy.NativeArray],\n    kernel: Union[ivy.Array, ivy.NativeArray],\n    recurrent_kernel: Union[ivy.Array, ivy.NativeArray],\n    bias: Optional[Union[ivy.Array, ivy.NativeArray]] = None,\n    recurrent_bias: Optional[Union[ivy.Array, ivy.NativeArray]] = None,\n) -> Tuple[ivy.Array, ivy.Array]:\n    x_shape = list(x.shape)\n    batch_shape = x_shape[:-2]\n    timesteps = x_shape[-2]\n    input_channels = x_shape[-1]\n    x_flat = ivy.reshape(x, (-1, input_channels))\n\n    Wi = kernel\n    Wi_x = ivy.reshape(\n        ivy.matmul(x_flat, Wi) + (bias if bias is not None else 0),\n        batch_shape + [timesteps, -1],\n    )\n    Wii_x, Wif_x, Wig_x, Wio_x = ivy.split(Wi_x, 4, -1)\n\n    Wh = recurrent_kernel\n\n    ht = init_h\n    ct = init_c\n\n    hts_list = []\n\n    for Wii_xt, Wif_xt, Wig_xt, Wio_xt in zip(\n        ivy.unstack(Wii_x, axis=-2),\n        ivy.unstack(Wif_x, axis=-2),\n        ivy.unstack(Wig_x, axis=-2),\n        ivy.unstack(Wio_x, axis=-2),\n    ):\n        htm1 = ht\n        ctm1 = ct\n\n        Wh_htm1 = ivy.matmul(htm1, Wh) + (\n            recurrent_bias if recurrent_bias is not None else 0\n        )\n        Whi_htm1, Whf_htm1, Whg_htm1, Who_htm1 = ivy.split(\n            Wh_htm1, num_or_size_splits=4, axis=-1\n        )\n\n        it = ivy.sigmoid(Wii_xt + Whi_htm1)\n        ft = ivy.sigmoid(Wif_xt + Whf_htm1)\n        gt = ivy.tanh(Wig_xt + Whg_htm1)\n        ot = ivy.sigmoid(Wio_xt + Who_htm1)\n        ct = ft * ctm1 + it * gt\n        ht = ot * ivy.tanh(ct)\n\n        hts_list.append(ivy.expand_dims(ht, -2))\n\n    return ivy.concat(hts_list, -2), ct\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy development dependencies\nDESCRIPTION: These commands install Ivy's development dependencies, including both required and optional packages. Additional files for specific hardware configurations are also mentioned.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/get_started.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements/requirements.txt\npip install -r requirements/optional.txt\n```\n\n----------------------------------------\n\nTITLE: Implementing TensorFlow add Function in Ivy Frontend\nDESCRIPTION: This snippet shows the implementation of TensorFlow's add function in the Ivy frontend. It handles TensorFlow-specific casting and wraps the Ivy add function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/functional/frontends/tensorflow/math.py\n@to_ivy_arrays_and_back\ndef add(x, y, name=None):\n    x, y = check_tensorflow_casting(x, y)\n    return ivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying Ivy Global Parameters in Python\nDESCRIPTION: Demonstrates how to access and modify global parameters in Ivy using getters, setters, and unsetters. Shows error handling when attempting to set read-only attributes directly.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/operating_modes.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> ivy.array_mode\nTrue\n>>> ivy.array_mode = False\nFile \"<stdin>\", line 1, in <module>\nFile \".../ivy/ivy/__init__.py\", line 1306, in __setattr__\n    raise ivy.utils.exceptions.IvyException(\n\nIvyException: Property: array_mode is read only! Please use the setter: set_array_mode() for setting its value!\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> ivy.array_mode\nTrue\n>>> ivy.set_array_mode(False)\n>>> ivy.array_mode\nFalse\n>>> ivy.unset_array_mode()\n>>> ivy.array_mode\nTrue\n```\n\n----------------------------------------\n\nTITLE: Overriding ivy.abs Function for MyArray in Python\nDESCRIPTION: This snippet demonstrates how to override the ivy.abs function for the MyArray class using the 'implements' decorator. It defines a custom absolute value function for MyArray objects.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/arrays.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@implements(ivy.abs)\ndef my_abs(my_array, ivy_array):\n \tmy_array.data = abs(my_array.data)\n```\n\n----------------------------------------\n\nTITLE: Configuring Interpolation Function in Python\nDESCRIPTION: This snippet sets up the partial_mixed_handler for the interpolate function. It defines a lambda function that determines when to use backend-specific implementations based on the interpolation mode.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/superset_behaviour.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ninterpolate.partial_mixed_handler = lambda *args, mode=\"linear\", **kwargs: mode not in [\n    \"tf_area\",\n    \"tf_bicubic\",\n    \"mitchellcubic\",\n    \"lanczos3\",\n    \"lanczos5\",\n    \"gaussian\",\n]\n```\n\n----------------------------------------\n\nTITLE: Frontend numpy argsort implementation\nDESCRIPTION: Implementation of the numpy frontend argsort function using the @to_ivy_arrays_and_back decorator.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef argsort(\n    x,\n    /,\n    *,\n    axis=-1,\n    kind=None,\n    order=None,\n):\n    return ivy.argsort(x, axis=axis)\n```\n\n----------------------------------------\n\nTITLE: Implementing JAX lax.add Frontend Function in Python\nDESCRIPTION: Implementation of the JAX lax.add frontend function that wraps ivy.add. Uses the @to_ivy_arrays_and_back decorator to handle array type conversion.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef add(x, y):\n    return ivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: Implementing PyTorch add() Function in Ivy\nDESCRIPTION: This snippet shows how to implement the PyTorch add() function in Ivy. It wraps the ivy.add() function and handles both positional and keyword arguments, including the alpha parameter.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef add(input, other, *, alpha=None, out=None):\n    return ivy.add(input, other, alpha=alpha, out=out)\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy from source\nDESCRIPTION: These commands clone the Ivy repository from GitHub and install it from source. This method allows users to access the latest changes.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/get_started.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ivy-llc/ivy.git\ncd ivy\npip install --user -e .\n```\n\n----------------------------------------\n\nTITLE: Implementing Cross Entropy Function in Python with Ivy\nDESCRIPTION: This code snippet demonstrates the implementation of a cross entropy function using Ivy's mathematical operations. It shows how compositional functions can be implicitly nestable.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/containers.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef cross_entropy(\n    true: Union[ivy.Array, ivy.NativeArray],\n    pred: Union[ivy.Array, ivy.NativeArray],\n    /,\n    *,\n    axis: Optional[int] = -1,\n    epsilon: float =1e-7,\n    out: Optional[ivy.Array] = None\n) -> ivy.Array:\n    pred = ivy.clip(pred, epsilon, 1 - epsilon)\n    log_pred = ivy.log(pred)\n    return ivy.negative(ivy.sum(log_pred * true, axis, out=out), out=out)\n```\n\n----------------------------------------\n\nTITLE: PyTorch Cholesky Decomposition with Out Support\nDESCRIPTION: Special case implementation of Cholesky decomposition in PyTorch that handles both native and manual out updates.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef cholesky(\n    x: torch.Tensor, /, *, upper: bool = False, out: Optional[torch.Tensor] = None\n) -> torch.Tensor:\n    if not upper:\n        return torch.linalg.cholesky(x, out=out)\n    else:\n        ret = torch.transpose(\n            torch.linalg.cholesky(\n                torch.transpose(x, dim0=len(x.shape) - 1, dim1=len(x.shape) - 2)\n            ),\n            dim0=len(x.shape) - 1,\n            dim1=len(x.shape) - 2,\n        )\n        if ivy.exists(out):\n            return ivy.inplace_update(out, ret)\n        return ret\n\n\ncholesky.support_native_out = True\n```\n\n----------------------------------------\n\nTITLE: Setting Up TensorFlow Profiler\nDESCRIPTION: Configures and runs the TensorFlow profiler to analyze model performance. The profiler captures host, Python, and device-level execution details, storing them in the specified log directory.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nlogs = 'logs/' + \"tensorflow\"\n\nfrom ivy.utils.profiler import tensorflow_profile_start, tensorflow_profile_stop\ntensorflow_profile_start(logs, \n                         host_tracer_level = 3,\n                         python_tracer_level = 1,\n                         device_tracer_level = 1)\ntf_model(x)\ntensorflow_profile_stop()\n```\n\n----------------------------------------\n\nTITLE: Dynamic Backend Context Manager Usage\nDESCRIPTION: Demonstrates the use of the dynamic_backend_as context manager to control dynamic backend behavior in different code sections.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/backend_setting.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwith ivy.dynamic_backend_as(True):\n  a = ivy.array([0., 1.])\n  b = ivy.array([2., 3.])\n\nwith ivy.dynamic_backend_as(False):\n  c = ivy.array([4., 5.])\n  d = ivy.array([6., 7.])\n```\n\n----------------------------------------\n\nTITLE: Initializing ResNet50 Model and Image Processing\nDESCRIPTION: Sets up the environment by configuring Ivy backend, loading a test image dataset, and initializing the ResNet50 model and image processor from Hugging Face.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nfrom transformers import AutoImageProcessor, ResNetForImageClassification\nfrom datasets import load_dataset\n\n# Set backend to torch\nivy.set_backend(\"torch\")\n\n# Download the input image\ndataset = load_dataset(\"huggingface/cats-image\")\nimage = dataset[\"test\"][\"image\"][0]\n\n# Setting the model\nimage_processor = AutoImageProcessor.from_pretrained(\"microsoft/resnet-50\")\nmodel = ResNetForImageClassification.from_pretrained(\"microsoft/resnet-50\")\n\n# Preprocessing the input image\ninputs = image_processor(image, return_tensors=\"pt\")\n```\n\n----------------------------------------\n\nTITLE: JAX Compilation Implementation\nDESCRIPTION: Implementation of the compile function for JAX backend using jax.jit with support for static argument specifications.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncompile = lambda fn, dynamic=True, example_inputs=None,\\\n                static_argnums=None, static_argnames=None:\\\n    jax.jit(fn, static_argnums=static_argnums,\n            static_argnames=static_argnames)\n```\n\n----------------------------------------\n\nTITLE: Implementing Special Method for Array Addition in Python\nDESCRIPTION: Implementation of the __add__ special method for the ivy.Array class, which calls the ivy.add function from the functional API.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/arrays.rst#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef __add__(self, other):\n    return ivy.add(self, other)\n```\n\n----------------------------------------\n\nTITLE: Implementing Stack Function for NumPy Backend in Ivy\nDESCRIPTION: Backend implementation of stack operation for NumPy arrays with native out support.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef stack(\n    arrays: Union[Tuple[np.ndarray], List[np.ndarray]],\n    /,\n    *,\n    axis: int = 0,\n    out: Optional[np.ndarray] = None,\n) -> np.ndarray:\n    return np.stack(arrays, axis, out=out)\n\nstack.support_native_out = True\n```\n\n----------------------------------------\n\nTITLE: Setting Up PyTorch Profiler\nDESCRIPTION: Configures and runs the PyTorch profiler to analyze model performance. The profiler captures CPU and CUDA activities, records tensor shapes, memory usage, and stack traces for detailed analysis.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom ivy.utils.profiler import torch_profiler_init, torch_profiler_start, torch_profiler_stop\nprofiler = torch_profiler_init(activities=[torch.profiler.ProfilerActivity.CPU, torch.profiler.ProfilerActivity.CUDA ],\n        on_trace_ready=torch.profiler.tensorboard_trace_handler('./logs/torch'),\n        record_shapes=True,\n        profile_memory=True,\n        with_stack=True)\ntorch_profiler_start(profiler)\ntorch_model(x2)\ntorch_profiler_stop(profiler)\n```\n\n----------------------------------------\n\nTITLE: Implementing Product Function in Ivy Core API\nDESCRIPTION: Core implementation of the product reduction operation with comprehensive type handling and documentation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@to_native_arrays_and_back\n@handle_out_argument\n@handle_nestable\ndef prod(\n    x: Union[ivy.Array, ivy.NativeArray],\n    *,\n    axis: Optional[Union[int, Sequence[int]]] = None,\n    dtype: Optional[Union[ivy.Dtype, ivy.NativeDtype]] = None,\n    keepdims: bool = False,\n    out: Optional[ivy.Array] = None,\n) -> ivy.Array:\n    return current_backend(x).prod(\n        x, axis=axis, dtype=dtype, keepdims=keepdims, out=out\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies\nDESCRIPTION: Commands for installing Ivy development dependencies based on platform\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_5\n\nLANGUAGE: none\nCODE:\n```\npip install -r requirements/optional.txt\n```\n\n----------------------------------------\n\nTITLE: Valid Function Return Types for Gradient Computation in Python\nDESCRIPTION: Examples of valid return types for functions used with ivy.execute_with_gradients, including single scalars and nested structures of scalars (zero-dimensional arrays).\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/gradients.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nivy.array(12.)\n\n# OR\n\nivy.Container(\n    a=ivy.array(12.),\n    b=ivy.Container(\n        c=ivy.array(15.),\n        d=ivy.array(32.)\n    )\n)\n\n# OR\n\n[ivy.array(25.), {'x': (ivy.array(21.), ivy.array(11.))}, (ivy.array(9.),)]\n```\n\n----------------------------------------\n\nTITLE: Array Creation Functions in Ivy\nDESCRIPTION: A comprehensive list of array creation functions implemented in the Ivy library. These functions are similar to NumPy's array creation routines and are designed to work across different backend frameworks.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/creation_functions.txt#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#arange # failing sporadically for tensorflow - https://github.com/tensorflow/tensorflow/issues/55796, and numpy due to isequal tol https://github.com/unifyai/ivy/actions/runs/3218044361/jobs/5261744015\n#asarray\nempty\nempty_like\n#eye #fails for jax non deterministically, possibly due to +0 vs -0 inconsistencies\nfrom_dlpack\nfull\nfull_like\n#linspace # fails for numpy due to tolerance issues e.g. out[-1]=16777217.0, but should be 16777217.0\nmeshgrid\nones\nones_like\ntril\ntriu\nzeros\nzeros_like\n```\n\n----------------------------------------\n\nTITLE: Implementing Inplace Updates in TensorFlow\nDESCRIPTION: TensorFlow implementation of inplace_update function. TensorFlow supports inplace updates for tf.Variable instances but not for tf.Tensor instances. This implementation handles both cases and updates ivy.Array instances.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef inplace_update(\n    x: Union[ivy.Array, tf.Tensor],\n    val: Union[ivy.Array, tf.Tensor],\n    /,\n    *,\n    ensure_in_backend: bool = False,\n    keep_input_dtype: bool = False,\n) -> ivy.Array:\n    if ivy.is_array(x) and ivy.is_array(val):\n        if keep_input_dtype:\n            val = ivy.astype(val, x.dtype)\n        (x_native, val_native), _ = ivy.args_to_native(x, val)\n        if _is_variable(x_native):\n            x_native.assign(val_native)\n            if ivy.is_ivy_array(x):\n                x.data = x_native\n            else:\n                x = ivy.Array(x_native)\n        elif ensure_in_backend:\n            raise ivy.utils.exceptions.IvyException(\n                \"TensorFlow does not support inplace updates of the tf.Tensor\"\n            )\n        elif ivy.is_ivy_array(x):\n            x.data = val_native\n            # Handle view updates\n            if ivy.exists(x._base):\n                base = x._base\n                base_idx = ivy.arange(base.size).reshape(base.shape)\n                for fn, args, kwargs, index in x._manipulation_stack:\n                    kwargs[\"copy\"] = True\n                    base_idx = ivy.__dict__[fn](base_idx, *args, **kwargs)\n                    base_idx = base_idx[index] if ivy.exists(index) else base_idx\n                base_flat = tf.reshape(base.data, -1)\n                base_flat = tf.tensor_scatter_nd_update(\n                    base_flat,\n                    tf.reshape(base_idx.data, (-1, 1)),\n                    tf.reshape(val_native, -1),\n                )\n\n                base.data = tf.reshape(base_flat, base.shape)\n                for ref in base._view_refs:\n                    view = ref()\n                    if ivy.exists(view) and view is not x:\n                        _update_view(view, base)\n            else:\n                for ref in x._view_refs:\n                    view = ref()\n                    if ivy.exists(view):\n                        _update_view(view, x)\n        else:\n            x = ivy.to_ivy(x_native)\n        return x\n    else:\n        return val\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeros Function in PyTorch\nDESCRIPTION: Backend-specific implementation of the zeros function for PyTorch, with required device and dtype arguments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef zeros(\n    shape: Union[int, Sequence[int]],\n    *,\n    dtype: torch.dtype,\n    device: torch.device,\n) -> Tensor:\n```\n\n----------------------------------------\n\nTITLE: PyTorch Compilation Implementation\nDESCRIPTION: Implementation of the compile function for PyTorch backend using JIT compilation, supporting both dynamic scripting and static tracing modes.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef compile(fn, dynamic=True, example_inputs=None,\n            static_argnums=None, static_argnames=None):\n    if dynamic:\n        return torch.jit.script(fn)\n    return torch.jit.trace(fn, example_inputs)\n```\n\n----------------------------------------\n\nTITLE: Using Overridden ivy.abs Function with MyArray in Python\nDESCRIPTION: This snippet shows how to use the overridden ivy.abs function with a MyArray object, demonstrating the successful integration of the custom class with Ivy's functional API.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/arrays.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nX = MyArray(-3)\nX = ivy.abs(X)\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeros Function in Ivy and JAX Backends\nDESCRIPTION: Comparison of the zeros function implementation between Ivy's API and JAX backend. The Ivy implementation infers dtype and device when not specified, handles nested arrays, and supports array-like types. The JAX implementation requires explicit dtype and device parameters.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_arguments.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Ivy\n@handle_nestable\n@handle_array_like_without_promotion\n@handle_out_argument\n@inputs_to_native_shapes\n@outputs_to_ivy_arrays\n@handle_array_function\n@infer_dtype\n@infer_device\ndef zeros(\n    shape: Union[ivy.Shape, ivy.NativeShape],\n    *,\n    dtype: Optional[Union[ivy.Dtype, ivy.NativeDtype]] = None,\n    device: Optional[Union[ivy.Device, ivy.NativeDevice]] = None,\n    out: Optional[ivy.Array] = None\n) -> ivy.Array:\n\n# JAX\ndef zeros(\n    shape:  Union[ivy.NativeShape, Sequence[int]],\n    *,\n    dtype: jnp.dtype,\n    device: jaxlib.xla_extension.Device,\n    out: Optional[JaxArray] = None,\n) -> JaxArray:\n```\n\n----------------------------------------\n\nTITLE: Handling Mixed Function References During Backend Setting\nDESCRIPTION: During backend setting, references to compositional implementations of mixed functions are stored as attributes in the backend function. This requires adding a partial_mixed_handler attribute containing a lambda function to the backend implementation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npartial_mixed_handler = lambda *args, **kwargs: ...\n```\n\n----------------------------------------\n\nTITLE: Mathematical Operations List\nDESCRIPTION: List of supported mathematical functions and operations with some comments indicating implementation status. Some functions like remainder and sign have specific notes about compatibility or testing issues across different frameworks like PyTorch and TensorFlow.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/operators_and_elementwise_functions.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nabs\nacos\nacosh\nadd\nasin\nasinh\natan\natan2\natanh\nbitwise_and\nbitwise_left_shift\nbitwise_invert\nbitwise_or\nbitwise_right_shift\nbitwise_xor\nceil\ncos\ncosh\ndivide\n#equal #failing for numpy\nexp\nexpm1\nfloor\nfloor_divide\ngreater\ngreater_equal\nisfinite\nisinf\nisnan\nless\nless_equal\nlog\nlog1p\nlog2\nlog10\nlogaddexp\nlogical_and\nlogical_not\nlogical_or\nlogical_xor\nmultiply\nnegative\npositive\nnot_equal\npow\n#remainder - torch and tensorflow deviate from standard in zeros handling, passing otherwise\nround\nsign #tests are passing but uncommenting causes everything in test_signatures to run\nsin\nsinh\nsquare\nsqrt\nsubtract\ntan\ntanh\ntrunc\n```\n\n----------------------------------------\n\nTITLE: Stateful Operations Example in Python\nDESCRIPTION: Shows how to track __setattr__ and __getattr__ methods of classes using the stateful parameters in the tracer.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\n\nivy.set_backend(\"torch\")\n\ndef fn(cont, x):\n    cont.new_attribute = x\n    return x + 1\n\nx = torch.tensor([0])\ncont = ivy.Container(x=x)\n\nargs = (cont.cont_deep_copy(), x)\ncomp_func = ivy.trace_graph(fn, arg_stateful_idxs=[[0]], args=args)\n```\n\n----------------------------------------\n\nTITLE: Implementing Inplace Update in PyTorch Backend\nDESCRIPTION: Function that handles inplace updates for both native PyTorch tensors and Ivy arrays. Supports dtype preservation and backend enforcement options.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef inplace_update(\n    x: Union[ivy.Array, torch.Tensor],\n    val: Union[ivy.Array, torch.Tensor],\n    /,\n    *,\n    ensure_in_backend: bool = False,\n    keep_input_dtype: bool = False,\n) -> ivy.Array:\n    ivy.utils.assertions.check_inplace_sizes_valid(x, val)\n    if ivy.is_array(x) and ivy.is_array(val):\n        if keep_input_dtype:\n            val = ivy.astype(val, x.dtype)\n        (x_native, val_native), _ = ivy.args_to_native(x, val)\n        if is_variable(x_native):\n            x_native.data = val_native\n        else:\n            x_native[()] = val_native\n        if ivy.is_ivy_array(x):\n            x.data = x_native\n            _update_torch_views(x)\n        else:\n            x = ivy.to_ivy(x_native)\n        if ensure_in_backend:\n            x._data = val_native\n        return x\n    else:\n        return val\n```\n\n----------------------------------------\n\nTITLE: Implementing full_like Function in Jax Backend\nDESCRIPTION: This snippet shows the implementation of the full_like function for the Jax backend. It uses the check_fill_value_and_dtype_are_compatible helper function and jnp.full_like to create the array.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef full_like(\n    x: JaxArray,\n    /,\n    fill_value: Number,\n    *,\n    dtype: jnp.dtype,\n    device: jaxlib.xla_extension.Device,\n    out: Optional[JaxArray] = None,\n) -> JaxArray:\n    ivy.utils.assertions.check_fill_value_and_dtype_are_compatible(fill_value, dtype)\n    return _to_device(\n        jnp.full_like(x, fill_value, dtype=dtype),\n        device=device,\n    )\n```\n\n----------------------------------------\n\nTITLE: Adding Unsupported Datatypes Decorator in PyTorch Backend\nDESCRIPTION: Python code example showing how to add a decorator to specify unsupported datatypes for a specific backend version.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@with_unsupported_dtypes({\"2.0.1 and below\": (\"float16\",)}, backend_version)\n```\n\n----------------------------------------\n\nTITLE: Implementing Stack Function for PyTorch Backend in Ivy\nDESCRIPTION: Backend implementation of stack operation for PyTorch tensors with native out support.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef stack(\n    arrays: Union[Tuple[torch.Tensor], List[torch.Tensor]],\n    /,\n    *,\n    axis: int = 0,\n    out: Optional[torch.Tensor] = None,\n) -> torch.Tensor:\n    return torch.stack(arrays, axis, out=out)\n\nstack.support_native_out = True\n```\n\n----------------------------------------\n\nTITLE: Implementing Decorator for Function Registration in Python\nDESCRIPTION: This snippet defines an 'implements' decorator function that registers custom function implementations in the HANDLED_FUNCTIONS dict, allowing them to be used with Ivy's functional API.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/arrays.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef implements(ivy_function):\n    def decorator(func):\n        HANDLED_FUNCTIONS[ivy_function] = func\n        return func\n    return decorator\n```\n\n----------------------------------------\n\nTITLE: Implementing Default Device Function in Python\nDESCRIPTION: Implementation of the ivy.default_device function which determines the correct device to use based on provided arguments and global settings.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef default_device(device=None, item=None):\n    if device is not None:\n        return device\n    if item is not None:\n        return ivy.dev(item)\n    return ivy.get_default_device()\n```\n\n----------------------------------------\n\nTITLE: Implementing full_like Function in NumPy Backend\nDESCRIPTION: This snippet demonstrates the implementation of the full_like function for the NumPy backend. It uses the check_fill_value_and_dtype_are_compatible helper function and np.full_like to create the array.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef full_like(\n    x: np.ndarray,\n    /,\n    fill_value: Number,\n    *,\n    dtype: np.dtype,\n    device: str,\n    out: Optional[np.ndarray] = None,\n) -> np.ndarray:\n    ivy.utils.assertions.check_fill_value_and_dtype_are_compatible(fill_value, dtype)\n    return _to_device(np.full_like(x, fill_value, dtype=dtype), device=device)\n```\n\n----------------------------------------\n\nTITLE: Performance Comparison Between Original and Compiled Functions\nDESCRIPTION: Demonstrates the performance improvement achieved through graph compilation by comparing execution times of original and compiled versions of the same function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/README.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Original vs Compiled Performance\nx = ivy.array([1., 2., 3.])\n\n# Original: ~0.57ms\nstart = time.time()\nresult = fn(x)\nprint(f\"Original: {time.time() - start:.4f}s\")\n\n# Compiled: ~0.22ms\nstart = time.time()\nresult = compiled_fn(x)\nprint(f\"Compiled: {time.time() - start:.4f}s\")\n```\n\n----------------------------------------\n\nTITLE: Defining MyArray Class with __ivy_array_function__ in Python\nDESCRIPTION: This snippet defines a MyArray class with an __ivy_array_function__ method that allows it to work with Ivy's functional API. It uses a global HANDLED_FUNCTIONS dict to map Ivy functions to custom implementations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/arrays.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nHANDLED_FUNCTIONS = {}\nclass MyArray:\n    def __init__(self, data=None):\n\t\tself.data = data\n\tdef __ivy_array_function__(self, func, types, args, kwargs):\n\t\tif func not in HANDLED_FUNCTIONS:\n\t\t\treturn NotImplemented\n\t\tif not all(issubclass(t, (MyArray, ivy.Array, ivy.NativeArray)) for t in types):\n\t\t\treturn NotImplemented\n\t\treturn HANDLED_FUNCTIONS[func](*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: PyTorch Flip Backend Implementation\nDESCRIPTION: Backend implementation of flip operation for PyTorch, supporting single or multiple axis flipping.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef flip(\n    x: torch.Tensor,\n    axis: Optional[Union[int, Sequence[int]]] = None,\n    *,\n    out: Optional[torch.Tensor] = None,\n) -> torch.Tensor:\n    num_dims: int = len(x.shape)\n    if not num_dims:\n        return x\n    if axis is None:\n        new_axis: List[int] = list(range(num_dims))\n    else:\n        new_axis: List[int] = axis\n    if isinstance(new_axis, int):\n        new_axis = [new_axis]\n    else:\n        new_axis = new_axis\n    new_axis = [item + num_dims if item < 0 else item for item in new_axis]\n    ret = torch.flip(x, new_axis)\n    return ret\n```\n\n----------------------------------------\n\nTITLE: Implementing JAX lax.tan Frontend Function in Python\nDESCRIPTION: Implementation of the JAX lax.tan frontend function that wraps ivy.tan. Uses the @to_ivy_arrays_and_back decorator to handle array type conversion.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef tan(x):\n    return ivy.tan(x)\n```\n\n----------------------------------------\n\nTITLE: Defining Function Signatures in Ivy API\nDESCRIPTION: Shows the structure of function signatures in the Ivy API, including type hints, positional-only and keyword-only arguments, and docstring format.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef my_func(\n    x: Union[ivy.Array, ivy.NativeArray],\n    /,\n    axes: Union[int, Sequence[int]],\n    *,\n    dtype: Optional[Union[ivy.Dtype, ivy.NativeDtype]] = None,\n    device: Optional[Union[ivy.Device, ivy.NativeDevice]] = None,\n    out: Optional[ivy.Array] = None\n) -> ivy.Array:\n    \"\"\"\n    Explanation of the function.\n\n    .. note::\n        This is an important note.\n\n    **Special Cases**\n\n    For this particular case,\n\n    - If ``x`` is ``NaN``, do something\n    - If ``y`` is ``-0``, do something else\n    - etc.\n\n    Parameters\n    ----------\n    x\n        input array. Should have a numeric data type.\n    axes\n        the axes along which to perform the op.\n    dtype\n        array data type.\n    device\n        the device on which to place the new array.\n    out\n        optional output array, for writing the result to. It must have a shape that the\n        inputs broadcast to.\n\n    Returns\n    -------\n    ret\n        an array.\n\n    Examples\n    --------\n\n    Some examples go here\n    \"\"\"\n    return ivy.current_backend(x).my_func(x, axes, dtype=dtype, device=device, out=out)\n```\n\n----------------------------------------\n\nTITLE: Implementing NumPy add Frontend Function in Python\nDESCRIPTION: Complex implementation of NumPy's add function with support for output arrays, dtype handling, type promotion and array masking through the where parameter.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n@handle_numpy_out\n@handle_numpy_dtype\n@to_ivy_arrays_and_back\n@handle_numpy_casting\n@from_zero_dim_arrays_to_scalar\ndef _add(\n    x1,\n    x2,\n    /,\n    out=None,\n    *,\n    where=True,\n    casting=\"same_kind\",\n    order=\"k\",\n    dtype=None,\n    subok=True,\n):\n    x1, x2 = promote_types_of_numpy_inputs(x1, x2)\n    ret = ivy.add(x1, x2, out=out)\n    if ivy.is_array(where):\n        ret = ivy.where(where, ret, ivy.default(out, ivy.zeros_like(ret)), out=out)\n    return ret\n```\n\n----------------------------------------\n\nTITLE: FCF Transformation Result for While Loop with If Statement\nDESCRIPTION: The transformed function in functional control flow form. It uses Ivy's control flow primitives (if_stmt, while_stmt) and state management through getter and setter functions to handle the original structured control flow.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/autograph_ivy/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef ivy__while_with_if(i, x, w, b):\n\n            def get_state_1():\n                return (res, i)\n\n            def set_state_1(vars_):\n                nonlocal res, i\n                (res, i) = vars_\n\n            def loop_body():\n                nonlocal res, i\n\n                def get_state():\n                    return (i,)\n\n                def set_state(vars_):\n                    nonlocal i\n                    (i,) = vars_\n\n                def if_body():\n                    nonlocal i\n                    i += 1\n\n                def else_body():\n                    nonlocal i\n                    pass\n                ivy.if_stmt((i == 7), if_body, else_body, get_state, set_state)\n                res = ((x * w) + b)\n                i += 1\n\n            def loop_test():\n                return (i <= 10)\n            res = None\n            ivy.while_stmt(loop_test, loop_body, get_state_1, set_state_1)\n            return res\n```\n\n----------------------------------------\n\nTITLE: Importing Submodules in Ivy's __init__.py\nDESCRIPTION: Demonstrates how submodules and their functions are imported in Ivy's __init__.py file. This pattern allows all methods to be called directly from the ivy namespace.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom . import elementwise\nfrom .elementwise import *\nfrom . import general\nfrom .general import *\n# etc.\n```\n\n----------------------------------------\n\nTITLE: Complex Shared Nested Structure Operations in Python with Ivy Containers\nDESCRIPTION: This example demonstrates more complex operations on Ivy Containers with shared nested structures, including deeper nesting and multiple containers.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/containers.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nx = ivy.Container(a={'b': 2, 'c': 4}, d={'e': 6, 'f': 8})\ny = ivy.Container(a=2, d=3)\nz = ivy.Container(a={'b': 10, 'c': {'g': 11, 'h': 12}}, d={'e': 13, 'f': 14})\n\nprint(x + y + z)\n{\n    a: {\n      b: 14,\n      c: {\n        g: 17,\n        h: 18,\n      }\n    },\n    d: {\n      e: 22,\n      f: 25\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Primary Function (tan) in PyTorch Backend\nDESCRIPTION: Example of a primary function's backend-specific implementation for PyTorch. This shows how Ivy wraps native PyTorch functions to provide consistent behavior across backends.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_types.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef tan(\n    x: torch.Tensor,\n    /,\n    *,\n    out: Optional[torch.Tensor] = None\n) -> torch.Tensor:\n    x = _cast_for_unary_op(x)\n    return torch.tan(x, out=out)\n```\n\n----------------------------------------\n\nTITLE: Mapping TensorFlow raw_ops ArgMax to math.argmax in Ivy Frontend\nDESCRIPTION: This code demonstrates how to map the TensorFlow raw_ops ArgMax function to the existing math.argmax implementation in the Ivy frontend, using the map_raw_ops_alias decorator to handle argument differences.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/functional/frontends/tensorflow/raw_ops.py\nArgMax = to_ivy_arrays_and_back(\n    map_raw_ops_alias(\n        tf_frontend.math.argmax,\n        kwargs_to_update={\"dimension\": \"axis\"},\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: TensorFlow frontend add implementation\nDESCRIPTION: Implementation of the TensorFlow frontend add function that maps to ivy.add.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef add(x, y, name=None):\n    return ivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: Using ivy.execute_with_gradients with Container Inputs in Python\nDESCRIPTION: An example demonstrating how to use ivy.execute_with_gradients with Container inputs, showing how to specify which parts of the input structure to compute gradients for and with respect to.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/gradients.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef func(xs) :\n    return ivy.mean(xs[0] + xs[1].b)\n\nx = ivy.array([1., 2., 3.])\nx = ivy.Container(a=x, b=x)\ny = ivy.array([4., 5., 6.])\ny = ivy.Container(b=y, c=x)\nxs = [x, y]\n\nret, grads = ivy.execute_with_gradients(\n    func,\n    xs,\n    xs_grad_idxs=[[0]],\n    ret_grad_idxs=[[\"\"]]\n)\n```\n\n----------------------------------------\n\nTITLE: Using Container with method chaining and built-in function limitations\nDESCRIPTION: This snippet demonstrates advanced Container operations including attribute method chaining (__len__), highlighting some limitations with Python's built-in functions that require specific return types.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/containers.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnum_dims = x.shape.__len__()\nprint(num_dims)\n{\n    a: 1,\n    b: {\n        a: 2,\n        b: 1\n    }\n}\n\nprint(len(x.shape))\n# doesn't work because Python in low-level C has a restriction on the return type of `len` to be `int`\n\nprint(num_dims.real)\n{\n    a: 1,\n    b: {\n        a: 2,\n        b: 1\n    }\n}\n\nprint(bin(num_dims))\n# doesn't work because some Python built-in functions have enforcement on input argument types\n```\n\n----------------------------------------\n\nTITLE: Monkey Patching Example for Function Tracing in PyTorch\nDESCRIPTION: Shows how original PyTorch functions are replaced with wrapped versions to enable tracing. The example demonstrates wrapping the torch.nn.functional.linear function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Original function\ntorch.nn.functional.linear(x, weight, bias)\n\n# After wrapping\ntorch.nn.functional.linear = _wrap_function_for_op_logging(torch.nn.functional.linear, graph)\ntorch.nn.functional.linear(x, weight, bias) # This will now be traced and stored in graph\n```\n\n----------------------------------------\n\nTITLE: Mixed Framework Function Tracing in Ivy (Ivy and PyTorch)\nDESCRIPTION: Example demonstrating how Ivy can trace a function that uses a mix of Ivy and PyTorch operations. The resulting computational graph is equivalent to the other examples, showing framework agnostic behavior.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef mix(x):\n    y = ivy.mean(x)\n    z = torch.sum(x)\n    f = ivy.var(y)\n    k = torch.cos(z)\n    m = ivy.sin(f)\n    o = torch.tan(y)\n    return ivy.concatenate(\n        [k, m, o], -1)\n\n# input\nx = ivy.array([[1., 2., 3.]])\n\n# create graph\ngraph = ivy.trace_graph(\n    mix, x)\n\n# call graph\nret = graph(x)\n```\n\n----------------------------------------\n\nTITLE: Implementing full_like Function in TensorFlow Backend\nDESCRIPTION: This snippet shows the implementation of the full_like function for the TensorFlow backend. It uses the check_fill_value_and_dtype_are_compatible helper function and tf.experimental.numpy.full_like to create the tensor.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef full_like(\n    x: Union[tf.Tensor, tf.Variable],\n    /,\n    fill_value: Number,\n    *,\n    dtype: tf.DType,\n    device: str,\n    out: Optional[Union[tf.Tensor, tf.Variable]] = None,\n) -> Union[tf.Tensor, tf.Variable]:\n    ivy.utils.assertions.check_fill_value_and_dtype_are_compatible(fill_value, dtype)\n    with tf.device(device):\n        return tf.experimental.numpy.full_like(x, fill_value, dtype=dtype)\n```\n\n----------------------------------------\n\nTITLE: Exception Handler Decorator Implementation (Python)\nDESCRIPTION: A decorator that handles exceptions from backend operations and wraps them in appropriate Ivy-specific exceptions. It ensures consistent error handling across different backend implementations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef handle_exceptions(fn: Callable) -> Callable:\n    @functools.wraps(fn)\n    def _handle_exceptions(*args, **kwargs):\n        try:\n            return fn(*args, **kwargs)\n        except IvyNotImplementedException as e:\n            raise e\n        except IvyError as e:\n            _print_traceback_history()\n            raise ivy.utils.exceptions.IvyError(fn.__name__, e, include_backend=True)\n        except IvyBroadcastShapeError as e:\n            _print_traceback_history()\n            raise ivy.utils.exceptions.IvyBroadcastShapeError(\n                fn.__name__, e, include_backend=True\n            )\n        except IvyDtypePromotionError as e:\n            _print_traceback_history()\n            raise ivy.utils.exceptions.IvyDtypePromotionError(\n                fn.__name__, e, include_backend=True\n            )\n        except (IndexError, IvyIndexError) as e:\n            _print_traceback_history()\n            raise ivy.utils.exceptions.IvyIndexError(\n                fn.__name__, e, include_backend=True\n            )\n        except (AttributeError, IvyAttributeError) as e:\n            _print_traceback_history()\n            raise ivy.utils.exceptions.IvyAttributeError(\n                fn.__name__, e, include_backend=True\n            )\n        except (ValueError, IvyValueError) as e:\n            _print_traceback_history()\n            raise ivy.utils.exceptions.IvyValueError(\n                fn.__name__, e, include_backend=True\n            )\n        except (Exception, IvyBackendException) as e:\n            _print_traceback_history()\n            raise ivy.utils.exceptions.IvyBackendException(\n                fn.__name__, e, include_backend=True\n            )\n\n    _handle_exceptions.handle_exceptions = True\n    return _handle_exceptions\n```\n\n----------------------------------------\n\nTITLE: Implementing TensorFlow argmax Function in Ivy Frontend\nDESCRIPTION: This snippet shows the implementation of TensorFlow's argmax function in the Ivy frontend. It handles output type casting and wraps the Ivy argmax function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/functional/frontends/tensorflow/math.py\n@to_ivy_arrays_and_back\ndef argmax(input, axis, output_type=None, name=None):\n    if output_type in [\"uint16\", \"int16\", \"int32\", \"int64\"]:\n        return ivy.astype(ivy.argmax(input, axis=axis), output_type)\n    else:\n        return ivy.astype(ivy.argmax(input, axis=axis), \"int64\")\n```\n\n----------------------------------------\n\nTITLE: Implementing Add Function in Ivy and TensorFlow Backends\nDESCRIPTION: Comparison of the add function implementation between Ivy's API and TensorFlow backend. Both implementations support numeric and array inputs, with an optional alpha parameter for scaling. The TensorFlow implementation accepts tf.Tensor and tf.Variable types.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_arguments.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Ivy\n@handle_exceptions\n@handle_nestable\n@handle_out_argument\n@to_native_arrays_and_back\n@handle_array_function\ndef add(\n    x1: Union[float, ivy.Array, ivy.NativeArray],\n    x2: Union[float, ivy.Array, ivy.NativeArray],\n    /,\n    *,\n    alpha: Optional[Union[int, float]] = None,\n    out: Optional[ivy.Array] = None,\n) -> ivy.Array:\n\n# TensorFlow\ndef add(\n    x1: Union[float, tf.Tensor, tf.Variable],\n    x2: Union[float, tf.Tensor, tf.Variable],\n    /,\n    *,\n    alpha: Optional[Union[int, float]] = None,\n    out: Optional[Union[tf.Tensor, tf.Variable]] = None,\n) -> Union[tf.Tensor, tf.Variable]:\n```\n\n----------------------------------------\n\nTITLE: Generator Functions Example in Python\nDESCRIPTION: Demonstrates how generator functions can be included or excluded from the computation graph using the include_generators parameter.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\n\nivy.set_backend(\"torch\")\n\ndef fn(x):\n    a = torch.randint(0, 100, size=[1])\n    z = x ** a\n    return z + torch.rand([1])\n\ncomp_func = ivy.trace_graph(fn, include_generators=True, args=(x,))\n```\n\n----------------------------------------\n\nTITLE: Defining a TensorFlow Model\nDESCRIPTION: Creates a simple TensorFlow neural network model with a single dense layer and ReLU activation function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass TFModel(tf.keras.Model):\n    def __init__(self):\n        super().__init__()\n        self.lin = tf.keras.layers.Dense(10, activation=tf.nn.relu)\n    \n    def call(self, inputs, training=False):\n        return self.lin(inputs)\n```\n\n----------------------------------------\n\nTITLE: Transforming While Loop with If Statement using to_functional_form\nDESCRIPTION: This example demonstrates how a simple Python function with a while loop and conditional statement is transformed from structured control flow to functional control flow using Autograph_Ivy's to_functional_form function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/autograph_ivy/README.md#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom control_flow_experimental.autograph_ivy.core.api import to_functional_form\nimport inspect\n\ndef while_with_if(i, x,w,b):\n  while i <= 10:\n    if i == 7:\n      i += 1\n    res = x*w+b\n    i += 1\n  return res\n\nconverted_fn = to_functional_form(while_with_if)\nprint(inspect.getsource(converted_fn))\n```\n\n----------------------------------------\n\nTITLE: Implementing Clip/Clamp Functions Across Frontend APIs\nDESCRIPTION: Frontend implementations of clipping/clamping operations for different frameworks mapped to Ivy's unified clip function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef clamp(x_min,x, x_max):\n    return ivy.clip(x, x_min, x_max)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef clip(x, x_min, x_max):\n    return ivy.clip(x, x_min, x_max)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef clip_by_value(x, x_min, x_max):\n    return ivy.clip(x, x_min, x_max)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef clamp(x, x_min, x_max):\n    return ivy.clip(x, x_min, x_max)\n```\n\n----------------------------------------\n\nTITLE: Decorated Array Function Implementation (Python)\nDESCRIPTION: Example implementation of the all() function using the handle_exceptions decorator. Shows how backend operations are wrapped with exception handling.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@handle_exceptions\ndef all(\n    x: Union[ivy.Array, ivy.NativeArray],\n    /,\n    *,\n    axis: Optional[Union[int, Sequence[int]]] = None,\n    keepdims: bool = False,\n    out: Optional[ivy.Array] = None,\n) -> ivy.Array:\n    return ivy.current_backend(x).all(x, axis=axis, keepdims=keepdims, out=out)\n```\n\n----------------------------------------\n\nTITLE: Function Tree Handling Example with Nested Function Call\nDESCRIPTION: This example shows a more complex transformation case with nested function calls. The function 'func' calls another function 'foo' and contains a while loop with library function calls.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/autograph_ivy/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x,y):\n  if x > y:\n    x+=20\n  else:\n    x+=10\n  return x\n\ndef func(x,y):\n    val = foo(x,y)\n    i=0\n    while i < val:\n        y+=1\n        z = ivy.array([1,2,3])\n        w = tf.convert_to_tensor([1,2,3])\n        i+=1\n\n    return y\n```\n\n----------------------------------------\n\nTITLE: Implementing full_like Function in PyTorch Backend\nDESCRIPTION: This snippet demonstrates the implementation of the full_like function for the PyTorch backend. It uses the check_fill_value_and_dtype_are_compatible helper function and torch.full_like to create the tensor.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef full_like(\n    x: torch.Tensor,\n    /,\n    fill_value: Number,\n    *,\n    dtype: torch.dtype,\n    device: torch.device,\n    out: Optional[torch.Tensor] = None,\n) -> torch.Tensor:\n    ivy.utils.assertions.check_fill_value_and_dtype_are_compatible(fill_value, dtype)\n    return torch.full_like(x, fill_value, dtype=dtype, device=device)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Container flexible argument passing\nDESCRIPTION: This example shows how Container allows for flexible argument passing when accessing attributes, supporting both positional and keyword arguments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/containers.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# external method flexibility enables positional and keyword arguments to be passed into the attribute\ny = ivy.Container(l1=[1, 2, 3], c1=ivy.Container(l1=[3, 2, 1], l2=[4, 5, 6]))\n```\n\n----------------------------------------\n\nTITLE: Defining TensorFlow Loss Function and Transpiling to NumPy\nDESCRIPTION: Defines a mean squared error loss function using TensorFlow operations, then transpiles it to NumPy using Ivy's transpile function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport tensorflow as tf\nimport numpy as np\n\ndef loss(predictions, targets):\n    return tf.sqrt(tf.reduce_mean(tf.square(predictions - targets)))\n\n# transpile any function from tf to numpy\nnp_loss = ivy.transpile(loss, source=\"tensorflow\", to=\"numpy\")\n```\n\n----------------------------------------\n\nTITLE: Current Closure-less Function Call Tree Transformation\nDESCRIPTION: The current version of the transformed function for handling call trees using a purely functional approach. It uses ivy__.converted_call for dynamic recursion into function calls and Ivy's WhileLoop for control flow.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/README.md#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef ivy__func(x, y):\n            do_return = False\n            retval_ = None\n            val = ivy__.converted_call(foo, (x, y), None)\n            i = 0\n\n            def loop_body(y, i):\n                y += 1\n                z = ivy__.converted_call(ivy.array, ([1, 2, 3],), None)\n                w = ivy__.converted_call(tf.convert_to_tensor, ([1, 2, 3],), None)\n                i += 1\n                return (y, i)\n\n            def loop_test(y, i):\n                return (i < val)\n            z = None\n            w = None\n            (y, i) = ivy.WhileLoop(loop_test, loop_body, (y, i))\n            try:\n                do_return = True\n                retval_ = y\n            except:\n                do_return = False\n                raise\n            return ivy__.return_none_or_val(retval_, do_return)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Softplus Function in TensorFlow Backend\nDESCRIPTION: Simple implementation of softplus function in Ivy's TensorFlow backend without superset behavior.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/superset_behaviour.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef softplus(x: Tensor,\n                 /,\n                 *,\n                 out: Optional[Tensor] = None) -> Tensor:\n    return tf.nn.softplus(x)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Backend Configuration Example\nDESCRIPTION: Shows how to use dynamic backend functionality with Ivy arrays, demonstrating backend conversion behavior based on dynamic_backend settings.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/backend_setting.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nivy.set_backend('torch')\nx = ivy.array([1,2,3])\ny = ivy.array([1,2,3])\ny.dynamic_backend=False\nx.dynamic_backend=True\nx.data # torch tensor\ny.data # torch.tensor\n\nivy.set_backend('jax')\nx.data # will be a jax array\ny.data # will still be a torch tensor since dynamic_backend=False\n```\n\n----------------------------------------\n\nTITLE: FCF Transformation with Dynamic Function Call Conversion\nDESCRIPTION: The transformed output for the function tree example. It uses 'converted_call' to dynamically handle function calls, deciding whether to transform them recursively or execute them directly at runtime.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/autograph_ivy/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef ivy__func(x, y):\n            val = converted_call(foo, (x, y), None)\n            i = 0\n\n            def get_state():\n                return (y, i)\n\n            def set_state(vars_):\n                nonlocal y, i\n                (y, i) = vars_\n\n            def loop_body():\n                nonlocal y, i\n                y += 1\n                z = converted_call(ivy.array, ([1, 2, 3],), None)\n                w = converted_call(tf.convert_to_tensor, ([1, 2, 3],), None)\n                i += 1\n\n            def loop_test():\n                return (i < val)\n            w = None\n            z = None\n            ivy.while_stmt(loop_test, loop_body, get_state, set_state)\n            return y\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeros Function in TensorFlow\nDESCRIPTION: Backend-specific implementation of the zeros function for TensorFlow, with required device and dtype arguments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef zeros(\n    shape: Union[int, Sequence[int]],\n    *,\n    dtype: tf.DType,\n    device: str,\n) -> Tensor:\n```\n\n----------------------------------------\n\nTITLE: Implementing PyTorch tan() Function in Ivy\nDESCRIPTION: This snippet demonstrates the implementation of the PyTorch tan() function in Ivy. It wraps the ivy.tan() function and includes the out parameter as an optional keyword argument.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef tan(input, *, out=None):\n    return ivy.tan(input, out=out)\n```\n\n----------------------------------------\n\nTITLE: TensorFlow tensor addition special methods\nDESCRIPTION: Implementation of __radd__ and __add__ special methods for TensorFlow tensor class showing operator overloading.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef __radd__(self, x, name=\"radd\"):\n    return tf_frontend.math.add(x, self._ivy_array, name=name)\n\ndef __add__(self, y, name=\"add\"):\n    return self.__radd__(y)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Device Exception in Ivy (Python)\nDESCRIPTION: This snippet demonstrates how Ivy raises a device exception when soft device mode is disabled and input arrays are on different devices.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nivy.set_backend(\"torch\")\nivy.set_soft_device_mode(False)\nx = ivy.array([1], device=\"cpu\")\ny = ivy.array([34], device=\"gpu:0\")\nivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: Backend Setting Implementation\nDESCRIPTION: Implementation of the backend setting mechanism in Ivy, managing the backend stack and function updates.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef set_backend(backend: str):\n\n    # un-modified ivy.__dict__\n    global ivy_original_dict\n    if not backend_stack:\n        ivy_original_dict = ivy.__dict__.copy()\n\n    # add the input backend to the global stack\n    backend_stack.append(backend)\n\n    # iterate through original ivy.__dict__\n    for k, v in ivy_original_dict.items():\n\n        # if method doesn't exist in the backend\n        if k not in backend.__dict__:\n            # add the original ivy method to backend\n            backend.__dict__[k] = v\n        # update global ivy.__dict__ with this method\n        ivy.__dict__[k] = backend.__dict__[k]\n```\n\n----------------------------------------\n\nTITLE: Implementing numpy.ndarray argsort instance method\nDESCRIPTION: Example implementation of argsort instance method for numpy.ndarray frontend class, showing how it delegates to the frontend function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef argsort(self, *, axis=-1, kind=None, order=None):\n    return np_frontend.argsort(self._ivy_array, axis=axis, kind=kind, order=order)\n```\n\n----------------------------------------\n\nTITLE: Implementing Partial Mixed Linear Function in PyTorch Backend\nDESCRIPTION: Implementation of the linear function in PyTorch backend showing how to handle partial mixed functionality with conditional behavior based on weight dimensions.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_types.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef linear(\n    x: torch.Tensor,\n    weight: torch.Tensor,\n    /,\n    *,\n    bias: Optional[torch.Tensor] = None,\n    out: Optional[torch.Tensor] = None,\n) -> torch.Tensor:\n    return torch.nn.functional.linear(x, weight, bias)\n\nlinear.partial_mixed_handler = lambda x, weight, **kwargs: weight.ndim == 2\n```\n\n----------------------------------------\n\nTITLE: PyTorch FX Graph Module\nDESCRIPTION: FX toolkit provides symbolic tracing and transformation of PyTorch modules through an intermediate representation. Uses Proxy objects to record operations and generates executable Python code from the graph.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/related_work/graph_tracers.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntorch.nn.Module\n```\n\n----------------------------------------\n\nTITLE: Transpiling PyTorch Network to TensorFlow\nDESCRIPTION: Example of using Ivy's transpiler to convert a PyTorch neural network class to TensorFlow. The transpiled code is immediately usable and is also saved to the ivy_transpiled_outputs directory for later reference.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\nimport tensorflow as tf\nimport torch\n\nclass Network(torch.nn.Module):\n\n    def __init__(self):\n     super().__init__()\n     self._linear = torch.nn.Linear(3, 3)\n\n    def forward(self, x):\n     return self._linear(x)\n\nTFNetwork = ivy.transpile(Network, source=\"torch\", target=\"tensorflow\")\n\nx = tf.convert_to_tensor([1., 2., 3.])\nnet = TFNetwork()\nnet(x)\n```\n\n----------------------------------------\n\nTITLE: Implementing IvyIndexError in NumPy Backend\nDESCRIPTION: Demonstrates how the NumPy backend implementation of ivy.all catches AxisError and raises IvyIndexError for consistency.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef all(\n    x: np.ndarray,\n    /,\n    *,\n    axis: Optional[Union[int, Sequence[int]]] = None,\n    keepdims: bool = False,\n    out: Optional[np.ndarray] = None,\n) -> np.ndarray:\n    try:\n        return np.asarray(np.all(x, axis=axis, keepdims=keepdims, out=out))\n    except np.AxisError as e:\n        raise ivy.utils.exceptions.IvyIndexError(error)\n```\n\n----------------------------------------\n\nTITLE: Configuring Mixed Backend Wrappers for Linear Function\nDESCRIPTION: Configuration of mixed backend wrappers for the linear function, specifying which wrappers should be added to primary implementation and which should be skipped.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_types.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlinear.mixed_backend_wrappers = {\n   \"to_add\": (\n     \"handle_out_argument\",\n     \"inputs_to_native_arrays\",\n     \"outputs_to_ivy_arrays\",\n   ),\n   \"to_skip\": (\"inputs_to_ivy_arrays\", \"handle_partial_mixed_function\"),\n}\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Compilation Implementation\nDESCRIPTION: Implementation of the compile function for TensorFlow backend using tf.function wrapper.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/ivy_as_a_transpiler.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncompile = lambda fn, dynamic=True, example_inputs=None,\\\n    static_argnums=None, static_argnames=None:\\\n        tf.function(fn)\n```\n\n----------------------------------------\n\nTITLE: Backend Handler Implementation\nDESCRIPTION: Core implementation of Ivy's backend handling system for managing framework selection and conversion.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef current_backend(*args, **kwargs):\n    global implicit_backend\n    # if a global backend has been set with set_backend then this will be returned\n    if backend_stack:\n        f = backend_stack[-1]\n        return f\n\n    # if no global backend exists, we try to infer the backend from the arguments\n    f = _determine_backend_from_args(list(args) + list(kwargs.values()))\n    if f is not None:\n        implicit_backend = f.current_backend_str()\n        return f\n    return importlib.import_module(_backend_dict[implicit_backend])\n```\n\n----------------------------------------\n\nTITLE: Using ivy.trace_graph() for Callable Tracing in RST\nDESCRIPTION: Demonstrates the usage of ivy.trace_graph() function, which traces a Callable or set of Callables into an Ivy graph. This one-liner simplifies the process of graph creation from callable objects.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n``ivy.trace_graph()``\n```\n\n----------------------------------------\n\nTITLE: Demonstrating IvyIndexError in NumPy and PyTorch\nDESCRIPTION: Shows how IvyIndexError is used to unify error messages across NumPy and PyTorch backends when using the ivy.all function with an invalid axis.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> x = ivy.array([0,0,1])\n>>> ivy.all(x, axis=2)\n<error_stack>\nIvyIndexError: numpy: all: AxisError: axis 2 is out of bounds for an array of dimension 1\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> x = ivy.array([0,0,1])\n>>> ivy.all(x, axis=2)\n<error_stack>\nIvyIndexError: torch: all: IndexError: Dimension out of range (expected to be in range of [-1, 0], but got 2)\n```\n\n----------------------------------------\n\nTITLE: Function Signature for ivy.execute_with_gradients in Python\nDESCRIPTION: The pseudo function signature for the ivy.execute_with_gradients function, which takes a callable function, inputs, input gradient indices, and output gradient indices to compute both function results and gradients.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/gradients.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef execute_with_gradients (\n    func : Callable,\n    xs : Any arbitrary nest,\n    xs_grad_idxs : Input indices,\n    ret_grad_idxs : Output indices,\n) :\n    return func_ret, grads\n```\n\n----------------------------------------\n\nTITLE: Implementing IvyBackendException Class in Python\nDESCRIPTION: Definition of the IvyBackendException class that inherits from IvyException, specifically designed to unify backend-specific exceptions.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/utils/exceptions.py\nclass IvyBackendException(IvyException):\n    def __init__(self, *messages, include_backend=False):\n        super().__init__(*messages, include_backend=include_backend)\n```\n\n----------------------------------------\n\nTITLE: Implementing Check_less Assertion Function\nDESCRIPTION: Defines a helper function check_less in ivy/utils/assertions.py to standardize value comparison and exception raising.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef check_less(x1, x2, allow_equal=False, message=\"\"):\n    # less_equal\n    if allow_equal and ivy.any(x1 > x2):\n        raise ivy.exceptions.IvyException(\n            f\"{x1} must be lesser than or equal to {x2}\"\n            if message == \"\"\n            else message\n        )\n    # less\n    elif not allow_equal and ivy.any(x1 >= x2):\n        raise ivy.exceptions.IvyException(\n            f\"{x1} must be lesser than {x2}\"\n            if message == \"\"\n            else message\n        )\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Soft Device Mode in Ivy (Python)\nDESCRIPTION: This snippet shows how soft device mode affects array operations in Ivy. With soft device mode enabled, input arrays are moved to the default device for operations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nivy.set_backend(\"torch\")\nivy.set_soft_device_mode(True)\nx = ivy.array([1], device=\"cpu\")\ny = ivy.array([34], device=\"gpu:0\")\nivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: Implementing Stack Function for TensorFlow Backend in Ivy\nDESCRIPTION: Backend implementation of stack operation for TensorFlow tensors using experimental numpy API.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef stack(\n    arrays: Union[Tuple[tf.Tensor], List[tf.Tensor]],\n    /,\n    *,\n    axis: int = 0,\n    out: Optional[Union[tf.Tensor, tf.Variable]] = None,\n) -> Union[tf.Tensor, tf.Variable]:\n    return tf.experimental.numpy.stack(arrays, axis)\n```\n\n----------------------------------------\n\nTITLE: Torch frontend add with type promotion\nDESCRIPTION: Implementation of torch frontend add function showing type promotion handling.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef add(input, other, *, alpha=1, out=None):\n    input, other = torch_frontend.promote_types_of_torch_inputs(input, other)\n    return ivy.add(input, other, alpha=alpha, out=out)\n```\n\n----------------------------------------\n\nTITLE: Setting Backend and Wrapping Functions in Ivy\nDESCRIPTION: Demonstrates how setting a backend in Ivy triggers function wrapping. The _wrap_function applies appropriate wrappers based on function decorators.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nivy.set_backend(backend_name)\n```\n\n----------------------------------------\n\nTITLE: Using Check_less in set_split_factor Function\nDESCRIPTION: Demonstrates the use of the check_less helper function in the set_split_factor function for input validation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@handle_exceptions\ndef set_split_factor(\n    factor: float,\n    device: Union[ivy.Device, ivy.NativeDevice] = None,\n    /,\n) -> None:\n    ivy.assertions.check_less(0, factor, allow_equal=True)\n    global split_factors\n    device = ivy.default(device, default_device())\n    split_factors[device] = factor\n```\n\n----------------------------------------\n\nTITLE: Implementing IvyException Base Class in Python\nDESCRIPTION: Definition of the IvyException base class that inherits from Python's Exception class. It handles backend-specific errors and provides unified error messaging.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/utils/exceptions.py\nclass IvyException(Exception):\n    def __init__(self, *messages, include_backend=False):\n        self.native_error = (\n            messages[0]\n            if len(messages) == 1\n            and isinstance(messages[0], Exception)\n            and not include_backend\n            else None\n        )\n        if self.native_error is None:\n            super().__init__(\n                _combine_messages(*messages, include_backend=include_backend)\n            )\n        else:\n            super().__init__(str(messages[0]))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Container Attribute Access and Method Calls in Python\nDESCRIPTION: This snippet shows how to access attributes and call methods on Container objects, including the use of __getattr__ for custom attribute handling.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/containers.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(y.__getattr__(\"count\", 1))\n{\n    c1: {\n        l1: 1,\n        l2: 0\n    },\n    l1: 1\n}\n\nprint(y.count(1))\n# doesn't work since essentially the argument 1 won't be passed to `__getattr__`\n\nprint(y.__getattr__(\"__add__\", [10]))\n{\n    c1: {\n        l1: [\n            3,\n            2,\n            1,\n            10\n        ],\n        l2: [\n            4,\n            5,\n            6,\n            10\n        ]\n    },\n    l1: [\n        1,\n        2,\n        3,\n        10\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Softplus with Superset Behavior (Compositional Approach)\nDESCRIPTION: Extended implementation of softplus in Ivy's TensorFlow backend with superset behavior, using a compositional approach. This includes beta and threshold parameters but is less efficient.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/superset_behaviour.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef softplus(x: Tensor,\n                 /,\n                 *,\n                 beta: Optional[Union[int, float]] = 1,\n                 threshold: Optional[Union[int, float]] = 20,\n                 out: Optional[Tensor] = None) -> Tensor:\n    res = (tf.nn.softplus(x * beta)) / beta\n    return tf.where(x * beta > threshold, x, res)\n```\n\n----------------------------------------\n\nTITLE: Implementing NumPy tan Function in Ivy Frontend\nDESCRIPTION: This code implements the NumPy tan function in the Ivy frontend. It handles various NumPy-specific arguments and behaviors using decorators, and ultimately calls the Ivy tan function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/functional/frontends/numpy/mathematical_functions/trigonometric_functions.py\n@handle_numpy_out\n@handle_numpy_dtype\n@to_ivy_arrays_and_back\n@handle_numpy_casting\n@from_zero_dim_arrays_to_scalar\ndef _tan(\n    x,\n    /,\n    out=None,\n    *,\n    where=True,\n    casting=\"same_kind\",\n    order=\"K\",\n    dtype=None,\n    subok=True,\n):\n    ret = ivy.tan(x, out=out)\n    if ivy.is_array(where):\n        ret = ivy.where(where, ret, ivy.default(out, ivy.zeros_like(ret)), out=out)\n    return ret\n```\n\n----------------------------------------\n\nTITLE: Exception Handling in Ivy Functions\nDESCRIPTION: The handle_exceptions wrapper catches native exceptions from different backends and unifies them into standardized IvyException or relevant subclasses.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nhandle_exceptions\n```\n\n----------------------------------------\n\nTITLE: Documenting Ivy Functions with reStructuredText Template\nDESCRIPTION: This template provides a structure for documenting an Ivy function and its corresponding Array and Container method implementations. It uses reStructuredText directives to automatically include function documentation from docstrings.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/functional_module.rst#2025-04-23_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n{{ name | escape | underline }}\n\n.. autofunction:: ivy.{{ name }}\n\n.. autoskippablemethod:: ivy.Array.{{ name }}\n\n.. autoskippablemethod:: ivy.Container.{{ name }}\n\n```\n\n----------------------------------------\n\nTITLE: Getting Model Predictions\nDESCRIPTION: Processes the model output to get the final classification prediction.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npredicted_label = logits.argmax(-1).item()\nprint(model.config.id2label[predicted_label])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Container attributes and methods with shape property\nDESCRIPTION: This example shows how the ivy.Container class handles attribute access by recursively applying operations to all leaves. The shape property is queried on container leaves, showing how attribute queries propagate through the nested structure.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/containers.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nx = ivy.Container(a=ivy.array([0.]), b=ivy.Container(a=ivy.array([[0.]]), b=ivy.array([1., 2., 3.])))\nprint(x.shape)\n{\n    a: [\n        1\n    ],\n    b: {\n        a: [\n            1,\n            1\n        ],\n        b: [\n            3\n        ]\n    }\n}\n\nprint(x.ndim)\n{\n    a: 1,\n    b: {\n        a: 2,\n        b: 1\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Array Caching Example in Python\nDESCRIPTION: Shows how the tracer caches constant arrays and their operations to reduce computation time through the array_caching parameter.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\n\nivy.set_backend(\"torch\")\n\ndef fn(x):\n    b = ivy.array([2])\n    a = ivy.array([2])\n    z = x ** (a + b)\n    return z\n\ncomp_func = ivy.trace_graph(fn, args=(x,))\n```\n\n----------------------------------------\n\nTITLE: Implementing IvyError and Specialized Exception Classes in Python\nDESCRIPTION: Definition of IvyError and related specialized exception classes that help unify error handling across different backends for specific error types.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/utils/exceptions.py\nclass IvyError(IvyException):\n    def __init__(self, *messages, include_backend=False):\n        super().__init__(*messages, include_backend=include_backend)\n```\n\n----------------------------------------\n\nTITLE: Decorator Order for Ivy Functions\nDESCRIPTION: Lists the recommended order of decorators for Ivy functions. This order is crucial for proper function behavior and test accuracy.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n@handle_complex_input\n@infer_device\n@handle_device_shifting\n@infer_dtype\n@handle_array_function\n@outputs_to_ivy_arrays\n@outputs_to_ivy_shapes\n@outputs_to_native_arrays\n@inputs_to_native_arrays\n@inputs_to_native_shapes\n@inputs_to_ivy_arrays\n@handle_out_argument\n@handle_view_indexing\n@handle_view\n@handle_array_like_without_promotion\n@handle_partial_mixed_function\n@handle_nestable\n@handle_ragged\n@handle_backend_invalid\n@handle_exceptions\n@handle_nans\n```\n\n----------------------------------------\n\nTITLE: Running Array API Tests via Terminal\nDESCRIPTION: Command for running Array API tests for a specific backend and test category using the provided shell script. This allows testing adherence to the Array API Standard for a particular backend framework like JAX, TensorFlow, NumPy, or PyTorch.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# /ivy\n/bin/bash -e ./scripts/shell/scripts/shell/test_array_api.sh jax test_linalg\n```\n\n----------------------------------------\n\nTITLE: Adding Nestable Function Documentation\nDESCRIPTION: Example showing how to add documentation for nestable functions that accept Container instances.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/docstrings.rst#2025-04-23_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n+Both the description and the type hints above assumes an array input for simplicity,\n+but this function is *nestable*, and therefore also accepts :class:`ivy.Container`\n+instances in place of any of the arguments.\n```\n\n----------------------------------------\n\nTITLE: Implementing Submodule Helper Functions\nDESCRIPTION: Demonstrates the implementation of helper functions used across multiple backend implementations to keep code clean and reusable.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/utils/assertions.py\ndef check_fill_value_and_dtype_are_compatible(fill_value, dtype):\n    if (\n        not (\n            (ivy.is_int_dtype(dtype) or ivy.is_uint_dtype(dtype))\n            and isinstance(fill_value, int)\n        )\n        and not (\n            ivy.is_complex_dtype(dtype) and isinstance(fill_value, (float, complex))\n        )\n        and not (\n            ivy.is_float_dtype(dtype)\n            and isinstance(fill_value, (float, np.float32))\n            or isinstance(fill_value, bool)\n        )\n    ):\n        raise ivy.utils.exceptions.IvyException(\n            f\"the fill_value: {fill_value} and data type: {dtype} are not compatible\"\n        )\n```\n\n----------------------------------------\n\nTITLE: PyTorch One-Hot Frontend Implementation\nDESCRIPTION: Frontend implementation of PyTorch's one_hot function using Ivy's abstraction layer.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef one_hot(tensor, num_classes=-1):\n    return ivy.one_hot(tensor, num_classes)\n```\n\n----------------------------------------\n\nTITLE: Handling Same Device Operations in Ivy (Python)\nDESCRIPTION: This snippet shows how Ivy handles operations when all input arrays are on the same device, even with soft device mode disabled.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nivy.set_backend(\"torch\")\nivy.set_soft_device_mode(False)\nx = ivy.array([1], device=\"gpu:0\")\ny = ivy.array([34], device=\"gpu:0\")\nivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: PyTorch Remainder Implementation with Type Handling\nDESCRIPTION: Complex implementation of remainder operation that handles different data types and conditional native out support.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef remainder(\n    x1: Union[float, torch.Tensor],\n    x2: Union[float, torch.Tensor],\n    /,\n    *,\n    modulus: bool = True,\n    out: Optional[torch.Tensor] = None,\n) -> torch.Tensor:\n    x1, x2 = ivy.promote_types_of_inputs(x1, x2)\n    if not modulus:\n        res = x1 / x2\n        res_floored = torch.where(res >= 0, torch.floor(res), torch.ceil(res))\n        diff = res - res_floored\n        diff, x2 = ivy.promote_types_of_inputs(diff, x2)\n        if ivy.exists(out):\n            if out.dtype != x2.dtype:\n                return ivy.inplace_update(\n                    out, torch.round(torch.mul(diff, x2)).to(out.dtype)\n                )\n        return torch.round(torch.mul(diff, x2), out=out).to(x1.dtype)\n    return torch.remainder(x1, x2, out=out).to(x1.dtype)\n\n\nremainder.support_native_out = True\n```\n\n----------------------------------------\n\nTITLE: Implementing Logspace Function for TensorFlow Backend in Ivy\nDESCRIPTION: Custom implementation of logspace operation for TensorFlow using composition of existing ops.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef logspace(\n    start: Union[tf.Tensor, tf.Variable, int],\n    stop: Union[tf.Tensor, tf.Variable, int],\n    num: int,\n    base: float = 10.0,\n    axis: Optional[int] = None,\n    *,\n    dtype: tf.DType,\n    device: str,\n) -> Union[tf.Tensor, tf.Variable]:\n    power_seq = ivy.linspace(start, stop, num, axis, dtype=dtype, device=device)\n    return base**power_seq\n```\n\n----------------------------------------\n\nTITLE: Running Ivy Tests for All Submodules in Python\nDESCRIPTION: This snippet demonstrates how to run tests for all submodules of ivy_core, ivy_nn, or ivy_stateful using Python scripts. It specifies the backend using a numeric argument.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_16\n\nLANGUAGE: python\nCODE:\n```\npython scripts/setup_tests/run_ivy_nn_test.py 1\n```\n\n----------------------------------------\n\nTITLE: Adding Output Parameter to Array API Docstring\nDESCRIPTION: Example showing how to add the 'out' parameter documentation to extend Array API Standard functionality.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/docstrings.rst#2025-04-23_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n+out\n+    optional output array, for writing the result to. It must have a shape that the inputs\n+    broadcast to.\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies List\nDESCRIPTION: Specifies required Python packages for the project. Each line represents a package name and optional version constraint. Notable dependencies include numpy for numerical computing, cryptography >= 40.0.0 for security features, and various utility packages.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/requirements/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nastor\ncryptography>=40.0.0\ndill\neinops\ngast\nnetworkx\nnumpy\npackaging\npsutil\nrequests\nruff\ntqdm\n```\n\n----------------------------------------\n\nTITLE: Numpy matrix class implementation\nDESCRIPTION: Implementation of the numpy.matrix class in Ivy's frontend showing initialization and data handling.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass matrix:\n    def __init__(self, data, dtype=None, copy=True):\n        self._init_data(data, dtype)\n\n    def _init_data(self, data, dtype):\n        if isinstance(data, str):\n            self._process_str_data(data, dtype)\n        elif isinstance(data, (list, ndarray)) or ivy.is_array(data):\n            if isinstance(data, ndarray):\n                data = data.ivy_array\n            if ivy.is_array(data) and dtype is None:\n                dtype = data.dtype\n            data = ivy.array(data, dtype=dtype)\n            self._data = data\n        else:\n            raise ivy.exceptions.IvyException(\"data must be an array, list, or str\")\n        ivy.assertions.check_equal(\n            len(ivy.shape(self._data)), 2, message=\"data must be 2D\"\n        )\n        self._dtype = self._data.dtype\n        self._shape = ivy.shape(self._data)\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Instance Method in Python\nDESCRIPTION: Example of how an instance method is implemented for the ivy.Array class, calling the corresponding function from the functional API.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/arrays.rst#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef add(self, x2):\n    return ivy.add(self._data, x2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Stack Function for JAX Backend in Ivy\nDESCRIPTION: Backend implementation of stack operation for JAX arrays, wrapping jnp.stack with Ivy's unified interface.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef stack(\n    arrays: Union[Tuple[JaxArray], List[JaxArray]],\n    /,\n    *,\n    axis: int = 0,\n    out: Optional[JaxArray] = None,\n) -> JaxArray:\n    return jnp.stack(arrays, axis=axis)\n```\n\n----------------------------------------\n\nTITLE: Graph Construction Process with Backward Traversal\nDESCRIPTION: Outlines the graph connection function that constructs the computational graph through backward traversal, starting from outputs and tracing back to inputs while optimizing the structure.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef connect():\n    \"\"\"Connects functions together into the final graph.\"\"\"\n    # Start from output\n    # Traverse backwards through operations\n    # Track parameters and functions\n    return optimized_graph\n```\n\n----------------------------------------\n\nTITLE: Building Ivy Documentation Using Docker Hub Image\nDESCRIPTION: This snippet demonstrates how to build the Ivy documentation using the pre-built unifyai/doc-builder Docker image from Docker Hub. It mounts the current directory to the container and outputs the built docs to docs/build.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/building_the_docs.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd <ivy directory>\ndocker run --rm -v $(pwd):/project unifyai/doc-builder\n```\n\n----------------------------------------\n\nTITLE: Adding Alias for Frontend Function\nDESCRIPTION: Example of how to add an alias for a frontend function implementation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/open_tasks.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n<alias_name> = <function_name>\n```\n\n----------------------------------------\n\nTITLE: TensorFlow frontend add with type checking\nDESCRIPTION: Implementation of TensorFlow frontend add function with explicit type checking.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n@to_ivy_arrays_and_back\ndef add(x, y, name=None):\n    x, y = check_tensorflow_casting(x, y)\n    return ivy.add(x, y)\n```\n\n----------------------------------------\n\nTITLE: Current Closure-less While Loop Transformation\nDESCRIPTION: The current version of the transformed function using a purely functional approach without closures. It uses Ivy's WhileLoop and IfElse constructs that take state as parameters instead of using nonlocal variables.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/README.md#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef ivy__while_with_if(i, x, w, b):\n            do_return = False\n            retval_ = None\n\n            def loop_body(res, i):\n\n                def if_body(i):\n                    i += 1\n                    return (i,)\n\n                def else_body(i):\n                    return (i,)\n                (i,) = ivy.IfElse((i == 7), if_body, else_body, (i,))\n                res = ((x * w) + b)\n                i += 1\n                return (res, i)\n\n            def loop_test(res, i):\n                return (i <= 10)\n            res = None\n            (res, i) = ivy.WhileLoop(loop_test, loop_body, (res, i))\n            try:\n                do_return = True\n                retval_ = res\n            except:\n                do_return = False\n                raise\n            return ivy__.return_none_or_val(retval_, do_return)\n```\n\n----------------------------------------\n\nTITLE: Implementing Backend-Specific Functions\nDESCRIPTION: Illustrates how functions are implemented in backend-specific modules, such as torch. Note the differences in type hints and argument handling compared to the Ivy API.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/navigating_the_code.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef my_func(\n    x: torch.Tensor,\n    /,\n    axes: Union[int, Sequence[int]],\n    *,\n    dtype: torch.dtype,\n    device: torch.device,\n    out: Optional[torch.Tensor] = None\n) -> torch.Tensor:\n    return torch.function_name(x, axes, dtype, device, out)\n```\n\n----------------------------------------\n\nTITLE: Using reproduce_failure Decorator in Array API Tests\nDESCRIPTION: Example of applying the reproduce_failure decorator to a test function that failed during execution. This decorator helps recreate specific test failures by preserving the exact inputs that caused the previous failure, useful for debugging and fixing issues.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@pytest.mark.parametrize(\"ctx\", make_binary_params(\"remainder\", dh.numeric_dtypes))\n@given(data=st.data())\n@reproduce_failure('6.55.0', b'AXic42BAAowcnP+RuMwMABAeAR0=')\ndef test_remainder(ctx, data):\n    left = data.draw(ctx.left_strat, label=ctx.left_sym)\n    right = data.draw(ctx.right_strat, label=ctx.right_sym)\n    if ctx.right_is_scalar:\n        assume(right != 0)\n    else:\n        assume(not xp.any(right == 0))\n\n    res = ctx.func(left, right)\n\n    binary_param_assert_dtype(ctx, left, right, res)\n    binary_param_assert_shape(ctx, left, right, res)\n    binary_param_assert_against_refimpl(ctx, left, right, res, \"%\", operator.mod)\n```\n\n----------------------------------------\n\nTITLE: Function Call Tree Example in Python\nDESCRIPTION: Example of a nested function call with control flow that demonstrates how Autograph_Ivy handles function call trees. The example includes a foo function that's called inside another function with a while loop.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x,y):\n  if x > y:\n    x+=20\n  else:\n    x+=10\n  return x\n\ndef func(x,y):\n    val = foo(x,y)\n    i=0\n    while i < val:\n        y+=1\n        z = ivy.array([1,2,3])\n        w = tf.convert_to_tensor([1,2,3])\n        i+=1\n\n    return y\n```\n\n----------------------------------------\n\nTITLE: Linear Algebra Operations Status List\nDESCRIPTION: A list of linear algebra operations with commented entries indicating implementation issues across different frameworks. Several operations are commented out due to known issues with specific frameworks, with corresponding GitHub issue references.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/linalg.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ncholesky\n#cross #fails for jax, torch, issue: https://github.com/pytorch/pytorch/issues/76588\ndet\ndiagonal\neigh\n#eigvalsh\n# inv  # failing sporadically for jax - https://github.com/data-apis/array-api-tests/issues/117\n#matmul # failing for torch - https://github.com/data-apis/array-api-tests/issues/117\n#matrix_norm # failing for jax non-deterministically\n#matrix_power # failing for jax, torch, and tensorflow- waiting on fix for https://github.com/data-apis/array-api-tests/issues/117\n#matrix_rank # failing for numpy (KeyError from a dtype), tensorflow (incompatible shapes)\nmatrix_transpose\nouter\npinv\nqr\n#slogdet # failing for numpy due to tol issues e.g. x = 0.6931471805599453, y = ivy.array(0.69314718) not equal\nsolve\nsvd\nsvdvals\ntensordot\n#trace # failing for jax, numpy, tensorflow, torch due to issues with dtypes in output in test: https://github.com/data-apis/array-api/issues/202\n#vecdot #failing for torch, due to unexpected behaviour on some dtypes while type-casting (https://github.com/pytorch/pytorch/issues/84530)\nvector_norm\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeros Function in JAX\nDESCRIPTION: Backend-specific implementation of the zeros function for JAX, with required device and dtype arguments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef zeros(\n    shape: Union[int, Sequence[int]],\n    *,\n    dtype: jnp.dtype,\n    device: jaxlib.xla_extension.Device,\n) -> JaxArray:\n```\n\n----------------------------------------\n\nTITLE: JAX Jaxpr Representation\nDESCRIPTION: jax.core.Jaxpr represents a typed function with parameters and results. Used by JAX transformations to create statically-typed expressions from Python functions.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/related_work/graph_tracers.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\njax.core.Jaxpr\n```\n\n----------------------------------------\n\nTITLE: Debugging Numerical Precision Issue in Acosh Function (Python)\nDESCRIPTION: This snippet shows a failing test case for the acosh function due to small numerical differences between JAX and TensorFlow backends. The solution involves adding relative and absolute tolerance parameters to the test function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@handle_test(\n    fn_tree=\"functional.ivy.acosh\",\n    dtype_and_x=helpers.dtype_and_values(\n        available_dtypes=helpers.get_dtypes(\"float\"),\n        min_value=1,\n        large_abs_safety_factor=4,\n        small_abs_safety_factor=4,\n    ),\n)\ndef test_acosh(*, dtype_and_x, test_flags, backend_fw, fn_name, on_device):\n    input_dtype, x = dtype_and_x\n    helpers.test_function(\n        input_dtypes=input_dtype,\n        test_flags=test_flags,\n        backend_to_test=backend_fw,\n        fn_name=fn_name,\n        on_device=on_device,\n        rtol_=1e-2,\n        atol_=1e-2,\n        x=x[0],\n    )\n```\n\n----------------------------------------\n\nTITLE: Setting Backend in Array API Tests\nDESCRIPTION: Code modification to set the backend explicitly in the _array_module.py file of the array_api_tests submodule. This needs to be done to run specific tests locally through terminal or IDE, replacing the default 'array_module = None' line.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport ivy as array_module\narray_module.set_backend(\"jax\") # or numpy, tensorflow, torch\n```\n\n----------------------------------------\n\nTITLE: Function Path Examples - Python Frontend API\nDESCRIPTION: Examples showing different types of function path duplications in Python frontend APIs, demonstrating how the same functionality can be accessed through different namespace paths.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nnp.asarray  # Example of type 1 duplication - same path\ntf.math.tan    # Example of type 2 duplication - different paths\ntf.raw_ops.Tan # Another path to same functionality\n```\n\n----------------------------------------\n\nTITLE: Array Mathematical Operations List\nDESCRIPTION: List of fundamental array operations including max, mean, min, product, standard deviation, sum and variance. Notes indicate that product and sum operations currently fail for PyTorch due to a bug in the Array API test suite (Issue #10).\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/statistical_functions.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nmax\nmean\nmin\nprod #failing for torch due to bug in Array API test suite (https://github.com/data-apis/array-api-tests/issues/10#issuecomment-1068840049)\nstd\nsum #failing for torch due to the same bug as prod\nvar\n```\n\n----------------------------------------\n\nTITLE: Implementing Compositional Function (cross_entropy) in Ivy\nDESCRIPTION: Example of a compositional function implementation. Compositional functions are built using other Ivy functions and don't have backend-specific implementations, making them portable across all backends.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_types.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef cross_entropy(\n    true: Union[ivy.Array, ivy.NativeArray],\n    pred: Union[ivy.Array, ivy.NativeArray],\n    /,\n    *,\n    axis: int = -1,\n    epsilon: float = 1e-7,\n    reduction: str = \"mean\",\n    out: Optional[ivy.Array] = None\n) -> ivy.Array:\n    ivy.utils.assertions.check_elem_in_list(reduction, [\"none\", \"sum\", \"mean\"])\n    pred = ivy.clip(pred, epsilon, 1 - epsilon)\n    log_pred = ivy.log(pred)\n    return _reduce_loss(reduction, log_pred * true, axis, out)\n```\n\n----------------------------------------\n\nTITLE: JAX Tangent Implementation\nDESCRIPTION: Simple JAX backend implementation of the tan function without native out support.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef tan(x: JaxArray, /, *, out: Optional[JaxArray] = None) -> JaxArray:\n    return jnp.tan(x)\n```\n\n----------------------------------------\n\nTITLE: Initializing NumPy ufunc in Ivy Frontend\nDESCRIPTION: This snippet shows how to initialize a NumPy universal function (ufunc) in the Ivy frontend's __init__ file. It imports a private function and creates a ufunc object with the same name as the original NumPy function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/functional/frontends/numpy/__init__.py\nfrom ivy.functional.frontends.numpy.mathematical_functions.arithmetic_operations import _add\nadd = ufunc(\"_add\")\n```\n\n----------------------------------------\n\nTITLE: Building Ivy Documentation Without Docker\nDESCRIPTION: This snippet shows how to build the Ivy documentation without Docker by using the make_docs_without_docker.sh script. The script installs required dependencies and builds the documentation for the specified Ivy directory.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/building_the_docs.rst#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd doc-builder\n./make_docs_without_docker.sh <ivy directory>\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy from Source\nDESCRIPTION: Command for installing the latest version of Ivy directly from the GitHub repository, allowing access to the most recent changes.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\npip install git+https://github.com/unifyai/ivy.git\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code Python Test Settings in JSON\nDESCRIPTION: JSON configuration for VS Code settings.json file to enable PyTest testing in the Ivy project. Specifies test directories and PyTest configuration options.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_23\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"python.testing.pytestArgs\": [\n      \"./ivy_tests/test_ivy/\",\n      \"./ivy_tests/array_api_testing/test_array_api/\",\n      \"--continue-on-collection-errors\"\n   ],\n   \"python.testing.unittestEnabled\": false,\n   \"python.testing.pytestEnabled\": true,\n   \"python.testing.autoTestDiscoverOnSaveEnabled\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Inplace Updates in JAX\nDESCRIPTION: JAX implementation of inplace_update function. JAX does not natively support inplace updates, so this implementation only updates ivy.Array instances and handles view updates.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef inplace_update(\n    x: Union[ivy.Array, JaxArray],\n    val: Union[ivy.Array, JaxArray],\n    /,\n    *,\n    ensure_in_backend: bool = False,\n    keep_input_dtype: bool = False,\n) -> ivy.Array:\n    if ivy.is_array(x) and ivy.is_array(val):\n        if ensure_in_backend:\n            raise ivy.utils.exceptions.IvyException(\n                \"JAX does not natively support inplace updates\"\n            )\n        if keep_input_dtype:\n            val = ivy.astype(val, x.dtype)\n        (x_native, val_native), _ = ivy.args_to_native(x, val)\n        if ivy.is_ivy_array(x):\n            x.data = val_native\n            # Handle view updates\n            if ivy.exists(x._base):\n                base = x._base\n                base_idx = ivy.arange(base.size).reshape(base.shape)\n                for fn, args, kwargs, index in x._manipulation_stack:\n                    kwargs[\"copy\"] = True\n                    base_idx = ivy.__dict__[fn](base_idx, *args, **kwargs)\n                    base_idx = base_idx[index] if ivy.exists(index) else base_idx\n                base_flat = base.data.flatten()\n                base_flat = base_flat.at[base_idx.data.flatten()].set(\n                    val_native.flatten()\n                )\n\n                base.data = base_flat.reshape(base.shape)\n\n                for ref in base._view_refs:\n                    view = ref()\n                    if ivy.exists(view) and view is not x:\n                        _update_view(view, base)\n\n            else:\n                for ref in x._view_refs:\n                    view = ref()\n                    if ivy.exists(view):\n                        _update_view(view, x)\n        else:\n            raise ivy.utils.exceptions.IvyException(\n                \"JAX does not natively support inplace updates\"\n            )\n        return x\n    else:\n        return val\n```\n\n----------------------------------------\n\nTITLE: NumPy Tangent Implementation with Native Out Support\nDESCRIPTION: NumPy backend implementation of the tan function with native out support using the support_native_out attribute.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@_scalar_output_to_0d_array\ndef tan(x: np.ndarray, /, *, out: Optional[np.ndarray] = None) -> np.ndarray:\n    return np.tan(x, out=out)\n\n\ntan.support_native_out = True\n```\n\n----------------------------------------\n\nTITLE: Implementing TensorFlow tan Function in Ivy Frontend\nDESCRIPTION: This code implements the TensorFlow tan function in the Ivy frontend. It simply wraps the Ivy tan function and ignores the 'name' argument, which is not supported in Ivy.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# in ivy/functional/frontends/tensorflow/math.py\n@to_ivy_arrays_and_back\ndef tan(x, name=None):\n    return ivy.tan(x)\n```\n\n----------------------------------------\n\nTITLE: Numpy frontend add with casting handling\nDESCRIPTION: Implementation of numpy frontend add function with special casting rules.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/ivy_frontends.rst#2025-04-23_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n@handle_numpy_out\n@handle_numpy_dtype\n@to_ivy_arrays_and_back\n@handle_numpy_casting\n@from_zero_dim_arrays_to_scalar\ndef _add(\n    x1,\n    x2,\n    /,\n    out=None,\n    *,\n    where=True,\n    casting=\"same_kind\",\n    order=\"k\",\n    dtype=None,\n    subok=True,\n):\n    x1, x2 = promote_types_of_numpy_inputs(x1, x2)\n    ret = ivy.add(x1, x2, out=out)\n    if ivy.is_array(where):\n        ret = ivy.where(where, ret, ivy.default(out, ivy.zeros_like(ret)), out=out)\n    return ret\n```\n\n----------------------------------------\n\nTITLE: Pulling Ivy Docker image\nDESCRIPTION: This command pulls a pre-built Docker image for Ivy, which includes all supported frameworks and relevant packages.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/get_started.rst#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull ivyllc/ivy:latest\n```\n\n----------------------------------------\n\nTITLE: Project Directory Structure\nDESCRIPTION: Shows the complete directory structure of the source-to-source translator project, including main components, translation infrastructure, transformations, configurations, and utility modules.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/README.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nsource_to_source_translator/\n├── main.py                     # Main entry point exposing transpile() API\n├── translations/               # Core translation infrastructure\n│   ├── translator.py          # Main Translator class implementation\n│   └── data/                  # Data classes for objects and globals\n├── transformations/           # AST transformation modules\n│   ├── transformers/          # Individual transformer implementations\n│   │   ├── annotation_transformer/     # Type annotation handling\n│   │   ├── canonicalize_transformer/   # Import and call canonicalization\n│   │   ├── method_transformer/         # Method call conversions\n│   │   └── ...                        # Other transformers\n│   └── configurations/        # Transformer-specific configs\n├── configs/                   # Stage-specific translation configs\n├── utils/                     # Utility functions\n│   ├── ast_utils.py          # AST manipulation and source code generation\n│   ├── cache_utils.py        # Caching utilities\n│   └── logging_utils.py      # Logging infrastructure\n│   └── ...                   # other utilities\n└── exceptions/               # Custom exception classes\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Test with Pytest\nDESCRIPTION: Command to run a specific test function in the Ivy test suite using pytest.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npytest ivy_tests/test_ivy/test_frontends/test_jax/test_numpy/test_manipulations.py::test_jax_transpose\n```\n\n----------------------------------------\n\nTITLE: Function Wrapping Process in Backend Setting\nDESCRIPTION: During backend setting, the _wrap_function checks the attributes of functions to determine which wrapping functions to apply, then wraps the function with all applicable wrappers.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n_wrap_function\n```\n\n----------------------------------------\n\nTITLE: Implementing Zeros Function in NumPy\nDESCRIPTION: Backend-specific implementation of the zeros function for NumPy, with required device and dtype arguments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef zeros(\n    shape: Union[int, Sequence[int]],\n    *,\n    dtype: np.dtype,\n    device: str,\n) -> np.ndarray:\n```\n\n----------------------------------------\n\nTITLE: Implementing IvyIndexError in Jax Backend\nDESCRIPTION: Shows how the Jax backend implementation of ivy.all catches ValueError and raises IvyIndexError for consistency across backends.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/exception_handling.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef all(\n    x: JaxArray,\n    /,\n    *,\n    axis: Optional[Union[int, Sequence[int]]] = None,\n    keepdims: bool = False,\n    out: Optional[JaxArray] = None,\n) -> JaxArray:\n    x = jnp.array(x, dtype=\"bool\")\n    try:\n        return jnp.all(x, axis, keepdims=keepdims)\n    except ValueError as error:\n        raise ivy.utils.exceptions.IvyIndexError(error)\n```\n\n----------------------------------------\n\nTITLE: Type Hint Example in Python Documentation\nDESCRIPTION: Example showing how type hints could be structured for nestable functions, demonstrating the Union type with original_type and ivy.Container.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_arguments.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nUnion[original_type, ivy.Container]\n```\n\n----------------------------------------\n\nTITLE: Updating Git Submodule for Array API Tests\nDESCRIPTION: Commands for initializing and updating the Array API test suite submodule in the Ivy repository. The first command initializes the local config file and checks out the submodule, while the second command pulls and merges changes from the upstream remote repository.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# to initialise local config file and fetch + checkout submodule (not needed every time)\ngit submodule update --init --recursive\n\n# pulls changes from the upstream remote repo and merges them\ngit submodule update --recursive --remote --merge\n```\n\n----------------------------------------\n\nTITLE: Output Directory Structure\nDESCRIPTION: Illustrates the structure of the output directory containing the translated code for different target frameworks including TensorFlow, PyTorch Frontend, and Ivy.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/README.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nivy_transpiled_outputs/\n├── tensorflow_outputs/        # Target: TensorFlow\n│   ├── __init__.py\n│   └── model.py\n├── torch_frontend_outputs/    # Target: PyTorch Frontend\n│   ├── __init__.py\n│   └── model.py\n└── ivy_outputs/              # Target: Ivy\n    ├── __init__.py\n    └── model.py\n```\n\n----------------------------------------\n\nTITLE: Array Function and Complex Number Handling\nDESCRIPTION: Miscellaneous wrappers like handle_array_function enable integration of custom classes with Ivy, while handle_complex_input provides support for complex numbers using the complex_mode keyword argument.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nhandle_array_function\nhandle_complex_input\n```\n\n----------------------------------------\n\nTITLE: Previously Generated While Loop Transformation with Closures\nDESCRIPTION: The previous version of the transformed function that used closures and nonlocal keywords to manage state. This represents the older approach before the refactoring to a purely functional style.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/README.md#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef ivy__while_with_if(i, x, w, b):\n\n            def get_state_1():\n                return (res, i)\n\n            def set_state_1(vars_):\n                nonlocal res, i\n                (res, i) = vars_\n\n            def loop_body():\n                nonlocal res, i\n\n                def get_state():\n                    return (i,)\n\n                def set_state(vars_):\n                    nonlocal i\n                    (i,) = vars_\n\n                def if_body():\n                    nonlocal i\n                    i += 1\n\n                def else_body():\n                    nonlocal i\n                    pass\n                ivy.if_stmt((i == 7), if_body, else_body, get_state, set_state)\n                res = ((x * w) + b)\n                i += 1\n\n            def loop_test():\n                return (i <= 10)\n            res = None\n            ivy.while_stmt(loop_test, loop_body, get_state_1, set_state_1)\n            return res\n```\n\n----------------------------------------\n\nTITLE: Defining a PyTorch Model\nDESCRIPTION: Creates a simple PyTorch neural network model with a single linear layer. The model takes input of size 10 and produces output of size 10.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass TorchModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.lin = nn.Linear(10, 10)\n    \n    def forward(self, x):\n        return self.lin(x)\n```\n\n----------------------------------------\n\nTITLE: Fetching Ivy Binaries with Python\nDESCRIPTION: Python code example showing how to import Ivy and fetch missing binaries using the cleanup_and_fetch_binaries utility function.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport ivy\n\nivy.utils.cleanup_and_fetch_binaries()\n```\n\n----------------------------------------\n\nTITLE: Cloning Ivy Repository with SSH\nDESCRIPTION: Command to clone the Ivy repository using SSH with submodules\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_0\n\nLANGUAGE: none\nCODE:\n```\ngit clone --recurse-submodules git@github.com:YOUR_USERNAME/ivy.git\n```\n\n----------------------------------------\n\nTITLE: Stage-Specific Implementation Structure - Python Module Organization\nDESCRIPTION: Demonstrates the structure of stage-specific transformer implementations extending from a base transformer class.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nrecursive_transformer/\n├── base_transformer.py              # Defines BaseRecurser\n├── frontend_torch_recursive_transformer.py  # For torch_frontend-to-ivy stage\n└── ivy_recursive_transformer.py            # For ivy-to-target stage\n```\n\n----------------------------------------\n\nTITLE: Docker Interactive Mode Commands\nDESCRIPTION: Commands for running Ivy Docker container in interactive mode with different configurations\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it unifyai/ivy bash\ndocker run --rm -it unifyai/ivy python3\ndocker run --rm -it -v /local_path_to_ivy/ivy/ivy:/ivy/ivy unifyai/ivy bash\n```\n\n----------------------------------------\n\nTITLE: PyTorch Cumprod Backend Implementation\nDESCRIPTION: Backend implementation of cumprod for PyTorch, handling both exclusive and non-exclusive cumulative products.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef cumprod(\n    x: torch.Tensor,\n    axis: int = 0,\n    exclusive: bool = False,\n    *,\n    out: Optional[torch.Tensor] = None,\n) -> torch.Tensor:\n    if exclusive:\n        x = torch.transpose(x, axis, -1)\n        x = torch.cat((torch.ones_like(x[..., -1:]), x[..., :-1]), -1, out=out)\n        res = torch.cumprod(x, -1, out=out)\n        return torch.transpose(res, axis, -1)\n    return torch.cumprod(x, axis, out=out)\n```\n\n----------------------------------------\n\nTITLE: Previous Function Call Tree Transformation with Closures\nDESCRIPTION: The previous version of the transformed function for handling call trees, using closures and nonlocal keywords. This shows how the original code manages nested function calls in the earlier implementation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/control_flow_experimental/README.md#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef ivy__func(x, y):\n            val = converted_call(foo, (x, y), None)\n            i = 0\n\n            def get_state():\n                return (y, i)\n\n            def set_state(vars_):\n                nonlocal y, i\n                (y, i) = vars_\n\n            def loop_body():\n                nonlocal y, i\n                y += 1\n                z = converted_call(ivy.array, ([1, 2, 3],), None)\n                w = converted_call(tf.convert_to_tensor, ([1, 2, 3],), None)\n                i += 1\n\n            def loop_test():\n                return (i < val)\n            w = None\n            z = None\n            ivy.while_stmt(loop_test, loop_body, get_state, set_state)\n            return y\n```\n\n----------------------------------------\n\nTITLE: Converting Shape Objects in Function Arguments and Results\nDESCRIPTION: Various wrappers are used to handle shape conversion between Ivy's Shape class and backend-specific NativeShape classes. These include inputs_to_native_shapes, outputs_to_ivy_shapes, and to_native_shapes_and_back.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_wrapping.rst#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ninputs_to_native_shapes\noutputs_to_ivy_shapes\nto_native_shapes_and_back\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Tangent Implementation\nDESCRIPTION: TensorFlow backend implementation of the tan function without native out support.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/inplace_updates.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef tan(\n    x: Union[tf.Tensor, tf.Variable],\n    /,\n    *,\n    out: Optional[Union[tf.Tensor, tf.Variable]] = None,\n) -> Union[tf.Tensor, tf.Variable]:\n    return tf.tan(x)\n```\n\n----------------------------------------\n\nTITLE: Cloning Ivy Repository with GitHub CLI\nDESCRIPTION: Command to clone the Ivy repository using GitHub CLI with submodules\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_2\n\nLANGUAGE: none\nCODE:\n```\ngh repo clone YOUR_USERNAME/ivy your_folder -- --recurse-submodules\n```\n\n----------------------------------------\n\nTITLE: Directory Structure of Graph Tracer Project\nDESCRIPTION: Shows the file organization of the Graph Tracer project with directories for special operations, conversion utilities, graph construction, and other core components.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/tracer/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\ntracer/\n├── special_ops/                # Handling tracing of higher-order functions\n│   ├── builtin_helpers.py     # Helpers for built-in(len, min, max etc.) function tracing\n│   ├── vmap_helpers.py        # Helpers for vectorized map(vmap) operations\n├── conversion.py              # Handling conversions between frameworks/proxies\n├── exchange.py                # Graph serialization/deserialization utilities\n├── globals.py                 # Global variables for tracing process\n├── graph.py                   # Graph construction and manipulation\n├── helpers.py                 # General utility functions for tracing\n├── param.py                   # Parameter handling and management\n├── reloader.py                # Module reloading utilities\n├── tracked_var_proxy.py       # Proxy classes for variable tracking\n├── tracked_var_replacements.py # Replacement functions for tracked variables\n├── tracer.py                  # Core tracing functionality\n└── wrapping.py                # Function wrapping utilities for logging\n```\n```\n\n----------------------------------------\n\nTITLE: Optimized Softplus Implementation with Optional Superset Behavior\nDESCRIPTION: Improved implementation of softplus in Ivy's TensorFlow backend, balancing superset behavior with efficiency. This approach maintains optimal performance when extended features are not used.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/superset_behaviour.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef softplus(x: Tensor,\n                 /,\n                 *,\n                 beta: Optional[Union[int, float]] = None,\n                 threshold: Optional[Union[int, float]] = None,\n                 out: Optional[Tensor] = None) -> Tensor:\n    if beta is not None and beta != 1:\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy from source\nDESCRIPTION: Steps to install Ivy directly from the source code repository. This approach allows access to the latest changes before they are released in the pip package.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ivy-llc/ivy.git\ncd ivy\npip install --user -e .\n```\n\n----------------------------------------\n\nTITLE: Implementing argsort Function in Python\nDESCRIPTION: This snippet defines a function named 'argsort'. While the implementation is not provided, argsort typically returns the indices that would sort an array.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/sorting_functions.txt#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nargsort\n```\n\n----------------------------------------\n\nTITLE: Type Transformation - Python Diff\nDESCRIPTION: Shows the code changes after applying the type transformer to handle type annotations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n- def func(x: torch.Tensor) -> torch.Tensor:\n+ def func(x: typing.Any):\n      return torch.nn.functional.linear(x, weight, bias) + x.mean()\n```\n\n----------------------------------------\n\nTITLE: Cloning doc-builder Repository Using HTTPS\nDESCRIPTION: This snippet shows how to clone the doc-builder repository using HTTPS. The doc-builder repository contains the necessary tools to build the Ivy documentation locally.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/building_the_docs.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/unifyai/doc-builder.git\n```\n\n----------------------------------------\n\nTITLE: Configuring Discussion Channel Map in Python\nDESCRIPTION: This snippet shows the structure of the discussion_channel_map configuration in Ivy. It maps module names to Discord channel IDs for documentation linking purposes.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndiscussion_channel_map = {\n    ...,\n    \"ivy.functional.ivy.creation\": [\"1000043690254946374\"],\n    \"ivy.functional.ivy.data_type\": [\"1000043749088436315\"],\n    ...,\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Options to Docker Documentation Build in Bash\nDESCRIPTION: Example of running the Docker documentation build with additional options, such as disabling cleanup.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -v /path/to/project:/project unifyai/doc-builder --no-cleanup\n```\n\n----------------------------------------\n\nTITLE: Defining Zeros Function Signature in Ivy\nDESCRIPTION: Signature of the ivy.zeros function in the Ivy API, showing optional device and dtype arguments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@outputs_to_ivy_arrays\n@handle_out_argument\n@infer_dtype\n@infer_device\ndef zeros(\n    shape: Union[int, Sequence[int]],\n    *,\n    dtype: Optional[Union[ivy.Dtype, ivy.NativeDtype]] = None,\n    device: Optional[Union[ivy.Device, ivy.NativeDevice]] = None,\n) -> ivy.Array:\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy Development Dependencies\nDESCRIPTION: Commands to install required and optional development dependencies for Ivy.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_21\n\nLANGUAGE: none\nCODE:\n```\ncd ivy/\n```\n\nLANGUAGE: none\nCODE:\n```\npip install -r requirements/requirements.txt\npip install -r requirements/optional.txt\n```\n\n----------------------------------------\n\nTITLE: Defining Ivy Device Class\nDESCRIPTION: Definition of the ivy.Device class which derives from str and verifies correct string formatting in the constructor.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/devices.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Device(str):\n    def __new__(cls, device_str):\n        # Verify device string format\n        return str.__new__(cls, device_str)\n```\n\n----------------------------------------\n\nTITLE: Final Code Generation - Python Diff\nDESCRIPTION: Shows the final code changes after applying all transformations including import adjustments and cleanup.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n+ import ivy.functional.frontends.torch as torch\n- def func(x: typing.Any):\n+ def Translated_func(x: typing.Any):\n    return torch.nn.functional.linear(x, weight, bias) + torch.Tensor.mean(x)\n```\n\n----------------------------------------\n\nTITLE: Directory Structure Example - Python Project Layout\nDESCRIPTION: Shows the hierarchical organization of transformer modules, each handling specific transformation tasks like annotations, closures, decorators etc.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ntransformers/\n├── annotation_transformer      # Handles type annotations\n├── canonicalize_transformer   # Canonicalizes imports and function calls to use full module paths\n├── closure_transformer       # Manages closure scope variables\n├── decorator_transformer    # Processes function decorators\n├── deletion_transformer    # Removes specific AST nodes/code segments\n├── docstring_transformer  # Modifies and transforms docstrings\n├── dunders_transformer   # Handles special methods (__getitem__, __setitem__, etc.)\n├── globals_transformer  # Manages global variable transformations\n├── inject_transformer   # Injects new code/functionality\n├── method_transformer  # Handles class method transformations\n├── native_layers_transformer  # Maps and replaces neural network layers (nn.Linear, nn.Conv2d, etc.)\n├── postprocessing_transformer # Performs final cleanup and framework-specific adjustments\n├── preprocessing_transformer  # Handles initial AST modifications\n├── recursive_transformer     # Manages nested function calls and recursive transformations\n├── rename_transformer       # Handles identifier renaming (variables, functions, classes)\n└── typing_transformer     # Processes Python type hints\n```\n\n----------------------------------------\n\nTITLE: Adding Discussion Links in reStructuredText\nDESCRIPTION: Example of using the custom discussion_linker extension to add links to Discord server and discussion boards for specific modules.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_5\n\nLANGUAGE: rst\nCODE:\n```\n.. discussion-links:: module.foo\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Cumprod Frontend Implementation\nDESCRIPTION: Frontend implementation of TensorFlow's cumprod function using Ivy's cumprod and flip functions.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/design/building_blocks.rst#2025-04-23_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef cumprod(x, axis=0, exclusive=False, reverse=False, name=None):\n   ret = ivy.cumprod(x, axis, exclusive)\n   if reverse:\n       return ivy.flip(ret, axis)\n   return ret\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variable for Ivy API Key in Bash\nDESCRIPTION: This command shows how to export your Ivy API key as an environment variable named IVY_KEY. This is the simplest method to configure your local environment to use your personal Ivy API key for additional transpilation capabilities.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/api_key.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport IVY_KEY=<my_key>\n```\n\n----------------------------------------\n\nTITLE: PyTorch JIT Tracing\nDESCRIPTION: torch.jit.trace and torch.jit.trace_module enable JIT compilation of PyTorch modules and functions by recording operations on example inputs. Returns ScriptFunction or ScriptModule instances.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/related_work/graph_tracers.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntorch.jit.trace\ntorch.jit.trace_module\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy using pip\nDESCRIPTION: This command installs Ivy using pip. Note that this only installs NumPy as a dependency, not other frameworks like PyTorch or TensorFlow.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/get_started.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install ivy\n```\n\n----------------------------------------\n\nTITLE: Configuration File Structure - Python Configuration Layout\nDESCRIPTION: Shows the organization of transformer configuration files containing metadata and mappings.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nconfigurations/\n├── base_transformer_config.py\n├── ivy_postprocessing_transformer_config.py  # Contains dtype mappings, etc.\n└── frontend_torch_postprocessing_transformer_config.py\n```\n\n----------------------------------------\n\nTITLE: Setting up Documentation Structure with Sphinx in RST\nDESCRIPTION: This RST file configures the Sphinx documentation structure for the Ivy project. It includes the README.md file and organizes documentation into multiple sections using toctree directives, while also setting up API reference documentation with autosummary.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/index.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. title:: Home\n\n.. include:: ../README.md\n  :parser: myst_parser.sphinx_\n\n\n.. toctree::\n  :hidden:\n  :maxdepth: -1\n\n  Home <self>\n\n\n.. toctree::\n  :hidden:\n  :maxdepth: -1\n  :caption: The Basics\n\n  overview/get_started.rst\n  overview/api_key.rst\n  demos/quickstart.ipynb\n\n\n.. toctree::\n  :hidden:\n  :maxdepth: -1\n  :caption: Demos\n\n  demos/learn_the_basics.rst\n  demos/examples_and_demos.rst\n\n\n.. toctree::\n  :hidden:\n  :maxdepth: -1\n  :caption: Background\n\n  overview/motivation.rst\n  overview/related_work.rst\n\n\n.. toctree::\n  :hidden:\n  :maxdepth: -1\n  :caption: Contributors\n\n  overview/design.rst\n  overview/contributing.rst\n  overview/deep_dive.rst\n  overview/glossary.rst\n  overview/faq.rst\n\n\n.. toctree::\n  :hidden:\n  :maxdepth: -1\n  :caption: API Reference\n\n  overview/one_liners.rst\n\n\n.. autosummary::\n  :toctree: docs/functional\n  :template: top_functional_toc.rst\n  :recursive:\n  :hide-table:\n\n  ivy.functional.ivy\n\n\n.. autosummary::\n  :toctree: docs/data_classes\n  :template: top_data_toc.rst\n  :recursive:\n  :hide-table:\n\n  ivy.data_classes\n\n\n.. autosummary::\n  :toctree: docs\n  :template: top_ivy_toc.rst\n  :recursive:\n  :hide-table:\n\n  ivy.stateful\n  ivy.utils\n  ivy_tests.test_ivy.helpers\n```\n\n----------------------------------------\n\nTITLE: Standard PyTorch Model Inference\nDESCRIPTION: Shows the traditional way of running inference using PyTorch without compilation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/one_liners/trace.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Normal flow using pytorch\nwith torch.no_grad():\nlogits = model(**inputs).logits\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy using Docker\nDESCRIPTION: Instructions for pulling the Docker image for Ivy. This provides a containerized environment with Ivy pre-installed.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull ivyllc/ivy:latest\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Graph Tracing Overview\nDESCRIPTION: tf.Graph class represents TensorFlow computations as a dataflow graph. Used by tf.function to represent function computations through tf.Operation and tf.Tensor instances.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/related_work/graph_tracers.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntf.Graph\n```\n\n----------------------------------------\n\nTITLE: Importing the Hypothesis reproduce_failure Decorator\nDESCRIPTION: Code snippet showing how to import the reproduce_failure decorator from the hypothesis library. This is needed to regenerate test failures in Array API tests that use hypothesis for property-based testing.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom hypothesis import reproduce_failure\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote for Syncing with Original Ivy Repository\nDESCRIPTION: Command to add the original Ivy repository as an upstream remote to keep your fork synced with the latest changes.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add upstream https://github.com/unifyai/ivy.git\n```\n\n----------------------------------------\n\nTITLE: Extending and Customizing Module Documentation Template in Jinja2\nDESCRIPTION: This Jinja2 template extends a base template 'top_level_module.rst' and customizes various blocks for module documentation. It sets up the module name, discussion module name, and generates a table of contents for submodules.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_data_module.rst#2025-04-23_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% extends \"top_level_module.rst\" %}\n\n{% set base_module = fullname + \".\" + fullname.split('.')[-1] %}\n\n{%- block module_name -%}\n    {{base_module}}\n{%- endblock -%}\n\n{%- block discussion_module_name -%}\n    {{base_module}}\n{%- endblock -%}\n\n{% block toctree -%}\n.. autosummary::\n   :toctree: {{name}}\n   :template: data_module.rst\n   :hide-table:\n   :recursive:\n{% for submodule in modules -%}\n{% if base_module != submodule %}\n   {{ submodule }}\n{% endif -%}\n{% endfor -%}\n\n{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Handling Numerical Precision Differences Between Backends\nDESCRIPTION: An example of an AssertionError due to numerical differences between JAX and TensorFlow results. The solution is to adjust the relative and absolute tolerance parameters when the results are close but not exact matches.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/error_handling.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nE       AssertionError:  the results from backend jax and ground truth framework tensorflow do not match\nE        0.25830078125!=0.258544921875\nE\nE\nE       Falsifying example: test_acosh(\nE           backend_fw='jax',\nE           on_device='cpu',\nE           dtype_and_x=(['float16'], [array(4., dtype=float16)]),\nE           test_flags=FunctionTestFlags(\nE               ground_truth_backend='tensorflow',\nE               num_positional_args=1,\nE               with_out=False,\nE               instance_method=False,\nE               test_gradients=True,\nE               test_trace=None,\nE               as_variable=[False],\nE               native_arrays=[False],\nE               container=[False],\nE           ),\nE           fn_name='acosh',\nE       )\nE\nE       You can reproduce this example by temporarily adding @reproduce_failure('6.82.4', b'AXicY2BAABYQwQgiAABDAAY=') as a decorator on your test case\n```\n\nLANGUAGE: python\nCODE:\n```\n@handle_test(\n    fn_tree=\"functional.ivy.acosh\",\n    dtype_and_x=helpers.dtype_and_values(\n        available_dtypes=helpers.get_dtypes(\"float\"),\n        min_value=1,\n        large_abs_safety_factor=4,\n        small_abs_safety_factor=4,\n    ),\n)\ndef test_acosh(*, dtype_and_x, test_flags, backend_fw, fn_name, on_device):\n    input_dtype, x = dtype_and_x\n    helpers.test_function(\n        input_dtypes=input_dtype,\n        test_flags=test_flags,\n        backend_to_test=backend_fw,\n        fn_name=fn_name,\n        on_device=on_device,\n        rtol_=1e-2,\n        atol_=1e-2,\n        x=x[0],\n    )\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream Remote\nDESCRIPTION: Command to add the original Ivy repository as upstream remote for syncing\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_3\n\nLANGUAGE: none\nCODE:\n```\ngit remote add upstream https://github.com/unifyai/ivy.git\n```\n\n----------------------------------------\n\nTITLE: Handling Backend Implementation Discrepancies\nDESCRIPTION: An example of an AssertionError where torch and tensorflow backends produce significantly different results. This suggests an implementation issue in the torch backend rather than a numerical precision problem, requiring a fix in the backend implementation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/error_handling.rst#2025-04-23_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nE       AssertionError:  the results from backend torch and ground truth framework tensorflow do not match\nE        [[1.41421356 1.41421356 1.41421356]\nE        [1.41421356 1.41421356 1.41421356]\nE        [1.41421356        inf 1.41421356]]!=[[1.41421356e+000 1.41421356e+000 1.41421356e+000]\nE        [1.41421356e+000 1.41421356e+000 1.41421356e+000]\nE        [1.41421356e+000 1.34078079e+154 1.41421356e+000]]\nE\nE\nE       Falsifying example: test_abs(\nE           backend_fw='torch',\nE           on_device='cpu',\nE           dtype_and_x=(['complex128'],\nE            [array([[-1.-1.00000000e+000j, -1.-1.00000000e+000j, -1.-1.00000000e+000j],\nE                    [-1.-1.00000000e+000j, -1.-1.00000000e+000j, -1.-1.00000000e+000j],\nE                    [-1.-1.00000000e+000j, -1.-1.34078079e+154j, -1.-1.00000000e+000j]])]),\nE           fn_name='abs',\nE           test_flags=FunctionTestFlags(\nE               ground_truth_backend='tensorflow',\nE               num_positional_args=1,\nE               with_out=False,\nE               instance_method=False,\nE               test_gradients=False,\nE               test_trace=None,\nE               as_variable=[False],\nE               native_arrays=[False],\nE               container=[False],\nE           ),\nE       )\nE\nE       You can reproduce this example by temporarily adding @reproduce_failure('6.82.4', b'AXicY2ZkYAIiBiBgZIAAxqHEXsAAB7jUQAAAMtEAzQ==') as a decorator on your test case\n```\n\n----------------------------------------\n\nTITLE: Setting Framework Paths for Docker Configuration\nDESCRIPTION: List of framework paths that need to be added to PyCharm Docker configuration to resolve import issues with the latest Docker image.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n/opt/fw/numpy\n/opt/fw/jax\n/opt/fw/tensorflow\n/opt/fw/torch\n/opt/fw/paddle\n/opt/fw/mxnet\n```\n\n----------------------------------------\n\nTITLE: Extending Function Documentation Template\nDESCRIPTION: Template code that extends a top-level table of contents template and defines function documentation blocks. Uses Jinja templating to create underlined 'Functions' heading and specifies functional module template.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_functional_toc.rst#2025-04-23_snippet_0\n\nLANGUAGE: jinja\nCODE:\n```\n{% extends \"top_level_toc.rst\" %}\n{% block name %}{{'Functions' | escape | underline}}{% endblock %}\n\n{% block template %}top_functional_module.rst{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Creating reStructuredText Documentation Index for Related Work in Ivy Project\nDESCRIPTION: This RST markup creates a documentation index page with links to related documentation pages comparing Ivy to other ML frameworks and tools. It includes both reference links at the top and a hidden toctree directive for proper documentation structure.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/related_work.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _`Frameworks`: related_work/frameworks.rst\n.. _`Graph Tracers`: related_work/graph_tracers.rst\n.. _`Ivy vs ONNX`: related_work/ivy_vs_onnx.rst\n\n.. toctree::\n   :hidden:\n   :maxdepth: -1\n   :caption: Related Work\n\n   related_work/ivy_vs_onnx.rst\n   related_work/graph_tracers.rst\n   related_work/frameworks.rst\n```\n\n----------------------------------------\n\nTITLE: Failed Pre-commit Output Example\nDESCRIPTION: Example of pre-commit check output showing a failed black formatting check\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/formatting.rst#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n[INFO] Stashing unstaged files to ~/.cache/pre-commit/patch1687898304-8072.\nblack....................................................................Failed\n- hook id: black\n- files were modified by this hook\n\nreformatted ivy/stateful/activations.py\n\nAll done! ✨ 🍰 ✨\n1 file reformatted.\n\nautoflake................................................................Passed\nflake8...................................................................Passed\ndocformatter.............................................................Passed\npydocstyle...............................................................Passed\nivy-lint.................................................................Passed\n[INFO] Restored changes from ~/.cache/pre-commit/patch1687898304-8072.\n```\n\n----------------------------------------\n\nTITLE: Running Specific Array API Tests via Terminal\nDESCRIPTION: Commands for running all tests in a specific Array API test file or running a single test within a file. This is useful after explicitly setting the backend in the _array_module.py file when you want to test specific functionality.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# run all tests in a file\npytest -vv ivy_tests/array_api_testing/test_array_api/array_api_tests/test_manipulation_functions.py\n\n# run a single test\npytest -vv ivy_tests/array_api_testing/test_array_api/array_api_tests/test_manipulation_functions.py -k \"test_concat\"\n```\n\n----------------------------------------\n\nTITLE: Updating Submodule to Latest Commit\nDESCRIPTION: Command for updating the Array API submodule to the latest commit before staging changes. This resolves issues with out-of-date submodules that can cause strange behavior when staging changes from Ivy's main repo.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Updating your submodule to the latest commit\ngit submodule update --remote\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies List\nDESCRIPTION: A list of required Python packages including transformers for machine learning, cryptography for security, testing tools like junitparser, code formatters black and ruff, and various utility packages.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/test_transpiler/requirements.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ntransformers\ncryptography\njunitparser\nblack\nruff\ntimm\ntqdm\nsimplex\nfreia\nntplib\nkornia # adding temporarily\ndatasets\n```\n\n----------------------------------------\n\nTITLE: Fixing Docker Socket Permission Issues on Ubuntu\nDESCRIPTION: Commands to resolve Docker connection issues in PyCharm on Ubuntu by adjusting permissions for the Docker socket and pid files.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsudo chmod a+rwx /var/run/docker.sock\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo chmod a+rwx /var/run/docker.pid\n```\n\n----------------------------------------\n\nTITLE: Options Block for Documentation Settings\nDESCRIPTION: Template block defining documentation options including special members and inheritance display settings.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_functional_module.rst#2025-04-23_snippet_2\n\nLANGUAGE: jinja2\nCODE:\n```\n   :special-members: __init__\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: Listing Python Dependencies for Ivy Project\nDESCRIPTION: This snippet lists the Python package dependencies for the Ivy project. It includes libraries for various purposes such as machine learning (TensorFlow, PyTorch), scientific computing (NumPy, SciPy), data processing (Pandas), and testing (pytest, hypothesis).\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/requirements/optional_gpu.txt#2025-04-23_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nautoflake # for backend generation\ncoverage\ndm-haiku # mod_name=haiku\nflax\nh5py\nhypothesis\njax\njaxlib\nmatplotlib\nnetworkx\nopencv-python # mod_name=cv2\npandas\npymongo\npyspark\npytest\nredis\nscikit-learn # mod_name=sklearn\nscipy\nsnakeviz # for profiling\ntensorflow\ntorch\ntorchvision\n```\n\n----------------------------------------\n\nTITLE: Array API Test Commands\nDESCRIPTION: Commands for running Array API tests at various levels including single function, file, and all tests.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_8\n\nLANGUAGE: none\nCODE:\n```\npytest ivy_tests/array_api_testing/test_array_api/array_api_tests/test_creation_functions.py::test_arange --no-header --no-summary -q\n\npytest ivy_tests/array_api_testing/test_array_api/array_api_tests/test_creation_functions.py --no-header --no-summary -q\n\npytest ivy_tests/array_api_testing/test_array_api/ --no-header --no-summary -q\n```\n\n----------------------------------------\n\nTITLE: Creating Conda Environment\nDESCRIPTION: Command to create a new conda environment for Ivy development with Python 3.10.0\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_4\n\nLANGUAGE: none\nCODE:\n```\nconda create --name ivy_dev python=3.10.0\n```\n\n----------------------------------------\n\nTITLE: Ivy Test Execution Commands\nDESCRIPTION: Various pytest commands for running Ivy tests at different levels - single function, single file, and all tests.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_7\n\nLANGUAGE: none\nCODE:\n```\npytest ivy_tests/test_ivy/test_functional/test_core/test_image.py::test_random_crop --no-header --no-summary -q\n\npytest ivy_tests/test_ivy/test_functional/test_core/test_image.py --no-header --no-summary -q\n\npytest ivy_tests/test_ivy/ --no-header --no-summary -q\n```\n\n----------------------------------------\n\nTITLE: Handling Unsupported Dtype Error in PyTorch Backend\nDESCRIPTION: An example of a RuntimeError that occurs when passing an unsupported dtype (float16) to torch's logaddexp2_cpu function. The solution is to add the dtype to the unsupported_dtypes decorator to handle the case gracefully.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/error_handling.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nE       RuntimeError: \"logaddexp2_cpu\" not implemented for 'Half'\nE       Falsifying example: test_logaddexp2(\nE           backend_fw='torch',\nE           on_device='cpu',\nE           dtype_and_x=(['float16', 'float16'],\nE            [array([-1.], dtype=float16), array([-1.], dtype=float16)]),\nE           test_flags=FunctionTestFlags(\nE               ground_truth_backend='tensorflow',\nE               num_positional_args=2,\nE               with_out=False,\nE               instance_method=False,\nE               test_gradients=False,\nE               test_trace=None,\nE               as_variable=[False],\nE               native_arrays=[False],\nE               container=[False],\nE           ),\nE           fn_name='logaddexp2',\nE       )\nE\nE       You can reproduce this example by temporarily adding @reproduce_failure('6.82.4', b'AXicY2BkAAMoBaaR2WAAAACVAAY=') as a decorator on your test case\n```\n\nLANGUAGE: python\nCODE:\n```\n@with_unsupported_dtypes({\"2.0.1 and below\": (\"float16\",)}, backend_version)\n```\n\n----------------------------------------\n\nTITLE: Custom Content Block for API Documentation\nDESCRIPTION: Template block that generates detailed documentation for functions, classes, and attributes using autofunction, autoclass, and autoivydata directives. Includes a fallback message when no content is available.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_functional_module.rst#2025-04-23_snippet_3\n\nLANGUAGE: jinja2\nCODE:\n```\n{% for function in functions %}\n.. autofunction:: ivy.{{ function }}\n{% endfor %}\n{% for class in classes %}\n.. autoclass:: ivy.{{ class }}\n{% endfor %}\n{% for attribute in attributes %}\n.. autoivydata:: {{ fullname }}.{{ attribute }}\n{% endfor %}\n{% if not functions and not classes and not attributes and not modules %}\nThere are no functions in this module yet. 🚧\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies\nDESCRIPTION: Lists required Python packages including ML frameworks (dm-haiku, flax), data processing libraries (pandas, pyspark), and development tools (autoflake, coverage). Includes specific version constraints and module name aliases in comments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/requirements/optional_apple_silicon_2.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nautoflake  # for backend generation\ncoverage\ndm-haiku  # mod_name=haiku\nflax\nml-dtypes==0.2.0\npandas\nprotobuf\npyspark\nscikit-learn  # mod_name=sklearn\nscipy\nsnakeviz  # for profiling\n```\n\n----------------------------------------\n\nTITLE: Running Ivy Tests on Windows Using Git Bash\nDESCRIPTION: This snippet shows how to run Ivy tests on Windows systems using Git Bash. It includes commands for running all tests, array API tests, and specific module tests for different backends.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nsh ./scripts/shell/run_tests.sh\nsh ./scripts/shell/test_array_api.sh [backend] test_[submodule]\nsh ./scripts/shell/test_ivy_core.sh [backend] test_[submodule]\nsh ./scripts/shell/test_ivy_nn.sh [backend] test_[submodule]\nsh ./scripts/shell/test_ivy_stateful.sh [backend] test_[submodule]\n```\n\n----------------------------------------\n\nTITLE: Installing Array API Testing Dependencies\nDESCRIPTION: Command for installing packages required for running tests in the Array API suite.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Non-Docker Test Commands\nDESCRIPTION: Commands for running tests without Docker, using python -m pytest with various scopes and configurations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_10\n\nLANGUAGE: none\nCODE:\n```\npython -m pytest ivy_tests/test_ivy/test_functional/test_core/test_image.py::test_random_crop --no-header --no-summary -q\n\npython -m pytest ivy_tests/test_ivy/test_functional/test_core/test_image.py --no-header --no-summary -q\n\npython -m pytest ivy_tests/test_ivy/ --no-header --no-summary -q\n```\n\n----------------------------------------\n\nTITLE: Basic Type Information Removal from Array API Docstring\nDESCRIPTION: Example showing how to remove redundant type information from Array API Standard docstrings when type hints are already present.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/docstrings.rst#2025-04-23_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\n-x: array\n+x\n-out: array\n+out\n```\n\n----------------------------------------\n\nTITLE: Module Documentation Template Block in Jinja2/RST\nDESCRIPTION: Template block for generating documentation of submodules using autosummary directive with recursive processing.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_functional_module.rst#2025-04-23_snippet_1\n\nLANGUAGE: jinja2\nCODE:\n```\n{% if modules %}\n.. autosummary::\n   :toctree: {{name}}\n   :template: top_functional_module.rst\n   :recursive:\n{% for module in modules %}\n   {{ module }}\n{%- endfor %}\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy using pip\nDESCRIPTION: The standard way to install the Ivy package using pip package manager. This makes the ivy library available in your Python environment.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install ivy\n```\n\n----------------------------------------\n\nTITLE: Listing Python Package Dependencies for Ivy Project\nDESCRIPTION: This snippet lists the required Python packages for the Ivy project. It includes libraries for data handling, machine learning, visualization, and specific frameworks like PyTorch and TensorFlow. Some entries have additional comments specifying module names or version constraints.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/requirements/optional_apple_silicon_1.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nh5py\nhypothesis\njax\njaxlib\nmatplotlib\nnetworkx\nopencv-python  # mod_name=cv2\npaddlepaddle  # unpinned , mod_name=paddle\npymongo\npytest\nredis\ntensorflow-macos  # mod_name=tensorflow_macos\ntensorflow-probability  # mod_name=tensorflow_probability\ntorch\ntorchvision\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy Dependencies for Apple Silicon\nDESCRIPTION: Command for installing optional dependencies specific to Apple Silicon machines.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements/optional_apple_silicon_2.txt\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx in Python\nDESCRIPTION: Example of a partial Sphinx configuration file (partial_conf.py) used to customize options specific to the Ivy project.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nivy_toctree_caption_map = {\n    \"ivy.functional.ivy\": \"Functions\",\n    \"ivy.stateful\": \"Framework classes\",\n    \"ivy.nested_array\": \"Nested array\",\n    \"ivy.utils\": \"Utils\",\n    \"ivy_tests.test_ivy.helpers\": \"Testing\",\n}\n```\n\n----------------------------------------\n\nTITLE: Git Add Commands for Selective Commits\nDESCRIPTION: Git commands for adding specific files and interactively selecting code changes\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit add filepath\ngit add -p filepath  # choose lines to add from the file\nget add -p           # choose lines to add from all changes\n```\n\n----------------------------------------\n\nTITLE: Defining Module Name Mapping in Jinja2 Template\nDESCRIPTION: Creates a dictionary mapping internal Ivy module paths to human-readable section titles for documentation. This mapping is used to provide more user-friendly headings in the generated documentation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_ivy_toc.rst#2025-04-23_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% set ivy_module_map = {\n    \"ivy.stateful\": \"Framework classes\",\n    \"ivy.nested_array\": \"Nested array\",\n    \"ivy.utils\": \"Utils\",\n    \"ivy_tests.test_ivy.helpers\": \"Testing\",\n} %}\n```\n\n----------------------------------------\n\nTITLE: Cloning Ivy Repository with HTTPS\nDESCRIPTION: Command to clone the Ivy repository using HTTPS with submodules\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_1\n\nLANGUAGE: none\nCODE:\n```\ngit clone --recurse-submodules https://github.com/YOUR_USERNAME/ivy.git\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Table of Contents Tree\nDESCRIPTION: Hidden table of contents structure defining the navigation hierarchy for the Deep Dive documentation section.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive.rst#2025-04-23_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :maxdepth: -1\n   :caption: Deep Dive\n\n   deep_dive/navigating_the_code.rst\n   deep_dive/function_types.rst\n   deep_dive/superset_behaviour.rst\n   deep_dive/backend_setting.rst\n   deep_dive/arrays.rst\n   deep_dive/containers.rst\n   deep_dive/data_types.rst\n   deep_dive/devices.rst\n   deep_dive/inplace_updates.rst\n   deep_dive/function_wrapping.rst\n   deep_dive/formatting.rst\n   deep_dive/ivy_lint.rst\n   deep_dive/function_arguments.rst\n   deep_dive/docstrings.rst\n   deep_dive/docstring_examples.rst\n   deep_dive/array_api_tests.rst\n   deep_dive/ivy_tests.rst\n   deep_dive/ivy_frontends.rst\n   deep_dive/ivy_frontends_tests.rst\n   deep_dive/exception_handling.rst\n   deep_dive/gradients.rst\n   deep_dive/operating_modes.rst\n   deep_dive/building_the_docs_pipeline.rst\n   deep_dive/fix_failing_tests.rst\n```\n\n----------------------------------------\n\nTITLE: Importing Numpy Frontend in Ivy\nDESCRIPTION: Example of importing the Numpy frontend in Ivy's __init__.py file.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/open_tasks.rst#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ivy.functional.frontends.numpy import __init__.py#L27\n```\n\n----------------------------------------\n\nTITLE: Cloning the Ivy Repository with Submodules using HTTPS\nDESCRIPTION: Command to clone the Ivy repository with its submodules using HTTPS authentication.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recurse-submodules https://github.com/YOUR_USERNAME/ivy.git\n```\n\n----------------------------------------\n\nTITLE: Installing Ivy from GitHub\nDESCRIPTION: Command to install the Ivy package directly from GitHub repository.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_20\n\nLANGUAGE: none\nCODE:\n```\npip install git+https://github.com/unifyai/ivy.git\n```\n\n----------------------------------------\n\nTITLE: Launching TensorBoard for Visualization\nDESCRIPTION: Command to launch TensorBoard for visualizing the performance profiling data collected from the models.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Launch TensorBoard and navigate to the Profile tab to view performance profile \n!tensorboard --logdir='logs/'\n```\n\n----------------------------------------\n\nTITLE: Adding Array API Standard Conformance Note\nDESCRIPTION: Example showing how to add documentation about conformance to the Array API Standard.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/docstrings.rst#2025-04-23_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n+This function conforms to the `Array API Standard\n+<https://data-apis.org/array-api/latest/>`_. This docstring is an extension of the\n+`docstring <https://data-apis.org/array-api/latest/API_specification/generated/array_api.tan.html>`_\n+in the standard.\n```\n\n----------------------------------------\n\nTITLE: Installing M1 Mac Dependencies\nDESCRIPTION: Commands for installing Ivy development dependencies specifically for M1 Mac\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_6\n\nLANGUAGE: none\nCODE:\n```\npip install -r requirements/optional_apple_silicon_1.txt\npip install -r requirements/optional_apple_silicon_2.txt\n```\n\n----------------------------------------\n\nTITLE: Defining Promotion Function Names\nDESCRIPTION: Lists the standard function names used for different types of operation and function promotions in the Ivy framework. Includes regular, inplace, and scalar promotion patterns.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/type_promotion.txt#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nfunc_promotion\nop_promotion\ninplace_op_promotion\nop_scalar_promotion\ninplace_op_scalar_promotion\n```\n\n----------------------------------------\n\nTITLE: Skipping Array API Tests - Test Case Example in Bash\nDESCRIPTION: Example of skipping specific test cases in the Array API test suite using the skips.txt file format. Shows how to skip the in-place power operation test with specific input conditions.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/array_api_tests.rst#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nivy_tests/array_api_testing/test_array_api/array_api_tests/test_special_cases.py::test_iop[__ipow__(x1_i is -infinity and x2_i > 0 and not (x2_i.is_integer() and x2_i % 2 == 1)) -> +infinity]\n```\n\n----------------------------------------\n\nTITLE: Instance Method Docstring Template\nDESCRIPTION: Template for documenting Array and Container instance methods that wrap API functions.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/docstrings.rst#2025-04-23_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nivy.<Array|Container> <instance|special|reverse special> method variant of ivy.<func_name>. This method simply wraps the\nfunction, and so the docstring for ivy.<func_name> also applies to this method\nwith minimal changes.\n\nParameters\n----------\n<parameters with their description>\n\nReturns\n-------\n<return value with its description>\n```\n\n----------------------------------------\n\nTITLE: Implementing sort Function in Python\nDESCRIPTION: This snippet defines a function named 'sort'. While the implementation is not provided, sort typically arranges elements in a specific order (e.g., ascending or descending).\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/sorting_functions.txt#2025-04-23_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nsort\n```\n\n----------------------------------------\n\nTITLE: Importing Deep Learning Libraries\nDESCRIPTION: Imports essential deep learning libraries including PyTorch, TensorFlow, and NumPy for numerical operations.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/utils/profiler_example.ipynb#2025-04-23_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport torch\nfrom torch import nn\nimport tensorflow as tf\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Docker Installation Commands for Ubuntu\nDESCRIPTION: Series of commands for installing Docker on Ubuntu, including adding the Docker repository and installing the required packages.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install \\\nca-certificates \\\ncurl \\\ngnupg \\\nlsb-release\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo mkdir -p /etc/apt/keyrings\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n```\n\nLANGUAGE: bash\nCODE:\n```\necho \\\n\"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\\n$(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update\n```\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n```\n\n----------------------------------------\n\nTITLE: Structuring Ivy Documentation in reStructuredText\nDESCRIPTION: Example of the index.rst file structure for Ivy documentation, including table of contents and autosummary directives.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_3\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ../README.rst\n\n.. toctree::\n    :hidden:\n    :maxdepth: -1\n    :caption: Overview\n\n    overview/background.rst\n    overview/design.rst\n    overview/related_work.rst\n    overview/extensions.rst\n    overview/contributing.rst\n    overview/deep_dive.rst\n    overview/faq.rst\n    overview/glossary.rst\n\n.. autosummary::\n    :toctree: docs/functional\n    :template: top_functional_toc.rst\n    :caption: API Reference\n    :recursive:\n    :hide-table:\n\n    ivy.functional.ivy\n```\n\n----------------------------------------\n\nTITLE: Running the Documentation Build Script in Bash\nDESCRIPTION: Command to run the convenience script for building documentation without Docker. It takes the path to the project as an argument.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./make_docs_without_docker.sh /path/to/project\n```\n\n----------------------------------------\n\nTITLE: Building doc-builder Docker Image Locally\nDESCRIPTION: This snippet demonstrates how to build the doc-builder Docker image locally after cloning the repository. This creates a local version of the image used for building Ivy documentation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/building_the_docs.rst#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd doc-builder\ndocker build -t unifyai/doc-builder .\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Git Hook\nDESCRIPTION: Command to install pre-commit as a git hook for automated checks before commits\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/formatting.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Missing Binaries Warning Message Example\nDESCRIPTION: Example of the warning message displayed when Ivy binaries are missing from the system, showing supported configurations and missing binary paths.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_24\n\nLANGUAGE: none\nCODE:\n```\nWARNING:root:   Some binaries seem to be missing in your system. This could be either because we don't have compatible binaries for your system or that newer binaries were available.\n                   In the latter case, calling ivy.utils.cleanup_and_fetch_binaries() should fetch the binaries binaries. Feel free to create an issue on https://github.com/unifyai/ivy.git in case of the former\n\nWARNING:root:\nFollowing are the supported configurations :\ncompiler : cp38-none-manylinux_2_17_x86_64, cp310-none-manylinux_2_17_x86_64\nengines : cp310-none-manylinux_2_17_x86_64\n\nWARNING:root:   /workspaces/ivy/ivy/compiler/_compiler.so not found.\n```\n\n----------------------------------------\n\nTITLE: Listing Ivy Test Scripts in Bash\nDESCRIPTION: This snippet shows the available test scripts in the Ivy project's scripts directory. It includes scripts for running core, nn, and stateful tests, as well as array API tests.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nscripts/setup_tests/run_ivy_core_test.py\nscripts/setup_tests/run_ivy_nn_test.py\nscripts/setup_tests/run_ivy_stateful_test.py\nscripts/shell/run_tests.sh\nscripts/shell/test_array_api.sh\nscripts/test_dependencies.py\nscripts/shell/test_dependencies.sh\nscripts/shell/test_ivy_core.sh\nscripts/shell/test_ivy_nn.sh\nscripts/shell/test_ivy_stateful.sh\n```\n\n----------------------------------------\n\nTITLE: Renaming Return Value in Array API Docstring\nDESCRIPTION: Example showing how to rename the return value from 'out' to 'ret' to avoid naming conflicts.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/docstrings.rst#2025-04-23_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n-out\n+ret\n```\n\n----------------------------------------\n\nTITLE: Configuring Skippable Method Attributes in Python\nDESCRIPTION: This snippet demonstrates the configuration of skippable_method_attributes in the partial_conf.py file. It defines criteria for skipping certain functions during documentation generation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nskippable_method_attributes = [\n    {\n        \"__qualname__\": \"_wrap_function.<locals>.new_function\"\n    }\n]\n```\n\n----------------------------------------\n\nTITLE: Building Ivy Documentation Using Convenience Script\nDESCRIPTION: This snippet shows how to build the Ivy documentation using the provided convenience script. The script handles all dependencies and builds the documentation in the docs/build directory.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/building_the_docs.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd docs\n./make_docs.sh\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit with pip\nDESCRIPTION: Command to install the pre-commit tool using pip package manager\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/formatting.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pre-commit\n```\n\n----------------------------------------\n\nTITLE: GitHub Issue Template Code Example\nDESCRIPTION: Example of a code reference in documentation for creating GitHub issues using templates\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/open_tasks.rst#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nNew issue\n```\n\nLANGUAGE: markdown\nCODE:\n```\nGet started\n```\n\nLANGUAGE: markdown\nCODE:\n```\nSubmit new issue\n```\n\n----------------------------------------\n\nTITLE: Running Ivy Tests Using Shell Scripts\nDESCRIPTION: This snippet demonstrates how to run various Ivy tests using shell scripts. It includes commands for running all tests, array API tests, and specific module tests for different backends.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/shell/run_tests.sh\n./scripts/shell/test_array_api.sh [backend] test_[submodule]\n./scripts/shell/test_ivy_core.sh [backend] test_[submodule]\n./scripts/shell/test_ivy_nn.sh [backend] test_[submodule]\n./scripts/shell/test_ivy_stateful.sh [backend] test_[submodule]\n```\n\n----------------------------------------\n\nTITLE: Cloning doc-builder Repository Using SSH\nDESCRIPTION: This snippet shows how to clone the doc-builder repository using SSH. This is an alternative to using HTTPS for cloning the repository containing documentation building tools.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/building_the_docs.rst#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:unifyai/doc-builder.git\n```\n\n----------------------------------------\n\nTITLE: Function Documentation Template Block in Jinja2/RST\nDESCRIPTION: Template block that generates automatic documentation for module functions using autosummary directive. It filters out private functions (starting with underscore) and creates a toctree structure.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_functional_module.rst#2025-04-23_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% if functions %}\n.. autosummary::\n   :toctree: {{name}}\n   :template: functional_module.rst\n   :hide-table:\n   :recursive:\n{% for function in functions %}\n   {% if not function.startswith('_') %}\n   {{ fullname }}.{{ function }}\n   {% endif %}\n{%- endfor %}\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Building Documentation with Docker in Bash\nDESCRIPTION: Command to build documentation using the unifyai/doc-builder Docker image. It mounts the project directory to the container and runs the build script.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/building_the_docs_pipeline.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -v /path/to/project:/project unifyai/doc-builder\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Function Signature in Swift\nDESCRIPTION: This snippet shows the signature of a standard function in Swift. It defines the function name, parameters, and return type.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/signatures.txt#2025-04-23_snippet_0\n\nLANGUAGE: Swift\nCODE:\n```\nfunc_signature\n```\n\n----------------------------------------\n\nTITLE: Successful Pre-commit Output Example\nDESCRIPTION: Example of successful pre-commit check output showing all passed checks\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/formatting.rst#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n[INFO] Stashing unstaged files to ~/.cache/pre-commit/patch1687898304-8072.\nblack....................................................................Passed\nautoflake................................................................Passed\nflake8...................................................................Passed\ndocformatter.............................................................Passed\npydocstyle...............................................................Passed\nivy-lint.................................................................Passed\n[INFO] Restored changes from ~/.cache/pre-commit/patch1687898304-8072.\n[formatting-docs 3516aed563] Test commit\n1 file changed, 1 insertion(+)\n```\n\n----------------------------------------\n\nTITLE: Virtual Environment Activation Commands\nDESCRIPTION: Commands for activating the virtual environment on Windows and Mac/Linux systems.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_9\n\nLANGUAGE: none\nCODE:\n```\nivy_dev\\Scripts\\activate.bat\n\nsource ivy_dev/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Installing Python Virtual Environment Package in WSL\nDESCRIPTION: Command to install the python3-venv package in WSL Ubuntu environment.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_17\n\nLANGUAGE: none\nCODE:\n```\nsudo apt install python3-venv\n```\n\n----------------------------------------\n\nTITLE: Git Blame and Log Commands\nDESCRIPTION: Commands for viewing file revision history and author information using git blame and git log\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Eg: From line 16 to next 5 lines since past 2 weeks\ngit blame --since=2.weeks -L 16,+5 <filepath> | grep -v \"^\\^\"\n# Deeper look at what each author changed in files retrieved from the above step\ngit log <commit_id> -p\n```\n\n----------------------------------------\n\nTITLE: Cloning the Ivy Repository with GitHub CLI\nDESCRIPTION: Command to clone the Ivy repository with its submodules using GitHub CLI tool.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngh repo clone YOUR_USERNAME/ivy your_folder -- --recurse-submodules\n```\n\n----------------------------------------\n\nTITLE: Declaring Extension Function Signature in Swift\nDESCRIPTION: This code snippet demonstrates the signature of an extension function in Swift. Extension functions allow adding new functionality to existing types.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/signatures.txt#2025-04-23_snippet_1\n\nLANGUAGE: Swift\nCODE:\n```\nextension_func_signature\n```\n\n----------------------------------------\n\nTITLE: Defining Mathematical Special Values\nDESCRIPTION: List of mathematical special values including irrational numbers, infinity (inf), and not-a-number (nan) representations commonly used in mathematical and computational contexts.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/constants.txt#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nirrational_numbers\ninf\nnan\n```\n\n----------------------------------------\n\nTITLE: Creating a New Branch in Git for Ivy Contributions\nDESCRIPTION: This command creates a new branch in your local Git repository for working on Ivy contributions. It's recommended to create a separate branch for each new pull request.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b name_of_your_branch\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment in WSL\nDESCRIPTION: Command to create a new Python virtual environment named ivy_dev.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_18\n\nLANGUAGE: none\nCODE:\n```\npython3 -m venv ivy_dev\n```\n\n----------------------------------------\n\nTITLE: Referencing DEX Language Built on Haskell\nDESCRIPTION: Mention of the DEX language being built on top of Haskell. This is not actual code, but a reference to the underlying technology used in the development of the DEX language.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/related_work/frameworks.rst#2025-04-23_snippet_1\n\nLANGUAGE: Haskell\nCODE:\n```\nHaskell\n```\n\n----------------------------------------\n\nTITLE: Docker Container Test Setup Commands\nDESCRIPTION: Commands for setting up and running tests inside a Docker container, including replacing the ivy folder and accessing the container.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_6\n\nLANGUAGE: none\nCODE:\n```\ndocker exec <container-name> rm -rf ivy\ndocker cp ivy <container-name>:/\n\ndocker exec -it ivy_container bash\ncd ivy\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code Settings for Pytest\nDESCRIPTION: JSON configuration for VS Code settings to enable running pytest tests directly from the VS Code interface.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"python.testing.pytestArgs\": [\n      \"./ivy_tests/test_ivy/\",\n      \"./ivy_tests/array_api_testing/test_array_api/\",\n      \"--continue-on-collection-errors\",\n   ],\n   \"python.testing.unittestEnabled\": false,\n   \"python.testing.pytestEnabled\": true,\n   \"python.testing.autoTestDiscoverOnSaveEnabled\": true,\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Fork Branch with Upstream Changes in Ivy\nDESCRIPTION: This command runs a shell script to merge changes from the upstream main branch into your fork's branch. It helps keep your fork up-to-date with the latest changes in the Ivy repository.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/shell/merge_with_upstream.sh name_of_your_branch\n```\n\n----------------------------------------\n\nTITLE: Cloning the Ivy Repository with Submodules using SSH\nDESCRIPTION: Command to clone the Ivy repository with its submodules using SSH authentication.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/fix_failing_tests.rst#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recurse-submodules git@github.com:YOUR_USERNAME/ivy.git\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Link Declarations\nDESCRIPTION: Link references used in the documentation for GitHub issues and pull requests.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. _`issues`: https://github.com/unifyai/ivy/issues\n.. _`pull-requests`: https://github.com/unifyai/ivy/pulls\n```\n\n----------------------------------------\n\nTITLE: HTML Video Embed in RST Documentation\nDESCRIPTION: HTML snippet for embedding a YouTube video within RST documentation. The code is commented out but shows the structure for embedding a video with specified dimensions and fullscreen capability.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/function_arguments.rst#2025-04-23_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<iframe width=\"420\" height=\"315\" allow=\"fullscreen;\" src=\"https://www.youtube.com/embed/5cAbryXza18\" class=\"video\"></iframe>\n```\n\n----------------------------------------\n\nTITLE: Listing Python Package Dependencies for Ivy Project\nDESCRIPTION: This snippet lists the required Python packages for the Ivy project. It includes libraries for various purposes such as backend generation (autoflake), machine learning (dm-haiku, flax), data processing (pandas, pyspark), and development tools (coverage, snakeviz). Some packages have specific version requirements or alternate module names specified.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/requirements/optional_apple_silicon_gpu_2.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nautoflake  # for backend generation\ncoverage\ndm-haiku  # mod_name=haiku\nflax\nml-dtypes==0.2.0\npandas\nprotobuf\npyspark\nscikit-learn  # mod_name=sklearn\nscipy\nsnakeviz  # for profiling\n```\n\n----------------------------------------\n\nTITLE: Git Commands for Resolving Merge Conflicts in Ivy Contributions\nDESCRIPTION: This sequence of Git commands demonstrates how to stash local changes, fetch and pull updates from the main branch, and then reapply your changes. It's useful for avoiding merge conflicts when updating your fork.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit stash\ngit fetch\ngit pull\ngit stash apply stash@{0}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Submodules for Documentation Generation in Jinja2\nDESCRIPTION: Creates a custom content block that iterates through all modules in the 'modules' variable and generates autodoc documentation for each, including members, special methods (specifically __init__), undocumented members, and private members.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/data_module.rst#2025-04-23_snippet_1\n\nLANGUAGE: jinja2\nCODE:\n```\n{% block custom_content %}\n{% for submodule in modules %}\n.. automodule:: {{submodule}}\n    :members:\n    :special-members: __init__\n    :undoc-members:\n    :private-members:\n\n{% endfor %}\n{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Activating Virtual Environment in WSL\nDESCRIPTION: Command to activate the ivy_dev virtual environment.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_19\n\nLANGUAGE: none\nCODE:\n```\nsource ivy_dev/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Listing Python Package Dependencies for ivy-llc/ivy Project\nDESCRIPTION: This snippet lists the required Python packages for the ivy-llc/ivy project. It includes libraries for data handling, machine learning frameworks, visualization, and testing. Some packages have specific requirements or alternate module names noted in comments.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/requirements/optional_apple_silicon_gpu_1.txt#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nh5py\njax\njaxlib\njax-metal\nhypothesis\nmatplotlib\nnetworkx\nopencv-python  # mod_name=cv2\npaddlepaddle  # unpinned , mod_name=paddle\npymongo\npytest\nredis\ntensorflow-macos  # mod_name=tensorflow_macos\ntensorflow-metal\ntensorflow-probability  # mod_name=tensorflow_probability\ntorch\ntorchvision\n```\n\n----------------------------------------\n\nTITLE: Specifying Array Method Signature in Swift\nDESCRIPTION: This snippet shows the signature of an array method in Swift. Array methods are functions that operate on Swift's Array type, allowing for various operations on array elements.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy_tests/array_api_testing/array_api_methods_to_test/signatures.txt#2025-04-23_snippet_2\n\nLANGUAGE: Swift\nCODE:\n```\narray_method_signature\n```\n\n----------------------------------------\n\nTITLE: Opening VSCode from Terminal\nDESCRIPTION: Command to open Visual Studio Code in the current directory.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/setting_up.rst#2025-04-23_snippet_22\n\nLANGUAGE: none\nCODE:\n```\ncode .\n```\n\n----------------------------------------\n\nTITLE: Running Pre-commit Checks Manually\nDESCRIPTION: Command to manually run all pre-commit checks on all files\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/formatting.rst#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --all-files\n```\n\n----------------------------------------\n\nTITLE: Extending Base Template with Private Members in Jinja2\nDESCRIPTION: Extends a base template ('top_level_module.rst') and overrides the options block to include private members while preserving any existing options from the parent template.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/data_module.rst#2025-04-23_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% extends \"top_level_module.rst\" %}\n\n{%- block options -%}\n    {{super()}}    :private-members:\n{%- endblock -%}\n```\n\n----------------------------------------\n\nTITLE: Rendering Module Name Block in Jinja2 Template\nDESCRIPTION: Defines a block that renders the module name by looking up the friendly name in the mapping dictionary, escaping it, and then underlining it for proper RST formatting.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/_templates/top_ivy_toc.rst#2025-04-23_snippet_1\n\nLANGUAGE: jinja2\nCODE:\n```\n{% block name %}{{ivy_module_map[fullname] | escape | underline}}{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: RST Document Structure with Table of Contents\nDESCRIPTION: RST markup for structuring the contributing documentation, including section references and a hidden table of contents tree\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :maxdepth: -1\n   :caption: Contributing\n\n   contributing/setting_up.rst\n   contributing/the_basics.rst\n   contributing/building_the_docs.rst\n   Deep Dive <https://docs.ivy.dev/overview/deep_dive.html>\n   contributing/helpful_resources.rst\n   contributing/error_handling.rst\n```\n\n----------------------------------------\n\nTITLE: RST External Links Definition\nDESCRIPTION: RST markup defining external reference links for GitHub issues and pull requests\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing.rst#2025-04-23_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. _`issues`: https://github.com/ivy-llc/ivy/issues\n.. _`pull-requests`: https://github.com/ivy-llc/ivy/pulls\n```\n\n----------------------------------------\n\nTITLE: Mentioning TensorFlow Lite in Python\nDESCRIPTION: Reference to TensorFlow Lite, a framework for deploying machine learning models on edge and mobile devices. This is not actual code, but a mention of the framework in the context of TensorFlow's current focus.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/related_work/frameworks.rst#2025-04-23_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nTensorFlow Lite\n```\n\n----------------------------------------\n\nTITLE: Creating Dummy Test File in Python for Ivy Project\nDESCRIPTION: Instructions for creating a separate dummy test.py file to evaluate particular test failures in the Ivy project. This file should not be added or committed when pushing changes.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/contributing/the_basics.rst#2025-04-23_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ntest.py\n```\n\n----------------------------------------\n\nTITLE: Canonicalization Transformation - Python Diff\nDESCRIPTION: Shows the code changes after applying the canonicalization transformer to standardize function calls.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n# After canonicalization transformer\ndef func(x: torch.Tensor) -> torch.Tensor:\n-     return nn.functional.linear(10, 5)(x) + x.mean()\n+     return torch.nn.functional.linear(x, weight, bias) + x.mean()\n```\n\n----------------------------------------\n\nTITLE: Method Transformation - Python Diff\nDESCRIPTION: Shows the code changes after applying the method transformer to convert method calls to function calls.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\ndef func(x: typing.Any):\n-     return torch.nn.functional.linear(x, weight, bias) + x.mean()\n+     return torch.nn.functional.linear(x, weight, bias) + torch.Tensor.mean(x)\n```\n\n----------------------------------------\n\nTITLE: PyTorch Backend Operation Example\nDESCRIPTION: Shows how Ivy infers and uses the PyTorch backend when performing operations with PyTorch tensors.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/deep_dive/backend_setting.rst#2025-04-23_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ny = ivy.multiply(torch.Tensor([3.]), torch.Tensor([4.]))\nivy.current_backend()\n```\n\n----------------------------------------\n\nTITLE: RST Table of Contents Configuration\nDESCRIPTION: Hidden table of contents directive configuring the documentation structure for motivation and background sections.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/docs/overview/motivation.rst#2025-04-23_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n   :hidden:\n   :maxdepth: -1\n   :caption: Background\n\n   motivation/ml_explosion.rst\n   motivation/why_transpile.rst\n```\n\n----------------------------------------\n\nTITLE: Original PyTorch Code Example\nDESCRIPTION: Sample PyTorch code demonstrating the initial state before transformation.\nSOURCE: https://github.com/ivy-llc/ivy/blob/main/ivy/transpiler/transformations/README.md#2025-04-23_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport torch\nimport torch.nn as nn\ndef func(x: torch.Tensor) -> torch.Tensor:\n    return nn.functional.linear(10, 5)(x) + x.mean()\n```"
  }
]