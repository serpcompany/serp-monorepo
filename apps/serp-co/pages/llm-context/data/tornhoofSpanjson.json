[
  {
    "owner": "tornhoof",
    "repo": "spanjson",
    "content": "TITLE: ASP.NET Core Integration with SpanJson C#\nDESCRIPTION: Demonstrates how to integrate SpanJson as the default JSON formatter in ASP.NET Core 6.0+ using the `SpanJson.AspNetCore.Formatter` NuGet package. It shows how to add SpanJson to the `AddMvc()` call in `ConfigureServices` and how to configure it with a custom resolver.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// This method gets called by the runtime. Use this method to add services to the container.\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMvc().AddSpanJson();\n}\n```\n\n----------------------------------------\n\nTITLE: SpanJson Synchronous and Asynchronous Serialization/Deserialization C#\nDESCRIPTION: Demonstrates synchronous and asynchronous serialization and deserialization using SpanJson with UTF-16 and UTF-8 encoding.  It covers generic and non-generic methods, serialization to array pools, and usage with TextWriter/TextReader and streams.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Synchronous API:\nvar result = JsonSerializer.Generic.Utf16.Serialize(input);\nvar result = JsonSerializer.NonGeneric.Utf16.Serialize(input);\nvar result = JsonSerializer.Generic.Utf16.Deserialize<Input>(input);\nvar result = JsonSerializer.NonGeneric.Utf16.Deserialize(input, typeof(Input));\n\nvar result = JsonSerializer.Generic.Utf8.Serialize(input);\nvar result = JsonSerializer.NonGeneric.Utf8.Serialize(input);\nvar result = JsonSerializer.Generic.Utf8.Deserialize<Input>(input);\nvar result = JsonSerializer.NonGeneric.Utf8.Deserialize(input, typeof(Input));\n\n// The following methods return an ArraySegment from the ArrayPool, you NEED to return it yourself after working with it.\nvar result = JsonSerializer.Generic.Utf16.SerializeToArrayPool(input);\nvar result = JsonSerializer.NonGeneric.Utf16.SerializeToArrayPool(input);\nvar result = JsonSerializer.Generic.Utf8.SerializeToArrayPool(input);\nvar result = JsonSerializer.NonGeneric.Utf8.SerializeToArrayPool(input);\n\n// Asynchronous API:\nValueTask result = JsonSerializer.Generic.Utf16.SerializeAsync(input, textWriter, cancellationToken);\nValueTask result = JsonSerializer.NonGeneric.Utf16.SerializeAsync(input, textWriter, cancellationToken);\nValueTask<Input> result = JsonSerializer.Generic.Utf16.DeserializeAsync<Input>(textReader,cancellationToken);\nValueTask<object> result = JsonSerializer.NonGeneric.Utf16.DeserializeAsync(textReader,typeof(Input),cancellationToken);\nValueTask result = JsonSerializer.Generic.Utf8.SerializeAsync(input, stream, cancellationToken);\nValueTask result = JsonSerializer.NonGeneric.Utf8.SerializeAsync(input, stream, cancellationToken);\nValueTask<Input> result = JsonSerializer.Generic.Utf8.DeserializeAsync<Input>(input, stream, cancellationToken);\nValueTask<object> result = JsonSerializer.NonGeneric.Utf8.DeserializeAsync(input, stream, typeof(Input) cancellationToken);\n\n// To use other resolvers use the appropriate overloads,e.g.:\nvar serialized = JsonSerializer.NonGeneric.Utf16.Serialize<Input, IncludeNullsOriginalCaseResolver<char>>(includeNull);\n\n// Pretty printing:\nvar pretty = JsonSerializer.PrettyPrinter.Print(serialized); // this works by reading the JSON and writing it out again with spaces and line breaks\n\n// Minify:\nvar minified = JsonSerializer.Minifier.Minify(serialized); // this works by reading the JSON and writing it out again without spaces and line breaks\n```\n\n----------------------------------------\n\nTITLE: SpanJson Serialization/Deserialization Full Example C#\nDESCRIPTION: A complete example showing basic serialization and deserialization using SpanJson.  It defines an `Input` class with a `Text` property and demonstrates how to serialize and deserialize an instance of this class using the `JsonSerializer`.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing SpanJson;\n\nnamespace Test\n{\n    public class Program\n    {\n        private static void Main(string[] args)\n        {\n            var input = new Input { Text = \"Hello World\" };\n            var serialized = JsonSerializer.Generic.Utf16.Serialize(input);\n            var deserialized = JsonSerializer.Generic.Utf16.Deserialize<Input>(serialized);\n        }\n    }\n\n    public class Input\n    {\n        public string Text { get; set; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Serializer/Deserializer Example C#\nDESCRIPTION: Illustrates the creation and use of a custom serializer/deserializer for converting a long value to and from a string during JSON serialization. It defines a custom formatter `LongAsStringFormatter` that implements `ICustomJsonFormatter<long>`.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// Type with a custom serializer to (de)serialize the long value into/from string\npublic class TestDTO\n{\n    [JsonCustomSerializer(typeof(LongAsStringFormatter), \"Hello World\")]\n    public long Value { get; set; }\n}\n\n// Serializes the Long into a string\npublic sealed class LongAsStringFormatter : ICustomJsonFormatter<long>\n{\n    public static readonly LongAsStringFormatter Default = new LongAsStringFormatter();\n\n    public object Arguments { get; set; } // the Argument from the attribute will be assigned\n\n    public void Serialize(ref JsonWriter<char> writer, long value)\n    {\n        StringUtf16Formatter.Default.Serialize(ref writer, value.ToString(CultureInfo.InvariantCulture));\n    }\n\n    public long Deserialize(ref JsonReader<char> reader)\n    {\n        var value = StringUtf16Formatter.Default.Deserialize(ref reader);\n        if (long.TryParse(value, out long longValue))\n        {\n            return longValue;\n        }\n\n        throw new InvalidOperationException(\"Invalid value.\");\n    }\n\n    public void Serialize(ref JsonWriter<byte> writer, long value)\n    {\n        StringUtf8Formatter.Default.Serialize(ref writer, value.ToString(CultureInfo.InvariantCulture));\n    }\n\n    public long Deserialize(ref JsonReader<byte> reader)\n    {\n        var value = StringUtf8Formatter.Default.Deserialize(ref reader);\n        if (long.TryParse(value, out long longValue))\n        {\n            return longValue;\n        }\n\n        throw new InvalidOperationException(\"Invalid value.\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Resolver Implementation C#\nDESCRIPTION: Shows how to implement a custom resolver by inheriting from `ResolverBase`.  It provides an example of a custom resolver named `CustomResolver` that configures specific `SpanJsonOptions` for null handling, naming conventions, enum serialization, and byte array handling.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class CustomResolver<TSymbol> : ResolverBase<TSymbol, CustomResolver<TSymbol>> where TSymbol : struct\n{\n    public CustomResolver() : base(new SpanJsonOptions\n    {\n        NullOption = NullOptions.ExcludeNulls,\n        NamingConvention = NamingConventions.CamelCase,\n        EnumOption = EnumOptions.Integer,\n        ByteArrayOptions = ByteArrayOptions.Base64\n    })\n    {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JsonConstructor Attribute Usage C#\nDESCRIPTION: Demonstrates the usage of the `JsonConstructor` attribute for specifying which constructor should be used during deserialization. It shows how to map constructor parameters to member names, including handling different names and order.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing SpanJson;\n\nnamespace Test\n{\n    // This JsonConstructorAttribute assumes that the constructor parameter names are the same as the member names (case insensitive comparison, order is not important)\n    public class DefaultDO\n    {\n        [JsonConstructor]\n        public DefaultDO(string key, int value)\n        {\n            Key = key;\n            Value = value;\n        }\n\n        public string Key { get; }\n        public int Value { get; }\n    }\n\n    // This JsonConstructorAttribute allows overwriting the matching names of the constructor parameter names to allow for different member names vs. constructor parameter names, order is important here\n    public readonly struct NamedDO\n    {\n        [JsonConstructor(nameof(Key), nameof(Value))]\n        public NamedDO(string first, int second)\n        {\n            Key = first;\n            Value = second;\n        }\n\n        public string Key { get; }\n        public int Value { get; }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Formatter Annotation Example C#\nDESCRIPTION: Shows how to annotate a custom type with a custom formatter, ensuring that the custom formatter is always used for serialization and deserialization of that type. It defines a class `TypeWithCustomSerializer` and a corresponding formatter `TwcsCustomSerializer`.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// It's possible to annotate custom types a custom formatter to always use the custom formatter\n[JsonCustomSerializer(typeof(TwcsCustomSerializer))]\npublic class TypeWithCustomSerializer : IEquatable<TypeWithCustomSerializer>\n{\n    public long Value { get; set; }\n}\n\n// Instead of copying the implementation of for serialize/deserialize for utf8/utf16\n// it is possible to use the writer/reader methods which support both, there is no or only a very minor performance difference\npublic sealed class TwcsCustomSerializer : ICustomJsonFormatter<TypeWithCustomSerializer>\n{\n    public static readonly TwcsCustomSerializer Default = new TwcsCustomSerializer();\n\n    public object Arguments { get; set; }\n\n    private void SerializeInternal<TSymbol>(ref JsonWriter<TSymbol> writer, TypeWithCustomSerializer value) where TSymbol : struct\n    {\n        if (value == null)\n        {\n            writer.WriteNull();\n            return;\n        }\n\n        writer.WriteBeginObject();\n        writer.WriteName(nameof(TypeWithCustomSerializer.Value));\n        writer.WriteInt64(value.Value);\n        writer.WriteEndObject();\n    }\n\n    public void Serialize(ref JsonWriter<byte> writer, TypeWithCustomSerializer value)\n    {\n        SerializeInternal(ref writer, value);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private TypeWithCustomSerializer DeserializeInternal<TSymbol>(ref JsonReader<TSymbol> reader) where TSymbol : struct\n    {\n        if (reader.ReadIsNull())\n        {\n            return null;\n        }\n\n        reader.ReadBeginObjectOrThrow();\n        var result = new TypeWithCustomSerializer {Value = reader.ReadInt64()};\n        reader.ReadEndObjectOrThrow();\n        return result;\n    }\n\n    public TypeWithCustomSerializer Deserialize(ref JsonReader<byte> reader)\n    {\n        return DeserializeInternal(ref reader);\n    }\n\n    public void Serialize(ref JsonWriter<char> writer, TypeWithCustomSerializer value)\n    {\n        SerializeInternal(ref writer, value);\n    }\n\n    public TypeWithCustomSerializer Deserialize(ref JsonReader<char> reader)\n    {\n        return DeserializeInternal(ref reader);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JsonExtensionData Attribute Example C#\nDESCRIPTION: Illustrates the use of the `JsonExtensionData` attribute to capture additional key-value pairs from the JSON input that do not map to specific properties in the class. These key-value pairs are stored in a dictionary.\nSOURCE: https://github.com/tornhoof/spanjson/blob/master/README.md#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Below class will serialize Key and Value and any additional key-value-pair from the dictionary\npublic class ExtensionTest\n{\n    public string Key;\n    public string Value;\n\n    [JsonExtensionData]\n    public IDictionary<string, object> AdditionalValues { get; set; }\n}\n```"
  }
]