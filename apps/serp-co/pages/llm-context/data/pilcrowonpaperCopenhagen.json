[
  {
    "owner": "pilcrowonpaper",
    "repo": "copenhagen",
    "content": "TITLE: Generating Secure Random Tokens Using Go\nDESCRIPTION: Provides a Go code snippet for generating a cryptographically secure random token. It creates a 15-byte random value, encodes it with base32 to produce a 24-character token, suitable for high-entropy identifiers such as session tokens or verification codes. Relies on 'crypto/rand' for security.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/server-side-tokens.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base32\"\n)\n\nbytes := make([]byte, 15)\nrand.Read(bytes)\nsessionId := base32.StdEncoding.EncodeToString(bytes)\n```\n\n----------------------------------------\n\nTITLE: Go Function for Generating CSRF Token with HMAC\nDESCRIPTION: This Go code snippet demonstrates how to generate a CSRF token and its corresponding HMAC using the SHA-256 algorithm. The function takes a session ID as input, generates a random token, and calculates the HMAC using a secret key. The function depends on the `crypto/rand`, `encoding/base64`, `crypto/hmac`, `crypto/sha256` and `string` packages.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/csrf.md#_snippet_3\n\nLANGUAGE: Go\nCODE:\n```\nfunc generateCSRFToken(sessionId string) (string, []byte) {\n\tbuffer := [10]byte{}\n\tcrypto.rand.Read(buffer)\n\tcsrfToken := base64.StdEncoding.encodeToString(buffer)\n\tmac := hmac.New(sha256.New, secret)\n\tmac.Write([]byte(csrfToken + \".\" + sessionId))\n\tcsrfTokenHMAC := mac.Sum(nil)\n\treturn csrfToken, csrfTokenHMAC\n}\n```\n\n----------------------------------------\n\nTITLE: Validating and Extending Session Expiration in Go\nDESCRIPTION: This Go code snippet demonstrates how to validate a user session, check for expiration, and automatically extend the session's lifetime using a sliding expiration mechanism. Dependencies include the standard Go libraries 'time' and 'errors', as well as custom logic for session retrieval and updating via 'getSessionFromStorage', 'updateSessionExpiration', and a 'Session' struct. It requires a valid session ID as input, and returns either the updated session object or an error; if the session is expired or invalid. Limitations include the need for correct time synchronization and valid session storage implementation.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/sessions.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nconst sessionExpiresIn = 30 * 24 * time.Hour\n\nfunc validateSession(sessionId string) (*Session, error) {\n\tsession, ok := getSessionFromStorage(sessionId)\n\tif !ok {\n\t\treturn nil, errors.New(\"invalid session id\")\n\t}\n\tif time.Now().After(session.ExpiresAt) {\n\t\treturn nil, errors.New(\"expired session\")\n\t}\n\tif time.Now().After(session.expiresAt.Sub(sessionExpiresIn / 2)) {\n\t\tsession.ExpiresAt = time.Now().Add(sessionExpiresIn)\n\t\tupdateSessionExpiration(session.Id, session.ExpiresAt)\n\t}\n\treturn session, nil\n}\n```\n\n----------------------------------------\n\nTITLE: PKCE Code Challenge Generation in Go\nDESCRIPTION: This Go snippet shows how to generate a code challenge from a code verifier using SHA256 hashing and base64 URL encoding with no padding. The code verifier should be generated using a cryptographically secure random generator.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/oauth.md#_snippet_2\n\nLANGUAGE: Go\nCODE:\n```\nvar codeVerifier string\ncodeChallengeBuf := sha256.Sum256([]byte(codeVerifier))\ncodeChallenge := base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(codeChallengeBuf)\n```\n\n----------------------------------------\n\nTITLE: Creating a new WebAuthn credential\nDESCRIPTION: This TypeScript code snippet demonstrates how to create a new WebAuthn credential using the `navigator.credentials.create` method. It sets up the `publicKey` parameters including attestation, relying party, user details, public key credential parameters, challenge, authenticator selection, and excluded credentials. It handles the response and extracts client data and attestation objects.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst credential = await navigator.credentials.create({\n\tpublicKey: {\n\t\tattestation: \"none\",\n\t\trp: { name: \"My app\" },\n\t\tuser: {\n\t\t\tid: crypto.getRandomValues(new Uint8Array(32)),\n\t\t\tname: username,\n\t\t\tdisplayName: name,\n\t\t},\n\t\tpubKeyCredParams: [\n\t\t\t{\n\t\t\t\ttype: \"public-key\",\n\t\t\t\t// ECDSA with SHA-256\n\t\t\t\talg: -7,\n\t\t\t},\n\t\t],\n\t\tchallenge,\n\t\tauthenticatorSelection: {\n\t\t\t// See note below.\n\t\t\tuserVerification: \"required\",\n\t\t\tresidentKey: \"required\",\n\t\t\trequireResidentKey: true,\n\t\t},\n\t\t// list of existing credentials\n\t\texcludeCredentials: [\n\t\t\t{\n\t\t\t\tid: new Uint8Array(/*...*/),\n\t\t\t\ttype: \"public-key\",\n\t\t\t},\n\t\t],\n\t},\n});\nif (!(credential instanceof PublicKeyCredential)) {\n\tthrow new Error(\"Failed to create credential\");\n}\nconst response = credential.response;\nif (!(response instanceof AuthenticatorAttestationResponse)) {\n\tthrow new Error(\"Unexpected\");\n}\n\nconst clientDataJSON: ArrayBuffer = response.clientDataJSON;\nconst attestationObject: ArrayBuffer = response.attestationObject;\n```\n\n----------------------------------------\n\nTITLE: Salting passwords before hashing\nDESCRIPTION: This snippet demonstrates the basic process of salting a password before hashing it. It generates a random salt, concatenates it with the password, hashes the result, and then stores both the hash and the salt.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/password-authentication.md#_snippet_2\n\nLANGUAGE: TEXT\nCODE:\n```\nsalt = randomValues()\nhash = hashPassword(password + salt) + salt\n```\n\n----------------------------------------\n\nTITLE: HTML Form with Anti-CSRF Token\nDESCRIPTION: This HTML code snippet demonstrates a form with an anti-CSRF token included as a hidden input field. The `__csrf` input contains the CSRF token, which should be a unique value associated with the user's session. This allows the server to verify that the request originated from the application and prevent CSRF attacks.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/csrf.md#_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n<form method=\"post\">\n\t<input name=\"message\" />\n\t<input type=\"hidden\" name=\"__csrf\" value=\"<CSRF_TOKEN>\" />\n\t<button>Submit</button>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Comparing password hashes using constant time comparison in Go\nDESCRIPTION: This code snippet shows how to compare password hashes in Go using constant time comparison to prevent timing attacks. It uses the `crypto/subtle` package for the comparison and `golang.org/x/crypto/argon2` for Argon2 hashing.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/password-authentication.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/subtle\"\n\t\"golang.org/x/crypto/argon2\"\n)\n\nvar storedHash []byte\nvar password []byte\nhash := argon2.IDKey(password, salt, 2, 19*1024, 1, 32)\n\nif (subtle.ConstantTimeCompare(hash, storedHash)) {\n\t// Valid password.\n}\n```\n\n----------------------------------------\n\nTITLE: WebAuthn Credential Retrieval TypeScript\nDESCRIPTION: This TypeScript code snippet retrieves a public key credential using the WebAuthn API. It initiates the credential retrieval process with a challenge and user verification requirement. It then verifies the credential type and extracts relevant information like client data, authenticator data, signature, and credential ID from the response. These data points are crucial for server-side verification. Requires a browser with WebAuthn support.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst credential = await navigator.credentials.get({\n\tpublicKey: {\n\t\tchallenge,\n\t\tuserVerification: \"required\",\n\t},\n});\n\nif (!(credential instanceof PublicKeyCredential)) {\n\tthrow new Error(\"Failed to create credential\");\n}\nconst response = credential.response;\nif (!(response instanceof AuthenticatorAssertionResponse)) {\n\tthrow new Error(\"Unexpected\");\n}\n\nconst clientDataJSON: ArrayBuffer = response.clientDataJSON);\nconst authenticatorData: ArrayBuffer = response.authenticatorData\nconst signature: ArrayBuffer = response.signature);\nconst credentialId: ArrayBuffer = publicKeyCredential.rawId;\n```\n\n----------------------------------------\n\nTITLE: ECDSA Signature Verification Go\nDESCRIPTION: This Go code verifies an ECDSA signature using the public key, authenticator data, and the client data JSON hash. It first calculates the SHA-256 hash of the client data JSON, then combines the authenticator data with the hash. The resulting data is hashed again using SHA-256 and the result is used to verify the signature. This step ensures that the signature is valid and that the client data hasn't been tampered with. Requires `crypto/ecdsa` and `crypto/sha256` packages.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_9\n\nLANGUAGE: Go\nCODE:\n```\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/sha256\"\n)\n\nclientDataJSONHash := sha256.Sum256(clientDataJSON)\n// Concatenate the authenticator data with the hashed client data JSON.\ndata := append(authenticatorData, clientDataJSONHash[:]...)\nhash := sha256.Sum256(data)\nvalidSignature := ecdsa.VerifyASN1(publicKey, hash[:], signature)\n```\n\n----------------------------------------\n\nTITLE: WebAuthn Client Data Type Verification Go\nDESCRIPTION: This Go code snippet verifies the `Type` field of the client data. It validates that the client data type is `webauthn.get`, ensuring that the request is a valid WebAuthn authentication request. If the type is invalid, it returns an error. This is a crucial step in the server-side authentication process for security reasons.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_8\n\nLANGUAGE: Go\nCODE:\n```\nif clientData.Type != \"webauthn.get\" {\n\treturn errors.New(\"invalid type\")\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing authenticator data in Go\nDESCRIPTION: This Go code snippet parses the authenticator data. It extracts the relying party ID hash, checks for user presence and user verified flags, and extracts the credential ID and COSE public key.  It includes error handling for invalid data lengths and relying party ID mismatches. It requires the `bytes`, `crypto/sha256`, `encoding/binary`, `encoding/json`, and `errors` packages.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"encoding/json\"\n\t\"errors\"\n)\nif len(authenticatorData) < 37 {\n\treturn errors.New(\"invalid authenticator data\")\n}\nrpIdHash := authenticatorData[0:32]\nexpectedRpIdHash := sha256.Sum256([]byte(\"example.com\"))\nif bytes.Equal(rpIdHash, expectedRpIdHash[:]) {\n\treturn errors.New(\"invalid relying party ID\")\n}\n\n// Check for the \"user present\" flag.\nif (authenticatorData[32] & 1) != 1 {\n\treturn errors.New(\"user not present\")\n}\n// Check for the \"user verified\" flag if you need user verification.\nif ((authenticatorData[32] >> 2) & 1) != 1 {\n\treturn errors.New(\"user not verified\")\n}\nif ((authenticatorData[32] >> 6) & 1) != 1 {\n\treturn errors.New(\"missing credentials\")\n}\n\nif (len(authenticatorData) < 55) {\n\treturn errors.New(\"invalid authenticator data\")\n}\ncredentialIdSize:= binary.BigEndian.Uint16(authenticatorData[53 : 55])\nif (len(authenticatorData) < 55 + credentialIdSize) {\n\treturn errors.New(\"invalid authenticator data\")\n}\ncredentialId := authenticatorData[55 : 55+credentialIdSize]\ncoseKey := authenticatorData[55+credentialIdSize:]\n\n// Parse COSE public key\n```\n\n----------------------------------------\n\nTITLE: Validating client data in Go\nDESCRIPTION: This Go code snippet validates the client data, which is JSON-encoded. It verifies the type, challenge, and origin. It requires the `bytes`, `crypto/sha256`, `encoding/base64`, `encoding/json`, and `errors` packages.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n)\n\nvar expectedChallenge []byte\n\n// Verify the challenge and delete it from storage.\n\nvar credentialId string\n\nvar clientData ClientData\n\n// Parse JSON\n\nif clientData.Type != \"webauthn.create\" {\n\treturn errors.New(\"invalid type\")\n}\nif !verifyChallenge(clientData.Challenge) {\n\treturn errors.New(\"invalid challenge\")\n}\nif clientData.Origin != \"https://example.com\" {\n\treturn errors.New(\"invalid origin\")\n}\n\ntype ClientData struct {\n\tType\t  string // \"type\"\n\tChallenge string // \"challenge\"\n\tOrigin\t  string // \"origin\"\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Fetch Request for Sending Money\nDESCRIPTION: This TypeScript code snippet demonstrates a vulnerable `fetch()` request that can be exploited in a CSRF attack. The request submits data to `bank.com` without any CSRF protection. It creates a `URLSearchParams` object, sets the recipient and value, and then sends a POST request to the specified URL. The function depends on the `fetch` API being available in the environment.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/csrf.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst body = new URLSearchParams();\nbody.set(\"recipient\", \"attacker\");\nbody.set(\"value\", \"$100\");\n\nawait fetch(\"https://bank.com/send-money\", {\n\tmethod: \"POST\",\n\tbody\n});\n```\n\n----------------------------------------\n\nTITLE: 2FA with WebAuthn and AllowCredentials TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to implement 2FA using WebAuthn's `allowCredentials` option. It retrieves a public key credential and specifies a list of the user's credentials, which enables support for non-resident keys. This configuration is crucial for scenarios where users might use multiple devices or security tokens. The `id` and `type` properties are necessary for specifying each credential.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst credential = await navigator.credentials.get({\n\tpublicKey: {\n\t\tchallenge,\n\t\tuserVerification: \"required\",\n\t\t// list of user credentials\n\t\tallowCredentials: [\n\t\t\t{\n\t\t\t\tid: new Uint8Array(/*...*/),\n\t\t\t\ttype: \"public-key\",\n\t\t\t},\n\t\t],\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: HTML Form for Sending Money\nDESCRIPTION: This HTML code snippet demonstrates a vulnerable form that can be exploited in a CSRF attack. The form submits data to `bank.com` without any CSRF protection, allowing an attacker to potentially make authenticated requests on behalf of the user. The form sends money to a specified recipient with a specified value.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/csrf.md#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<form action=\"https://bank.com/send-money\" method=\"post\">\n\t<input name=\"recipient\" value=\"attacker\" />\n\t<input name=\"value\" value=\"$100\" />\n\t<button>Send money</button>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Parsing attestation object in Go\nDESCRIPTION: This Go code snippet defines the structure for parsing the attestation object, which is encoded with CBOR. It includes the attestation statement and authenticator data. It checks that the attestation format is 'none'.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nvar attestationObject AttestationObject\n\n// Parse attestation object\n\nif attestationObject.Fmt != \"none\" {\n\treturn errors.New(\"invalid attestation statement format\")\n}\n\ntype AttestationObject  struct {\n\tFmt                  string // \"fmt\"\n\tAttestationStatement AttestationStatement // \"attStmt\"\n\tAuthenticatorData    []byte // \"authData\"\n}\n\ntype AttestationStatement struct {\n\t// see spec\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring passkey authenticator selection\nDESCRIPTION: This TypeScript snippet configures the `authenticatorSelection` options for creating passkeys, ensuring user verification is required, and the credential is a resident key. This setup is suitable for password replacement.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst credential = await navigator.credentials.create({\n\tpublicKey: {\n\t\t// ...\n\t\tauthenticatorSelection: {\n\t\t\tuserVerification: \"required\",\n\t\t\tresidentKey: \"required\",\n\t\t\trequireResidentKey: true,\n\t\t},\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: Signing a Message with ECDSA in Go\nDESCRIPTION: Demonstrates how to sign a message using ECDSA in Go, leveraging the 'crypto/ecdsa', 'crypto/rand', and 'crypto/sha256' packages. The code takes a string message, hashes it with SHA-256, and generates an ASN.1 encoded signature using the provided private key. Requires an initialized ECDSA private key (`privateKey`). The input is any string message; output is a signature in ASN.1 DER encoding as per the PKIX standard.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/cryptography/ecdsa.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n)\n\nmsg := \"Hello world!\"\nhash := sha256.Sum256([]byte(msg))\nsignature, err := ecdsa.SignASN1(rand.Reader, privateKey, hash[:])\n```\n\n----------------------------------------\n\nTITLE: Using Verification Links with Tokens\nDESCRIPTION: An example URL structure for email verification links that use a long, random, single-use token. These links should be configured with appropriate Referrer Policy to prevent token leakage.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/email-verification.md#_snippet_0\n\nLANGUAGE: url\nCODE:\n```\nhttps://example.com/verify-email/<TOKEN>\n```\n\n----------------------------------------\n\nTITLE: Generating Random Strings with Base32 Encoding in Go\nDESCRIPTION: Uses crypto/rand to generate cryptographically secure random bytes and encodes them using standard base32 encoding. This produces a random string with a standardized character set.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base32\"\n)\n\nfunc generateRandomString() string {\n\tbytes := make([]byte, 12)\n\trand.Read(bytes)\n\treturn base32.StdEncoding.EncodeToString(bytes)\n}\n```\n\n----------------------------------------\n\nTITLE: Checking for compromised passwords using haveibeenpwned API\nDESCRIPTION: This snippet shows how to use the haveibeenpwned API to check if a password has been compromised. It hashes the password with SHA-1, takes the first 5 characters, and makes a GET request to the API.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/password-authentication.md#_snippet_0\n\nLANGUAGE: HTTP\nCODE:\n```\nGET https://api.pwnedpasswords.com/range/12345\n```\n\n----------------------------------------\n\nTITLE: SQL Table Definition for Tokens\nDESCRIPTION: Defines a SQL table named 'token' to persist server-side tokens with associated user IDs, expiration timestamps, and constraints. It establishes foreign key relationships with user data and supports long-term or session-based tokens. Suitable for relational databases like PostgreSQL or MySQL.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/server-side-tokens.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE token (\n\ttoken STRING NOT NULL UNIQUE,\n\texpires_at INTEGER NOT NULL,\n\tuser_id INTEGER NOT NULL,\n\n\tFOREIGN KEY (user_id) REFERENCES user(id)\n)\n```\n\n----------------------------------------\n\nTITLE: OIDC Discovery JSON Example\nDESCRIPTION: This JSON snippet shows the format of the JSON document returned by the OpenID Connect discovery endpoint. It provides the necessary information to configure an application, including the endpoint URLs for authorization, token exchange, and user info retrieval. \nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/oauth.md#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"issuer\": \"https://example.com\",\n  \"authorization_endpoint\": \"https://example.com/oauth2/authorize\",\n  \"token_endpoint\": \"https://example.com/oauth2/token\",\n  \"userinfo_endpoint\": \"https://example.com/oauth2/userinfo\",\n  \"code_challenge_methods_supported\": [\"S256\"],\n  \"grant_types_supported\": [\"authorization_code\", \"refresh_token\"],\n  \"scopes_supported\": [\"openid\", \"email\", \"profile\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers Using Rejection Sampling in Go\nDESCRIPTION: Implements rejection sampling with bit masking to generate unbiased random integers within a custom range. This approach repeatedly generates random values until one falls within the desired range.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/rand\"\n\t\"math/big\"\n)\n\nfunc generateRandomUint64(max *big.Int) uint64 {\n\trandVal := new(big.Int)\n\tshift := max.BitLen() % 8\n\tbytes := make([]byte, (max.BitLen() / 8) + 1)\n\trand.Read(bytes)\n\tif shift != 0 {\n\t\tbytes[0] &= (1 << shift) - 1\n\t}\n\trandVal.SetBytes(bytes)\n\tfor randVal.Cmp(max) >= 0 {\n\t\trand.Read(bytes)\n\t\tif shift != 0 {\n\t\t\tbytes[0] &= (1 << shift) - 1\n\t\t}\n\t\trandVal.SetBytes(bytes)\n\t}\n\treturn randVal.Uint64()\n}\n```\n\n----------------------------------------\n\nTITLE: Go HTTP Request Handler with Origin Header Check\nDESCRIPTION: This Go code snippet demonstrates how to check the `Origin` header of an incoming HTTP request to prevent CSRF attacks.  It verifies that the `Origin` header matches the expected value for non-GET requests. If the `Origin` header is invalid, the handler returns a 403 Forbidden error. It depends on the `net/http` package.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/csrf.md#_snippet_4\n\nLANGUAGE: Go\nCODE:\n```\nfunc handleRequest(w http.ResponseWriter, request *http.Request) {\n  \tif request.Method != \"GET\" {\n\t\toriginHeader := request.Header.Get()\n\t\t// You can also compare it against the Host or X-Forwarded-Host header.\n\t\tif originHeader != \"https://example.com\" {\n\t\t\t// Invalid request origin\n\t\t\tw.WriteHeader(403)\n\t\t\treturn\n\t\t}\n  \t}\n  \t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring security token authenticator selection\nDESCRIPTION: This TypeScript snippet configures the `authenticatorSelection` options for creating credentials for security tokens, disabling user verification, allowing non-resident keys, and limiting the authenticator to cross-platform security tokens.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/webauthn.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst credential = await navigator.credentials.create({\n\tpublicKey: {\n\t\t// ...\n\t\tauthenticatorSelection: {\n\t\t\tuserVerification: \"discouraged\",\n\t\t\tresidentKey: \"discouraged\",\n\t\t\trequireResidentKey: false,\n\t\t\tauthenticatorAttachment: \"cross-platform\",\n\t\t},\n\t},\n});\n```\n\n----------------------------------------\n\nTITLE: HTML Sign-in Link\nDESCRIPTION: This HTML snippet creates a hyperlink to the login endpoint, allowing users to initiate the OAuth flow. The href attribute points to the application's login route, initiating the OAuth process with the specified provider.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/oauth.md#_snippet_0\n\nLANGUAGE: HTML\nCODE:\n```\n<a href=\"/login/github\">Sign in with GitHub</a>\n```\n\n----------------------------------------\n\nTITLE: Base64 Encoding Credentials in Go\nDESCRIPTION: This Go snippet demonstrates how to base64 encode client ID and client secret for use in the Authorization header when exchanging an authorization code for an access token. It uses the standard library's `base64` package to encode the concatenated client ID and secret.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/oauth.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nvar clientId, clientSecret string\ncredentials := base64.StdEncoding.EncodeToString([]byte(clientId + \":\" + clientSecret))\n```\n\n----------------------------------------\n\nTITLE: Generating Random Strings Using Custom Alphabet in Go\nDESCRIPTION: Builds a random string by repeatedly selecting random characters from a defined alphabet. This approach requires a separate random integer generator and gives complete control over the character set.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nconst alphabet = \"abcdefg\"\n\nfunc generateRandomString() string {\n\tvar result string\n\tfor i := 0; i < 12; i ++ {\n\t\tresult += string(alphabet[generateRandomInt(0, len(alphabet))])\n\t}\n\treturn result\n}\n```\n\n----------------------------------------\n\nTITLE: Example response from haveibeenpwned API\nDESCRIPTION: This is an example of the response from the haveibeenpwned API. It is a list of SHA-1 password suffixes beginning with the 5 characters provided in the request. These suffixes, when combined with the prefix, represent compromised passwords.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/password-authentication.md#_snippet_1\n\nLANGUAGE: TEXT\nCODE:\n```\nec68dea7966a1ea2ba9408be4dcc409884f\n248b2dddf14a111b9d08b906d06224a0a79\nf10a49ecd2ada17a120dc359f162b84e12c\n```\n\n----------------------------------------\n\nTITLE: Generating Random Strings with Custom Character Set in Go\nDESCRIPTION: Creates a custom base32 encoding with a specific character set, then uses it to encode randomly generated bytes into a string. This technique allows for control over which characters appear in the output.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base32\"\n)\n\nvar customEncoding = base32.NewEncoding(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\")\n\nfunc generateRandomString() string {\n\tbytes := make([]byte, 12)\n\trand.Read(bytes)\n\treturn customEncoding.EncodeToString(bytes)\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Floating-Point Numbers Using Bit Manipulation in Go\nDESCRIPTION: Creates a random float64 between 0 and 1 by directly setting the mantissa bits. This approach avoids division operations and can be more efficient while still providing uniform distribution.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/rand\"\n\t\"math\"\n)\n\nfunc generateRandomFloat64() float64 {\n\tbytes := make([]byte, 7)\n\trand.Read(bytes)\n\tbytes = append(make([]byte, 1), bytes...)\n\t// set exponent part to 0b01111111111\n\tbytes[0] = 0x3f\n\tbytes[1] |= 0xf0\n\treturn math.Float64frombits(binary.BigEndian.Uint64(bytes)) - 1\n}\n```\n\n----------------------------------------\n\nTITLE: ASN.1 DER Sequence Structure for ECDSA Signatures (PKIX RFC 5480)\nDESCRIPTION: Describes the ASN.1 syntax for ECDSA signature encoding per PKIX (RFC 5480). This formal definition is used for DER-encoded signatures, typically generated by cryptographic libraries. It depicts the signature as a sequence containing r and s as INTEGERs. Required for standards-compliant storage or exchange of signatures.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/cryptography/ecdsa.md#_snippet_2\n\nLANGUAGE: asn.1\nCODE:\n```\nSEQUENCE {\n    r     INTEGER,\n    s     INTEGER\n}\n```\n\n----------------------------------------\n\nTITLE: Compressed ECDSA Public Key SEC1 Binary Structure\nDESCRIPTION: Shows the SEC1 compressed format of an ECDSA public key: 0x02 or 0x03 prefix (depending on whether y is even or odd) concatenated with x (big-endian byte array). Enables compact public key representation. Input must compute the parity of y as required.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/cryptography/ecdsa.md#_snippet_4\n\nLANGUAGE: binary\nCODE:\n```\n0x02 || x\n0x03 || x\n```\n\n----------------------------------------\n\nTITLE: Generating Random Floating-Point Numbers Using Integer Division in Go\nDESCRIPTION: Produces a random float between 0 and 1 by generating a random integer and dividing by a power of 2. Uses a 53-bit integer (maximum precision for float64) to ensure uniform distribution.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nfunc generateRandomFloat64() float64 {\n\treturn float64(generateRandomInteger(1<<53)) / (1 << 53)\n}\n```\n\n----------------------------------------\n\nTITLE: Uncompressed ECDSA Public Key SEC1 Binary Structure\nDESCRIPTION: Illustrates how to construct the uncompressed SEC1 format of an ECDSA public key. The format begins with 0x04, followed by x and y coordinates as big-endian byte arrays, each matching the curve's size. Inputs are x and y as byte arrays. Used for compatibility with SEC1-based systems and libraries.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/cryptography/ecdsa.md#_snippet_3\n\nLANGUAGE: binary\nCODE:\n```\n0x04 || x || y\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers in Power-of-2 Range Using Bit Masking in Go\nDESCRIPTION: Generates a random integer within a range that is a power of 2 using bit masking. This approach is simple and efficient when the desired range is 2, 4, 8, 16, etc.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nbytes := make([]byte, 1)\nrand.Read(bytes)\nvalue := bytes[0] & 0x03 // random value between [0, 3]\n```\n\n----------------------------------------\n\nTITLE: Concatenating ECDSA Signature (r || s) IEEE P1363 Format in TypeScript\nDESCRIPTION: Represents the assembly of an ECDSA signature in the IEEE P1363 format, where the positive integers r and s (with bit lengths matching the curve) are concatenated as big-endian byte sequences. Dependencies include handling of big integer types and byte arrays according to the curve's specifications. The input should be r and s as byte arrays; output is their straight concatenation, used for interoperability with libraries expecting the P1363 format.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/cryptography/ecdsa.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nr || s;\n```\n\n----------------------------------------\n\nTITLE: ASN.1 DER Sequence for ECDSA Public Key PKIX SubjectPublicKeyInfo\nDESCRIPTION: Defines the ASN.1 structure for representing an ECDSA public key using 'SubjectPublicKeyInfo' per RFC 5480. It wraps the algorithm identifier and SEC1 format (compressed or uncompressed key) in a BIT STRING. Suitable as DER-encoded input for APIs or files requiring PKIX/subjectPublicKeyInfo syntax.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/cryptography/ecdsa.md#_snippet_5\n\nLANGUAGE: asn.1\nCODE:\n```\nSubjectPublicKeyInfo := SEQUENCE {\n    algorithm           AlgorithmIdentifier,\n    subjectPublicKey    BIT STRING\n}\n```\n\n----------------------------------------\n\nTITLE: ASN.1 DER Structure for ECDSA AlgorithmIdentifier PKIX Format\nDESCRIPTION: Specifies the ASN.1 encoding for the PKIX 'AlgorithmIdentifier' pertaining to ECDSA. This sequence includes the ECDSA algorithm OID (e.g., 1.2.840.10045.2.1) and the OID for the named curve (such as P-256). Required for full PKIX public key representations.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/cryptography/ecdsa.md#_snippet_6\n\nLANGUAGE: asn.1\nCODE:\n```\nAlgorithmIdentifier := SEQUENCE {\n    algorithm   OBJECT IDENTIFIER\n    namedCurve  OBJECT IDENTIFIER\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers Using Modulo in Go\nDESCRIPTION: Generates a random integer in a custom range by using the modulo operator. This approach may introduce a modulo bias, but can be acceptable if the random source has significantly more bits than needed for the range.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n)\n\n// Generates a random integer between [0, max).\n// `max` should not be a very large number.\nfunc generateRandomUint32(max uint32): uint32 {\n\tvar max uint32 = 10\n\tbytes := make([]byte, 4)\n\trand.Read(bytes)\n\trandUint32 := binary.BigEndian.Uint32(bytes) // Convert bytes to uint32\n\treturn randUint32 % max\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Integers Using Floating-Point Multiplication in Go\nDESCRIPTION: Creates a random integer by multiplying a maximum value with a random float. While this can introduce bias, it spreads the bias evenly and can be suitable for small ranges.\nSOURCE: https://github.com/pilcrowonpaper/copenhagen/blob/main/pages/random-values.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc generateRandomUint32(max uint32): uint32 {\n\tvar max uint32 = 10\n\treturn uint32(max * generateRandomFloat32())\n}\n```"
  }
]