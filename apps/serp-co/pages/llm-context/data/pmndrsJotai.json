[
  {
    "owner": "pmndrs",
    "repo": "jotai",
    "content": "TITLE: Creating Primitive Atoms with Type Inference in Jotai\nDESCRIPTION: Examples of creating primitive atoms in Jotai with automatically inferred types. The TypeScript compiler automatically determines the type based on the initial value provided.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/typescript.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst numAtom = atom(0) // primitive number atom\nconst strAtom = atom('') // primitive string atom\n```\n\n----------------------------------------\n\nTITLE: Creating Primitive Atoms in Jotai\nDESCRIPTION: Demonstrates how to create basic atoms with different data types including numbers, strings, arrays and objects. These atoms represent the basic building blocks of state in Jotai.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom } from 'jotai'\n\nconst countAtom = atom(0)\nconst countryAtom = atom('Japan')\nconst citiesAtom = atom(['Tokyo', 'Kyoto', 'Osaka'])\nconst mangaAtom = atom({ 'Dragon Ball': 1984, 'One Piece': 1997, Naruto: 1999 })\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Atoms in Jotai for Filtering Friend Lists\nDESCRIPTION: This snippet demonstrates how to create derived atoms in Jotai for filtering a list of friends based on their online status. It shows the creation of a base atom and two derived atoms for online and offline friends.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/concepts.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst dumbAtom = atom([{ name: 'Friend 1', online: false }])\nconst onlineAtom = atom((get) => get(dumbAtom).filter((item) => item.online))\nconst offlineAtom = atom((get) => get(dumbAtom).filter((item) => !item.online))\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Atoms\nDESCRIPTION: Shows different approaches to combining multiple atoms into a single derived atom, including basic and functional programming patterns.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst count1 = atom(1)\nconst count2 = atom(2)\nconst count3 = atom(3)\n\nconst sum = atom((get) => get(count1) + get(count2) + get(count3))\n```\n\nLANGUAGE: jsx\nCODE:\n```\nconst atoms = [count1, count2, count3, ...otherAtoms]\nconst sum = atom((get) => atoms.map(get).reduce((acc, count) => acc + count))\n```\n\n----------------------------------------\n\nTITLE: Implementing useSetAtom Hook in React Component\nDESCRIPTION: Demonstrates the use of useSetAtom hook to update an atom's value without reading it, which can help prevent unnecessary rerenders in performance-critical scenarios.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/use-atom.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst switchAtom = atom(false)\n\nconst SetTrueButton = () => {\n  const setCount = useSetAtom(switchAtom)\n  const setTrue = () => setCount(true)\n\n  return (\n    <div>\n      <button onClick={setTrue}>Set True</button>\n    </div>\n  )\n}\n\nconst SetFalseButton = () => {\n  const setCount = useSetAtom(switchAtom)\n  const setFalse = () => setCount(false)\n\n  return (\n    <div>\n      <button onClick={setFalse}>Set False</button>\n    </div>\n  )\n}\n\nexport default function App() {\n  const state = useAtomValue(switchAtom)\n\n  return (\n    <div>\n      State: <b>{state.toString()}</b>\n      <SetTrueButton />\n      <SetFalseButton />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using useAtom Hook in JavaScript\nDESCRIPTION: Demonstrates the basic usage of the useAtom hook to read and update an atom's value in a React component. It also includes important notes on referential equality and potential infinite loops.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/use-atom.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst [value, setValue] = useAtom(anAtom)\n\nconst stableAtom = atom(0)\nconst Component = () => {\n  const [atomValue] = useAtom(atom(0)) // This will cause an infinite loop since the atom instance is being recreated in every render\n  const [atomValue] = useAtom(stableAtom) // This is fine\n  const [derivedAtomValue] = useAtom(\n    useMemo(\n      // This is also fine\n      () => atom((get) => get(stableAtom) * 2),\n      [],\n    ),\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Example React Application with Jotai\nDESCRIPTION: Complete example showing integration of Jotai atoms in a React application with async data fetching.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/atom.mdx#2025-04-12_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Suspense } from 'react'\nimport { atom, useAtom } from 'jotai'\n\nconst userIdAtom = atom(1)\nconst userAtom = atom(async (get, { signal }) => {\n  const userId = get(userIdAtom)\n  const response = await fetch(\n    `https://jsonplaceholder.typicode.com/users/${userId}?_delay=2000`,\n    { signal },\n  )\n  return response.json()\n})\n\nconst Controls = () => {\n  const [userId, setUserId] = useAtom(userIdAtom)\n  return (\n    <div>\n      User Id: {userId}\n      <button onClick={() => setUserId((c) => c - 1)}>Prev</button>\n      <button onClick={() => setUserId((c) => c + 1)}>Next</button>\n    </div>\n  )\n}\n\nconst UserName = () => {\n  const [user] = useAtom(userAtom)\n  return <div>User name: {user.name}</div>\n}\n\nconst App = () => (\n  <>\n    <Controls />\n    <Suspense fallback=\"Loading...\">\n      <UserName />\n    </Suspense>\n  </>\n)\n\nexport default App\n```\n\n----------------------------------------\n\nTITLE: Atom Creation in React Components\nDESCRIPTION: Example of creating atoms within React components using useMemo for stable references.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/atom.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst Component = ({ value }) => {\n  const valueAtom = useMemo(() => atom({ value }), [value])\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Async Atoms from Jotai v1 to v2\nDESCRIPTION: Compares how to handle async atoms in Jotai v1 versus v2. In v2, get functions no longer automatically resolve promises, requiring explicit await or then() usage.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Previous API\nconst asyncAtom = atom(async () => 'hello')\nconst derivedAtom = atom((get) => get(asyncAtom).toUppercase())\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// New API\nconst asyncAtom = atom(async () => 'hello')\nconst derivedAtom = atom(async (get) => (await get(asyncAtom)).toUppercase())\n// or\nconst derivedAtom = atom((get) => get(asyncAtom).then((x) => x.toUppercase()))\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Custom Jotai Store in React\nDESCRIPTION: Demonstrates how to create a custom store using createStore(), set and get atom values, subscribe to atom changes, and use the store with a Provider component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/store.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst myStore = createStore()\n\nconst countAtom = atom(0)\nmyStore.set(countAtom, 1)\nconst unsub = myStore.sub(countAtom, () => {\n  console.log('countAtom value is changed to', myStore.get(countAtom))\n})\n// unsub() to unsubscribe\n\nconst Root = () => (\n  <Provider store={myStore}>\n    <App />\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typing Primitive Atoms in Jotai\nDESCRIPTION: Examples of creating primitive atoms with explicit type annotations in Jotai. This approach allows defining more complex types or union types for atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/typescript.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst numAtom = atom<number>(0)\nconst numAtom = atom<number | null>(0)\nconst arrAtom = atom<string[]>([])\n```\n\n----------------------------------------\n\nTITLE: Creating a Writable Derived Atom in JavaScript\nDESCRIPTION: Shows how to create a derived atom with both read and write functions, converting text to uppercase and allowing updates to the original atom.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst textAtom = atom('hello')\nexport const textUpperCaseAtom = atom(\n  (get) => get(textAtom).toUpperCase(),\n  (_get, set, newText) => set(textAtom, newText),\n)\n```\n\n----------------------------------------\n\nTITLE: Using Atoms in React Components\nDESCRIPTION: Shows how to use atoms within React components using the useAtom hook, similar to React's useState hook pattern.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\n\nfunction Counter() {\n  const [count, setCount] = useAtom(countAtom)\n  return (\n    <h1>\n      {count}\n      <button onClick={() => setCount((c) => c + 1)}>one up</button>\n      ...\n```\n\n----------------------------------------\n\nTITLE: Implementing atomWithDebounce in TypeScript\nDESCRIPTION: Creates an atom with debounced state updates. Includes functionality for managing timeouts, tracking debounce status, and handling state updates with configurable delay. Returns an object containing current value, debouncing status, timeout clearing, and debounced value atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-debounce.mdx#2025-04-12_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { atom, SetStateAction } from 'jotai'\n\nexport default function atomWithDebounce<T>(\n  initialValue: T,\n  delayMilliseconds = 500,\n  shouldDebounceOnReset = false,\n) {\n  const prevTimeoutAtom = atom<ReturnType<typeof setTimeout> | undefined>(\n    undefined,\n  )\n\n  // DO NOT EXPORT currentValueAtom as using this atom to set state can cause\n  // inconsistent state between currentValueAtom and debouncedValueAtom\n  const _currentValueAtom = atom(initialValue)\n  const isDebouncingAtom = atom(false)\n\n  const debouncedValueAtom = atom(\n    initialValue,\n    (get, set, update: SetStateAction<T>) => {\n      clearTimeout(get(prevTimeoutAtom))\n\n      const prevValue = get(_currentValueAtom)\n      const nextValue =\n        typeof update === 'function'\n          ? (update as (prev: T) => T)(prevValue)\n          : update\n\n      const onDebounceStart = () => {\n        set(_currentValueAtom, nextValue)\n        set(isDebouncingAtom, true)\n      }\n\n      const onDebounceEnd = () => {\n        set(debouncedValueAtom, nextValue)\n        set(isDebouncingAtom, false)\n      }\n\n      onDebounceStart()\n\n      if (!shouldDebounceOnReset && nextValue === initialValue) {\n        onDebounceEnd()\n        return\n      }\n\n      const nextTimeoutId = setTimeout(() => {\n        onDebounceEnd()\n      }, delayMilliseconds)\n\n      // set previous timeout atom in case it needs to get cleared\n      set(prevTimeoutAtom, nextTimeoutId)\n    },\n  )\n\n  // exported atom setter to clear timeout if needed\n  const clearTimeoutAtom = atom(null, (get, set, _arg) => {\n    clearTimeout(get(prevTimeoutAtom))\n    set(isDebouncingAtom, false)\n  })\n\n  return {\n    currentValueAtom: atom((get) => get(_currentValueAtom)),\n    isDebouncingAtom,\n    clearTimeoutAtom,\n    debouncedValueAtom,\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling SSR with Jotai Atoms in Next.js\nDESCRIPTION: This code snippet shows how to create an atom that handles server-side rendering (SSR) in Next.js. It uses a guard to return prefetched or empty data during SSR, and fetches data on the client-side.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/nextjs.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst postData = atom((get) => {\n  const id = get(postId)\n  if (isSSR || prefetchedPostData[id]) {\n    return prefetchedPostData[id] || EMPTY_POST_DATA\n  }\n  return fetchData(id) // returns a promise\n})\n```\n\n----------------------------------------\n\nTITLE: Avoiding Heavy Computation in Component Renders with Jotai\nDESCRIPTION: This example demonstrates how to move heavy computation out of the React component lifecycle and into Jotai actions to improve performance. The code shows the incorrect approach with computation in selectors versus the correct approach using action atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/performance.mdx#2025-04-12_snippet_0\n\nLANGUAGE: js\nCODE:\n```\n// Heavy computation for each item\nconst selector = (s) => s.filter(heavyComputation)\nconst Profile = () => {\n  const [computed] = useAtom(selectAtom(friendsAtom, selector))\n}\n```\n\nLANGUAGE: js\nCODE:\n```\nconst friendsAtom = atom([])\nconst fetchFriendsAtom = atom(null, async (get, set, payload) => {\n  // Fetch all friends\n  const res = await fetch('https://...')\n  // Make heavy computation once only\n  const computed = res.filter(heavyComputation)\n  set(friendsAtom, computed)\n})\n// Usage in components\nconst Profile = () => {\n  const [friends] = useAtom(friendsAtom)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Atom State Management in JavaScript\nDESCRIPTION: A simplified implementation of Jotai's core functionality using React hooks. It demonstrates how to create atoms, manage their state using WeakMap to avoid memory leaks, and implement the useAtom hook for reading and updating atom values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/core-internals.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useState, useEffect } from 'react'\n\n// atom function returns a config object which contains initial value\nexport const atom = (initialValue) => ({ init: initialValue })\n\n// we need to keep track of the state of the atom.\n// we are using weakmap to avoid memory leaks\nconst atomStateMap = new WeakMap()\nconst getAtomState = (atom) => {\n  let atomState = atomStateMap.get(atom)\n  if (!atomState) {\n    atomState = { value: atom.init, listeners: new Set() }\n    atomStateMap.set(atom, atomState)\n  }\n  return atomState\n}\n\n// useAtom hook returns a tuple of the current value\n// and a function to update the atom's value\nexport const useAtom = (atom) => {\n  const atomState = getAtomState(atom)\n  const [value, setValue] = useState(atomState.value)\n  useEffect(() => {\n    const callback = () => setValue(atomState.value)\n\n    // same atom can be used at multiple components, so we need to\n    // keep listening for atom's state change till component is unmounted.\n    atomState.listeners.add(callback)\n    callback()\n    return () => atomState.listeners.delete(callback)\n  }, [atomState])\n\n  const setAtom = (nextValue) => {\n    atomState.value = nextValue\n\n    // let all the subscribed components know that the atom's state has changed\n    atomState.listeners.forEach((l) => l())\n  }\n\n  return [value, setAtom]\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typing Derived Atoms in Jotai\nDESCRIPTION: Examples of creating derived atoms with explicit type annotations, covering async atoms, write-only atoms with multiple parameters, and read/write atoms. This approach is useful for complex typing scenarios.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/typescript.mdx#2025-04-12_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst asyncStrAtom = atom<Promise<string>>(async () => 'foo')\n\n/**\n * For write only atoms you'll need to supply three type parameters.\n * The first type parameter describes the value returned from the atom. In the following example this is `null`.\n * The second type parameter describes the arguments (plural) you will pass to the \"write\" function. Even if you only\n * plan to have one argument, this type must be an array as show in the example.\n * The third type parameter describes the return value of the \"write\" function. Normally, there is no return value,\n * which is why we use `void` in the example below.\n */\nconst writeOnlyAtom = atom<null, [string, number], void>(\n  null,\n  (_get, set, stringValue, numberValue) => set(fooAtom, stringValue),\n)\n\n/**\n * Read/Write atoms also take the same three type parameters.\n * Just for the sake of completeness, in this example, we show that the first type parameter\n * can also describe an async atom.\n */\nconst readWriteAtom = atom<Promise<string>, [number], void>(\n  async (get) => await get(asyncStrAtom),\n  (_get, set, num) => set(strAtom, String(num)),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Primitive Atoms in JavaScript\nDESCRIPTION: Examples of creating basic primitive atoms with different data types as initial values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/atom.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom } from 'jotai'\n\nconst priceAtom = atom(10)\nconst messageAtom = atom('hello')\nconst productAtom = atom({ id: 12, name: 'good stuff' })\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Read-Only Atoms\nDESCRIPTION: Demonstrates how to create derived atoms that compute values based on other atoms using a read function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst doubledCountAtom = atom((get) => get(countAtom) * 2)\n\nfunction DoubleCounter() {\n  const [doubledCount] = useAtom(doubledCountAtom)\n  return <h2>{doubledCount}</h2>\n}\n```\n\n----------------------------------------\n\nTITLE: Switching Between Sync and Async Values\nDESCRIPTION: Shows how to create a pattern that switches from synchronous to asynchronous to trigger suspending when needed. This allows dynamic control over when components suspend.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst request = async () => fetch('https://...').then((res) => res.json())\nconst baseAtom = atom(0)\nconst Component = () => {\n  const [value, setValue] = useAtom(baseAtom)\n  const handleClick = () => {\n    setValue(request()) // Will suspend until request resolves\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useAtomDevtools for Redux DevTools Integration\nDESCRIPTION: Demonstrates how to use the useAtomDevtools hook to connect a specific atom to Redux DevTools for debugging. This enables time travel debugging, pausing, and value dispatching for the specified atom.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/debugging.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst countAtom = atom(0)\n// setting countAtom.debugLabel is recommended if we have more atoms\n\nfunction Counter() {\n  const [count, setCount] = useAtom(countAtom)\n  useAtomDevtools(countAtom)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Derived Atoms with Dependency Tracking in JavaScript\nDESCRIPTION: An enhanced implementation of Jotai that supports derived atoms with dependency tracking. This version includes functions for reading and writing atom values, as well as a notification system that updates all dependent atoms when a parent atom changes.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/core-internals.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useState, useEffect } from 'react'\n\nexport const atom = (read, write) => {\n  if (typeof read === 'function') {\n    return { read, write }\n  }\n  const config = {\n    init: read,\n\n    // get in the read function is to read the atom value.\n    // It's reactive and read dependencies are tracked.\n    read: (get) => get(config),\n\n    // get in the write function is also to read atom value, but it's not tracked.\n    // set in the write function is to write atom value and\n    // it will invoke the write function of the target atom.\n    write:\n      write ||\n      ((get, set, arg) => {\n        if (typeof arg === 'function') {\n          set(config, arg(get(config)))\n        } else {\n          set(config, arg)\n        }\n      }),\n  }\n  return config\n}\n\n// same as above but the state has one extra property: dependents\nconst atomStateMap = new WeakMap()\nconst getAtomState = (atom) => {\n  let atomState = atomStateMap.get(atom)\n  if (!atomState) {\n    atomState = {\n      value: atom.init,\n      listeners: new Set(),\n      dependents: new Set(),\n    }\n    atomStateMap.set(atom, atomState)\n  }\n  return atomState\n}\n\n// If atom is primitive, we return it's value.\n// If atom is derived, we read the parent atom's value\n// and add current atom to parent's the dependent set (recursively).\nconst readAtom = (atom) => {\n  const atomState = getAtomState(atom)\n  const get = (a) => {\n    if (a === atom) {\n      return atomState.value\n    }\n    const aState = getAtomState(a)\n    aState.dependents.add(atom) // XXX add only\n    return readAtom(a) // XXX no caching\n  }\n  const value = atom.read(get)\n  atomState.value = value\n  return value\n}\n\n// if atomState is modified, we need to notify all the dependent atoms (recursively)\n// now run callbacks for all the components that are dependent on this atom\nconst notify = (atom) => {\n  const atomState = getAtomState(atom)\n  atomState.dependents.forEach((d) => {\n    if (d !== atom) notify(d)\n  })\n  atomState.listeners.forEach((l) => l())\n}\n\n// writeAtom calls atom.write with the necessary params and triggers notify function\nconst writeAtom = (atom, value) => {\n  const atomState = getAtomState(atom)\n\n  // 'a' is some atom from atomStateMap\n  const get = (a) => {\n    const aState = getAtomState(a)\n    return aState.value\n  }\n\n  // if 'a' is the same as atom, update the value, notify that atom and return\n  // else calls writeAtom for 'a' (recursively)\n  const set = (a, v) => {\n    if (a === atom) {\n      atomState.value = v\n      notify(atom)\n      return\n    }\n    writeAtom(a, v)\n  }\n\n  atom.write(get, set, value)\n}\n\nexport const useAtom = (atom) => {\n  const [value, setValue] = useState()\n  useEffect(() => {\n    const callback = () => setValue(readAtom(atom))\n    const atomState = getAtomState(atom)\n    atomState.listeners.add(callback)\n    callback()\n    return () => atomState.listeners.delete(callback)\n  }, [atom])\n  const setAtom = (nextValue) => {\n    writeAtom(atom, nextValue)\n  }\n  return [value, setAtom]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Typed Atoms with useAtom Hook in Jotai\nDESCRIPTION: Examples of consuming atoms with the useAtom hook, which properly types the returned state and setter based on the atom's type definition.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/typescript.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst [num, setNum] = useAtom(primitiveNumAtom)\nconst [num] = useAtom(readOnlyNumAtom)\nconst [, setNum] = useAtom(writeOnlyNumAtom)\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Atoms with Type Inference in Jotai\nDESCRIPTION: Examples of creating different types of derived atoms (read-only, write-only, and read/write) with automatically inferred types. This is the recommended approach for most use cases.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/typescript.mdx#2025-04-12_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n# Read only derived atoms\nconst readOnlyAtom = atom((get) => get(numAtom))\nconst asyncReadOnlyAtom = atom(async (get) => await get(someAsyncAtom))\n\n# Write only atoms\nconst writeOnlyAtom = atom(null, (_get, set, str: string) => set(fooAtom, str))\nconst multipleArgumentsAtom = atom(\n  null,\n  (_get, set, valueOne: number, valueTwo: number) =>\n    set(fooAtom, Math.max(valueOne, valueTwo))\n);\n\n# Read/Write atoms\nconst readWriteAtom = atom(\n  (get) => get(strAtom),\n  (_get, set, num: number) => set(strAtom, String(num))\n)\nconst asyncReadWriteAtom = atom(\n  async (get) => await get(asyncStrAtom),\n  (_get, set, num: number) => set(strAtom, String(num))\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Writable Derived Atoms\nDESCRIPTION: Shows how to create derived atoms that can both read and write values using get and set functions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst decrementCountAtom = atom(\n  (get) => get(countAtom),\n  (get, set, _arg) => set(countAtom, get(countAtom) - 1)\n)\n```\n\n----------------------------------------\n\nTITLE: Example Usage of useReducerAtom with Counter Component\nDESCRIPTION: Practical example showing how to use useReducerAtom with a counter implementation. Demonstrates creating an atom, defining a reducer for increment/decrement actions, and using the hook in a React component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/use-reducer-atom.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom } from 'jotai'\n\nconst countReducer = (prev, action) => {\n  if (action.type === 'inc') return prev + 1\n  if (action.type === 'dec') return prev - 1\n  throw new Error('unknown action type')\n}\n\nconst countAtom = atom(0)\n\nconst Counter = () => {\n  const [count, dispatch] = useReducerAtom(countAtom, countReducer)\n  return (\n    <div>\n      {count}\n      <button onClick={() => dispatch({ type: 'inc' })}>+1</button>\n      <button onClick={() => dispatch({ type: 'dec' })}>-1</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Small Focused Components with Jotai Atoms\nDESCRIPTION: This example shows how to break down components into smaller, atomic parts that each observe only the atoms they need, improving render performance by limiting the scope of re-renders. The comparison shows a monolithic component versus properly separated components.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/performance.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst Profile = () => {\n  const [name] = useAtom(nameAtom)\n  const [age] = useAtom(ageAtom)\n  return (\n    <>\n      <div>{name}</div>\n      <div>{age}</div>\n    </>\n  )\n}\n```\n\nLANGUAGE: jsx\nCODE:\n```\nconst NameComponent = () => {\n  const [name] = useAtom(nameAtom)\n  return <div>{name}</div>\n}\nconst AgeComponent = () => {\n  const [age] = useAtom(ageAtom)\n  return <div>{age}</div>\n}\nconst Profile = () => {\n  return (\n    <>\n      <NameComponent />\n      <AgeComponent />\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing React Context and Jotai Usage in JSX\nDESCRIPTION: This snippet demonstrates the difference between using React Context with useState and Jotai for state management. It shows how Jotai simplifies the process of sharing state across components, reducing the need for multiple contexts and provider nesting.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/comparison.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n// 1. useState local state\nconst Component = () => {\n  const [state, setState] = useState(0)\n}\n\n// 2. Lift local state up and share it via context\nconst StateContext = createContext()\nconst Parent = ({ children }) => {\n  return (\n    <StateContext.Provider value={useState(0)}>\n      {children}\n    </StateContext.Provider>\n  )\n}\nconst Component = () => {\n  const [state, setState] = useContext(StateContext)\n}\n\n// 3. Have multiple states and contexts\nconst State1Context = createContext()\nconst State2Context = createContext()\nconst Parent = ({ children }) => (\n  <State1Context.Provider value={useState(0)}>\n    <State2Context.Provider value={useState(0)}>\n      {children}\n    </State2Context.Provider>\n  </State1Context.Provider>\n)\nconst Component1 = () => {\n  const [state, setState] = useContext(State1Context)\n}\nconst Component2 = () => {\n  const [state, setState] = useContext(State2Context)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Dispatch Action Atom in JavaScript\nDESCRIPTION: Demonstrates how to create a dispatch action atom that calls other action atoms based on the provided action type.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nexport const dispatchAtom = atom(null, (_get, set, action) => {\n  if (action === 'INC') {\n    set(incAtom)\n  } else if (action === 'DEC') {\n    set(decAtom)\n  } else {\n    throw new Error('unknown action')\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using loadable Utility with Async Atoms in Jotai\nDESCRIPTION: This snippet demonstrates how to use the loadable utility to handle async atoms without using Suspense. It wraps an async atom and provides a value with loading, hasData, or hasError states.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/async.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { loadable } from \"jotai/utils\"\n\nconst asyncAtom = atom(async (get) => ...)\nconst loadableAtom = loadable(asyncAtom)\n// Does not need to be wrapped by a <Suspense> element\nconst Component = () => {\n  const [value] = useAtom(loadableAtom)\n  if (value.state === 'hasError') return <Text>{value.error}</Text>\n  if (value.state === 'loading') {\n    return <Text>Loading...</Text>\n  }\n  console.log(value.data) // Results of the Promise\n  return <Text>Value: {value.data}</Text>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Derived Atoms in JavaScript\nDESCRIPTION: Demonstration of creating read-only, write-only, and read-write derived atoms with custom logic.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/atom.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst readOnlyAtom = atom((get) => get(priceAtom) * 2)\nconst writeOnlyAtom = atom(\n  null,\n  (get, set, update) => {\n    set(priceAtom, get(priceAtom) - update.discount)\n    set(priceAtom, (price) => price - update.discount)\n  },\n)\nconst readWriteAtom = atom(\n  (get) => get(priceAtom) * 2,\n  (get, set, newPrice) => {\n    set(priceAtom, newPrice / 2)\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Refreshable Atoms with Default Values in Jotai\nDESCRIPTION: Implementation of atomWithRefreshAndDefault that creates atoms which can be reset to their original derived state. The implementation uses a refresh counter atom to trigger updates and maintains relationship between dependent atoms even after manual updates.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-refresh-and-default.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst refreshCountAtom = atom(0)\n\nconst baseDataAtom = atom(1) // original data, e.g. base count1Atom\nconst dataAtom = atom(\n  (get) => {\n    get(refreshCountAtom) // it's introduced at atomWithRefresh\n    return get(baseDataAtom)\n  },\n  (get, set, update) => {\n    set(baseDataAtom, update)\n  },\n)\n\nconst atomWithRefreshAndDefault = (refreshAtom, getDefault) => {\n  const overwrittenAtom = atom(null)\n  return atom(\n    (get) => {\n      const lastState = get(overwrittenAtom)\n      if (lastState && lastState.refresh === get(refreshAtom)) {\n        return lastState.value\n      }\n      return getDefault(get)\n    },\n    (get, set, update) => {\n      set(overwrittenAtom, { refresh: get(refreshAtom), value: update })\n    },\n  )\n}\n\n// This is an alternative of `atomWithDefault((get) => get(count1Atom) * 2)`\nconst refreshableAtom = atomWithRefreshAndDefault(\n  refreshCountAtom,\n  (get) => get(dataAtom) * 2,\n)\n\n// You can reset by updating just one atom\nconst resetRootAtom = atom(null, (get, set) => {\n  set(refreshCountAtom, get(refreshCountAtom) + 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Testing a Counter Component with React Testing Library\nDESCRIPTION: Shows how to test the Counter component using React Testing Library. The test verifies that clicking the increment button increases the displayed count.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/testing.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport React from 'react'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { Counter } from './Counter'\n\ntest('should increment counter', () => {\n  // Arrange\n  render(<Counter />)\n\n  const counter = screen.getByText('0')\n  const incrementButton = screen.getByText('one up')\n  // Act\n  await userEvent.click(incrementButton)\n  // Assert\n  expect(counter.textContent).toEqual('1')\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing useReducerAtom Hook in TypeScript\nDESCRIPTION: Core implementation of useReducerAtom hook that combines Jotai's atom state management with reducer pattern. The hook takes a primitive atom and a reducer function as arguments, returning a state-dispatch tuple similar to React's useReducer.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/use-reducer-atom.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useCallback } from 'react'\nimport { useAtom } from 'jotai'\nimport type { PrimitiveAtom } from 'jotai'\n\nexport function useReducerAtom<Value, Action>(\n  anAtom: PrimitiveAtom<Value>,\n  reducer: (v: Value, a: Action) => Value,\n) {\n  const [state, setState] = useAtom(anAtom)\n  const dispatch = useCallback(\n    (action: Action) => setState((prev) => reducer(prev, action)),\n    [setState, reducer],\n  )\n  return [state, dispatch] as const\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Array of Atom Configs\nDESCRIPTION: Demonstrates storing and managing an array of atom configurations, including adding new atoms dynamically and rendering individual counters.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/atoms-in-atom.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst countsAtom = atom([atom(1), atom(2), atom(3)])\n\nconst Counter = ({ countAtom }) => {\n  const [count, setCount] = useAtom(countAtom)\n  return (\n    <div>\n      {count} <button onClick={() => setCount((c) => c + 1)}>+1</button>\n    </div>\n  )\n}\n\nconst Parent = () => {\n  const [counts, setCounts] = useAtom(countsAtom)\n  const addNewCount = () => {\n    const newAtom = atom(0)\n    setCounts((prev) => [...prev, newAtom])\n  }\n  return (\n    <div>\n      {counts.map((countAtom) => (\n        <Counter countAtom={countAtom} key={countAtom} />))}\n      <button onClick={addNewCount}>Add</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Actions\nDESCRIPTION: Shows how to implement asynchronous actions in atoms using async write functions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nconst fetchCountAtom = atom(\n  (get) => get(countAtom),\n  async (_get, set, url) => {\n    const response = await fetch(url)\n    set(countAtom, (await response.json()).count)\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing an Async Write Atom\nDESCRIPTION: Demonstrates creating an atom with an async write function. This pattern is useful for performing asynchronous operations when updating state.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst countAtom = atom(1)\nconst asyncIncrementAtom = atom(null, async (get, set) => {\n  // await something\n  set(countAtom, get(countAtom) + 1)\n})\n\nconst Component = () => {\n  const [, increment] = useAtom(asyncIncrementAtom)\n  const handleClick = () => {\n    increment()\n  }\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using unwrap Utility with Async Atoms in Jotai\nDESCRIPTION: This example shows how to use the unwrap utility to convert an async atom to a sync atom. It allows for configuring fallback values and is useful for deriving atoms, especially in v2 API where 'get' in the read function doesn't resolve promises.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/async.mdx#2025-04-12_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atom } from 'jotai'\nimport { unwrap } from 'jotai/utils'\n\nconst countAtom = atom(0)\nconst delayedCountAtom = atom(async (get) => {\n  await new Promise((r) => setTimeout(r, 500))\n  return get(countAtom)\n})\n\nconst unwrapped1Atom = unwrap(delayedCountAtom)\n// The value is `undefined` while pending\n\nconst unwrapped2Atom = unwrap(delayedCountAtom, (prev) => prev ?? 0)\n// The value is `0` initially, and subsequent updates keep the previous value.\n```\n\n----------------------------------------\n\nTITLE: Basic Dark Mode Implementation with atomWithStorage\nDESCRIPTION: Demonstrates how to create a persistent dark mode toggle using atomWithStorage with localStorage\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/storage.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithStorage } from 'jotai/utils'\n\nconst darkModeAtom = atomWithStorage('darkMode', false)\n\nconst Page = () => {\n  const [darkMode, setDarkMode] = useAtom(darkModeAtom)\n\n  return (\n    <>\n      <h1>Welcome to {darkMode ? 'dark' : 'light'} mode!</h1>\n      <button onClick={() => setDarkMode(!darkMode)}>toggle theme</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Suspense-Compatible Queries with atomWithSuspenseQuery\nDESCRIPTION: Demonstrates how to implement a query that works with React Suspense for data fetching. This allows the component to suspend while the query is loading.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { atomWithSuspenseQuery } from 'jotai-tanstack-query'\n\nconst idAtom = atom(1)\nconst userAtom = atomWithSuspenseQuery((get) => ({\n  queryKey: ['users', get(idAtom)],\n  queryFn: async ({ queryKey: [, id] }) => {\n    const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`)\n    return res.json()\n  },\n}))\n\nconst UserData = () => {\n  const [{ data }] = useAtom(userAtom)\n\n  return <div>{JSON.stringify(data)}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Atom Config in Another Atom\nDESCRIPTION: Illustrates storing an atom configuration within another atom, allowing dynamic switching between different name atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/atoms-in-atom.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst firstNameAtom = atom('Tanjiro')\nconst lastNameAtom = atom('Kamado')\n\nconst showingNameAtom = atom(firstNameAtom)\n\nconst Component = () => {\n  const [nameAtom, setNameAtom] = useAtom(showingNameAtom)\n  const [name] = useAtom(nameAtom)\n  return (\n    <div>\n      Name: {name}\n      <button onClick={() => setNameAtom(firstNameAtom)}>\n        Show First Name\n      </button>\n      <button onClick={() => setNameAtom(lastNameAtom)}>Show Last Name</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic atomFamily Usage Pattern in JavaScript\nDESCRIPTION: Shows the function signature of atomFamily which takes an initialization function and an optional equality function to create parameterized atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\natomFamily(initializeAtom, areEqual): (param) => Atom\n```\n\n----------------------------------------\n\nTITLE: Extending Atoms with Reducer Functionality in JavaScript\nDESCRIPTION: Demonstrates how to add reducer functionality to an atom created with atomWithStorage, combining multiple atom utilities.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst reducer = ...\nconst baseAtom = atomWithStorage('mykey', '')\nexport const derivedAtom = atom(\n  (get) => get(baseAtom),\n  (get, set, action) => {\n    set(baseAtom, reducer(get(baseAtom), action))\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Using Provider Component with Jotai in JSX\nDESCRIPTION: Example showing how to use the Provider component to create a sub-tree with its own atom state. This demonstrates the basic Provider usage pattern.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/provider.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst SubTree = () => (\n  <Provider>\n    <Child />\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Installing TanStack Query Devtools\nDESCRIPTION: Command to install the TanStack Query Devtools package.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @tanstack/react-query-devtools\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter with useAtomCallback Example\nDESCRIPTION: Complete example showing how to use useAtomCallback in a React application. Demonstrates creating an atom, a Counter component for updating the atom value, and a Monitor component that reads the atom value imperatively using useAtomCallback.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/callback.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useEffect, useState, useCallback } from 'react'\nimport { Provider, atom, useAtom } from 'jotai'\nimport { useAtomCallback } from 'jotai/utils'\n\nconst countAtom = atom(0)\n\nconst Counter = () => {\n  const [count, setCount] = useAtom(countAtom)\n  return (\n    <>\n      {count} <button onClick={() => setCount((c) => c + 1)}>+1</button>\n    </>\n  )\n}\n\nconst Monitor = () => {\n  const [count, setCount] = useState(0)\n  const readCount = useAtomCallback(\n    useCallback((get) => {\n      const currCount = get(countAtom)\n      setCount(currCount)\n      return currCount\n    }, []),\n  )\n  useEffect(() => {\n    const timer = setInterval(async () => {\n      console.log(readCount())\n    }, 1000)\n    return () => {\n      clearInterval(timer)\n    }\n  }, [readCount])\n  return <div>current count: {count}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Async Read Atom in JavaScript\nDESCRIPTION: Demonstrates how to create an async atom that reads from another atom and performs an asynchronous calculation. The async atom will suspend the component when accessed until the promise resolves.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst countAtom = atom(1)\nconst asyncAtom = atom(async (get) => get(countAtom) * 2)\n```\n\n----------------------------------------\n\nTITLE: Defining SplitAtom Type Signature in TypeScript\nDESCRIPTION: Type definition for the splitAtom utility that shows its structure and generic parameters. It takes a PrimitiveAtom of an array and an optional key extractor, returning an atom containing an array of primitive atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/split.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype SplitAtom = <Item, Key>(\n  arrayAtom: PrimitiveAtom<Array<Item>>,\n  keyExtractor?: (item: Item) => Key\n): Atom<Array<PrimitiveAtom<Item>>>\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Query with atomWithQuery\nDESCRIPTION: Demonstrates how to create and use a query atom that fetches user data based on a dynamic ID. Shows handling of loading and error states within the component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { atomWithQuery } from 'jotai-tanstack-query'\n\nconst idAtom = atom(1)\nconst userAtom = atomWithQuery((get) => ({\n  queryKey: ['users', get(idAtom)],\n  queryFn: async ({ queryKey: [, id] }) => {\n    const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`)\n    return res.json()\n  },\n}))\n\nconst UserData = () => {\n  const [{ data, isPending, isError }] = useAtom(userAtom)\n\n  if (isPending) return <div>Loading...</div>\n  if (isError) return <div>Error</div>\n\n  return <div>{JSON.stringify(data)}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Suspense-Compatible Infinite Queries\nDESCRIPTION: Shows how to create an infinite query atom that works with React Suspense. This enables pagination with Suspense-based loading patterns.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { atomWithSuspenseInfiniteQuery } from 'jotai-tanstack-query'\n\nconst postsAtom = atomWithSuspenseInfiniteQuery(() => ({\n  queryKey: ['posts'],\n  queryFn: async ({ pageParam }) => {\n    const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${pageParam}`)\n    return res.json()\n  },\n  getNextPageParam: (lastPage, allPages, lastPageParam) => lastPageParam + 1,\n  initialPageParam: 1,\n}))\n\nconst Posts = () => {\n  const [{ data, fetchNextPage, isPending, isError, isFetching }] =\n    useAtom(postsAtom)\n\n  return (\n    <>\n      {data.pages.map((page, index) => (\n        <div key={index}>\n          {page.map((post: any) => (\n            <div key={post.id}>{post.title}</div>\n          ))}\n        </div>\n      ))}\n      <button onClick={() => fetchNextPage()}>Next</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Async Derived Atoms\nDESCRIPTION: Demonstrates how to create atoms that handle asynchronous operations using async functions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst urlAtom = atom('https://json.host.com')\nconst fetchUrlAtom = atom(async (get) => {\n  const response = await fetch(get(urlAtom))\n  return await response.json()\n})\n```\n\n----------------------------------------\n\nTITLE: Using useAtomsDebugValue with React Dev Tools\nDESCRIPTION: Shows how to implement the useAtomsDebugValue hook to debug all atoms in a component tree. The DebugAtoms component is placed under the Provider to capture all atom values and their dependencies.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/debugging.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst DebugAtoms = () => {\n  useAtomsDebugValue()\n  return null\n}\n\nconst Root = () => (\n  <Provider>\n    <DebugAtoms />\n    <App />\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Using Async Atoms with React Suspense\nDESCRIPTION: Shows how to use async atoms in React components with Suspense. The component will suspend until the async atom resolves, and the Suspense component will display a fallback UI during this time.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst ComponentUsingAsyncAtoms = () => {\n  const [num] = useAtom(asyncAtom)\n  // here `num` is always `number` even though asyncAtom returns a Promise\n}\nconst App = () => {\n  return (\n    <Suspense fallback={/* What to show while suspended */}>\n      <ComponentUsingAsyncAtoms />\n    </Suspense>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Enhanced localStorage Helper with JSON Support\nDESCRIPTION: A reusable helper function that creates atoms with localStorage persistence and JSON parsing/stringifying support.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/persistence.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst atomWithLocalStorage = (key, initialValue) => {\n  const getInitialValue = () => {\n    const item = localStorage.getItem(key)\n    if (item !== null) {\n      return JSON.parse(item)\n    }\n    return initialValue\n  }\n  const baseAtom = atom(getInitialValue())\n  const derivedAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue =\n        typeof update === 'function' ? update(get(baseAtom)) : update\n      set(baseAtom, nextValue)\n      localStorage.setItem(key, JSON.stringify(nextValue))\n    },\n  )\n  return derivedAtom\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Infinite Scrolling with atomWithInfiniteQuery\nDESCRIPTION: Shows how to create a paginated data query for implementing infinite scrolling with atomWithInfiniteQuery. Demonstrates handling of pagination with getNextPageParam and fetching next pages on user action.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { atomWithInfiniteQuery } from 'jotai-tanstack-query'\n\nconst postsAtom = atomWithInfiniteQuery(() => ({\n  queryKey: ['posts'],\n  queryFn: async ({ pageParam }) => {\n    const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${pageParam}`)\n    return res.json()\n  },\n  getNextPageParam: (lastPage, allPages, lastPageParam) => lastPageParam + 1,\n  initialPageParam: 1,\n}))\n\nconst Posts = () => {\n  const [{ data, fetchNextPage, isPending, isError, isFetching }] =\n    useAtom(postsAtom)\n\n  if (isPending) return <div>Loading...</div>\n  if (isError) return <div>Error</div>\n\n  return (\n    <>\n      {data.pages.map((page, index) => (\n        <div key={index}>\n          {page.map((post: any) => (\n            <div key={post.id}>{post.title}</div>\n          ))}\n        </div>\n      ))}\n      <button onClick={() => fetchNextPage()}>Next</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Atom Snapshot Navigation in Jotai with React\nDESCRIPTION: Demonstrates how to use useAtomsSnapshot and useGotoAtomsSnapshot hooks from jotai-devtools to create and navigate between atom state snapshots. The example shows updating multiple atoms (petAtom and colorAtom) simultaneously using a snapshot mechanism.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Provider } from 'jotai'\nimport { useAtomsSnapshot, useGotoAtomsSnapshot } from 'jotai-devtools/utils'\n\nconst petAtom = atom('cat')\nconst colorAtom = atom('blue')\n\nconst UpdateSnapshot = () => {\n  const snapshot = useAtomsSnapshot()\n  const goToSnapshot = useGotoAtomsSnapshot()\n  return (\n    <button\n      onClick={() => {\n        const newSnapshot = new Map(snapshot)\n        newSnapshot.set(petAtom, 'dog')\n        newSnapshot.set(colorAtom, 'green')\n        goToSnapshot(newSnapshot)\n      }}\n    >\n      Go to snapshot\n    </button>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using selectAtom with Person Object Example\nDESCRIPTION: Demonstrates practical usage of selectAtom with a complex nested object structure, showing both basic selection and deep equality comparison examples.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/select.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst defaultPerson = {\n  name: {\n    first: 'Jane',\n    last: 'Doe',\n  },\n  birth: {\n    year: 2000,\n    month: 'Jan',\n    day: 1,\n    time: {\n      hour: 1,\n      minute: 1,\n    },\n  },\n}\n\n// Original atom.\nconst personAtom = atom(defaultPerson)\n\n// Tracks person.name. Updated when person.name object changes, even\n// if neither name.first nor name.last actually change.\nconst nameAtom = selectAtom(personAtom, (person) => person.name)\n\n// Tracks person.birth. Updated when year, month, day, hour, or minute changes.\n// Use of deepEquals means that this atom doesn't update if birth field is\n// replaced with a new object containing the same data. E.g., if person is re-read\n// from a database.\nconst birthAtom = selectAtom(personAtom, (person) => person.birth, deepEquals)\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Atoms with Getter Functions in Jotai\nDESCRIPTION: This snippet demonstrates how to create derived atoms in Jotai using a getter function. It shows how to access and combine multiple atom values to create a new derived atom that updates when dependencies change.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/functional-programming-and-jotai.mdx#2025-04-12_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst nameAtom = atom('Visitor')\nconst countAtom = atom(1)\nconst greetingAtom = atom((get) => {\n  const name = get(nameAtom)\n  const count = get(countAtom)\n  return (\n    <div>\n      Hello, {name}! You have visited this page {count} times.\n    </div>\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Data Mutations with atomWithMutation\nDESCRIPTION: Demonstrates how to create a mutation atom that can POST data to an API endpoint. Shows how to trigger the mutation and access its status.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst postAtom = atomWithMutation(() => ({\n  mutationKey: ['posts'],\n  mutationFn: async ({ title }: { title: string }) => {\n    const res = await fetch(`https://jsonplaceholder.typicode.com/posts`, {\n      method: 'POST',\n      body: JSON.stringify({\n        title,\n        body: 'body',\n        userId: 1,\n      }),\n      headers: {\n        'Content-type': 'application/json; charset=UTF-8',\n      },\n    })\n    const data = await res.json()\n    return data\n  },\n}))\n\nconst Posts = () => {\n  const [{ mutate, status }] = useAtom(postAtom)\n  return (\n    <div>\n      <button onClick={() => mutate({ title: 'foo' })}>Click me</button>\n      <pre>{JSON.stringify(status, null, 2)}</pre>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Permanently Suspended Atom\nDESCRIPTION: Shows how to create an atom that will remain suspended indefinitely until explicitly set to another value. This can be useful for controlling loading states.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst baseAtom = atom(new Promise(() => {})) // Will be suspend until set otherwise\n```\n\n----------------------------------------\n\nTITLE: Todo List Implementation Using SplitAtom\nDESCRIPTION: Complete example showing how to implement a todo list using splitAtom. Demonstrates creating individual todo items, managing their state, and handling remove operations using the dispatch function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/split.mdx#2025-04-12_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { Provider, atom, useAtom, PrimitiveAtom } from 'jotai'\nimport { splitAtom } from 'jotai/utils'\nimport './styles.css'\n\nconst initialState = [\n  {\n    task: 'help the town',\n    done: false,\n  },\n  {\n    task: 'feed the dragon',\n    done: false,\n  },\n]\n\nconst todosAtom = atom(initialState)\nconst todoAtomsAtom = splitAtom(todosAtom)\n\ntype TodoType = (typeof initialState)[number]\n\nconst TodoItem = ({\n  todoAtom,\n  remove,\n}: {\n  todoAtom: PrimitiveAtom<TodoType>\n  remove: () => void\n}) => {\n  const [todo, setTodo] = useAtom(todoAtom)\n  return (\n    <div>\n      <input\n        value={todo.task}\n        onChange={(e) => {\n          setTodo((oldValue) => ({ ...oldValue, task: e.target.value }))\n        }}\n      />\n      <input\n        type=\"checkbox\"\n        checked={todo.done}\n        onChange={() => {\n          setTodo((oldValue) => ({ ...oldValue, done: !oldValue.done }))\n        }}\n      />\n      <button onClick={remove}>remove</button>\n    </div>\n  )\n}\n\nconst TodoList = () => {\n  const [todoAtoms, dispatch] = useAtom(todoAtomsAtom)\n  return (\n    <ul>\n      {todoAtoms.map((todoAtom) => (\n        <TodoItem\n          todoAtom={todoAtom}\n          remove={() => dispatch({ type: 'remove', atom: todoAtom })}\n        />\n      ))}\n    </ul>\n  )\n}\n\nconst App = () => (\n  <Provider>\n    <TodoList />\n  </Provider>\n)\n\nexport default App\n```\n\n----------------------------------------\n\nTITLE: AsyncStorage Integration with Jotai\nDESCRIPTION: Helper function for creating atoms with AsyncStorage persistence, using onMount for initial loading and JSON parsing.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/persistence.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst atomWithAsyncStorage = (key, initialValue) => {\n  const baseAtom = atom(initialValue)\n  baseAtom.onMount = (setValue) => {\n    ;(async () => {\n      const item = await AsyncStorage.getItem(key)\n      setValue(JSON.parse(item))\n    })()\n  }\n  const derivedAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue =\n        typeof update === 'function' ? update(get(baseAtom)) : update\n      set(baseAtom, nextValue)\n      AsyncStorage.setItem(key, JSON.stringify(nextValue))\n    },\n  )\n  return derivedAtom\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Derived Atoms in JavaScript\nDESCRIPTION: Demonstrates how to create a simple derived atom that computes the length of a text atom's value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nexport const textAtom = atom('hello')\nexport const textLenAtom = atom((get) => get(textAtom).length)\n```\n\n----------------------------------------\n\nTITLE: Syncing Jotai with Next.js Router using atomWithHash\nDESCRIPTION: This snippet demonstrates how to create an atom that syncs with the Next.js router using atomWithHash. It subscribes to route change and hash change events to keep the atom value in sync with the URL.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/nextjs.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst pageAtom = atomWithHash('page', 1, {\n  replaceState: true,\n  subscribe: (callback) => {\n    Router.events.on('routeChangeComplete', callback)\n    window.addEventListener('hashchange', callback)\n    return () => {\n      Router.events.off('routeChangeComplete', callback)\n      window.removeEventListener('hashchange', callback)\n    }\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating Jotai with TanStack Query\nDESCRIPTION: Example showing how to set up Jotai with TanStack Query, including provider initialization, query atom creation, and mutation hook implementation.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Provider } from 'jotai/react'\nimport { useHydrateAtoms } from 'jotai/react/utils'\nimport {\n  useMutation,\n  useQueryClient,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport { atomWithQuery, queryClientAtom } from 'jotai-tanstack-query'\n\nconst queryClient = new QueryClient()\n\nconst HydrateAtoms = ({ children }) => {\n  useHydrateAtoms([[queryClientAtom, queryClient]])\n  return children\n}\n\nexport const App = () => {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Provider>\n        <HydrateAtoms>\n          <App />\n        </HydrateAtoms>\n      </Provider>\n    </QueryClientProvider>\n  )\n}\n\nexport const todosAtom = atomWithQuery((get) => {\n  return {\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n  }\n})\n\nexport const useTodoMutation = () => {\n  const queryClient = useQueryClient()\n\n  return useMutation(\n    async (body: todo) => {\n      await fetch('/todo', { Method: 'POST', Body: body })\n    },\n    {\n      onSuccess: () => {\n        void queryClient.invalidateQueries(['todos'])\n      },\n      onError,\n    }\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Counter Reducer with Jotai atomWithReducer\nDESCRIPTION: Demonstrates how to create a basic counter reducer atom using atomWithReducer from Jotai utils. The reducer handles increment and decrement actions with error handling for unknown action types.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/reducer.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomWithReducer } from 'jotai/utils'\n\nconst countReducer = (prev, action) => {\n  if (action.type === 'inc') return prev + 1\n  if (action.type === 'dec') return prev - 1\n  throw new Error('unknown action type')\n}\n\nconst countReducerAtom = atomWithReducer(0, countReducer)\n```\n\n----------------------------------------\n\nTITLE: Implementing useImmerAtom Hook\nDESCRIPTION: Example of using useImmerAtom hook to add Immer functionality to atoms at the component level\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/immer.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom } from 'jotai'\nimport { useImmerAtom } from 'jotai-immer'\n\nconst primitiveAtom = atom({ value: 0 })\n\nconst Counter = () => {\n  const [count] = useImmerAtom(primitiveAtom)\n  return <div>count: {count.value}</div>\n}\n\nconst Controls = () => {\n  const [, setCount] = useImmerAtom(primitiveAtom)\n  // setCount === update : (draft: Draft<Value>) => void\n  const inc = () =>\n    setCount((draft) => {\n      ++draft.value\n    })\n  return <button onClick={inc}>+1</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cache with Jotai for API Requests\nDESCRIPTION: Complete example demonstrating how to use atomWithCache for API requests compared to normal atoms. The example shows how cached atoms maintain their values across renders, reducing unnecessary network requests.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/cache.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { atomWithCache } from 'jotai-cache'\n\nconst idAtom = atom(1)\n\nconst normalAtom = atom(async (get) => {\n  const id = get(idAtom)\n  const response = await fetch(`https://reqres.in/api/users/${id}?delay=1`)\n  return response.json()\n})\n\nconst cachedAtom = atomWithCache(async (get) => {\n  const id = get(idAtom)\n  const response = await fetch(`https://reqres.in/api/users/${id}?delay=1`)\n  return response.json()\n})\n\nconst NormalUser = () => {\n  const [{ data }] = useAtom(normalAtom)\n  return (\n    <div>\n      <h1>User (normal atom)</h1>\n      <ul>\n        <li>ID: {data.id}</li>\n        <li>First name: {data.first_name}</li>\n        <li>Last name: {data.last_name}</li>\n      </ul>\n    </div>\n  )\n}\n\nconst CachedUser = () => {\n  const [{ data }] = useAtom(cachedAtom)\n  return (\n    <div>\n      <h1>User (cached atom)</h1>\n      <ul>\n        <li>ID: {data.id}</li>\n        <li>First name: {data.first_name}</li>\n        <li>Last name: {data.last_name}</li>\n      </ul>\n    </div>\n  )\n}\n\nconst App = () => {\n  const [id, setId] = useAtom(idAtom)\n  return (\n    <div>\n      ID: {id}{' '}\n      <button type=\"button\" onClick={() => setId((c) => c - 1)}>\n        Prev\n      </button>{' '}\n      <button type=\"button\" onClick={() => setId((c) => c + 1)}>\n        Next\n      </button>\n      <hr />\n      <Suspense fallback=\"Loading...\">\n        <CachedUser />\n      </Suspense>\n      <hr />\n      <Suspense fallback=\"Loading...\">\n        <NormalUser />\n      </Suspense>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using atomEffect for Reactive Side Effects\nDESCRIPTION: Example showing how to create and use an atomEffect for logging changes to an atom, including cleanup on unmount, and activating it through a React component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomEffect } from 'jotai-effect'\n\nconst logEffect = atomEffect((get, set) => {\n  set(logAtom, get(someAtom)) // Runs on mount or when someAtom changes\n  return () => {\n    set(logAtom, 'unmounting') // Cleanup on unmount\n  }\n})\n\n// activates the atomEffect while Component is mounted\nfunction Component() {\n  useAtom(logEffect)\n}\n```\n\n----------------------------------------\n\nTITLE: Async Atom with Write Function\nDESCRIPTION: Shows how to use an async atom within a write function of another atom. The write function must be async when it needs to await the value of an async atom.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst asyncAtom = atom(async (get) => ...)\nconst writeAtom = atom(null, async (get, set, payload) => {\n  await get(asyncAtom)\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Using the useStore Hook in Jotai\nDESCRIPTION: Example showing how to use the useStore hook to access the current Jotai store within a component. This hook provides direct access to the store for advanced use cases.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/provider.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst Component = () => {\n  const store = useStore()\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Resettable Atoms\nDESCRIPTION: Example showing how to create resettable atoms for primitive and complex values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomWithReset } from 'jotai/utils'\n\nconst dollarsAtom = atomWithReset(0)\nconst todoListAtom = atomWithReset([\n  { description: 'Add a todo', checked: false },\n])\n```\n\n----------------------------------------\n\nTITLE: Implementing useAtomEffect Hook in TypeScript\nDESCRIPTION: This snippet shows the implementation of the useAtomEffect hook using Jotai's atomEffect and React's useMemo. It utilizes a stable version of useMemo from the use-memo-one library for performance optimization.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/use-atom-effect.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useMemoOne as useStableMemo } from 'use-memo-one'\nimport { useAtomValue } from 'jotai/react'\nimport { atomEffect } from 'jotai-effect'\n\ntype EffectFn = Parameters<typeof atomEffect>[0]\n\nexport function useAtomEffect(effectFn: EffectFn) {\n  useAtomValue(useStableMemo(() => atomEffect(effectFn), [effectFn]))\n}\n```\n\n----------------------------------------\n\nTITLE: Basic atomFamily Example in JavaScript\nDESCRIPTION: Simple example of creating and using an atomFamily with a name parameter that initializes atoms with the name value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom } from 'jotai'\nimport { atomFamily } from 'jotai/utils'\n\nconst todoFamily = atomFamily((name) => atom(name))\n\ntodoFamily('foo')\n// this will create a new atom('foo'), or return the one if already created\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Resettable Atom with Currency Conversion\nDESCRIPTION: Shows how to create a derived resettable atom using the RESET symbol. Implements a dollars-to-cents converter with reset functionality where the derived atom (cents) can reset the base atom (dollars).\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/resettable.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom, useSetAtom } from 'jotai'\nimport { atomWithReset, useResetAtom, RESET } from 'jotai/utils'\n\nconst dollarsAtom = atomWithReset(0)\nconst centsAtom = atom(\n  (get) => get(dollarsAtom) * 100,\n  (get, set, newValue: number | typeof RESET) =>\n    set(dollarsAtom, newValue === RESET ? newValue : newValue / 100)\n)\n\nconst ResetExample = () => {\n  const [dollars] = useAtom(dollarsAtom)\n  const setCents = useSetAtom(centsAtom)\n  const resetCents = useResetAtom(centsAtom)\n\n  return (\n    <>\n      <h3>Current balance ${dollars}</h3>\n      <button onClick={() => setCents(100)}>Set $1</button>\n      <button onClick={() => setCents(200)}>Set $2</button>\n      <button onClick={resetCents}>Reset</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of useHydrateAtoms in JavaScript\nDESCRIPTION: Demonstrates how to use the useHydrateAtoms hook to hydrate an atom with a server-side value in a React component. This example shows the basic implementation for a counter component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/ssr.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { useHydrateAtoms } from 'jotai/utils'\n\nconst countAtom = atom(0)\nconst CounterPage = ({ countFromServer }) => {\n  useHydrateAtoms([[countAtom, countFromServer]])\n  const [count] = useAtom(countAtom)\n  // count would be the value of `countFromServer`, not 0.\n}\n```\n\n----------------------------------------\n\nTITLE: Using atomWithBroadcast in a React component with Jotai\nDESCRIPTION: This example demonstrates how to use the atomWithBroadcast function to create a count state that can be shared across browser tabs. The ListOfThings component uses the useAtom hook to access and update the broadcast atom value with a button that increments the count.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-broadcast.mdx#2025-04-12_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst broadAtom = atomWithBroadcast('count', 0)\n\nconst ListOfThings = () => {\n  const [count, setCount] = useAtom(broadAtom)\n\n  return (\n    <div>\n      {count}\n      <button onClick={() => setCount(count + 1)}>+1</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Derived Async Atom\nDESCRIPTION: Demonstrates how to create an atom that depends on another async atom. When an atom uses an async atom, it must also be async and use await to access the value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst anotherAtom = atom(async (get) => (await get(asyncAtom)) / 2)\n```\n\n----------------------------------------\n\nTITLE: Creating Atoms with Default Values\nDESCRIPTION: Example showing how to create atoms with computed default values using atomWithDefault.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomWithDefault } from 'jotai/utils'\n\nconst count1Atom = atom(1)\nconst count2Atom = atomWithDefault((get) => get(count1Atom) * 2)\n```\n\n----------------------------------------\n\nTITLE: Implementing atomWithToggle Function in TypeScript\nDESCRIPTION: This snippet defines the atomWithToggle function, which creates a new atom with a boolean state and a setter function to toggle it. It uses Jotai's atom function internally and provides type safety.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-toggle.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WritableAtom, atom } from 'jotai'\n\nexport function atomWithToggle(\n  initialValue?: boolean,\n): WritableAtom<boolean, [boolean?], void> {\n  const anAtom = atom(initialValue, (get, set, nextValue?: boolean) => {\n    const update = nextValue ?? !get(anAtom)\n    set(anAtom, update)\n  })\n\n  return anAtom as WritableAtom<boolean, [boolean?], void>\n}\n```\n\n----------------------------------------\n\nTITLE: Using bunshi for Scoped State Management in React\nDESCRIPTION: A counter example using bunshi (formerly jotai-molecules) to create scoped state with molecules and custom scopes. This allows atoms to be created with values from component props via scope providers.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/scope.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { molecule, useMolecule, createScope, ScopeProvider } from 'bunshi/react'\n\nconst InitialCountScope = createScope({ initialCount: 0 })\nconst countMolecule = molecule((getMol, getScope) => {\n  const { initialCount } = getScope(InitialCountScope)\n  return atom(initialCount)\n})\n\nconst Counter = () => {\n  const countAtom = useMolecule(countMolecule)\n  const [count, setCount] = useAtom(countAtom)\n  return (\n    <div>\n      {count} <button onClick={() => setCount((c) => c + 1)}>+1</button>\n    </div>\n  )\n}\n\nconst App = () => (\n  <div>\n    <h1>With initial value 1</h1>\n    <ScopeProvider scope={InitialCountScope} value={{ initialCount: 1 }}>\n      <Counter />\n      <Counter />\n    </ScopeProvider>\n    <h1>With initial value 2</h1>\n    <ScopeProvider scope={InitialCountScope} value={{ initialCount: 2 }}>\n      <Counter />\n      <Counter />\n    </ScopeProvider>\n    <h1>Default</h1>\n    <Counter />\n    <Counter />\n  </div>\n)\n```\n\n----------------------------------------\n\nTITLE: Atom Type Signatures in TypeScript\nDESCRIPTION: TypeScript type definitions for different atom creation patterns including primitive and derived atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/atom.mdx#2025-04-12_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction atom<Value>(initialValue: Value): PrimitiveAtom<Value>\n\nfunction atom<Value>(read: (get: Getter) => Value): Atom<Value>\n\nfunction atom<Value, Args extends unknown[], Result>(\n  read: (get: Getter) => Value,\n  write: (get: Getter, set: Setter, ...args: Args) => Result,\n): WritableAtom<Value, Args, Result>\n\nfunction atom<Value, Args extends unknown[], Result>(\n  read: Value,\n  write: (get: Getter, set: Setter, ...args: Args) => Result,\n): WritableAtom<Value, Args, Result>\n```\n\n----------------------------------------\n\nTITLE: Implementing atomWithListeners Function in TypeScript\nDESCRIPTION: This snippet defines the atomWithListeners function, which creates an atom with a listener mechanism. It returns an atom and a hook for adding listeners that are called when the atom's value changes.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-listeners.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useEffect } from 'react'\nimport { atom, useSetAtom, Getter, Setter, SetStateAction } from 'jotai'\n\ntype Callback<Value> = (\n  get: Getter,\n  set: Setter,\n  newVal: Value,\n  prevVal: Value,\n) => void\n\nexport function atomWithListeners<Value>(initialValue: Value) {\n  const baseAtom = atom(initialValue)\n  const listenersAtom = atom<Callback<Value>[]>([])\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, arg: SetStateAction<Value>) => {\n      const prevVal = get(baseAtom)\n      set(baseAtom, arg)\n      const newVal = get(baseAtom)\n      get(listenersAtom).forEach((callback) => {\n        callback(get, set, newVal, prevVal)\n      })\n    },\n  )\n  const useListener = (callback: Callback<Value>) => {\n    const setListeners = useSetAtom(listenersAtom)\n    useEffect(() => {\n      setListeners((prev) => [...prev, callback])\n      return () =>\n        setListeners((prev) => {\n          const index = prev.indexOf(callback)\n          return [...prev.slice(0, index), ...prev.slice(index + 1)]\n        })\n    }, [setListeners, callback])\n  }\n  return [anAtom, useListener] as const\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing atomWithToggleAndStorage in TypeScript for Jotai\nDESCRIPTION: This function creates a writable atom that toggles a boolean value and persists it in storage. It combines the functionality of atomWithToggle and atomWithStorage, allowing for toggling and automatic state persistence.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-toggle-and-storage.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { WritableAtom, atom } from 'jotai'\nimport { atomWithStorage } from 'jotai/utils'\n\nexport function atomWithToggleAndStorage(\n  key: string,\n  initialValue?: boolean,\n  storage?: any,\n): WritableAtom<boolean, [boolean?], void> {\n  const anAtom = atomWithStorage(key, initialValue, storage)\n  const derivedAtom = atom(\n    (get) => get(anAtom),\n    (get, set, nextValue?: boolean) => {\n      const update = nextValue ?? !get(anAtom)\n      void set(anAtom, update)\n    },\n  )\n\n  return derivedAtom as WritableAtom<boolean, [boolean?], void>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Refreshable Data Source\nDESCRIPTION: Example showing how to create a refreshable data source using atomWithRefresh.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomWithRefresh } from 'jotai/utils'\n\nconst postsAtom = atomWithRefresh((get) =>\n  fetch('https://jsonplaceholder.typicode.com/posts').then((r) => r.json()),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a freezeAtomCreator Factory in TypeScript\nDESCRIPTION: Defines a factory function for creating frozen atoms in TypeScript. This utility function wraps atom creation with freezeAtom to ensure all atoms created through it will have their values deeply frozen.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/debugging.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { freezeAtom } from 'jotai/utils'\n\nexport function freezeAtomCreator<\n  CreateAtom extends (...args: unknown[]) => Atom<unknown>,\n>(createAtom: CreateAtom): CreateAtom {\n  return ((...args: unknown[]) => freezeAtom(createAtom(...args))) as never\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Jotai Atom State in Reusable Component (JSX)\nDESCRIPTION: This snippet shows how to create a reusable TextDisplay component using Jotai atoms. It demonstrates initializing atom state with props, using Provider and HydrateAtoms components, and creating child components that share the atom state.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/initialize-atom-on-render.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst textAtom = atom('')\n\nconst PrettyText = () => {\n  const [text] = useAtom(textAtom)\n  return (\n    <>\n      <text\n        style={{\n          color: 'blue',\n        }}\n      >\n        {text}\n      </text>\n    </>\n  )\n}\n\nconst UpdateTextInput = () => {\n  const [text, setText] = useAtom(textAtom)\n  const handleInputChange = (e) => {\n    setText(e.target.value)\n  }\n  return (\n    <>\n      <input onChange={handleInputChange} value={text} />\n    </>\n  )\n}\n\nconst HydrateAtoms = ({ initialValues, children }) => {\n  // initialising on state with prop on render here\n  useHydrateAtoms(initialValues)\n  return children\n}\n\nexport const TextDisplay = ({ initialTextValue }) => (\n  <Provider>\n    <HydrateAtoms initialValues={[[textAtom, initialTextValue]]}>\n      <PrettyText />\n      <br />\n      <UpdateTextInput />\n    </HydrateAtoms>\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Serialize Atom Pattern Implementation\nDESCRIPTION: Complex serialization pattern for Jotai atoms with React component integration for localStorage persistence.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/persistence.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype Actions =\n  | { type: 'serialize'; callback: (value: string) => void }\n  | { type: 'deserialize'; value: string }\n\nconst serializeAtom = atom(null, (get, set, action: Actions) => {\n  if (action.type === 'serialize') {\n    const obj = {\n      todos: get(todosAtom).map(get),\n    }\n    action.callback(JSON.stringify(obj))\n  } else if (action.type === 'deserialize') {\n    const obj = JSON.parse(action.value)\n    // needs error handling and type checking\n    set(\n      todosAtom,\n      obj.todos.map((todo: Todo) => atom(todo)),\n    )\n  }\n})\n\nconst Persist = () => {\n  const [, dispatch] = useAtom(serializeAtom)\n  const save = () => {\n    dispatch({\n      type: 'serialize',\n      callback: (value) => {\n        localStorage.setItem('serializedTodos', value)\n      },\n    })\n  }\n  const load = () => {\n    const value = localStorage.getItem('serializedTodos')\n    if (value) {\n      dispatch({ type: 'deserialize', value })\n    }\n  }\n  return (\n    <div>\n      <button onClick={save}>Save to localStorage</button>\n      <button onClick={load}>Load from localStorage</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using ScopeProvider from jotai-scope in a React Counter App\nDESCRIPTION: A counter example demonstrating how to use ScopeProvider from jotai-scope to create isolated instances of atoms. The anotherCountAtom is scoped to each provider, while countAtom remains shared across providers.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/scope.mdx#2025-04-12_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { ScopeProvider } from 'jotai-scope'\n\nconst countAtom = atom(0)\nconst anotherCountAtom = atom(0)\n\nconst Counter = () => {\n  const [count, setCount] = useAtom(countAtom)\n  const [anotherCount, setAnotherCount] = useAtom(anotherCountAtom)\n  return (\n    <>\n      <div>\n        <span>count: {count}</span>\n        <button type=\"button\" onClick={() => setCount((c) => c + 1)}>\n          increment\n        </button>\n      </div>\n      <div>\n        <span>another count: {anotherCount}</span>\n        <button type=\"button\" onClick={() => setAnotherCount((c) => c + 1)}>\n          increment\n        </button>\n      </div>\n    </>\n  )\n}\n\nconst App = () => {\n  return (\n    <div>\n      <h1>First Provider</h1>\n      <ScopeProvider atoms={[anotherCountAtom]}>\n        <Counter />\n      </ScopeProvider>\n      <h1>Second Provider</h1>\n      <ScopeProvider atoms={[anotherCountAtom]}>\n        <Counter />\n      </ScopeProvider>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Counter with Action Atoms in JavaScript\nDESCRIPTION: Shows how to implement a counter using separate action atoms for increment and decrement operations, allowing for code splitting and lazy loading.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst baseAtom = atom(0) // do not export\nexport const countAtom = atom((get) => get(baseAtom)) // read only\nexport const incAtom = atom(null, (_get, set) => {\n  set(baseAtom, (prev) => prev + 1)\n})\nexport const decAtom = atom(null, (_get, set) => {\n  set(baseAtom, (prev) => prev - 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Advanced atomFamily with Derived State in JavaScript\nDESCRIPTION: Shows how to create an atomFamily that derives its state from another atom (todosAtom) and provides setter functions to update specific properties.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom } from 'jotai'\nimport { atomFamily } from 'jotai/utils'\n\nconst todoFamily = atomFamily((name) =>\n  atom(\n    (get) => get(todosAtom)[name],\n    (get, set, arg) => {\n      const prev = get(todosAtom)\n      set(todosAtom, { ...prev, [name]: { ...prev[name], ...arg } })\n    },\n  ),\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom JSON Storage Implementation\nDESCRIPTION: Shows how to create a custom storage implementation using createJSONStorage with optional JSON parsing configuration\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/storage.mdx#2025-04-12_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst storage = createJSONStorage(\n  // getStringStorage\n  () => localStorage, // or sessionStorage, asyncStorage or alike\n  // options (optional)\n  {\n    reviver, // optional reviver option for JSON.parse\n    replacer, // optional replacer option for JSON.stringify\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing an Editable Text Field with atomWithMachine\nDESCRIPTION: Creating an editable text field using XState machine with Jotai. The machine has two states: reading and editing, with transitions between them based on user interactions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/xstate.mdx#2025-04-12_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithMachine } from 'jotai-xstate'\nimport { assign, createMachine } from 'xstate'\n\nconst createEditableMachine = (value: string) =>\n  createMachine<{ value: string }>({\n    id: 'editable',\n    initial: 'reading',\n    context: {\n      value,\n    },\n    states: {\n      reading: {\n        on: {\n          dblclick: 'editing',\n        },\n      },\n      editing: {\n        on: {\n          cancel: 'reading',\n          commit: {\n            target: 'reading',\n            actions: assign({\n              value: (_, { value }) => value,\n            }),\n          },\n        },\n      },\n    },\n  })\n\nconst defaultTextAtom = atom('edit me')\nconst editableMachineAtom = atomWithMachine((get) =>\n  // `get` is available only for initializing a machine\n  createEditableMachine(get(defaultTextAtom)),\n)\n\nconst Toggle = () => {\n  const [state, send] = useAtom(editableMachineAtom)\n\n  return (\n    <div>\n      {state.matches('reading') && (\n        <strong onDoubleClick={send}>{state.context.value}</strong>\n      )}\n      {state.matches('editing') && (\n        <input\n          autoFocus\n          defaultValue={state.context.value}\n          onBlur={(e) => send({ type: 'commit', value: e.target.value })}\n          onKeyDown={(e) => {\n            if (e.key === 'Enter') {\n              send({ type: 'commit', value: e.target.value })\n            }\n            if (e.key === 'Escape') {\n              send('cancel')\n            }\n          }}\n        />\n      )}\n      <br />\n      <br />\n      <div>\n        Double-click to edit. Blur the input or press <code>enter</code> to\n        commit. Press <code>esc</code> to cancel.\n      </div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Counter Component with Reset Functionality\nDESCRIPTION: Complete example of a counter component implementing multiple ways to reset atom values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithDefault, useResetAtom, RESET } from 'jotai/utils'\n\nconst count1Atom = atom(1)\nconst count2Atom = atomWithDefault((get) => get(count1Atom) * 2)\n\nconst Counter = () => {\n  const [count1, setCount1] = useAtom(count1Atom)\n  const [count2, setCount2] = useAtom(count2Atom)\n  const resetCount2 = useResetAtom(count2Atom)\n\n  return (\n    <>\n      <div>\n        count1: {count1}, count2: {count2}\n      </div>\n      <button onClick={() => setCount1((c) => c + 1)}>increment count1</button>\n      <button onClick={() => setCount2((c) => c + 1)}>increment count2</button>\n      <button onClick={() => resetCount2()}>Reset with useResetAtom</button>\n      <button onClick={() => setCount2(RESET)}>Reset with RESET const</button>\n    </>\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing Counter with Zustand Store and Jotai Atom\nDESCRIPTION: Example implementation showing how to create a counter component using atomWithStore to establish two-way binding between a Zustand store and Jotai atom. The component demonstrates state management and updates through a button click.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/zustand.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithStore } from 'jotai-zustand'\nimport create from 'zustand/vanilla'\n\nconst store = create(() => ({ count: 0 }))\nconst stateAtom = atomWithStore(store)\nconst Counter = () => {\n  const [state, setState] = useAtom(stateAtom)\n\n  return (\n    <>\n      count: {state.count}\n      <button\n        onClick={() => setState((prev) => ({ ...prev, count: prev.count + 1 }))}\n      >\n        button\n      </button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Simple localStorage Pattern with Jotai\nDESCRIPTION: Basic implementation of localStorage persistence with Jotai atoms. Uses a derived atom to sync state with localStorage.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/persistence.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst strAtom = atom(localStorage.getItem('myKey') ?? 'foo')\n\nconst strAtomWithPersistence = atom(\n  (get) => get(strAtom),\n  (get, set, newStr) => {\n    set(strAtom, newStr)\n    localStorage.setItem('myKey', newStr)\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Syncing Atom Values with localStorage in JavaScript\nDESCRIPTION: Shows how to create an atom that synchronizes its value with localStorage, providing persistence across page reloads.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst baseAtom = atom(localStorage.getItem('mykey') || '')\nexport const persistedAtom = atom(\n  (get) => get(baseAtom),\n  (get, set, newValue) => {\n    const nextValue =\n      typeof newValue === 'function' ? newValue(get(baseAtom)) : newValue\n    set(baseAtom, nextValue)\n    localStorage.setItem('mykey', nextValue)\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Storage Reset Implementation\nDESCRIPTION: Example of implementing a reset functionality for stored values using the RESET symbol\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/storage.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithStorage, RESET } from 'jotai/utils'\n\nconst textAtom = atomWithStorage('text', 'hello')\n\nconst TextBox = () => {\n  const [text, setText] = useAtom(textAtom)\n\n  return (\n    <>\n      <input value={text} onChange={(e) => setText(e.target.value)} />\n      <button onClick={() => setText(RESET)}>Reset (to 'hello')</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using withAtomEffect to Bind Effects to an Atom\nDESCRIPTION: Example demonstrating how to use withAtomEffect to create an atom with a bound effect that updates its value based on changes to another atom, including cleanup functionality.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { withAtomEffect } from 'jotai-effect'\n\nconst valuesAtom = withAtomEffect(atom(null), (get, set) => {\n  set(valuesAtom, get(countAtom))\n  return () => {\n    // cleanup\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing atomWithBroadcast for cross-tab state sharing in Jotai with TypeScript\nDESCRIPTION: This snippet defines the atomWithBroadcast function that creates an atom shared between browser tabs and frames using the BroadcastChannel API. It handles sending and receiving updates, managing listeners, and providing a clean API for state updates. The implementation includes proper cleanup through onMount and return functions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-broadcast.mdx#2025-04-12_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { atom, SetStateAction } from 'jotai'\n\nexport function atomWithBroadcast<Value>(key: string, initialValue: Value) {\n  const baseAtom = atom(initialValue)\n  const listeners = new Set<(event: MessageEvent<any>) => void>()\n  const channel = new BroadcastChannel(key)\n\n  channel.onmessage = (event) => {\n    listeners.forEach((l) => l(event))\n  }\n\n  const broadcastAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update: { isEvent: boolean; value: SetStateAction<Value> }) => {\n      set(baseAtom, update.value)\n\n      if (!update.isEvent) {\n        channel.postMessage(get(baseAtom))\n      }\n    },\n  )\n\n  broadcastAtom.onMount = (setAtom) => {\n    const listener = (event: MessageEvent<any>) => {\n      setAtom({ isEvent: true, value: event.data })\n    }\n\n    listeners.add(listener)\n\n    return () => {\n      listeners.delete(listener)\n    }\n  }\n\n  const returnedAtom = atom(\n    (get) => get(broadcastAtom),\n    (_get, set, update: SetStateAction<Value>) => {\n      set(broadcastAtom, { isEvent: false, value: update })\n    },\n  )\n\n  return returnedAtom\n}\n```\n\n----------------------------------------\n\nTITLE: Provider with Custom Store Instance\nDESCRIPTION: Example demonstrating how to create a custom store and pass it to a Provider. This allows for more control over the store's configuration and lifecycle.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/provider.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst myStore = createStore()\n\nconst Root = () => (\n  <Provider store={myStore}>\n    <App />\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Proper Suspense Setup with Provider\nDESCRIPTION: Demonstrates the correct way to set up Suspense with Jotai's Provider component. At least one Suspense component must be inside the Provider to avoid rendering loops.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst App = () => (\n  <Provider>\n    <Suspense fallback=\"Loading...\">\n      <Layout />\n    </Suspense>\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Using atomWithQuery for Pokemon Data Fetching\nDESCRIPTION: A complete example showing how to use atomWithQuery to fetch Pokemon data from a tRPC API. It creates atoms for the selected Pokemon name and for the query result, and demonstrates how to use them in a React component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/trpc.mdx#2025-04-12_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { httpLink } from '@trpc/client'\nimport { createTRPCJotai } from 'jotai-trpc'\nimport { trpcPokemonUrl } from 'trpc-pokemon'\nimport type { PokemonRouter } from 'trpc-pokemon'\n\nconst trpc = createTRPCJotai<PokemonRouter>({\n  links: [\n    httpLink({\n      url: trpcPokemonUrl,\n    }),\n  ],\n})\n\nconst NAMES = [\n  'bulbasaur',\n  'ivysaur',\n  'venusaur',\n  'charmander',\n  'charmeleon',\n  'charizard',\n  'squirtle',\n  'wartortle',\n  'blastoise',\n]\n\nconst nameAtom = atom(NAMES[0])\n\nconst pokemonAtom = trpc.pokemon.byId.atomWithQuery((get) => get(nameAtom))\n\nconst Pokemon = () => {\n  const [data, refresh] = useAtom(pokemonAtom)\n  return (\n    <div>\n      <div>ID: {data.id}</div>\n      <div>Height: {data.height}</div>\n      <div>Weight: {data.weight}</div>\n      <button onClick={refresh}>Refresh</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of observe Function\nDESCRIPTION: Example showing how to use the observe function to react to atom state changes and set values in another atom. Returns an unobserve function that can be called to remove the effect.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { observe } from 'jotai-effect'\n\nconst unobserve = observe((get, set) => {\n  set(logAtom, `someAtom changed: ${get(someAtom)}`)\n})\n\nunobserve()\n```\n\n----------------------------------------\n\nTITLE: React Native Storage Implementation\nDESCRIPTION: Shows how to implement storage in React Native using AsyncStorage\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/storage.mdx#2025-04-12_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nimport { atomWithStorage, createJSONStorage } from 'jotai/utils'\nimport AsyncStorage from '@react-native-async-storage/async-storage'\n\nconst storage = createJSONStorage(() => AsyncStorage)\nconst content = {} // anything JSON serializable\nconst storedAtom = atomWithStorage('stored-key', content, storage)\n```\n\n----------------------------------------\n\nTITLE: Deriving values from multiple async dependencies\nDESCRIPTION: Using derive with multiple atoms as dependencies, passing their values to the producer function in the same order.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/derive.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { derive } from 'jotai-derive'\n\n// Atom<string | Promise<string>>\nconst welcomeMessageAtom = derive(\n  [userAtom, serverNameAtom],\n  (user, serverName) => `Welcome ${user.name} to ${serverName}!`,\n)\n```\n\n----------------------------------------\n\nTITLE: Using Jotai DevTools with Provider\nDESCRIPTION: This example shows how to use the Jotai DevTools component in a React application with a custom Jotai store and Provider. It includes creating a custom store and passing it to both the Provider and DevTools components.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'jotai'\nimport { DevTools } from 'jotai-devtools'\nimport 'jotai-devtools/styles.css'\n\nconst customStore = createStore()\n\nconst App = () => {\n  return (\n    <Provider store={customStore}>\n      <DevTools store={customStore} />\n      {/* your app */}\n    </Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Expensive Atoms Without Lazy Loading in Jotai\nDESCRIPTION: This example shows a scenario where an expensive image initialization happens at definition time, even though it's only used in a specific route. This demonstrates the problem that lazy atoms solve.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/lazy.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst imageDataAtom = atom(initializeExpensiveImage()) // 1) has to be computed here\n\nfunction Home() {\n  ...\n}\n\nfunction ImageEditor() {\n  // 2) used only in this route\n  const [imageData, setImageData] = useAtom(imageDataAtom);\n  ...\n}\n\nfunction App() {\n  return (\n    <Router>\n      <Route path=\"/\" component={Home} />\n      <Route path=\"/edit\" component={ImageEditor} />\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using freezeAtom to Prevent Mutations in Jotai\nDESCRIPTION: Shows how to use freezeAtom utility to deeply freeze atom values with Object.freeze, preventing unintentional mutations. This helps identify bugs where state objects are accidentally modified.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/debugging.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom } from 'jotai'\nimport { freezeAtom } from 'jotai/utils'\n\nconst objAtom = freezeAtom(atom({ count: 0 }))\n```\n\n----------------------------------------\n\nTITLE: AtomWithLocation Usage Example\nDESCRIPTION: Complete example showing how to use atomWithLocation with React components to manage navigation state.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/location.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithLocation } from 'jotai-location'\n\nconst locationAtom = atomWithLocation()\n\nconst App = () => {\n  const [loc, setLoc] = useAtom(locationAtom)\n  return (\n    <ul>\n      <li>\n        <button\n          style={{\n            fontWeight: loc.pathname === '/' ? 'bold' : 'normal',\n          }}\n          onClick={() => setLoc((prev) => ({ ...prev, pathname: '/' }))}\n        >\n          Home\n        </button>\n      </li>\n      <li>\n        <button\n          style={{\n            fontWeight:\n              loc.pathname === '/foo' && !loc.searchParams?.get('bar')\n                ? 'bold'\n                : 'normal',\n          }}\n          onClick={() =>\n            setLoc((prev) => ({\n              ...prev,\n              pathname: '/foo',\n              searchParams: new URLSearchParams(),\n            }))\n          }\n        >\n          Foo\n        </button>\n      </li>\n      <li>\n        <button\n          style={{\n            fontWeight:\n              loc.pathname === '/foo' && loc.searchParams?.get('bar') === '1'\n                ? 'bold'\n                : 'normal',\n          }}\n          onClick={() =>\n            setLoc((prev) => ({\n              ...prev,\n              pathname: '/foo',\n              searchParams: new URLSearchParams([['bar', '1']]),\n            }))\n          }\n        >\n          Foo?bar=1\n        </button>\n      </li>\n    </ul>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Storage Value Validation with Zod\nDESCRIPTION: Implementation of storage validation using Zod schema validation\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/storage.mdx#2025-04-12_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nimport { atomWithStorage } from 'jotai/utils'\nimport { z } from 'zod'\n\nconst myNumberSchema = z.number().int().nonnegative()\n\nconst storedNumberAtom = atomWithStorage('my-number', 0, {\n  getItem(key, initialValue) {\n    const storedValue = localStorage.getItem(key)\n    try {\n      return myNumberSchema.parse(JSON.parse(storedValue ?? ''))\n    } catch {\n      return initialValue\n    }\n  },\n  setItem(key, value) {\n    localStorage.setItem(key, JSON.stringify(value))\n  },\n  removeItem(key) {\n    localStorage.removeItem(key)\n  },\n  subscribe(key, callback, initialValue) {\n    if (\n      typeof window === 'undefined' ||\n      typeof window.addEventListener === 'undefined'\n    ) {\n      return\n    }\n    window.addEventListener('storage', (e) => {\n      if (e.storageArea === localStorage && e.key === key) {\n        let newValue\n        try {\n          newValue = myNumberSchema.parse(JSON.parse(e.newValue ?? ''))\n        } catch {\n          newValue = initialValue\n        }\n        callback(newValue)\n      }\n    })\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Using focusAtom with Jotai\nDESCRIPTION: Demonstration of using focusAtom to create a new atom focused on a specific property of the data structure.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/large-objects.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom } from 'jotai'\nimport { focusAtom } from 'jotai-optics'\n\nconst dataAtom = atom(initialData)\n\nconst peopleAtom = focusAtom(dataAtom, (optic) => optic.prop('people'))\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Infinite Loop Prevention\nDESCRIPTION: Example showing how atomEffect avoids infinite loops by not rerunning when it updates a value that it is watching, preventing recursive updates.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\natomEffect((get, set) => {\n  get(countAtom)\n  set(countAtom, (value) => value + 1) // Will not loop\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing splitAtom in Jotai\nDESCRIPTION: Example of using splitAtom to create individual atoms for each element in an array.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/large-objects.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { splitAtom } from 'jotai/utils'\n\nconst peopleAtomsAtom = splitAtom(peopleAtom)\n```\n\n----------------------------------------\n\nTITLE: Using atomWithListeners in a React Component\nDESCRIPTION: This example demonstrates how to use the atomWithListeners function in a React component. It creates an EvenCounter component that listens for changes to a count atom and updates its state when the count becomes even.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-listeners.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst [countAtom, useCountListener] = atomWithListeners(0)\n\nfunction EvenCounter() {\n  const [evenCount, setEvenCount] = useState(0)\n\n  useCountListener(\n    useCallback(\n      (get, set, newVal, prevVal) => {\n        // Every time `countAtom`'s value is set, we check if its new value\n        // is even, and if it is, we increment `evenCount`.\n        if (newVal % 2 === 0) {\n          setEvenCount((c) => c + 1)\n        }\n      },\n      [setEvenCount],\n    ),\n  )\n\n  return <>Count was set to an even number {evenCount} times.</>\n}\n```\n\n----------------------------------------\n\nTITLE: Building useSplitAtom Hook for Jotai\nDESCRIPTION: Implements a custom hook that leverages splitAtom from Jotai utils to work with arrays in atoms, allowing items to be added, removed, or reordered.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/custom-useatom-hooks.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { splitAtom } from 'jotai/utils'\n\nexport function useSplitAtom(anAtom) {\n  return useAtom(splitAtom(anAtom))\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Primitive Resettable Atom with TodoList Example\nDESCRIPTION: Demonstrates how to create a resettable todo list atom using atomWithReset and useResetAtom hooks from jotai/utils. Includes a component that can add new todos and reset the list to initial state.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/resettable.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithReset, useResetAtom } from 'jotai/utils'\n\nconst todoListAtom = atomWithReset([\n  { description: 'Add a todo', checked: false },\n])\n\nconst TodoList = () => {\n  const [todoList, setTodoList] = useAtom(todoListAtom)\n  const resetTodoList = useResetAtom(todoListAtom)\n\n  return (\n    <>\n      <ul>\n        {todoList.map((todo) => (\n          <li>{todo.description}</li>\n        ))}\n      </ul>\n\n      <button\n        onClick={() =>\n          setTodoList((l) => [\n            ...l,\n            {\n              description: `New todo ${new Date().toDateString()}`,\n              checked: false,\n            },\n          ])\n        }\n      >\n        Add todo\n      </button>\n      <button onClick={resetTodoList}>Reset</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: atomFamily with Custom Equality Function in JavaScript\nDESCRIPTION: Example of atomFamily with a compound parameter object and custom equality function that compares only the id property for atom identity.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom } from 'jotai'\nimport { atomFamily } from 'jotai/utils'\n\nconst todoFamily = atomFamily(\n  ({ id, name }) => atom({ name }),\n  (a, b) => a.id === b.id,\n)\n```\n\n----------------------------------------\n\nTITLE: Maintaining Stable References with selectAtom\nDESCRIPTION: Shows multiple approaches to maintain stable references when using selectAtom within React components to prevent infinite loops.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/select.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst baseAtom = atom(0) // Stable\nconst baseSelector = (v) => v // Stable\nconst Component = () => {\n  // Solution 1: Memoize the whole resulting atom with \"useMemo\"\n  const [value] = useAtom(useMemo(() => selectAtom(baseAtom, (v) => v), []))\n\n  // Solution 2: Memoize the inline callback with \"useCallback\"\n  const [value] = useAtom(\n    selectAtom(\n      baseAtom,\n      useCallback((v) => v, []),\n    ),\n  )\n\n  // Solution 3: All constraints are already satisfied\n  const [value] = useAtom(selectAtom(baseAtom, baseSelector))\n}\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Recursion Support Example\nDESCRIPTION: Example showing how to use set.recurse to implement recursive updates within an effect, with logic to prevent infinite recursion based on a condition.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\natomEffect((get, set) => {\n  const count = get(countAtom)\n  if (count % 10 === 0) {\n    return\n  }\n  set.recurse(countAtom, (value) => value + 1)\n})\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Cleanup Function Example\nDESCRIPTION: Example demonstrating how to use a cleanup function within an effect to properly manage resources like intervals, which is invoked on unmount or before re-evaluation.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\natomEffect((get, set) => {\n  const intervalId = setInterval(() => set(clockAtom, Date.now()))\n  return () => clearInterval(intervalId)\n})\n```\n\n----------------------------------------\n\nTITLE: Migrating Provider's scope Prop in Jotai v2\nDESCRIPTION: Demonstrates how to replace the removed scope prop by creating a custom React Context with a Jotai store, allowing more control over store scoping.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n// Previous API\nconst myScope = Symbol()\n\n  // Parent component\n  <Provider scope={myScope}>\n    ...\n  </Provider>\n\n  // Child component\n  useAtom(..., myScope)\n```\n\nLANGUAGE: jsx\nCODE:\n```\n// New API\nconst MyContext = createContext()\nconst store = createStore()\n\n  // Parent component\n  <MyContext.Provider value={store}>\n    ...\n  </MyContext.Provider>\n\n  // Child Component\n  const store = useContext(MyContext)\n  useAtom(..., { store })\n```\n\n----------------------------------------\n\nTITLE: Implementing Jotai Provider in Next.js App Component\nDESCRIPTION: This TypeScript snippet demonstrates how to wrap a Next.js app component with a Jotai Provider. This ensures that the Jotai store is scoped to each request in SSR scenarios, preventing state leaks between requests.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/nextjs.mdx#2025-04-12_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Provider } from 'jotai'\n\nfunction App({ Component, pageProps }: AppProps) {\n  return (\n    <Provider>\n      <Component {...pageProps} />\n    </Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Example Usage of useAtomEffect in React Component\nDESCRIPTION: This example demonstrates how to use the useAtomEffect hook in a React component. It subscribes to a channel, updates messages atom, and renders the messages. The effect function is memoized using a stable version of useCallback.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/use-atom-effect.mdx#2025-04-12_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useCallbackOne as useStableCallback } from 'use-memo-one'\nimport { atom, useAtom } from 'jotai'\nimport { atomFamily } from 'jotai/utils'\nimport { useAtomEffect } from './useAtomEffect'\n\nconst channelSubscriptionAtomFamily = atomFamily<Channel>(\n  (channelId: string) => {\n    return atom(new Channel(channelId))\n  },\n)\nconst messagesAtom = atom<Message[]>([])\n\nfunction Messages({ channelId }: { channelId: string }) {\n  const [messages] = useAtom(messagesAtom)\n  useAtomEffect(\n    useStableCallback(\n      (get, set) => {\n        const channel = get(channelSubscriptionAtomFamily(channelId))\n        const unsubscribe = channel.subscribe((message) => {\n          set(messagesAtom, (prev) => [...prev, message])\n        })\n        return unsubscribe\n      },\n      [channelId],\n    ),\n  )\n  return (\n    <>\n      <h1>You have {messages.length} messages</h1>\n      <hr />\n      {messages.map((message) => (\n        <div key={message.id}>{message.text}</div>\n      ))}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using atomWithLazy for Deferred Initialization in Jotai\nDESCRIPTION: This snippet demonstrates the usage of `atomWithLazy` to create an atom whose initial value is computed only when it's first used. This is useful for expensive initializations that should be deferred until necessary.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/lazy.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atomWithLazy } from 'jotai/utils'\n\n// passing the initialization function\nconst imageDataAtom = atomWithLazy(initializeExpensiveImage)\n\nfunction Home() {\n  ...\n}\n\nfunction ImageEditor() {\n  // only gets initialized if user goes to `/edit`.\n  const [imageData, setImageData] = useAtom(imageDataAtom);\n  ...\n}\n\nfunction App() {\n  return (\n    <Router>\n      <Route path=\"/\" component={Home} />\n      <Route path=\"/edit\" component={ImageEditor} />\n    </Router>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: atomWithCache Function Signature\nDESCRIPTION: API signature for the atomWithCache function, which creates a read-only atom with caching capabilities. It accepts a read function and optional configuration options.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/cache.mdx#2025-04-12_snippet_1\n\nLANGUAGE: js\nCODE:\n```\natomWithCache(read, options): Atom\n```\n\n----------------------------------------\n\nTITLE: Implementing useSelectAtom Hook with Jotai\nDESCRIPTION: Creates a custom hook that uses selectAtom to derive a value from an atom using a selector function. The hook demonstrates how to properly select and subscribe to parts of an atom's state with proper memoization.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/custom-useatom-hooks.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useAtomValue } from 'jotai'\nimport { selectAtom } from 'jotai/utils'\n\nexport function useSelectAtom(anAtom, selector) {\n  const selectorAtom = selectAtom(\n    anAtom,\n    selector,\n    // Alternatively, you can customize `equalityFn` to determine when it will rerender\n    // Check selectAtom's signature for details.\n  )\n  return useAtomValue(selectorAtom)\n}\n\n// how to use it\nfunction useN(n) {\n  const selector = useCallback((v) => v[n], [n])\n  return useSelectAtom(arrayAtom, selector)\n}\n```\n\n----------------------------------------\n\nTITLE: Testing React Native Components with Jotai\nDESCRIPTION: Demonstrates how to test React Native components that use Jotai atoms using React Native Testing Library. The test verifies counter increment functionality through pressing a button.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/testing.mdx#2025-04-12_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { render, fireEvent } from '@testing-library/react-native'\nimport { Counter } from './counter'\n\ntest('should increment counter', () => {\n  // Arrange\n  const { getByText } = render(<Counter />)\n  const counter = getByText('0')\n  const incrementButton = getByText('one up')\n  // Act\n  fireEvent.press(incrementButton)\n  // Assert\n  expect(counter.props.children.toString()).toEqual('1')\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Jotai Atom State with TypeScript (TSX)\nDESCRIPTION: This snippet shows how to implement the atom state initialization pattern using TypeScript. It uses a Map for initial atom values to work with useHydrateAtoms' overloaded types, and includes type definitions for the AtomsHydrator component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/initialize-atom-on-render.mdx#2025-04-12_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { ReactNode } from 'react'\nimport { Provider, atom, useAtomValue } from 'jotai'\nimport type { WritableAtom } from 'jotai'\nimport { useHydrateAtoms } from 'jotai/utils'\n\nconst testAtom = atom('')\n\nexport default function App() {\n  return (\n    <Provider>\n      <AtomsHydrator atomValues={[[testAtom, 'hello']]}>\n        <Component />\n      </AtomsHydrator>\n    </Provider>\n  )\n}\n\n//This component contains all the states and the logic\nfunction Component() {\n  const testAtomValue = useAtomValue(testAtom)\n  return <div>{testAtomValue}</div>\n}\n\nfunction AtomsHydrator({\n  atomValues,\n  children,\n}: {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  atomValues: Iterable<\n    readonly [WritableAtom<unknown, [any], unknown>, unknown]\n  >\n  children: ReactNode\n}) {\n  useHydrateAtoms(new Map(atomValues))\n  return children\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Atom Configs\nDESCRIPTION: Shows how to create new atom configurations on demand using useState, including a counter implementation with the ability to reset.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/atoms-in-atom.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nconst Component = () => {\n  const [currentAtom, setCurrentAtom] = useState(() => atom(0))\n  const [count, setCount] = useAtom(currentAtom)\n  return (\n    <div>\n      Count: {count} <button onClick={() => setCount((c) => c + 1)}>+1</button>\n      <button onClick={() => setCurrentAtom(atom(0))}>Create new</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining useAtomCallback TypeScript Interface\nDESCRIPTION: TypeScript type definition for the useAtomCallback hook, showing its parameters and return type. The hook accepts a callback function with get and set parameters, and optional options.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/callback.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nuseAtomCallback<Result, Args extends unknown[]>(\n  callback: (get: Getter, set: Setter, ...arg: Args) => Result,\n  options?: Options\n): (...args: Args) => Result\n```\n\n----------------------------------------\n\nTITLE: Managing Lazy Atoms with Multiple Stores in Jotai\nDESCRIPTION: This example illustrates how lazy atoms behave with multiple stores in Jotai. Each store initializes the lazy atom independently on first use, demonstrating that initialization happens once per store.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/lazy.mdx#2025-04-12_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\ntype RGB = [number, number, number];\n\nfunction randomRGB(): RGB {\n  ...\n}\n\nconst lift = (value: number) => ([r, g, b]: RGB) => {\n  return [r + value, g + value, b + value]\n}\n\nconst colorAtom = lazyAtom(randomRGB)\n\nlet store = createStore()\n\nconsole.log(store.get(colorAtom)) // [0, 36, 128]\nstore.set(colorAtom, lift(8))\nconsole.log(store.get(colorAtom)) // [8, 44, 136]\n\n// recreating store, sometimes done when logging out or resetting the app in some way\nstore = createStore()\n\nconsole.log(store.get(colorAtom)) // [255, 12, 46] -- a new random color\n```\n\n----------------------------------------\n\nTITLE: Migrating waitForAll Util in Jotai v2\nDESCRIPTION: Demonstrates how to replace the waitForAll utility with native Promise.all, allowing direct use of JavaScript's built-in promise handling capabilities.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Previous API\nconst allAtom = waitForAll([fooAtom, barAtom])\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// New API\nconst allAtom = atom((get) => Promise.all([get(fooAtom), get(barAtom)]))\n```\n\n----------------------------------------\n\nTITLE: Dependency Management - Dynamic Dependency Recalculation\nDESCRIPTION: Example demonstrating how dependencies are recalculated on every run of the effect, allowing for dynamic dependencies based on conditions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\natomEffect((get, set) => {\n  if (get(isEnabledAtom)) {\n    // `isEnabledAtom` and `anAtom` are dependencies\n    const aValue = get(anAtom)\n  } else {\n    // `isEnabledAtom` and `anotherAtom` are dependencies\n    const anotherValue = get(anotherAtom)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Complete Tags Component Implementation\nDESCRIPTION: Full example combining selectAtom and splitAtom in a React component for displaying tags.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/large-objects.mdx#2025-04-12_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\nimport { selectAtom, splitAtom } from 'jotai/utils'\n\nconst tagsSelector = (s) => s.tags\nconst Tags = () => {\n  const tagsAtom = selectAtom(infoAtom, tagsSelector)\n  const tagsAtomsAtom = splitAtom(tagsAtom)\n  const [tagAtoms] = useAtom(tagsAtomsAtom)\n  return (\n    <div>\n      {tagAtoms.map((tagAtom) => (\n        <Tag key={`${tagAtom}`} tagAtom={tagAtom} />\n      ))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an atomFamily with Deep Equality Comparison in JavaScript\nDESCRIPTION: Example showing how to create an atomFamily with deep equality comparison, similar to Recoil's atomFamily behavior, using a deep equality function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atom } from 'jotai'\nimport { atomFamily } from 'jotai/utils'\nimport deepEqual from 'fast-deep-equal'\n\nconst fooFamily = atomFamily((param) => atom(param), deepEqual)\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Hooks with React Hooks Testing Library in Jotai\nDESCRIPTION: Shows how to test a custom atom in isolation using React Hooks Testing Library. The test verifies that the counter atom's reducer correctly increments the value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/testing.mdx#2025-04-12_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { renderHook, act } from '@testing-library/react-hooks'\nimport { useAtom } from 'jotai'\nimport { countAtom } from './countAtom'\n\ntest('should increment counter', () => {\n  const { result } = renderHook(() => useAtom(countAtom))\n\n  act(() => {\n    result.current[1]('INCREASE')\n  })\n\n  expect(result.current[0]).toBe(1)\n})\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition of useHydrateAtoms\nDESCRIPTION: Provides the TypeScript type definition for the useHydrateAtoms hook, showing its parameters and return type. This definition includes options for specifying a custom store.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/ssr.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useHydrateAtoms(\n  values: Iterable<readonly [Atom<unknown>, unknown]>,\n  options?: { store?: Store },\n): void\n```\n\n----------------------------------------\n\nTITLE: Dependency Management in Effect - Synchronous Example\nDESCRIPTION: Example showing how atoms accessed with get inside the effect are automatically added to the atom's dependencies, causing the effect to run when those atoms change value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\natomEffect((get, set) => {\n  // updates whenever `anAtom` changes value\n  get(anAtom)\n})\n```\n\n----------------------------------------\n\nTITLE: Wrapping Functions in Atoms in JavaScript\nDESCRIPTION: Shows how to wrap a function in an object when creating an atom to avoid confusion with derived atom getter functions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst doublerAtom = atom({ callback: (n) => n * 2 })\n// Usage\nconst [doubler] = useAtom(doublerAtom)\nconst doubledValue = doubler.callback(50) // Will compute to 100\n```\n\n----------------------------------------\n\nTITLE: Using atomWithToggle in a React Component with JSX\nDESCRIPTION: This snippet shows how to use the atom created by atomWithToggle in a React component. It demonstrates accessing the atom's value, toggling it, and forcing specific boolean states using the toggle function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-toggle.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst Toggle = () => {\n  const [isActive, toggle] = useAtom(isActiveAtom)\n\n  return (\n    <>\n      <button onClick={() => toggle()}>\n        isActive: {isActive ? 'yes' : 'no'}\n      </button>\n      <button onClick={() => toggle(true)}>force true</button>\n      <button onClick={() => toggle(false)}>force false</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Derived Atom in JavaScript\nDESCRIPTION: Shows how to create a derived atom that depends on another atom, demonstrating the dependency mechanism in Jotai.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/use-atom.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst uppercaseAtom = atom((get) => get(textAtom).toUpperCase())\n```\n\n----------------------------------------\n\nTITLE: Using atomWithProxy for two-way binding between Jotai and Valtio\nDESCRIPTION: Example demonstrating how to create an atom from a Valtio proxy with two-way binding, allowing state changes from both the atom and the proxy.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/valtio.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithProxy } from 'jotai-valtio'\nimport { proxy } from 'valtio/vanilla'\n\nconst proxyState = proxy({ count: 0 })\nconst stateAtom = atomWithProxy(proxyState)\nconst Counter = () => {\n  const [state, setState] = useAtom(stateAtom)\n\n  return (\n    <>\n      count: {state.count}\n      <button\n        onClick={() => setState((prev) => ({ ...prev, count: prev.count + 1 }))}\n      >\n        inc atom\n      </button>\n      <button\n        onClick={() => {\n          ++proxyState.count\n        }}\n      >\n        inc proxy\n      </button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Atom from Observable in Jotai\nDESCRIPTION: This example shows how to use atomWithObservable to create an atom from an rxjs observable. The atom's value will be the last value emitted from the stream.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/async.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithObservable } from 'jotai/utils'\nimport { interval } from 'rxjs'\nimport { map } from 'rxjs/operators'\n\nconst counterSubject = interval(1000).pipe(map((i) => `#${i}`))\nconst counterAtom = atomWithObservable(() => counterSubject)\n\nconst Counter = () => {\n  const [counter] = useAtom(counterAtom)\n  return <div>count: {counter}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Two-Way Binding with atomWithStore in Jotai-Redux\nDESCRIPTION: Example of creating a counter component that uses atomWithStore to establish two-way binding between a Redux store and a Jotai atom. The component can increment a counter through Redux actions while maintaining synchronization with Jotai's state management.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/redux.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithStore } from 'jotai-redux'\nimport { createStore } from 'redux'\n\nconst initialState = { count: 0 }\nconst reducer = (state = initialState, action: { type: 'INC' }) => {\n  if (action.type === 'INC') {\n    return { ...state, count: state.count + 1 }\n  }\n  return state\n}\nconst store = createStore(reducer)\nconst storeAtom = atomWithStore(store)\n\nconst Counter = () => {\n  const [state, dispatch] = useAtom(storeAtom)\n\n  return (\n    <>\n      count: {state.count}\n      <button onClick={() => dispatch({ type: 'INC' })}>button</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using withHistory function in JavaScript\nDESCRIPTION: Demonstrates how to use the withHistory function to create an atom that tracks state history. It shows the basic setup and usage in a React component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/history.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { withHistory } from 'jotai-history'\n\nconst targetAtom = atom(0)\nconst limit = 2\nconst historyAtom = withHistory(targetAtom, limit)\n\nfunction Component() {\n  const [current, previous] = useAtomValue(historyAtom)\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using atomWithImmer in React Components\nDESCRIPTION: Example showing how to create and use an atomWithImmer to manage counter state with immutable updates\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/immer.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithImmer } from 'jotai-immer'\n\nconst countAtom = atomWithImmer({ value: 0 })\n\nconst Counter = () => {\n  const [count] = useAtom(countAtom)\n  return <div>count: {count.value}</div>\n}\n\nconst Controls = () => {\n  const [, setCount] = useAtom(countAtom)\n  // setCount === update : (draft: Draft<Value>) => void\n  const inc = () =>\n    setCount((draft) => {\n      ++draft.value\n    })\n  return <button onClick={inc}>+1</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Mutation with Jotai URQL\nDESCRIPTION: Example demonstrating how to use atomWithMutation for GraphQL mutations with result handling\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/urql.mdx#2025-04-12_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAtom } from 'jotai'\n\nconst incrementMutationAtom = atomWithMutation<{ increment: number }>({\n  query: 'mutation Increment { increment }',\n})\n\nconst Counter = () => {\n  const [operationResult, executeMutation] = useAtom(incrementMutationAtom)\n  return (\n    <div>\n      <button\n        onClick={() =>\n          executeMutation().then((it) => console.log(it.data?.increment))\n        }\n      >\n        Increment\n      </button>\n      <div>{operationResult.data?.increment}</div>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Atom Config in useState\nDESCRIPTION: Demonstrates how to store and switch between atom configurations using React's useState hook. Shows passing atom configs as props and selecting between different atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/atoms-in-atom.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nconst Component = ({ atom1, atom2 }) => {\n  const [selectedAtom, setSelectedAtom] = useState(atom1)\n  const [value] = useAtom(selectedAtom)\n  return (\n    <div>\n      Selected value: {value}\n      <button onClick={() => setSelectedAtom(atom1)}>Select an atom</button>\n      <button onClick={() => setSelectedAtom(atom2)}>\n        Select another atom\n      </button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using withImmer with Existing Atoms\nDESCRIPTION: Demonstration of using withImmer to wrap an existing atom with Immer functionality\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/immer.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom, atom } from 'jotai'\nimport { withImmer } from 'jotai-immer'\n\nconst primitiveAtom = atom({ value: 0 })\nconst countAtom = withImmer(primitiveAtom)\n\nconst Counter = () => {\n  const [count] = useAtom(countAtom)\n  return <div>count: {count.value}</div>\n}\n\nconst Controls = () => {\n  const [, setCount] = useAtom(countAtom)\n  // setCount === update : (draft: Draft<Value>) => void\n  const inc = () =>\n    setCount((draft) => {\n      ++draft.value\n    })\n  return <button onClick={inc}>+1</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Mutation State with atomWithMutationState\nDESCRIPTION: Shows how to create an atom that tracks all mutations matching specific filters in the MutationCache. This allows for monitoring mutation activity across components.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst mutationStateAtom = atomWithMutationState((get) => ({\n  filters: {\n    mutationKey: ['posts'],\n  },\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing GraphQL Query with Jotai URQL\nDESCRIPTION: Example showing how to use atomWithQuery for GraphQL queries with error handling and data fetching\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/urql.mdx#2025-04-12_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useAtom } from 'jotai'\n\nconst countQueryAtom = atomWithQuery<{ count: number }>({\n  query: 'query Count { count }',\n  getClient: () => client, // This option is optional if `useRehydrateAtom([[clientAtom, client]])` is used globally\n})\n\nconst Counter = () => {\n  // Will suspend until first operation result is resolved. Either with error, partial data, data\n  const [operationResult, reexecute] = useAtom(countQueryAtom)\n\n  if (operationResult.error) {\n    // This shall be handled in the parent ErrorBoundary above\n    throw operationResult.error\n  }\n\n  // You have to use optional chaining here, as data may be undefined at this point (only in case of error)\n  return <>{operationResult.data?.count}</>\n}\n```\n\n----------------------------------------\n\nTITLE: Simplified Storage Validation\nDESCRIPTION: Shows how to use the unstable_withStorageValidator utility for simpler storage validation\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/storage.mdx#2025-04-12_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nimport {\n  atomWithStorage,\n  createJSONStorage,\n  unstable_withStorageValidator as withStorageValidator,\n} from 'jotai/utils'\nimport { z } from 'zod'\n\nconst myNumberSchema = z.number().int().nonnegative()\nconst isMyNumber = (v) => myNumberSchema.safeParse(v).success\n\nconst storedNumberAtom = atomWithStorage(\n  'my-number',\n  0,\n  withStorageValidator(isMyNumber)(createJSONStorage()),\n)\n```\n\n----------------------------------------\n\nTITLE: Posts List Component with Refresh\nDESCRIPTION: Example of a component that displays and refreshes posts using atomWithRefresh.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_10\n\nLANGUAGE: jsx\nCODE:\n```\nconst PostsList = () => {\n  const [posts, refreshPosts] = useAtom(postsAtom)\n\n  return (\n    <div>\n      <ul>\n        {posts.map((post) => (\n          <li key={post.id}>{post.title}</li>\n        ))}\n      </ul>\n\n      {/* Clicking this button will re-fetch the posts */}\n      <button type=\"button\" onClick={() => refreshPosts()}>\n        Refresh posts\n      </button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Atom Values in JavaScript\nDESCRIPTION: Demonstrates how to create an atom that can override the value of a read-only atom, allowing for dynamic value manipulation.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/composing-atoms.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst rawNumberAtom = atom(10.1) // can be exported\nconst roundNumberAtom = atom((get) => Math.round(get(rawNumberAtom)))\nconst overwrittenAtom = atom(null)\nexport const numberAtom = atom(\n  (get) => get(overwrittenAtom) ?? get(roundNumberAtom),\n  (get, set, newValue) => {\n    const nextValue =\n      typeof newValue === 'function' ? newValue(get(numberAtom)) : newValue\n    set(overwrittenAtom, nextValue)\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing sequenceAtomArray for Jotai Atoms\nDESCRIPTION: This snippet shows how to implement a sequencing operation for Jotai atoms, similar to Promise.all. It converts an array of atoms into an atom containing an array, demonstrating the monad-traversable relationship.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/functional-programming-and-jotai.mdx#2025-04-12_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nfunction sequenceAtomArray<T>(atoms: Array<Atom<T>>): Atom<Array<T>> {\n  return atom((get) => atoms.map(get))\n}\n```\n\n----------------------------------------\n\nTITLE: Dependency Management in Effect - Asynchronous Example\nDESCRIPTION: Example demonstrating that asynchronous get calls do not add atoms to the effect's dependencies, meaning changes to those atoms won't trigger the effect to run.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\natomEffect((get, set) => {\n  setTimeout(() => {\n    // does not add `anAtom` as a dependency\n    get(anAtom)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Testing with Injected Initial Values in Jotai\nDESCRIPTION: Demonstrates how to test components with specific initial atom values using Jotai's Provider and useHydrateAtoms. This example tests that a counter doesn't increment beyond a maximum value of 100.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/testing.mdx#2025-04-12_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react'\nimport { render, screen } from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport { useHydrateAtoms } from 'jotai/utils'\nimport { countAtom, Counter } from './Counter'\nimport { Provider } from 'jotai'\n\nconst HydrateAtoms = ({ initialValues, children }) => {\n  useHydrateAtoms(initialValues)\n  return children\n}\n\nconst TestProvider = ({ initialValues, children }) => (\n  <Provider>\n    <HydrateAtoms initialValues={initialValues}>{children}</HydrateAtoms>\n  </Provider>\n)\n\nconst CounterProvider = () => {\n  return (\n    <TestProvider initialValues={[[countAtom, 100]]}>\n      <Counter />\n    </TestProvider>\n  )\n}\n\ntest('should not increment on max (100)', () => {\n  render(<CounterProvider />)\n\n  const counter = screen.getByText('100')\n  const incrementButton = screen.getByText('one up')\n  await userEvent.click(incrementButton)\n  expect(counter.textContent).toEqual('100')\n})\n```\n\n----------------------------------------\n\nTITLE: Using useAtomsDebugValue Hook in React\nDESCRIPTION: This example demonstrates the usage of the useAtomsDebugValue hook from jotai-devtools/utils. It shows how to create atoms, use them in components, and implement the debug hook to display atom values in React DevTools.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtomsDebugValue } from 'jotai-devtools/utils'\n\nconst textAtom = atom('hello')\ntextAtom.debugLabel = 'textAtom'\n\nconst lenAtom = atom((get) => get(textAtom).length)\nlenAtom.debugLabel = 'lenAtom'\n\nconst TextBox = () => {\n  const [text, setText] = useAtom(textAtom)\n  const [len] = useAtom(lenAtom)\n  return (\n    <span>\n      <input value={text} onChange={(e) => setText(e.target.value)} />({len})\n    </span>\n  )\n}\n\nconst DebugAtoms = () => {\n  useAtomsDebugValue()\n  return null\n}\n\nconst App = () => (\n  <Provider>\n    <DebugAtoms />\n    <TextBox />\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Jotai Optics Usage\nDESCRIPTION: Demonstrates creating a derived atom using focusAtom to access a nested property\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/optics.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst baseAtom = atom({ a: 5 }) // PrimitiveAtom<{a: number}>\nconst derivedAtom = focusAtom(baseAtom, (optic) => optic.prop('a')) // PrimitiveAtom<number>\n```\n\n----------------------------------------\n\nTITLE: Using observe with React and Custom Store\nDESCRIPTION: Example demonstrating how to use observe with a custom Jotai store in a React application, ensuring the effect is mounted to the correct store provided to the Provider component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst store = createStore()\nconst unobserve = observe((get, set) => {\n  set(logAtom, `someAtom changed: ${get(someAtom)}`)\n}, store)\n\n<Provider store={store}>...</Provider>\n```\n\n----------------------------------------\n\nTITLE: Using Reusable Jotai Component in App (JSX)\nDESCRIPTION: This snippet demonstrates how to use the reusable TextDisplay component with different initial text values in an App component. It showcases the ability to create multiple instances of the component with unique atom states.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/initialize-atom-on-render.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nexport default function App() {\n  return (\n    <div className=\"App\">\n      <TextDisplay initialTextValue=\"initial text value 1\" />\n\n      <TextDisplay initialTextValue=\"initial text value 2\" />\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using atomWithProxy with sync option for synchronous updates\nDESCRIPTION: Example of using atomWithProxy with the sync option enabled for synchronous updates instead of batched updates, which can help sync with other Jotai atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/valtio.mdx#2025-04-12_snippet_3\n\nLANGUAGE: js\nCODE:\n```\natomWithProxy(proxyObject, { sync: true })\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Synchronous Execution Example\nDESCRIPTION: Example showing how effects run synchronously in the current task after synchronous evaluations complete, allowing immediate access to updated values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nconst logCounts = atomEffect((get, set) => {\n  set(logAtom, `count is ${get(countAtom)}`)\n})\nconst actionAtom = atom(null, (get, set) => {\n  get(logAtom) // 'count is 0'\n  set(countAtom, (value) => value + 1) // effect runs synchronously\n  get(logAtom) // 'count is 1'\n})\nstore.sub(logCounts, () => {})\nstore.set(actionAtom)\n```\n\n----------------------------------------\n\nTITLE: Advanced Usage of useHydrateAtoms in JavaScript\nDESCRIPTION: Shows more complex usage of useHydrateAtoms, including hydrating multiple atoms, using a Map, and specifying a custom store. This example demonstrates flexibility in hydrating atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/ssr.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// Usage with an array, specifying a store\nuseHydrateAtoms(\n  [\n    [countAtom, 42],\n    [frameworkAtom, 'Next.js'],\n  ],\n  { store: myStore },\n)\n// Or with a map\nuseHydrateAtoms(new Map([[count, 42]]))\n```\n\n----------------------------------------\n\nTITLE: Using useAtomsDevtools Hook in React\nDESCRIPTION: This example demonstrates the usage of the useAtomsDevtools hook, which shows all atoms in the store. It includes creating atoms, using them in a component, and implementing the debug hook in a wrapper component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_8\n\nLANGUAGE: jsx\nCODE:\n```\nconst countAtom = atom(0);\nconst doubleCountAtom = atom((get) => get(countAtom) * 2);\n\nfunction Counter() {\n  const  [count, setCount] =  useAtom(countAtom);\n  const  [doubleCount] =  useAtom(doubleCountAtom);\n\n  ...\n}\n\nconst AtomsDevtools = ({ children }) => {\n  useAtomsDevtools('demo')\n  return children\n}\n\nexport default function App()  {\n  return (\n    <AtomsDevtools>\n      <Counter />\n    </AtomsDevtools>\n  )\n }\n```\n\n----------------------------------------\n\nTITLE: Creating a derived atom with jotai-derive\nDESCRIPTION: Using the derive function to create a tighter async data-processing pipeline that only awaits when necessary, avoiding unnecessary recomputation.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/derive.mdx#2025-04-12_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// With `jotai-derive`\n\nimport { derive } from 'jotai-derive'\n\n// Atom<string | Promise<string>>\nconst uppercaseNameAtom = derive(\n  [userAtom], // will be awaited only when necessary\n  (user) => user.name.toUppercase(),\n)\n```\n\n----------------------------------------\n\nTITLE: AtomWithHash Usage Example\nDESCRIPTION: Example demonstrating how to use atomWithHash to create a counter component with persisted state in URL hash.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/location.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithHash } from 'jotai-location'\n\nconst countAtom = atomWithHash('count', 1)\n\nconst Counter = () => {\n  const [count, setCount] = useAtom(countAtom)\n  return (\n    <div>\n      <div>count: {count}</div>\n      <button onClick={() => setCount((c) => c + 1)}>+1</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Reset Implementation\nDESCRIPTION: Demonstrates conditional reset functionality based on previous value state\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/storage.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithStorage, RESET } from 'jotai/utils'\n\nconst isVisibleAtom = atomWithStorage('visible', false)\n\nconst TextBox = () => {\n  const [isVisible, setIsVisible] = useAtom(isVisibleAtom)\n\n  return (\n    <>\n      { isVisible && <h1>Header is visible!</h1> }\n      <button onClick={() => setIsVisible((prev) => prev ? RESET : true))}>Toggle visible</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Relay Query with Jotai\nDESCRIPTION: Complete example demonstrating how to use atomWithQuery to fetch data from a GraphQL API using Relay with Jotai. Shows environment setup, query atom creation, and component implementation with proper Provider and Suspense boundaries.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/relay.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport React, { Suspense } from 'react'\nimport { Provider, useAtom } from 'jotai'\nimport { useHydrateAtoms } from 'jotai/utils'\nimport { environmentAtom, atomWithQuery } from 'jotai-relay'\nimport { Environment, Network, RecordSource, Store } from 'relay-runtime'\nimport graphql from 'babel-plugin-relay/macro'\n\nconst myEnvironment = new Environment({\n  network: Network.create(async (params, variables) => {\n    const response = await fetch('https://countries.trevorblades.com/', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        query: params.text,\n        variables,\n      }),\n    })\n    return response.json()\n  }),\n  store: new Store(new RecordSource()),\n})\n\nconst countriesAtom = atomWithQuery(\n  graphql`\n    query AppCountriesQuery {\n      countries {\n        name\n      }\n    }\n  `,\n  () => ({}),\n)\n\nconst Main = () => {\n  const [data] = useAtom(countriesAtom)\n  return (\n    <ul>\n      {data.countries.map(({ name }) => (\n        <li key={name}>{name}</li>\n      ))}\n    </ul>\n  )\n}\n\nconst HydrateAtoms = ({ children }) => {\n  useHydrateAtoms([[environmentAtom, myEnvironment]])\n  return children\n}\n\nconst App = () => {\n  return (\n    <Provider>\n      <HydrateAtoms>\n        <Suspense fallback=\"Loading...\">\n          <Main />\n        </Suspense>\n      </HydrateAtoms>\n    </Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: AtomFamily Serialization Pattern\nDESCRIPTION: Advanced serialization pattern using atomFamily with support for complex state structures and localStorage persistence.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/persistence.mdx#2025-04-12_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntype Actions =\n  | { type: 'serialize'; callback: (value: string) => void }\n  | { type: 'deserialize'; value: string }\n\nconst serializeAtom = atom(null, (get, set, action: Actions) => {\n  if (action.type === 'serialize') {\n    const todos = get(todosAtom)\n    const todoMap: Record<string, { title: string; completed: boolean }> = {}\n    todos.forEach((id) => {\n      todoMap[id] = get(todoAtomFamily({ id }))\n    })\n    const obj = {\n      todos,\n      todoMap,\n      filter: get(filterAtom),\n    }\n    action.callback(JSON.stringify(obj))\n  } else if (action.type === 'deserialize') {\n    const obj = JSON.parse(action.value)\n    // needs error handling and type checking\n    set(filterAtom, obj.filter)\n    obj.todos.forEach((id: string) => {\n      const todo = obj.todoMap[id]\n      set(todoAtomFamily({ id, ...todo }), todo)\n    })\n    set(todosAtom, obj.todos)\n  }\n})\n\nconst Persist = () => {\n  const [, dispatch] = useAtom(serializeAtom)\n  const save = () => {\n    dispatch({\n      type: 'serialize',\n      callback: (value) => {\n        localStorage.setItem('serializedTodos', value)\n      },\n    })\n  }\n  const load = () => {\n    const value = localStorage.getItem('serializedTodos')\n    if (value) {\n      dispatch({ type: 'deserialize', value })\n    }\n  }\n  return (\n    <div>\n      <button onClick={save}>Save to localStorage</button>\n      <button onClick={load}>Load from localStorage</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useAtomsSnapshot Hook in React\nDESCRIPTION: This example shows how to use the useAtomsSnapshot hook to take a snapshot of currently mounted atoms and their state. It demonstrates iterating over the snapshot and displaying atom information.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_9\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Provider } from 'jotai'\nimport { useAtomsSnapshot } from 'jotai-devtools/utils'\n\nconst RegisteredAtoms = () => {\n  const atoms = useAtomsSnapshot()\n\n  return (\n    <div>\n      <p>Atom count: {atoms.size}</p>\n      <div>\n        {Array.from(atoms).map(([atom, atomValue]) => (\n          <p key={`${atom}`}>{`${atom.debugLabel}: ${atomValue}`}</p>\n        ))}\n      </div>\n    </div>\n  )\n}\n\nconst App = () => (\n  <Provider>\n    <RegisteredAtoms />\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Idempotency Example\nDESCRIPTION: Example showing how atomEffect runs once per state change, regardless of how many times it is referenced, ensuring consistent behavior and avoiding duplicate executions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nlet i = 0\nconst effectAtom = atomEffect(() => {\n  get(countAtom)\n  i++\n})\nstore.sub(effectAtom, () => {})\nstore.sub(effectAtom, () => {})\nstore.set(countAtom, (value) => value + 1)\nconsole.log(i) // 1\n```\n\n----------------------------------------\n\nTITLE: Creating Derived Atoms\nDESCRIPTION: Shows two approaches to creating derived atoms from nested atom configurations, including a concise version using double get.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/atoms-in-atom.mdx#2025-04-12_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst derivedNameAtom = atom((get) => {\n  const nameAtom = get(showingNameAtom)\n  return get(nameAtom)\n})\n\n// Or a shorter version\nconst derivedNameAtom = atom((get) => get(get(showingNameAtom)))\n```\n\n----------------------------------------\n\nTITLE: SessionStorage Configuration with atomWithStorage\nDESCRIPTION: Example of using atomWithStorage utility with sessionStorage configuration.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/persistence.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomWithStorage, createJSONStorage } from 'jotai/utils'\n\nconst storage = createJSONStorage(() => sessionStorage)\nconst someAtom = atomWithStorage('some-key', someInitialValue, storage)\n```\n\n----------------------------------------\n\nTITLE: Installing jotai-scope Package\nDESCRIPTION: Command to install the jotai-scope package via npm, which provides functionality for scoping Jotai atoms within component subtrees.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/scope.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-scope\n```\n\n----------------------------------------\n\nTITLE: Implementing useAtomDevtools Hook in TypeScript\nDESCRIPTION: This example shows how to use the useAtomDevtools hook from jotai-devtools/utils in TypeScript. It demonstrates creating a typed atom, setting a debug label, and using the hook with different configurations.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useAtomDevtools } from 'jotai-devtools/utils'\n\nexport interface Task {\n  label: string\n  complete: boolean\n}\n\nexport const tasksAtom = atom<Task[]>([])\n\ntasksAtom.debugLabel = 'Tasks'\n\nexport const useTasksDevtools = () => {\n  useAtomDevtools(tasksAtom)\n\n  useAtomDevtools<Task[]>(tasksAtom)\n\n  useAtomDevtools(tasksAtom, 'Tasks (Instance 1)')\n  useAtomDevtools(tasksAtom, 'Tasks (Instance 2)')\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Signatures for useAtom Hook\nDESCRIPTION: Provides the TypeScript function signatures for the useAtom hook, showing its usage with writable and read-only atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/use-atom.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// primitive or writable derived atom\nfunction useAtom<Value, Update>(\n  atom: WritableAtom<Value, Update>,\n  options?: { store?: Store },\n): [Value, SetAtom<Update>]\n\n// read-only atom\nfunction useAtom<Value>(\n  atom: Atom<Value>,\n  options?: { store?: Store },\n): [Value, never]\n```\n\n----------------------------------------\n\nTITLE: Basic atomWithQuery Function Signature\nDESCRIPTION: Shows the TypeScript signature for all jotai-tanstack-query atom creators. The pattern consists of a getOptions function that returns query options and an optional getQueryClient function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst dataAtom = atomWithSomething(getOptions, getQueryClient)\n```\n\n----------------------------------------\n\nTITLE: Explicitly Typed Primitive Atom Family in TypeScript\nDESCRIPTION: Example of explicitly declaring atomFamily for a primitive atom using SetStateAction type in TypeScript.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype SetStateAction<Value> = Value | ((prev: Value) => Value)\n\nconst myFamily = atomFamily<number, number, SetStateAction<number>>(\n  (id: number) => atom(id),\n)\n```\n\n----------------------------------------\n\nTITLE: Hydrating Multiple Stores in JavaScript\nDESCRIPTION: Illustrates how to hydrate atoms in multiple stores by using multiple useHydrateAtoms hooks. This approach allows for more complex state management scenarios.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/ssr.mdx#2025-04-12_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nuseHydrateAtoms([\n  [countAtom, 42],\n  [frameworkAtom, 'Next.js'],\n])\nuseHydrateAtoms(\n  [\n    [countAtom, 17],\n    [frameworkAtom, 'Gatsby'],\n  ],\n  { store: myStore },\n)\n```\n\n----------------------------------------\n\nTITLE: Creating a Counter Atom with Reducer in Jotai\nDESCRIPTION: Implements a counter atom using atomWithReducer from Jotai utils. The reducer handles INCREASE and DECREASE actions to modify the counter state.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/testing.mdx#2025-04-12_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { atomWithReducer } from 'jotai/utils'\n\nconst reducer = (state: number, action?: 'INCREASE' | 'DECREASE') => {\n  switch (action) {\n    case 'INCREASE':\n      return state + 1\n    case 'DECREASE':\n      return state - 1\n    case undefined:\n      return state\n  }\n}\nexport const countAtom = atomWithReducer(0, reducer)\n```\n\n----------------------------------------\n\nTITLE: Creating a Counter Component with Jotai in React\nDESCRIPTION: Demonstrates a simple counter component implementation using Jotai. It defines a count atom with an initial value of 0 and a Counter component that displays and increments the count.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/testing.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtom } from 'jotai'\n\nexport const countAtom = atom(0)\n\nexport function Counter() {\n  const [count, setCount] = useAtom(countAtom)\n  return (\n    <h1>\n      <p>{count}</p>\n      <button onClick={() => setCount((c) => c + 1)}>one up</button>\n    </h1>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: atomWithProxy function signature and parameters\nDESCRIPTION: The function signature for atomWithProxy showing required and optional parameters. It accepts a proxy object and optional configuration options.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/valtio.mdx#2025-04-12_snippet_2\n\nLANGUAGE: js\nCODE:\n```\natomWithProxy(proxyObject, options?)\n```\n\n----------------------------------------\n\nTITLE: Using useAtomValue Hook in JSX\nDESCRIPTION: Illustrates the usage of useAtomValue hook to read an atom's value without the setter function, which can be useful for performance optimization.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/use-atom.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst countAtom = atom(0)\n\nconst Counter = () => {\n  const setCount = useSetAtom(countAtom)\n  const count = useAtomValue(countAtom)\n\n  return (\n    <>\n      <div>count: {count}</div>\n      <button onClick={() => setCount(count + 1)}>+1</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Defining selectAtom TypeScript Signature\nDESCRIPTION: TypeScript function signature for selectAtom showing its parameters including the source atom, selector function, and optional equality function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/select.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction selectAtom<Value, Slice>(\n  anAtom: Atom<Value>,\n  selector: (v: Value, prevSlice?: Slice) => Slice,\n  equalityFn: (a: Slice, b: Slice) => boolean = Object.is,\n): Atom<Slice>\n```\n\n----------------------------------------\n\nTITLE: Defining atomWithReset Type in TypeScript\nDESCRIPTION: TypeScript type definition for atomWithReset function that creates a resettable atom with an initial value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction atomWithReset<Value>(\n  initialValue: Value,\n): WritableAtom<Value, SetStateAction<Value> | typeof RESET>\n```\n\n----------------------------------------\n\nTITLE: Explicit TypeScript Generic Type Declaration for atomFamily\nDESCRIPTION: Shows how to explicitly declare parameter, value, and update action types using TypeScript generics with atomFamily.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\natomFamily<Param, Value, Update>(initializeAtom: (param: Param) => WritableAtom<Value, Update>, areEqual?: (a: Param, b: Param) => boolean)\natomFamily<Param, Value>(initializeAtom: (param: Param) => Atom<Value>, areEqual?: (a: Param, b: Param) => boolean)\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite with Jotai Babel Plugins\nDESCRIPTION: Configuration setup for Vite that enables Jotai debug labels and React refresh functionality. The config imports necessary plugins from jotai/babel and includes them in the Vite React plugin configuration.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/vite.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport jotaiDebugLabel from 'jotai/babel/plugin-debug-label'\nimport jotaiReactRefresh from 'jotai/babel/plugin-react-refresh'\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [\n    react({ babel: { plugins: [jotaiDebugLabel, jotaiReactRefresh] } }),\n  ],\n  // ... The rest of your configuration\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Reset Functionality Example\nDESCRIPTION: Complex example showing how to implement reset functionality with derived atoms and components.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useSetAtom } from 'jotai'\nimport { atomWithReset, useResetAtom, RESET } from 'jotai/utils'\n\nconst dollarsAtom = atomWithReset(0)\nconst centsAtom = atom(\n  (get) => get(dollarsAtom) * 100,\n  (get, set, newValue: number | typeof RESET) =>\n    set(dollarsAtom, newValue === RESET ? newValue : newValue / 100)\n)\n\nconst ResetExample = () => {\n  const setDollars = useSetAtom(dollarsAtom)\n  const resetCents = useResetAtom(centsAtom)\n\n  return (\n    <>\n      <button onClick={() => setDollars(RESET)}>Reset dollars</button>\n      <button onClick={resetCents}>Reset cents</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Definition for Async-Compatible Atom\nDESCRIPTION: Demonstrates how to properly type an atom in TypeScript to accept both synchronous values and promises. This is necessary because TypeScript infers a primitive type by default.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/async.mdx#2025-04-12_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst baseAtom = atom<number | Promise<number>>(0) // Will accept sync and async values\n```\n\n----------------------------------------\n\nTITLE: Using atomWithToggleAndStorage in JavaScript with Jotai\nDESCRIPTION: This example demonstrates how to use the atomWithToggleAndStorage function to create an atom. The created atom will have an initial value of false and will be stored in localStorage under the key 'isActive'.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-toggle-and-storage.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomWithToggleAndStorage } from 'XXX'\n\n// will have an initial value set to false & get stored in localStorage under the key \"isActive\"\nconst isActiveAtom = atomWithToggleAndStorage('isActive')\n```\n\n----------------------------------------\n\nTITLE: SplitAtom Function Signature with Key Extractor\nDESCRIPTION: Detailed function signature for splitAtom showing the optional key extractor parameter and return type. Demonstrates the flexibility of accepting either WritableAtom or regular Atom as input.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/split.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport function splitAtom<Item, Key>(\n  arrAtom: WritableAtom<Item[], [Item[]], void> | Atom<Item[]>,\n  keyExtractor?: (item: Item) => Key,\n)\n```\n\n----------------------------------------\n\nTITLE: Using mutableAtom for self-aware proxied values\nDESCRIPTION: Example showing how to create and use a mutableAtom, which wraps a value in a self-aware Valtio proxy that can be modified directly like a normal JavaScript object.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/valtio.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\nconst countProxyAtom = mutableAtom(0)\n\nfunction IncrementButton() {\n  const countProxy = useAtomValue(countProxyAtom)\n  return <button onClick={() => ++countProxy.value}>+</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Observe Function Type Signature in TypeScript\nDESCRIPTION: Type definition for the observe function, which defines the Effect type, Cleanup type, and Unobserve return type. This function mounts an effect to watch state changes on a Jotai store.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype Cleanup = () => void\n\ntype Effect = (\n  get: Getter & { peek: Getter }\n  set: Setter & { recurse: Setter }\n) => Cleanup | void\n\ntype Unobserve = () => void\n\nfunction observe(effect: Effect, store?: Store): Unobserve\n```\n\n----------------------------------------\n\nTITLE: Adding Debug Labels to Atoms in Jotai\nDESCRIPTION: Demonstrates how to add a debug label to a Jotai atom for easier identification during debugging. The example shows setting a custom label 'count' that will only be applied in non-production environments.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/debugging.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst countAtom = atom(0)\n// countAtom's debugLabel by default is 'atom1'\nif (process.env.NODE_ENV !== 'production') {\n  countAtom.debugLabel = 'count'\n  // debugLabel is 'count' now\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Bunja with Lifecycle Effects\nDESCRIPTION: Creates a basic bunja with a count atom and lifecycle effects. The bunja instance is created when accessed via useBunja and destroyed when no longer referenced.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/bunja.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bunja } from 'bunja'\nimport { useBunja } from 'bunja/react'\n\nconst countBunja = bunja([], () => {\n  const countAtom = atom(0)\n  return {\n    countAtom,\n    [bunja.effect]() {\n      console.log('mounted')\n      return () => console.log('unmounted')\n    },\n  }\n})\n\nfunction MyComponent() {\n  const { countAtom } = useBunja(countBunja)\n  const [count, setCount] = useAtom(countAtom)\n  // Your component logic here\n}\n```\n\n----------------------------------------\n\nTITLE: Using atomWithCompare with Shallow Equality in TypeScript\nDESCRIPTION: An example of creating an atom with atomWithCompare using shallow equality comparison for CSS properties. This prevents re-renders when the new style object is shallow-equal to the previous one.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-compare.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atomWithCompare } from 'XXX'\nimport { shallowEquals } from 'YYY'\nimport { CSSProperties } from 'react'\n\nconst styleAtom = atomWithCompare<CSSProperties>(\n  { backgroundColor: 'blue' },\n  shallowEquals,\n)\n```\n\n----------------------------------------\n\nTITLE: atomEffect Function Signature\nDESCRIPTION: Type definition for the atomEffect function, which creates an atom for declaring side effects that react to state changes when mounted.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfunction atomEffect(effect: Effect): Atom<void>\n```\n\n----------------------------------------\n\nTITLE: Using soon for conditional dependencies\nDESCRIPTION: Advanced usage with the soon function to handle conditional dependencies in atom derivation, enabling more complex data flow control.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/derive.mdx#2025-04-12_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// pipes allow for cleaner code when using `soon` directly.\nimport { pipe } from 'remeda';\nimport { soon } from 'jotai-derive';\n\n// Atom<RestrictedItem | Promise<RestrictedItem>>\nconst queryAtom = ...;\n\n// Atom<boolean | Promise<boolean>>\nconst isAdminAtom = ...;\n\n// Atom<null | RestrictedItem | Promise<null | RestrictedItem>>\nconst restrictedItemAtom = atom((get) =>\n  pipe(\n    get(isAdminAtom),\n    soon((isAdmin) => (isAdmin ? get(queryAtom) : null))\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating a Toggle Atom with atomWithToggle in JavaScript\nDESCRIPTION: This example demonstrates how to use the atomWithToggle function to create a new atom with an initial value of true. It shows the basic usage of the utility function in a JavaScript context.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-toggle.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { atomWithToggle } from 'XXX'\n\n// will have an initial value set to true\nconst isActiveAtom = atomWithToggle(true)\n```\n\n----------------------------------------\n\nTITLE: Migrating Provider's initialValues Prop in Jotai v2\nDESCRIPTION: Shows how to replace the removed initialValues prop from Provider component with the useHydrateAtoms hook, which offers more flexibility for initial atom values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\n// Previous API\nconst countAtom = atom(0)\n\n  // in component\n  <Provider initialValues={[[countAtom, 1]]}>\n    ...\n```\n\nLANGUAGE: jsx\nCODE:\n```\n// New API\nconst countAtom = atom(0)\n\nconst HydrateAtoms = ({ initialValues, children }) => {\n  useHydrateAtoms(initialValues)\n  return children\n}\n\n  // in component\n  <Provider>\n    <HydrateAtoms initialValues={[[countAtom, 1]]}>\n      ...\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Value for atomWithObservable in Jotai\nDESCRIPTION: This snippet demonstrates how to provide an initial value when using atomWithObservable. The initial value can be a static value or a function that returns a value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/async.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst counterAtom = atomWithObservable(() => counterSubject, {\n  initialValue: 10,\n})\n\nconst counterAtom2 = atomWithObservable(() => counterSubject, {\n  initialValue: () => Math.random(),\n})\n```\n\n----------------------------------------\n\nTITLE: Provider Component TypeScript Interface\nDESCRIPTION: TypeScript signature for the Provider component, showing it accepts an optional store prop. This defines the component's API for TypeScript users.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/provider.mdx#2025-04-12_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst Provider: React.FC<{\n  store?: Store\n}>\n```\n\n----------------------------------------\n\nTITLE: atomWithRefresh Type Definition\nDESCRIPTION: TypeScript type definitions for atomWithRefresh function that creates refreshable atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nfunction atomWithRefresh<Value>(\n  read: Read<Value, [], void>,\n): WritableAtom<Value, [], void>\n```\n\n----------------------------------------\n\nTITLE: Managing Map of Atom Configs\nDESCRIPTION: Shows how to store and manage a map of atom configurations for different fruits and their prices, demonstrating object-based atom storage.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/atoms-in-atom.mdx#2025-04-12_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nconst pricesAtom = atom({\n  apple: atom(15),\n  orange: atom(12),\n  pineapple: atom(25),\n})\n\nconst Fruit = ({ name, priceAtom }) => {\n  const [price] = useAtom(priceAtom)\n  return (\n    <div>\n      {name}: {price}\n    </div>\n  )\n}\n\nconst Parent = () => {\n  const [prices] = useAtom(pricesAtom)\n  return (\n    <div>\n      {Object.keys(prices).map((name) => (\n        <Fruit name={name} priceAtom={prices[name]} key={name} />))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of createTRPCJotai\nDESCRIPTION: Shows how to create a tRPC client with Jotai integration using createTRPCJotai and define an atom with a query based on another atom value.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/trpc.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCJotai } from 'jotai-trpc'\n\nconst trpc = createTRPCJotai<MyRouter>({\n  links: [\n    httpLink({\n      url: myUrl,\n    }),\n  ],\n})\n\nconst idAtom = atom('foo')\nconst queryAtom = trpc.bar.baz.atomWithQuery((get) => get(idAtom))\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Jotai Store Outside React in JSX\nDESCRIPTION: This snippet demonstrates how to create a Jotai store, update and read atom values outside React, and use the store within React components. It uses the createStore function to interact with atom states outside the React environment.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/using-store-outside-react.mdx#2025-04-12_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom, useAtomValue, createStore, Provider } from 'jotai'\n\nconst timeAtom = atom(0)\nconst store = createStore()\n\nstore.set(timeAtom, (prev) => prev + 1) // Update atom's value\nstore.get(timeAtom) // Read atom's value\n\nfunction Component() {\n  const time = useAtomValue(timeAtom) // Inside React\n  return (\n    <div className=\"App\">\n      <h1>{time}</h1>\n    </div>\n  )\n}\n\nexport default function App() {\n  return (\n    <Provider store={store}>\n      <Component />\n    </Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vite for Jotai DevTools\nDESCRIPTION: This Vite configuration example shows how to set up Babel presets for Jotai in a Vite + React project, enabling hot reload and debug labels for atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport default defineConfig({\n  plugins: [\n    react({\n      babel: {\n        presets: ['jotai/babel/preset'],\n      },\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Provider Implementation at Root Level\nDESCRIPTION: Example showing how to wrap an entire application with the Provider component. This is a common pattern when you want to provide atom values to the entire app.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/provider.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst Root = () => (\n  <Provider>\n    <App />\n  </Provider>\n)\n```\n\n----------------------------------------\n\nTITLE: Using UNDO and REDO actions with jotai-history in JavaScript\nDESCRIPTION: Demonstrates how to use the UNDO and REDO actions to move backward and forward in the state history within a React component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/history.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { REDO, UNDO } from 'jotai-history'\n\n...\n\nfunction Component() {\n  const setHistoryAtom = useSetAtom(historyAtom)\n  ...\n  setHistoryAtom(UNDO)\n  setHistoryAtom(REDO)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Jotai DevTools via npm\nDESCRIPTION: This command installs the jotai-devtools package using npm, which is required to use the Jotai DevTools features.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-devtools\n```\n\n----------------------------------------\n\nTITLE: Using the Store API in Jotai v2\nDESCRIPTION: Demonstrates how to use the new Store API to directly manipulate atom values, including setting values, retrieving values, and subscribing to changes in the store.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createStore } from 'jotai' // or from 'jotai/vanilla'\n\nconst store = createStore()\nstore.set(fooAtom, 'foo')\n\nconsole.log(store.get(fooAtom)) // prints \"foo\"\n\nconst unsub = store.sub(fooAtom, () => {\n  console.log('fooAtom value in store is changed')\n})\n// call unsub() to unsubscribe.\n```\n\n----------------------------------------\n\nTITLE: Implementing State Management with Jotai in JSX\nDESCRIPTION: This snippet shows how to use Jotai for state management, demonstrating its simplicity compared to React Context. It illustrates the creation of atoms, optional use of Provider, and how components can access and update state using useAtom hook.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/comparison.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Provider, atom, useAtom } from 'jotai'\nconst atom1 = atom(0)\nconst atom2 = atom(0)\n// Optional: you can use Provider's just like useContext,\n// ...but if you only need one,\n// ...you can just omit it and Jotai will use a default one (called Provider-less mode).\nconst Parent = ({ children }) => {\n  return <Provider>{children}</Provider>\n}\nconst Component1 = () => {\n  const [state, setState] = useAtom(atom1)\n}\nconst Component2 = () => {\n  const [state, setState] = useAtom(atom2)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Atom Names for SWC Plugins\nDESCRIPTION: JavaScript configuration showing how to enable SWC plugins for custom atom names in Next.js. This allows the plugins to work with atom factories that have different names.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_10\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  experimental: {\n    swcPlugins: [\n      ['@swc-jotai/debug-label', { atomNames: ['customAtom'] }],\n      ['@swc-jotai/react-refresh', { atomNames: ['customAtom'] }],\n    ],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Default Jotai Store\nDESCRIPTION: Shows how to access the default store used in provider-less mode using getDefaultStore()\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/core/store.mdx#2025-04-12_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst defaultStore = getDefaultStore()\n```\n\n----------------------------------------\n\nTITLE: withAtomEffect Function Signature\nDESCRIPTION: Type definition for the withAtomEffect function, which binds an effect to a clone of the target atom. The effect is active while the cloned atom is mounted.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfunction withAtomEffect<T>(targetAtom: Atom<T>, effect: Effect): Atom<T>\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Inference with atomFamily\nDESCRIPTION: Demonstrates how TypeScript infers types from the initialization function when using atomFamily with a primitive atom.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/family.mdx#2025-04-12_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { PrimitiveAtom } from 'jotai'\n\n/**\n * here the atom(id) returns a PrimitiveAtom<number>\n * and PrimitiveAtom<number> is a WritableAtom<number, SetStateAction<number>>\n */\nconst myFamily = atomFamily((id: number) => atom(id)).\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Batched Updates Example\nDESCRIPTION: Example demonstrating how multiple synchronous updates are batched as a single atomic transaction, with the effect running only once after all updates are applied.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst tensAtom = atom(0)\nconst onesAtom = atom(0)\nconst updateTensAndOnes = atom(null, (get, set) => {\n  set(tensAtom, (value) => value + 1)\n  set(onesAtom, (value) => value + 1)\n})\nconst combos = atom([])\nconst effectAtom = atomEffect((get, set) => {\n  const value = get(tensAtom) * 10 + get(onesAtom)\n  set(combos, (arr) => [...arr, value])\n})\nstore.sub(effectAtom, () => {})\nstore.set(updateTensAndOnes)\nstore.get(combos) // [00, 11]\n```\n\n----------------------------------------\n\nTITLE: Equivalent Promise Structure Using Async-Await Syntax\nDESCRIPTION: This snippet shows the parallel between Jotai's atom pattern and JavaScript's async-await pattern with Promises. It illustrates how both are using similar monadic patterns under the hood.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/functional-programming-and-jotai.mdx#2025-04-12_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst namePromise = Promise.resolve('Visitor')\nconst countPromise = Promise.resolve(1)\nconst greetingPromise = (async function () {\n  const name = await namePromise\n  const count = await countPromise\n  return (\n    <div>\n      Hello, {name}! You have visited this page {count} times.\n    </div>\n  )\n})()\n```\n\n----------------------------------------\n\nTITLE: Simple Reset Button Component Example\nDESCRIPTION: Example showing how to create a button component that resets a todo list atom.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useResetAtom } from 'jotai/utils'\nimport { todoListAtom } from './store'\n\nconst TodoResetButton = () => {\n  const resetTodoList = useResetAtom(todoListAtom)\n  return <button onClick={resetTodoList}>Reset</button>\n}\n```\n\n----------------------------------------\n\nTITLE: Using RESET action with jotai-history in JavaScript\nDESCRIPTION: Shows how to use the RESET action to clear the entire history of states in a React component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/history.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { RESET } from 'jotai-history'\n\n...\n\nfunction Component() {\n  const setHistoryAtom = useSetAtom(historyAtom)\n  ...\n  setHistoryAtom(RESET)\n}\n```\n\n----------------------------------------\n\nTITLE: mutableAtom function signature and parameters\nDESCRIPTION: The function signature for mutableAtom showing required and optional parameters. It accepts an initial value and optional configuration options.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/valtio.mdx#2025-04-12_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nmutableAtom(value, options?)\n```\n\n----------------------------------------\n\nTITLE: Implementing atomWithCompare in TypeScript with Jotai\nDESCRIPTION: The implementation of atomWithCompare function that creates an atom using atomWithReducer. It compares values using a custom comparison function and only updates when the comparison returns false.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-compare.mdx#2025-04-12_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { atomWithReducer } from 'jotai/utils'\n\nexport function atomWithCompare<Value>(\n  initialValue: Value,\n  areEqual: (prev: Value, next: Value) => boolean,\n) {\n  return atomWithReducer(initialValue, (prev: Value, next: Value) => {\n    if (areEqual(prev, next)) {\n      return prev\n    }\n\n    return next\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Dependency Management in Effect - Cleanup Function Example\nDESCRIPTION: Example showing that get calls in the cleanup function do not add atoms to the effect's dependencies, so changes to those atoms won't trigger the effect to run.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\natomEffect((get, set) => {\n  return () => {\n    // does not add `anAtom` as a dependency\n    get(anAtom)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Monad Interface Type Definitions in TypeScript\nDESCRIPTION: This snippet defines the core interface of a monad in TypeScript, showing the three essential functions: of (unit), map, and join. These functions define the behavior required for a structure to be considered a monad.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/functional-programming-and-jotai.mdx#2025-04-12_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\ntype SomeMonad<T> = /* for example... */ Array<T>\ndeclare function of<T>(plainValue: T): SomeMonad<T>\ndeclare function map<T, V>(\n  anInstance: SomeMonad<T>,\n  transformContents: (contents: T) => V,\n): SomeMonad<V>\ndeclare function join<T>(nestedInstances: SomeMonad<SomeMonad<T>>): SomeMonad<T>\n```\n\n----------------------------------------\n\nTITLE: Type Declaration for Promise.all Combinator\nDESCRIPTION: This snippet shows the type declaration for Promise.all, which is a Promise combinator that converts an array of promises into a promise of an array. It demonstrates the concept of sequencing for monads.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/functional-programming-and-jotai.mdx#2025-04-12_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\ndeclare function promiseAll<T>(promises: Array<Promise<T>>): Promise<Array<T>>\n```\n\n----------------------------------------\n\nTITLE: Using Jotai DevTools without Provider\nDESCRIPTION: This example demonstrates how to use the Jotai DevTools component in a React application without a Provider. It includes the necessary import for styles and the DevTools component placement.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DevTools } from 'jotai-devtools'\nimport 'jotai-devtools/styles.css'\n\nconst App = () => {\n  return (\n    <>\n      <DevTools />\n      {/* your app */}\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Forcing Hydration in JavaScript\nDESCRIPTION: Demonstrates how to force hydration of previously hydrated atoms using the dangerouslyForceHydrate option. This should be used cautiously as it may cause issues with concurrent rendering.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/ssr.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nuseHydrateAtoms(\n  [\n    [countAtom, 42],\n    [frameworkAtom, 'Next.js'],\n  ],\n  {\n    dangerouslyForceHydrate: true,\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Type Definitions for URQL Atom Options\nDESCRIPTION: Type definitions for options passed to atomWithQuery and atomWithMutation functions\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/urql.mdx#2025-04-12_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\ntype AtomWithQueryOptions<\n  Data = unknown,\n  Variables extends AnyVariables = AnyVariables,\n> = {\n  query: DocumentInput<Data, Variables>\n  getVariables?: (get: Getter) => Variables\n  getContext?: (get: Getter) => Partial<OperationContext>\n  getPause?: (get: Getter) => boolean\n  getClient?: (get: Getter) => Client\n}\n\ntype AtomWithMutationOptions<\n  Data = unknown,\n  Variables extends AnyVariables = AnyVariables,\n> = {\n  query: DocumentInput<Data, Variables>\n  getClient?: (get: Getter) => Client\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Read-only Atom with selectAtom\nDESCRIPTION: Example showing how to create and use a read-only derived atom using selectAtom.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/large-objects.mdx#2025-04-12_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst infoAtom = atom((get) => get(dataAtom).info)\n```\n\n----------------------------------------\n\nTITLE: Using soonAll for multiple conditional dependencies\nDESCRIPTION: Advanced pattern using soonAll to handle multiple conditions before deciding whether to access another atom, demonstrating complex conditional data flow.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/derive.mdx#2025-04-12_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// pipes allow for cleaner code when using `soon` directly.\nimport { pipe } from 'remeda';\nimport { soon, soonAll } from 'jotai-derive';\n\n// Atom<RestrictedItem | Promise<RestrictedItem>>\nconst queryAtom = ...;\n\n// Atom<boolean | Promise<boolean>>\nconst isAdminAtom = ...;\n\n// Atom<boolean | Promise<boolean>>\nconst enabledAtom = ...;\n\n// Atom<null | RestrictedItem | Promise<null | RestrictedItem>>\nconst restrictedItemAtom = atom((get) =>\n  pipe(\n    soonAll(get(isAdminAtom), get(enabledAtom)),\n    soon(([isAdmin, enabled]) => (isAdmin && enabled ? get(queryAtom) : null))\n  )\n);\n```\n\n----------------------------------------\n\nTITLE: Creating useFreezeAtom Hook in Jotai\nDESCRIPTION: A custom hook that wraps the freezeAtom utility from Jotai to create an immutable version of an atom. This helps prevent unwanted state mutations.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/custom-useatom-hooks.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { freezeAtom } from 'jotai/utils'\n\nexport function useFreezeAtom(anAtom) {\n  return useAtom(freezeAtom(anAtom))\n}\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Conditional Execution Example\nDESCRIPTION: Example showing how to conditionally run an effect based on another atom's value, where the effect only runs when mounted and the condition is met.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\natom((get) => {\n  if (get(isEnabledAtom)) {\n    get(effectAtom)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Effect Behavior - Using Peek Example\nDESCRIPTION: Example demonstrating how to use get.peek to read atom data without subscribing to it, allowing the effect to access values without creating dependencies.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nconst countAtom = atom(0)\natomEffect((get, set) => {\n  const count = get.peek(countAtom) // Will not add `countAtom` as a dependency\n})\n```\n\n----------------------------------------\n\nTITLE: Disabling Suspense in Jotai URQL\nDESCRIPTION: Example showing how to disable suspense functionality globally\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/urql.mdx#2025-04-12_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { suspenseAtom } from 'jotai-urql'\n\nexport const App = () => {\n  // We disable suspense for the entire app\n  useHydrateAtoms([[suspenseAtom, false]])\n  return <Counter />\n}\n```\n\n----------------------------------------\n\nTITLE: React Component using splitAtom\nDESCRIPTION: React component implementation showing how to use splitAtom results in JSX.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/large-objects.mdx#2025-04-12_snippet_3\n\nLANGUAGE: jsx\nCODE:\n```\nconst People = () => {\n  const [peopleAtoms] = useAtom(peopleAtomsAtom)\n  return (\n    <div>\n      {peopleAtoms.map((personAtom) => (\n        <Person personAtom={personAtom} key={`${personAtom}`} />\n      ))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing TanStack Query Devtools\nDESCRIPTION: Example showing how to implement TanStack Query Devtools with Jotai integration and custom query client configuration.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  QueryClientProvider,\n  QueryClient,\n  QueryCache,\n} from '@tanstack/react-query'\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\nimport { queryClientAtom } from 'jotai-tanstack-query'\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: Infinity,\n    },\n  },\n})\n\nconst HydrateAtoms = ({ children }) => {\n  useHydrateAtoms([[queryClientAtom, queryClient]])\n  return children\n}\n\nexport const App = () => {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Provider>\n        <HydrateAtoms>\n          <App />\n        </HydrateAtoms>\n      </Provider>\n      <ReactQueryDevtools />\n    </QueryClientProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing useFocusAtom Hook with Jotai Optics\nDESCRIPTION: A custom hook that uses the jotai-optics extension to focus on a specific property of an atom's state. Demonstrates proper usage of memoization for both the atom and the optics function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/custom-useatom-hooks.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useAtom } from 'jotai'\nimport { focusAtom } from 'jotai-optics'\n\n/* if an atom is created here, please use `useMemo(() => atom(initValue), [initValue])` instead. */\nexport function useFocusAtom(anAtom, keyFn) {\n    return useAtom(focusAtom(anAtom, keyFn))\n}\n\n// how to use it\nuseFocusAtom(anAtom) {\n    useMemo(() => atom(initValue), [initValue]),\n    useCallback((optic) => optic.prop('key'), [])\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring @swc-jotai/react-refresh in Next.js\nDESCRIPTION: JavaScript configuration for enabling the React Refresh plugin in Next.js using the experimental SWC plugins feature.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  experimental: {\n    swcPlugins: [['@swc-jotai/react-refresh', {}]],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing TanStack Query and jotai-tanstack-query Usage\nDESCRIPTION: Demonstrates how to incrementally adopt jotai-tanstack-query alongside existing TanStack Query hooks. Shows the same query implemented with both the standard useQuery hook and with atomWithQuery.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n// existing useQueryHook\nconst { data, isPending, isError } = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n\n// jotai-tanstack-query\nconst todosAtom = atomWithQuery(() => ({\n  queryKey: ['todos'],\n}))\n\nconst [{ data, isPending, isError }] = useAtom(todosAtom)\n```\n\n----------------------------------------\n\nTITLE: Using Flexible Atom Write Functions in Jotai v2\nDESCRIPTION: Shows the enhanced write function in Jotai v2 that can accept multiple arguments and return values, offering more flexibility in atom state management.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\natom(\n  (get) => get(...),\n  (get, set, arg1, arg2, ...) => {\n    ...\n    return someValue\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Restarting a Machine in Provider-less Mode\nDESCRIPTION: Example showing how to restart an XState machine that has reached its final state when initialized in a global store (provider-less mode).\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/xstate.mdx#2025-04-12_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { RESTART } from 'jotai-xstate'\n\nconst YourComponent = () => {\n  const [current, send] = useAtom(yourMachineAtom)\n\n  const isFinalState = current.matches('myFinalState')\n\n  useEffect(() => {\n    // restart globally initialized machine on component unmount\n    return () => {\n      if (isFinalState) send(RESTART)\n    }\n  }, [isFinalState])\n}\n```\n\n----------------------------------------\n\nTITLE: URQL Client Setup with Jotai Provider\nDESCRIPTION: Example showing how to set up URQL client with Jotai provider and atom hydration\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/urql.mdx#2025-04-12_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Suspense } from 'react'\nimport { Provider } from 'jotai/react'\nimport { useHydrateAtoms } from 'jotai/react/utils'\nimport { clientAtom } from 'jotai-urql'\n\nimport {\n  createClient,\n  cacheExchange,\n  fetchExchange,\n  Provider as UrqlProvider,\n} from 'urql'\n\nconst urqlClient = createClient({\n  url: 'https://countries.trevorblades.com/',\n  exchanges: [cacheExchange, fetchExchange],\n  fetchOptions: () => {\n    return { headers: {} }\n  },\n})\n\nconst HydrateAtoms = ({ children }) => {\n  useHydrateAtoms([[clientAtom, urqlClient]])\n  return children\n}\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <UrqlProvider value={urqlClient}>\n      <Provider>\n        <HydrateAtoms>\n          <Suspense fallback=\"Loading...\">\n            <Component {...pageProps} />\n          </Suspense>\n        </HydrateAtoms>\n      </Provider>\n    </UrqlProvider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Dependent Bunjas with Different Lifetimes\nDESCRIPTION: Demonstrates how to create bunjas with broader and narrower lifetimes. Shows a page bunja with child and modal bunjas that depend on it, ensuring proper state lifetime management.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/bunja.mdx#2025-04-12_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst pageBunja = bunja([], () => {\n  const pageStateAtom = atom({})\n  return { pageStateAtom }\n})\n\nconst childBunja = bunja([pageBunja], ({ pageStateAtom }) => {\n  const childStateAtom = atom((get) => ({\n    ...get(pageStateAtom),\n    child: 'state',\n  }))\n  return { childStateAtom }\n})\n\nconst modalBunja = bunja([pageBunja], ({ pageStateAtom }) => {\n  const modalStateAtom = atom((get) => ({\n    ...get(pageStateAtom),\n    modal: 'state',\n  }))\n  return { modalStateAtom }\n})\n\nfunction Page() {\n  const [modalOpen, setModalOpen] = useState(false)\n  return (\n    <>\n      <Child />\n      {modalOpen && <Modal />}\n    </>\n  )\n}\n\nfunction Child() {\n  const { childStateAtom } = useBunja(childBunja)\n  const childState = useAtomValue(childStateAtom)\n  // ...\n}\n\nfunction Modal() {\n  const { modalStateAtom } = useBunja(modalBunja)\n  const modalState = useAtomValue(modalStateAtom)\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Applying atomWithCompare in a React Component\nDESCRIPTION: A React component example showing how to use the styleAtom created with atomWithCompare. Demonstrates how clicking buttons multiple times only triggers one render due to the equality comparison.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/atom-with-compare.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nconst StylePreview = () => {\n  const [styles, setStyles] = useAtom(styleAtom)\n\n  return (\n    <div>\n      <div styles={styles}>Style preview</div>\n\n      {/* Clicking this button twice will only trigger one render */}\n      <button onClick={() => setStyles({ ...styles, backgroundColor: 'red' })}>\n        Set background to red\n      </button>\n\n      {/* Clicking this button twice will only trigger one render */}\n      <button onClick={() => setStyles({ ...styles, fontSize: 32 })}>\n        Enlarge font\n      </button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies Directly into a Scope\nDESCRIPTION: Shows how to inject values directly into a scope without using context providers, which is useful when values are created within the component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/bunja.mdx#2025-04-12_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { inject } from 'bunja/react'\n\nfunction MyComponent() {\n  const { queryAtom } = useBunja(\n    fetchBunja,\n    inject([[UrlScope, 'https://example.com/']]),\n  )\n  const { data, isPending, isError } = useAtomValue(queryAtom)\n  // Your component logic here\n}\n```\n\n----------------------------------------\n\nTITLE: Dependency Injection Using Scope\nDESCRIPTION: Creates a scope-based bunja for local state management. The fetchBunja depends on a URL scope and creates a query atom that fetches data from the injected URL.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/bunja.mdx#2025-04-12_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bunja, createScope } from 'bunja'\n\nconst UrlScope = createScope()\n\nconst fetchBunja = bunja([UrlScope], (url) => {\n  const queryAtom = atomWithQuery((get) => ({\n    queryKey: [url],\n    queryFn: async () => (await fetch(url)).json(),\n  }))\n  return { queryAtom }\n})\n```\n\n----------------------------------------\n\nTITLE: Initializing Complex Data Structure in JavaScript\nDESCRIPTION: Example of a nested data structure containing information about people, films, and metadata that will be managed using Jotai atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/recipes/large-objects.mdx#2025-04-12_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst initialData = {\n  people: [\n    {\n      name: 'Luke Skywalker',\n      information: { height: 172 },\n      siblings: ['John Skywalker', 'Doe Skywalker'],\n    },\n    {\n      name: 'C-3PO',\n      information: { height: 167 },\n      siblings: ['John Doe', 'Doe John'],\n    },\n  ],\n  films: [\n    {\n      title: 'A New Hope',\n      planets: ['Tatooine', 'Alderaan'],\n    },\n    {\n      title: 'The Empire Strikes Back',\n      planets: ['Hoth'],\n    },\n  ],\n  info: {\n    tags: ['People', 'Films', 'Planets', 'Titles'],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating splitAtom Util with Async Atoms in Jotai v2\nDESCRIPTION: Shows how to handle splitAtom utility with async atoms in v2, using the unwrap helper to convert async atoms to sync atoms before passing to utilities that don't support async values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Previous API\nconst splittedAtom = splitAtom(asyncArrayAtom)\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// New API\nconst splittedAtom = splitAtom(unwrap(asyncArrayAtom, () => []))\n```\n\n----------------------------------------\n\nTITLE: Creating a Scope from Context\nDESCRIPTION: Simplifies the process of creating a scope and binding it to a context using the createScopeFromContext utility function.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/bunja.mdx#2025-04-12_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createContext } from 'react'\nimport { createScopeFromContext } from 'bunja/react'\n\nconst UrlContext = createContext('https://example.com/')\nconst UrlScope = createScopeFromContext(UrlContext)\n```\n\n----------------------------------------\n\nTITLE: Migration Changes for v0.8.0\nDESCRIPTION: Code diff showing the required changes when migrating to jotai-tanstack-query v0.8.0, including atom signature changes and simplified return structures.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\n- const [dataAtom, statusAtom] = atomsWithSomething(getOptions, getQueryClient)\n+ const dataAtom = atomWithSomething(getOptions, getQueryClient)\n```\n\nLANGUAGE: diff\nCODE:\n```\n- const [dataAtom, statusAtom] = atomsWithQuery(/* ... */);\n- const [data] = useAtom(dataAtom);\n- const [status] = useAtom(statusAtom);\n\n+ const dataAtom = atomWithQuery(/* ... */);\n+ const [{ data, isPending, isError }] = useAtom(dataAtom);\n```\n\nLANGUAGE: diff\nCODE:\n```\n- const [, postAtom] = atomsWithMutation(/* ... */);\n- const [post, mutate] = useAtom(postAtom);\n\n+ const postAtom = atomWithMutation(/* ... */);\n+ const [{ data, error, mutate }] = useAtom(postAtom);\n```\n\n----------------------------------------\n\nTITLE: AtomWithLocation API Signature\nDESCRIPTION: Function signature for creating an atom linked to window.location.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/location.mdx#2025-04-12_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\natomWithLocation(options): PrimitiveAtom\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js for Jotai DevTools\nDESCRIPTION: This Next.js configuration enables transpilePackages for jotai-devtools, which is necessary for the UI CSS and components to be transpiled correctly in a Next.js project.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst nextConfig = {\n  transpilePackages: ['jotai-devtools'],\n}\nmodule.exports = nextConfig\n```\n\n----------------------------------------\n\nTITLE: RESET Symbol Type Definition\nDESCRIPTION: TypeScript definition for the RESET symbol used to reset atoms to their initial values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst RESET: unique symbol\n```\n\n----------------------------------------\n\nTITLE: Helper Hook for Query Data Handling\nDESCRIPTION: Implementation of useQueryAtomData helper hook for handling query results and error states\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/urql.mdx#2025-04-12_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AnyVariables, OperationResult } from '@urql/core'\nimport { useAtom } from 'jotai'\nimport type { AtomWithQuery } from 'jotai-urql'\n\nexport const useQueryAtomData = <\n  Data = unknown,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  queryAtom: AtomWithQuery<Data, Variables>,\n) => {\n  const [opResult, dispatch] = useAtom(queryAtom)\n\n  if (opResult.error && opResult.stale) {\n    use(\n      new Promise((resolve) => {\n        setTimeout(resolve, 10000)\n      }),\n    )\n  }\n\n  if (opResult.error) {\n    throw opResult.error\n  }\n\n  if (!opResult.data) {\n    throw Error(\n      'Query data is undefined. Probably you paused the query? In that case use `useQueryAtom` instead.',\n    )\n  }\n  return [opResult.data, dispatch, opResult] as [\n    Exclude<typeof opResult.data, undefined>,\n    typeof dispatch,\n    typeof opResult,\n  ]\n}\n\nfunction use(promise: Promise<any> | any) {\n  if (promise.status === 'fulfilled') {\n    return promise.value\n  }\n  if (promise.status === 'rejected') {\n    throw promise.reason\n  } else if (promise.status === 'pending') {\n    throw promise\n  } else {\n    promise.status = 'pending'\n    ;(promise as Promise<any>).then(\n      (result: any) => {\n        promise.status = 'fulfilled'\n        promise.value = result\n      },\n      (reason: any) => {\n        promise.status = 'rejected'\n        promise.reason = reason\n      },\n    )\n    throw promise\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a dual-natured atom with atomWithQuery\nDESCRIPTION: Example showing how to create a dual-natured atom that can return either a User object or a Promise of a User object.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/derive.mdx#2025-04-12_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// `jotai-derive` is applicable to most data-fetching solutions, not just `jotai-apollo`\nimport { atomWithQuery } from 'jotai-apollo';\n\n// An example of a dual-natured atom\nconst userAtom: Atom<User | Promise<User>> =\n  atomWithQuery(...);\n```\n\n----------------------------------------\n\nTITLE: Creating a Next.js Project with Jotai using create-next-app\nDESCRIPTION: This bash command shows how to create a new Next.js project with Jotai integration using the create-next-app command-line tool. It uses a pre-configured example from the Next.js repository.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/nextjs.mdx#2025-04-12_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example with-jotai with-jotai-app\n```\n\n----------------------------------------\n\nTITLE: AtomWithHash API Signature\nDESCRIPTION: Function signature for creating an atom linked to URL hash state.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/location.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\natomWithHash(key, initialValue, options): PrimitiveAtom\n```\n\n----------------------------------------\n\nTITLE: Configuring React Refresh Plugin with Custom Atom Names\nDESCRIPTION: Extended configuration for the React Refresh plugin that includes custom atom function names.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\n    [\"jotai/babel/plugin-react-refresh\", { \"customAtomNames\": [\"customAtom\"] }]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring @swc-jotai/debug-label in Next.js\nDESCRIPTION: JavaScript configuration for enabling the debug-label plugin in Next.js using the experimental SWC plugins feature.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  experimental: {\n    swcPlugins: [['@swc-jotai/debug-label', {}]],\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Babel for Jotai DevTools in package.json\nDESCRIPTION: This configuration sets up Babel presets for Jotai, including plugins for React refresh and debug labels, which are recommended for an optimal debugging experience.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/devtools.mdx#2025-04-12_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"presets\": [\n    \"jotai/babel/preset\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies via React Context\nDESCRIPTION: Example showing how to bind a scope to a React context. Different context values create separate bunja instances, even when they reference the same bunja definition.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/bunja.mdx#2025-04-12_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createContext } from 'react'\nimport { bunja, createScope } from 'bunja'\nimport { bindScope } from 'bunja/react'\n\nconst UrlContext = createContext('https://example.com/')\nconst UrlScope = createScope()\nbindScope(UrlScope, UrlContext)\n\nconst fetchBunja = bunja([UrlScope], (url) => {\n  const queryAtom = atomWithQuery((get) => ({\n    queryKey: [url],\n    queryFn: async () => (await fetch(url)).json(),\n  }))\n  return { queryAtom }\n})\n\nfunction ParentComponent() {\n  return (\n    <>\n      <UrlContext value=\"https://example.com/foo\">\n        <ChildComponent />\n      </UrlContext>\n      <UrlContext value=\"https://example.com/bar\">\n        <ChildComponent />\n      </UrlContext>\n    </>\n  )\n}\n\nfunction ChildComponent() {\n  const { queryAtom } = useBunja(fetchBunja)\n  const { data, isPending, isError } = useAtomValue(queryAtom)\n  // Your component logic here\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Redux and Jotai-Redux Dependencies\nDESCRIPTION: Command for installing the required dependencies to use Redux with Jotai. This installs both the redux core library and the jotai-redux integration package.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/redux.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install redux jotai-redux\n```\n\n----------------------------------------\n\nTITLE: Installing @swc-jotai/react-refresh Plugin\nDESCRIPTION: Command to install the React Refresh plugin for Jotai atoms via npm. This plugin prevents state reset during development with React Refresh.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install --save-dev @swc-jotai/react-refresh\n```\n\n----------------------------------------\n\nTITLE: Original Atom Definition Before @swc-jotai/debug-label\nDESCRIPTION: Example JavaScript code showing an atom definition before transformation by the debug-label plugin.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nexport const countAtom = atom(0)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Usage with ES5 Target\nDESCRIPTION: Shows how to use useHydrateAtoms with TypeScript when targeting ES5, using 'as const' to preserve tuple types. This is important for proper type inference in older JavaScript environments.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/ssr.mdx#2025-04-12_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nuseHydrateAtoms([\n  [countAtom, 42],\n  [frameworkAtom, 'Next.js'],\n] as const)\n```\n\n----------------------------------------\n\nTITLE: Using canUndo and canRedo indicators in JSX\nDESCRIPTION: Shows how to use the canUndo and canRedo indicators to conditionally disable undo and redo buttons in a React component.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/history.mdx#2025-04-12_snippet_4\n\nLANGUAGE: jsx\nCODE:\n```\n...\n\nfunction Component() {\n  const history = useAtomValue(historyAtom)\n\n  return (\n    <>\n      <button disabled={!history.canUndo}>Undo</button>\n      <button disabled={!history.canRedo}>Redo</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: useResetAtom Hook Type Definition\nDESCRIPTION: TypeScript type definition for the useResetAtom hook used to reset atoms to their initial values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/utilities/resettable.mdx#2025-04-12_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useResetAtom<Value>(\n  anAtom: WritableAtom<Value, typeof RESET>,\n): () => void | Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Caution example when mutating proxies in atoms\nDESCRIPTION: Example demonstrating what not to do when working with proxies in atom read functions, as direct mutations during rendering can cause infinite loops.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/valtio.mdx#2025-04-12_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst countProxyAtom = mutableAtom(0)\n\natom(\n  (get) => {\n    const countProxy = get(countProxyAtom)\n    ++countProxy.value // This will cause an infinite loop\n  },\n  (get, set) => {\n    const countProxy = get(countProxyAtom)\n    ++countProxy.value // This is fine\n  },\n)\n```\n\n----------------------------------------\n\nTITLE: Installing @swc-jotai/debug-label Plugin\nDESCRIPTION: Command to install the debug-label plugin for Jotai atoms via npm. This plugin automatically adds debug labels to atoms for identification.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nnpm install --save-dev @swc-jotai/debug-label\n```\n\n----------------------------------------\n\nTITLE: Default Export Atom Before Transformation\nDESCRIPTION: Example JavaScript code showing a default exported atom before transformation by the debug-label plugin.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_5\n\nLANGUAGE: js\nCODE:\n```\n// countAtom.ts\nexport default atom(0)\n```\n\n----------------------------------------\n\nTITLE: Using Conventional Commit Format for Feature Addition\nDESCRIPTION: Example of a conventional commit message format for adding a new feature, starting with the 'feat' type followed by a colon and a space, then a lowercase message.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/CONTRIBUTING.md#2025-04-12_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nfeat: add a 'foo' type support\n```\n\n----------------------------------------\n\nTITLE: Installing bunshi Package\nDESCRIPTION: Command to install the bunshi package (formerly jotai-molecules) via npm, which provides a solution for creating atoms that can depend on props and state within component trees.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/scope.mdx#2025-04-12_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install bunshi\n```\n\n----------------------------------------\n\nTITLE: Migrating abortableAtom Util in Jotai v2\nDESCRIPTION: Shows how the special abortableAtom utility is no longer needed as the abort signal functionality is now supported directly in regular atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/migrating-to-v2-api.mdx#2025-04-12_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// Previous API\nconst asyncAtom = abortableAtom(async (get, { signal }) => {\n ...\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// New API\nconst asyncAtom = atom(async (get, { signal }) => {\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing URQL Extension Dependencies\nDESCRIPTION: Command to install required dependencies for using jotai-urql extension\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/urql.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-urql @urql/core wonka\n```\n\n----------------------------------------\n\nTITLE: Creating a derived atom without jotai-derive\nDESCRIPTION: Traditional approach to creating a derived atom that always awaits the base atom, introducing unnecessary deferring even when values are immediately available.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/derive.mdx#2025-04-12_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Without `jotai-derive`\n\nimport { atom } from 'jotai'\n\n// Type is Atom<Promise<string>>, even though\n// get(userAtom) does not always return a promise,\n// meaning we could compute `uppercaseNameAtom`\n// synchronously.\nconst uppercaseNameAtom = atom(async (get) => {\n  const user = await get(userAtom)\n  return user.name.toUppercase()\n})\n```\n\n----------------------------------------\n\nTITLE: Debug Label Plugin Example Input\nDESCRIPTION: Example of code before the debug label plugin transformation.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const countAtom = atom(0)\n```\n\n----------------------------------------\n\nTITLE: Inserting Table of Contents in Markdown\nDESCRIPTION: This code snippet demonstrates how to insert a table of contents component in Markdown. It's used multiple times in the document to organize different sections of the Jotai documentation.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/index.mdx#2025-04-12_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n<TOC section=\"core\" />\n```\n\n----------------------------------------\n\nTITLE: Installing Zustand Integration Dependencies\nDESCRIPTION: Command to install the required packages zustand and jotai-zustand for enabling Zustand integration with Jotai.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/zustand.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install zustand jotai-zustand\n```\n\n----------------------------------------\n\nTITLE: Transformed Atom With debug-label Plugin\nDESCRIPTION: Example JavaScript code showing how the debug-label plugin adds a debugLabel property to an atom based on its identifier.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nexport const countAtom = atom(0)\ncountAtom.debugLabel = 'countAtom'\n```\n\n----------------------------------------\n\nTITLE: Installing Jotai Relay Dependencies\nDESCRIPTION: Commands to install the required packages jotai-relay and relay-runtime via npm\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/relay.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-relay relay-runtime\n```\n\n----------------------------------------\n\nTITLE: Installing Valtio and Jotai-Valtio packages\nDESCRIPTION: Command to install the required packages for using Valtio extension with Jotai.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/valtio.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install valtio jotai-valtio\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Label Plugin in Babel\nDESCRIPTION: Basic configuration for the debug label plugin that automatically adds debug labels to atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"jotai/babel/plugin-debug-label\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Jotai Todos Locally\nDESCRIPTION: Terminal commands for cloning the Jotai repository, installing dependencies, and starting the development server for the todos example application. This includes setting up both the main library and the example project.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/examples/todos/README.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/jotai\n\n# install project dependencies & build the library\ncd jotai && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/todos && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing jotai-trpc Extension\nDESCRIPTION: Install the required dependencies to use Jotai with tRPC, including jotai-trpc, @trpc/client, and @trpc/server packages.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/trpc.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-trpc @trpc/client @trpc/server\n```\n\n----------------------------------------\n\nTITLE: Default Export Atom After debug-label Transformation\nDESCRIPTION: Example JavaScript code showing how the debug-label plugin transforms a default exported atom by adding a debugLabel property.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_6\n\nLANGUAGE: js\nCODE:\n```\n// countAtom.ts\nconst countAtom = atom(0)\ncountAtom.debugLabel = 'countAtom'\nexport default countAtom\n```\n\n----------------------------------------\n\nTITLE: Configuring React Refresh Plugin in Babel\nDESCRIPTION: Basic configuration for the React Refresh plugin that prevents state reset during development with React Refresh.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"jotai/babel/plugin-react-refresh\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Conventional Commit Format with Scope\nDESCRIPTION: Example of a conventional commit message format that includes a scope in parentheses, specifying which part of the codebase the commit affects.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/CONTRIBUTING.md#2025-04-12_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nfix(react): change the 'bar' parameter type\n```\n\n----------------------------------------\n\nTITLE: Configuring Debug Label Plugin with Custom Atom Names\nDESCRIPTION: Extended configuration for the debug label plugin that includes custom atom function names.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\n    [\"jotai/babel/plugin-debug-label\", { \"customAtomNames\": [\"customAtom\"] }]\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Bunja\nDESCRIPTION: Command to install the Bunja package via npm.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/bunja.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install bunja\n```\n\n----------------------------------------\n\nTITLE: Installing Jotai Location Package\nDESCRIPTION: Command to install the jotai-location package using npm.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/location.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-location\n```\n\n----------------------------------------\n\nTITLE: Configuring Jotai Babel Preset with Custom Atom Names\nDESCRIPTION: Extended configuration for the Jotai Babel preset that includes custom atom function names.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"presets\": [[\"jotai/babel/preset\", { \"customAtomNames\": [\"customAtom\"] }]]\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Hacker News Example with Jotai (Bash)\nDESCRIPTION: These commands clone the Jotai repository, install dependencies, and start the development server for the Hacker News example. It demonstrates the setup process for running the project locally.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/examples/hacker_news/README.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/jotai\n\n# install project dependencies & build the library\ncd jotai && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/hacker_news && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Setting up Jotai Starter Project Locally using Bash\nDESCRIPTION: This snippet shows the command-line instructions for cloning the Jotai repository, installing dependencies, and starting the development server for the starter project. It uses pnpm as the package manager.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/examples/starter/README.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/jotai\n\n# install project dependencies & build the library\ncd jotai && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/starter && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Jotai Babel Preset\nDESCRIPTION: Basic configuration for using the Jotai Babel preset that includes all Jotai-specific plugins.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"presets\": [\"jotai/babel/preset\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring @swc-jotai/debug-label in .swcrc\nDESCRIPTION: JSON configuration for adding the debug-label plugin to .swcrc file. This enables the plugin in the SWC compiler.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsc\": {\n    \"experimental\": {\n      \"plugins\": [[\"@swc-jotai/debug-label\", {}]]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Jotai Mega Form Example\nDESCRIPTION: Command sequence for cloning the Jotai repository, installing dependencies, and starting the mega form example development server. This includes setting up both the main Jotai library and the specific example project.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/examples/mega-form/README.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/jotai\n\n# install project dependencies & build the library\ncd jotai && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/mega-form && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing jotai-tanstack-query Dependencies\nDESCRIPTION: Command to install the required packages for using jotai-tanstack-query extension. This installs both the extension library and the core TanStack Query package.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/query.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-tanstack-query @tanstack/query-core\n```\n\n----------------------------------------\n\nTITLE: Debug Label Plugin Example Output\nDESCRIPTION: Example of code after the debug label plugin transformation, showing the added debugLabel property.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/babel.mdx#2025-04-12_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const countAtom = atom(0)\ncountAtom.debugLabel = 'countAtom'\n```\n\n----------------------------------------\n\nTITLE: Installing Jotai Optics Dependencies\nDESCRIPTION: Command to install the required packages optics-ts and jotai-optics via npm\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/optics.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install optics-ts jotai-optics\n```\n\n----------------------------------------\n\nTITLE: Installing jotai-cache Package\nDESCRIPTION: Command to install the jotai-cache package using npm, which is a third-party library that adds caching capabilities to Jotai atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/cache.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-cache\n```\n\n----------------------------------------\n\nTITLE: Configuring @swc-jotai/react-refresh in .swcrc\nDESCRIPTION: JSON configuration for adding the React Refresh plugin to .swcrc file. This enables the plugin in the SWC compiler.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/tools/swc.mdx#2025-04-12_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"jsc\": {\n    \"experimental\": {\n      \"plugins\": [[\"@swc-jotai/react-refresh\", {}]]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing jotai-derive package\nDESCRIPTION: Command to install the jotai-derive package which provides primitives for handling dual-natured atoms.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/derive.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-derive\n```\n\n----------------------------------------\n\nTITLE: Installing Jotai Immer Dependencies\nDESCRIPTION: Commands to install the required packages immer and jotai-immer\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/immer.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install immer jotai-immer\n```\n\n----------------------------------------\n\nTITLE: Setting up Jotai Todo List Example Locally\nDESCRIPTION: This bash script outlines the steps to clone the Jotai repository, install dependencies, and run the todos_with_atomFamily example locally. It includes cloning the repo, installing project dependencies, building the library, and starting the development server.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/examples/todos_with_atomFamily/README.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/jotai\n\n# install project dependencies & build the library\ncd jotai && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/todos_with_atomFamily && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing jotai-history package\nDESCRIPTION: Command to install the jotai-history package using npm.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/third-party/history.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-history\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Jotai Hello Example\nDESCRIPTION: Step-by-step commands to clone the Jotai repository, install dependencies, and start the Hello example development server. Includes project setup and navigation instructions.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/examples/hello/README.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/jotai\n\n# install project dependencies & build the library\ncd jotai && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/hello && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Setting up Jotai Text Length Example Locally\nDESCRIPTION: This bash script clones the Jotai repository, installs dependencies, and starts the development server for the text length example. It assumes you have git and pnpm installed.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/examples/text_length/README.md#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/pmndrs/jotai\n\n# install project dependencies & build the library\ncd jotai && pnpm install\n\n# move to the examples folder & install dependencies\ncd examples/text_length && pnpm install\n\n# start the dev server\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing jotai-effect Package\nDESCRIPTION: Command to install the jotai-effect package via npm, which provides utilities for handling reactive side effects in Jotai.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/effect.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install jotai-effect\n```\n\n----------------------------------------\n\nTITLE: Installing XState and Jotai-XState\nDESCRIPTION: Command to install the required dependencies for using XState with Jotai.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/xstate.mdx#2025-04-12_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install xstate jotai-xstate\n```\n\n----------------------------------------\n\nTITLE: React Component with Jotai Optics Integration\nDESCRIPTION: Example React component showing how to use focusAtom with multiple properties and update handlers\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/extensions/optics.mdx#2025-04-12_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport { atom } from 'jotai'\nimport { focusAtom } from 'jotai-optics'\n\nconst objectAtom = atom({ a: 5, b: 10 })\nconst aAtom = focusAtom(objectAtom, (optic) => optic.prop('a'))\nconst bAtom = focusAtom(objectAtom, (optic) => optic.prop('b'))\n\nconst Controls = () => {\n  const [a, setA] = useAtom(aAtom)\n  const [b, setB] = useAtom(bAtom)\n  return (\n    <div>\n      <span>Value of a: {a}</span>\n      <span>Value of b: {b}</span>\n      <button onClick={() => setA((oldA) => oldA + 1)}>Increment a</button>\n      <button onClick={() => setB((oldB) => oldB + 1)}>Increment b</button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Value Types from Atoms in Jotai\nDESCRIPTION: Example of using the ExtractAtomValue utility type to access the value type of an atom for use in other parts of your application, such as when integrating with external libraries.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/guides/typescript.mdx#2025-04-12_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ExtractAtomValue, useAtomValue } from 'jotai'\nimport { userAtom } from 'state'\nimport { useQuery } from '@tanstack/react-query'\n\nexport default function WriteReview(hid) {\n  const user = useAtomValue(userAtom)\n  const res = useGetReviewQuery(user)\n}\n\nfunction useGetReviewQuery(user: ExtractAtomValue<typeof userAtom>) {\n  return fetch('/api/user/' + user.id + '/review')\n}\n```\n\n----------------------------------------\n\nTITLE: Legacy Callback Pattern for Handling Multiple Async Operations\nDESCRIPTION: This snippet demonstrates an older pattern for handling multiple asynchronous operations using callbacks. It shows the manual tracking of completion state that was common before Promise combinators.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/docs/basics/functional-programming-and-jotai.mdx#2025-04-12_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst nPending = 4\nconst results: string[]\nfunction callback(err, data) {\n  if (err) throw err\n  results.push(data)\n  if (results.length === nPending) {\n    // do something with results...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Web Crawler Access Using robots.txt\nDESCRIPTION: Standard robots.txt configuration that allows full access to all web crawlers and specifies the XML sitemap location. This helps search engines properly index the Jotai documentation website.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/website/public/robots.txt#2025-04-12_snippet_0\n\nLANGUAGE: robots.txt\nCODE:\n```\nUser-agent: *\nAllow: /\nSitemap: https://jotai.org/sitemap/sitemap-index.xml\n```\n\n----------------------------------------\n\nTITLE: Configuring Robot.txt for Jotai Website\nDESCRIPTION: This snippet defines the robot.txt configuration for the Jotai website. It allows all web crawlers to access any path on the site and specifies the location of the XML sitemap for improved indexing.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/website/static/robots.txt#2025-04-12_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nUser-agent: *\nAllow: /\nSitemap: https://jotai.org/sitemap/sitemap-index.xml\n```\n\n----------------------------------------\n\nTITLE: Creating Write-Only Derived Atoms\nDESCRIPTION: Demonstrates how to create atoms that only handle write operations without reading values.\nSOURCE: https://github.com/pmndrs/jotai/blob/main/README.md#2025-04-12_snippet_6\n\nLANGUAGE: jsx\nCODE:\n```\nconst multiplyCountAtom = atom(null, (get, set, by) =>\n  set(countAtom, get(countAtom) * by),\n)\n```"
  }
]