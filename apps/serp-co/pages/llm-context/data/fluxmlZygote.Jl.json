[
  {
    "owner": "fluxml",
    "repo": "zygote.jl",
    "content": "TITLE: Basic Differentiation and LLVM Inspection with Zygote.jl in Julia\nDESCRIPTION: Demonstrates basic automatic differentiation using Zygote.jl in the Julia REPL. It defines a simple linear function `f(x)`, computes its value and derivative at `x=10` using the `f'(x)` syntax provided by Zygote, and inspects the generated LLVM code for the derivative function to show the result of source-to-source differentiation. Requires the Zygote package.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/README.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Zygote\n\njulia> f(x) = 5x + 3\n\njulia> f(10), f'(10)\n(53, 5.0)\n\njulia> @code_llvm f'(10)\ndefine i64 @\"julia_#625_38792\"(i64) {\ntop:\n  ret i64 5\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of a Simple Polynomial in Julia with Zygote\nDESCRIPTION: This snippet demonstrates calculating the gradient of the function `f(x) = 3x^2 + 2x + 1` with respect to `x` at the point `x = 5` using Zygote's `gradient` function. The expected result is `(32.0,)`, returned as a tuple containing the gradient for each input variable.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\nindex\njulia> using Zygote\n\njulia> gradient(x -> 3x^2 + 2x + 1, 5)\n(32.0,)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of a Multi-Argument Function in Julia with Zygote\nDESCRIPTION: This snippet shows how Zygote's `gradient` function computes gradients for functions with multiple arguments. It calculates the gradient of `f(a, b) = a*b` at the point `(a=2, b=3)`. The result `(3.0, 2.0)` is a tuple containing the partial derivatives ∂f/∂a and ∂f/∂b respectively.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\nindex\njulia> gradient((a, b) -> a*b, 2, 3)\n(3.0, 2.0)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of Function with Loop Control Flow in Julia with Zygote\nDESCRIPTION: This snippet defines a function `pow(x, n)` that calculates `x` raised to the power `n` using a `for` loop. It then demonstrates that Zygote can differentiate through this imperative control flow by calculating the gradient of `x^3` at `x=5`, resulting in `(75.0,)`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\nindex\njulia> function pow(x, n)\n         r = 1\n         for i = 1:n\n           r *= x\n         end\n         return r\n       end\npow (generic function with 1 method)\n\njulia> gradient(x -> pow(x, 3), 5)\n(75.0,)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of Recursive Function in Julia with Zygote\nDESCRIPTION: This snippet defines a recursive function `pow2(x, n)` that calculates `x` raised to the power `n`. It then shows Zygote's ability to differentiate through recursion by computing the gradient of `x^3` at `x=5`, correctly yielding `(75.0,)`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_5\n\nLANGUAGE: jldoctest\nCODE:\n```\nindex\njulia> pow2(x, n) = n <= 0 ? 1 : x*pow2(x, n-1)\npow2 (generic function with 1 method)\n\njulia> gradient(x -> pow2(x, 3), 5)\n(75.0,)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of Function from External Library (Colors.jl) in Julia with Zygote\nDESCRIPTION: This snippet shows that Zygote can differentiate through functions defined in external Julia libraries, even if they weren't explicitly designed for automatic differentiation. It uses the `Colors.jl` package to calculate the `colordiff` between two RGB colors and then computes the gradient of this difference function with respect to both input colors.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Colors\n\njulia> colordiff(RGB(1, 0, 0), RGB(0, 1, 0))\n86.60823557376344\n\njulia> gradient(colordiff, RGB(1, 0, 0), RGB(0, 1, 0))\n((r = 0.4590887719632896, g = -9.598786801605689, b = 14.181383399012862), (r = -1.7697549557037275, g = 28.88472330558805, b = -0.044793892637761346))\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient Involving Mutable Data Structures (Dictionary) in Julia with Zygote\nDESCRIPTION: This snippet demonstrates Zygote's support for differentiating functions that involve mutable data structures like dictionaries. It calculates the gradient of a function defined using a `do` block, which modifies and then uses a value stored in a dictionary `d`. The gradient of `x*x` at `x=5` is correctly computed as `(10.0,)`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_6\n\nLANGUAGE: jldoctest\nCODE:\n```\nindex\njulia> d = Dict()\nDict{Any, Any}()\n\njulia> gradient(5) do x\n         d[:x] = x\n         d[:x] * d[:x]\n       end\n(10.0,)\n\njulia> d[:x]\n5\n```\n\n----------------------------------------\n\nTITLE: Using Zygote.pullback for Gradient Computation in Julia\nDESCRIPTION: Demonstrates the use of Zygote's pullback function to compute the result and obtain a gradient-producing pullback for the sin function at a specific value. Dependencies: Zygote.jl. Inputs: function and arguments; Outputs: function result and pullback closure. This is a fundamental automatic differentiation operation.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Zygote\n\njulia> y, back = Zygote.pullback(sin, 0.5);\n\njulia> y\n0.479425538604203\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient Involving Custom Struct `Point` in Julia with Zygote\nDESCRIPTION: This snippet demonstrates Zygote's ability to differentiate functions operating on custom data types. It creates two `Point` instances, `a` and `b`, calculates the distance of their sum, and then computes the gradient of the distance function `dist(a + b)` with respect to `a`. The resulting gradient is a named tuple `(x = ..., y = ...)` representing the partial derivatives for the fields of `a`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> a = Point(1, 2)\nPoint(1.0, 2.0)\n\njulia> b = Point(3, 4)\nPoint(3.0, 4.0)\n\njulia> dist(a + b)\n7.211102550927978\n\njulia> gradient(a -> dist(a + b), a)[1]\n(x = 0.5547001962252291, y = 0.8320502943378437)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Adjoint Rules with @adjoint in Zygote (Julia)\nDESCRIPTION: Uses the @adjoint macro from Zygote to specify a custom adjoint (pullback) for a user-defined mul function. Requires Zygote's @adjoint. Inputs: a, b scalars; Outputs: value and tuple of gradients. Illustrates the canonical way to attach a custom reverse-mode rule.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> mul(a, b) = a*b;\n\njulia> using Zygote: @adjoint\n\njulia> @adjoint mul(a, b) = mul(a, b), c\\u0304 -> (c\\u0304*b, c\\u0304*a)\n\njulia> gradient(mul, 2, 3)\n(3.0, 2.0)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient with Explicit Parameters (Callable Struct) in Julia with Zygote\nDESCRIPTION: This snippet illustrates another way to handle explicit parameters using a callable struct `Linear`. The struct holds the parameters `W` and `b`, and an instance `model` can be called like a function `model(x)`. The gradient is taken with respect to the `model` instance itself, resulting in a named tuple `dmodel` containing gradients for the fields `W` and `b`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> struct Linear\n         W\n         b\n       end\n\njulia> (l::Linear)(x) = l.W * x .+ l.b\n\njulia> model = Linear(rand(2, 5), rand(2))\nLinear([0.267663 … 0.334385], [0.0386873, 0.0203294])\n\njulia> x = rand(5);\n\njulia> dmodel = gradient(model -> sum(model(x)), model)[1]\n(W = [0.652543 … 0.683588], b = [1.0, 1.0])\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient with Implicit Parameters using `Params` in Julia with Zygote\nDESCRIPTION: This snippet demonstrates the implicit parameter handling style in Zygote. The `linear` function uses global variables `W` and `b`. The `gradient` function is called with a zero-argument anonymous function `() -> sum(linear(x))`, and the parameters to differentiate with respect to (`W` and `b`) are specified separately using `Params([W, b])`. The gradients are accessed from the returned `Grads` object using the original parameter arrays as keys.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> W = rand(2, 5); b = rand(2);\n\njulia> linear(x) = W * x .+ b\nlinear (generic function with 2 methods)\n\njulia> grads = gradient(() -> sum(linear(x)), Params([W, b]))\nGrads(...)\n\njulia> grads[W], grads[b] # access gradients using arrays as keys\n([0.652543 … 0.683588], [1.0, 1.0])\n```\n\n----------------------------------------\n\nTITLE: Manually Defining a Pullback for sin in Julia\nDESCRIPTION: Implements a custom derivative (pullback) for sin, returning sin(x) and a lambda that computes ȳ * cos(x). No external dependencies. Inputs: scalar x; Outputs: tuple of (sin(x), function for gradient computation). This illustrates the vector-Jacobian product concept for custom rules.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\ndsin(x) = (sin(x), y\\u0304 -> (y\\u0304 * cos(x),))\n```\n\n----------------------------------------\n\nTITLE: Custom Types and Default Adjoint Behavior in Zygote (Julia)\nDESCRIPTION: Defines a Point struct and overloads operators and accessors for fields, then demonstrates the use of Zygote.gradient to obtain derivatives with respect to Point fields. No external dependencies beyond Base. Illustrates how Zygote maps gradients to named tuples by default for struct fields.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nimport Base: +, -\n\nstruct Point\n  x::Float64\n  y::Float64\nend\n\nwidth(p::Point) = p.x\nheight(p::Point) = p.y\n\na::Point + b::Point = Point(width(a) + width(b), height(a) + height(b))\na::Point - b::Point = Point(width(a) - width(b), height(a) - height(b))\ndist(p::Point) = sqrt(width(p)^2 + height(p)^2)\n```\n\n----------------------------------------\n\nTITLE: Gradient Hooks: Custom Adjoint to Apply Functions to Gradients (Julia)\nDESCRIPTION: Defines a hook function and attaches an adjoint via @adjoint that allows a custom function f to process the gradient during backprop. Zygote can use this pattern for debugging or modifying gradients (e.g., gradient clipping).\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> hook(f, x) = x\nhook (generic function with 1 method)\n\njulia> @adjoint hook(f, x) = x, x\\u0304 -> (nothing, f(x\\u0304))\n```\n\n----------------------------------------\n\nTITLE: Overloading Field Accessors with Custom Adjoints for Structs (Julia)\nDESCRIPTION: Overloads width and height accessors using @adjoint so their gradients return a Point object with appropriate placement of derivatives. Zygote.refresh() is used to apply new adjoints. Shows how to direct gradient flow into custom types rather than named tuples.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> @adjoint width(p::Point) = p.x, x\\u0304 -> (Point(x\\u0304, 0),)\n\njulia> @adjoint height(p::Point) = p.y, y\\u0304 -> (Point(0, y\\u0304),)\n\njulia> Zygote.refresh() # currently needed when defining new adjoints\n\njulia> gradient(a -> height(a), Point(1, 2))\n(Point(0.0, 1.0),)\n\njulia> gradient(a -> dist(a), Point(1, 2))[1]\nPoint(0.4472135954999579, 0.8944271909999159)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of abs2 for Complex Input using Zygote in Julia\nDESCRIPTION: Demonstrates calculating the gradient of the real-valued function `abs2(c)` with respect to a complex input `1+2im` using Zygote.jl. This treats the complex number as a pair of real numbers, returning the gradient `∂z/∂x + (∂z/∂y)i`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_0\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> using Zygote\n\njulia> gradient(c -> abs2(c), 1+2im)\n(2.0 + 4.0im,)\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Pullback to Compute Gradients in Julia\nDESCRIPTION: Shows a function gradsin that applies the manually defined dsin pullback and evaluates its gradient at x=0.5, and compares it with cos(0.5) for correctness. Demonstrates practical gradient evaluation. No special dependencies.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> function gradsin(x)\n         _, back = dsin(x)\n         back(1)\n       end\ngradsin (generic function with 1 method)\n\njulia> gradsin(0.5)\n(0.8775825618903728,)\n\njulia> cos(0.5)\n0.8775825618903728\n```\n\n----------------------------------------\n\nTITLE: Generic Gradient Calculator with Zygote.pullback in Julia\nDESCRIPTION: Defines mygradient to compute derivatives of arbitrary functions using Zygote.pullback. Requires Zygote. Inputs: function and arguments; Outputs: gradients. Useful for general-purpose reverse-mode AD of scalar functions.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> function mygradient(f, x...)\n         _, back = Zygote.pullback(f, x...)\n         back(1)\n       end\nmygradient (generic function with 1 method)\n\njulia> mygradient(sin, 0.5)\n(0.8775825618903728,)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradients for Implicit Parameters with Zygote.jl in Julia\nDESCRIPTION: Demonstrates how Zygote can compute gradients with respect to variables (`W`, `b`) that are used implicitly within a function (`predict`) but are not passed as arguments. This is achieved using the `gradient(Params(...)) do ... end` syntax, essential for training machine learning models where parameters are often global or stored in structs. Requires the Zygote package.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/README.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> W, b = rand(2, 3), rand(2);\n\njulia> predict(x) = W*x .+ b;\n\njulia> g = gradient(Params([W, b])) do\n         sum(predict([1,2,3]))\n       end\nGrads(...)\n\njulia> g[W], g[b]\n([1.0 2.0 3.0; 1.0 2.0 3.0], [1.0, 1.0])\n```\n\n----------------------------------------\n\nTITLE: Using Hooks for Gradient Debugging and Modification in Julia\nDESCRIPTION: Shows practical usage of hook to inspect or modify gradients, such as printing them or applying functions for debugging. Demonstrates calling hook inside a differentiable function.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> gradient((a, b) -> hook(-, a)*b, 2, 3)\n(-3.0, 2.0)\n\njulia> gradient((a, b) -> hook(a\\u0304 -> @show(a\\u0304), a)*b, 2, 3)\n\\u0101 = 3.0\n(3.0, 2.0)\n```\n\n----------------------------------------\n\nTITLE: Measuring Nesting Levels of Differentiation with Custom Adjoints (Julia)\nDESCRIPTION: Implements nestlevel with a custom adjoint that increments the nesting level counter. Demonstrates how to detect the depth of nested gradient computations, useful for advanced AD diagnostics.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_15\n\nLANGUAGE: julia\nCODE:\n```\nnestlevel() = 0\n\n@adjoint nestlevel() = nestlevel()+1, _ -> nothing\n```\n\n----------------------------------------\n\nTITLE: Demonstration: Nesting Levels in Zygote Gradient Computation (Julia)\nDESCRIPTION: Provides an end-to-end demo function f that prints the current differentiation nesting level, and shows how repeated application of gradient increases this number. Highlights practical use of nestlevel for tracking recursion depth under AD.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_16\n\nLANGUAGE: julia\nCODE:\n```\njulia> function f(x)\n         println(nestlevel(), \" levels of nesting\")\n         return x\n       end\nf (generic function with 1 method)\n\njulia> grad(f, x) = gradient(f, x)[1]\ngrad (generic function with 1 method)\n\njulia> f(1);\n0 levels of nesting\n\njulia> grad(f, 1);\n1 levels of nesting\n\njulia> grad(x -> x*grad(f, x), 1);\n2 levels of nesting\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient with Explicit Parameters (Dictionary) in Julia with Zygote\nDESCRIPTION: This snippet demonstrates the explicit parameter handling style in Zygote. A `linear` function takes parameters `θ` (a dictionary containing weights `:W` and bias `:b`) and input `x` explicitly. The gradient is calculated for the function `θ -> sum(linear(θ, x))` with respect to the parameter dictionary `θ`. The result `θ̄` is a dictionary containing gradients for `:W` and `:b`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\njulia> linear(θ, x) = θ[:W] * x .+ θ[:b]\nlinear (generic function with 1 method)\n\njulia> x = rand(5);\n\njulia> θ = Dict(:W => rand(2, 5), :b => rand(2))\nDict{Any,Any} with 2 entries:\n  :b => [0.0430585, 0.530201]\n  :W => [0.923268 … 0.589691]\n\n# Alternatively, use a named tuple or struct rather than a dict.\n# θ = (W = rand(2, 5), b = rand(2))\n\njulia> θ̄ = gradient(θ -> sum(linear(θ, x)), θ)[1]\nDict{Any,Any} with 2 entries:\n  :b => [1.0, 1.0]\n  :W => [0.628998 … 0.433006]\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Struct `Point` and Associated Methods in Julia\nDESCRIPTION: This snippet defines a custom Julia struct `Point` with `x` and `y` fields of type `Float64`. It also defines methods for addition (`+`), subtraction (`-`), and calculating the Euclidean distance (`dist`) for `Point` objects by extending Base operators and defining a new function.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\nimport Base: +, -\n\nstruct Point\n  x::Float64\n  y::Float64\nend\n\na::Point + b::Point = Point(a.x + b.x, a.y + b.y)\na::Point - b::Point = Point(a.x - b.x, a.y - b.y)\ndist(p::Point) = sqrt(p.x^2 + p.y^2)\n```\n\n----------------------------------------\n\nTITLE: Calculating Holomorphic Derivative via Real Part Gradient in Julia\nDESCRIPTION: Shows how to compute the complex derivative of a holomorphic function (`log(x)`) using Zygote. The derivative is obtained by taking the complex conjugate of the gradient of the real part of the function.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_1\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> gradient(x -> real(log(x)), 1+2im)[1] |> conj\n0.2 - 0.4im\n```\n\n----------------------------------------\n\nTITLE: Verifying Holomorphic Derivative via Imaginary Part Gradient in Julia\nDESCRIPTION: Verifies the result from the previous snippet using the Cauchy-Riemann equations. For a holomorphic function, the derivative can also be calculated as `-im` times the conjugate of the gradient of the imaginary part.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_2\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> -im*gradient(x -> imag(log(x)), 1+2im)[1] |> conj\n0.2 - 0.4im\n```\n\n----------------------------------------\n\nTITLE: Calculating Wirtinger Derivatives for Non-Holomorphic Function in Julia\nDESCRIPTION: Demonstrates the use of the `wirtinger` function (defined previously) to compute the Wirtinger derivatives for the non-holomorphic function `f(x) = abs2(x)` at `x = 1+2im`. Both Wirtinger derivatives are non-zero, confirming non-holomorphicity.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> wirtinger(x -> abs2(x), 1+2im)\n(1.0 - 2.0im, 1.0 + 2.0im)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Operations on Zygote Grads Objects in Julia\nDESCRIPTION: This Julia code demonstrates common operations on Zygote's `Grads` objects, which store gradients keyed by parameters. It shows how to calculate gradients using `gradient` with `Params`, accumulate gradients using addition (`.+`), interact with `IdDict` (important for GPU compatibility), apply functions element-wise using `map` (e.g., gradient clipping), modify gradients in-place using `foreach` (e.g., in-place clipping), and iterate over parameter-gradient pairs using `pairs`. It also includes tests (`@test`) to verify the results and demonstrates error handling (`@test_throws`) when combining gradients with mismatched parameter keys. Dependencies include `Zygote` and `Test`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/utils.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\n```julia\nusing Zygote, Test\n\nw, x1, x2, b = rand(2), rand(2), rand(2), rand(2)\n\ngs1 = gradient(() -> sum(tanh.(w .* x1 .+ b)), Params([w, b]))\ngs2 = gradient(() -> sum(tanh.(w .* x2 .+ b)), Params([w, b]))\n\n# accumulate gradients\ngs = gs1 .+ gs2\n@test gs[w] ≈ gs1[w] + gs2[w]\n@test gs[b] ≈ gs1[b] + gs2[b]\n\n# gradients and IdDict interact nicely\n# note that an IdDict must be used for gradient algebra on the GPU\ngs .+= IdDict(p => randn(size(p)) for p in keys(gs))\n\n# clip gradients\nmap(x -> clamp.(x, -0.1, 0.1), gs)\n\n# clip gradients in-place\nforeach(x -> clamp!(x, -0.1, 0.1), gs)\n\nfor (p, g) in pairs(gs)\n  # do something with parameter `p` and corresponding gradient `g`\nend\n\n# note that gradients must be w.r.t. to the same parameter key set\ngs3 = gradient(() -> sum(tanh.(w .* x2)), Params([w]))\n# gs3 does not have the key b\n@test_throws ArgumentError gs1 .+ gs3\n```\n```\n\n----------------------------------------\n\nTITLE: Checkpointing via Custom Adjoint for Memory Optimization (Julia)\nDESCRIPTION: Implements checkpointing by defining a checkpoint function with a custom adjoint that re-invokes the pullback, trading extra computation for memory savings. Demonstrates use with and without side effects. Requires Zygote._pullback.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_12\n\nLANGUAGE: julia\nCODE:\n```\njulia> checkpoint(f, x) = f(x)\ncheckpoint (generic function with 1 method)\n\njulia> @adjoint checkpoint(f, x) = f(x), y\\u0304 -> Zygote._pullback(f, x)[2](y\\u0304)\n\njulia> gradient(x -> checkpoint(sin, x), 1)\n(0.5403023058681398,)\n```\n\n----------------------------------------\n\nTITLE: Installing Zygote.jl using Julia Package Manager\nDESCRIPTION: This command installs the Zygote.jl package using Julia's built-in package manager Pkg. It should be run in the Julia REPL after entering the Pkg mode by typing `]`.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n] add Zygote\n```\n\n----------------------------------------\n\nTITLE: Differentiating Composite Functions via Pullbacks in Julia\nDESCRIPTION: Implements a composite function 'foo' that chains sin and cos, and a corresponding pullback definition for J(::typeof(foo), x). The pullback closure propagates gradients backward through the composite computation. This demonstrates how Zygote internally handles composition by chaining pullbacks, requiring that constituent functions support differentiation.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction foo(x)\n  a = sin(x)\n  b = cos(a)\n  return b\nend\n```\n\nLANGUAGE: julia\nCODE:\n```\nfunction J(::typeof(foo), x)\n  a, da = J(sin, x)\n  b, db = J(cos, a)\n  return b, function(b̄)\n    ā, = db(b̄)\n    x̄, = da(ā)\n    return x̄\n  end\nend\n\ngradient(foo, 1) # (-0.403,)\n```\n\n----------------------------------------\n\nTITLE: Gradient Computation Using Pullbacks in Julia\nDESCRIPTION: Defines a gradient function that, given a function f and its arguments, computes the derivative assuming the pullback J exists for f. Demonstrates usage on sin and multiplication, returning gradients as tuples. This approach works for simple functions with pre-defined adjoints and expects differentiable arguments; output is the gradient as computed by the corresponding pullback function.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\ngradient(f, x...) = J(f, x...)[2](1)\n\ngradient(sin, 1) # (0.540,)\n\ngradient(*, 2, 3) # (3, 2)\n```\n\n----------------------------------------\n\nTITLE: Computing Gradients for Custom Types with Zygote.gradient (Julia)\nDESCRIPTION: Evaluates the gradient of a function of Point using Zygote.gradient and shows the default output as a named tuple of field derivatives. Demonstrates behavior for structs without custom adjoint overloads.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> gradient(a -> dist(a), Point(1, 2))[1]\n(x = 0.4472135954999579, y = 0.8944271909999159)\n```\n\n----------------------------------------\n\nTITLE: Defining Pullbacks for Simple Functions in Julia\nDESCRIPTION: Implements the J function for three specific cases: sin, cos, and multiplication (*), returning both the result and the backward (pullback) function. This mechanism enables explicit reverse-mode autodiff for these operations by returning closures that compute gradients with respect to the arguments. No special dependencies beyond Julia base. Inputs are numeric types; outputs are tuples of (result, gradient function) for each operation.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nJ(::typeof(sin), x) = sin(x), ȳ -> ȳ*cos(x)\nJ(::typeof(cos), x) = cos(x), ȳ -> -ȳ*sin(x)\nJ(::typeof(*), a, b) = a*b, c̄ -> (b*c̄, a*c̄)\n```\n\n----------------------------------------\n\nTITLE: Low-Level Pullback Interface Example in Zygote (Julia)\nDESCRIPTION: Demonstrates use of Zygote._pullback for reverse-mode AD, returning both primal result and a back-propagation closure. The sample with sin shows expected behavior: invoking back with 1 returns a tuple with 'nothing' (for the function) and the derivative. Prerequisite: Zygote package. Input: differentiable function and argument; output: value and a closure to compute gradients.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> y, back = Zygote._pullback(sin, 0.5);\n\njulia> back(1)\n(nothing, 0.8775825618903728)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Zygote's Generated Code using `@code_typed` and `_pullback` in Julia\nDESCRIPTION: This snippet demonstrates using Julia's `@code_typed` macro with Zygote's internal `_pullback` function to examine the type-inferred code generated for both the forward pass and the resulting pullback (backward pass/adjoint) function. It first defines a simple `add` function, then uses `_pullback` to get the result and the pullback, and finally uses `@code_typed` on both `_pullback` itself (applied to the `add` function) and the returned `back` function to reveal the underlying implementation details. This is useful for debugging Zygote's automatic differentiation process. Requires the Zygote.jl package.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/profiling.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\njulia> using Zygote: Context, _pullback\n\njulia> add(a, b) = a+b\nadd (generic function with 1 method)\n\njulia> @code_typed _pullback(Context(), add, 1, 2)\nCodeInfo(\n1 ─ %1 = (Base.getfield)(args, 1)::Int64\n│   %2 = (Base.getfield)(args, 2)::Int64\n│   %3 = (Base.add_int)(%1, %2)::Int64\n│   %4 = (Base.tuple)(%3, $(QuoteNode(∂(add))))::PartialTuple(Tuple{Int64,typeof(∂(add))}, Any[Int64, Const(∂(add), false)])\n└──      return %4\n) => Tuple{Int64,typeof(∂(add))}\n\njulia> y, back = _pullback(Context(), add, 1, 2)\n(3, ∂(add))\n\njulia> @code_typed back(1)\nCodeInfo(\n1 ─ %1 = (Base.mul_int)(Δ, 1)::Int64\n│   %2 = (Base.mul_int)(Δ, 1)::Int64\n│   %3 = (Zygote.tuple)(nothing, %1, %2)::PartialTuple(Tuple{Nothing,Int64,Int64}, Any[Const(nothing, false), Int64, Int64])\n└──      return %3\n) => Tuple{Nothing,Int64,Int64}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Gradients using ChainRulesCore.jl for Zygote in Julia\nDESCRIPTION: Shows how to define a custom differentiation rule for a user-defined function `add(a, b)` using the `ChainRulesCore.rrule` interface. This allows extending Zygote's differentiation capabilities. The `rrule` function returns the original function's result and a pullback function (`add_pb`) that computes the gradients for the inputs. Requires the ChainRulesCore package.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/README.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\njulia> using ChainRulesCore\n\njulia> add(a, b) = a + b\n\njulia> function ChainRulesCore.rrule(::typeof(add), a, b)\n           add_pb(dy) = (NoTangent(), dy, dy)\n           return add(a, b), add_pb\n       end\n```\n\n----------------------------------------\n\nTITLE: Handling Control Flow in Pullback for Power Function (Julia)\nDESCRIPTION: Shows how to differentiate a loop-based power function (pow) using pullbacks. The J(::typeof(pow), x, n) definition accumulates pullback closures in forward mode and applies them in reverse order in the backward pass, correctly mirroring the original loop. Illustrates how Zygote handles control flow and mutable state for AD; expects numeric inputs, outputs tuple (gradient wrt x, 0) since n is integer and non-differentiable.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\nfunction pow(x, n) # x^n\n  r = 1\n  for _ = 1:n\n    r *= x\n  end\n  return r\nend\n\nfunction J(::typeof(pow), x, n)\n  r = 1\n  Js = []\n  for i = 1:n\n    r, back = J(*, r, x)\n    push!(Js, back)\n  end\n  return r, function(r̄)\n    x̄ = 0\n    for i = n:-1:1\n      r̄, x̄′ = Js[i](r̄)\n      x̄ += x̄′\n    end\n    return (x̄, 0)\n  end\nend\n\ngradient(pow, 2, 3) # (12, 0)\n```\n\n----------------------------------------\n\nTITLE: Handling Closures in Zygote Pullbacks (Julia)\nDESCRIPTION: Shows how Zygote exposes closure variables in the gradient output via _pullback. Creating a closure over 'a' and differentiating a function created with a let block illustrates how captured variables (such as 'a') are included in the output. Requires Zygote loaded. Inputs are closure and value; outputs tuple with gradients for closure variables and function arguments.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njulia> f = let a = 3; x -> x*a; end\n#19 (generic function with 1 method)\n\njulia> y, back = Zygote._pullback(f, 2);\n\njulia> back(1)\n((a = 2,), 3)\n```\n\n----------------------------------------\n\nTITLE: Entry Point Macro Example for Differentiable Functions (Julia)\nDESCRIPTION: Illustrates use of the @differentiable macro to mark a function as eligible for Zygote-based AD. This expands to generate required overloads for the pullback machinery. Intended for use cases where manual annotation is feasible; highlights the limitation of requiring annotation for every function unless automated via generated functions.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\n@differentiable foo(x) = sin(cos(x))\n```\n\n----------------------------------------\n\nTITLE: Differentiating Dynamic Function Calls with Zygote.jl in Julia\nDESCRIPTION: Illustrates Zygote's ability to differentiate through dynamic Julia code, including dictionary lookups and I/O operations (`readline`). It defines a dictionary mapping strings to functions (`sin`, `cos`, `tan`) and computes the gradient of an anonymous function that selects a function from the dictionary based on user input and applies it to `x=1`. Requires the Zygote package.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/README.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> fs = Dict(\"sin\" => sin, \"cos\" => cos, \"tan\" => tan);\n\njulia> gradient(x -> fs[readline()](x), 1)\nsin\n0.5403023058681398\n```\n\n----------------------------------------\n\nTITLE: Inspecting Lowered and SSA IR in Julia and Zygote\nDESCRIPTION: Provides examples of examining the lowered and SSA-form representations of a Julia function using @code_lowered and Zygote.@code_ir macros. This step occurs before automatic differentiation is performed on the internal IR. Useful for debugging and understanding compiler transformations. No dependencies beyond Julia and Zygote.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> foo(x) = baz(bar(x))\nfoo (generic function with 1 method)\n\njulia> @code_lowered foo(1)\nCodeInfo(\n1 ─ %1 = (Main.bar)(x)\n│   %2 = (Main.baz)(%1)\n└──      return %2\n```\n\nLANGUAGE: julia\nCODE:\n```\njulia> Zygote.@code_ir foo(1)\n1 1 ─ %1 = (Main.bar)(_2)::Any\n  │   %2 = (Main.baz)(%1)::Any\n  └──      return %2\n```\n\n----------------------------------------\n\nTITLE: Viewing Adjoint IR with Zygote Adjoint Macro (Julia)\nDESCRIPTION: Uses Zygote.@code_adjoint to show the auto-generated adjoint (pullback) code for a function. Output includes tuple unpacking and handling of closure values using gradindex and Δ constructs. Useful for inspecting the result of Zygote's transformation before lowering to executable IR. Prereq: the Zygote.jl package.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_8\n\nLANGUAGE: julia\nCODE:\n```\njulia> Zygote.@code_adjoint foo(1)\n1 1 ─ %1  = (Zygote._pullback)(_2, Zygote.unwrap, Main.bar)::Any\n  │   %2  = (Base.getindex)(%1, 1)::Any\n  │         (Base.getindex)(%1, 2)::Any\n  │   %4  = (Zygote._pullback)(_2, %2, _4)::Any\n  │   %5  = (Base.getindex)(%4, 1)::Any\n  │         (Base.getindex)(%4, 2)::Any\n  │   %7  = (Zygote._pullback)(_2, Zygote.unwrap, Main.baz)::Any\n  │   %8  = (Base.getindex)(%7, 1)::Any\n  │         (Base.getindex)(%7, 2)::Any\n  │   %10 = (Zygote._pullback)(_2, %8, %5)::Any\n  │   %11 = (Base.getindex)(%10, 1)::Any\n  │         (Base.getindex)(%10, 2)::Any\n  └──       return %11\n  1 ─ %1  = Δ()::Any\n1 │   %2  = (@12)(%1)::Any\n  │   %3  = (Zygote.gradindex)(%2, 1)::Any\n  │   %4  = (Zygote.gradindex)(%2, 2)::Any\n  │         (@9)(%3)::Any\n  │   %6  = (@6)(%4)::Any\n  │   %7  = (Zygote.gradindex)(%6, 1)::Any\n  │   %8  = (Zygote.gradindex)(%6, 2)::Any\n  │         (@3)(%7)::Any\n  │   %10 = (Zygote.tuple)(nothing, %8)::Any\n  └──       return %10\n, [1])\n```\n\n----------------------------------------\n\nTITLE: Hand-Written Pullback Structure for Closures in Julia\nDESCRIPTION: Defines a Pullback struct to represent pullback closures and demonstrates its use in a hand-written pullback for a composite function. The (p::Pullback{typeof(foo)})(b̄) method implements the backward pass by unpacking stored closures with correct gradient flow. Mimics Zygote's closure conversion trick for handling adjoints in the absence of first-class closures in lowered Julia IR.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\nstruct Pullback{F}\n  data\nend\n\nfunction J(::typeof(foo), x)\n  a, da = J(sin, x)\n  b, db = J(cos, a)\n  return b, Pullback{typeof(foo)}((da, db))\nend\n\nfunction (p::Pullback{typeof(foo)})(b̄)\n  da, db = p.data[1], p.data[2]\n  ā = db(b̄)\n  x̄ = da(ā)\n  return x̄\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Adjoint with Explicit Error for Debugging (Julia)\nDESCRIPTION: Shows how to define a custom adjoint (gradient) function that throws an error, to facilitate debugging in Zygote. The custom adjoint for 'bad' triggers an error during differentiation, helping to identify problematic points in the call graph. Requires Zygote.@adjoint macro, and illustrates use in tracing errors during backpropagation.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_10\n\nLANGUAGE: julia\nCODE:\n```\nbad(x) = x\n\nZygote.@adjoint bad(x) = x, _ -> error(\"bad\")\n\nfoo(x) = bad(sin(x))\n\ngradient(foo, 1) # error!\n```\n\n----------------------------------------\n\nTITLE: Granular Debugging with Zygote._pullback (Julia)\nDESCRIPTION: Demonstrates a workflow for isolating errors in AD by using Zygote._pullback to manually trace computation through nested calls. By splitting calls into smaller parts (e.g., calling _pullback on 'sin' and 'bad' separately), the problematic function can be identified. This is especially useful when stack traces are ambiguous due to compiler errors. Assumes Zygote present.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/internals.md#_snippet_11\n\nLANGUAGE: julia\nCODE:\n```\njulia> y, back = Zygote._pullback(foo, 1);\n\njulia> back(1) # just make up a value here, it just needs to look similar to `y`\nERROR: bad\n\n# Ok, so we try functions that foo calls\n\njulia> y, back = Zygote._pullback(sin, 1);\n\njulia> back(1)\n(nothing, 0.5403023058681398)\n\n# Looks like that's fine\n\njulia> y, back = Zygote._pullback(bad, 1);\n\njulia> back(1) # ok, here's our issue. Lather, rinse, repeat.\nERROR: bad\n```\n\n----------------------------------------\n\nTITLE: Customizing the Struct Constructor's Adjoint in Julia with @adjoint\nDESCRIPTION: Defines a custom adjoint for the Point constructor so that gradients are unpacked correctly when constructing a Point from differentiable values. Prevents errors during gradient propagation through constructors.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_9\n\nLANGUAGE: julia\nCODE:\n```\njulia> @adjoint Point(a, b) = Point(a, b), p\\u0304 -> (p\\u0304.x, p\\u0304.y)\n\njulia> gradient(x -> dist(Point(x, 1)), 1)\n(0.7071067811865475,)\n```\n\n----------------------------------------\n\nTITLE: Referencing Zygote Utility Function Documentation in Julia\nDESCRIPTION: This `@docs` block lists several utility functions provided by Zygote, including `Zygote.withgradient` (compute function value and gradient), `Zygote.withjacobian` (compute function value and Jacobian), `Zygote.@showgrad` (macro for debugging gradients), `Zygote.hook` (intercept gradients), `Zygote.Buffer` (mutable buffer for gradients), `Zygote.forwarddiff` (use ForwardDiff within Zygote), `Zygote.checkpointed` (gradient checkpointing), and `Zygote.eager_update!` (related to parameter updates). It directs the documentation generator to include their respective docstrings.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/utils.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nZygote.withgradient\nZygote.withjacobian\nZygote.@showgrad\nZygote.hook\nZygote.Buffer\nZygote.forwarddiff\nZygote.checkpointed\nZygote.eager_update!\n```\n```\n\n----------------------------------------\n\nTITLE: Referencing Zygote Jacobian and Hessian Function Documentation in Julia\nDESCRIPTION: This `@docs` block lists functions related to computing Jacobians (`Zygote.jacobian`), Hessians (`Zygote.hessian`, `Zygote.hessian_reverse`), and the diagonal of the Hessian (`Zygote.diaghessian`) using Zygote. It serves as a directive for a documentation system (like Documenter.jl) to insert the documentation for these specific functions.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/utils.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\n```@docs\nZygote.jacobian\nZygote.hessian\nZygote.hessian_reverse\nZygote.diaghessian\n```\n```\n\n----------------------------------------\n\nTITLE: Checkpointing Impact with Side Effects in Pullbacks (Julia)\nDESCRIPTION: Shows that checkpointing means side-effectful functions are evaluated twice during differentiation, as evidenced by two prints. Demonstrates subtle behaviors of custom pullback design with functions having side effects.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_13\n\nLANGUAGE: julia\nCODE:\n```\njulia> foo(x) = (println(x); sin(x))\nfoo (generic function with 1 method)\n\njulia> gradient(x -> checkpoint(foo, x), 1)\n1\n1\n(0.5403023058681398,)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom rrule for Foreign Function Calls in Zygote (Julia)\nDESCRIPTION: This snippet defines an improved version of jclock, followed by a custom rrule function using ChainRulesCore's interface to provide a manual differentiation rule for jclock. The example demonstrates how, by specifying the custom rule, Zygote can compute the gradient for code involving foreign calls that would otherwise be unsupported. Dependencies include ChainRulesCore and Zygote. The key parameters are x and the sensitivities used in pullbacks. Input types are numeric, output is the custom gradient result.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/limitations.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\njclock(x) = ccall(:clock, Int32, ()) * x\n\nfunction ChainRulesCore.rrule(::typeof(jclock), x)\n  y = jclock(x)\n  pb(ȳ) = (ChainRulesCore.NoTangent(), ȳ * y)\n\n  return y, pb\nend\n\njulia> gradient(jclock, rand())\n(674298.4243400148,)\n```\n\n----------------------------------------\n\nTITLE: Calling and Differentiating Foreign Functions in Julia\nDESCRIPTION: This snippet defines and calls a Julia function jclock which invokes a C function (clock) via ccall, then applies Zygote's gradient function to demonstrate that foreign calls are not differentiable. The main parameter is x, and the dependency is the foreign C library. Inputs are numeric, and outputs include either the result or an error. Zygote returns an error when differentiation is attempted on ccall expressions, as it cannot inspect external routines.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/limitations.md#_snippet_4\n\nLANGUAGE: julia\nCODE:\n```\njulia> jclock(x) = ccall(:clock, Int32, ()) * 2\njclock (generic function with 1 method)\n\njulia> jclock(2)\n30921278\n\njulia> gradient(jclock, rand())\nERROR: Can't differentiate foreigncall expression\nYou might want to check the Zygote limitations documentation.\nhttps://fluxml.ai/Zygote.jl/latest/limitations\n\nStacktrace:\n  ...\n```\n\n----------------------------------------\n\nTITLE: Try-Catch Control Flow and Differentiation in Julia\nDESCRIPTION: This snippet defines safe_sqrt, a function using try/catch to handle domain errors of sqrt. The accompanying examples show how Zygote's gradient and pullback operations behave: they succeed if no exception is thrown, but fail if the catch block is entered. The main parameter is x, and results depend on input validity. The only dependency is Julia's sqrt. Caution: Zygote cannot differentiate through exception-catching paths.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/limitations.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> function safe_sqrt(x)\n           try\n               sqrt(x)\n           catch\n               0.\n           end\n       end\nsafe_sqrt (generic function with 1 method)\n\njulia> gradient(safe_sqrt, 4.)\n(0.25,)\n\njulia> val, pull = pullback(safe_sqrt, -1.)\n(0.0, Zygote.var\"#76#77\"{Zygote.Pullback{Tuple{typeof(safe_sqrt), Float64}, Any}}(∂(safe_sqrt)))\n\njulia> pull(1.)\nERROR: Can't differentiate function execution in catch block at #= REPL[2]:3 =#.\nStacktrace:\n```\n\n----------------------------------------\n\nTITLE: Cumulative Addition Example with Potential Variable Boxing Issue in Julia\nDESCRIPTION: This snippet defines a loop-based summation function mysum, which re-binds the variable tot on each iteration. The example is used to highlight how variable re-binding, particularly in the context of closures or type changes, might cause confusion or incorrect gradients with Zygote. The key parameters are the numeric inputs x and n, with outputs being a scalar sum. No dependencies are needed. Limitations may occur if variable types change or if boxed variables arise.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/limitations.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\nfunction mysum(x::Real, n::Int)\n  tot = 0.0\n  for i in 1:n\n    tot += x^n  # binds symbol `tot` to new value\n  end\n  return tot\nend\n```\n\n----------------------------------------\n\nTITLE: Error Trigger: Differentiating Mutating Functions with Zygote in Julia\nDESCRIPTION: This snippet demonstrates the error generated when attempting to differentiate a mutating function (f!) using Zygote's gradient function. The example shows both the user's attempt and the resulting error message about unsupported array mutation. The key parameter is the random input vector to gradient, and the output is an error stacktrace. This highlights the limitation that mutating operations are not compatible with Zygote's AD system.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/limitations.md#_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\njulia> gradient(rand(3)) do x\n         sum(f!(x))\n       end\nERROR: Mutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\nThis error occurs when you ask Zygote to differentiate operations that change\nthe elements of arrays in-place (e.g. setting values with x .= ...)\n\nPossible fixes:\n- avoid mutating operations (preferred)\n- or read the documentation and solutions for this error\n  https://fluxml.ai/Zygote.jl/latest/limitations\n\nStacktrace:\n  ...\n```\n\n----------------------------------------\n\nTITLE: Defining Jacobi and Wirtinger Derivative Functions in Julia using Zygote\nDESCRIPTION: Defines two helper functions in Julia using Zygote.jl. `jacobi(f, x)` computes the two columns of the 2x2 real Jacobian matrix of a complex function `f` at `x` by calling the pullback twice (with `1` and `im`). `wirtinger(f, x)` uses the Jacobian columns to compute the two Wirtinger derivatives, `∂f/∂z` and `∂f/∂z'`, which generalize complex derivatives for non-holomorphic functions.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_5\n\nLANGUAGE: julia\nCODE:\n```\nfunction jacobi(f, x)\n  y, back = Zygote.pullback(f, x)\n  back(1)[1], back(im)[1]\nend\n\nfunction wirtinger(f, x)\n  du, dv = jacobi(f, x)\n  (du' + im*dv')/2, (du + im*dv)/2\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Indirect Mutation Patterns in Julia Functions\nDESCRIPTION: These snippets define two Julia functions: g_inner!, which performs in-place assignment on one array from another, and g_outer, which allocates a new array and applies g_inner! to it. This example illustrates a scenario where a non-mutating function (g_outer) indirectly results in mutation, which may also trigger Zygote limitations in AD. The main parameters are the vectors x and y, and the output is a mutated or newly allocated array. No external dependencies are required.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/limitations.md#_snippet_2\n\nLANGUAGE: julia\nCODE:\n```\nfunction g_inner!(x, y)\n  for i in eachindex(x, y)\n    x[i] = 2 * y[i]\n  end\n  return x\nend\n\nfunction g_outer(y)\n  z = similar(y)\n  g_inner!(z, y)\n  return z\nend\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradients with Arrays and Rational Numbers in Julia with Zygote\nDESCRIPTION: This snippet demonstrates Zygote's ability to compute gradients involving arrays and non-standard number types like `Rational`. The first example calculates the gradient of the sum of a matrix-vector product with respect to the matrix `W`. The second calculates the gradient of `f(x) = 3x^2 + 2x + 1` at `x = 1//4`, resulting in a rational gradient.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/index.md#_snippet_3\n\nLANGUAGE: julia\nCODE:\n```\njulia> W = rand(2, 3); x = rand(3);\n\njulia> gradient(W -> sum(W*x), W)[1]\n2×3 Array{Float64,2}:\n 0.0462002  0.817608  0.979036\n 0.0462002  0.817608  0.979036\n\njulia> gradient(x -> 3x^2 + 2x + 1, 1//4)\n(7//2,)\n```\n\n----------------------------------------\n\nTITLE: Gradient Reflection: Detecting Differentiation Mode via Custom Adjoint (Julia)\nDESCRIPTION: Defines a function isderiving along with a custom adjoint that allows code to check if computation is under a gradient pass. Useful for conditional logic during differentiation. No dependencies besides Zygote macros.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_14\n\nLANGUAGE: julia\nCODE:\n```\nisderiving() = false\n\n@adjoint isderiving() = true, _ -> nothing\n```\n\n----------------------------------------\n\nTITLE: Defining Mutating Functions in Julia\nDESCRIPTION: This snippet defines a basic mutating function f! that doubles every element in the input array x in-place. Since Zygote does not support in-place mutation when differentiating, using this function with Zygote will result in an error. The key functionality is mutating x via broadcasting assignment, and the only parameter is the array x. No external dependencies are needed, but the function must not be used with Zygote's gradient routines.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/limitations.md#_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nfunction f!(x)\n  x .= 2 .* x\n  return x\nend\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Zygote's Default getfield Adjoint for Structs (Julia)\nDESCRIPTION: Shows Zygote's out-of-the-box adjoint for struct field access (getfield), resulting in a tuple with field and nothing for non-involved fields. Helpful for understanding default adjoint propagation.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/adjoints.md#_snippet_7\n\nLANGUAGE: julia\nCODE:\n```\njulia> gradient(a -> a.x, Point(1, 2))\n((x = 1, y = nothing),)\n```\n\n----------------------------------------\n\nTITLE: Calculating Wirtinger Derivatives for Holomorphic Function in Julia\nDESCRIPTION: Demonstrates the use of the `wirtinger` function (defined previously) to compute the Wirtinger derivatives for a known holomorphic function `f(x) = 3x^2 + 2x + 1` at `x = 1+2im`. For holomorphic functions, the second Wirtinger derivative (`∂f/∂z'`) should be zero.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_6\n\nLANGUAGE: julia\nCODE:\n```\njulia> wirtinger(x -> 3x^2 + 2x + 1, 1+2im)\n(8.0 + 12.0im, 0.0 + 0.0im)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of Real Part for Non-Holomorphic Function in Julia\nDESCRIPTION: Demonstrates calculating the gradient of the real part for a non-holomorphic function `log(x')` (log of conjugate). The conjugate of this gradient is calculated.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_3\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> gradient(x -> real(log(x')), 1+2im)[1] |> conj\n0.2 - 0.4im\n```\n\n----------------------------------------\n\nTITLE: Failing Cauchy-Riemann Check for Non-Holomorphic Function in Julia\nDESCRIPTION: Shows that the Cauchy-Riemann check (calculating the derivative via the imaginary part's gradient) fails for the non-holomorphic function `log(x')`, yielding a different result compared to the gradient of the real part.\nSOURCE: https://github.com/fluxml/zygote.jl/blob/master/docs/src/complex.md#_snippet_4\n\nLANGUAGE: jldoctest\nCODE:\n```\njulia> -im*gradient(x -> imag(log(x')), 1+2im)[1] |> conj\n-0.2 + 0.4im\n```"
  }
]