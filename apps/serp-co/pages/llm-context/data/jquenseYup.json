[
  {
    "owner": "jquense",
    "repo": "yup",
    "content": "TITLE: Creating and Using Yup Schema with TypeScript\nDESCRIPTION: Demonstrates how to create a user schema with various field validations, validate data against it, and use TypeScript type inference. The example shows required fields, positive integers, email/URL validation, and default values.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { object, string, number, date, InferType } from 'yup';\n\nlet userSchema = object({\n  name: string().required(),\n  age: number().required().positive().integer(),\n  email: string().email(),\n  website: string().url().nullable(),\n  createdOn: date().default(() => new Date()),\n});\n\n// parse and assert validity\nlet user = await userSchema.validate(await fetchUser());\n\ntype User = InferType<typeof userSchema>;\n/* {\n  name: string;\n  age: number;\n  email?: string | undefined\n  website?: string | null | undefined\n  createdOn: Date\n}*/\n```\n\n----------------------------------------\n\nTITLE: Conditional Schema Validation with when() Using Object Syntax\nDESCRIPTION: Example of using when() with object syntax to conditionally apply different validation rules based on the value of a sibling field or context value. Shows how to use is, then, and otherwise for branching schema logic.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_41\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = object({\n  isBig: boolean(),\n  count: number()\n    .when('isBig', {\n      is: true, // alternatively: (val) => val == true\n      then: (schema) => schema.min(5),\n      otherwise: (schema) => schema.min(0),\n    })\n    .when('$other', ([other], schema) =>\n      other === 4 ? schema.max(6) : schema,\n    ),\n});\n\nawait schema.validate(value, { context: { other: 4 } });\n```\n\n----------------------------------------\n\nTITLE: Basic Validation Tests in Yup\nDESCRIPTION: Demonstrates how to use Yup's built-in validation tests to assert input criteria. The example shows validating string length and email format.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nstring()\n  .min(3, 'must be at least 3 characters long')\n  .email('must be a valid email')\n  .validate('no'); // ValidationError\n```\n\n----------------------------------------\n\nTITLE: Object Schema Example\nDESCRIPTION: Demonstrates object schema definition with multiple field validations\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_60\n\nLANGUAGE: javascript\nCODE:\n```\nyup.object({\n  name: string().required(),\n  age: number().required().positive().integer(),\n  email: string().email(),\n  website: string().url(),\n});\n```\n\n----------------------------------------\n\nTITLE: Validating Schema with validate and validateSync Methods\nDESCRIPTION: Demonstrates how to validate values against a schema using both asynchronous and synchronous validation methods. Shows basic usage and options for controlling validation behavior.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nvalue = await schema.validate({ name: 'jimmy', age: 24 });\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Methods to Yup Schema\nDESCRIPTION: Shows how to extend Yup's built-in schema types with new methods using addMethod(), implementing a custom date format parser with Moment.js.\nSOURCE: https://github.com/jquense/yup/blob/master/docs/extending.md#2025-04-18_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction parseDateFromFormats(formats, parseStrict) {\n  return this.transform(function (value, originalValue) {\n    if (this.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : yup.date.INVALID_DATE;\n  });\n}\n\nyup.addMethod(yup.date, 'format', parseDateFromFormats);\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Validation Tests in Yup\nDESCRIPTION: Shows how to create custom validation tests for specialized checks. The example creates a test to verify that a string value is exactly 'James'.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nlet jamesSchema = string().test(\n  'is-james',\n  (d) => `${d.path} is not James`,\n  (value) => value == null || value === 'James',\n);\n\njamesSchema.validateSync('James'); // \"James\"\n\njamesSchema.validateSync('Jane'); // ValidationError \"this is not James\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Validation Based on Multiple Fields\nDESCRIPTION: Example showing how to use when() with multiple dependent fields to create validation rules that depend on a combination of field values. Values are spread as arguments to the is condition.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_42\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = object({\n  isSpecial: boolean(),\n  isBig: boolean(),\n  count: number().when(['isBig', 'isSpecial'], {\n    is: true, // alternatively: (isBig, isSpecial) => isBig && isSpecial\n    then: (schema) => schema.min(5),\n    otherwise: (schema) => schema.min(0),\n  }),\n});\n\nawait schema.validate({\n  isBig: true,\n  isSpecial: true,\n  count: 10,\n});\n```\n\n----------------------------------------\n\nTITLE: Casting Values with Yup Schema\nDESCRIPTION: Shows how to use the cast method to coerce input values to the correct types according to the schema definition without performing full validation. In this example, string values are converted to their appropriate types.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Attempts to coerce values to the correct type\nlet parsedUser = userSchema.cast({\n  name: 'jimmy',\n  age: '24',\n  createdOn: '2014-09-23T19:25:25Z',\n});\n// ✅  { name: 'jimmy', age: 24, createdOn: Date }\n```\n\n----------------------------------------\n\nTITLE: Creating Exclusive Test Validations in Yup\nDESCRIPTION: Demonstrates how to use the options object syntax for test() to create exclusive validations. This example shows a maximum length validation with custom parameters and messaging.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_45\n\nLANGUAGE: javascript\nCODE:\n```\nlet max = 64;\nlet schema = yup.string().test({\n  name: 'max',\n  exclusive: true,\n  params: { max },\n  message: '${path} must be less than ${max} characters',\n  test: (value) => value == null || value.length <= max,\n});\n```\n\n----------------------------------------\n\nTITLE: Strict Validation with Yup Schema\nDESCRIPTION: Demonstrates how to use strict validation mode to avoid the parsing/coercion step and directly validate that inputs already match the expected types. This example shows an error when a string is provided where a number is expected.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// ❌  ValidationError \"age is not a number\"\nlet parsedUser = await userSchema.validate(\n  {\n    name: 'jimmy',\n    age: '24',\n  },\n  { strict: true },\n);\n```\n\n----------------------------------------\n\nTITLE: Using String Regex Matching in Yup\nDESCRIPTION: Shows how to validate strings against regular expressions in Yup. Includes examples of basic regex matching and handling empty strings with the excludeEmptyString option.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_50\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = string().matches(/(hi|bye)/);\n\nawait schema.isValid('hi'); // => true\nawait schema.isValid('nope'); // => false\n```\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = string().matches(/(hi|bye)/, { excludeEmptyString: true });\n\nawait schema.isValid(''); // => true\n```\n\n----------------------------------------\n\nTITLE: Complex Custom Validation with Contextual Errors\nDESCRIPTION: Demonstrates creating advanced validation tests with dynamic error messages based on different conditions. The example validates a SKU format with specific prefix, suffix, and length requirements.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nlet order = object({\n  no: number().required(),\n  sku: string().test({\n    name: 'is-sku',\n    skipAbsent: true,\n    test(value, ctx) {\n      if (!value.startsWith('s-')) {\n        return ctx.createError({ message: 'SKU missing correct prefix' });\n      }\n      if (!value.endsWith('-42a')) {\n        return ctx.createError({ message: 'SKU missing correct suffix' });\n      }\n      if (value.length < 10) {\n        return ctx.createError({ message: 'SKU is not the right length' });\n      }\n      return true;\n    },\n  }),\n});\n\norder.validate({ no: 1234, sku: 's-1a45-14a' });\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Email Validation in Yup\nDESCRIPTION: Shows how to override Yup's default email validation with a custom implementation. This example adds a custom email validation method with a specific regex pattern.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nyup.addMethod(yup.string, 'email', function validateEmail(message) {\n  return this.matches(myEmailRegex, {\n    message,\n    name: 'email',\n    excludeEmptyString: true,\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Type Parsing and Transforms in Yup\nDESCRIPTION: Demonstrates how Yup handles type parsing and transformation of values. The example shows converting a string to a number and transforming object properties with string modifications like lowercase and trim.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nlet num = number().cast('1'); // 1\n\nlet obj = object({\n  firstName: string().lowercase().trim(),\n})\n  .json()\n  .camelCase()\n  .cast('{\"first_name\": \"jAnE \"}'); // { firstName: 'jane' }\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Schema Types in Yup\nDESCRIPTION: Demonstrates how to create a new schema type by extending an existing schema class, implementing a MomentDateSchema with custom validation and transformation logic.\nSOURCE: https://github.com/jquense/yup/blob/master/docs/extending.md#2025-04-18_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { DateSchema } from 'yup';\n\nclass MomentDateSchema extends DateSchema {\n  static create() {\n    return MomentDateSchema();\n  }\n\n  constructor() {\n    super();\n    this._validFormats = [];\n\n    this.withMutation(() => {\n      this.transform(function (value, originalvalue) {\n        if (this.isType(value))\n          // we have a valid value\n          return value;\n        return Moment(originalValue, this._validFormats, true);\n      });\n    });\n  }\n\n  _typeCheck(value) {\n    return (\n      super._typeCheck(value) || (moment.isMoment(value) && value.isValid())\n    );\n  }\n\n  format(formats) {\n    if (!formats) throw new Error('must enter a valid format');\n    let next = this.clone();\n    next._validFormats = {}.concat(formats);\n  }\n}\n\nlet schema = new MomentDateSchema();\n\nschema.format('YYYY-MM-DD').cast('It is 2012-05-25'); // => Fri May 25 2012 00:00:00 GMT-0400 (Eastern Daylight Time)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Validation Tests in Yup\nDESCRIPTION: Shows how to add custom validation tests to Yup schemas. The examples demonstrate both synchronous and asynchronous validation, including how to access test context and create custom error messages.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_44\n\nLANGUAGE: javascript\nCODE:\n```\nlet jimmySchema = string().test(\n  'is-jimmy',\n  '${path} is not Jimmy',\n  (value, context) => value === 'jimmy',\n);\n\n// or make it async by returning a promise\nlet asyncJimmySchema = string()\n  .label('First name')\n  .test(\n    'is-jimmy',\n    ({ label }) => `${label} is not Jimmy`, // a message can also be a function\n    async (value, testContext) =>\n      (await fetch('/is-jimmy/' + value)).responseText === 'true',\n  );\n\nawait schema.isValid('jimmy'); // => true\nawait schema.isValid('john'); // => false\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Paths with validateAt Method\nDESCRIPTION: Shows how to validate specific nested paths within a schema using the validateAt method. Demonstrates validation for conditional schema rules at different paths with the same root value.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_29\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = object({\n  foo: array().of(\n    object({\n      loose: boolean(),\n      bar: string().when('loose', {\n        is: true,\n        otherwise: (schema) => schema.strict(),\n      }),\n    }),\n  ),\n});\n\nlet rootValue = {\n  foo: [{ bar: 1 }, { bar: 1, loose: true }],\n};\n\nawait schema.validateAt('foo[0].bar', rootValue); // => ValidationError: must be a string\n\nawait schema.validateAt('foo[1].bar', rootValue); // => '1'\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Schemas with Yup's lazy Function\nDESCRIPTION: Shows how to use lazy evaluation to create dynamic schemas that are determined at validation time. Examples include recursive tree structures and polymorphic fields that change schema based on the input value type.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nlet node = object({\n  id: number(),\n  child: yup.lazy(() => node.default(undefined)),\n});\n\nlet renderable = yup.lazy((value) => {\n  switch (typeof value) {\n    case 'number':\n      return number();\n    case 'string':\n      return string();\n    default:\n      return mixed();\n  }\n});\n\nlet renderables = array().of(renderable);\n```\n\n----------------------------------------\n\nTITLE: Using oneOf() for Value Validation\nDESCRIPTION: Example of using oneOf() (alias: equals) to restrict valid values to a specific set. This validator allows the field value to match any of the specified values but rejects all others.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_39\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.mixed().oneOf(['jimmy', 42]);\n\nawait schema.isValid(42); // => true\nawait schema.isValid('jimmy'); // => true\nawait schema.isValid(new Date()); // => false\n```\n\n----------------------------------------\n\nTITLE: Creating References to Other Fields with Yup\nDESCRIPTION: Demonstrates how to create references to other fields in a schema using Yup's ref function. References allow validations to depend on values from other fields and can access context variables.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ref, object, string } from 'yup';\n\nlet schema = object({\n  baz: ref('foo.bar'),\n  foo: object({\n    bar: string(),\n  }),\n  x: ref('$x'),\n});\n\nschema.cast({ foo: { bar: 'boom' } }, { context: { x: 5 } });\n// => { baz: 'boom',  x: 5, foo: { bar: 'boom' } }\n```\n\n----------------------------------------\n\nTITLE: Creating String Validation Schemas in Yup\nDESCRIPTION: Shows how to create and use string validation schemas in Yup. Demonstrates basic validation of string values.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_49\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.string();\n\nawait schema.isValid('hello'); // => true\n```\n\n----------------------------------------\n\nTITLE: Customizing Error Messages in Yup\nDESCRIPTION: Demonstrates how to customize default error messages in Yup using setLocale. The example shows setting custom messages for mixed and number validations in Portuguese.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport { setLocale } from 'yup';\n\nsetLocale({\n  mixed: {\n    default: 'Não é válido',\n  },\n  number: {\n    min: 'Deve ser maior que ${min}',\n  },\n});\n\n// now use Yup schemas AFTER you defined your custom dictionary\nlet schema = yup.object().shape({\n  name: yup.string(),\n  age: yup.number().min(18),\n});\n\ntry {\n  await schema.validate({ name: 'jimmy', age: 11 });\n} catch (err) {\n  err.name; // => 'ValidationError'\n  err.errors; // => ['Deve ser maior que 18']\n}\n```\n\n----------------------------------------\n\nTITLE: Omitting Fields from Yup Object Schema in JavaScript\nDESCRIPTION: Demonstrates how to create a new schema with specific fields omitted using the omit method. It shows how to define an initial object schema and then create a new schema without certain fields.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_61\n\nLANGUAGE: javascript\nCODE:\n```\nlet person = object({\n  age: number().default(30).required(),\n  name: string().default('pat').required(),\n  color: string().default('red').required(),\n});\n\nlet nameAndAge = person.omit(['color']);\nnameAndAge.getDefault(); // => { age: 30, name: 'pat'}\n```\n\n----------------------------------------\n\nTITLE: Internationalization (i18n) Support in Yup\nDESCRIPTION: Shows how to integrate Yup with i18n libraries by setting up translation keys and value functions. The example demonstrates configuring locale with both static keys and dynamic value generators.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nimport { setLocale } from 'yup';\n\nsetLocale({\n  // use constant translation keys for messages without values\n  mixed: {\n    default: 'field_invalid',\n  },\n  // use functions to generate an error object that includes the value from the schema\n  number: {\n    min: ({ min }) => ({ key: 'field_too_short', values: { min } }),\n    max: ({ max }) => ({ key: 'field_too_big', values: { max } }),\n  },\n});\n\n// ...\n\nlet schema = yup.object().shape({\n  name: yup.string(),\n  age: yup.number().min(18),\n});\n\ntry {\n  await schema.validate({ name: 'jimmy', age: 11 });\n} catch (err) {\n  messages = err.errors.map((err) => i18next.t(err.key));\n}\n```\n\n----------------------------------------\n\nTITLE: Transforming Keys in Yup Object Schema using from Method in JavaScript\nDESCRIPTION: Shows how to use the from method to transform specified keys to new keys in a Yup object schema. It also demonstrates the alias option to retain the old key.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_62\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = object({\n  myProp: mixed(),\n  Other: mixed(),\n})\n  .from('prop', 'myProp')\n  .from('other', 'Other', true);\n\nschema.cast({ prop: 5, other: 6 }); // => { myProp: 5, other: 6, Other: 6 }\n```\n\n----------------------------------------\n\nTITLE: Schema Composition and Reuse in Yup\nDESCRIPTION: Shows how Yup schemas are immutable and can be composed and reused. The example demonstrates creating an optional string schema and then deriving a defined string schema from it.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nlet optionalString = string().optional();\n\nlet definedString = optionalString.defined();\n\nlet value = undefined;\noptionalString.isValid(value); // true\ndefinedString.isValid(value); // false\n```\n\n----------------------------------------\n\nTITLE: Array Schema Validation Example\nDESCRIPTION: Shows typed array validation with number constraints\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_55\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.array().of(yup.number().min(2));\n\nawait schema.isValid([2, 3]); // => true\nawait schema.isValid([1, -24]); // => false\n\nschema.cast(['2', '3']); // => [2, 3]\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Transforms in Yup\nDESCRIPTION: Shows how to add custom transform functions to a Yup schema. The example creates a string transformation that reverses the input string.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nlet reversedString = string()\n  .transform((currentValue) => currentValue.split('').reverse().join(''))\n  .cast('dlrow olleh'); // \"hello world\"\n```\n\n----------------------------------------\n\nTITLE: Making Fields Optional with optional() Method\nDESCRIPTION: Example showing how to make a field optional (allowing undefined values) using the optional() method. This affects both validation behavior and TypeScript type inference.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nlet schema = string().optional();\n\nschema.cast(undefined); // undefined\n\nInferType<typeof schema>; // string | undefined\n```\n\n----------------------------------------\n\nTITLE: TypeScript Integration with Yup Schemas\nDESCRIPTION: Demonstrates how to extract TypeScript interfaces from Yup schemas using InferType. The example creates a person schema with various field types and validations.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as yup from 'yup';\n\nlet personSchema = yup.object({\n  firstName: yup.string().defined(),\n  nickName: yup.string().default('').nullable(),\n  sex: yup\n    .mixed()\n    .oneOf(['male', 'female', 'other'] as const)\n    .defined(),\n  email: yup.string().nullable().email(),\n  birthDate: yup.date().nullable().min(new Date(1900, 0, 1)),\n});\n\ninterface Person extends yup.InferType<typeof personSchema> {\n  // using interface instead of type generally gives nicer editor feedback\n}\n```\n\n----------------------------------------\n\nTITLE: Using defined() Method for Required Values\nDESCRIPTION: Example showing how to require a value to be defined (not undefined) using the defined() method. This affects both validation and TypeScript type inference.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nlet schema = string().defined();\n\nschema.cast(undefined); // TypeError\n\nInferType<typeof schema>; // string\n```\n\n----------------------------------------\n\nTITLE: Conditional Schema with Function Syntax\nDESCRIPTION: Example showing how to use when() with a function that returns a schema. This provides a more flexible way to create conditional schema logic based on field values.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_43\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.object({\n  isBig: yup.boolean(),\n  count: yup.number().when('isBig', ([isBig], schema) => {\n    return isBig ? schema.min(5) : schema.min(0);\n  }),\n});\n\nawait schema.validate({ isBig: false, count: 4 });\n```\n\n----------------------------------------\n\nTITLE: Type Handling with nonNullable() Method\nDESCRIPTION: Example showing how to use nonNullable() to explicitly disallow null values in a schema. This is the default behavior but can be used to override a previously set nullable() setting.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nlet schema = number().nonNullable();\n\nschema.cast(null); // TypeError\n\nInferType<typeof schema>; // number\n```\n\n----------------------------------------\n\nTITLE: Adding Value Transformations to Yup Schemas\nDESCRIPTION: Shows how to add transformations to the schema to modify values during the casting process. Examples include converting strings to uppercase and implementing custom date parsing logic.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_46\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = string().transform((value, originalValue) => {\n  return this.isType(value) && value !== null ? value.toUpperCase() : value;\n});\n\nschema.cast('jimmy'); // => 'JIMMY'\n```\n\nLANGUAGE: javascript\nCODE:\n```\nmodule.exports = function (formats = 'MMM dd, yyyy') {\n  return date().transform((value, originalValue, context) => {\n    // check to see if the previous transform already parsed the date\n    if (context.isType(value)) return value;\n\n    // the default coercion failed so let's try it with Moment.js instead\n    value = Moment(originalValue, formats);\n\n    // if it's valid return the date object, otherwise return an `InvalidDate`\n    return value.isValid() ? value.toDate() : new Date('');\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Number Schema Validation Example\nDESCRIPTION: Demonstrates basic number schema validation using Yup\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_52\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.number();\n\nawait schema.isValid(10); // => true\n```\n\n----------------------------------------\n\nTITLE: Ensuring Yup Schema Matches Existing TypeScript Type\nDESCRIPTION: Demonstrates how to ensure that a Yup schema produces a type compatible with an existing TypeScript interface. Shows both valid and invalid schema examples with type checking.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { object, number, string, ObjectSchema } from 'yup';\n\ninterface Person {\n  name: string;\n  age?: number;\n  sex: 'male' | 'female' | 'other' | null;\n}\n\n// will raise a compile-time type error if the schema does not produce a valid Person\nlet schema: ObjectSchema<Person> = object({\n  name: string().defined(),\n  age: number().optional(),\n  sex: string<'male' | 'female' | 'other'>().nullable().defined(),\n});\n\n// ❌ errors:\n// \"Type 'number | undefined' is not assignable to type 'string'.\"\nlet badSchema: ObjectSchema<Person> = object({\n  name: number(),\n});\n```\n\n----------------------------------------\n\nTITLE: Boolean Schema Validation Example\nDESCRIPTION: Shows how to validate boolean values using Yup schema\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_53\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.boolean();\n\nawait schema.isValid(true); // => true\n```\n\n----------------------------------------\n\nTITLE: Synchronous Validation with Custom Test Functions\nDESCRIPTION: Shows how to create and use synchronous validation tests with Yup. Demonstrates a schema with a custom test function that validates whether a value is different from 42.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_27\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = number().test(\n  'is-42',\n  \"this isn't the number i want\",\n  (value) => value != 42,\n);\n\nschema.validateSync(23); // throws ValidationError\n```\n\n----------------------------------------\n\nTITLE: Date Schema Validation Example\nDESCRIPTION: Illustrates date schema validation with ISO date strings support\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_54\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.date();\n\nawait schema.isValid(new Date()); // => true\n```\n\n----------------------------------------\n\nTITLE: Extending Yup Schema Types with New Methods\nDESCRIPTION: Shows how to extend Yup's built-in schema types with new methods using TypeScript's interface merging and the addMethod utility. The example adds an 'append' method to StringSchema.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n// globals.d.ts\ndeclare module 'yup' {\n  interface StringSchema<TType, TContext, TDefault, TFlags> {\n    append(appendStr: string): this;\n  }\n}\n\n// app.ts\nimport { addMethod, string } from 'yup';\n\naddMethod(string, 'append', function append(appendStr: string) {\n  return this.transform((value) => `${value}${appendStr}`);\n});\n\nstring().append('~~~~').cast('hi'); // 'hi~~~~'\n```\n\n----------------------------------------\n\nTITLE: Tuple Schema Example\nDESCRIPTION: Shows tuple schema usage with type inference\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_59\n\nLANGUAGE: javascript\nCODE:\n```\nimport { tuple, string, number, InferType } from 'yup';\n\nlet schema = tuple([\n  string().label('name'),\n  number().label('age').positive().integer(),\n]);\n\nawait schema.validate(['James', 3]); // ['James', 3]\n\nawait schema.validate(['James', -24]); // => ValidationError: age must be a positive number\n\nInferType<typeof schema> // [string, number] | undefined\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Methods to Yup Schema Types\nDESCRIPTION: Shows how to extend Yup's functionality by adding custom methods to schema types. The example demonstrates adding a 'format' method to the date schema type that transforms values using Moment.js.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addMethod, date } from 'yup';\n\naddMethod(date, 'format', function format(formats, parseStrict) {\n  return this.transform((value, originalValue, ctx) => {\n    if (ctx.isType(value)) return value;\n\n    value = Moment(originalValue, formats, parseStrict);\n\n    return value.isValid() ? value.toDate() : new Date('');\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Array Ensure Method Example\nDESCRIPTION: Shows array ensure method usage for handling null and undefined values\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_57\n\nLANGUAGE: javascript\nCODE:\n```\narray().ensure().cast(null); // => []\narray().ensure().cast(1); // => [1]\narray().ensure().cast([1]); // => [1]\n```\n\n----------------------------------------\n\nTITLE: Adding Methods to All Yup Schema Types\nDESCRIPTION: Demonstrates how to add a custom method to all schema types by extending the abstract base Schema class. This approach allows for adding globally available methods across all schema types.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nimport { addMethod, Schema } from 'yup';\n\naddMethod(Schema, 'myMethod', ...)\n```\n\n----------------------------------------\n\nTITLE: Array Compact Method Example\nDESCRIPTION: Demonstrates array compact method for filtering falsey values\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_58\n\nLANGUAGE: javascript\nCODE:\n```\narray().compact().cast(['', 1, 0, 4, false, null]); // => [1, 4]\n\narray()\n  .compact(function (v) {\n    return v == null;\n  })\n  .cast(['', 1, 0, 4, false, null]); // => ['', 1, 0, 4, false]\n```\n\n----------------------------------------\n\nTITLE: Schema Defaults and TypeScript Types\nDESCRIPTION: Shows how setting defaults in a Yup schema affects the TypeScript type inference by marking fields as defined rather than optional.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { string } from 'yup';\n\nlet value: string = string().default('hi').validate(undefined);\n\n// vs\n\nlet value: string | undefined = string().validate(undefined);\n```\n\n----------------------------------------\n\nTITLE: Setting Default Values with different() Method\nDESCRIPTION: Examples of setting default values for schema types, including primitive values, objects, and functions that return new defaults. Shows how to optimize performance by using factory functions for complex default values.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_34\n\nLANGUAGE: javascript\nCODE:\n```\nyup.string.default('nothing');\n\nyup.object.default({ number: 5 }); // object will be cloned every time a default is needed\n\nyup.object.default(() => ({ number: 5 })); // this is cheaper\n\nyup.date.default(() => new Date()); // also helpful for defaults that change over time\n```\n\n----------------------------------------\n\nTITLE: Validation Options Interface\nDESCRIPTION: Defines the options that can be passed to Yup's validation methods. Includes controls for strictness, error handling, unknown fields, recursion, and context values.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_26\n\nLANGUAGE: javascript\nCODE:\n```\ninterface Options {\n  // when true, parsing is skipped and the input is validated \"as-is\"\n  strict: boolean = false;\n  // Throw on the first error or collect and return all\n  abortEarly: boolean = true;\n  // Remove unspecified keys from objects\n  stripUnknown: boolean = false;\n  // when `false` validations will be performed shallowly\n  recursive: boolean = true;\n  // External values that can be provided to validations and conditionals\n  context?: object;\n}\n```\n\n----------------------------------------\n\nTITLE: Using withMutation for Schema Modification\nDESCRIPTION: Example of using withMutation() to modify a schema in-place rather than creating clones for each change. This is useful for performance-critical schema modifications or when adding multiple tests.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_33\n\nLANGUAGE: javascript\nCODE:\n```\nobject()\n  .shape({ key: string() })\n  .withMutation((schema) => {\n    return arrayOfObjectTests.forEach((test) => {\n      schema.test(test);\n    });\n  });\n```\n\n----------------------------------------\n\nTITLE: Using notOneOf() for Value Exclusion\nDESCRIPTION: Example of using notOneOf() to disallow specific values. This validator rejects any values in the specified array but allows all other values that pass other validations.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_40\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = yup.mixed().notOneOf(['jimmy', 42]);\n\nawait schema.isValid(42); // => false\nawait schema.isValid(new Date()); // => true\n```\n\n----------------------------------------\n\nTITLE: Defining Cast Options Interface in TypeScript\nDESCRIPTION: TypeScript interface that defines the options for the Schema.cast() method, including options to strip unknown properties, assert valid types, and provide context for resolving conditions and references.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_30\n\nLANGUAGE: javascript\nCODE:\n```\ninterface CastOptions<TContext extends {}> {\n  // Remove undefined properties from objects\n  stripUnknown: boolean = false;\n\n  // Throws a TypeError if casting doesn't produce a valid type\n  // note that the TS return type is inaccurate when this is `false`, use with caution\n  assert?: boolean = true;\n\n  // External values that used to resolve conditions and references\n  context?: TContext;\n}\n```\n\n----------------------------------------\n\nTITLE: Describing Dynamic Schemas with Context\nDESCRIPTION: Shows how to provide context when describing schemas with dynamic components like conditions. This example demonstrates a schema with conditional validation rules based on a boolean field value.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ref, object, string, boolean } from 'yup';\n\nlet schema = object({\n  isBig: boolean(),\n  count: number().when('isBig', {\n    is: true,\n    then: (schema) => schema.min(5),\n    otherwise: (schema) => schema.min(0),\n  }),\n});\n\nschema.describe({ value: { isBig: true } });\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Schema Configurations in Yup\nDESCRIPTION: Demonstrates how to create reusable schema configurations using Yup, including a required string schema and a custom date schema that uses Moment.js for parsing.\nSOURCE: https://github.com/jquense/yup/blob/master/docs/extending.md#2025-04-18_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as yup from 'yup';\n\nconst requiredString = yup.string().required().default('');\n\nconst momentDate = (parseFormats = ['MMM dd, yyy']) =>\n  yup.date().transform(function (value, originalValue) {\n    if (this.isType(value)) return value;\n\n    // the default coercion transform failed so let's try it with Moment instead\n    value = Moment(originalValue, parseFormats);\n    return value.isValid() ? value.toDate() : yup.date.INVALID_DATE;\n  });\n\nexport { momentDate, requiredString };\n```\n\n----------------------------------------\n\nTITLE: Creating Mixed Type Schemas in Yup\nDESCRIPTION: Shows how to create and use mixed type schemas that can accept multiple types of values. Includes TypeScript type inference and nullability handling.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mixed, InferType } from 'yup';\n\nlet schema = mixed().nullable();\n\nschema.validateSync('string'); // 'string';\n\nschema.validateSync(1); // 1;\n\nschema.validateSync(new Date()); // Date;\n\nInferType<typeof schema>; // {} | undefined\n\nInferType<typeof schema.nullable().defined()>; // {} | null\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Types in Yup with TypeScript\nDESCRIPTION: Demonstrates how to implement custom types in Yup with proper TypeScript type narrowing. The example shows creating a MongoDB ObjectId validator with transformation.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nimport { mixed, InferType } from 'yup';\n\nlet objectIdSchema = yup\n  .mixed((input): input is ObjectId => input instanceof ObjectId)\n  .transform((value: any, input, ctx) => {\n    if (ctx.isType(value)) return value;\n    return new ObjectId(value);\n  });\n\nawait objectIdSchema.validate(ObjectId('507f1f77bcf86cd799439011')); // ObjectId(\"507f1f77bcf86cd799439011\")\n\nawait objectIdSchema.validate('507f1f77bcf86cd799439011'); // ObjectId(\"507f1f77bcf86cd799439011\")\n\nInferType<typeof objectIdSchema>; // ObjectId\n```\n\n----------------------------------------\n\nTITLE: Collecting Schema Details with describe Method\nDESCRIPTION: Demonstrates how to use the describe method to retrieve a serializable description of a schema, including its constraints and configuration. Shows both basic usage and advanced usage with dynamic components.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nlet schema = object({\n  name: string().required(),\n});\n\nlet description = schema.describe();\n```\n\n----------------------------------------\n\nTITLE: Using Yup's reach Function for Nested Schema Access\nDESCRIPTION: Demonstrates how to use the 'reach' utility function to access nested schemas within a complex schema structure. The examples show various path syntaxes including array indices and nested object properties.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { reach } from 'yup';\n\nlet schema = object({\n  nested: object({\n    arr: array(object({ num: number().max(4) })),\n  }),\n});\n\nreach(schema, 'nested.arr.num');\nreach(schema, 'nested.arr[].num');\nreach(schema, 'nested.arr[1].num');\nreach(schema, 'nested[\"arr\"][1].num');\n```\n\n----------------------------------------\n\nTITLE: Importing Yup Core Schema Types and Classes\nDESCRIPTION: Shows how to import various schema types, classes, and type definitions from the Yup validation library. This includes basic schema types like mixed, string, number, as well as core schema classes and TypeScript type definitions.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// core schema\nimport {\n  mixed,\n  string,\n  number,\n  boolean,\n  bool,\n  date,\n  object,\n  array,\n  ref,\n  lazy,\n} from 'yup';\n\n// Classes\nimport {\n  Schema,\n  MixedSchema,\n  StringSchema,\n  NumberSchema,\n  BooleanSchema,\n  DateSchema,\n  ArraySchema,\n  ObjectSchema,\n} from 'yup';\n\n// Types\nimport type { InferType, ISchema, AnySchema, AnyObjectSchema } from 'yup';\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Validation with Promise-Based Tests\nDESCRIPTION: Demonstrates why asynchronous test functions cannot be used with validateSync. Shows a test function that returns a Promise, which is incompatible with synchronous validation.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_28\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = number().test('is-42', \"this isn't the number i want\", (value) =>\n  Promise.resolve(value != 42),\n);\n\nschema.validateSync(42); // throws Error\n```\n\n----------------------------------------\n\nTITLE: Type Handling with nullable() Method\nDESCRIPTION: Example showing how to use nullable() to indicate that null is a valid value for a schema. This affects type checking and TypeScript inference, allowing null to be a valid type.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\nlet schema = number().nullable();\n\nschema.cast(null); // null\n\nInferType<typeof schema>; // number | null\n```\n\n----------------------------------------\n\nTITLE: Using strip() Method to Remove Properties from Output Objects\nDESCRIPTION: Example showing how to mark a schema property to be removed from output objects using the strip() method. This is useful for excluding certain fields during type casting while keeping them in the schema definition.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_31\n\nLANGUAGE: javascript\nCODE:\n```\nlet schema = object({\n  useThis: number(),\n  notThis: string().strip(),\n});\n\nschema.cast({ notThis: 'foo', useThis: 4 }); // => { useThis: 4 }\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Schema Metadata in TypeScript\nDESCRIPTION: Shows how to extend Yup's type definitions to include custom metadata fields. This example demonstrates declaration merging to add placeholderText and tooltipText to the schema metadata interface.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n// yup.d.ts\nimport 'yup';\n\ndeclare module 'yup' {\n  // Define your desired `SchemaMetadata` interface by merging the\n  // `CustomSchemaMetadata` interface.\n  export interface CustomSchemaMetadata {\n    placeholderText?: string;\n    tooltipText?: string;\n    // …\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Inference with strip() Method\nDESCRIPTION: Example demonstrating how TypeScript infers types when using the strip() method, showing that stripped properties are removed from the inferred type using the 'never' type.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\nlet schema = object({\n  useThis: number(),\n  notThis: string().strip(),\n});\n\nInferType<typeof schema>; /*\n{\n   useThis?: number | undefined\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Schema Description Type Definitions\nDESCRIPTION: Defines the TypeScript interfaces for schema descriptions returned by the describe method. Includes the base SchemaDescription interface and specialized interfaces for references and lazy schemas.\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SchemaDescription {\n  type: string;\n  label?: string;\n  meta: object | undefined;\n  oneOf: unknown[];\n  notOneOf: unknown[];\n  default?: unknown;\n  nullable: boolean;\n  optional: boolean;\n  tests: Array<{ name?: string; params: ExtraParams | undefined }>;\n\n  // Present on object schema descriptions\n  fields: Record<string, SchemaFieldDescription>;\n\n  // Present on array schema descriptions\n  innerType?: SchemaFieldDescription;\n}\n\ntype SchemaFieldDescription =\n  | SchemaDescription\n  | SchemaRefDescription\n  | SchemaLazyDescription;\n\ninterface SchemaRefDescription {\n  type: 'ref';\n  key: string;\n}\n\ninterface SchemaLazyDescription {\n  type: string;\n  label?: string;\n  meta: object | undefined;\n}\n```\n\n----------------------------------------\n\nTITLE: Updated Syntax for Yup's when() Method\nDESCRIPTION: Example showing the breaking change in the when() method syntax where the function version no longer sets 'this' to the schema instance and requires explicitly returning a schema. Values are passed as an array and the schema is the second parameter.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nstring()\n-   .when('other', function (other) => {\n-      if (other) return this.required()\n+   .when('other', ([other], schema) => {\n+     return other ? schema.required() : schema\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Parsing for Object and Array Schema in Yup\nDESCRIPTION: Example of how to enable JSON parsing for object and array schemas after this functionality was removed as a default behavior in v1.0.0-beta.0. The json() method must now be explicitly called to parse JSON strings.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nobject().json().cast('{}')\narray().json().cast('[]')\n```\n\n----------------------------------------\n\nTITLE: Array Required Validation - JavaScript\nDESCRIPTION: Example showing new array validation behavior where empty arrays are considered valid for required() checks. To maintain old behavior requiring non-empty arrays, use both required() and min(1).\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\narray().required().min(1)\n```\n\n----------------------------------------\n\nTITLE: Updated Method Extension in Yup\nDESCRIPTION: Example showing how to extend Yup with custom methods after the base class hierarchy change. Instead of extending the 'mixed' prototype, extensions should now target the 'Schema' class.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n-  mixed,\n+  Schema,\n} from 'yup';\n\n- addMethod(mixed, 'method', impl)\n+ addMethod(Schema, 'method', impl)\n```\n\n----------------------------------------\n\nTITLE: String Type Coercion - JavaScript\nDESCRIPTION: Custom string type coercion transform that recreates legacy behavior of converting objects and arrays to strings via toString().\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nstring().transform((_, input) => input != null && input.toString ? input.toString() : value);\n```\n\n----------------------------------------\n\nTITLE: Array Creation Alternative Example\nDESCRIPTION: Demonstrates alternative syntax for creating array schemas\nSOURCE: https://github.com/jquense/yup/blob/master/README.md#2025-04-18_snippet_56\n\nLANGUAGE: javascript\nCODE:\n```\narray().of(yup.number());\n// or\narray(yup.number());\n```\n\n----------------------------------------\n\nTITLE: Listing New Features in Markdown\nDESCRIPTION: Uses Markdown syntax to enumerate new features added in a release, with links to relevant commits.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_2\n\nLANGUAGE: Markdown\nCODE:\n```\n### Features\n\n* expose LazySchema ([2b0f126](https://github.com/jquense/yup/commit/2b0f1264083fccb646f7f6bd43adfbff2caaf295))\n```\n\n----------------------------------------\n\nTITLE: Specifying Bug Fixes in Markdown\nDESCRIPTION: Uses Markdown syntax to list bug fixes made in a particular release, including a link to the relevant commit.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n### Bug Fixes\n\n* lazy validation errors thrown in builders should resolve async like other validations ([c7d7f97](https://github.com/jquense/yup/commit/c7d7f977e02a7e578950dff192057e0b200999bd))\n```\n\n----------------------------------------\n\nTITLE: Defining Version and Date in Markdown\nDESCRIPTION: Uses Markdown syntax to specify the version number and release date for a particular release of the Yup library.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n## [1.6.1](https://github.com/jquense/yup/compare/v1.6.0...v1.6.1) (2024-12-17)\n```\n\n----------------------------------------\n\nTITLE: Documenting Version Changes in Markdown\nDESCRIPTION: This snippet shows the format used to document version changes in the Yup changelog. It includes version numbers, dates, and descriptions of changes made in each release.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n## v0.22.1 - Thu, 12 Oct 2017 14:49:16 GMT\n\n- Fix bug in browsers without symbol [#132](https://github.com/jquense/yup/pull/132)\n\n## v0.22.0 - Sat, 26 Aug 2017 14:48:57 GMT\n\n** Breaking **\n\n- Use native Set and lodash CloneDeep: [#109](https://github.com/jquense/yup/pull/109)\n\n\\*\\* Fixes and Features\n\n- Better custom locale support: [#105](https://github.com/jquense/yup/pull/105)\n- fix some messages: [#112](https://github.com/jquense/yup/pull/112)\n- Clearer errors for common mistakes: [#108](https://github.com/jquense/yup/pull/108)\n- New string validation length: [#67](https://github.com/jquense/yup/pull/67)\n```\n\n----------------------------------------\n\nTITLE: Documenting Commit Changes in Markdown\nDESCRIPTION: This snippet demonstrates how individual commit changes are documented in the changelog, including commit hashes and descriptions of the changes made.\nSOURCE: https://github.com/jquense/yup/blob/master/CHANGELOG.md#2025-04-18_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n## v0.21.3 - Wed, 18 Jan 2017 15:39:25 GMT\n\n- [7bc01e0](../../commit/7bc01e0) [added] deep path support for `from`\n\n## v0.21.2 - Fri, 09 Sep 2016 16:52:44 GMT\n\n- [be80413](../../commit/be80413) [fixed] default in concat()\n```"
  }
]