[
  {
    "owner": "emurgo",
    "repo": "cardano-serialization-lib",
    "content": "TITLE: Initializing Transaction Builder with Protocol Parameters - JavaScript\nDESCRIPTION: This snippet initializes the TransactionBuilder with Cardano protocol parameters such as linear fee, pool deposit, key deposit, max value size, max transaction size, and coins per UTxO word. It uses the TransactionBuilderConfigBuilder to set these parameters and create a TransactionBuilder instance. These parameters are critical for creating valid transactions on the Cardano network.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// instantiate the tx builder with the Cardano protocol parameters - these may change later on\nconst linearFee = CardanoWasm.LinearFee.new(\n    CardanoWasm.BigNum.from_str('44'),\n    CardanoWasm.BigNum.from_str('155381')\n);\nconst txBuilderCfg = CardanoWasm.TransactionBuilderConfigBuilder.new()\n    .fee_algo(linearFee)\n    .pool_deposit(CardanoWasm.BigNum.from_str('500000000'))\n    .key_deposit(CardanoWasm.BigNum.from_str('2000000'))\n    .max_value_size(4000)\n    .max_tx_size(8000)\n    .coins_per_utxo_word(CardanoWasm.BigNum.from_str('34482'))\n    .build();\nconst txBuilder = CardanoWasm.TransactionBuilder.new(txBuilderCfg);\n```\n\n----------------------------------------\n\nTITLE: Adding UTXOs to Transaction - JavaScript\nDESCRIPTION: This snippet adds UTXOs (Unspent Transaction Outputs) to the transaction builder. It iterates through an array of UTXO hex strings, converts them into TransactionUnspentOutput objects, and adds them to the wasmUtxos collection.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst utxos = [\n    \"82825820731224c9d2bc3528578009fec9f9e34a67110aca2bd4dde0f050845a2daf660d0082583900436075347d6a452eba4289ae345a8eb15e73eb80979a7e817d988fc56c8e2cfd5a9478355fa1d60759f93751237af3299d7faa947023e493821a001deabfa1581c9a5e0d55cdf4ce4e19c8acbff7b4dafc890af67a594a4c46d7dd1c0fa14001\",\n    \"82825820a04996d5ef87fdece0c74625f02ee5c1497a06e0e476c5095a6b0626b295074a00825839001772f234940519e71318bb9c5c8ad6eacfe8fd91a509050624e3855e6c8e2cfd5a9478355fa1d60759f93751237af3299d7faa947023e4931a0016e360\"\n]\nconst output = wasm.TransactionOutput.new(wasm.Address.from_bech32(\"addr_test1qppkqaf5044y2t46g2y6udz636c4uultszte5l5p0kvgl3tv3ck06k550q64lgwkqavljd63yda0x2va074fguprujfsjre4xh\"), wasm.Value.new(wasm.BigNum.from_str(\"969750\")))\ntxBuilder.add_output(output)\n\nconst wasmUtxos = wasm.TransactionUnspentOutputs.new();\nfor (let i = 0; i < utxos.length; i++) {\n    wasmUtxos.add(wasm.TransactionUnspentOutput.from_hex(utxos[i]));\n    }\n```\n\n----------------------------------------\n\nTITLE: Adding Output to Transaction - JavaScript\nDESCRIPTION: This snippet adds a transaction output using the `add_output` method. It uses a Shelley address and a value to specify the destination and amount of ADA to be sent in the transaction.  It demonstrates how to create a new TransactionOutput object using an address and a value (BigNum).\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// base address\nconst shelleyOutputAddress = CardanoWasm.Address.from_bech32(\"addr_test1qpu5vlrf4xkxv2qpwngf6cjhtw542ayty80v8dyr49rf5ewvxwdrt70qlcpeeagscasafhffqsxy36t90ldv06wqrk2qum8x5w\");\n// pointer address\nconst shelleyChangeAddress = CardanoWasm.Address.from_bech32(\"addr_test1gz2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzerspqgpsqe70et\");\n\n// add output to the tx\ntxBuilder.add_output(\n    CardanoWasm.TransactionOutput.new(\n    shelleyOutputAddress,\n    CardanoWasm.Value.new(CardanoWasm.BigNum.from_str('1000000'))    \n    ),\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Metadata Map in Cardano\nDESCRIPTION: This snippet demonstrates how to create a MetadataMap and insert key-value pairs using the CardanoWasm library. It shows how to construct TransactionMetadatum objects with text and integer values and add them to the map. The code effectively recreates the JSON metadata example using Cardano's native structures, representing receiver ID, sender ID, comment, and a list of tags.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst map = CardanoWasm.MetadataMap.new();\nmap.insert(\n  CardanoWasm.TransactionMetadatum.new_text(\"receiver_id\"),\n  CardanoWasm.TransactionMetadatum.new_text(\"SJKdj34k3jjKFDKfjFUDfdjkfd\"),\n);\nmap.insert(\n  CardanoWasm.TransactionMetadatum.new_text(\"sender_id\"),\n  CardanoWasm.TransactionMetadatum.new_text(\"jkfdsufjdk34h3Sdfjdhfduf873\"),\n);\nmap.insert(\n  CardanoWasm.TransactionMetadatum.new_text(\"comment\"),\n  CardanoWasm.TransactionMetadatum.new_text(\"happy birthday\"),\n);\nconst tags = CardanoWasm.MetadataList.new();\ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new(CardanoWasm.BigNum.from_str(\"0\"))));\ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new(CardanoWasm.BigNum.from_str(\"264\"))));\ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new_negative(CardanoWasm.BigNum.from_str(\"1024\"))));\ntags.add(CardanoWasm.TransactionMetadatum.new_int(CardanoWasm.Int.new(CardanoWasm.BigNum.from_str(\"32\"))));\nmap.insert(\n  CardanoWasm.TransactionMetadatum.new_text(\"tags\"),\n  CardanoWasm.TransactionMetadatum.new_list(tags),\n);\nconst metadatum = CardanoWasm.TransactionMetadatum.new_map(map);\n```\n\n----------------------------------------\n\nTITLE: Generating BIP32 Key from BIP39 Entropy\nDESCRIPTION: This JavaScript snippet shows how to generate a root `BIP32PrivateKey` from a BIP39 mnemonic.  It utilizes the `bip39` npm package to convert the mnemonic phrase into entropy.  The generated entropy is then used by `CardanoWasm.Bip32PrivateKey.from_bip39_entropy` to derive the root key. It depends on the CardanoWasm and bip39 libraries.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-keys.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { mnemonicToEntropy } from 'bip39';\n\nconst entropy = mnemonicToEntropy(\n  [ \"test\", \"walk\", \"nut\", \"penalty\", \"hip\", \"pave\", \"soap\", \"entry\", \"language\", \"right\", \"filter\", \"choice\" ].join(' ')\n);\n\nconst rootKey = CardanoWasm.Bip32PrivateKey.from_bip39_entropy(\n  Buffer.from(entropy, 'hex'),\n  Buffer.from(''),\n);\n```\n\n----------------------------------------\n\nTITLE: Adding Change Output and Calculating Fee - JavaScript\nDESCRIPTION: This snippet adds a change output and calculates the minimum fee required for the transaction using the `add_change_if_needed` method. It sends any remaining ADA (inputs + withdrawals - outputs + refund - deposit - min fee) to the specified change address. It is important to add the change output last because any modifications to the transaction can impact its size and fee.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// calculate the min fee required and send any change to an address\ntxBuilder.add_change_if_needed(shelleyChangeAddress);\n```\n\n----------------------------------------\n\nTITLE: Deriving BIP32 Keys\nDESCRIPTION: This JavaScript snippet demonstrates how to derive BIP32 keys from a root key using the BIP44 specification. It uses the `BIP32PrivateKey` class to derive account, UTxO public, and stake keys from a Bech32-encoded root key. The snippet depends on the CardanoWasm library.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-keys.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction harden(num: number): number {\n  return 0x80000000 + num;\n}\n\n\nconst rootKey = CardanoWasm.BIP32PrivateKey.from_bech32(\"xprv17qx9vxm6060qjn5fgazfue9nwyf448w7upk60c3epln82vumg9r9kxzsud9uv5rfscxp382j2aku254zj3qfx9fx39t6hjwtmwq85uunsd8x0st3j66lzf5yn30hwq5n75zeuplepx8vxc502txx09ygjgx06n0p\");\nconst accountKey = rootKey\n  .derive(harden(1852)) // purpose\n  .derive(harden(1815)) // coin type\n  .derive(harden(0)); // account #0\n\nconst utxoPubKey = accountKey\n  .derive(0) // external\n  .derive(0)\n  .to_public();\n\nconst stakeKey = accountKey\n  .derive(2) // chimeric\n  .derive(0)\n  .to_public();\n```\n\n----------------------------------------\n\nTITLE: Mint NFT Function Definition (JavaScript)\nDESCRIPTION: This function defines the process for minting an NFT. It takes the private key, policy, asset name, description, image URL, and media type as input.  It fetches UTXOs, builds the transaction with minting script, sets metadata, signs and submits to the Yoroi backend. It depends on cardano-serialization-lib and axios.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/minting-nfts.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst mintNft = async (\n  privateKey,\n  policy,\n  assetName,\n  description,\n  imageUrl,\n  mediaType\n) => {\n  const FEE = 300000;\n\n  const publicKey = privateKey.to_public();\n\n  const addr = CardanoWasm.BaseAddress.new(\n    CardanoWasm.NetworkInfo.testnet().network_id(),\n    CardanoWasm.StakeCredential.from_keyhash(publicKey.hash()),\n    CardanoWasm.StakeCredential.from_keyhash(publicKey.hash())\n  ).to_address();\n\n  const policyPubKey = policy.privateKey.to_public();\n\n  const policyAddr = CardanoWasm.BaseAddress.new(\n    CardanoWasm.NetworkInfo.testnet().network_id(),\n    CardanoWasm.StakeCredential.from_keyhash(policyPubKey.hash()),\n    CardanoWasm.StakeCredential.from_keyhash(policyPubKey.hash())\n  ).to_address();\n\n  console.log(`ADDR: ${addr.to_bech32()}`);\n\n  // get utxos for our address and select one that is probably big enough to pay the tx fee\n  const utxoRes = await axios.post(\n    \"https://testnet-backend.yoroiwallet.com/api/txs/utxoForAddresses\",\n    {\n      addresses: [addr.to_bech32()],\n    }\n  );\n\n  let utxo = null;\n\n  if (utxoRes.data) {\n    for (const utxoEntry of utxoRes.data) {\n      if (utxoEntry.amount > FEE) {\n        utxo = utxoEntry;\n      }\n    }\n  }\n\n  if (utxo === null) {\n    throw new Error(\"no utxo found with sufficient ADA.\");\n  }\n\n  console.log(`UTXO: ${JSON.stringify(utxo, null, 4)}`);\n\n  // get current global slot from yoroi backend\n  const { data: slotData } = await axios.get(\n    \"https://testnet-backend.yoroiwallet.com/api/v2/bestblock\"\n  );\n\n  const ttl = slotData.globalSlot + 60 * 60 * 2;  // two hours from now\n\n  const txBuilder = CardanoWasm.TransactionBuilder.new(\n    CardanoWasm.TransactionBuilderConfigBuilder.new()\n      .fee_algo(\n        CardanoWasm.LinearFee.new(\n          CardanoWasm.BigNum.from_str(\"44\"),\n          CardanoWasm.BigNum.from_str(\"155381\")\n        )\n      )\n      .coins_per_utxo_word(CardanoWasm.BigNum.from_str(\"34482\"))\n      .pool_deposit(CardanoWasm.BigNum.from_str(\"500000000\"))\n      .key_deposit(CardanoWasm.BigNum.from_str(\"2000000\"))\n      .max_value_size(5000)\n      .max_tx_size(16384)\n      .build()\n  );\n\n  const scripts = CardanoWasm.NativeScripts.new();\n\n  const policyKeyHash = CardanoWasm.BaseAddress.from_address(policyAddr)\n    .payment_cred()\n    .to_keyhash();\n\n  console.log(\n    `POLICY_KEYHASH: ${Buffer.from(policyKeyHash.to_bytes()).toString(\"hex\")}`\n  );\n\n  // add key hash script so only people with policy key can mint assets using this policyId\n  const keyHashScript = CardanoWasm.NativeScript.new_script_pubkey(\n    CardanoWasm.ScriptPubkey.new(policyKeyHash)\n  );\n  scripts.add(keyHashScript);\n\n  const policyTtl = policy.ttl || ttl;\n\n  console.log(`POLICY_TTL: ${policyTtl}`);\n\n  // add timelock so policy is locked after this slot\n  const timelock = CardanoWasm.TimelockExpiry.new(policyTtl);\n  const timelockScript = CardanoWasm.NativeScript.new_timelock_expiry(timelock);\n  scripts.add(timelockScript);\n\n  const mintScript = CardanoWasm.NativeScript.new_script_all(\n    CardanoWasm.ScriptAll.new(scripts)\n  );\n\n  const privKeyHash = CardanoWasm.BaseAddress.from_address(addr)\n    .payment_cred()\n    .to_keyhash();\n  txBuilder.add_key_input(\n    privKeyHash,\n    CardanoWasm.TransactionInput.new(\n      CardanoWasm.TransactionHash.from_bytes(Buffer.from(utxo.tx_hash, \"hex\")),\n      utxo.tx_index\n    ),\n    CardanoWasm.Value.new(CardanoWasm.BigNum.from_str(utxo.amount))\n  );\n\n  txBuilder.add_mint_asset_and_output_min_required_coin(\n    mintScript,\n    CardanoWasm.AssetName.new(Buffer.from(assetName)),\n    CardanoWasm.Int.new_i32(1),\n    CardanoWasm.TransactionOutputBuilder.new().with_address(addr).next()\n  );\n\n  const policyId = Buffer.from(mintScript.hash().to_bytes()).toString(\"hex\");\n\n  console.log(`POLICY_ID: ${policyId}`);\n\n  const metadata = {\n    [policyId]: {\n      [assetName]: {\n        name: assetName,\n        description,\n        image: imageUrl,\n        mediaType,\n      },\n    },\n  };\n\n  console.log(`METADATA: ${JSON.stringify(metadata, null, 4)}`);\n\n  // transaction ttl can't be later than policy ttl\n  const txTtl = ttl > policyTtl ? policyTtl : ttl;\n\n  console.log(`TX_TTL: ${txTtl}`);\n\n  txBuilder.set_ttl(txTtl);\n  txBuilder.add_json_metadatum(\n    CardanoWasm.BigNum.from_str(\"721\"),\n    JSON.stringify(metadata)\n  );\n\n  txBuilder.add_change_if_needed(addr);\n\n  const txBody = txBuilder.build();\n  const txHash = CardanoWasm.hash_transaction(txBody);\n\n  console.log(`TX_HASH: ${Buffer.from(txHash.to_bytes()).toString(\"hex\")}`);\n\n  // sign the tx using the policy key and main key\n  const witnesses = CardanoWasm.TransactionWitnessSet.new();\n  const vkeyWitnesses = CardanoWasm.Vkeywitnesses.new();\n  vkeyWitnesses.add(CardanoWasm.make_vkey_witness(txHash, policy.privateKey));\n  vkeyWitnesses.add(CardanoWasm.make_vkey_witness(txHash, privateKey));\n  witnesses.set_vkeys(vkeyWitnesses);\n  witnesses.set_native_scripts;\n  const witnessScripts = CardanoWasm.NativeScripts.new();\n  witnessScripts.add(mintScript);\n  witnesses.set_native_scripts(witnessScripts);\n\n  const unsignedTx = txBuilder.build_tx();\n\n  // create signed transaction\n  const tx = CardanoWasm.Transaction.new(\n    unsignedTx.body(),\n    witnesses,\n    unsignedTx.auxiliary_data()\n  );\n\n  const signedTx = Buffer.from(tx.to_bytes()).toString(\"base64\");\n\n  // submit the transaction using yoroi backend\n  try {\n    const { data } = await axios.post(\n      \"https://testnet-backend.yoroiwallet.com/api/txs/signed\",\n      {\n        signedTx,\n      }\n    );\n\n    console.log(`SUBMIT_RESULT: ${JSON.stringify(data, null, 4)}`);\n  } catch (error) {\n    console.error(\n      `failed to submit tx via yoroi backend: ${error.toString()}. error details: ${JSON.stringify(\n        error.response?.data\n      )}`\n    );\n  }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Adding Input and Change address - JavaScript\nDESCRIPTION: This code adds inputs from the UTXOs and sets the change address for the transaction. It uses the LargestFirstMultiAsset coin selection strategy and a pre-configured change address to handle any remaining balance after the transaction.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst wasmChangeConfig = wasm.ChangeConfig.new(wasm.Address.from_bech32(\"addr_test1qqzf7fhgm0gf370ngxgpskg5c3kgp2g0u4ltxlrmsvumaztv3ck06k550q64lgwkqavljd63yda0x2va074fguprujfs43mc83\"))\n\ntxBuilder.add_inputs_from_and_change(wasmUtxos, wasm.CoinSelectionStrategyCIP2.LargestFirstMultiAsset, wasmChangeConfig)\n```\n\n----------------------------------------\n\nTITLE: Building the Transaction - JavaScript\nDESCRIPTION: This snippet builds the final transaction using the transaction builder. It utilizes previously configured inputs, outputs, and change address to assemble the complete transaction object.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_13\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst transaction = txBuilder.build_tx()\n```\n\n----------------------------------------\n\nTITLE: Deriving Keys from Mnemonic in JavaScript\nDESCRIPTION: This code derives the keys (root, account, stake, and UTXO private keys) from a given mnemonic using the Bip32PrivateKey class. It uses the bip39 library to convert the mnemonic to entropy. The derived keys are used for creating addresses and signing transactions. It requires the mnemonic as input and the bip39 and @emurgo/cardano-serialization-lib-nodejs libraries.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/delegate-to-abstain.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { mnemonicToEntropy } from \"bip39\";\n\nconst MNEMONIC = \"your mnemonic\";\n\nfunction harden(num: number): number {\n  return 0x80000000 + num;\n}\n\n  // derive the keys from mnemonic\n  const entropy = mnemonicToEntropy(MNEMONIC!);\n  const rootKey = Bip32PrivateKey.from_bip39_entropy(\n    Buffer.from(entropy, \"hex\"),\n    Buffer.from(\"\")\n  );\n\n  const accountKey = rootKey\n    .derive(harden(1852))\n    .derive(harden(1815))\n    .derive(harden(0));\n  const stakePrivKey = accountKey.derive(2).derive(0);\n  const utxoPrivKey = accountKey.derive(0).derive(0);\n```\n\n----------------------------------------\n\nTITLE: Encoding and Decoding Arbitrary Bytes as Metadata in CardanoWasm\nDESCRIPTION: This JavaScript code snippet demonstrates encoding arbitrary bytes as metadata using `CardanoWasm.encode_arbitrary_bytes_as_metadatum` and decoding them back using `CardanoWasm.decode_arbitrary_bytes_from_metadatum`.  The snippet assumes you have a byte array `bytes` generated from some method (potentially the CDDL solution mentioned). It also asserts that the decoded bytes match the original bytes.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nconst bytes = /* whatever method you want - you can use the CDDL solution in the 3rd option here */\nconst metadata = CardanoWasm.encode_arbitrary_bytes_as_metadatum(bytes);\nconst decoded_bytes = CardanoWasm.decode_arbitrary_bytes_from_metadatum(metadata);\nassertEquals(bytes, decoded_bytes);\n```\n\n----------------------------------------\n\nTITLE: Building Transaction Body and Hashing - JavaScript\nDESCRIPTION: This snippet builds the transaction body without witnesses using the `build` method and then calculates the transaction hash using `hash_transaction`. The transaction hash is essential for creating the transaction witnesses.  The returned `txBody` is a `TransactionBody` and `txHash` is the `Hash32` of the transaction body.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// once the transaction is ready, we build it to get the tx body without witnesses\nconst txBody = txBuilder.build();\nconst txHash = CardanoWasm.hash_transaction(txBody);\n```\n\n----------------------------------------\n\nTITLE: Adding Keyhash Witnesses to Transaction - JavaScript\nDESCRIPTION: This snippet adds keyhash witnesses to the transaction. It creates a Vkeywitnesses object, generates a Vkeywitness using `make_vkey_witness`, adds it to the Vkeywitnesses object, and then sets the Vkeywitnesses object in the TransactionWitnessSet. The `prvKey` from previous step is used to sign the transaction.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// add keyhash witnesses\nconst witnesses = CardanoWasm.TransactionWitnessSet.new();\nconst vkeyWitnesses = CardanoWasm.Vkeywitnesses.new();\nconst vkeyWitness = CardanoWasm.make_vkey_witness(txHash, prvKey);\nvkeyWitnesses.add(vkeyWitness);\nwitnesses.set_vkeys(vkeyWitnesses);\n```\n\n----------------------------------------\n\nTITLE: Recursive Metadata Parsing in Cardano\nDESCRIPTION: This JavaScript function `parseMetadata` recursively parses a `TransactionMetadatum` struct from the CardanoWasm library into a JavaScript Map/object. It checks the metadata's type using `metadata.kind()` and then processes it accordingly. It handles MetadataMap, MetadataList, Int, Bytes, and Text types, converting them into corresponding JavaScript data structures.  Big integers that are too large for `as_i32()` are explicitly mentioned to be handled using `as_positive()`/`as_negative()` and conversion from BigNums.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction parseMetadata(metadata) {\n  // we must check the type first to know how to handle it\n  switch (metadata.kind()) {\n    case CardanoWasm.TransactionMetadatumKind.MetadataMap:\n      const mapRet = new Map();\n      const map = metadata.as_map();\n      const keys = maps.keys();\n      for (var i = 0; i < keys.len(); i += 1) {\n        const key = keys.get(i);\n        const value = parseMetadata(map.get(key);\n        mapRet.set(key, value);\n      }\n      return mapRet;\n    case CardanoWasm.TransactionMetadatumKind.MetadataList:\n      let arrRet = [];\n      const arr = metadata.as_list();\n      for (var i = 0; i < arr.len(); i += 1) {\n        const elem = parseMetadata(arr.get(i));\n        arrRet.push(elem);\n      }\n      return arrRet;\n    case CardanoWasm.TransactionMetadatumKind.Int:\n      const x = metadata.as_int();\n      // If the integer is too big as_i32() returns undefined\n      // to handle larger numbers we need to use x.as_positive() / x.as_negative() and\n      // convert from BigNums after checking x.is_positive() first\n      return x.as_i32();\n    case CardanoWasm.TransactionMetadatumKind.Bytes:\n      return Buffer.from(metadata.as_bytes());\n    case CardanoWasm.TransactionMetadatumKind.Text:\n      return metadata.as_text();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Cardano Addresses\nDESCRIPTION: This JavaScript code illustrates the creation of various types of Cardano addresses using derived public keys. It shows how to create BaseAddress, EnterpriseAddress, PointerAddress, RewardAddress, and ByronAddress, each with specific properties related to staking and network configurations. It depends on the CardanoWasm library.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-keys.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\n// base address with staking key\nconst baseAddr = CardanoWasm.BaseAddress.new(\n  CardanoWasm.NetworkInfo.mainnet().network_id(),\n  CardanoWasm.StakeCredential.from_keyhash(utxoPubKey.to_raw_key().hash()),\n  CardanoWasm.StakeCredential.from_keyhash(stakeKey.to_raw_key().hash()),\n);\n\n// enterprise address without staking ability, for use by exchanges/etc\nconst enterpriseAddr = CardanoWasm.EnterpriseAddress.new(\n  CardanoWasm.NetworkInfo.mainnet().network_id(),\n  CardanoWasm.StakeCredential.from_keyhash(utxoPubKey.to_raw_key().hash())\n);\n\n// pointer address - similar to Base address but can be shorter, see formal spec for explanation\nconst ptrAddr = CardanoWasm.PointerAddress.new(\n  CardanoWasm.NetworkInfo.mainnet().network_id(),\n  CardanoWasm.StakeCredential.from_keyhash(utxoPubKey.to_raw_key().hash()),\n  CardanoWasm.Pointer.new(\n    100, // slot\n    2,   // tx index in slot\n    0    // cert indiex in tx\n  )\n);\n\n// reward address - used for withdrawing accumulated staking rewards\nconst rewardAddr = CardanoWasm.RewardAddress.new(\n  CardanoWasm.NetworkInfo.mainnet().network_id(),\n  CardanoWasm.StakeCredential.from_keyhash(stakeKey.to_raw_key().hash())\n);\n\n// bootstrap address - byron-era addresses with no staking rights\nconst byronAddr = CardanoWasm.ByronAddress.icarus_from_key(\n  utxoPubKey, // Ae2* style icarus address\n  CardanoWasm.NetworkInfo.mainnet().protocol_magic()\n);\n```\n\n----------------------------------------\n\nTITLE: Creating Finalized Transaction - JavaScript\nDESCRIPTION: This snippet creates the finalized transaction by combining the transaction body, witnesses, and optional metadata.  It uses the `Transaction.new` constructor to create the final transaction object. The created transaction is ready to be submitted to the Cardano network.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n// create the finalized transaction with witnesses\nconst transaction = CardanoWasm.Transaction.new(\n    txBody,\n    witnesses,\n    undefined, // transaction metadata\n);\n```\n\n----------------------------------------\n\nTITLE: Signing Cardano Transaction in JavaScript\nDESCRIPTION: This snippet demonstrates how to sign a Cardano transaction using stake and payment keys. It creates a FixedTransaction from the transaction body bytes and adds signatures from both stake and UTXO private keys. It relies on the FixedTransaction object and the private keys derived from the mnemonic phrase.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/delegate-to-abstain.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n  const txBody = txBuilder.build();\n\n  //Use FixedTransaction for each time when you need to sign a transaction, especially if you recieved it from a third party\n  const transaction = FixedTransaction.new_from_body_bytes(txBody.to_bytes());\n\n  // sign the tx with stake and payment keys\n  transaction.sign_and_add_vkey_signature(stakePrivKey.to_raw_key());\n  transaction.sign_and_add_vkey_signature(utxoPrivKey.to_raw_key());\n\n  // CBOR\n  console.log(transaction.to_hex());\n```\n\n----------------------------------------\n\nTITLE: Creating Vote Delegation Certificate for Abstain in JavaScript\nDESCRIPTION: This snippet creates a vote delegation certificate that delegates votes to always abstain. It instantiates a new 'Always Abstain' DRep, creates a VoteDelegation object linking the stake key hash to the DRep, and adds the vote delegation certificate to the transaction builder. Dependencies include the stake private key and the Cardano Serialization Lib.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/delegate-to-abstain.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n  // create new \"Always Abstain\" DRep and Vote Delegation\n  const drep = DRep.new_always_abstain();\n  const voteDelegation = VoteDelegation.new(\n    Credential.from_keyhash(stakePrivKey.to_public().to_raw_key().hash()),\n    drep\n  );\n\n  // add vote delegation certificate to the txBuilder\n  const certs = Certificates.new();\n  certs.add(Certificate.new_vote_delegation(voteDelegation));\n  txBuilder.set_certs(certs);\n```\n\n----------------------------------------\n\nTITLE: NFT Minting Execution (JavaScript)\nDESCRIPTION: This code snippet executes the NFT minting process using a pre-defined private key and policy key. It initializes the CardanoWasm library, defines the NFT metadata, and calls the `mintNft` function to create and submit the transaction.  It handles potential errors during the minting process.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/minting-nfts.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ntry {\n  const privateKey = CardanoWasm.PrivateKey.from_bech32(\n    //\"ed25519_sk1fde2u8u2qme8uau5ac3w6c082gvtnmxt6uke2w8e07xwzewxee3q3n0f8e\"\n    \"ed25519_sk18j0a6704zyerm6dsj6p2fp8juw5m43rfgk0y84jnm7w5khs4dpqquewh43\"\n  );\n\n  console.log(`PRIVATE KEY: ${privateKey.to_bech32()}`);\n\n  /*\n  const policyPrivateKey = CardanoWasm.PrivateKey.from_bech32(\n    \"ed25519_sk1q96x2g66j5g7u5wydl7kcagk0h8upxznt3gj48h6njqthkyr7faqxmnnte\"\n  );\n  */\n\n  // import policy key from a .skey file\n  const policyPrivateKey = CardanoWasm.PrivateKey.from_normal_bytes(\n    cbor.decodeFirstSync(\n      \"582009ca7f508dd5a5f9823d367e98170f25606799f49ae7363a47a11d7d3502c91f\"\n    )\n  );\n\n  console.log(`POLICY_PRIV_KEY: ${policyPrivateKey.to_bech32()}`);\n\n  await mintNft(\n    privateKey, // main key\n    {\n      privateKey: policyPrivateKey, // policy key\n      // pass null here to get automatic ttl for policy\n      // and paste the POLICY_TTL output you get in console to here to mint with same policy\n      ttl: null, // policy ttl\n    },\n    \"asdNFT5\", // assetName\n    \"some descr this is a new nft with same policy\", // description\n    \"ipfs://QmNhmDPJMgdsFRM9HyiQEJqrKkpsWFshqES8mPaiFRq9Zk\", // image url\n    \"image/jpeg\" // mediaType\n  );\n} catch (err) {\n  console.error(`failed to mint nft: ${err.toString()}`);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Adding Keyhash Input to Transaction - JavaScript\nDESCRIPTION: This snippet demonstrates how to add a keyhash input to a transaction using the `add_key_input` method of the TransactionBuilder. It retrieves a private key, calculates its public key hash, and adds it as an input with a specified transaction hash, index, and value. This input represents ADA held in a Shelley-era normal address (Base, Enterprise, Pointer).\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// add a keyhash input - for ADA held in a Shelley-era normal address (Base, Enterprise, Pointer)\nconst prvKey = CardanoWasm.PrivateKey.from_bech32(\"ed25519e_sk16rl5fqqf4mg27syjzjrq8h3vq44jnnv52mvyzdttldszjj7a64xtmjwgjtfy25lu0xmv40306lj9pcqpa6slry9eh3mtlqvfjz93vuq0grl80\");\ntxBuilder.add_key_input(\n    prvKey.to_public().hash(),\n    CardanoWasm.TransactionInput.new(\n        CardanoWasm.TransactionHash.from_bytes(\n            Buffer.from(\"8561258e210352fba2ac0488afed67b3427a27ccf1d41ec030c98a8199bc22ec\", \"hex\")\n        ), // tx hash\n        0, // index\n    ),\n    CardanoWasm.Value.new(CardanoWasm.BigNum.from_str('3000000'))\n);\n```\n\n----------------------------------------\n\nTITLE: Parsing Metadata Map in Cardano\nDESCRIPTION: This snippet shows how to parse a Cardano MetadataMap and retrieve values associated with specific keys. It utilizes the `as_map()` method to access the map's content and the `get()` method to fetch values. A try-catch block handles potential exceptions if the expected structure doesn't match, demonstrating error handling when working with metadata.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ntry {\n  const map = metadatum.as_map();\n  const receiver = map.get(CardanoWasm.TransactionMetadatum.new_text(\"receiver_id\"));\n  const sender = map.get(CardanoWasm.TransactionMetadatum.new_text(\"sender_id\"));\n  const comment = map.get(CardanoWasm.TransactionMetadatum.new_text(\"comment\"));\n  const tags = map.get(CardanoWasm.TransactionMetadatum.new_text(\"tags\"));\n} catch (e) {\n  // structure did not match\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Cardano Transaction Builder Configuration in JavaScript\nDESCRIPTION: This snippet initializes the TransactionBuilderConfigBuilder with Cardano protocol parameters like fees, deposits, and maximum sizes.  It sets the linear fee, pool deposit, key deposit, max value size, max transaction size, coins per UTXO byte, and ex unit prices. These parameters are crucial for determining the transaction fees and validity.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/delegate-to-abstain.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst linearFee = LinearFee.new(\n    BigNum.from_str(\"44\"),\n    BigNum.from_str(\"155381\")\n  );\n\n  // these parameters is used as an example, you should use the latest actual protocol params from cardano-node, cardano-cli or from 3rd party API providers\n  const txBuilderCfg = TransactionBuilderConfigBuilder.new()\n    .fee_algo(linearFee)\n    .pool_deposit(BigNum.from_str(\"500000000\"))\n    .key_deposit(BigNum.from_str(\"2000000\"))\n    .max_value_size(5000)\n    .max_tx_size(16384)\n    .coins_per_utxo_byte(BigNum.from_str(\"4310\"))\n    .ex_unit_prices(ExUnitPrices.new(\n      UnitInterval.new(\n        BigNum.from_str(\"577\"),\n        BigNum.from_str(\"10000\")\n      ),\n      UnitInterval.new(\n        BigNum.from_str(\"721\"),\n        BigNum.from_str(\"10000000\")\n      )\n    ))\n    .build();\n    .build();\n```\n\n----------------------------------------\n\nTITLE: Setting Time to Live (TTL) for Transaction - JavaScript\nDESCRIPTION: This snippet sets the time-to-live (TTL) for the transaction using the `set_ttl` method.  The TTL is specified as an absolute slot value, after which the transaction becomes invalid. This ensures that the transaction is only valid within a specific time window.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// set the time to live - the absolute slot value before the tx becomes invalid\ntxBuilder.set_ttl(410021);\n```\n\n----------------------------------------\n\nTITLE: Metadata Parsing via CDDL: JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates parsing Cardano metadata back into a CDDL-defined object using the generated library.  It shows how to convert metadata bytes back into an instance of the `Foo` type and how to access the fields of the object.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nlet cddlMetadata;\ntry {\n  cddlMetadata = OurMetadataLib.Foo.from_bytes(metadata.to_bytes());\n} catch (e) {\n  // this should never happen if OurMetadataLib was generated from compatible CDDL with the metadata definition\n}\n// we can now directly access the fields with cddlMetadata.receiver_id(), etc\n```\n\n----------------------------------------\n\nTITLE: JSON Example: Detailed Schema (Complex Key)\nDESCRIPTION: This JSON snippet illustrates a more complex key using the `DetailedSchema`. The key is a list containing a map and a bytestring. This shows the flexibility of `DetailedSchema` to represent arbitrary metadata, including complex keys.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\"map\":[\n  {\n    \"k\":{\"list\":[\n      {\"map\": [\n        {\n          \"k\": {\"int\": 5},\n          \"v\": {\"int\": 7}\n        },\n        {\n          \"k\": {\"string\": \"hello\"},\n          \"v\": {\"string\": \"world\"}\n        }\n      ]},\n      {\"bytes\": \"ff00ff00\"}\n    ]},\n    \"v\":{\"int\":5}\n  }\n]}\n```\n\n----------------------------------------\n\nTITLE: Simplified Metadata Construction with i32: JavaScript\nDESCRIPTION: This JavaScript snippet shows a simplified approach to metadata construction using `i32` types in CDDL, allowing direct use of JavaScript numbers. It demonstrates how to create a `Foo` object with a list of 32-bit integers directly from a JavaScript array. The CDDL definition for `tags` is assumed to be `[+i32]`.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\n// notice how we can directly work with js numbers here now!\n// but remember they must fit into a 32-bit number now - no 64-bit numbers like are allowed in the metadata\nconst tags = [0, 264, -1024, 32];\nconst map = OurMetadataLib.Foo.new(\"SJKdj34k3jjKFDKfjFUDfdjkfd\", \"jkfdsufjdk34h3Sdfjdhfduf873\", \"happy birthday\", tags)\n```\n\n----------------------------------------\n\nTITLE: Initializing Transaction Builder Config - JavaScript\nDESCRIPTION: This code snippet initializes the TransactionBuilder with various configuration settings such as fees, UTXO costs, deposits, unit prices, and maximum transaction sizes. It uses the wasm.TransactionBuilderConfigBuilder to set these parameters.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst txBuilder = wasm.TransactionBuilder.new(\n    wasm.TransactionBuilderConfigBuilder.new()\n      .fee_algo(wasm.LinearFee.new(wasm.BigNum.from_str('44'), wasm.BigNum.from_str('155381')))\n      .coins_per_utxo_word(wasm.BigNum.from_str('34482'))\n      .pool_deposit(wasm.BigNum.from_str('500000000'))\n      .key_deposit(wasm.BigNum.from_str('2000000'))\n      .ex_unit_prices(\n        wasm.ExUnitPrices.new(\n          wasm.UnitInterval.new(wasm.BigNum.from_str('577'), wasm.BigNum.from_str('10000')),\n          wasm.UnitInterval.new(wasm.BigNum.from_str('721'), wasm.BigNum.from_str('10000000')),\n        ),\n      )\n      .max_value_size(5000)\n      .max_tx_size(16384)\n      .build(),\n  )\n```\n\n----------------------------------------\n\nTITLE: Adding Bootstrap (Byron-era) Witnesses - JavaScript\nDESCRIPTION: This snippet adds bootstrap witnesses for Byron-era addresses to the transaction. It creates BootstrapWitnesses, makes an Icarus bootstrap witness using the transaction hash, Byron address, and a Bip32 private key.  The bootstrap witness is added to the BootstrapWitnesses object, and then it's set to the TransactionWitnessSet.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// add bootstrap (Byron-era) witnesses\nconst cip1852Account = CardanoWasm.Bip32PrivateKey.from_bech32('xprv1hretan5mml3tq2p0twkhq4tz4jvka7m2l94kfr6yghkyfar6m9wppc7h9unw6p65y23kakzct3695rs32z7vaw3r2lg9scmfj8ec5du3ufydu5yuquxcz24jlkjhsc9vsa4ufzge9s00fn398svhacse5su2awrw');\nconst bootstrapWitnesses = CardanoWasm.BootstrapWitnesses.new();\nconst bootstrapWitness = CardanoWasm.make_icarus_bootstrap_witness(\n    txHash,\n    byronAddress,\n    cip1852Account,\n);\nbootstrapWitnesses.add(bootstrapWitness);\nwitnesses.set_bootstraps(bootstrapWitnesses);\n```\n\n----------------------------------------\n\nTITLE: Converting Addresses\nDESCRIPTION: This JavaScript snippet demonstrates how to convert a Shelley address to a generic `Address` type and create a `TransactionOutput`. It also shows how to create an `Address` directly from a Bech32-encoded string. It depends on the CardanoWasm library.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-keys.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst address = baseAddress.to_address();\n\nconst output = CardanoWasm.TransactionOutput(address, BigNum.from_str(\"365\"));\n```\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst addr = CardanoWasm.Address.from_bech32(\"addr1vyt3w9chzut3w9chzut3w9chzut3w9chzut3w9chzut3w9cj43ltf\");\n\n```\n\n----------------------------------------\n\nTITLE: Converting 128-byte XPrv Key\nDESCRIPTION: This JavaScript code snippet demonstrates how to convert a 128-byte XPrv key to a `BIP32PrivateKey` and back using the `from_128_xprv` and `to_128_xprv` methods.  It includes an assertion to ensure that the conversion is lossless and that the original XPrv key can be recovered. It requires the CardanoWasm library and the `xprvBytes` variable to be defined.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-keys.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst bip32PrivateKey = CardanoWasm.BIP32PrivateKey.from_128_xprv(xprvBytes);\nassert(xprvBytes == CardanoWasm.BIP32PrivateKey.to_128_xprv());\n```\n\n----------------------------------------\n\nTITLE: JSON Conversion: No Conversions (JavaScript)\nDESCRIPTION: This code snippet demonstrates converting a JavaScript object to Cardano metadata using the `NoConversions` schema, and then converting the metadata back to a JSON string.  It shows how to use the CardanoWasm library to encode and decode metadata with no type conversions.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst obj = {\n  receiver_id: \"SJKdj34k3jjKFDKfjFUDfdjkfd\",\n  sender_id: \"jkfdsufjdk34h3Sdfjdhfduf873\",\n  comment: \"happy birthday\",\n  tags: [0, 264, -1024, 32]\n};\nconst metadata = CardanoWasm.encode_json_str_to_metadatum(JSON.stringify(obj), CardanoWasm.MetadataJsonSchema.NoConversions);\nconst metadataString = CardanoWasm.decode_metadatum_to_json_str(metadata, CardanoWasm.MetadataJsonSchema.NoConversions);\n```\n\n----------------------------------------\n\nTITLE: Metadata Construction via CDDL: JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to construct metadata using a library generated from a CDDL definition.  It shows how to create an instance of a CDDL-defined type (`Foo`) and how to convert it to Cardano metadata bytes.  It also illustrates how to create nested data structures like lists of integers.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst tags = OurMetadataLib.Ints.new();\n// if we have smaller (32-bit signed) numbers we can construct easier\ntags.add(OurMetadataLib.Int.new_i32(0));\n// but for bigger (>= 2^32) numbers we must use BigNum and specify the sign ourselves\ntags.add(OurMetadataLib.Int.new(CardanoWasm.Int.from_str(\"264\")));\n// and for negative large (< -2^32) numbers (here we construct -1024)\ntags.add(OurMetadataLib.Int.new_negative(CardanoWasm.Int.from_str(\"1024\")));\ntags.add(OurMetadataLib.Int.new_i32(32));\nconst map = OurMetadataLib.Foo.new(\"SJKdj34k3jjKFDKfjFUDfdjkfd\", \"jkfdsufjdk34h3Sdfjdhfduf873\", \"happy birthday\", tags)\nlet metadata;\ntry {\n  metadata = CardanoWasm.TransactionMetadata.from_bytes(map.to_bytes());\n} catch (e) {\n  // this should never happen if OurMetadataLib was generated from compatible CDDL with the metadata definition\n}\n```\n\n----------------------------------------\n\nTITLE: Running Development Server using npm\nDESCRIPTION: This script starts the Create React App development server. It opens the app in the browser at http://localhost:3000 and automatically reloads the page on changes. It may also display lint errors in the console.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-asmjs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Starting Development Server (npm start)\nDESCRIPTION: Starts the React application in development mode, enabling hot reloading and displaying linting errors in the console. It opens the application in a web browser at http://localhost:3000.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-browser/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Building the repository\nDESCRIPTION: Commands to initialize submodules, use the correct Node.js version, install dependencies, and build the Rust code for Node.js.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/README.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit submodule update --init --recursive\nnvm use\nnpm install\nnpm run rust:build-nodejs\n```\n\n----------------------------------------\n\nTITLE: Installing Rust\nDESCRIPTION: Commands to install Rust, set up the environment, add WASM target, and install wasm-pack.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/README.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncurl https://sh.rustup.rs -sSf | sh -s -- -y\necho 'export PATH=$HOME/.cargo/bin/:$PATH' >> $BASH_ENV\nrustup install stable\nrustup target add wasm32-unknown-unknown --toolchain stable\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n```\n\n----------------------------------------\n\nTITLE: Building for Production (npm run build)\nDESCRIPTION: Builds the React application for production, optimizing performance by bundling React in production mode, minifying code, and including file hashes.  The resulting production-ready files are placed in the 'build' directory. Deployment is ready from here.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-browser/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Building for Production using npm\nDESCRIPTION: This script builds the Create React App for production, creating an optimized bundle in the `build` folder. The build includes minified code and hashed filenames for performance and caching.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-asmjs/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Generating .cbor files from CDDL specs in one step\nDESCRIPTION: This command combines the generation of `.diag` files and their conversion to `.cbor` files into a single command. It pipes the output of the `cddl generate` command to the `diag2cbor.rb` script. Requires the installation of cddl and cbor-diag gems and ruby.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/specs/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncddl specs/shelley.cddl generate 1 | diag2cbor.rb > test/name_here.cbor\n```\n\n----------------------------------------\n\nTITLE: Running Tests (npm test)\nDESCRIPTION: Launches the test runner in interactive watch mode. This command allows developers to execute unit or integration tests and automatically rerun them when code changes are detected. Refer to Create React App's documentation for more information on test configuration.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-browser/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Generating .diag files from CDDL specs\nDESCRIPTION: This command generates a `.diag` file from the specified CDDL specification (`specs/shelley.cddl`).  It utilizes the `cddl generate` command, piping the output to a file named `test/name_here.diag`. The `1` argument likely specifies the number of instances to generate.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/specs/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncddl specs/shelley.cddl generate 1 > test/name_here.diag\n```\n\n----------------------------------------\n\nTITLE: Installing cddl and cbor-diag Ruby gems\nDESCRIPTION: These commands install the `cddl` and `cbor-diag` Ruby gems, which are required for generating CDDL instances. First updates apt, and then installs ruby, then uses gem to install `cddl` and `cbor-diag`.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/specs/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt install ruby\nsudo gem install cddl\nsudo gem install cbor-diag\n```\n\n----------------------------------------\n\nTITLE: CDDL Codegen: Wasm-pack Build Command\nDESCRIPTION: This command builds a wasm package from the generated rust code located in the `/export/` directory. It targets nodejs and converts the rust code to wasm. Other targets are possible like `--target=browser`.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\ncd export\nwasm-pack build --target=nodejs\n```\n\n----------------------------------------\n\nTITLE: CDDL Codegen: Cargo Run Command\nDESCRIPTION: This command runs the `cddl-codegen` tool to generate a wasm-convertible Rust library from the `input.cddl` file. The generated code will be placed in the `/export/` directory.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: CDDL Codegen: Cargo Build Command\nDESCRIPTION: This command builds the `cddl-codegen` tool, preparing it for generating code based on a CDDL definition. Requires a `input.cddl` file in the same directory.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ncargo build\n```\n\n----------------------------------------\n\nTITLE: CDDL Codegen: Wasm-pack Pack Command\nDESCRIPTION: This command packages the wasm module into a distributable npm package located in the `/pkg/` directory. Requires running `wasm-pack build` beforehand.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\nwasm-pack pack\n```\n\n----------------------------------------\n\nTITLE: Converting .diag to .cbor files\nDESCRIPTION: This command converts a `.diag` file to a `.cbor` file using the `diag2cbor.rb` script. It takes the `.diag` file as input (`test/name_here.diag`) and outputs a `.cbor` file (`test/name_here.cbor`). Requires the installation of cbor-diag gem.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/specs/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndiag2cbor.rb test/name_here.diag > test/name_here.cbor\n```\n\n----------------------------------------\n\nTITLE: CDDL Metadata Checker: Cargo Run Command\nDESCRIPTION: This shell command runs the cargo project after building, using the `input.cddl` file located in the `/tools/metadata-cddl-checker/` directory.  The tool will validate whether the input CDDL conforms to the expected metadata format.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Running Tests with npm\nDESCRIPTION: This script launches the test runner in interactive watch mode for the Create React App project. Refer to the Create React App documentation for details on writing and running tests.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-asmjs/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm test\n```\n\n----------------------------------------\n\nTITLE: Ejecting from Create React App (npm run eject)\nDESCRIPTION: Ejects the project from Create React App, exposing all configuration files and dependencies for full customization. This is a one-way operation and cannot be reversed. It provides complete control over the build process.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-browser/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run eject\n```\n\n----------------------------------------\n\nTITLE: JSON Example: Detailed Schema\nDESCRIPTION: This JSON snippet shows the `DetailedSchema` for representing Cardano metadata. All values are represented as an object with a single field, where the key tags the type and the value is the data itself. This schema can represent almost all metadata, but is verbose.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\"map\":[\n  {\n    \"k\":{\"bytes\":\"8badf00d\"},\n    \"v\":{\"bytes\":\"deadbeef\"}\n  },\n  {\n    \"k\":{\"int\":9},\n    \"v\":{\"int\":5}\n  },\n  {\n    \"k\":{\"string\":\"obj\"},\n    \"v\":{\"map\":[\n      {\n        \"k\":{\"string\":\"a\"},\n        \"v\":{\"list\":[\n          {\"map\":[\n            {\n              \"k\":{\"int\":5},\n              \"v\":{\"int\":2}\n            }\n          ]},\n          {\"map\":[\n          ]}\n        ]}\n      }\n    ]}\n  }\n]}\n```\n\n----------------------------------------\n\nTITLE: Publishing to crates.io\nDESCRIPTION: Command to publish a new version of the Rust package to crates.io.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/README.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnpm run rust:publish\n```\n\n----------------------------------------\n\nTITLE: Adding Bootstrap (Byron-era) Input to Transaction - JavaScript\nDESCRIPTION: This snippet adds a bootstrap input (Byron-era address) to the transaction using the `add_bootstrap_input` method. It uses a Byron address, a transaction hash, index, and value to represent ADA held in a Byron-era address. Note the use of Buffer to convert the hex string to bytes.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/generating-transactions.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// add a bootstrap input - for ADA held in a Byron-era address\nconst byronAddress = CardanoWasm.ByronAddress.from_base58(\"Ae2tdPwUPEZLs4HtbuNey7tK4hTKrwNwYtGqp7bDfCy2WdR3P6735W5Yfpe\");\ntxBuilder.add_bootstrap_input(\n    byronAddress,\n    CardanoWasm.TransactionInput.new(\n    CardanoWasm.TransactionHash.from_bytes(\n        Buffer.from(\"488afed67b342d41ec08561258e210352fba2ac030c98a8199bc22ec7a27ccf1\", \"hex\"),\n    ), // tx hash\n    0, // index\n    ),\n    CardanoWasm.Value.new(CardanoWasm.BigNum.from_str('3000000'))\n);\n```\n\n----------------------------------------\n\nTITLE: CDDL Metadata Checker: Cargo Build Command\nDESCRIPTION: This shell command builds the cargo project to check if your CDDL conforms to the metadata CDDL. You must place your CDDL in a file named `input.cddl` inside the `/tools/metadata-cddl-checker/` directory before running this command.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ncargo build\n```\n\n----------------------------------------\n\nTITLE: JSON Example: Basic Conversions\nDESCRIPTION: This JSON snippet illustrates the `BasicConversions` schema, demonstrating support for byte strings (as hex strings) and integers (as strings) as keys and byte strings as values. Byte strings must be prefixed with \"0x\". Strings that can be parsed as an integer will be treated as metadata integers.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/doc/getting-started/metadata.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"0x8badf00d\": \"0xdeadbeef\",\n  \"9\": 5,\n  \"obj\": {\n    \"a\":[\n      {\n        \"5\": 2\n      },\n      {\n      }\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing to NPM\nDESCRIPTION: Commands to publish new versions of the NodeJS, Browser (WASM), and ASM.js packages to NPM.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/README.rst#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnpm run js:publish-nodejs\nnpm run js:publish-browser\nnpm run js:publish-asm\n```\n\n----------------------------------------\n\nTITLE: Testing the library\nDESCRIPTION: Command to run the Rust tests using npm.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/README.rst#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm run rust:test\n```\n\n----------------------------------------\n\nTITLE: Ejecting from Create React App using npm\nDESCRIPTION: This script ejects the project from the Create React App build tool, exposing all configuration files and dependencies. Note that this is a one-way operation and cannot be undone.\nSOURCE: https://github.com/emurgo/cardano-serialization-lib/blob/master/templates/react-asmjs/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run eject\n```"
  }
]