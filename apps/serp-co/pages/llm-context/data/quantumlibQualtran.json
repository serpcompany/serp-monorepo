[
  {
    "owner": "quantumlib",
    "repo": "qualtran",
    "content": "TITLE: Install Qualtran using pip\nDESCRIPTION: This command installs the Qualtran library and its dependencies using pip, the Python package installer. It's the basic installation method.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npip install qualtran\n```\n\n----------------------------------------\n\nTITLE: Instantiating the Toffoli gate\nDESCRIPTION: This snippet demonstrates how to create an instance of the `Toffoli` gate using the `Toffoli()` constructor.  No parameters are required for basic instantiation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/toffoli.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntoffoli = Toffoli()\n```\n\n----------------------------------------\n\nTITLE: Controlling an XGate in Qualtran\nDESCRIPTION: This snippet demonstrates how to create a controlled version of an XGate using the `controlled()` method. The initial XGate and its controlled version are displayed using `show_bloq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloq\nfrom qualtran.bloqs.basic_gates import XGate\n\nx = XGate()\n\nshow_bloq(x)\nshow_bloq(x.controlled())\n```\n\n----------------------------------------\n\nTITLE: Square Example Instance\nDESCRIPTION: Creates an instance of the `Square` class with a specified bitsize. The `Square` bloq implements $U|a\\rangle|0\\rangle \\rightarrow |a\\rangle|a^2\\rangle$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsquare = Square(bitsize=8)\n```\n\n----------------------------------------\n\nTITLE: Finding factors using the period in Python\nDESCRIPTION: This snippet uses the period to calculate the factors of `N`. It asserts that the period is even and that `g**(period//2)` is not equal to -1. It then calculates `p1` and `m1` and asserts that their product modulo `N` is 0.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nassert period % 2 == 0\nassert g**(period//2) != -1\n\nhalf_period = g**(period//2)\np1 = half_period + 1\nm1 = half_period - 1\n\nassert (p1*m1) % N == 0\n```\n\n----------------------------------------\n\nTITLE: Displaying the Toffoli gate graphically\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display a graphical representation of the `toffoli` gate.  It takes a list of `Bloq` objects and a list of corresponding labels as input.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/toffoli.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([toffoli],\n           ['`toffoli`'])\n```\n\n----------------------------------------\n\nTITLE: Import CZ from qualtran.bloqs.basic_gates\nDESCRIPTION: This snippet imports the `CZ` class from the `qualtran.bloqs.basic_gates` module. The `CZ` represents the controlled-Z quantum gate, which applies a Z gate to the target qubit conditioned on the control qubit being in the |1> state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CZ\n```\n\n----------------------------------------\n\nTITLE: Create and activate a Conda environment\nDESCRIPTION: These commands create a new Conda environment named 'my-qualtran-env' with Python 3.11 and then activates it. Conda environments help manage dependencies for different projects.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nconda create -n my-qualtran-env python=3.11\nconda activate my-qualtran-env\n```\n\n----------------------------------------\n\nTITLE: Importing Qualtran in Python (shell)\nDESCRIPTION: This snippet shows how to import the `qualtran` package into your Python environment. Successful import indicates that the installation was successful.  Prerequisites: Qualtran must be installed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nimport qualtran\n```\n\n----------------------------------------\n\nTITLE: Importing CNOT Gate from Qualtran\nDESCRIPTION: This snippet imports the `CNOT` class directly from the `qualtran.bloqs.basic_gates` module. This is the primary method for accessing and using the CNOT gate within Qualtran circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/cnot.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CNOT\n```\n\n----------------------------------------\n\nTITLE: Sparse State Preparation from Dictionary\nDESCRIPTION: This code prepares a sparse state using the `SparseStatePreparationAliasSampling` class, using a dictionary `coeff_map` to represent non-zero coefficients. The `from_sparse_dict` method is used to create an instance of `SparseStatePreparationAliasSampling` with specified non-zero coefficients, a size `N`, and a precision calculated from `mu`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncoeff_map = {0: 1.0, 3: 1.0, 5: 3.0, 7: 2.0}\nN = 9\nmu = 3\nsparse_state_prep_alias = SparseStatePreparationAliasSampling.from_sparse_dict(\n    coeff_map, N, precision=2**-mu / len(coeff_map)\n)\n```\n\n----------------------------------------\n\nTITLE: Show graphical representation of TwoBitCSwap\nDESCRIPTION: Generates and displays a graphical representation of the `TwoBitCSwap` gate using the `show_bloqs` function from `qualtran.drawing`. The gate is labeled as '`cswap_bit`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cswap_bit],\n           ['`cswap_bit`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate Identity gate with default size\nDESCRIPTION: Creates an instance of the `Identity` gate with the default size (1 qubit).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/identity.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nidentity = Identity()\n```\n\n----------------------------------------\n\nTITLE: QPE Simulation with Different Window Functions\nDESCRIPTION: This script sets up and executes Quantum Phase Estimation (QPE) simulations using different window functions: Rectangular, SinState, and Kaiser.  It initializes the unitary operator (ZPowGate), configures the simulation parameters (number of samples, number of bits), constructs the QPE circuits using different window states, and estimates the phase from the simulated results.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ntheta = 0.51234\nunitary = ZPowGate(2 * theta)\nn_samples = 100_000\nm = 6\nx_vals = [x / 2**m for x in range(2**m)]\n# Textbook QPE\nqpe_textbook = TextbookQPE(unitary, RectangularWindowState(m))\nthetas_textbook = simulate_theta_estimate(qpe_textbook, n_samples)\n# SinState QPE\nqpe_sinstate = TextbookQPE(unitary, LPResourceState(m))\nthetas_sinstate = simulate_theta_estimate(qpe_sinstate, n_samples)\n# Kaiser QPE\nkaiser_window_state = KaiserWindowState.from_precision_and_delta(3, 1e-2)\nalpha = kaiser_window_state.alpha\nassert kaiser_window_state.bitsize == m, f'{kaiser_window_state.bitsize}'\nqpe_kaiser_state = TextbookQPE(unitary, kaiser_window_state)\nthetas_kaiser_state = simulate_theta_estimate(qpe_kaiser_state, n_samples)\n```\n\n----------------------------------------\n\nTITLE: Defining a Test Bloq with Decomposition - Python\nDESCRIPTION: Defines a custom `Bloq` subclass called `TestTwoCNOT` that implements its own decomposition logic using the `build_composite_bloq` method. The decomposition consists of two `CNOT` gates with reversed control and target qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass TestTwoCNOT(Bloq):\n    @property\n    def signature(self) -> Signature:\n        return Signature.build(q1=1, q2=1)\n\n    def build_composite_bloq(\n        self, bb: 'BloqBuilder', q1: 'Soquet', q2: 'Soquet'\n    ) -> Dict[str, 'Soquet']:\n        q1, q2 = bb.add(CNOT(), ctrl=q1, target=q2)\n        q1, q2 = bb.add(CNOT(), ctrl=q2, target=q1)\n        return {'q1': q1, 'q2': q2}\n```\n\n----------------------------------------\n\nTITLE: Generate call graph of OutOfPlaceAdder gate\nDESCRIPTION: Generates and displays the call graph of the `OutOfPlaceAdder` gate using `call_graph` and `show_call_graph`. This illustrates the internal structure of the gate and its dependencies. `ignore_split_join` is used as a generalizer for resource counting.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nadd_oop_symb_g, add_oop_symb_sigma = add_oop_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(add_oop_symb_g)\nshow_counts_sigma(add_oop_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: ControlledAddOrSubtract Instance - Symbolic Integers\nDESCRIPTION: Creates an instance of `ControlledAddOrSubtract` for signed integers with a symbolic size `n` (`QInt(n)`). This allows for creating instances with sizes determined at runtime or during symbolic analysis.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_add_or_subtract.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nn = sympy.Symbol(\"n\")\nctrl_add_or_sub_signed_symb = ControlledAddOrSubtract(QInt(n), QInt(n))\n```\n\n----------------------------------------\n\nTITLE: Display graphical signatures of AddK instances\nDESCRIPTION: Uses `show_bloqs` to display the graphical representation of the instantiated `AddK` gates (`add_k`, `add_k_small`, `add_k_large`). This visualization aids in understanding the register structure and the constant addition operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([add_k, add_k_small, add_k_large],\n           ['`add_k`', '`add_k_small`', '`add_k_large`'])\n```\n\n----------------------------------------\n\nTITLE: Product Example Instance\nDESCRIPTION: Creates an instance of the `Product` class with specified bitsizes for the input registers `a` and `b`. The `Product` bloq implements the unitary $U|a\\rangle|b\\rangle|0\\rangle \\rightarrow |a\\rangle|b\\rangle|a\\times b\\rangle$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nproduct = Product(a_bitsize=4, b_bitsize=6)\n```\n\n----------------------------------------\n\nTITLE: Drawing Musical Score for Select Bloq\nDESCRIPTION: This snippet generates a musical score representation of the `sel_thc` bloq. It uses `get_musical_score_data` and `draw_musical_score` from `qualtran.drawing` to create the visualization. The figure size and title are also set.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import get_musical_score_data, draw_musical_score\nmsd = get_musical_score_data(sel_thc.decompose_bloq())\nfig, ax = draw_musical_score(msd)\nfig.set_size_inches(12, 8)\nax.set_title('Select')\nplt.tick_params(left=False, right=False, labelleft=False, labelbottom=False, bottom=False)\n```\n\n----------------------------------------\n\nTITLE: Creating and Visualizing THCRotations Bloq\nDESCRIPTION: This snippet creates a `THCRotations` bloq and visualizes its call graph. It specifies the parameters for the bloq, generates the call graph using `bloq.call_graph()`, displays the graph using `show_call_graph`, and prints the rotation and QROM costs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.thc.select_bloq import THCRotations\n\nbloq = THCRotations(num_mu, num_spin_orb, num_bits_theta, kr1=16, kr2=16)\ngraph, sigma = bloq.call_graph()\nshow_call_graph(graph)\nprint(f\"rotation cost = {108 * 14}, qrom cost = {402}\")\n```\n\n----------------------------------------\n\nTITLE: Importing necessary Qualtran modules\nDESCRIPTION: This snippet imports the required modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `QBit`, `QInt`, `QUInt`, `QAny` for defining quantum circuits and data types, as well as modules for drawing and visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: THC Hamiltonian Block Encoding using Qualtran\nDESCRIPTION: This code snippet demonstrates how to construct a `SelectTHC` and `PrepareTHC` block from random coefficients representing a THC Hamiltonian using the `qualtran` library. It generates random coefficients for the FeMoCo model complex and builds the Select and Prepare oracles needed for block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom qualtran.bloqs.chemistry.thc import SelectTHC, PrepareTHC\n\n# Let's just generate some random coefficients for the moment with parameters\n# corresponding to the FeMoCo model complex.\nnum_spin_orb = 108\nnum_mu = 350\nnum_bits_theta = 16\nnum_bits_state_prep = 10\ntpq = np.random.normal(0, 1, size=(num_spin_orb//2, num_spin_orb//2))\nzeta = np.random.normal(0, 1, size=(num_mu, num_mu))\nzeta = 0.5 * (zeta + zeta.T)\neta = np.random.normal(0, 1, size=(num_mu, num_spin_orb//2))\neri_thc = np.einsum(\"Pp,Pr,Qq,Qs,PQ->prqs\", eta, eta, eta, eta, zeta, optimize=True)\n# In practice one typically uses the exact ERI tensor instead of that from THC, but that's a minor detail.\ntpq_prime = tpq - 0.5 * np.einsum(\"illj->ij\", eri_thc, optimize=True) + np.einsum(\"llij->ij\", eri_thc, optimize=True)\nt_l = np.linalg.eigvalsh(tpq_prime)\n# Build Select and Prepare\nprep_thc = PrepareTHC.from_hamiltonian_coeffs(t_l, eta, zeta, num_bits_state_prep=num_bits_state_prep)\nsel_thc = SelectTHC(num_mu, num_spin_orb, num_bits_theta=num_bits_theta, keep_bitsize=prep_thc.keep_bitsize, kr1=16, kr2=16)\n```\n\n----------------------------------------\n\nTITLE: Instantiate StatePreparationViaRotations with Numerical Values\nDESCRIPTION: Creates an instance of `StatePreparationViaRotations` with specific numerical values for the state coefficients and phase bitsize. The `state_coefs` variable holds the complex coefficients, and `phase_bitsize` determines the accuracy of the rotations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstate_coefs = (\n    (-0.42677669529663675 - 0.1767766952966366j),\n    (0.17677669529663664 - 0.4267766952966367j),\n    (0.17677669529663675 - 0.1767766952966368j),\n    (0.07322330470336305 - 0.07322330470336309j),\n    (0.4267766952966366 - 0.17677669529663692j),\n    (0.42677669529663664 + 0.17677669529663675j),\n    (0.0732233047033631 + 0.17677669529663678j),\n    (-0.07322330470336308 - 0.17677669529663678j),\n)\nstate_prep_via_rotation = StatePreparationViaRotations(\n    phase_bitsize=2, state_coefficients=state_coefs\n)\n```\n\n----------------------------------------\n\nTITLE: Find ECC Private Key using Phase Estimation (Qualtran)\nDESCRIPTION: Defines the `FindECCPrivateKey` composite bloq which utilizes two phase estimations to recover the private key in an Elliptic Curve Cryptography system.  It leverages `ECCAddR` for point addition and follows the approach detailed in Litinski 2023. The implementation aims to find the private key $k$ such that $Q = [k]P$, where $P$ is the base point and $Q$ is the public key.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.cryptography.ecc import FindECCPrivateKey\n```\n\n----------------------------------------\n\nTITLE: Import PrepareUniformSuperposition from qualtran\nDESCRIPTION: This snippet imports the `PrepareUniformSuperposition` class from the `qualtran.bloqs.state_preparation` module. This class is used to prepare a uniform superposition over the first n basis states.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/prepare_uniform_superposition.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.state_preparation import PrepareUniformSuperposition\n```\n\n----------------------------------------\n\nTITLE: Instantiate Unitary with TGate\nDESCRIPTION: This snippet creates an instance of the `Unitary` class, representing a block encoding of a TGate. The TGate is a fundamental quantum gate, and this demonstrates how to create a block encoding for it using the `Unitary` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/unitary.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import TGate\n\nunitary_block_encoding = Unitary(TGate())\n```\n\n----------------------------------------\n\nTITLE: Splitting and Applying XGate to Bits in Qualtran\nDESCRIPTION: This snippet shows how to split a quantum unsigned integer into individual bits and apply the `XGate` to each bit using Qualtran's `BloqBuilder`. It creates a 3-bit `QUInt`, splits it into individual qubit variables using `bb.split`, applies the `XGate` to each bit, and then joins the bits back into a `QUInt` using `bb.join`. The resulting composite bloq is then displayed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import XGate\n\ndtype = QUInt(3)  # 3-bit integer for demonstration purposes\n\n# We'll use BloqBuilder directly. In the standard library this would\n# be the `build_composite_bloq` method on the `BitwiseNot` bloq class\nbb = BloqBuilder()\nx = bb.add_register_from_dtype('x', dtype)\n\n# First, we split up the bits using the `.split` helper method on BloqBuilder.\n# It returns a numpy array of quantum variables.\nx_bits = bb.split(x)\n\n# Then, we apply the XGate to each bit. Remember that each quantum variable\n# must be used exactly once, so the input bits are consumed by the XGate and\n# we get a new variable back that we store in our `x_bits` array.\nfor i in range(len(x_bits)):\n    x_bits[i] = bb.add(XGate(), q=x_bits[i])\n\n# For users calling this bloq, we want the fact that we split up all the bits\n# to be an \"implementation detail\"; so we re-join our output bits back into\n# a 3-bit unsigned integer\nx = bb.join(x_bits, dtype=dtype)\n\n# Finish up and draw a diagram\ncbloq = bb.finalize(x=x)\nshow_bloq(cbloq)\n```\n\n----------------------------------------\n\nTITLE: Import MultiAnd bloq from qualtran.bloqs.mcmt\nDESCRIPTION: This code imports the `MultiAnd` class, enabling the construction and usage of multi-controlled AND gates in quantum algorithms. This class is a generalization of the `And` gate for more than two control qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mcmt import MultiAnd\n```\n\n----------------------------------------\n\nTITLE: Define out-of-place quantum addition gate with OutOfPlaceAdder\nDESCRIPTION: Defines an n-bit out-of-place addition gate `OutOfPlaceAdder` using the Qualtran library. This gate implements the transformation |a>|b>|0> -> |a>|b>|a+b> with a resource cost of 4n - 4 T gates for computation and 0 T-gates for uncomputation. The `bitsize` parameter defines the size of the input registers, and `include_most_significant_bit` determines the size of the output register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import OutOfPlaceAdder\n```\n\n----------------------------------------\n\nTITLE: MultiTargetCNOT Definition\nDESCRIPTION: Imports the `MultiTargetCNOT` class from `qualtran.bloqs.mcmt`. This gate implements a controlled-NOT gate acting on multiple target qubits using a circuit of depth $2\\log(n) + 1$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mcmt import MultiTargetCNOT\n```\n\n----------------------------------------\n\nTITLE: Create OneState Instance\nDESCRIPTION: Creates an instance of the `OneState` bloq, representing the |1> quantum state. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\none_state = OneState()\n```\n\n----------------------------------------\n\nTITLE: Comparator Definition in Qualtran\nDESCRIPTION: Defines a `Comparator` bloq that compares and potentially swaps two n-bit numbers. It implements $|a\\rangle|b\\rangle \\mapsto |\\min(a,b)\\rangle|\\max(a,b)\\rangle|a>b\\rangle$, swapping the registers if a > b. The `bitsize` parameter determines the size of the input registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Comparator\n```\n\n----------------------------------------\n\nTITLE: Building call graph for PrepareSecondQuantization in Qualtran\nDESCRIPTION: This code extends the `PrepareSecondQuantization` bloq with a `build_call_graph` method that defines the constituent bloqs and their costs for state preparation. It includes preparing a uniform superposition, outputting a QROM, performing an inequality test, and swapping alt values. It uses black box QROAM.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Set, Optional\nfrom qualtran.bloqs.arithmetic.comparison import LessThanEqual\nfrom qualtran.bloqs.basic_gates.swap import CSwap\nfrom qualtran.resource_counting import SympySymbolAllocator, BloqCountT\nfrom qualtran.bloqs.state_preparation import PrepareUniformSuperposition\nfrom qualtran.bloqs.chemistry.black_boxes import QROAM\n\n\n@frozen\nclass PrepareSecondQuantization(PrepareOracle):\n\n    num_spin_orb: int\n    num_bits_state_prep: int = 16\n    qroam_block_size: Optional[int] = None\n\n    @cached_property\n    def selection_registers(self) -> Tuple[Register, ...]:\n        bitsize = (self.num_spin_orb // 2 - 1).bit_length()\n        return (\n            Register('p', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register('q', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register('r', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register('s', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register('alpha', BQUInt(1)),\n            Register('beta', BQUInt(1)),\n            Register('sign', BQUInt(1)),\n        )\n\n    def build_call_graph(self, ssa: 'SympySymbolAllocator') -> Set['BloqCountT']:\n        # 1. Prepare a uniform superposition over p, q, r and s\n        bitsize = (self.num_spin_orb // 2 - 1).bit_length()\n        # a factor of 4 here for p, q, r, and s\n        cost_uni_prep = (PrepareUniformSuperposition(self.num_spin_orb//2), 4)\n        # we are free to ignore certain costs at this point, so let's forget\n        # about the Hadamards on the alpha/beta registers.\n        # 2. Output a QROM\n        # we have N^4 elements to output\n        data_size = (self.num_spin_orb // 2)**2 + (self.num_spin_orb // 2) ** 4\n        # We need the alt values for p,q,r,s, the theta values and alt values\n        # for theta, and the keep values (for alias sampling.)\n        target_bitsize = sum((bitsize,)*4 + (1, 1, self.num_bits_state_prep))\n        # here we are using a \"black box\" QROAM which has formulaic costs for\n        # qrom or qroam. Setting qroam_block_size=1 ensures we get a QROM.\n        cost_qrom = (QROAM(data_size, target_bitsize, qroam_block_size=self.qroam_block_size), 1)\n        # 3. inequality test the keep register \n        cost_ineq = (LessThanEqual(self.num_bits_state_prep, self.num_bits_state_prep), 1)\n        # 4. swap the alt values, the sign bit does not need a swap.\n        cost_swap = (CSwap(bitsize), 4)\n        return {cost_uni_prep, cost_qrom, cost_ineq, cost_swap}\n```\n\n----------------------------------------\n\nTITLE: Call Graph of LinearDepthHalfLessThanEqual in Qualtran\nDESCRIPTION: This snippet generates and displays the call graph for `LinearDepthHalfLessThanEqual` using `call_graph` and `show_call_graph`. It facilitates the analysis of resource costs and complexity of the quantum comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlineardepthhalflessthanequal_small_g, lineardepthhalflessthanequal_small_sigma = lineardepthhalflessthanequal_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lineardepthhalflessthanequal_small_g)\nshow_counts_sigma(lineardepthhalflessthanequal_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Statements and Module Definitions\nDESCRIPTION: This snippet imports necessary modules from Qualtran and other libraries such as NumPy, SymPy, and Cirq. It also defines the basic structure and dependencies for building quantum sorting algorithms in Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Decomposing and counting sub-bloqs of ModExp in Python\nDESCRIPTION: This snippet decomposes the `ModExp` bloq into its constituent sub-bloqs and counts the occurrences of each sub-bloq. This allows for analyzing the complexity of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmod_exp_decomp = mod_exp.decompose_bloq()\nmod_exp_decomp.bloq_counts()\n```\n\n----------------------------------------\n\nTITLE: Example instantiation of TextbookQPE\nDESCRIPTION: Creates an instance of TextbookQPE using ZPowGate and RectangularWindowState with a specified bitsize. Demonstrates how to set up the QPE algorithm with a given unitary and state preparation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import ZPowGate\nfrom qualtran.bloqs.phase_estimation import RectangularWindowState, TextbookQPE\n\ntextbook_qpe_small = TextbookQPE(ZPowGate(exponent=2 * 0.234), RectangularWindowState(3))\n```\n\n----------------------------------------\n\nTITLE: PrepareHubbard Instance Example\nDESCRIPTION: Creates an instance of the `PrepareHubbard` class with specified dimensions `x_dim` and `y_dim`, hopping parameter `t`, and interaction parameter `u`. This demonstrates how to initialize the PREPARE operation for a Hubbard model with specific parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nx_dim = 4\ny_dim = 4\nt = 1.0\nu = 4.0 / t\nprep_hubb = PrepareHubbard(x_dim, y_dim, t=t, u=u)\n```\n\n----------------------------------------\n\nTITLE: Create instances of AddK gate\nDESCRIPTION: Creates example instances of the `AddK` gate with different register sizes and constant values, including symbolic and fixed values, showcasing the flexibility of adding constant values to quantum registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nn, k = sympy.symbols('n k')\nadd_k = AddK(QUInt(n), k=k)\n```\n\nLANGUAGE: python\nCODE:\n```\nadd_k_small = AddK(QUInt(4), k=2)\n```\n\nLANGUAGE: python\nCODE:\n```\nadd_k_large = AddK(QInt(64), k=-23)\n```\n\n----------------------------------------\n\nTITLE: Generate and Display Call Graph of YPowGate\nDESCRIPTION: This snippet generates and displays the call graph and counts sigma of the y_pow gate using the call_graph method and the show_call_graph/show_counts_sigma functions. It also uses the ignore_split_join generalizer. The call graph visualizes the dependencies and resources used by the gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ny_pow_g, y_pow_sigma = y_pow.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(y_pow_g)\nshow_counts_sigma(y_pow_sigma)\n```\n\n----------------------------------------\n\nTITLE: Multi-Data QROM Instance - Python\nDESCRIPTION: This snippet creates a `QROM` instance that loads from two data arrays: `data1` and `data2`. Both are `np.arange(5)`, but `data2` is offset by 1. The selection register is 3 bits wide. The first target register requires 3 bits, while the second requires 4.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndata1 = np.arange(5)\ndata2 = np.arange(5) + 1\nqrom_multi_data = QROM([data1, data2], selection_bitsizes=(3,), target_bitsizes=(3, 4))\n```\n\n----------------------------------------\n\nTITLE: CRz Import\nDESCRIPTION: Imports the `CRz` class from the `qualtran.bloqs.basic_gates` module. This gate represents a controlled rotation around the Z axis of the Bloch sphere.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CRz\n```\n\n----------------------------------------\n\nTITLE: Create Large CSwapApprox Instance\nDESCRIPTION: Creates a large instance of the CSwapApprox class with a bitsize of 64. This is used for swapping larger registers in quantum computations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# A large version that swaps 64-bit registers.\napprox_cswap_large = CSwapApprox(bitsize=64)\n```\n\n----------------------------------------\n\nTITLE: PrepareHubbard Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts of the `PrepareHubbard` instance. The `ignore_split_join` generalizer is used to simplify the graph. This helps analyze the resource requirements of the operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprep_hubb_g, prep_hubb_sigma = prep_hubb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prep_hubb_g)\nshow_counts_sigma(prep_hubb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Test Bloq Decomposition\nDESCRIPTION: This code uses `assert_valid_bloq_decomposition` to test whether the decomposition of the `prep` bloq is valid. This verifies that the decomposition satisfies basic wiring conditions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Quick test that are decomposition is ok.\nfrom qualtran.testing import assert_valid_bloq_decomposition\nassert_valid_bloq_decomposition(prep);\n```\n\n----------------------------------------\n\nTITLE: Hubbard Model Hamiltonian Simulation Instance\nDESCRIPTION: Creates an instance of `HamiltonianSimulationByGQSP` using the `get_walk_operator_for_hubbard_model` function to create a walk operator. The `t` parameter specifies the simulation time and `precision` specifies error tolerance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/hamiltonian_simulation/hamiltonian_simulation_by_gqsp.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import (\n    get_walk_operator_for_hubbard_model,\n)\n\nwalk_op = get_walk_operator_for_hubbard_model(2, 2, 1, 1)\nhubbard_time_evolution_by_gqsp = HamiltonianSimulationByGQSP(walk_op, t=5, precision=1e-7)\n```\n\n----------------------------------------\n\nTITLE: GF2AddK Symbolic Example\nDESCRIPTION: Creates an instance of `GF2AddK` with symbolic parameters `m` and `k`.  This demonstrates how to define a `GF2AddK` bloq with symbolic dimensions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_add_k.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nm, k = sympy.symbols('m, k', positive=True, integers=True)\ngf2_add_k_symbolic = GF2AddK(m, k)\n```\n\n----------------------------------------\n\nTITLE: Compare Naive and Sparse State Preparation in Qualtran (Python)\nDESCRIPTION: This snippet demonstrates a comparison between a naive state preparation method (`PrepareSecondQuantizationDetailed`) and a sparse state preparation method (`PrepareSparse`) in Qualtran. It generates a random chemical Hamiltonian, prepares the state using both methods, and compares their Toffoli counts. This helps in understanding the performance benefits of using sparse preparation techniques.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.sparse.prepare import PrepareSparse\nnum_bits_state_prep = 4\nnum_spin_orb = 10\ntpq, eris = gen_random_chem_ham(num_spin_orb)\nalt_pqrs, keep = build_alt_keep_vals(tpq, eris, num_spin_orb, num_bits_state_prep)\nprep = PrepareSecondQuantizationDetailed(num_spin_orb, tuple(alt_pqrs), tuple(keep), num_bits_state_prep=num_bits_state_prep)\nprep_sparse = PrepareSparse.from_hamiltonian_coeffs(num_spin_orb, tpq, eris, num_bits_state_prep).decompose_bloq()\nprint(f\"naive = {toffoli_count(prep)}, sparse = {toffoli_count(prep_sparse)}\")\n```\n\n----------------------------------------\n\nTITLE: Installing Qualtran from PyPI using pip (shell)\nDESCRIPTION: This snippet shows how to install Qualtran from PyPI using pip. This installs the latest tagged release. Prerequisites: pip and a Python environment.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install qualtran\n```\n\n----------------------------------------\n\nTITLE: Creating a LessThanConstant instance\nDESCRIPTION: This creates an instance of the `LessThanConstant` bloq with `bitsize=8` and `less_than_val=5`, specifying that the integer to be compared is represented by 8 bits and the constant value is 5.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nlt_k = LessThanConstant(bitsize=8, less_than_val=5)\n```\n\n----------------------------------------\n\nTITLE: ParallelComparators Definition in Qualtran\nDESCRIPTION: Defines the `ParallelComparators` bloq that compares and swaps pairs of n-bit numbers with a specified offset. The `k` parameter specifies the size of the input list, `offset` specifies the distance between compared numbers, and `bitsize` the bit size of each number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.sorting import ParallelComparators\n```\n\n----------------------------------------\n\nTITLE: Build Composite Bloq: PrepareSecondQuantizationDetailed\nDESCRIPTION: This code defines a composite `Bloq` named `PrepareSecondQuantizationDetailed` for preparing a second quantization state.  It leverages Qualtran primitives like `PrepareUniformSuperposition`, `ContiguousIndexFourD`, `SelectSwapQROM`, `Hadamard`, `LessThanEqual`, and `CSwap`. The `build_composite_bloq` method defines the circuit's structure, utilizing QROAM to output alt/keep values, preparing a uniform superposition over sigma, and performing inequality tests for alias sampling.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom attrs import field\nfrom typing import Dict\nfrom qualtran import SoquetT, BloqBuilder, Register\n\nfrom qualtran.bloqs.data_loading.select_swap_qrom import SelectSwapQROM, find_optimal_log_block_size\nfrom qualtran.bloqs.basic_gates import Hadamard, OnEach\n\n\n@frozen\nclass PrepareSecondQuantizationDetailed(PrepareOracle):\n\n    num_spin_orb: int\n    alt_pqrs: Tuple[int, ...] = field(repr=False)\n    keep: Tuple[int, ...] = field(repr=False)\n    num_bits_state_prep: int = 16\n    qroam_block_size: Optional[int] = None\n\n    @cached_property\n    def selection_registers(self) -> Tuple[Register, ...]:\n        ns = self.num_spin_orb // 2\n        bitsize = (ns - 1).bit_length()\n        data_size = (ns ** 2 + ns**4)\n        contg_reg_size = (data_size - 1).bit_length()\n        return (\n            Register('p', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register('q', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register('r', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register('s', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb // 2)),\n            Register(\n                'l', BQUInt(bitsize=contg_reg_size, iteration_length=data_size),\n            ),\n            Register('alpha', BQUInt(1)),\n            Register('beta', BQUInt(1)),\n            Register('sigma', BQUInt(bitsize=self.num_bits_state_prep)),\n        )\n\n    @cached_property\n    def junk_registers(self) -> Tuple[Register, ...]:\n        alt_bitsize = (self.num_spin_orb // 2 - 1).bit_length()\n        return (\n            Register('alt_pqrs', QAny(alt_bitsize), shape=(4,)),\n            Register('keep', QAny(self.num_bits_state_prep)),\n            Register('less_than', QBit()),\n        )\n\n    def build_composite_bloq(\n        self,\n        bb: 'BloqBuilder',\n        p: 'SoquetT',\n        q: 'SoquetT',\n        r: 'SoquetT',\n        s: 'SoquetT',\n        l: 'SoquetT',\n        alpha: 'SoquetT',\n        beta: 'SoquetT',\n        sigma: 'SoquetT',\n        alt_pqrs: 'SoquetT',\n        keep: 'SoquetT',\n        less_than: 'SoquetT',\n    ) -> Dict[str, 'SoquetT']:\n        # 1. Prepare \\sum_d |d\\rangle\n        p = bb.add(PrepareUniformSuperposition(self.num_spin_orb // 2), target=p)\n        q = bb.add(PrepareUniformSuperposition(self.num_spin_orb // 2), target=q)\n        r = bb.add(PrepareUniformSuperposition(self.num_spin_orb // 2), target=r)\n        s = bb.add(PrepareUniformSuperposition(self.num_spin_orb // 2), target=s)\n        # 2. Make a contiguous register from our 4-registers\n        n_n = (self.num_spin_orb // 2 - 1).bit_length()\n        creg_bitsize = self.signature.get_left('l').bitsize\n        p, q, r, s, l = bb.add(ContiguousIndexFourD(n_n, creg_bitsize), p=p, q=q, r=r, s=s, l=l)\n        # 3. Output the alt / keep values using QRO(A)M. The target bitsizes are\n        # the sizes of the qrom data sets. The alt pqrs values have bitsize n_n\n        # and the keep register has bitsize of num_bits_state_prep, which\n        # controls the precision of the alias sampling.\n        target_bitsizes = (n_n,) * 4 + (self.num_bits_state_prep,)\n        ns = self.num_spin_orb // 2\n        data_size = ns ** 2 + ns**4\n        log_block_size = find_optimal_log_block_size(data_size, sum(target_bitsizes))\n        qroam = SelectSwapQROM.build_from_data(\n            self.alt_pqrs[0],\n            self.alt_pqrs[1],\n            self.alt_pqrs[2],\n            self.alt_pqrs[3],\n            self.keep,\n            target_bitsizes=target_bitsizes,\n            log_block_sizes=[log_block_size],\n            use_dirty_ancilla=False,\n        )\n        (l, alt_pqrs[0], alt_pqrs[1], alt_pqrs[2], alt_pqrs[3], keep) = bb.add(\n            qroam,\n            selection=l,\n            target0_=alt_pqrs[0],\n            target1_=alt_pqrs[1],\n            target2_=alt_pqrs[2],\n            target3_=alt_pqrs[3],\n            target4_=keep,\n        )\n        # 4. prepare uniform superposition over sigma\n        sigma = bb.add(OnEach(self.num_bits_state_prep, Hadamard()), q=sigma)\n        # 5. inequality test for alias sampling\n        lte_bloq = LessThanEqual(self.num_bits_state_prep, self.num_bits_state_prep)\n        keep, sigma, less_than = bb.add(lte_bloq, x=keep, y=sigma, target=less_than)\n        # 6. swap the ind and alt_pqrs values\n        less_than, alt_pqrs[0], p = bb.add(CSwap(n_n), ctrl=less_than, x=alt_pqrs[0], y=p)\n        less_than, alt_pqrs[1], q = bb.add(CSwap(n_n), ctrl=less_than, x=alt_pqrs[1], y=q)\n        less_than, alt_pqrs[2], r = bb.add(CSwap(n_n), ctrl=less_than, x=alt_pqrs[2], y=r)\n        less_than, alt_pqrs[3], s = bb.add(CSwap(n_n), ctrl=less_than, x=alt_pqrs[3], y=s)\n        # 7. invert the comparator\n        keep, sigma, less_than = bb.add(lte_bloq, x=keep, y=sigma, target=less_than)\n        return {\n            'p': p,\n            'q': q,\n            'r': r,\n            's': s,\n            'l': l,\n            'alpha': alpha,\n            'beta': beta,\n            'sigma': sigma,\n            'alt_pqrs': alt_pqrs,\n            'keep': keep,\n            'less_than': less_than,\n        }\n```\n\n----------------------------------------\n\nTITLE: Call Graph Visualization for TensorProduct\nDESCRIPTION: Generates and displays the call graph for the `tensor_product_block_encoding` instance, providing insight into the internal structure and dependencies. Also visualizes resource counts using `show_counts_sigma`. `ignore_split_join` is used to simplify the call graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/tensor_product.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ntensor_product_block_encoding_g, tensor_product_block_encoding_sigma = tensor_product_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(tensor_product_block_encoding_g)\nshow_counts_sigma(tensor_product_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Self-Adjoint Gate Examples in Qualtran\nDESCRIPTION: This code snippet demonstrates that the `XGate` and `CNOT` gates are self-adjoint (i.e., their adjoint is equal to themselves) by comparing the gate with its adjoint using the `==` operator. It requires the `CNOT` and `XGate` classes from `qualtran.bloqs.basic_gates`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CNOT, XGate\n\n# Examples of self-adjoint bloqs.\nprint('X == X^dag:      ', XGate() == XGate().adjoint())\nprint('CNOT == CNOT^dag:', CNOT() == CNOT().adjoint())\n```\n\n----------------------------------------\n\nTITLE: Initializing Equals Comparator in Qualtran\nDESCRIPTION: This snippet demonstrates how to initialize the `Equals` comparator with a `QUInt` of size 4. The `Equals` comparator checks if two quantum registers are equal.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nequals = Equals(QUInt(4))\n```\n\n----------------------------------------\n\nTITLE: Convert And bloq to Clifford+T circuit\nDESCRIPTION: This code converts the `and_bloq` to a Clifford+T circuit using the `to_clifford_t_circuit()` method. This facilitates the compilation of the `And` bloq into a gate set that is commonly used in fault-tolerant quantum computation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nand_bloq.to_clifford_t_circuit()\n```\n\n----------------------------------------\n\nTITLE: BitwiseNot example instantiation\nDESCRIPTION: Demonstrates the instantiation of the `BitwiseNot` class with a `QUInt` data type of size 4. This creates a bitwise NOT gate that operates on a register of 4 unsigned integer qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nbitwise_not = BitwiseNot(QUInt(4))\n```\n\n----------------------------------------\n\nTITLE: ControlledAddOrSubtract Instance - Unsigned Integers\nDESCRIPTION: Creates an instance of `ControlledAddOrSubtract` for unsigned 8-bit integers (`QUInt(8)`). This bloq can add or subtract an unsigned 8-bit integer into another unsigned 8-bit integer based on the control bit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_add_or_subtract.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nctrl_add_or_sub_unsigned = ControlledAddOrSubtract(QUInt(8), QUInt(8))\n```\n\n----------------------------------------\n\nTITLE: Showing BitonicSort Bloqs\nDESCRIPTION: Displays the graphical signatures of `bitonic_sort` and `bitonic_sort_symb` using `show_bloqs`. It visualizes the structure and registers of the bitonic sort network.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([bitonic_sort, bitonic_sort_symb],\n           ['`bitonic_sort`', '`bitonic_sort_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Initializing PrepareSecondQuantization bloq in Qualtran\nDESCRIPTION: This code defines the `PrepareSecondQuantization` bloq, inheriting from `PrepareOracle`. It sets up the selection registers (p, q, r, s, alpha, beta, sign) required for state preparation in second quantization algorithms. The register sizes are determined based on the number of spin orbitals.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import cached_property\nfrom typing import Tuple\nfrom attrs import frozen\nfrom qualtran import Register, BQUInt, QBit, QAny\n\nfrom qualtran.drawing import show_bloq\nfrom qualtran.bloqs.state_preparation.prepare_base import PrepareOracle\n\n@frozen\nclass PrepareSecondQuantization(PrepareOracle):\n\n    num_spin_orb: int\n\n    @cached_property\n    def selection_registers(self) -> Tuple[Register, ...]:\n        bitsize = (self.num_spin_orb // 2 - 1).bit_length()\n        return (\n            Register('p', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb//2)),\n            Register('q', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb//2)),\n            Register('r', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb//2)),\n            Register('s', BQUInt(bitsize=bitsize, iteration_length=self.num_spin_orb//2)),\n            Register('alpha', BQUInt(bitsize=1)),\n            Register('beta', BQUInt(bitsize=1)),\n            Register('sign', BQUInt(bitsize=1)),\n        )\n\n    # defer definition of junk registers until you actually need to implement a decomposition.\n\nshow_bloq(PrepareSecondQuantization(4))\n```\n\n----------------------------------------\n\nTITLE: Create Bell State Circuit in Cirq\nDESCRIPTION: This code snippet demonstrates how to create a Bell state circuit using Cirq, leveraging the `to_cirq_circuit` method available in Qualtran's CompositeBloq. This allows for interoperability between Qualtran's higher-level representations and Cirq's circuit-level descriptions. The created circuit is then visualized using `SVGCircuit`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.contrib.svg import SVGCircuit\ncircuit = cbloq.to_cirq_circuit()\nSVGCircuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Instantiating QubitizationQPE for Hubbard Model\nDESCRIPTION: This snippet demonstrates how to instantiate the `QubitizationQPE` class for the Hubbard model. It imports necessary functions to define the walk operator for the Hubbard model, sets parameters like `x_dim`, `y_dim`, `t`, and `u`, calculates `qlambda` and `qpe_eps`, and then creates an instance of `QubitizationQPE` using the calculated parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import (\n    get_walk_operator_for_hubbard_model,\n)\nfrom qualtran.bloqs.phase_estimation import LPResourceState, QubitizationQPE\n\nx_dim, y_dim, t = 2, 2, 2\nu = 4 * t\nwalk = get_walk_operator_for_hubbard_model(x_dim, y_dim, t, u)\n\nalgo_eps = t / 100\nN = x_dim * y_dim * 2\nqlambda = 2 * N * t + (N * u) // 2\nqpe_eps = algo_eps / (qlambda * np.sqrt(2))\nqubitization_qpe_hubbard_model_small = QubitizationQPE(\n    walk, LPResourceState.from_standard_deviation_eps(qpe_eps)\n)\n```\n\n----------------------------------------\n\nTITLE: Import BlockEncoding Class from Qualtran - Python\nDESCRIPTION: This code snippet imports the `BlockEncoding` class from the `qualtran.bloqs.block_encoding` module. This class serves as the base for defining various block encoding schemes within the Qualtran framework. It provides an abstract interface for implementing specific block encoding algorithms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/block_encoding.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import BlockEncoding\n```\n\n----------------------------------------\n\nTITLE: Initializing StatePreparationViaRotations\nDESCRIPTION: This snippet initializes the `StatePreparationViaRotations` bloq with a specified `phase_bitsize` (precision for rotation angles) and `state_coefficients` (the target quantum state coefficients). The bloq is then visualized using `show_bloq`. `phase_bitsize` controls the accuracy of the rotation. The example shows the bloq and its decomposition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nqsp = StatePreparationViaRotations(\n    phase_bitsize=phase_bitsize, state_coefficients=tuple(state_coefs)\n)\nshow_bloq(qsp)\nshow_bloq(qsp.decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: Call Graph of Hubbard Time Evolution\nDESCRIPTION: Generates and displays the call graph for the `hubbard_time_evolution_by_gqsp` instance using `hubbard_time_evolution_by_gqsp.call_graph`.  The `ignore_split_join` generalizer simplifies the graph by ignoring split and join operations. Displays both the graph and the sigma counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/hamiltonian_simulation/hamiltonian_simulation_by_gqsp.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nhubbard_time_evolution_by_gqsp_g, hubbard_time_evolution_by_gqsp_sigma = hubbard_time_evolution_by_gqsp.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(hubbard_time_evolution_by_gqsp_g)\nshow_counts_sigma(hubbard_time_evolution_by_gqsp_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Qualtran and Related Libraries\nDESCRIPTION: This code snippet imports necessary modules from the `qualtran` library, including classes for building quantum circuits like `Bloq`, `CompositeBloq`, and `BloqBuilder`. It also imports modules for defining data types such as `QBit`, `QInt`, `QUInt`, and `QAny`, as well as libraries for drawing and visualization, such as `cirq`, `numpy`, and `sympy`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_square.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Fixed-Point Multiplication of Two Reals - Python\nDESCRIPTION: Implements fixed-point multiplication of two real numbers using repeated additions, as described in Appendix D5. `get_bitsize_for_fxp_mul` calculates the number of bits required based on the desired error tolerance (epsilon). `mul_via_repeated_add` performs the actual multiplication, and `test_multiplication_for_eps` validates the results against standard floating-point multiplication using the helper function `assert_allclose`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/error_analysis_for_fxp_arithmetic.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Multiplying two real numbers\ndef get_bitsize_for_fxp_mul(eps: float):\n    return int(np.ceil(1 + np.log2(1/eps)) + np.log2(1 + np.log2(1/eps))) # Equation D17\n\ndef mul_via_repeated_add(a: float, b: float, d: int):\n    \"\"\"Multiplicaiton via repeated additions algorithm described in Appendix D5\"\"\"\n    a_fxp, b_fxp = fxp(a, d=d), fxp(b, d=d)\n    res = fxp(0, d=d)\n    for i, b_bin in enumerate(b_fxp.bin()[:-1]):\n        a_fxp >>= 1\n        if int(b_bin):\n            res += a_fxp\n    return res\n\ndef test_multiplication_for_eps(eps: float, d: int):\n    rng = np.random.default_rng(int(eps * 1e9))\n    try:\n        for _ in range(100):\n            a, b = rng.random(2)\n            res = mul_via_repeated_add(a, b, d)\n            assert_allclose(res, a * b, eps)\n        print(f'Success! {d=}, {eps=}')\n    except AssertionError:\n        print(f'Failed! {d=}, {eps=}')\n\nfor eps in [1e-3, 1e-4, 1e-5, 1e-6, 1e-7]:\n    d = get_bitsize_for_fxp_mul(eps)\n    test_multiplication_for_eps(eps, d - 1) # Works for d-1 as well, bounds in the paper are probably loose?\n```\n\n----------------------------------------\n\nTITLE: Example Instance of SelectBlockEncoding\nDESCRIPTION: This snippet creates an example instance of `SelectBlockEncoding` using `SelectHubbard` and `PrepareHubbard` for a 3x3 Hubbard model. It sets up the parameters for the Hubbard model and initializes the `select_block` object.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import PrepareHubbard, SelectHubbard\n\n# 3x3 hubbard model U/t = 4\ndim = 3\nselect = SelectHubbard(x_dim=dim, y_dim=dim)\nU = 4\nt = 1\nprepare = PrepareHubbard(x_dim=dim, y_dim=dim, t=t, u=U)\nselect_block = SelectBlockEncoding(select=select, prepare=prepare)\n```\n\n----------------------------------------\n\nTITLE: Instantiate RectangularWindowState with symbolic size\nDESCRIPTION: Creates an instance of `RectangularWindowState` with a symbolic size 'n' using `sympy.Symbol`. This allows for the creation of a symbolic instance that can be used for resource estimation or other symbolic calculations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nrectangular_window_state_symbolic = RectangularWindowState(sympy.Symbol('n'))\n```\n\n----------------------------------------\n\nTITLE: Phase Estimation Circuit Example\nDESCRIPTION: This snippet demonstrates the usage of the phase_estimation function with a walk operator for the 1D Ising model.  It sets the number of sites, error tolerance, and the number of bits of accuracy, then constructs and prints the resulting Cirq circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnum_sites: int = 6\neps: float = 1e-2\nm_bits: int = 4\n\nwalk_op, _ = get_walk_operator_for_1d_ising_model(num_sites, eps)\ncircuit = cirq.Circuit(phase_estimation(walk_op, m=m_bits))\nprint(circuit)\n```\n\n----------------------------------------\n\nTITLE: Instantiating QubitizationQPE for THC Hamiltonian\nDESCRIPTION: This snippet instantiates `QubitizationQPE` for a THC (Tensor Hyper-Contraction) Hamiltonian. It builds random test integrals for the THC Hamiltonian, retrieves the walk operator, calculates `qpe_eps` based on algorithm accuracy, and finally instantiates the `QubitizationQPE` class with the walk operator and calculated epsilon.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom openfermion.resource_estimates.utils import QI\n\nfrom qualtran.bloqs.chemistry.thc.prepare_test import build_random_test_integrals\nfrom qualtran.bloqs.chemistry.thc.walk_operator import get_walk_operator_for_thc_ham\nfrom qualtran.bloqs.phase_estimation import LPResourceState, QubitizationQPE\n\n# Li et al parameters from openfermion.resource_estimates.thc.compute_cost_thc_test\nnum_spinorb = 152\nnum_bits_state_prep = 10\nnum_bits_rot = 20\nthc_dim = 450\nnum_spat = num_spinorb // 2\nqroam_blocking_factor = np.power(2, QI(thc_dim + num_spat)[0])\nt_l, eta, zeta = build_random_test_integrals(thc_dim, num_spinorb // 2, seed=7)\nwalk = get_walk_operator_for_thc_ham(\n    t_l,\n    eta,\n    zeta,\n    num_bits_state_prep=num_bits_state_prep,\n    num_bits_theta=num_bits_rot,\n    kr1=qroam_blocking_factor,\n    kr2=qroam_blocking_factor,\n)\n\nalgo_eps = 0.0016\nqpe_eps = algo_eps / (walk.block_encoding.alpha * 2**0.5)\nqubitization_qpe_chem_thc = QubitizationQPE(\n    walk, LPResourceState.from_standard_deviation_eps(qpe_eps)\n)\n```\n\n----------------------------------------\n\nTITLE: Import SumOfSquares Bloq\nDESCRIPTION: Imports the `SumOfSquares` class from the `qualtran.bloqs.arithmetic` module.  This bloq computes the sum of squares of k n-bit binary numbers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import SumOfSquares\n```\n\n----------------------------------------\n\nTITLE: Import Square Bloq\nDESCRIPTION: Imports the `Square` class from the `qualtran.bloqs.arithmetic` module.  This bloq computes the square of an n-bit binary number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Square\n```\n\n----------------------------------------\n\nTITLE: Import LinearCombination from qualtran\nDESCRIPTION: This snippet imports the `LinearCombination` class from the `qualtran.bloqs.block_encoding` module. This class is used to create block encodings of linear combinations of unitary operators.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/linear_combination.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import LinearCombination\n```\n\n----------------------------------------\n\nTITLE: Create instances of OutOfPlaceAdder gate\nDESCRIPTION: Creates example instances of the `OutOfPlaceAdder` gate with different register sizes, including symbolic and fixed sizes.  This demonstrates how to instantiate the gate for different bit sizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nadd_oop_symb = OutOfPlaceAdder(bitsize=n)\n```\n\nLANGUAGE: python\nCODE:\n```\nadd_oop_small = OutOfPlaceAdder(bitsize=4)\n```\n\nLANGUAGE: python\nCODE:\n```\nadd_oop_large = OutOfPlaceAdder(bitsize=64)\n```\n\n----------------------------------------\n\nTITLE: Instantiating PrepareSparse from Hamiltonian Coefficients\nDESCRIPTION: This snippet demonstrates how to create an instance of the `PrepareSparse` class from Hamiltonian coefficients. It first builds random test integrals, then uses the `from_hamiltonian_coeffs` method to initialize `PrepareSparse` with the number of spin orbitals, Tpq (one-body integrals), ERIs (two-body integrals), and the number of bits for state preparation precision.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.sparse.prepare_test import build_random_test_integrals\n\nnum_spin_orb = 6\ntpq, eris = build_random_test_integrals(num_spin_orb // 2)\nprep_sparse = PrepareSparse.from_hamiltonian_coeffs(\n    num_spin_orb, tpq, eris, num_bits_state_prep=4\n)\n```\n\n----------------------------------------\n\nTITLE: Import SelectBlockEncoding from qualtran\nDESCRIPTION: This snippet imports the `SelectBlockEncoding` class from the `qualtran.bloqs.block_encoding` module. `SelectBlockEncoding` implements block encoding using SELECT and PREPARE oracles.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import SelectBlockEncoding\n```\n\n----------------------------------------\n\nTITLE: Create Bell State in Qualtran\nDESCRIPTION: This code demonstrates how to create a Bell state (|00> + |11>) in Qualtran. It initializes a PlusState and a ZeroState, then applies a CNOT gate with the PlusState as control and the ZeroState as target. Finally, it visualizes the resulting composite bloq and its tensor contraction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CNOT\n\nbb = BloqBuilder()\n\nq0 = bb.add(PlusState())\nq1 = bb.add(ZeroState())\n\nq0, q1 = bb.add(CNOT(), ctrl=q0, target=q1)\n\ncbloq = bb.finalize(q0=q0, q1=q1)\nshow_bloq(cbloq)\nprint(cbloq.tensor_contract())\n```\n\n----------------------------------------\n\nTITLE: Create instances of Add gate\nDESCRIPTION: Creates example instances of the `Add` gate with different register sizes, including symbolic sizes and fixed sizes. This demonstrates how to instantiate the gate with different `QInt` and `QUInt` data types.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nadd_symb = Add(QInt(bitsize=n))\n```\n\nLANGUAGE: python\nCODE:\n```\nadd_small = Add(QUInt(bitsize=4))\n```\n\nLANGUAGE: python\nCODE:\n```\nadd_large = Add(QUInt(bitsize=64))\n```\n\nLANGUAGE: python\nCODE:\n```\nadd_diff_size_regs = Add(QUInt(bitsize=4), QUInt(bitsize=16))\n```\n\n----------------------------------------\n\nTITLE: Fixed-Point Squaring of a Real Number - Python\nDESCRIPTION: Implements fixed-point squaring of a real number using repeated additions, based on Appendix D6. The `get_bitsize_for_fxp_square` function determines the necessary bitsize based on the error tolerance. The `square_via_repeated_add` function carries out the squaring operation. Finally, `test_square_for_eps` validates the results by comparing them to the square of the floating-point number with a specified tolerance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/error_analysis_for_fxp_arithmetic.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Squaring a real number\ndef get_bitsize_for_fxp_square(eps: float):\n    return int(np.ceil(np.log2(1/eps) + np.log2(11/3 + np.log2(1/eps)))) # Equation D36\n\ndef square_via_repeated_add(a: float, d: int):\n    a = fxp(a, d)\n    res = fxp(0, d=d)\n    a_bin = [int(x) for x in a.bin()]\n    one = fxp(0.5, d=d)\n    \n    # Equation D23 & D29\n    for n in range(d//2, d-1):\n        res += (a >> n) * a_bin[n]\n    mask = fxp(0, d=d)\n    for n in range((d - 1) // 2):\n        res += (((a & mask) >> n) + ((one >> (2*n+1)) * a_bin[n])) * a_bin[n]\n        mask |= (one >> n)\n    if not d & 1: # Equation D29\n        n = d // 2 - 1\n        res += ((a & mask) >> n) * a_bin[n]\n    return res\n\ndef test_square_for_eps(eps: float, d: int):\n    rng = np.random.default_rng(int(eps * 1e9))\n    try:\n        for _ in range(100):\n            a, = rng.random(1)\n            res = square_via_repeated_add(a, d)\n            assert_allclose(res, a**2, eps)\n        print(f'Success! {d=}, {eps=}')\n    except AssertionError:\n        print(f'Failed! {d=}, {eps=}')\n\n\nfor eps in [1e-3, 1e-4, 1e-5, 1e-6, 1e-7]:\n    d = get_bitsize_for_fxp_square(eps) # Need a +1 to make it work for smaller `eps`. Bound in the paper is too tight?\n    test_square_for_eps(eps, d)\n```\n\n----------------------------------------\n\nTITLE: Allocating Qubits with ZeroState and PlusState in Qualtran\nDESCRIPTION: This snippet demonstrates how to allocate qubits in the |0> and |+> states using the `ZeroState` and `PlusState` bloqs in Qualtran. It uses `BloqBuilder` to create a composite bloq that allocates one qubit in the zero state and another in the plus state. Finally, it displays the bloq using `show_bloq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import BloqBuilder\nfrom qualtran.bloqs.basic_gates import ZeroState, PlusState\n\nbb = BloqBuilder()\nzero_q = bb.add(ZeroState())\nplus_q = bb.add(PlusState())\ncbloq = bb.finalize(q0=zero_q, q1=plus_q)\n\nfrom qualtran.drawing import show_bloq\nshow_bloq(cbloq)\n```\n\n----------------------------------------\n\nTITLE: PlusEqualProduct Example Instance\nDESCRIPTION: Creates an instance of the `PlusEqualProduct` class with specified bitsizes for the input registers `a`, `b`, and the output register `result`. `PlusEqualProduct` performs result += a * b or result -= a * b based on the `is_adjoint` parameter.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na_bit, b_bit, res_bit = 2, 2, 4\nplus_equal_product = PlusEqualProduct(a_bit, b_bit, res_bit)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and Cirq\nDESCRIPTION: Imports necessary modules from Qualtran and Cirq, including Bloq, CompositeBloq, BloqBuilder, Signature, Register, QBit, QInt, QUInt, QAny, and modules for drawing and visualization. It also imports typing, numpy, and sympy.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: GF2MulViaKaratsuba Instance Creation\nDESCRIPTION: Creates an instance of the `GF2MulViaKaratsuba` class. It defines a polynomial `m_x` and uses it to initialize a finite field `QGF(2, 5, m_x)`. The `GF2MulViaKaratsuba` object is then instantiated with this finite field.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nm_x = [5, 2, 0]  # x^5 + x^2 + 1\ngf2mulviakaratsuba = GF2MulViaKaratsuba(QGF(2, 5, m_x))\n```\n\n----------------------------------------\n\nTITLE: Approximate QFT Instance Creation (Epsilon)\nDESCRIPTION: This snippet shows how to create an instance of the `ApproximateQFT` class using an epsilon value to determine the size of the phase gradient register. It initializes an approximate QFT for 50 qubits with an error tolerance of `1e-5`. The `.from_epsilon()` method automatically calculates the required `phase_bitsize`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/approximate_qft.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nepsilon = 1e-5\napproximate_qft_from_epsilon = ApproximateQFT.from_epsilon(50, epsilon)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of Symbolic Hamiltonian Simulation\nDESCRIPTION: Generates and displays the call graph for the `symbolic_hamsim_by_gqsp` instance. Uses generalizers like `ignore_split_join`, `ignore_alloc_free`, and `generalize_rotation_angle` to simplify the call graph by ignoring split/join operations, allocation/freeing, and generalizing rotation angles. Then displays the sigma counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/hamiltonian_simulation/hamiltonian_simulation_by_gqsp.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import generalize_rotation_angle, ignore_split_join, ignore_alloc_free\n_, symbolic_hamsim_by_gqsp_sigma = symbolic_hamsim_by_gqsp.call_graph(max_depth=2, generalizer=[ignore_split_join, ignore_alloc_free, generalize_rotation_angle])\nshow_counts_sigma(symbolic_hamsim_by_gqsp_sigma)\n```\n\n----------------------------------------\n\nTITLE: Musical Score Visualization for UniformSuperpositionTHC\nDESCRIPTION: Generates and displays a musical score visualization of the `UniformSuperpositionTHC` bloq using `draw_musical_score`. This provides a detailed view of the quantum circuit's operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing.musical_score import draw_musical_score, get_musical_score_data\n\nmsd = get_musical_score_data(thc_uni.decompose_bloq())\nfig, ax = draw_musical_score(msd)\nfig.set_size_inches(20, 10)\n```\n\n----------------------------------------\n\nTITLE: Define CSwapApprox\nDESCRIPTION: Defines the CSwapApprox class, which approximately implements a multi-target controlled swap unitary using 4n T-gates. This is useful when an incorrect phase can be absorbed into a garbage state. It takes the bitsize as a parameter and operates on control, x, and y registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.swap_network import CSwapApprox\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counts for PrepareSparse\nDESCRIPTION: This code generates and displays the call graph and resource counts for the `prep_sparse` bloq. It uses `call_graph` method with a specified `max_depth` and `generalizer` to simplify the graph. The resulting graph and sigma counts are then displayed using `show_call_graph` and `show_counts_sigma`, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprep_sparse_g, prep_sparse_sigma = prep_sparse.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prep_sparse_g)\nshow_counts_sigma(prep_sparse_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiate GF2PolyAdd with concrete parameters\nDESCRIPTION: Creates an instance of `GF2PolyAdd` with specific parameters for a polynomial of degree 4 over GF(2^3). `QGFPoly` defines the data type of the quantum register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QGF, QGFPoly\n\nqgf_poly = QGFPoly(4, QGF(2, 3))\ngf2_poly_4_8_add = GF2PolyAdd(qgf_poly)\n```\n\n----------------------------------------\n\nTITLE: Initializing SelectSwapQROM with Symbolic Dimensions (2D, Clean Ancilla)\nDESCRIPTION: This snippet initializes a `SelectSwapQROM` with 2D symbolic dimensions and clean ancilla. It defines symbols N, M, b1, b2, k1, k2, and c, then creates `qroam_symb_clean_2d` using `build_from_bitsize` with `use_dirty_ancilla=False`. This allows exploring QROM costs using symbolic dimensions and clean ancilla qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nN, M, b1, b2, k1, k2, c = sympy.symbols('N M b1 b2 k1 k2 c', positive=True, integers=True)\nlog_block_sizes = (k1, k2)\nqroam_symb_clean_2d = SelectSwapQROM.build_from_bitsize(\n    (N, M), (b1, b2), log_block_sizes=log_block_sizes, num_controls=c, use_dirty_ancilla=False\n)\n```\n\n----------------------------------------\n\nTITLE: ModSub Example Instance\nDESCRIPTION: Creates an instance of the `ModSub` class with a `QUInt` register of size `n` and a symbolic modulus `p`. Demonstrates how to instantiate the modular subtraction gate with symbolic parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\nmodsub_symb = ModSub(QUInt(n), p)\n```\n\n----------------------------------------\n\nTITLE: SparseMatrixHermitian Example (Concrete)\nDESCRIPTION: Demonstrates the creation of a `SparseMatrixHermitian` instance using concrete dimensions. It creates `TopLeftRowColumnOracle` and `UniformSqrtEntryOracle` instances with a system bitsize of 2. Finally, it instantiates `SparseMatrixHermitian` with these oracles and `eps=0`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix_hermitian.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding.sparse_matrix import TopLeftRowColumnOracle\nfrom qualtran.bloqs.block_encoding.sparse_matrix_hermitian import UniformSqrtEntryOracle\n\ncol_oracle = TopLeftRowColumnOracle(system_bitsize=2)\nentry_oracle = UniformSqrtEntryOracle(system_bitsize=2, entry=0.3)\nsparse_matrix_hermitian_block_encoding = SparseMatrixHermitian(col_oracle, entry_oracle, eps=0)\n```\n\n----------------------------------------\n\nTITLE: Import CYGate from Qualtran (Python)\nDESCRIPTION: This snippet imports the `CYGate` class from the `qualtran.bloqs.basic_gates` module, which represents the controlled Y gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CYGate\n```\n\n----------------------------------------\n\nTITLE: Display graphical representation of And bloq\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display a graphical representation of the instantiated `and_bloq`. The graphical representation helps visualize the inputs, outputs, and internal structure of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([and_bloq],\n           ['`and_bloq`'])\n```\n\n----------------------------------------\n\nTITLE: Importing GreaterThanConstant Bloq\nDESCRIPTION: This line imports the `GreaterThanConstant` class from the `qualtran.bloqs.arithmetic` module. The `GreaterThanConstant` bloq is used to compare an integer against a constant value.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import GreaterThanConstant\n```\n\n----------------------------------------\n\nTITLE: Dense State Preparation with Symbolic Parameters\nDESCRIPTION: This code demonstrates the usage of `StatePreparationAliasSampling` with symbolic parameters using the `sympy` library. It defines symbolic variables `n_coeffs`, `sum_coeff`, and `eps` to represent the number of coefficients, the sum of coefficients, and the desired precision, respectively. It then uses the `from_n_coeff` method to create a `StatePreparationAliasSampling` instance with these symbolic parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nn_coeffs, sum_coeff, eps = sympy.symbols(r\"L \\lambda \\epsilon\")\nstate_prep_alias_symb = StatePreparationAliasSampling.from_n_coeff(\n    n_coeffs, sum_coeff, precision=eps\n)\n```\n\n----------------------------------------\n\nTITLE: Convert Adjoint of And bloq to Clifford+T circuit\nDESCRIPTION: This snippet takes the adjoint (inverse) of the `and_bloq` and converts it to a Clifford+T circuit using the `to_clifford_t_circuit()` method. This is useful for uncomputing the `And` operation in reversible quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nand_bloq.adjoint().to_clifford_t_circuit()\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph of ApplyLthBloq\nDESCRIPTION: This code generates the call graph and sigma counts for the `apply_lth_bloq` using `apply_lth_bloq.call_graph`. The `ignore_split_join` generalizer is used to simplify the graph. The call graph and sigma counts are then displayed using `show_call_graph` and `show_counts_sigma` respectively, providing insights into the bloq's resource costs and dependencies.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_lth_bloq.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\napply_lth_bloq_g, apply_lth_bloq_sigma = apply_lth_bloq.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(apply_lth_bloq_g)\nshow_counts_sigma(apply_lth_bloq_sigma)\n```\n\n----------------------------------------\n\nTITLE: And Gate Adjoint Cost Comparison in Qualtran\nDESCRIPTION: This example demonstrates that the `And` gate has a special optimized construction for its adjoint which results in reduced cost. The call graphs and sigma costs for both forward and backward (adjoint) direction are displayed using `show_counts_sigma`. It uses `And` gate from `qualtran.bloqs.mcmt` and `show_counts_sigma` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# A bloq with a special construction (and reduced cost) for its adjoint.\n\nfrom qualtran.bloqs.mcmt import And\nfrom qualtran.drawing import show_counts_sigma\n\n_, forward_costs = And().call_graph()\n_, backward_costs = And().adjoint().call_graph()\nshow_counts_sigma(forward_costs)\nshow_counts_sigma(backward_costs)\n```\n\n----------------------------------------\n\nTITLE: Import NewtonRaphsonApproxInverseSquareRoot\nDESCRIPTION: This snippet imports the `NewtonRaphsonApproxInverseSquareRoot` class from the `qualtran.bloqs.chemistry.trotter.grid_ham.inverse_sqrt` module. This class implements a single Newton-Raphson step to approximate the inverse square root.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.grid_ham.inverse_sqrt import NewtonRaphsonApproxInverseSquareRoot\n```\n\n----------------------------------------\n\nTITLE: Importing the QFTTextBook class\nDESCRIPTION: Imports the `QFTTextBook` class from the `qualtran.bloqs.qft` module, enabling its use in quantum circuit constructions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_text_book.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.qft import QFTTextBook\n```\n\n----------------------------------------\n\nTITLE: Importing SingleQubitCompare Bloq\nDESCRIPTION: This line imports the `SingleQubitCompare` class from the `qualtran.bloqs.arithmetic` module. The `SingleQubitCompare` bloq applies a comparison operation on two qubits and stores the results in ancilla qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import SingleQubitCompare\n```\n\n----------------------------------------\n\nTITLE: HasDuplicates Symbolic Instance\nDESCRIPTION: Creates a symbolic instance of the `HasDuplicates` class. The length of the list is fixed to 4, but the data type (`dtype`) of each element is set to `QUInt(n)`, where `n` is a symbolic variable defined using `sympy.Symbol(\"n\")`. This allows for a more general representation where the number of qubits required for each element can be determined later.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nn = sympy.Symbol(\"n\")\nhas_duplicates_symb = HasDuplicates(4, QUInt(n))\n```\n\n----------------------------------------\n\nTITLE: Contract tensor network to obtain result and junk indices\nDESCRIPTION: This code contracts the tensor network of the composite bloq (`cbloq`) to obtain a vector representing the probability amplitudes of the output states. It then uses `np.where` to find the non-zero entries in the reshaped vector, extracting the indices corresponding to the junk and result qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Our tensor network now just has the result index and a junk index.\n# We use `np.where` to find non-zero entries into this.\n# In fact -- the second index corresponding to `res` is the bit output\nvec = cbloq.tensor_contract()\njunk_i, res_i = np.where(vec.reshape((2, 2)))\nres_i\n```\n\n----------------------------------------\n\nTITLE: Instantiate YPowGate with exponent and eps\nDESCRIPTION: This snippet creates an instance of the YPowGate class, setting the exponent to 0.123 and the precision (eps) to 1e-8. The exponent determines the amount of rotation around the Y-axis of the Bloch sphere.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ny_pow = YPowGate(exponent=0.123, eps=1e-8)\n```\n\n----------------------------------------\n\nTITLE: Controlled State Preparation\nDESCRIPTION: This code demonstrates controlled state preparation using the `StatePreparationViaRotations` bloq. The bloq is initialized with a `control_bitsize` of 1, indicating that it is controlled by a qubit. A plus state is prepared for the control qubit. The circuit then prepares the target state conditionally based on the control qubit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nqsp_ctrl = StatePreparationViaRotations(\n    phase_bitsize=phase_bitsize,\n    state_coefficients=tuple(state_coefs),\n    control_bitsize=1\n)\nbb = BloqBuilder()\ncontrol = bb.add(PlusState())\nstate = bb.allocate(state_bitsize)\nphase_gradient = bb.add(PhaseGradientState(phase_bitsize))\ncontrol, state, phase_gradient = bb.add(\n    qsp_ctrl, prepare_control=control, target_state=state, phase_gradient=phase_gradient\n)\nbb.add(PhaseGradientState(bitsize=phase_bitsize).adjoint(), phase_grad=phase_gradient)\nnetwork = bb.finalize(control=control, state=state)\ncoefficients = network.tensor_contract()\ncorrect = 1 / np.sqrt(2) * np.array([1] + [0] * (2**state_bitsize - 1) + list(state_coefs))\n```\n\n----------------------------------------\n\nTITLE: Show graphical representation of Swap gates\nDESCRIPTION: Generates and displays graphical representations of the `Swap` gates with symbolic and fixed bitsizes using the `show_bloqs` function. The gates are labeled accordingly.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([swap, swap_small, swap_large],\n           ['`swap`', '`swap_small`', '`swap_large`'])\n```\n\n----------------------------------------\n\nTITLE: Defining ThreeParallelBloqs - Python\nDESCRIPTION: Defines a custom `Bloq` called `ThreeParallelBloqs` which contains three `TestParallelCombo` bloqs in sequence.  This is a helper class used in the `flatten` examples.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nclass ThreeParallelBloqs(Bloq):\n    @property\n    def signature(self) -> Signature:\n        return Signature.build(stuff=3)\n\n    def build_composite_bloq(\n            self, bb: 'BloqBuilder', stuff: 'SoquetT'\n    ) -> Dict[str, 'SoquetT']:\n        stuff = bb.add(TestParallelCombo(), reg=stuff)\n        stuff = bb.add(TestParallelCombo(), reg=stuff)\n        stuff = bb.add(TestParallelCombo(), reg=stuff)\n        return {'stuff': stuff}\n```\n\n----------------------------------------\n\nTITLE: Initializing SelectSwapQROM with Numerical Data (2D)\nDESCRIPTION: This snippet demonstrates initializing `SelectSwapQROM` with 2D numpy arrays. It creates two 2D arrays, `data1` and `data2`, using `np.arange` and `reshape`, and then uses `build_from_data` to instantiate `qroam_multi_dim`. This shows how to use multi-dimensional data with `SelectSwapQROM`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndata1 = np.arange(25).reshape((5, 5))\ndata2 = (np.arange(25) + 1).reshape((5, 5))\nqroam_multi_dim = SelectSwapQROM.build_from_data(data1, data2)\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for QuantumVariableRotation\nDESCRIPTION: This snippet generates and displays the call graph for the `QuantumVariableRotation` bloq, up to a depth of 1. It uses `ignore_split_join` as a generalizer and visualizes the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nqvr_g, qvr_sigma = qvr.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(qvr_g)\nshow_counts_sigma(qvr_sigma)\n```\n\n----------------------------------------\n\nTITLE: ControlledAddOrSubtract Instance - Signed Integers\nDESCRIPTION: Creates an instance of `ControlledAddOrSubtract` for signed 8-bit integers (`QInt(8)`). This bloq can add or subtract a signed 8-bit integer into another signed 8-bit integer based on the control bit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_add_or_subtract.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nctrl_add_or_sub_signed = ControlledAddOrSubtract(QInt(8), QInt(8))\n```\n\n----------------------------------------\n\nTITLE: Basic Product Block Encoding\nDESCRIPTION: This example demonstrates the creation of a `Product` block encoding using two `Unitary` block encodings: one representing a T gate and the other a Hadamard gate. The resulting `product_block_encoding` combines these two unitaries into a single block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/product.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard, TGate\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\nproduct_block_encoding = Product((Unitary(TGate()), Unitary(Hadamard())))\n```\n\n----------------------------------------\n\nTITLE: Hadamard Gate Graphical Signature (Python)\nDESCRIPTION: Generates a graphical representation of the Hadamard gate using Qualtran's drawing utilities. This allows for visual inspection of the bloq's input and output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([hadamard],\n           ['`hadamard`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph of BinaryPolynomialMultiplication\nDESCRIPTION: Generates and displays the call graph for `binarypolynomialmultiplication`, ignoring split-join operations. The call graph shows the decomposition of the bloq into quantum gates, with a maximum depth of 1. Also displays the associated resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nbinarypolynomialmultiplication_g, binarypolynomialmultiplication_sigma = binarypolynomialmultiplication.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(binarypolynomialmultiplication_g)\nshow_counts_sigma(binarypolynomialmultiplication_sigma)\n```\n\n----------------------------------------\n\nTITLE: Casting with QAny and QUInt in Qualtran\nDESCRIPTION: This snippet demonstrates how to use `QAny` and `Cast` in Qualtran to handle untyped quantum variables and cast them to specific data types. It allocates three qubits in the zero state, joins them into a `QAny(3)` variable, and then casts the variable to a `QUInt(3)` using the `Cast` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nbb = BloqBuilder()\n\n# Make three |0> qubits\nqs = [bb.add(ZeroState()) for _ in range(3)]\n\n# Join them into one quantum variable. Since\n# we don't specify a type, `x` is `QAny(3)`. \nx = bb.join(qs)\n\n# Maybe we're trying to allocate an unsigned integer.\nfrom qualtran.bloqs.bookkeeping import Cast\nfrom qualtran import QAny\nx = bb.add(Cast(inp_dtype=QAny(3), out_dtype=QUInt(3)), reg=x)\n\ncbloq = bb.finalize(x=x)\nshow_bloq(cbloq)\n```\n\n----------------------------------------\n\nTITLE: Convert to Contiguous Index Example Instance\nDESCRIPTION: Creates an instance of `ToContiguousIndex` with specified `bitsize` and `s_bitsize`. This instance can then be used in a quantum circuit for converting to a contiguous index.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nto_contg_index = ToContiguousIndex(bitsize=4, s_bitsize=8)\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying a call graph for LessThanConstant\nDESCRIPTION: This generates a call graph for the `lt_k` bloq, which visualizes the dependencies and sub-components within the quantum circuit. It also computes and displays the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlt_k_g, lt_k_sigma = lt_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lt_k_g)\nshow_counts_sigma(lt_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display graphical representation of MultiAnd bloq\nDESCRIPTION: This code uses the `show_bloqs` function to generate and display a graphical representation of the instantiated `multi_and` bloq.  The graphical representation visually represents the MultiAnd gate, showing its control qubits, target qubit, and any ancilla qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([multi_and],\n           ['`multi_and`'])\n```\n\n----------------------------------------\n\nTITLE: PrepareFirstQuantization bloq definition\nDESCRIPTION: This snippet imports the `PrepareFirstQuantization` class from `qualtran.bloqs.chemistry.pbc.first_quantization`. This class is a Qualtran `Bloq` responsible for preparing the quantum state representing the first quantized chemistry Hamiltonian, as described in the provided reference paper.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization import PrepareFirstQuantization\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: Imports necessary modules from the `qualtran` library and other standard libraries for defining and visualizing quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Decomposing Subbloqs Manually in Qualtran\nDESCRIPTION: This code decomposes each subbloq within a flattened `CompositeBloq`. It iterates through the subbloqs and uses `decompose_bloq()` to decompose each subbloq before adding it to the new `CompositeBloq` being built.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Go through and decompose each subbloq\n# We'll manually code this up in this notebook since this isn't a useful operation.\nbb, _ = BloqBuilder.from_signature(flat_three_p.signature)\nsoq_map: List[Tuple[SoquetT, SoquetT]] = []\n    \nfor binst, in_soqs, old_out_soqs in flat_three_p.iter_bloqsoqs():\n    in_soqs = bb.map_soqs(in_soqs, soq_map)\n    \n    # Here, we call `decompose_bloq()` before adding in the subbloq\n    new_out_soqs = bb.add_t(binst.bloq.decompose_bloq(), **in_soqs)\n    soq_map.extend(zip(old_out_soqs, new_out_soqs))\n\nfsoqs = bb.map_soqs(flat_three_p.final_soqs(), soq_map)\ndecompose_children = bb.finalize(**fsoqs)\nshow_bloq(decompose_children)\n```\n\n----------------------------------------\n\nTITLE: Activate a Conda environment\nDESCRIPTION: This command activates an existing Conda environment. This needs to be executed each time a new terminal is opened.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nconda activate my-qualtran-env\n```\n\n----------------------------------------\n\nTITLE: Import necessary libraries for QubitCount estimation\nDESCRIPTION: Imports the required modules from Qualtran for defining a bloq with interior allocation and resource counting, including `sympy` for symbolic computation, `InteriorAlloc` for creating a bloq with an interior allocation, and `get_cost_value`, `query_costs`, and `QubitCount` for resource estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/resource_counting/qubit_counts.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.drawing import show_bloq\n\nfrom qualtran.bloqs.for_testing.interior_alloc import InteriorAlloc\nfrom qualtran.resource_counting import get_cost_value, query_costs, QubitCount\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and Related Libraries\nDESCRIPTION: Imports necessary modules from the Qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, Register, and quantum data types. It also imports typing, numpy, sympy, and cirq for general use.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: SelectPauliLCU Example Instance\nDESCRIPTION: This code snippet demonstrates how to instantiate a `SelectPauliLCU` object. It defines a list of Pauli strings (`us`), calculates the required selection bitsize, and then creates a `SelectPauliLCU` instance with the specified parameters: `selection_bitsize`, `target_bitsize`, and `select_unitaries`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/select_pauli_lcu.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntarget_bitsize = 4\nus = ['XIXI', 'YIYI', 'ZZZZ', 'ZXYZ']\nus = [cirq.DensePauliString(u) for u in us]\nselection_bitsize = int(np.ceil(np.log2(len(us))))\nselect_pauli_lcu = SelectPauliLCU(selection_bitsize, target_bitsize, select_unitaries=us)\n```\n\n----------------------------------------\n\nTITLE: Import Necessary Modules\nDESCRIPTION: Imports necessary modules from Qualtran and other libraries such as numpy, sympy, and cirq. These modules are essential for defining quantum circuits, handling symbolic calculations, and performing numerical computations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Resource Estimates for 1D Ising Model\nDESCRIPTION: This snippet calculates resource estimates (QEC gate cost) for the 1D Ising model using a specified number of sites, error tolerance, and bits of accuracy. It uses the phase_estimation function and the get_qec_gates_cost_for_circuit function to obtain the cost and prints the result.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.cirq_interop.t_complexity_protocol import t_complexity_compat\n\nnum_sites: int = 200\neps: float = 1e-5\nm_bits: int = 14\n\nwalk, _ = get_walk_operator_for_1d_ising_model(num_sites, eps)\n\ncircuit = cirq.Circuit(phase_estimation(walk, m=m_bits))\n%time result = get_qec_gates_cost_for_circuit(circuit)\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Wiring Bloqs with BloqBuilder (Way 2) - Python\nDESCRIPTION: Demonstrates an alternative wiring of two `CNOT` Bloqs using `BloqBuilder`. The key difference is the second `CNOT` gate's control and target are reversed, leading to a different circuit structure. The `finalize` method creates a `CompositeBloq` from the constructed circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Wire up (way 2)\nbb = BloqBuilder()\nq0 = bb.add_register('q0', 1)\nq1 = bb.add_register('q1', 1)\nq0, q1 = bb.add(bloq, ctrl=q0, target=q1)\nq0, q1 = bb.add(bloq, ctrl=q1, target=q0) ## !!\ncbloq = bb.finalize(q0=q0, q1=q1)\nshow_bloq(cbloq)\n```\n\n----------------------------------------\n\nTITLE: Import Libraries\nDESCRIPTION: Imports necessary libraries from Qualtran and standard Python libraries for building quantum circuits, data manipulation, and visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Displaying ModDbl Bloqs Graphically\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical representations of the `moddbl_small` and `moddbl_large` Bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([moddbl_small, moddbl_large],\n           ['`moddbl_small`', '`moddbl_large`'])\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying the Call Graph for the Toffoli gate\nDESCRIPTION: This snippet generates a call graph for the `toffoli` gate to visualize its decomposition into sub-operations. It uses `toffoli.call_graph()` with a maximum depth of 1 and a generalizer to ignore split/join operations (`ignore_split_join`). The resulting graph and sigma counts are then displayed using `show_call_graph` and `show_counts_sigma` respectively. This is for resource estimation and optimization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/toffoli.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ntoffoli_g, toffoli_sigma = toffoli.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(toffoli_g)\nshow_counts_sigma(toffoli_sigma)\n```\n\n----------------------------------------\n\nTITLE: Signed Integer to Two's Complement Conversion\nDESCRIPTION: Defines a class for converting a signed integer (ones' complement) to its two's complement representation. This conversion is performed in-place. The `bitsize` parameter specifies the size of the register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.conversions import SignedIntegerToTwosComplement\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and Related Modules\nDESCRIPTION: Imports necessary modules from the `qualtran` library, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register, as well as QBit, QInt, QUInt, and QAny for defining quantum data types. Also imports modules for drawing and visualization, such as show_bloq, show_call_graph, and show_counts_sigma, and standard Python libraries like typing, numpy, sympy and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/trigonometric/trigonometric.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Using GraphvizCallGraph to generate an SVG (Python)\nDESCRIPTION: This code snippet demonstrates how to use the `GraphvizCallGraph` class to generate an SVG representation of a call graph. It initializes `GraphvizCallGraph` with a call graph and then uses `get_svg_bytes` to obtain the SVG data as bytes. The code then prints the first 400 bytes of the SVG data to the console. This requires the `pydot` and `graphviz` libraries to be installed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/drawing/drawing_call_graph.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import GraphvizCallGraph\n\ndrawer = GraphvizCallGraph(call_graph)\n\n# Additional methods are provided like `get_svg_bytes` which can\n# be written to a file to save the diagram.\nprint(drawer.get_svg_bytes()[:400], '...')\n```\n\n----------------------------------------\n\nTITLE: CModNeg Example Instance\nDESCRIPTION: Creates an instance of the `CModNeg` class with a `QUInt` register of size `n=32` and a symbolic modulus `p`. This example instantiates a controlled modular negation gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn = 32\nprime = sympy.Symbol('p')\ncmod_neg = CModNeg(QUInt(n), mod=prime)\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying a call graph for BiQubitsMixer\nDESCRIPTION: This generates a call graph for the `bi_qubits_mixer` bloq, which visualizes the dependencies and sub-components within the quantum circuit. It also computes and displays the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nbi_qubits_mixer_g, bi_qubits_mixer_sigma = bi_qubits_mixer.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(bi_qubits_mixer_g)\nshow_counts_sigma(bi_qubits_mixer_sigma)\n```\n\n----------------------------------------\n\nTITLE: Sparse Permutation Definition\nDESCRIPTION: Creates a `Permutation` instance from a partial permutation map. The map defines a permutation only for some indices, leaving others unchanged. In this case, the permutation is defined on a total size of 16, with the mapping {0: 1, 1: 3, 2: 8, 3: 15, 4: 12}.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsparse_permutation = Permutation.from_partial_permutation_map(\n    16, {0: 1, 1: 3, 2: 8, 3: 15, 4: 12}\n)\n```\n\n----------------------------------------\n\nTITLE: GF2MulViaKaratsuba Call Graph\nDESCRIPTION: Generates and displays the call graph for the `GF2MulViaKaratsuba` object.  It uses `qualtran.resource_counting.generalizers.ignore_split_join` to simplify the call graph and then visualizes it using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf2mulviakaratsuba_g, gf2mulviakaratsuba_sigma = gf2mulviakaratsuba.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf2mulviakaratsuba_g)\nshow_counts_sigma(gf2mulviakaratsuba_sigma)\n```\n\n----------------------------------------\n\nTITLE: Decomposing and Showing a Bloq Diagram - Python\nDESCRIPTION: Shows how to decompose a `Bloq` (in this case, `TestTwoCNOT`) into its composite representation and then display the resulting diagram using `show_bloq`.  The `decompose_bloq()` method leverages the `build_composite_bloq` implementation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(TestTwoCNOT().decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying a call graph for GreaterThanConstant\nDESCRIPTION: This generates a call graph for the `gt_k` bloq, which visualizes the dependencies and sub-components within the quantum circuit. It also computes and displays the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngt_k_g, gt_k_sigma = gt_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gt_k_g)\nshow_counts_sigma(gt_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: GF2Addition Class Definition\nDESCRIPTION: Import the GF2Addition class from the qualtran.bloqs.gf_arithmetic module. This class implements in-place addition over GF($2^m$).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_addition.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2Addition\n```\n\n----------------------------------------\n\nTITLE: BitonicSort with Symbolic Bitsize\nDESCRIPTION: Creates a `BitonicSort` instance with a symbolic bitsize `n`.  It sorts 4 integers, each with a bitsize of n, demonstrating how to use symbolic values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nbitonic_sort_symb = BitonicSort(4, n)\n```\n\n----------------------------------------\n\nTITLE: Import ProgrammableRotationGateArray\nDESCRIPTION: Imports the `ProgrammableRotationGateArray` class from `qualtran.bloqs.rotations`. This allows for the creation of instances of the class and its usage in quantum algorithms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/programmable_rotation_gate_array.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import ProgrammableRotationGateArray\n```\n\n----------------------------------------\n\nTITLE: Sign Truncate Example Instance\nDESCRIPTION: Creates an instance of `SignTruncate` to truncate a 16-bit integer (`QInt(16)`) to an 8-bit integer (`QInt(8)`). This demonstrates how to use the `SignTruncate` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QInt\n\nsign_truncate = SignTruncate(QInt(16), QInt(8))\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counting\nDESCRIPTION: This code generates and visualizes the call graph and resource counts for the `ctrl_on_int` instance. `ignore_split_join` is used as a generalizer to simplify the call graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nctrl_on_int_g, ctrl_on_int_sigma = ctrl_on_int.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ctrl_on_int_g)\nshow_counts_sigma(ctrl_on_int_sigma)\n```\n\n----------------------------------------\n\nTITLE: InvertRealNumber Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `InvertRealNumber` instance, using the `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ninvert_real_number_g, invert_real_number_sigma = invert_real_number.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(invert_real_number_g)\nshow_counts_sigma(invert_real_number_sigma)\n```\n\n----------------------------------------\n\nTITLE: Decompose and Show MultiAnd Bloq with Graphviz in Python\nDESCRIPTION: This snippet decomposes a `MultiAnd` gate into its constituent bloqs and displays the resulting circuit diagram using Graphviz. It demonstrates how to use the `MultiAnd` gate and the `show_bloq` function from the `qualtran` library to visualize a quantum circuit's structure. The decomposition creates a `CompositeBloq` which can then be visualized.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/drawing/musical_score.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mcmt import MultiAnd\nfrom qualtran.drawing import show_bloq\n\ncbloq = MultiAnd((1,1,0,1)).decompose_bloq()\nshow_bloq(cbloq)\n```\n\n----------------------------------------\n\nTITLE: Compare Toffoli Counts\nDESCRIPTION: This code compares the Toffoli counts for the original `PrepareSecondQuantization` bloq and the decomposed `PrepareSecondQuantizationDetailed` bloq. This provides insights into the cost differences between the black box QROAM cost and the cost provided by `SelectSwapQROM`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprep_basic = toffoli_count(PrepareSecondQuantization(num_spin_orb))\nprep_decom = toffoli_count(prep.decompose_bloq())\nprint(f\"call graph = {prep_basic}, decomposition = {prep_decom}\")\n```\n\n----------------------------------------\n\nTITLE: Iterating Bloqnections - Python\nDESCRIPTION: Shows how to iterate over bloq instances and their connections using `cbloq.iter_bloqnections()`. The example prints each bloq instance along with its incoming and outgoing connections.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfor binst, pred_cxns, succ_cxns in cbloq.iter_bloqnections():\n    print(binst)\n    for pred in pred_cxns:\n        print('  ', pred.left, '->', pred.right)\n    for succ in succ_cxns:\n        print('  ', succ.left, '->', succ.right)\n```\n\n----------------------------------------\n\nTITLE: GF2MulK Instance from Polynomials\nDESCRIPTION: Creates an instance of the `GF2MulK` bloq directly from polynomial coefficients for the constant (fx) and modulus (mx). This alternative constructor `from_polynomials` is used to define constant multiplication in GF(2^3).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfx = [2, 0]  # x^2 + 1\nmx = [0, 1, 3]  # x^3 + x + 1\ngf2_poly_multiply_by_constant = GF2MulK.from_polynomials(fx, mx)\n```\n\n----------------------------------------\n\nTITLE: Using GateHelper Class\nDESCRIPTION: This snippet demonstrates the usage of the `GateHelper` class, which simplifies the process of working with `GateWithRegisters`. It shows how to access the signature, named qubits, operation, and circuit associated with the gate through the `GateHelper` instance.  It also demonstrates how to decompose the circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport qualtran.cirq_interop.testing as cq_testing\n\ng = cq_testing.GateHelper(gate)\n\nprint('r:', g.r)\nprint('quregs:', g.quregs)\nprint('operation:', g.operation)\nprint('\\ncircuit:\\n', g.circuit)\nprint('\\n\\ndecomposed circuit:\\n', cirq.Circuit(cirq.decompose_once(g.operation)))\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph of Bloq\nDESCRIPTION: Generates and displays the call graph of the `programmable_rotation_gate_array` bloq. It uses the `call_graph` method with `max_depth=1` and `ignore_split_join` generalizer, then displays the call graph and counts sigma using `show_call_graph` and `show_counts_sigma` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/programmable_rotation_gate_array.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprogrammable_rotation_gate_array_g, programmable_rotation_gate_array_sigma = programmable_rotation_gate_array.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(programmable_rotation_gate_array_g)\nshow_counts_sigma(programmable_rotation_gate_array_sigma)\n```\n\n----------------------------------------\n\nTITLE: Controlled Hadamard Gate Definition (Python)\nDESCRIPTION: Defines the `CHadamard` gate as a controlled version of the Hadamard gate. Includes register definitions for the control and target qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CHadamard\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for SU2RotationGate\nDESCRIPTION: This snippet generates and displays the call graph for the `su2_rotation_gate`. It uses the `call_graph` method of the `SU2RotationGate` class, along with the `ignore_split_join` generalizer, to create the call graph and its associated sigma counts, which are then visualized using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/su2_rotation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsu2_rotation_gate_g, su2_rotation_gate_sigma = su2_rotation_gate.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(su2_rotation_gate_g)\nshow_counts_sigma(su2_rotation_gate_sigma)\n```\n\n----------------------------------------\n\nTITLE: SelectSwapQROM Import\nDESCRIPTION: This snippet imports the `SelectSwapQROM` class from the `qualtran.bloqs.data_loading.select_swap_qrom` module. This allows the user to utilize the optimized QROM implementation for loading data into quantum registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.data_loading.select_swap_qrom import SelectSwapQROM\n```\n\n----------------------------------------\n\nTITLE: Define a Placeholder Bloq: ContiguousIndexFourD\nDESCRIPTION: This code defines a placeholder `Bloq` called `ContiguousIndexFourD`. It takes an input of four `bitsize` registers (p, q, r, s) and maps them to a contiguous `output_bitsize` register l. It also includes a method to calculate the T complexity and build a call graph for the bloq, currently using `Toffoli` gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Signature, Bloq\nfrom qualtran.bloqs.basic_gates import Toffoli\nfrom qualtran.cirq_interop.t_complexity_protocol import TComplexity\n\n\n@frozen\nclass ContiguousIndexFourD(Bloq):\n    bitsize: int\n    output_bitsize: int\n\n    @cached_property\n    def signature(self) -> Signature:\n        return Signature.build(\n            p=self.bitsize, q=self.bitsize, r=self.bitsize, s=self.bitsize, l=self.output_bitsize\n        )\n\n    # Exercise (easy): wire up this bloq\n    # Exercise (harder): test that your decomposition is correct! Some of the\n    #   arithmetic sub-bloqs will require more details!\n    # Exercise (easy): add an on_classical_vals method\n    # Exercise: Send a PR for this bloq\n\n    def t_complexity(self) -> TComplexity:\n        return TComplexity(t=4 * (3 * (self.bitsize**2 - self.bitsize) + 4 * (self.bitsize - 1))) \n\n    def build_call_graph(self, ssa: 'SympySymbolAllocator') -> Set['BloqCountT']:\n        # Exercise: Use existing bloqs in qualtran to give this call graph a little more spice.\n        cost = 3 * (self.bitsize**2 - self.bitsize) + 4 * (self.bitsize - 1)\n        return {(Toffoli(), cost)}\n```\n\n----------------------------------------\n\nTITLE: Display SignTruncate Bloq\nDESCRIPTION: Displays the graphical representation of the `sign_truncate` Bloq using the `show_bloqs` function. This provides a visual representation of the quantum circuit implemented by the `SignTruncate` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sign_truncate],\n           ['`sign_truncate`'])\n```\n\n----------------------------------------\n\nTITLE: Create CtrlScaleModAdd instance with small constant parameters in Python\nDESCRIPTION: Creates an instance of the `CtrlScaleModAdd` class with specific constant parameters: bitsize=4, mod=7, and k=1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nctrl_scale_mod_add_small = CtrlScaleModAdd(bitsize=4, mod=7, k=1)\n```\n\n----------------------------------------\n\nTITLE: Instantiate SubtractFrom gate with large size\nDESCRIPTION: Creates an instance of the `SubtractFrom` gate with a large size of 64 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsub_from_large = SubtractFrom(QInt(bitsize=64))\n```\n\n----------------------------------------\n\nTITLE: Signed Integer to Two's Complement Example Instance\nDESCRIPTION: Creates an instance of `SignedIntegerToTwosComplement` with a register size of 10 bits. This instance can then be used to construct quantum circuits for converting signed integers to two's complement representation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsigned_to_twos = SignedIntegerToTwosComplement(bitsize=10)\n```\n\n----------------------------------------\n\nTITLE: MultiTargetCNOT Call Graph\nDESCRIPTION: Generates and displays the call graph of the symbolic `MultiTargetCNOT` instance, ignoring split and join operations using `qualtran.resource_counting.generalizers.ignore_split_join`. This call graph is used for resource analysis.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nc_multi_not_symb_g, c_multi_not_symb_sigma = c_multi_not_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(c_multi_not_symb_g)\nshow_counts_sigma(c_multi_not_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Plotting QPE Simulation Results\nDESCRIPTION: This code generates a plot comparing the results of QPE simulations using different window functions. It calculates the Holevo variance for each window function's estimates and displays the probability distribution of the estimated phases alongside the true phase. Matplotlib is used for creating the plot, which includes labels, titles, and a legend.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\nplt.rcParams['figure.figsize'] = (20, 10)\n\ntheta_counts_textbok = np.bincount(thetas_textbook) / n_samples\ntheta_counts_sinstate = np.bincount(thetas_sinstate) / n_samples\ntheta_counts_kaiser = np.bincount(thetas_kaiser_state) / n_samples\nvar_textbook = holevo_variance(thetas_textbook / 2**m)\nvar_sinstate = holevo_variance(thetas_sinstate / 2**m)\nvar_kaiser = holevo_variance(thetas_kaiser_state / 2**m)\n\nplt.plot(np.array(x_vals[:len(theta_counts_textbok)]), theta_counts_textbok, label=r\"TextbookQPE; var($\\tilde{\\phi}$)=\"f\"{var_textbook:.2e}\")\nplt.plot(np.array(x_vals[:len(theta_counts_sinstate)]), theta_counts_sinstate, label=r\"SinStateQPE; var($\\tilde{\\phi}$)=\"f\"{var_sinstate:.2e}\")\nplt.plot(np.array(x_vals[:len(theta_counts_kaiser)]), theta_counts_kaiser, label=f\"KaiserQPE({alpha=:0.3}); \"r\"var($\\tilde{\\phi}$)=\"f\"{var_kaiser:.2e}\")\nplt.vlines(theta, 0, 1, linestyles='--', label=f'True Phase $\\phi$={theta}', colors='red')\nplt.yscale('log', base=10)\nplt.ylabel(f'Fraction of samples')\nplt.xlabel(f'{m}-bit approximation of phase measured by running QPE. Should be close to {theta=}')\nplt.title(f'QPE on ZPowGate(2 * {theta}) using {m=} bit control register and {n_samples} samples.')\nplt.legend()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Import DoubleFactorizationBlockEncoding from qualtran\nDESCRIPTION: This line imports the `DoubleFactorizationBlockEncoding` class from the specified module within the `qualtran` library. This bloq represents a block encoding of the double factorization Hamiltonian.  It will be used in example code later on.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.df.double_factorization import DoubleFactorizationBlockEncoding\n```\n\n----------------------------------------\n\nTITLE: Comparator Instance Example\nDESCRIPTION: An example of instantiating the Comparator class with a bitsize of 3. This creates a comparator object that can compare two 3-bit numbers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncomparator = Comparator(3)\n```\n\n----------------------------------------\n\nTITLE: Generate and display call graph and counts sigma for And bloq\nDESCRIPTION: This snippet generates the call graph and counts sigma for the `and_bloq` using the `call_graph` method. The `ignore_split_join` generalizer is used to simplify the call graph. The call graph and counts sigma are then displayed using `show_call_graph` and `show_counts_sigma` respectively, providing insights into the bloq's internal structure and resource usage.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nand_bloq_g, and_bloq_sigma = and_bloq.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(and_bloq_g)\nshow_counts_sigma(and_bloq_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph for CModAddK\nDESCRIPTION: Generates and displays the call graph and resource counts for the `cmod_add_k` using `call_graph` with `ignore_split_join`.  The graph and counts are visualized using `show_call_graph` and `show_counts_sigma`, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncmod_add_k_g, cmod_add_k_sigma = cmod_add_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cmod_add_k_g)\nshow_counts_sigma(cmod_add_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: Initializing fxpmath and Assertions - Python\nDESCRIPTION: Defines helper functions for creating fixed-point numbers using `fxpmath` and performing assertions to check the closeness of fixed-point results to floating-point values. It configures `fxpmath` to minimize bit growth during arithmetic operations and truncate shifted bits, crucial for accurately simulating fixed-point behavior. The `assert_allclose` function verifies the accuracy of the fixed-point calculations against standard floating-point results.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/error_analysis_for_fxp_arithmetic.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\nfrom fxpmath import Fxp\nimport numpy as np\n\n# Initial setup - Helpers\ndef fxp(x: float, d: int, *, d_word: Optional[int]=None) -> Fxp:\n    \"\"\"Creates an unsigned fixed-point representation of `x` with `d` bits of precision after decimal.\"\"\"\n    assert 0 <= x < 1\n    d_word = d if d_word is None else d_word\n    # Dtype Format: f'fxp-{signed/unsigned}{total_bitsize}/{frac_bitsize}'\n    dtype = f'fxp-u{d_word}/{d}'\n\n    # `op_sizing` and `const_op_sizing` controls the behavior of fixed point type when performing \n    # arithmetic with other fixed point types. Setting the value to `same` ensures that no addition\n    # bits are used during arithmetic. \n    # shifting='trunc' sets the behavior of fixed point type to truncate shifted bits when doing a\n    # bitwise left/right shift operation.\n    return Fxp(x, dtype=dtype, op_sizing='same', const_op_sizing='same', shifting='trunc')\n\ndef assert_allclose(x: Fxp, y: float, eps: float):\n    np.testing.assert_allclose(x.get_val(), y, atol=eps)\n```\n\n----------------------------------------\n\nTITLE: Instantiate PrepareSecondQuantizationDetailed\nDESCRIPTION: This code demonstrates how to generate random chemistry Hamiltonian elements using `gen_random_chem_ham` and then uses the `build_alt_keep_vals` function to build the alt and keep values. Finally, it instantiates `PrepareSecondQuantizationDetailed` with the generated values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.chem_tutorials import gen_random_chem_ham\nnum_bits_state_prep = 10\nnum_spin_orb = 10\ntpq, eris = gen_random_chem_ham(num_spin_orb)\nalt_pqrs, keep = build_alt_keep_vals(tpq, eris, num_spin_orb, num_bits_state_prep)\nprep = PrepareSecondQuantizationDetailed(num_spin_orb, tuple(alt_pqrs), tuple(keep), num_bits_state_prep=num_bits_state_prep)\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signatures of CModAdd instances in Python\nDESCRIPTION: Uses `show_bloqs` to display the graphical signatures of the `cmodadd_example` and `cmodadd_symbolic` instances of the `CModAdd` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cmodadd_example, cmodadd_symbolic],\n           ['`cmodadd_example`', '`cmodadd_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Call graph generation for Swap gate\nDESCRIPTION: Generates and displays the call graph and resource counts sigma for the `Swap` gate, using the `call_graph` method and `ignore_split_join` generalizer to simplify the graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nswap_g, swap_sigma = swap.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(swap_g)\nshow_counts_sigma(swap_sigma)\n```\n\n----------------------------------------\n\nTITLE: ModNeg Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma of the `ModNeg` bloq. The `ignore_split_join` generalizer is used to simplify the call graph. This is used for resource estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmod_neg_g, mod_neg_sigma = mod_neg.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(mod_neg_g)\nshow_counts_sigma(mod_neg_sigma)\n```\n\n----------------------------------------\n\nTITLE: Importing Qualtran and Cirq Libraries\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register, as well as various register types (QBit, QInt, QUInt, QAny). It also imports typing hints, NumPy, SymPy, and Cirq, which are essential for defining and manipulating quantum circuits and data structures.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/cnot.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Create Magic State\nDESCRIPTION: Creates the T|+> magic state using the PlusState and TGate. This example demonstrates how to combine gates in Qualtran to generate quantum states and performs tensor contraction on the resulting circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/t_gate.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import PlusState\n\nbb = BloqBuilder()\nq = bb.add(PlusState())\nq = bb.add(TGate(), q=q)\ncbloq = bb.finalize(q=q)\nshow_bloq(cbloq, 'musical_score')\nprint(cbloq.tensor_contract() * np.sqrt(2))\n```\n\n----------------------------------------\n\nTITLE: Qualtran Approximate QFT Import\nDESCRIPTION: This snippet imports the `ApproximateQFT` class from the `qualtran.bloqs.qft` module. The `ApproximateQFT` class is the core component being documented and is used to perform approximate Quantum Fourier Transforms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/approximate_qft.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.qft import ApproximateQFT\n```\n\n----------------------------------------\n\nTITLE: Create Small CAdd Instance\nDESCRIPTION: This snippet creates an instance of the `CAdd` class with a `QUInt` register of size 3, representing a small controlled addition gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_addition.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncadd_small = CAdd(QUInt(3))\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph for BlackBoxSelect\nDESCRIPTION: This snippet generates a call graph for the `black_box_select` object with a maximum depth of 1, ignoring split/join operations. It then displays the generated call graph and sigma counts using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nblack_box_select_g, black_box_select_sigma = black_box_select.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(black_box_select_g)\nshow_counts_sigma(black_box_select_sigma)\n```\n\n----------------------------------------\n\nTITLE: Reflection Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma for `refl_using_prep`. It uses `ignore_split_join` as a generalizer to simplify the graph by ignoring split and join operations. `max_depth` limits the depth of the call graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nrefl_using_prep_g, refl_using_prep_sigma = refl_using_prep.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(refl_using_prep_g)\nshow_counts_sigma(refl_using_prep_sigma)\n```\n\n----------------------------------------\n\nTITLE: Define GFPolyJoin operation in Qualtran\nDESCRIPTION: Defines the `GFPolyJoin` operation in Qualtran. This operation is the inverse of `GFPolySplit`. It takes an array of QGF registers representing the coefficients of a polynomial and joins them into a single `QGFPoly` register. This facilitates constructing a polynomial from its coefficients.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf_poly_split_and_join.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_poly_arithmetic import GFPolyJoin\n```\n\n----------------------------------------\n\nTITLE: Decompose Subtract gate\nDESCRIPTION: Decomposes the `Subtract` gate with a symbolic size 'n' into its constituent gates. This is useful for understanding the gate's implementation and resource requirements. Requires the `sympy` library.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nsub_symp_decomposition = Subtract(QInt(bitsize=n)).decompose_bloq()\n```\n\n----------------------------------------\n\nTITLE: Import YPowGate from qualtran.bloqs.basic_gates\nDESCRIPTION: This snippet imports the YPowGate class from the qualtran.bloqs.basic_gates module. This import is necessary to use the YPowGate class in your code.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import YPowGate\n```\n\n----------------------------------------\n\nTITLE: Create ModAddK instance with symbolic parameters in Python\nDESCRIPTION: Creates an instance of the `ModAddK` class with symbolic parameters 'n', 'm', and 'k' for bitsize, modulus, and add_val, respectively.  These parameters are sympy symbols.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn, m, k = sympy.symbols('n m k')\nmod_add_k = ModAddK(bitsize=n, mod=m, add_val=k)\n```\n\n----------------------------------------\n\nTITLE: Import LPResourceState from qualtran.bloqs\nDESCRIPTION: This code imports the `LPResourceState` class from the `qualtran.bloqs.phase_estimation.lp_resource_state` module. This bloq is used to prepare the optimal resource state for phase estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation.lp_resource_state import LPResourceState\n```\n\n----------------------------------------\n\nTITLE: ModSub Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma of the `ModSub` bloq, using the `ignore_split_join` generalizer for simplification. This is used for resource analysis of modular subtraction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmodsub_symb_g, modsub_symb_sigma = modsub_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(modsub_symb_g)\nshow_counts_sigma(modsub_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Creating a LessThanEqual instance with symbolic parameters\nDESCRIPTION: This creates an instance of the `LessThanEqual` bloq with symbolic parameters for `x_bitsize` and `y_bitsize` using the `sympy` library. This enables parameterized circuit construction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nn1, n2 = sympy.symbols('n1 n2')\nleq_symb = LessThanEqual(x_bitsize=n1, y_bitsize=n2)\n```\n\n----------------------------------------\n\nTITLE: Displaying ThreeParallelBloqs - Python\nDESCRIPTION: Displays `ThreeParallelBloqs` using `show_bloq`.  The `as_composite_bloq` method is used to wrap the bloq into a compute graph with a single node.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Note! We're using `.as_composite_bloq()` to wrap the Bloq\n# into a compute graph with one node.\nthree_p = ThreeParallelBloqs().as_composite_bloq()\nshow_bloq(three_p)\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signatures of KaliskiModInverse instances\nDESCRIPTION: This code generates and displays the graphical signatures of both the concrete (`kaliskimodinverse_example`) and symbolic (`kaliskimodinverse_symbolic`) instances of the `KaliskiModInverse` class.  This helps visualize the input and output registers of the quantum operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_division.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([kaliskimodinverse_example, kaliskimodinverse_symbolic],\n           ['`kaliskimodinverse_example`', '`kaliskimodinverse_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: SelectHubbard Import\nDESCRIPTION: Imports the `SelectHubbard` class from the `qualtran.bloqs.chemistry.hubbard_model.qubitization` module. This class implements the SELECT operation optimized for the 2D Hubbard model.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import SelectHubbard\n```\n\n----------------------------------------\n\nTITLE: Generating and Visualizing CNOT Call Graph\nDESCRIPTION: This snippet generates a call graph for the `cnot` gate using `cnot.call_graph`. The `ignore_split_join` generalizer simplifies the graph. The resulting graph and sigma values are then visualized using `show_call_graph` and `show_counts_sigma` to analyze resource consumption.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/cnot.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncnot_g, cnot_sigma = cnot.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cnot_g)\nshow_counts_sigma(cnot_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph\nDESCRIPTION: This snippet generates and displays the call graph for the `prep_uniform` bloq. It utilizes `ignore_split_join` generalizer to simplify the graph by ignoring split and join operations. The `call_graph` method creates the graph and its associated counts sigma, which are then visualized using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/prepare_uniform_superposition.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprep_uniform_g, prep_uniform_sigma = prep_uniform.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prep_uniform_g)\nshow_counts_sigma(prep_uniform_sigma)\n```\n\n----------------------------------------\n\nTITLE: CSwap instantiation with symbolic bitsize\nDESCRIPTION: Instantiates a `CSwap` object (controlled swap) with a symbolic bitsize 'n' using `sympy.Symbol`. This creates a generic controlled swap gate for registers of size 'n'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CSwap\n```\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n', positive=True, integer=True)\ncswap = CSwap(bitsize=n)\n```\n\n----------------------------------------\n\nTITLE: QROAMClean build_from_data Example\nDESCRIPTION: Example of constructing a `QROAMClean` instance from numpy arrays using the `build_from_data` factory method.  Two arrays `data1` and `data2` are used to construct the QROAM, with a log block size of 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndata1 = np.arange(5, dtype=int)\ndata2 = np.arange(5, dtype=int) + 1\nqroam_clean_multi_data = QROAMClean.build_from_data(data1, data2, log_block_sizes=(1,))\n```\n\n----------------------------------------\n\nTITLE: Instantiate PrepareUniformSuperposition\nDESCRIPTION: This snippet demonstrates the instantiation of the `PrepareUniformSuperposition` class with `n=5`. This creates an object that prepares a uniform superposition over the first 5 basis states (|0>, |1>, |2>, |3>, |4>).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/prepare_uniform_superposition.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprep_uniform = PrepareUniformSuperposition(n=5)\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counting for KaliskiModInverse\nDESCRIPTION: This code generates and displays the call graph and resource counts for the `kaliskimodinverse_example` instance. The call graph shows the dependencies between different quantum operations within the `KaliskiModInverse` implementation, while the resource counts provide an estimate of the quantum resources required for the computation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_division.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nkaliskimodinverse_example_g, kaliskimodinverse_example_sigma = kaliskimodinverse_example.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(kaliskimodinverse_example_g)\nshow_counts_sigma(kaliskimodinverse_example_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show Sparse State Preparation Bloqs\nDESCRIPTION: This code snippet utilizes the `show_bloqs` function from `qualtran.drawing` to display graphical representations of the `sparse_state_prep_alias`, `sparse_state_prep_alias_from_list`, and `sparse_state_prep_alias_symb` bloqs. The function takes a list of bloqs and corresponding labels as arguments to visualize them.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sparse_state_prep_alias, sparse_state_prep_alias_from_list, sparse_state_prep_alias_symb],\n           ['`sparse_state_prep_alias`', '`sparse_state_prep_alias_from_list`', '`sparse_state_prep_alias_symb`'])\n```\n\n----------------------------------------\n\nTITLE: PrepareIdentity Import\nDESCRIPTION: Imports the `PrepareIdentity` class from the `qualtran.bloqs.reflections.prepare_identity` module. This class implements an identity PrepareOracle for creating a reflection about zero and as a signal state for block encodings.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.reflections.prepare_identity import PrepareIdentity\n```\n\n----------------------------------------\n\nTITLE: Importing Equals from qualtran.bloqs.arithmetic\nDESCRIPTION: This snippet imports the `Equals` class from the `qualtran.bloqs.arithmetic` module. The `Equals` class is used to implement a quantum equality comparison.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Equals\n```\n\n----------------------------------------\n\nTITLE: DoubleFactorizationBlockEncoding Example Instance\nDESCRIPTION: This snippet demonstrates how to instantiate the `DoubleFactorizationBlockEncoding` bloq with specific parameters. It defines the number of spin orbitals, the dimension of the auxiliary index, the total number of eigenvalues, and the number of bits for state preparation and rotations. It then creates an instance of the `DoubleFactorizationBlockEncoding` class with these parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnum_spin_orb = 10\nnum_aux = 50\nnum_eig = num_aux * (num_spin_orb // 2)\nnum_bits_state_prep = 12\nnum_bits_rot = 7\ndf_block_encoding = DoubleFactorizationBlockEncoding(\n    num_spin_orb=num_spin_orb,\n    num_aux=num_aux,\n    num_eig=num_eig,\n    num_bits_state_prep=num_bits_state_prep,\n    num_bits_rot_aa_outer=1,\n    num_bits_rot_aa_inner=7,\n    num_bits_rot=num_bits_rot,\n)\n```\n\n----------------------------------------\n\nTITLE: Importing CModSub class\nDESCRIPTION: Imports the `CModSub` class from the `qualtran.bloqs.mod_arithmetic` module. `CModSub` performs controlled modular subtraction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import CModSub\n```\n\n----------------------------------------\n\nTITLE: Instantiate PairPotential\nDESCRIPTION: This snippet calculates the polynomial coefficients, builds the QROM data, and instantiates the `PairPotential` class with specific parameters. It defines the bitsize (7), polynomial bitsize (15), calculates the polynomial coefficients using `get_inverse_square_root_poly_coeffs`, builds the QROM data using `build_qrom_data_for_poly_fit`, and then creates the `PairPotential` object.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nbitsize = 7\npoly_bitsize = 15\npoly_coeffs = get_inverse_square_root_poly_coeffs()\nqrom_data = build_qrom_data_for_poly_fit(2 * bitsize + 2, poly_bitsize, poly_coeffs)\nqrom_data = tuple(tuple(int(k) for k in d) for d in qrom_data)\npair_potential = PairPotential(bitsize=bitsize, qrom_data=qrom_data, poly_bitsize=poly_bitsize)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of Nested Control\nDESCRIPTION: Displays the call graph for the `nested_ctrl_bloq` bloq.  This showcases the structure of the composite bloq after nesting the controls.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nshow_call_graph(nested_ctrl_bloq)\n```\n\n----------------------------------------\n\nTITLE: KaiserWindowState Instance Example\nDESCRIPTION: This creates an instance of the `KaiserWindowState` class with a `bitsize` of 5 and an `alpha` parameter of 2.  This object can then be used within a larger quantum algorithm, such as Quantum Phase Estimation (QPE).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nkaiser_window_state_small = KaiserWindowState(5, 2)\n```\n\n----------------------------------------\n\nTITLE: Bloq without AutoPartition\nDESCRIPTION: Defines a `Bloq` called `NotWrapped` that explicitly splits and joins qubits. It demonstrates the need for `AutoPartition` by showcasing a bloq signature that doesn't directly match up with other bloqs, leading to complex diagrams.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import cached_property\n\nfrom qualtran.bloqs.rotations.hamming_weight_phasing import HammingWeightPhasing\nfrom qualtran.drawing import draw_musical_score\nfrom qualtran.drawing.musical_score import get_musical_score_data\n\n\n@attrs.frozen\nclass ManyBit(Bloq):\n    @cached_property\n    def signature(self) -> Signature:\n        return Signature((Register('xs', QBit(), shape=(20,)),))\n\n\n@attrs.frozen\nclass NotWrapped(Bloq):\n    bitsize: int = 10\n\n    @cached_property\n    def signature(self) -> Signature:\n        return Signature((Register('x', QBit(), shape=(self.bitsize,)), Register('y', QAny(20))))\n\n    def build_composite_bloq(\n        self, bb: BloqBuilder, x: 'SoquetT', y: 'SoquetT'\n    ) -> Dict[str, 'SoquetT']:\n        for i in range(5):\n            two_bit = bb.join(x[i * 2 : i * 2 + 2], QUInt(2))\n            two_bit = bb.add(HammingWeightPhasing(2, 0.11), x=two_bit)\n            x[i * 2 : i * 2 + 2] = bb.split(two_bit)\n        many_bit = bb.split(y)\n        many_bit = bb.add(ManyBit(), xs=many_bit)\n        return {'x': x, 'y': bb.join(many_bit)}\n\n\nbloq = NotWrapped()\ndraw_musical_score(get_musical_score_data(bloq.decompose_bloq()))\n```\n\n----------------------------------------\n\nTITLE: Drawing LinearDepthHalfLessThanEqual bloq\nDESCRIPTION: This code visualizes the `LinearDepthHalfLessThanEqual` bloq using `show_bloqs` from `qualtran.drawing`. This provides a visual representation of the quantum comparator circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lineardepthhalflessthanequal_small],\n           ['`lineardepthhalflessthanequal_small`'])\n```\n\n----------------------------------------\n\nTITLE: GF2PolyAddK Symbolic Instance\nDESCRIPTION: This snippet creates an instance of `GF2PolyAddK` with symbolic dimensions using `sympy`.  The polynomial degree and field extension degree are defined as symbolic variables `n` and `m`.  The constant polynomial is initialized as a zero polynomial.  This allows for creating a `GF2PolyAddK` object that works with symbolic dimensions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add_k.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\nfrom galois import Poly\n\nfrom qualtran import QGF, QGFPoly\n\nn, m = sympy.symbols('n, m', positive=True, integers=True)\nqgf_poly = QGFPoly(n, QGF(2, m))\ngf2_poly_add_k_symbolic = GF2PolyAddK(qgf_poly, Poly([0, 0, 0, 0]))\n```\n\n----------------------------------------\n\nTITLE: Import Subtract gate from Qualtran\nDESCRIPTION: Imports the `Subtract` gate from the `qualtran.bloqs.arithmetic` module. This gate performs the subtraction operation on two quantum registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Subtract\n```\n\n----------------------------------------\n\nTITLE: QROM Import Statement - Python\nDESCRIPTION: This snippet imports the `QROM` class from the `qualtran.bloqs.data_loading.qrom` module. This allows you to instantiate and use the `QROM` bloq within your quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.data_loading.qrom import QROM\n```\n\n----------------------------------------\n\nTITLE: Plotting Toffoli counts for PrepareSecondQuantization with QROM\nDESCRIPTION: This code plots the Toffoli gate count of the `PrepareSecondQuantization` bloq as a function of the number of spin orbitals. It iterates over a range of spin orbital values and computes the Toffoli count for each value, then plots the results on a log-log scale. QROAM block size is fixed to 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nbasis_vals = np.linspace(10, 100, 10, dtype=int)\ntoff_counts = [toffoli_count(PrepareSecondQuantization(int(n), qroam_block_size=1)) for n in basis_vals]\nplot_linear_log_log(ax, basis_vals, np.array(toff_counts))\nax.set_xlabel(\"$N$\")\nax.set_ylabel(\"Toffoli count\")\n```\n\n----------------------------------------\n\nTITLE: Uncomputing a State using the Adjoint\nDESCRIPTION: This code demonstrates uncomputing a previously prepared state using the adjoint of the `StatePreparationViaRotations` bloq. The `uncompute` parameter is set to `True` when initializing the bloq. The circuit first prepares the state, then un-prepares it using the adjoint. Ideally, the circuit brings the state back to |0>.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nqsp_adj = StatePreparationViaRotations(\n    phase_bitsize=phase_bitsize, state_coefficients=tuple(state_coefs), uncompute=True\n)\n\nbb = BloqBuilder()\nstate = bb.allocate(state_bitsize)\nphase_gradient = bb.add(PhaseGradientState(phase_bitsize))\nstate, phase_gradient = bb.add(\n    qsp, target_state=state, phase_gradient=phase_gradient\n)\nstate, phase_gradient = bb.add(\n    qsp_adj, target_state=state, phase_gradient=phase_gradient\n)\nbb.add(PhaseGradientState(bitsize=phase_bitsize).adjoint(), phase_grad=phase_gradient)\ncircuit = bb.finalize(state=state)\n\nshow_bloq(circuit)\ncoefficients = circuit.tensor_contract()\n```\n\n----------------------------------------\n\nTITLE: Example `ECAddR` instantiation\nDESCRIPTION: Demonstrates how to instantiate the `ECAddR` bloq. The first example uses symbolic parameters defined by `sympy`. The second example instantiates `ECAddR` with concrete values: $n=5$, $mod=17$, and $curve_a=0$, and the elliptic curve point $P = (15, 13)$. Two instances are created: `ec_add_r` (symbolic) and `ec_add_r_small` (concrete).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nn, p, Rx, Ry = sympy.symbols('n p R_x R_y')\nec_add_r = ECAddR(n=n, R=ECPoint(Rx, Ry, mod=p))\n```\n\nLANGUAGE: python\nCODE:\n```\nn = 5  # fits our mod = 17\nP = ECPoint(15, 13, mod=17, curve_a=0)\nec_add_r_small = ECAddR(n=n, R=P)\n```\n\n----------------------------------------\n\nTITLE: Generating Call Graph for ModDbl\nDESCRIPTION: This snippet generates and displays the call graph and resource counts sigma for the `moddbl_small` Bloq, using the `call_graph` method and the `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmoddbl_small_g, moddbl_small_sigma = moddbl_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(moddbl_small_g)\nshow_counts_sigma(moddbl_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Importing LinearDepthHalfLessThan from qualtran\nDESCRIPTION: This snippet imports the `LinearDepthHalfLessThan` class from the `qualtran.bloqs.arithmetic` module.  This class is used for comparing two quantum integers to determine if a < b.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import LinearDepthHalfLessThan\n```\n\n----------------------------------------\n\nTITLE: AutoPartition Bloq Definition\nDESCRIPTION: Describes the `AutoPartition` bloq, which automatically adds and undoes `Partition` operations to match the signature of a sub-bloq.  It enables using a bloq in a context expecting an alternative signature.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import Partition\n```\n\n----------------------------------------\n\nTITLE: Creating Block Encoding Bloq for First Quantization\nDESCRIPTION: This snippet creates a block encoding bloq for the first quantized Hamiltonian. It initializes `PrepareFirstQuantization` and `SelectFirstQuantization` bloqs, then combines them using `LCUBlockEncoding` with `BlackBoxSelect` and `BlackBoxPrepare`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.select_and_prepare import (\n    SelectFirstQuantization,\n    PrepareFirstQuantization,\n)\nfrom qualtran.bloqs.state_preparation.black_box_prepare import BlackBoxPrepare\nfrom qualtran.bloqs.multiplexers.black_box_select import BlackBoxSelect\n\n# keep the electron count small to make the diagrams nicer\nrs = 3.0\neta = 3.5  # rough value for simple solids.\n# The number of bits for representing the basis (in each spatial dimension)\n# => The number of planewaves in each dimension, N_x = 2^num_bits_p - 1, and the\n# total number of planewaves is N = N_x N_y N_z\nnum_bits_p = 6\nvol = volume_from_rs_eta(rs, eta)\n# Assume hydrogen here so zeta = 1\nalpha = approximate_alpha_first_quantization(vol, eta, num_bits_p)\nprep_fq = PrepareFirstQuantization(num_bits_p, eta, eta, eta, sum_of_l1_coeffs=alpha)\nsel_fq = SelectFirstQuantization(num_bits_p, eta, eta, eta)\nblock_encoding_bloq = LCUBlockEncoding(\n    select=BlackBoxSelect(sel_fq), prepare=BlackBoxPrepare(prep_fq)\n)\n```\n\n----------------------------------------\n\nTITLE: Setting the base value for modular exponentiation in Python\nDESCRIPTION: This snippet sets the base `g` for modular exponentiation. The choice of `g` doesn't matter much for the algorithm's demonstration but impacts the period found.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ng = 8\ng\n```\n\n----------------------------------------\n\nTITLE: Show PrepareIdentity Graphically\nDESCRIPTION: Visualizes the `prepare_identity` bloq using the `show_bloqs` function. This helps in understanding the structure and connections of the identity state preparation operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prepare_identity],\n           ['`prepare_identity`'])\n```\n\n----------------------------------------\n\nTITLE: Importing LinearDepthHalfLessThanEqual from qualtran\nDESCRIPTION: This snippet imports the `LinearDepthHalfLessThanEqual` class from the `qualtran.bloqs.arithmetic` module. It provides functionality to compare two integers to determine if a <= b.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import LinearDepthHalfLessThanEqual\n```\n\n----------------------------------------\n\nTITLE: CtrlSpecAnd with Bit Controls\nDESCRIPTION: This example shows how to instantiate `CtrlSpecAnd` with bit controls. A `CtrlSpec` is defined using `QBit` as the data type and a list of binary control values `[0, 1, 0, 1]`. This specifies that the control should be active when the bits match this pattern.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import CtrlSpec, QBit\n\nctrl_on_bits = CtrlSpecAnd(CtrlSpec(qdtypes=QBit(), cvs=[0, 1, 0, 1]))\n```\n\n----------------------------------------\n\nTITLE: CtrlSpecAnd with Multiple Values\nDESCRIPTION: This example demonstrates the instantiation of `CtrlSpecAnd` with multiple control values, using both `QUInt` and `QInt` data types. The control values are specified as lists within the `cvs` parameter, corresponding to each data type.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import CtrlSpec, QInt, QUInt\n\nctrl_on_multiple_values = CtrlSpecAnd(\n    CtrlSpec(qdtypes=(QUInt(4), QInt(4)), cvs=([0b0101, 0b1100], [2, -2]))\n)\n```\n\n----------------------------------------\n\nTITLE: Instantiate SubtractFrom gate with small size\nDESCRIPTION: Creates an instance of the `SubtractFrom` gate with a fixed size of 4 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nsub_from_small = SubtractFrom(QInt(bitsize=4))\n```\n\n----------------------------------------\n\nTITLE: Import PlusEqualProduct Bloq\nDESCRIPTION: Imports the `PlusEqualProduct` class from the `qualtran.bloqs.arithmetic` module. This bloq performs the operation result += a * b.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import PlusEqualProduct\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules for And and MultiAnd\nDESCRIPTION: This code snippet imports the required modules and classes from the `qualtran` library, including `Bloq`, `CompositeBloq`, `BloqBuilder`, `Signature`, `Register`, and quantum bit/integer classes.  It also imports `numpy`, `sympy`, and `cirq` for numerical computation, symbolic manipulation, and quantum circuit operations, respectively. The `typing` module is used for type hints.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Example Instance of SU2RotationGate\nDESCRIPTION: This snippet creates an instance of the SU2RotationGate with specific rotation angles: theta = pi/4, phi = pi/2, and lambda = pi/2. This demonstrates how to instantiate the gate with custom parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/su2_rotation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsu2_rotation_gate = SU2RotationGate(np.pi / 4, np.pi / 2, np.pi / 2)\n```\n\n----------------------------------------\n\nTITLE: Creating a GreaterThanConstant instance\nDESCRIPTION: This creates an instance of the `GreaterThanConstant` bloq with `bitsize=4` and `val=13`, specifying that the integer to be compared is represented by 4 bits and the constant value is 13.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngt_k = GreaterThanConstant(bitsize=4, val=13)\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for PotentialEnergy\nDESCRIPTION: This snippet generates and displays the call graph for the `PotentialEnergy` bloq, up to a depth of 1. It uses `ignore_split_join` as a generalizer and visualizes the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\npotential_energy_g, potential_energy_sigma = potential_energy.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(potential_energy_g)\nshow_counts_sigma(potential_energy_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying the call graph\nDESCRIPTION: This code generates the call graph and resource counts for the `qft_phase_gradient_small` bloq using the `call_graph` method. It then displays the call graph and sigma counts using `show_call_graph` and `show_counts_sigma`, providing insights into the bloq's internal structure and resource requirements.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_phase_gradient.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nqft_phase_gradient_small_g, qft_phase_gradient_small_sigma = qft_phase_gradient_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(qft_phase_gradient_small_g)\nshow_counts_sigma(qft_phase_gradient_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: KaiserWindowState Symbolic Instance Example\nDESCRIPTION: This creates an instance of the `KaiserWindowState` class with symbolic values for `bitsize` and `alpha` using the `sympy` library.  Symbolic instances are useful for abstract analysis and transformations before specifying concrete values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nkaiser_window_state_symbolic = KaiserWindowState(*sympy.symbols('n, alpha'))\n```\n\n----------------------------------------\n\nTITLE: XPowGate Graphical Signature\nDESCRIPTION: Generates and displays a graphical representation of the `XPowGate` bloq. This visualization aids in understanding the gate's structure, inputs, and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([x_pow],\n           ['`x_pow`'])\n```\n\n----------------------------------------\n\nTITLE: Concrete GuidingState Example\nDESCRIPTION: This snippet demonstrates how to create a `GuidingState` instance with concrete parameters. It defines a `KXorInstance` with specific values for `n`, `k`, and the constraints. It then creates a `GuidingState` object with \\( \\ell = 4 \\).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.optimization.k_xor_sat import Constraint, KXorInstance\n\ninst = KXorInstance(\n    n=4,\n    k=2,\n    constraints=(\n        Constraint(S=(0, 1), b=1),\n        Constraint(S=(2, 3), b=-1),\n        Constraint(S=(1, 2), b=1),\n    ),\n)\nguiding_state = GuidingState(inst, ell=4)\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Qualtran and Related Libraries\nDESCRIPTION: This code imports necessary modules from the `qualtran` library for defining quantum circuits and data structures, along with standard Python libraries such as `typing`, `numpy`, `sympy`, and `cirq` for numerical and symbolic computations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_text_book.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Example SelectTHC Instance\nDESCRIPTION: Creates an instance of the `SelectTHC` class with specified parameters such as `num_mu`, `num_spin_orb`, `num_bits_theta`, and `keep_bitsize`. This shows how to initialize and configure the `SelectTHC` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nnum_mu = 8\nnum_mu = 10\nnum_spin_orb = 2 * 4\nthc_sel = SelectTHC(\n    num_mu=num_mu, num_spin_orb=num_spin_orb, num_bits_theta=12, keep_bitsize=10\n)\n```\n\n----------------------------------------\n\nTITLE: Display graphical signatures of OutOfPlaceAdder instances\nDESCRIPTION: Uses `show_bloqs` to display the graphical representation of the instantiated `OutOfPlaceAdder` gates (`add_oop_symb`, `add_oop_small`, `add_oop_large`). This visualization helps to understand the register structure and data flow of the out-of-place quantum addition operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([add_oop_symb, add_oop_small, add_oop_large],\n           ['`add_oop_symb`', '`add_oop_small`', '`add_oop_large`'])\n```\n\n----------------------------------------\n\nTITLE: Comparator with Symbolic Bitsize\nDESCRIPTION: Creates a Comparator instance with a symbolic bitsize `n`, allowing for generic specifications. The SymPy library is used to define the symbolic variable.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\ncomparator_symb = Comparator(n)\n```\n\n----------------------------------------\n\nTITLE: Show SquareRealNumber Bloq\nDESCRIPTION: Displays the `SquareRealNumber` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([square_real_number],\n           ['`square_real_number`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiating QFTTextBook with a Symbolic Bitsize\nDESCRIPTION: Creates an instance of the `QFTTextBook` class with a symbolic `bitsize` represented by the `sympy` symbol `n`. This allows for defining a QFT with a variable number of qubits that can be later specified.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_text_book.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.symbols('n')\nsymbolic_qft = QFTTextBook(bitsize=n)\n```\n\n----------------------------------------\n\nTITLE: Plotting Toffoli Count Distribution for Varying Eta\nDESCRIPTION: This snippet generates pie charts visualizing the Toffoli count distribution for SELECT, PREPARE, and PREPARE$^{\\dagger}$ operations for different values of eta (number of electrons).  It iterates through eta values, creates the corresponding bloqs, calculates toffoli counts, and displays them as pie charts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots(nrows=1, ncols=5)\nfor ieta, eta in enumerate([10, 20, 40, 60, 80]):\n    vol = volume_from_rs_eta(rs, eta)\n    alpha = approximate_alpha_first_quantization(vol, eta, num_bits_p)\n    prep_fq = PrepareFirstQuantization(num_bits_p, eta, eta, eta, sum_of_l1_coeffs=alpha)\n    sel_fq = SelectFirstQuantization(num_bits_p, eta, eta, eta)\n    block_encoding_bloq = LCUBlockEncoding(select=BlackBoxSelect(sel_fq), prepare=BlackBoxPrepare(prep_fq))\n    toffoli_counts = [get_toffoli_counts(b) for b in [sel_fq, prep_fq, prep_fq.adjoint()]]\n    ax[ieta].set_title(rf'$\\eta = {eta}$')\n    ax[ieta].pie(toffoli_counts, autopct='%1.1f%%')\nax[-1].legend(labels=['SELECT', 'PREPARE', r'PREPARE^{\\dagger}$'], loc='best', bbox_to_anchor=(2, 1))\nfig.set_size_inches(10, 6)\n```\n\n----------------------------------------\n\nTITLE: Import PrepareOracle from qualtran\nDESCRIPTION: This snippet imports the `PrepareOracle` class from the `qualtran.bloqs.state_preparation.prepare_base` module. `PrepareOracle` is the abstract base class defining the interface for PREPARE oracles in Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.state_preparation.prepare_base import PrepareOracle\n```\n\n----------------------------------------\n\nTITLE: Building CompositeBloq with BloqBuilder in Python\nDESCRIPTION: Demonstrates how to use the BloqBuilder to construct a CompositeBloq. It allocates a quantum variable, applies a Hadamard gate, frees the variable, and finalizes the building process. The allocate, add, and free methods of BloqBuilder are used to manipulate quantum variables.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/Readme.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> bb = BloqBuilder()\n>>> q = bb.allocate(1)       # allocate a quantum variable.\n>>> q, = bb.add(H, qubit=q)  # wire it into a new `H` op, get new quantum variable back.\n>>> bb.free(q)               # discard our quantum variable, get nothing back.\n>>> cbloq = bb.finalize()    # finish building, turn into a `CompositeBloq`\n```\n\n----------------------------------------\n\nTITLE: Plotting T Complexity of And Gate in Qualtran\nDESCRIPTION: This snippet generates a plot showing the relationship between the number of qubits and the T complexity of the And gate. It calls the `get_t_count_plot_data_for_and` function to retrieve the data, then uses matplotlib to create and display the plot.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/cirq_interop/t_complexity.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nn_controls, t_count = get_t_count_plot_data_for_and()\nplt.plot(n_controls, t_count, 'o-', label='T')\nplt.ylabel('count')\nplt.xlabel('number of qubits')\nplt.title('And gate')\nplt.legend()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signature of ArcSin\nDESCRIPTION: Generates and displays the graphical signature of the `ArcSin` bloq using `show_bloqs` from `qualtran.drawing`. This visualization provides a high-level overview of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/trigonometric/trigonometric.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([arcsin],\n           ['`arcsin`'])\n```\n\n----------------------------------------\n\nTITLE: Import PrepareZetaState in Python\nDESCRIPTION: Imports the `PrepareZetaState` class from the `qualtran.bloqs.chemistry.pbc.first_quantization.prepare_zeta` module. This class is used to prepare a superposition over atomic species weighted by their nuclear charges (zeta).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.prepare_zeta import PrepareZetaState\n```\n\n----------------------------------------\n\nTITLE: Show ZeroState Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `ZeroState` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([zero_state],\n           ['`zero_state`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph of ControlledViaAnd\nDESCRIPTION: Generates and displays the call graph for `controlled_via_and_ints` using `controlled_via_and_ints.call_graph` with a maximum depth of 1 and a generalizer that ignores split/join operations.  The call graph and counts sigma are displayed using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncontrolled_via_and_ints_g, controlled_via_and_ints_sigma = controlled_via_and_ints.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(controlled_via_and_ints_g)\nshow_counts_sigma(controlled_via_and_ints_sigma)\n```\n\n----------------------------------------\n\nTITLE: Visualize Call Graph in Qualtran using Python\nDESCRIPTION: This snippet generates and visualizes the call graph of the `qroam_clean_multi_data` function using `qualtran.resource_counting`. It uses the `ignore_split_join` generalizer to simplify the graph and displays both the graph and the counts sigma. Dependencies include `qualtran.resource_counting.generalizers`, `qroam_clean_multi_data`, `show_call_graph`, and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nqroam_clean_multi_data_g, qroam_clean_multi_data_sigma = qroam_clean_multi_data.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(qroam_clean_multi_data_g)\nshow_counts_sigma(qroam_clean_multi_data_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of LinearDepthHalfLessThan in Qualtran\nDESCRIPTION: This snippet generates and displays the call graph for `LinearDepthHalfLessThan` using `call_graph` and `show_call_graph`.  This call graph is used to determine the resource costs associated with the quantum comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlineardepthhalflessthan_small_g, lineardepthhalflessthan_small_sigma = lineardepthhalflessthan_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lineardepthhalflessthan_small_g)\nshow_counts_sigma(lineardepthhalflessthan_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: QPE Imports for Comparison\nDESCRIPTION: This imports modules needed to construct Quantum Phase Estimation circuits. It imports cirq for circuit simulations. It imports BloqBuilder and CompositeBloq from qualtran, and various window functions including KaiserWindowState, RectangularWindowState, and LPResourceState.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport numpy as np\nfrom qualtran import BloqBuilder, CompositeBloq\nfrom qualtran.bloqs.basic_gates import ZPowGate, OneState, OneEffect\nfrom qualtran.bloqs.phase_estimation import TextbookQPE, RectangularWindowState, LPResourceState, KaiserWindowState\n```\n\n----------------------------------------\n\nTITLE: Instantiating QubitizationQPE for Ising Model\nDESCRIPTION: This snippet demonstrates how to instantiate the `QubitizationQPE` class for the 1D Ising model. It retrieves the walk operator using `get_walk_operator_for_1d_ising_model` and then creates an instance of `QubitizationQPE` using this walk operator and a `RectangularWindowState` with a specified size.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.ising.walk_operator import get_walk_operator_for_1d_ising_model\nfrom qualtran.bloqs.phase_estimation import RectangularWindowState\n\nwalk, _ = get_walk_operator_for_1d_ising_model(4, 0.1)\nqubitization_qpe_ising = QubitizationQPE(walk, RectangularWindowState(4))\n```\n\n----------------------------------------\n\nTITLE: Bloq with AutoPartition\nDESCRIPTION: Defines a `Bloq` called `Wrapped` that utilizes `AutoPartition` to wrap the `HammingWeightPhasing` and `ManyBit` bloqs. This demonstrates how to encapsulate partition/unpartition pairs behind a decomposition level, resulting in cleaner diagrams.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n@attrs.frozen\nclass Wrapped(Bloq):\n    bitsize: int = 10\n\n    @cached_property\n    def signature(self) -> Signature:\n        return Signature((Register('x', QBit(), shape=(self.bitsize,)), Register('y', QAny(20))))\n\n    def build_composite_bloq(\n        self, bb: BloqBuilder, x: 'SoquetT', y: 'SoquetT'\n    ) -> Dict[str, 'SoquetT']:\n        for i in range(5):\n            hwp = HammingWeightPhasing(2, i * 0.11)\n            x[i * 2 : i * 2 + 2] = bb.add(\n                AutoPartition(hwp, [(Register('reg_1', QBit(), shape=(2,)), ('x',))]),\n                reg_1=x[i * 2 : i * 2 + 2],\n            )\n        many = ManyBit()\n        b = AutoPartition(many, [(Register('y', QAny(20)), ('xs',))])\n        y = bb.add(b, y=y)\n        return {'x': x, 'y': y}\n\n\nbloq = Wrapped()\ndraw_musical_score(get_musical_score_data(bloq.decompose_bloq()))\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signatures of ModAddK instances in Python\nDESCRIPTION: Uses `show_bloqs` to display the graphical signatures for the symbolic instance `mod_add_k`, the small constant instance `mod_add_k_small`, and the large constant instance `mod_add_k_large` of the ModAddK class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([mod_add_k, mod_add_k_small, mod_add_k_large],\n           ['`mod_add_k`', '`mod_add_k_small`', '`mod_add_k_large`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate Controlled PrepareUniformSuperposition\nDESCRIPTION: This snippet creates a controlled version of the `PrepareUniformSuperposition` gate. The `cvs=[1]` parameter specifies that the gate is controlled by a single control qubit, which must be in the |1> state for the gate to be applied.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/prepare_uniform_superposition.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nc_prep_uniform = PrepareUniformSuperposition(n=5, cvs=[1])\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports\nDESCRIPTION: Imports necessary modules from Qualtran and other libraries for defining and using bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Xor example instantiation\nDESCRIPTION: Demonstrates the instantiation of the `Xor` class with a `QAny` data type of size 4.  This creates an XOR gate that operates on a register of 4 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nxor = Xor(QAny(4))\n```\n\n----------------------------------------\n\nTITLE: Instantiate KaliskiModInverse with symbolic values\nDESCRIPTION: This code instantiates the `KaliskiModInverse` class with symbolic bit size `n` and modulus `p`. This allows for symbolic manipulation and analysis of the modular multiplicative inverse computation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_division.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\nkaliskimodinverse_symbolic = KaliskiModInverse(n, p)\n```\n\n----------------------------------------\n\nTITLE: SplitJoin Bloq Composition\nDESCRIPTION: Defines a `SplitJoin` bloq that combines `Split` and `Join` operations to create an identity operation on a quantum register. This demonstrates how to compose bloqs using the `BloqBuilder`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport attrs\n\n@attrs.frozen\nclass SplitJoin(Bloq):\n    n: int\n\n    @property\n    def signature(self) -> Signature:\n        return Signature([Register('x', QAny(self.n))])\n\n    def build_composite_bloq(\n        self, bb: 'BloqBuilder', *, x: 'Soquet'\n    ) -> Dict[str, 'Soquet']:\n        xs = bb.split(x)\n        x = bb.join(xs)\n        return {'x': x}\n\nsplit_join = SplitJoin(n=4).decompose_bloq()\nshow_bloq(split_join)\n```\n\n----------------------------------------\n\nTITLE: Importing ChebyshevPolynomial class\nDESCRIPTION: This snippet imports the `ChebyshevPolynomial` class from the `qualtran.bloqs.block_encoding` module. This class is used for block encoding Chebyshev polynomials of a Hermitian matrix.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import ChebyshevPolynomial\n```\n\n----------------------------------------\n\nTITLE: TwoBitCSwap instantiation\nDESCRIPTION: Instantiates a `TwoBitCSwap` object from the `qualtran.bloqs.basic_gates` module, representing a controlled two-qubit swap gate (Fredkin gate).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import TwoBitCSwap\n```\n\nLANGUAGE: python\nCODE:\n```\ncswap_bit = TwoBitCSwap()\n```\n\n----------------------------------------\n\nTITLE: Visualizing GQSP Instances\nDESCRIPTION: Visualizes the created GQSP instances (`gqsp`, `gqsp_with_negative_power`, and `gqsp_with_large_negative_power`) using `show_bloqs` from Qualtran's drawing module. The titles are specified for each bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qsp/generalized_qsp.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gqsp, gqsp_with_negative_power, gqsp_with_large_negative_power],\n           ['`gqsp`', '`gqsp_with_negative_power`', '`gqsp_with_large_negative_power`'])\n```\n\n----------------------------------------\n\nTITLE: Importing LinearDepthHalfGreaterThan from qualtran\nDESCRIPTION: This snippet imports the `LinearDepthHalfGreaterThan` class from the `qualtran.bloqs.arithmetic` module, enabling its usage for comparing quantum integers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import LinearDepthHalfGreaterThan\n```\n\n----------------------------------------\n\nTITLE: Create OneEffect Instance\nDESCRIPTION: Creates an instance of the `OneEffect` bloq, representing the <1| quantum effect. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\none_effect = OneEffect()\n```\n\n----------------------------------------\n\nTITLE: TensorProduct Instance with Hadamard and TGate\nDESCRIPTION: Create an instance of `TensorProduct` using `TGate` and `Hadamard` gates wrapped in `Unitary` block encodings. This shows how to combine different unitary gates into a single tensor product block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/tensor_product.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard, TGate\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\ntensor_product_block_encoding = TensorProduct((Unitary(TGate()), Unitary(Hadamard())))\n```\n\n----------------------------------------\n\nTITLE: Phase Estimation Circuit with Qualtran\nDESCRIPTION: This function constructs the Heisenberg-limited phase estimation circuit for a given qubitization walk operator. It takes the walk operator and the number of bits of accuracy (m) as input and returns a Cirq OP_TREE representing the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef phase_estimation(walk: QubitizationWalkOperator, m: int) -> cirq.OP_TREE:\n    \"\"\"Heisenberg limited phase estimation circuit for learning eigenphase of `walk`.\n    \n    The method yields an OPTREE to construct Heisenberg limited phase estimation circuit \n    for learning eigenphases of the `walk` operator with `m` bits of accuracy. The \n    circuit is implemented as given in Fig.2 of Ref-1.\n    \n    Args:\n        walk: Qubitization walk operator.\n        m: Number of bits of accuracy for phase estimation. \n        \n    Ref:\n        1) [Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity]\n            (https://arxiv.org/abs/1805.03662)\n            Fig. 2\n    \"\"\"\n    reflect = walk.reflect\n    walk_regs = get_named_qubits(walk.signature)\n    reflect_regs = {reg.name: walk_regs[reg.name] for reg in reflect.signature}\n    \n    reflect_controlled = reflect.controlled(control_values=[0])\n    walk_controlled = walk.controlled(control_values=[1])\n\n    m_qubits = [cirq.q(f'm_{i}') for i in range(m)]\n    state_prep = cirq.StatePreparationChannel(get_resource_state(m), name='chi_m')\n\n    yield state_prep.on(*m_qubits)\n    yield walk_controlled.on_registers(**walk_regs, ctrl=m_qubits[0])\n    for i in range(1, m):\n        yield reflect_controlled.on_registers(control=m_qubits[i], **reflect_regs)\n        walk = walk ** 2\n        yield walk.on_registers(**walk_regs)\n        yield reflect_controlled.on_registers(control=m_qubits[i], **reflect_regs)\n        \n    yield cirq.qft(*m_qubits, inverse=True)\n```\n\n----------------------------------------\n\nTITLE: PrepareHubbard Import\nDESCRIPTION: Imports the `PrepareHubbard` class from the `qualtran.bloqs.chemistry.hubbard_model.qubitization` module. This class implements the PREPARE operation optimized for the 2D Hubbard model.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import PrepareHubbard\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Dependencies (Python)\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library and other standard Python libraries like NumPy and SymPy. These modules are used for defining quantum circuits, gates, and registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Drawing LinearDepthHalfGreaterThan bloq\nDESCRIPTION: This code visualizes the `LinearDepthHalfGreaterThan` bloq using `show_bloqs` from `qualtran.drawing`. It provides a graphical representation of the quantum circuit for the comparison operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lineardepthhalfgreaterthan_small],\n           ['`lineardepthhalfgreaterthan_small`'])\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying a call graph for GreaterThan\nDESCRIPTION: This generates a call graph for the `greater_than` bloq, which visualizes the dependencies and sub-components within the quantum circuit. It also computes and displays the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngreater_than_g, greater_than_sigma = greater_than.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(greater_than_g)\nshow_counts_sigma(greater_than_sigma)\n```\n\n----------------------------------------\n\nTITLE: Partition Bloq Definition\nDESCRIPTION: Defines the `Partition` bloq, which partitions a generic index into multiple registers. The `partition` parameter indicates whether to partition or un-partition the register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import Partition\n```\n\n----------------------------------------\n\nTITLE: Classifying T-Count by Bloq Type\nDESCRIPTION: This snippet classifies the T-count of the `prep_thc` bloq by bloq type using `classify_t_count_by_bloq_type` from `qualtran.resource_counting`. The resulting `costs` dictionary contains the T-count for each bloq type.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.classify_bloqs import classify_t_count_by_bloq_type\ncosts = classify_t_count_by_bloq_type(prep_thc)\n```\n\n----------------------------------------\n\nTITLE: Instantiating SelectSparse\nDESCRIPTION: This snippet creates an instance of the `SelectSparse` class, which represents the SELECT oracle for the sparse Hamiltonian. The constructor takes the number of spin orbitals as an argument.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnum_spin_orb = 4\nsel_sparse = SelectSparse(num_spin_orb)\n```\n\n----------------------------------------\n\nTITLE: Printing Debug Text of a Composite Bloq - Python\nDESCRIPTION: Demonstrates how to obtain a textual description of a `CompositeBloq`'s internal structure using the `debug_text()` method. This outputs a topologically sorted list of sub-bloqs and their connections, aiding in debugging complex circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(cbloq.debug_text())\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for ChebyshevPolynomial (Even)\nDESCRIPTION: This snippet generates and displays the call graph and sigma counts for the `chebyshev_poly_even` instance. It uses `ignore_split_join` as a generalizer to simplify the graph. The call graph shows the dependencies between different bloqs within the Chebyshev polynomial block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nchebyshev_poly_even_g, chebyshev_poly_even_sigma = chebyshev_poly_even.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(chebyshev_poly_even_g)\nshow_counts_sigma(chebyshev_poly_even_sigma)\n```\n\n----------------------------------------\n\nTITLE: Dense State Preparation from Probabilities\nDESCRIPTION: This code demonstrates the usage of `StatePreparationAliasSampling` to prepare a state with specified probabilities. It defines a list of coefficients `coeffs` and uses the `from_probabilities` method to create a `StatePreparationAliasSampling` instance with a precision parameter dependent on `mu`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = [1.0, 1, 3, 2]\nmu = 3\nstate_prep_alias = StatePreparationAliasSampling.from_probabilities(\n    coeffs, precision=2**-mu / len(coeffs) * sum(coeffs)\n)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of PrepareSparse\nDESCRIPTION: This snippet shows how to generate and display the graphical signature of the `prep_sparse` bloq using `show_bloqs` from `qualtran.drawing`. This visualization provides a high-level overview of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prep_sparse],\n           ['`prep_sparse`'])\n```\n\n----------------------------------------\n\nTITLE: ModNeg Example Instance\nDESCRIPTION: Creates an instance of the `ModNeg` class with a `QUInt` register of size `n=32` and a symbolic modulus `p`. This demonstrates how to instantiate the modular negation gate with specific parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn = 32\nprime = sympy.Symbol('p')\nmod_neg = ModNeg(QUInt(n), mod=prime)\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientState Definition\nDESCRIPTION: Defines the `PhaseGradientState` Bloq, which prepares a phase gradient state | on a new register of bitsize b_{grad}. It allocates/deallocates registers and delegates to the PhaseGradientUnitary bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import PhaseGradientState\n```\n\n----------------------------------------\n\nTITLE: Import ControlledViaAnd\nDESCRIPTION: Imports the `ControlledViaAnd` class from the `qualtran.bloqs.mcmt` module, which is used to reduce a generic controlled bloq to a singly-controlled bloq using an And ladder.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mcmt import ControlledViaAnd\n```\n\n----------------------------------------\n\nTITLE: Generating a random quantum state\nDESCRIPTION: This function generates a random quantum state with a specified number of qubits (`state_bitsizes`).  It creates a numpy array of complex numbers and normalizes the state vector. This function is used as input to `StatePreparationViaRotations` to set target coefficient values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef gen_random_state (state_bitsizes: int):\n    state = np.array([random.uniform(-1,1) + random.uniform(-1,1)*1j for _ in range(2**state_bitsizes)])\n    return state/np.linalg.norm(state)\n```\n\n----------------------------------------\n\nTITLE: ScaleIntByReal Example Instance\nDESCRIPTION: Creates an instance of the `ScaleIntByReal` class with specified bitsizes for the real number and integer input registers. This bloq implements $|r\\rangle|i\\rangle|0\\rangle \\rightarrow |r\\rangle|i\\rangle|r \\times i\\rangle$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nscale_int_by_real = ScaleIntByReal(r_bitsize=12, i_bitsize=4)\n```\n\n----------------------------------------\n\nTITLE: Import Statements and Setup\nDESCRIPTION: This snippet imports necessary modules from `qualtran`, `typing`, `numpy`, `sympy`, and `cirq`. These modules provide functionalities for building quantum circuits, defining data types, and performing mathematical operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add_k.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Symbolic QROM Instance - Python\nDESCRIPTION: This snippet creates a symbolic `QROM` instance using `sympy` symbols for the selection sizes (N, M) and target bitsizes (b1, b2).  It also takes the number of controls, `c`, as a symbolic parameter.  The `build_from_bitsize` method is used to construct the `QROM` from these symbolic parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nN, M, b1, b2, c = sympy.symbols('N M b1 b2 c')\nqrom_symb = QROM.build_from_bitsize((N, M), (b1, b2), num_controls=c)\n```\n\n----------------------------------------\n\nTITLE: Instantiate PrepareFirstQuantization\nDESCRIPTION: This snippet instantiates the `PrepareFirstQuantization` bloq with specific parameters, such as the number of bits to represent the momentum register, the number of electrons, the number of atoms, and the sum of nuclear charges. This creates an object ready to be used in a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 6\neta = 10\nnum_atoms = 10\nlambda_zeta = 10\nprep_first_quant = PrepareFirstQuantization(num_bits_p, eta, num_atoms, lambda_zeta)\n```\n\n----------------------------------------\n\nTITLE: Creating an EqualsAConstant instance\nDESCRIPTION: This creates an instance of the `EqualsAConstant` bloq with `bitsize=4` and `val=13`, specifying that the integer to be compared is represented by 4 bits and the constant value is 13.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\neq_k = EqualsAConstant(bitsize=4, val=13)\n```\n\n----------------------------------------\n\nTITLE: Example Instance of SingleFactorizationBlockEncoding\nDESCRIPTION: This code snippet demonstrates how to create an instance of the `SingleFactorizationBlockEncoding` bloq. It sets the parameters `num_spin_orb`, `num_aux`, `num_bits_state_prep`, `num_bits_rot_aa_outer` and `num_bits_rot_aa_inner`, and initializes the `sf_block_encoding` object with these values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnum_spin_orb = 10\nnum_aux = 50\nnum_bits_state_prep = 12\nsf_block_encoding = SingleFactorizationBlockEncoding(\n    num_spin_orb=num_spin_orb,\n    num_aux=num_aux,\n    num_bits_state_prep=num_bits_state_prep,\n    num_bits_rot_aa_outer=7,\n    num_bits_rot_aa_inner=7,\n)\n```\n\n----------------------------------------\n\nTITLE: LinearCombination instantiation example\nDESCRIPTION: This code demonstrates how to instantiate the `LinearCombination` class with a set of unitary operators (Hadamard, T, X, and Z gates) and corresponding coefficients. The `lambd_bits` parameter specifies the number of bits used to represent the coefficients.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/linear_combination.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard, TGate, XGate, ZGate\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\nlinear_combination_block_encoding = LinearCombination(\n    (Unitary(TGate()), Unitary(Hadamard()), Unitary(XGate()), Unitary(ZGate())),\n    lambd=(0.25, -0.25, 0.25, -0.25),\n    lambd_bits=1,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Instances of ECAdd with Symbolic Parameters in Qualtran\nDESCRIPTION: This code demonstrates how to create instances of the `ECAdd` class with symbolic parameters. `sympy.symbols` are used to define symbolic variables `n` and `p` representing the bitsize and modulus, respectively.  This allows creating a generic ECAdd bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ec_add.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\nec_add = ECAdd(n, mod=p)\n```\n\n----------------------------------------\n\nTITLE: Create Large CAdd Instance\nDESCRIPTION: This snippet creates an instance of the `CAdd` class with `QUInt` registers of size 1000, representing a large controlled addition gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_addition.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncadd_large = CAdd(QUInt(1000), QUInt(1000))\n```\n\n----------------------------------------\n\nTITLE: Signature Creation from Registers\nDESCRIPTION: This snippet creates a `Signature` object from a list of `Register` objects.  The `Signature` object represents the input/output signature of a quantum gate, specifying the names and sizes of the registers that the gate operates on. The created signature `r` is printed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nr = Signature([control_reg, target_reg])\nr\n```\n\n----------------------------------------\n\nTITLE: Instantiate KaliskiModInverse with concrete values\nDESCRIPTION: This code instantiates the `KaliskiModInverse` class with a bit size of 32 and a modulus of 10^9 + 7. This creates an object that can compute the modular multiplicative inverse for 32-bit numbers modulo 10^9 + 7.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_division.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nkaliskimodinverse_example = KaliskiModInverse(32, 10**9 + 7)\n```\n\n----------------------------------------\n\nTITLE: Generating T Count Plot Data for MultiAnd Gate in Qualtran\nDESCRIPTION: This function calculates and returns the number of T gates required for a MultiAnd gate with a varying number of qubits (from 3 to n_max inclusive). It iterates through the specified range, creates a MultiAnd gate for each number of qubits, and calculates its T complexity using the t_complexity protocol. The function returns two lists: the number of control qubits and the corresponding T counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/cirq_interop/t_complexity.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef get_t_count_plot_data_for_and(n_max: int = 10):\n    \"\"\"Returns the #T when the number of qubits is between 3 and n_max inclusive\"\"\"\n    n_controls = []\n    t_count = []\n    for n in range(3, n_max + 2):\n        n_controls.append(n)\n        gate = MultiAnd(cvs=(1, )*n)\n        c = t_complexity(gate)\n        t_count.append(c.t)\n    return n_controls, t_count\n```\n\n----------------------------------------\n\nTITLE: Displaying MontgomeryModMul Bloqs Graphically\nDESCRIPTION: This snippet uses the `show_bloqs` function to display the graphical representations of the `dirtyoutofplacemontgomerymodmul_small` and `dirtyoutofplacemontgomerymodmul_medium` Bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([dirtyoutofplacemontgomerymodmul_small, dirtyoutofplacemontgomerymodmul_medium],\n           ['`dirtyoutofplacemontgomerymodmul_small`', '`dirtyoutofplacemontgomerymodmul_medium`'])\n```\n\n----------------------------------------\n\nTITLE: Showing ParallelComparators Bloq\nDESCRIPTION: Displays the graphical signature of `parallel_compare` using the `show_bloqs` function, visualizing the structure of the parallel comparator network.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([parallel_compare],\n           ['`parallel_compare`'])\n```\n\n----------------------------------------\n\nTITLE: Adjoint of CompositeBloq in Qualtran\nDESCRIPTION: This snippet takes the previously constructed `bell_cbloq` and visualizes its adjoint using the `adjoint()` method and `show_bloq`. This demonstrates how to obtain the adjoint of a composite bloq, reversing the order of operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Take the adjoint of a composite bloq\nshow_bloq(bell_cbloq.adjoint())\n```\n\n----------------------------------------\n\nTITLE: Generate call graph of AddK gate\nDESCRIPTION: Generates and displays the call graph of the `AddK` gate using `call_graph` and `show_call_graph`. This illustrates the internal structure of the gate and its dependencies for resource analysis. `ignore_split_join` is used as a generalizer for resource counting.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nadd_k_g, add_k_sigma = add_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(add_k_g)\nshow_counts_sigma(add_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: SymmetricDifference Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma of the `symm_diff` instance. `ignore_split_join` is used as a generalizer to simplify the call graph. `show_call_graph` and `show_counts_sigma` are used to visualize the call graph and resource counts, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsymm_diff_g, symm_diff_sigma = symm_diff.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(symm_diff_g)\nshow_counts_sigma(symm_diff_sigma)\n```\n\n----------------------------------------\n\nTITLE: Creating DirtyOutOfPlaceMontgomeryModMul Instance\nDESCRIPTION: This snippet creates a `DirtyOutOfPlaceMontgomeryModMul` instance with specified bit size, window size and modulus.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndirtyoutofplacemontgomerymodmul_small = DirtyOutOfPlaceMontgomeryModMul(6, 2, 7)\n```\n\n----------------------------------------\n\nTITLE: Creating an instance of ZPowConstViaPhaseGradient with symbolic angle\nDESCRIPTION: Creates an instance of `ZPowConstViaPhaseGradient` with a symbolic angle (`t`) and a specific error tolerance (1e-11).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/zpow_via_phase_gradient.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nt = sympy.symbols(\"t\")\nzpow_const_via_phase_grad_symb_angle = ZPowConstViaPhaseGradient.from_precision(t, eps=1e-11)\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasingViaPhaseGradient Example Instance\nDESCRIPTION: Creates an instance of `HammingWeightPhasingViaPhaseGradient` with a bitsize of 4 and an exponent of pi/2. This shows how to instantiate the phase gradient version of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nhamming_weight_phasing_via_phase_gradient = HammingWeightPhasingViaPhaseGradient(4, np.pi / 2.0)\n# Applying this unitary to |1111> should be the identity, and |0101> will flip the sign.\n```\n\n----------------------------------------\n\nTITLE: Signature Creation with build\nDESCRIPTION: This snippet demonstrates using the `Signature.build` factory method as a concise way to define a signature from keyword arguments, where each keyword argument represents a register name and its size. The snippet asserts that this method of creating a signature is equivalent to creating it from a list of `Register` objects.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nr == Signature.build(\n    control=2,\n    target=3,\n)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for T Complexity Analysis\nDESCRIPTION: This snippet imports necessary libraries for T complexity analysis, including matplotlib for plotting, numpy for numerical operations, And and MultiAnd gates from qualtran.bloqs.mcmt, get_named_qubits from qualtran._infra.gate_with_registers, and t_complexity from qualtran.cirq_interop.t_complexity_protocol.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/cirq_interop/t_complexity.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom qualtran.bloqs.mcmt import And, MultiAnd\nfrom qualtran._infra.gate_with_registers import get_named_qubits\nfrom qualtran.cirq_interop.t_complexity_protocol import t_complexity\n```\n\n----------------------------------------\n\nTITLE: Flattening All Subbloqs in Qualtran\nDESCRIPTION: This snippet flattens all subbloqs of a `CompositeBloq` using the `flatten_once()` method. It takes the flattened `CompositeBloq` named `flat_three_p` as input and removes one layer of nesting for all subbloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# Actually do a flattening operation on all the subbloqs\nshow_bloq(\n    flat_three_p.flatten_once()\n)\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports for Quantum Phase Estimation\nDESCRIPTION: This snippet imports necessary modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `BloqBuilder`, `Signature`, `Register`, `QBit`, `QInt`, `QUInt`, `QAny` along with drawing utilities and standard Python libraries like `typing`, `numpy`, `sympy`, and `cirq`. These libraries are essential for defining and simulating quantum circuits and bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Multi-Dimensional QROM Instance - Python\nDESCRIPTION: This snippet demonstrates a `QROM` instance that loads from two 2D arrays, `data1` and `data2`, of shape (3, 3). Both are reshaped from `np.arange(9)`, with `data2` offset by 1. The selection registers are (2, 2) bits wide. Both target registers require 8 bits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndata1 = np.arange(9).reshape((3, 3))\ndata2 = (np.arange(9) + 1).reshape((3, 3))\nqrom_multi_dim = QROM([data1, data2], selection_bitsizes=(2, 2), target_bitsizes=(8, 8))\n```\n\n----------------------------------------\n\nTITLE: Symbolic Permutation with Cycles\nDESCRIPTION: Defines a symbolic `Permutation` instance with cycles where each cycle length is also symbolic.  `N` represents the overall size and `d` is a symbolic indexed base representing the lengths of each of the `n_cycles` (4 in this instance).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.symbolics import Shaped\n\nN = sympy.symbols(\"N\", positive=True, integer=True)\nn_cycles = 4\nd = sympy.IndexedBase('d', shape=(n_cycles,))\npermutation_symb_with_cycles = Permutation(N, tuple(Shaped((d[i],)) for i in range(n_cycles)))\n```\n\n----------------------------------------\n\nTITLE: IsingXUnitary Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `ising_x` bloq using the `show_bloqs` function.  This visualization helps understand the bloq's structure and its connections.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ising_x],\n           ['`ising_x`'])\n```\n\n----------------------------------------\n\nTITLE: BitonicMerge Instance Example\nDESCRIPTION: Creates an instance of `BitonicMerge` to merge two sorted sequences, each of length 4, where each integer has a bitsize of 7.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nbitonic_merge = BitonicMerge(4, 7)\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Typing\nDESCRIPTION: Imports necessary modules from Qualtran, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register, as well as various quantum data types (QBit, QInt, QUInt, QAny). Also imports standard Python libraries such as typing, numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_add_or_subtract.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Importing BiQubitsMixer Bloq\nDESCRIPTION: This line imports the `BiQubitsMixer` class from the `qualtran.bloqs.arithmetic` module. The `BiQubitsMixer` bloq mixes the values in a way that preserves the result of comparison and uses ancilla qubits to reduce T-count.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import BiQubitsMixer\n```\n\n----------------------------------------\n\nTITLE: Product Block Encoding with Properties\nDESCRIPTION: This example creates a `Product` block encoding, similar to the previous example, but also defines specific properties for the `Unitary` block encodings, such as `alpha`, `ancilla_bitsize`, `resource_bitsize`, and `epsilon`. These parameters are used to define the accuracy and resource requirements of the block encodings.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/product.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard, TGate\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\nu1 = Unitary(TGate(), alpha=0.5, ancilla_bitsize=2, resource_bitsize=1, epsilon=0.01)\nu2 = Unitary(Hadamard(), alpha=0.5, ancilla_bitsize=1, resource_bitsize=1, epsilon=0.1)\nproduct_block_encoding_properties = Product((u1, u2))\n```\n\n----------------------------------------\n\nTITLE: Hashing Bloq Attributes to Filenames in Qualtran\nDESCRIPTION: This snippet defines functions to extract attributes from Qualtran bloqs and generate a unique filename based on the hashed representation of these attributes. It handles `CompositeBloq`, `ProgrammableRotationGateArray`, `Adjoint`, and `Controlled` bloqs.  It uses `attrs.asdict` to get the attributes and `hashlib.md5` for generating the filename.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/ui-export.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport attrs\nimport hashlib\nimport json\n\nfrom qualtran import Adjoint, CompositeBloq, Controlled\nfrom qualtran.bloqs.rotations.programmable_rotation_gate_array import ProgrammableRotationGateArray\n\ndef bloq_attrs(bloq):\n  if isinstance(bloq, CompositeBloq):\n    return {}\n  if isinstance(bloq, ProgrammableRotationGateArray):\n    return {}\n  if isinstance(bloq, (Adjoint, Controlled)):\n    return bloq_attrs(bloq.subbloq)\n\n  return attrs.asdict(bloq)\n\ndef bloq_filename(bloq):\n  attrs_dict = bloq_attrs(bloq)\n  attrs_keys = list(attrs_dict.keys())\n  attrs_keys.sort()\n\n  prefix = ''\n  if isinstance(bloq, Adjoint):\n    prefix = 'Adjoint_'\n  if isinstance(bloq, Controlled):\n    prefix = 'Controlled_'\n\n  attrs_list = [\n    [key, attrs_dict[key]]\n    for key in attrs_keys\n  ] if attrs_keys else []\n  unhashed = json.dumps(attrs_list, cls=BloqEncoder)\n\n  return prefix + hashlib.md5(unhashed.encode(), usedforsecurity=False).hexdigest() + '.json'\n```\n\n----------------------------------------\n\nTITLE: Classical Data Loading Example - Python\nDESCRIPTION: This snippet demonstrates a classical analogue to a QROM operation using nested for loops in Python and numpy arrays. It initializes two numpy arrays, `data`, and uses nested loops to select and assign portions of those arrays to output variables. This mimics the behavior of a QROM where selection registers are used to address and load classical data.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# N, M, P, Q, R, S, T are pre-initialized integer parameters.\noutput = [np.zeros((P, Q)), np.zeros((R, S, T))]\n# Load two different classical datasets; each of different shape.\ndata = [np.random.rand(N, M, P, Q), np.random.rand(N, M, R, S, T)]\nfor i in range(N): # For loop over two selection indices i and j.\n    for j in range(M):\n       # Load two multidimensional classical datasets data[0] and data[1] s.t.\n       # |i, j|0  -> |i, j|data[0][i, j, :]|data[1][i, j, :]\n       output[0] = data[0][i, j, :]\n       output[1] = data[1][i, j, :]\n```\n\n----------------------------------------\n\nTITLE: GF2MulViaKaratsuba Bloq Definition (Incomplete)\nDESCRIPTION: Defines the `GF2MulViaKaratsuba` bloq, which multiplies two GF($2^n$) numbers (or binary polynomials) modulo $m(x)$ using Karatsuba multiplication. It applies the transformation $\\ket{f}\\ket{g} \\rightarrow \\ket{f} \\ket{g} \\ket{f*g \\mod m(x)}$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_23\n\n\n\n----------------------------------------\n\nTITLE: Instantiate SubtractFrom gate with symbolic size\nDESCRIPTION: Creates an instance of the `SubtractFrom` gate with a symbolic size 'n'.  This allows for representing the gate with a variable number of qubits. Requires `sympy`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nsub_from_symb = SubtractFrom(QInt(bitsize=n))\n```\n\n----------------------------------------\n\nTITLE: Showing BitonicMerge Bloq\nDESCRIPTION: Displays the graphical signature of `bitonic_merge` using the `show_bloqs` function to visualize the structure of the bitonic merge network.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([bitonic_merge],\n           ['`bitonic_merge`'])\n```\n\n----------------------------------------\n\nTITLE: Hadamard Gate as SU2RotationGate\nDESCRIPTION: This snippet defines a Hadamard gate by instantiating the SU2RotationGate with specific parameters (theta = pi/4, phi = 0, lambda = 0). This illustrates how other common quantum gates can be represented as SU2 rotations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/su2_rotation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nhadamard = SU2RotationGate(np.pi / 4, 0, 0)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Representation of ZGate\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical representation of the instantiated `zgate` object. This visualization helps in understanding the gate's action within a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([zgate],\n           ['`zgate`'])\n```\n\n----------------------------------------\n\nTITLE: Creating a LessThanEqual instance\nDESCRIPTION: This creates an instance of the `LessThanEqual` bloq with `x_bitsize=4` and `y_bitsize=8`, specifying the bit sizes of the two integers to be compared.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nleq = LessThanEqual(x_bitsize=4, y_bitsize=8)\n```\n\n----------------------------------------\n\nTITLE: Example `FindECCPrivateKey` instantiation\nDESCRIPTION: Demonstrates how to instantiate the `FindECCPrivateKey` bloq with symbolic parameters for the curve order ($p$) and point coordinates ($P_x, P_y, Q_x, Q_y$). It creates symbolic variables using `sympy` and uses them to define the base point $P$ and the public key $Q$ as `ECPoint` objects. Finally, it instantiates `FindECCPrivateKey` with these points.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\nPx, Py, Qx, Qy = sympy.symbols('P_x P_y Q_x Q_y')\nP = ECPoint(Px, Py, mod=p)\nQ = ECPoint(Qx, Qy, mod=p)\necc = FindECCPrivateKey(n=n, base_point=P, public_key=Q)\n```\n\n----------------------------------------\n\nTITLE: Importing CModMulK from qualtran.bloqs\nDESCRIPTION: This snippet imports the `CModMulK` class from the `qualtran.bloqs.mod_arithmetic` module, which is used to create controlled modular multiplication-by-constant gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import CModMulK\n```\n\n----------------------------------------\n\nTITLE: CZPowGate Example\nDESCRIPTION: Creates an instance of the `CZPowGate` with a specified exponent. This example demonstrates how to instantiate the controlled `ZPowGate` with a specific rotation angle.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncz_pow = CZPowGate(exponent=0.123)\n```\n\n----------------------------------------\n\nTITLE: Show OneState Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `OneState` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\none_state_g, one_state_sigma = one_state.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(one_state_g)\nshow_counts_sigma(one_state_sigma)\n```\n\n----------------------------------------\n\nTITLE: CompositeBloq Adjoint Example in Qualtran\nDESCRIPTION: This example constructs a `bell_cbloq` (composite bloq) by applying a ladder of CNOT gates after preparing a PlusState. The code then visualizes the original composite bloq. It relies on numpy for array creation and Qualtran's BloqBuilder, PlusState, ZeroState, and CNOT from qualtran.bloqs.basic_gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nfrom qualtran import BloqBuilder\nfrom qualtran.bloqs.basic_gates import ZeroState, PlusState, CNOT\n\n# Construct a bell state by doing a ladder of CNOTs\nbb = BloqBuilder()\nq0 = bb.add(PlusState())\n\nsrc_q = q0  # current wire\nqvars = []  # track output wires\nfor _ in range(3):\n    next_q = bb.add(ZeroState())\n    src_q, next_q = bb.add(CNOT(), ctrl=src_q, target=next_q)\n    \n    qvars.append(src_q)\n    src_q = next_q\n    \nqvars.append(src_q)\nbell_cbloq = bb.finalize(qs=np.array(qvars))\nshow_bloq(bell_cbloq)\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signature of Bloq\nDESCRIPTION: Displays the graphical signature of the `programmable_rotation_gate_array` bloq. This uses the `show_bloqs` function from `qualtran.drawing` to visualize the bloq with a given label.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/programmable_rotation_gate_array.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([programmable_rotation_gate_array],\n           ['`programmable_rotation_gate_array`'])\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph\nDESCRIPTION: This snippet generates a call graph for `select_block` using `call_graph` method with a maximum depth of 1 and ignoring split/join operations. It then displays the call graph and the counts sigma using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nselect_block_g, select_block_sigma = select_block.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(select_block_g)\nshow_counts_sigma(select_block_sigma)\n```\n\n----------------------------------------\n\nTITLE: Join Example Instance\nDESCRIPTION: Creates an instance of the `Join` bloq, configured to join an array of `QBit`s into a register of type `QUInt(4)`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\njoin = Join(dtype=QUInt(4))\n```\n\n----------------------------------------\n\nTITLE: GF2Multiplication Instance with Symbolic Bitsize\nDESCRIPTION: Creates an instance of the `GF2Multiplication` bloq with a symbolic bitsize `m` and `plus_equal_prod` set to False. This example uses `sympy` to define `m` as a symbolic variable.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nm = sympy.Symbol('m')\ngf2_multiplication_symbolic = GF2Multiplication(m, plus_equal_prod=False)\n```\n\n----------------------------------------\n\nTITLE: Import Libraries for GF(2^m) Inverse\nDESCRIPTION: Imports necessary libraries from Qualtran and other packages such as numpy, sympy, and cirq for implementing and testing GF(2^m) inverse functionality. This includes Bloq, CompositeBloq, Signature, Register from qualtran and typing, numpy, sympy and cirq\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_inverse.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: Imports necessary modules from the Qualtran library for defining quantum circuits, including data structures for bloqs, registers, qubits, and integers. It also imports typing, NumPy, SymPy, and Cirq for additional functionalities such as data handling, symbolic calculations, and circuit construction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Instantiate SelectUVFirstQuantization in Python\nDESCRIPTION: Creates an instance of the `SelectUVFirstQuantization` class with specified parameters `num_bits_p`, `eta`, and `num_bits_nuc_pos`. This instance will be used to select the U and V operators for the first-quantized chemistry Hamiltonian, using the given parameters for momentum, electrons, and nuclear positions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 5\neta = 10\nnum_bits_nuc_pos = 16\n\nselect_uv = SelectUVFirstQuantization(\n    num_bits_p=num_bits_p, eta=eta, num_atoms=eta, num_bits_nuc_pos=num_bits_nuc_pos\n)\n```\n\n----------------------------------------\n\nTITLE: Estimate qubit count of a bloq\nDESCRIPTION: Estimates the qubit count of the `bloq` using `get_cost_value` and the `QubitCount` cost key. This provides an estimate based on the bloq's structure and internal allocations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/resource_counting/qubit_counts.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nget_cost_value(bloq, QubitCount())\n```\n\n----------------------------------------\n\nTITLE: Instantiate SelectFirstQuantization\nDESCRIPTION: This snippet instantiates the `SelectFirstQuantization` bloq with specified parameters, including the number of bits for the momentum register, number of electrons, number of atoms, and lambda zeta. This creates a `SelectFirstQuantization` object that can be used within a larger quantum algorithm.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 6\neta = 10\nnum_atoms = 10\nlambda_zeta = 10\nsel_first_quant = SelectFirstQuantization(num_bits_p, eta, num_atoms, lambda_zeta)\n```\n\n----------------------------------------\n\nTITLE: Sign Extend Example Instance\nDESCRIPTION: Creates an instance of `SignExtend` to extend an 8-bit integer (`QInt(8)`) to a 16-bit integer (`QInt(16)`). This demonstrates how to use the `SignExtend` class with integer data types.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QInt\n\nsign_extend = SignExtend(QInt(8), QInt(16))\n```\n\n----------------------------------------\n\nTITLE: Show the call graph\nDESCRIPTION: Generates and displays the call graph and counts sigma of the `trott_unitary` bloq up to a depth of 1. The call graph visualizes the dependencies and sub-bloqs called by the main bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/trotterized_unitary.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ntrott_unitary_g, trott_unitary_sigma = trott_unitary.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(trott_unitary_g)\nshow_counts_sigma(trott_unitary_sigma)\n```\n\n----------------------------------------\n\nTITLE: Approximate QFT Graphical Signature\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical representations (signatures) of the previously created `approximate_qft_small` and `approximate_qft_from_epsilon` instances. This visualization helps understand the input/output structure of the bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/approximate_qft.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([approximate_qft_small, approximate_qft_from_epsilon],\n           ['`approximate_qft_small`', '`approximate_qft_from_epsilon`'])\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and related libraries\nDESCRIPTION: Imports necessary modules from the `qualtran` library for defining and manipulating quantum blocks, as well as standard Python libraries for typing, numerical computation, and symbolic mathematics.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf_poly_split_and_join.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Creating CModMulK Instance with Concrete Values\nDESCRIPTION: This snippet creates an instance of the `CModMulK` class with concrete values for the constant multiplier `k` and the modulus `mod`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmodmul = CModMulK(QUInt(8), k=123, mod=13 * 17)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of MultiplexedCSwap\nDESCRIPTION: Displays the graphical signature of the MultiplexedCSwap instance.  This allows for visual inspection of the register connections.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([multiplexed_cswap],\n           ['`multiplexed_cswap`'])\n```\n\n----------------------------------------\n\nTITLE: Analyzing Toffoli count of PrepareSecondQuantization\nDESCRIPTION: This code defines a function `toffoli_count` that computes the Toffoli gate count of a given bloq. It uses `get_cost_value` to retrieve the QEC gates cost and then extracts the number of CCZ gates, which are equivalent to Toffoli gates. It also checks for the presence of raw T gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom qualtran import Bloq\nfrom qualtran.bloqs.chemistry.chem_tutorials import plot_linear_log_log\nfrom qualtran.resource_counting import get_cost_value, QECGatesCost\nfrom qualtran.resource_counting.generalizers import generalize_cswap_approx\n\ndef toffoli_count(bloq: Bloq) -> int:\n    # TODO: The rotations here should be in terms of Toffoli via phase gradient rotation.\n    cost = get_cost_value(bloq, QECGatesCost(), generalizer=generalize_cswap_approx).total_t_and_ccz_count(ts_per_rotation=0)\n    n_t = cost['n_t']\n    assert n_t == 0, \"Found raw T gates, should be only Toffolis\"\n    return cost['n_ccz']\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of GF2Multiplication Instances\nDESCRIPTION: Shows the graphical signatures of the `gf16_multiplication` and `gf2_multiplication_symbolic` bloq instances using `show_bloqs` from `qualtran.drawing`. This visualizes the input and output registers of the bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf16_multiplication, gf2_multiplication_symbolic],\n           ['`gf16_multiplication`', '`gf2_multiplication_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Documenting Registers with Docstrings in Qualtran Bloqs (Python)\nDESCRIPTION: This code snippet demonstrates how to document a Qualtran Bloq's registers using the 'Registers' section in the class docstring.  It documents the `ctrl` and `target` registers of the `And` class, specifying their purpose (control and output, respectively).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Autodoc.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass And(Bloq):\n    \"\"\"A two-bit 'and' operation.\n\n    Registers:\n        ctrl: A two-bit control register.\n        target [right]: The output bit.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Plotting Cost Breakdown by Bloq Type\nDESCRIPTION: This snippet generates a pie chart visualizing the cost breakdown by bloq type for `prep_thc`. It sorts the costs, creates labels with percentages, and displays the pie chart with a legend showing the contribution of each bloq type.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nvalues = np.array(list(costs.values()))\nix = np.argsort(values)[::-1]\nvalues = values[ix]\nhandles = np.arange(len(costs.values()))\nkeys = np.array(list(costs.keys()))[ix]\nnorm = sum(values)\nlabels = [f'{l}: {100*v/norm:3.4f}' for l, v in zip(keys, values)]\nplt.pie(values)\nax.legend(handles, labels=labels, prop={'size': 10},\n          bbox_to_anchor=(1.0, 0.60))\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Representation of YGate (Python)\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display a graphical representation of the `y_gate`. This visual representation helps in understanding the gate's function within a circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([y_gate],\n           ['`y_gate`'])\n```\n\n----------------------------------------\n\nTITLE: MultiplyTwoReals Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `MultiplyTwoReals` instance, using the `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmultiply_two_reals_g, multiply_two_reals_sigma = multiply_two_reals.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(multiply_two_reals_g)\nshow_counts_sigma(multiply_two_reals_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiate TextbookQPE with precision and delta\nDESCRIPTION: Illustrates creating a TextbookQPE instance configured for a specific precision (n) and success probability delta, using symbolic variables and ZPowGate as the unitary.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.basic_gates import ZPowGate\nfrom qualtran.bloqs.phase_estimation import RectangularWindowState, TextbookQPE\n\ntheta = sympy.Symbol('theta')\nprecision, delta = sympy.symbols('n, delta')\ntextbook_qpe_from_precision_and_delta = TextbookQPE(\n    ZPowGate(exponent=2 * theta),\n    RectangularWindowState.from_precision_and_delta(precision, delta),\n)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for Toffoli implementation\nDESCRIPTION: This snippet imports necessary modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `BloqBuilder`, `Signature`, `Register`, `QBit`, `QInt`, `QUInt`, `QAny` for defining quantum circuits and data structures. Also imports `show_bloq`, `show_call_graph`, `show_counts_sigma` for visualization. The snippet further imports standard python packages like `typing`, `numpy`, `sympy` and `cirq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/toffoli.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Instantiate StatePreparationViaRotations with Symbolic Values\nDESCRIPTION: Creates an instance of `StatePreparationViaRotations` with symbolic values for the state coefficients length and phase bitsize. This allows for generic representation and manipulation of the state preparation gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.symbolics import HasLength\n\nn_state_coeff = sympy.Symbol(\"L\")\nphase_bitsize = sympy.Symbol(r\"\\text{phase_bitsize}\")\nstate_prep_via_rotation_symb = StatePreparationViaRotations(\n    state_coefficients=HasLength(n_state_coeff), phase_bitsize=phase_bitsize\n)\n```\n\n----------------------------------------\n\nTITLE: Symbolic GuidingState Example with c*k\nDESCRIPTION: This snippet creates a `GuidingState` instance with symbolic parameters. It defines symbolic variables for `n`, `m`, `c`, and `k` to represent the parameters of the kXOR instance and the Kikuchi parameter ell=c*k. Then a symbolic `KXorInstance` and `GuidingState` object are created.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.optimization.k_xor_sat import KXorInstance\n\nn, m, c = sympy.symbols(\"n m c\", positive=True, integer=True)\nk = sympy.symbols(\"k\", positive=True, integer=True, even=True)\ninst = KXorInstance.symbolic(n=n, m=m, k=k)\nguiding_state_symb_c = GuidingState(inst, ell=c * k)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of `ECPhaseEstimateR`\nDESCRIPTION: Generates and displays the graphical signature of the `ECPhaseEstimateR` bloq, including both the symbolic instance `ec_pe` and the smaller instance `ec_pe_small` using `show_bloqs`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ec_pe, ec_pe_small],\n           ['`ec_pe`', '`ec_pe_small`'])\n```\n\n----------------------------------------\n\nTITLE: T-Count Analysis for PrepareTHC\nDESCRIPTION: Analyzes the T-count of the `PrepareTHC` bloq and compares it with theoretical costs from a reference paper. This includes categorizing T-counts by bloq type and identifying discrepancies in comparator and QROM costs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nbinned_counts = classify_t_count_by_bloq_type(thc_prep.decompose_bloq())\ndata_size = thc_prep.num_mu * (thc_prep.num_mu + 1) // 2 + thc_prep.num_spin_orb // 2\n\nnum_bits_mu = thc_prep.num_mu.bit_length() \nqrom_bitsize = 2 * num_bits_mu + 2 + thc_prep.keep_bitsize\npaper_costs = {\n    'arithmetic': 4*(num_bits_mu ** 2 + num_bits_mu - 1) + 4*thc_prep.keep_bitsize,\n    'swaps': 4*(2 * num_bits_mu + (num_bits_mu + 1)), # Swaps from inequality and swap from from \n    'data_loading': 4 * (int(np.ceil(data_size/4) + qrom_bitsize * (4 - 1))), # Eq. 31 from THC paper, k = 4 in this specific case.\n}\nfor k, v in paper_costs.items():\n    print(f\"{k+':':20s} qualtran = {binned_counts[k]:5d} vs paper cost = {v:5d}.\")\n\nprint(f\"Total cost = {sum(v for v in binned_counts.values())}\")\nassert binned_counts['data_loading'] == 248\n```\n\n----------------------------------------\n\nTITLE: BitonicMerge Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph for `bitonic_merge` using `bitonic_merge.call_graph`. The `ignore_split_join` generalizer is used to simplify the graph. Displays the call graph and sigma counts using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nbitonic_merge_g, bitonic_merge_sigma = bitonic_merge.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(bitonic_merge_g)\nshow_counts_sigma(bitonic_merge_sigma)\n```\n\n----------------------------------------\n\nTITLE: HasDuplicates Concrete Instance\nDESCRIPTION: Creates a concrete instance of the `HasDuplicates` class with specific parameters. The length of the list is set to 4, and the data type (`dtype`) of each element is set to `QUInt(3)`, which represents an unsigned integer with 3 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nhas_duplicates = HasDuplicates(4, QUInt(3))\n```\n\n----------------------------------------\n\nTITLE: Drawing Musical Score for DoubleFactorizationBlockEncoding\nDESCRIPTION: This snippet draws the musical score for the `df_bloq` (DoubleFactorizationBlockEncoding). It decomposes the bloq, gets the musical score data, and visualizes it using `matplotlib`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nmsd = get_musical_score_data(df_bloq.decompose_bloq())\nfig, ax = draw_musical_score(msd)\nfig.set_size_inches(10, 10)\nplt.tick_params(left=False, right=False, labelleft=False, labelbottom=False, bottom=False)\n```\n\n----------------------------------------\n\nTITLE: Example Instance of SelectBlockEncoding with BlackBox\nDESCRIPTION: This snippet creates another example instance of `SelectBlockEncoding`, but this time using `BlackBoxSelect` and `BlackBoxPrepare` wrappers around `SelectHubbard` and `PrepareHubbard`. This demonstrates how to create a 'black box' version of the block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import PrepareHubbard, SelectHubbard\nfrom qualtran.bloqs.multiplexers.black_box_select import BlackBoxSelect\nfrom qualtran.bloqs.state_preparation.black_box_prepare import BlackBoxPrepare\n\n# 3x3 hubbard model U/t = 4\ndim = 3\nselect = SelectHubbard(x_dim=dim, y_dim=dim)\nU = 4\nt = 1\nprepare = PrepareHubbard(x_dim=dim, y_dim=dim, t=t, u=U)\nblack_box_select_block = SelectBlockEncoding(\n    select=BlackBoxSelect(select), prepare=BlackBoxPrepare(prepare)\n)\n```\n\n----------------------------------------\n\nTITLE: Assigning the period value in Python\nDESCRIPTION: This snippet assigns the value of the period, which was found in the previous loop. This value is used for calculating the factors.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nperiod = 8\n```\n\n----------------------------------------\n\nTITLE: Show Dense State Preparation Bloqs\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display graphical representations of the `state_prep_alias` and `state_prep_alias_symb` bloqs. The `show_bloqs` function takes a list of bloqs and a corresponding list of labels as input.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([state_prep_alias, state_prep_alias_symb],\n           ['`state_prep_alias`', '`state_prep_alias_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Create CModAdd instance with constant parameters in Python\nDESCRIPTION: Creates an instance of the `CModAdd` class with a specific `QUInt` data type of size 32 and a modulus of 10**9 + 7.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ncmodadd_example = CModAdd(QUInt(32), 10**9 + 7)\n```\n\n----------------------------------------\n\nTITLE: PrepareTHC Example Instance\nDESCRIPTION: Creates an instance of the `PrepareTHC` class using random test integrals generated by `build_random_test_integrals`. This example demonstrates how to prepare the THC Hamiltonian state using specific coefficients.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.thc.prepare_test import build_random_test_integrals\n\nnum_spat = 4\nnum_mu = 8\nt_l, eta, zeta = build_random_test_integrals(num_mu, num_spat, seed=7)\nthc_prep = PrepareTHC.from_hamiltonian_coeffs(\n    t_l, eta, zeta, num_bits_state_prep=8, log_block_size=2\n)\n```\n\n----------------------------------------\n\nTITLE: Classical simulation graph of MultiAnd gate\nDESCRIPTION: This code creates a classical simulation graph of the `MultiAnd` gate using the `ClassicalSimGraphDrawer`.  The gate is first decomposed using `decompose_bloq`, and then simulated with a specific input state (ctrl=[1,1,0,1]). The resulting graph is rendered as an SVG image, visualizing the classical computation performed by the decomposed gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import ClassicalSimGraphDrawer\n\nClassicalSimGraphDrawer(\n    MultiAnd((1,1,1,1)).decompose_bloq(), \n    vals=dict(ctrl=[1,1,0,1])\n).get_svg()\n```\n\n----------------------------------------\n\nTITLE: Displaying Graphical Signatures of QubitizationQPE instances\nDESCRIPTION: This snippet displays the graphical signatures of the instantiated `QubitizationQPE` objects for the Hubbard, Sparse Chemistry, THC, and Ising models, providing a visual representation of the circuit structure. It uses `show_bloqs` function to display the bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([qubitization_qpe_hubbard_model_small, qubitization_qpe_sparse_chem, qubitization_qpe_chem_thc, qubitization_qpe_ising],\n           ['`qubitization_qpe_hubbard_model_small`', '`qubitization_qpe_sparse_chem`', '`qubitization_qpe_chem_thc`', '`qubitization_qpe_ising`'])\n```\n\n----------------------------------------\n\nTITLE: SymmetricDifference Import\nDESCRIPTION: Imports the `SymmetricDifference` function from the `qualtran.bloqs.arithmetic.lists` module. This function computes the symmetric difference between two sorted sets.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.lists import SymmetricDifference\n```\n\n----------------------------------------\n\nTITLE: Example: Get Walk Operator for THC Hamiltonian\nDESCRIPTION: This snippet shows how to construct a walk operator for a Tensor Hyper-Contraction (THC) Hamiltonian using the `get_walk_operator_for_thc_ham` function. It uses parameters consistent with the openfermion.resource_estimates.thc module and demonstrates how to set up the necessary inputs for the walk operator construction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom openfermion.resource_estimates.utils import QI\n\nfrom qualtran.bloqs.chemistry.thc.prepare_test import build_random_test_integrals\nfrom qualtran.bloqs.chemistry.thc.walk_operator import get_walk_operator_for_thc_ham\n\n# Li et al parameters from openfermion.resource_estimates.thc.compute_cost_thc_test\nnum_spinorb = 152\nnum_bits_state_prep = 10\nnum_bits_rot = 20\nthc_dim = 450\nnum_spat = num_spinorb // 2\nt_l, eta, zeta = build_random_test_integrals(thc_dim, num_spinorb // 2, seed=7)\nqroam_blocking_factor = np.power(2, QI(thc_dim + num_spat)[0])\nthc_walk_op = get_walk_operator_for_thc_ham(\n    t_l,\n    eta,\n    zeta,\n    num_bits_state_prep=num_bits_state_prep,\n    num_bits_theta=num_bits_rot,\n    kr1=qroam_blocking_factor,\n    kr2=qroam_blocking_factor,\n)\n```\n\n----------------------------------------\n\nTITLE: Instantiate GFPolySplit with QGFPoly in Qualtran\nDESCRIPTION: Creates an instance of the `GFPolySplit` bloq using a `QGFPoly` instance. This demonstrates how to initialize the split operation with a specific polynomial defined over a Galois field, in this case, GF(2^3).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf_poly_split_and_join.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QGF, QGFPoly\n\ngf_poly_split = GFPolySplit(QGFPoly(4, QGF(2, 3)))\n```\n\n----------------------------------------\n\nTITLE: Approximate QFT Instance Creation (Small)\nDESCRIPTION: This snippet demonstrates creating an instance of the `ApproximateQFT` class with specific parameters.  It creates an approximate QFT acting on 6 qubits with a phase gradient register of 5 qubits.  This instance `approximate_qft_small` can then be used in quantum circuit constructions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/approximate_qft.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\napproximate_qft_small = ApproximateQFT(6, 5)\n```\n\n----------------------------------------\n\nTITLE: Instantiate GF2Addition with a Fixed Size\nDESCRIPTION: Instantiate the `GF2Addition` class with a fixed size of 4. This creates an object `gf16_addition` that performs addition over GF($2^4$).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_addition.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngf16_addition = GF2Addition(4)\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library and other standard libraries like typing, numpy, sympy, and cirq. These modules are essential for defining and manipulating quantum circuits within the Qualtran framework.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/approximate_qft.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Flattening with Predicate in Qualtran\nDESCRIPTION: This snippet flattens a `CompositeBloq` once based on a predicate. The lambda function `lambda binst: binst.i == 1` filters which subbloqs are flattened based on the `binst.i` property.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Flatten by binst properties\nshow_bloq(\n    flat_three_p.flatten_once(lambda binst: binst.i == 1)\n)\n```\n\n----------------------------------------\n\nTITLE: Musical Score of DoubleFactorizationBlockEncoding Decomposition\nDESCRIPTION: This code decomposes the `df_block_encoding` bloq and generates a musical score representation of the decomposed circuit. The `get_musical_score_data` function retrieves the data needed to create the score, and `draw_musical_score` renders the score as a figure. The figure size is then adjusted for better visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import get_musical_score_data, draw_musical_score\nmsd = get_musical_score_data(df_block_encoding.decompose_bloq())\nfig, ax = draw_musical_score(msd)\nfig.set_size_inches(14, 10)\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counting for `FindECCPrivateKey`\nDESCRIPTION: Generates and displays the call graph and resource counts for `FindECCPrivateKey`. The call graph shows the sub-bloqs called by `FindECCPrivateKey`, up to a maximum depth of 1. The `ignore_split_join` generalizer simplifies the call graph by ignoring split and join operations. Resource counts are represented by `ecc_sigma` and displayed using `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\necc_g, ecc_sigma = ecc.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ecc_g)\nshow_counts_sigma(ecc_sigma)\n```\n\n----------------------------------------\n\nTITLE: Defining CtrlSpec with QUInt for Controlled Bloq\nDESCRIPTION: This example showcases how to define a `CtrlSpec` with a `QUInt` type and a specific control value (`cvs`) to control a bloq. It creates a controlled version of an XGate that is active when the control register equals 6.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import CtrlSpec, QUInt, QBit\n\nctrl_spec = CtrlSpec(qdtypes=QUInt(4), cvs=0b0110)\nassert ctrl_spec.is_active(6)\ncx = x.controlled(ctrl_spec=ctrl_spec)\nshow_bloq(cx, type='musical_score')\n```\n\n----------------------------------------\n\nTITLE: Instantiate PrepareTFirstQuantization\nDESCRIPTION: This snippet creates an instance of the `PrepareTFirstQuantization` bloq, specifying the number of bits to represent the momentum and the number of electrons. The instance, `prepare_t`, will prepare the state for the kinetic energy part of the first-quantized Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 5\neta = 10\n\nprepare_t = PrepareTFirstQuantization(num_bits_p=num_bits_p, eta=eta)\n```\n\n----------------------------------------\n\nTITLE: GF2Inverse Instance with bitsize 4\nDESCRIPTION: Creates an instance of the `GF2Inverse` class with a `bitsize` of 4. This means the inverse will be computed for elements in GF(2^4).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_inverse.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngf16_inverse = GF2Inverse(4)\n```\n\n----------------------------------------\n\nTITLE: Creating ModDbl Instances\nDESCRIPTION: This snippet demonstrates how to create instances of the `ModDbl` class with different parameters. One instance uses a small modulus, while the other uses a larger prime number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprime = 10**9 + 7\nmoddbl_large = ModDbl(QUInt(32), prime)\n```\n\n----------------------------------------\n\nTITLE: Allocate Example Instance\nDESCRIPTION: Creates an instance of the `Allocate` bloq with a symbolic size `n`.  This showcases how to instantiate the `Allocate` bloq with a dynamically sized register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nalloc = Allocate(QUInt(n))\n```\n\n----------------------------------------\n\nTITLE: Displaying the Toffoli gate as a musical score\nDESCRIPTION: This snippet calls `show_bloq` to display the `toffoli` gate in a 'musical_score' format, which likely uses a different graphical convention.  This is for visualizing the structure of the gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/toffoli.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(toffoli, 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: TStateMaker Decomposition in Qualtran\nDESCRIPTION: This snippet defines a custom bloq called `TStateMaker`, which creates a T-state by applying a Hadamard gate followed by a T-gate. The decomposition of this bloq is then displayed using `show_bloq`. It uses `Hadamard` and `TGate` from `qualtran.bloqs.basic_gates` and requires `Bloq`, `Signature`, `SoquetT` from `qualtran` and standard typing imports.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import cached_property\nfrom typing import *\n\nfrom qualtran import BloqBuilder, Bloq, Signature, SoquetT\nfrom qualtran.bloqs.basic_gates import TGate, Hadamard\n\nclass TStateMaker(Bloq):\n    @cached_property\n    def signature(self) -> 'Signature':\n        return Signature.build(x=1)\n\n    def build_composite_bloq(self, bb: 'BloqBuilder', x: 'SoquetT') -> Dict[str, 'SoquetT']:\n        x = bb.add(Hadamard(), q=x)\n        x = bb.add(TGate(), q=x)\n        return {'x': x}\n    \nshow_bloq(TStateMaker().decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: CZPowGate Import\nDESCRIPTION: Imports the `CZPowGate` class from the `qualtran.bloqs.basic_gates` module. This gate represents a controlled power of the Pauli Z operator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CZPowGate\n```\n\n----------------------------------------\n\nTITLE: Import PhasingViaCostFunction\nDESCRIPTION: This snippet imports the `PhasingViaCostFunction` class from the `qualtran.bloqs.rotations` module. This is necessary for creating instances of the `PhasingViaCostFunction` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phasing_via_cost_function.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import PhasingViaCostFunction\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and Cirq Libraries\nDESCRIPTION: Import necessary libraries from Qualtran, including Bloq, CompositeBloq, BloqBuilder, Signature, Register, QBit, QInt, QUInt, QAny, along with typing, numpy, sympy and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/programmable_rotation_gate_array.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientState Example Instance\nDESCRIPTION: Creates an instance of the `PhaseGradientState` Bloq with a bitsize of 4, preparing a phase gradient state on 4 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QFxp\n\nphase_gradient_state = PhaseGradientState(4)\n```\n\n----------------------------------------\n\nTITLE: ModSub Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `ModSub` bloq, providing a visual representation of its input and output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([modsub_symb],\n           ['`modsub_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Generate and display the call graph of TwoBitFFFT\nDESCRIPTION: Generates and displays the call graph of the TwoBitFFFT gate using qualtran's call_graph and show_call_graph functions, ignoring split/join operations.  This visualizes the internal structure and dependencies of the gate, including resource counts using `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/two_bit_ffft.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ntwo_bit_ffft_g, two_bit_ffft_sigma = two_bit_ffft.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(two_bit_ffft_g)\nshow_counts_sigma(two_bit_ffft_sigma)\n```\n\n----------------------------------------\n\nTITLE: Analyze PrepareTFirstQuantization call graph\nDESCRIPTION: This snippet generates and visualizes the call graph and sigma counts for the `prepare_t` bloq, up to a maximum depth of 1, using `ignore_split_join` as a generalizer.  This shows the bloqs called by `prepare_t` and estimates the resource costs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprepare_t_g, prepare_t_sigma = prepare_t.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prepare_t_g)\nshow_counts_sigma(prepare_t_sigma)\n```\n\n----------------------------------------\n\nTITLE: Controlled Hadamard Gate Example (Python)\nDESCRIPTION: Instantiates the `CHadamard` gate by applying the `.controlled()` method to a `Hadamard` instance. It also includes an assertion to verify the type of the resulting controlled gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nchadamard = Hadamard().controlled()\nassert isinstance(chadamard, CHadamard)\n```\n\n----------------------------------------\n\nTITLE: IsingZZUnitary Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `ising_zz` bloq. This visualization uses the `show_bloqs` function to depict the structure and connectivity of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ising_zz],\n           ['`ising_zz`'])\n```\n\n----------------------------------------\n\nTITLE: Generating UI Navigation Data from Qualtran Notebook Specs\nDESCRIPTION: This snippet generates a JSON file (`ui_export/navigation.json`) that contains navigation data for a UI based on Qualtran notebook specifications.  It iterates through notebook sections, notebooks, and bloq specs to extract information like bloq names, example names, example docstrings, and filenames, organizing it into a structured dictionary for JSON serialization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/ui-export.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom pathlib import Path\n\nfrom qualtran_dev_tools.notebook_specs import NB_BY_SECTION\n\ndocs_by_section = {\n  section[0]: {\n    notebook_spec.title: list(\n      {\n        'name': bloq_spec.bloq_cls.__name__,\n        'examples': list(\n          {\n            'name': example.name,\n            'example_docstring': example.docstring,\n            'filename': bloq_filename(example.make())\n          }\n          for example in bloq_spec.examples\n        )\n      }\n      for bloq_spec in notebook_spec.bloq_specs\n    )\n    for notebook_spec in section[1]\n  }\n  for section in NB_BY_SECTION\n}\n\nPath('ui_export').mkdir(parents=True, exist_ok=True)\n\nwith open('ui_export/navigation.json', 'w') as f:\n  json.dump(docs_by_section, f, indent=2)\n```\n\n----------------------------------------\n\nTITLE: Initializing SelectSwapQROM with Symbolic Dimensions (2D, Dirty Ancilla)\nDESCRIPTION: This snippet shows how to initialize a `SelectSwapQROM` instance with 2D symbolic dimensions using `sympy`. It defines variables N, M, b1, b2, k1, k2, and c, then creates `qroam_symb_dirty_2d` using `build_from_bitsize`. This allows creating symbolically sized QROMs that can be used in cost analyses. `use_dirty_ancilla` defaults to True.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nN, M, b1, b2, k1, k2, c = sympy.symbols('N M b1 b2 k1 k2 c', positive=True, integers=True)\nlog_block_sizes = (k1, k2)\nqroam_symb_dirty_2d = SelectSwapQROM.build_from_bitsize(\n    (N, M), (b1, b2), log_block_sizes=log_block_sizes, num_controls=c\n)\n```\n\n----------------------------------------\n\nTITLE: Verifying Controlled State Preparation\nDESCRIPTION: This snippet verifies the controlled state preparation accuracy. It compares the obtained coefficients with the expected coefficients for the controlled state. It calculates the dot product of obtained coefficients with correct coefficients and prints accuracy and each coefficients in polar form.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\naccuracy = np.dot(coefficients, np.array(correct).conj())\n\nprint(f\"accuracy: {abs(accuracy)}\\n\")\n\nprint(\"Comparison (coefficients in polar form):\")\nfor i, (c, s) in enumerate(zip(coefficients, correct)):\n    print(f\"  |{f'{i:0{state_bitsize+1}b}'[0]},{f'{i:0{state_bitsize+1}b}'[1:]}> result: {round(abs(c),4)} {round(np.angle(c, deg=True),2)}  \"+\\\n          f\"exact: {round(abs(s),4)} {round(np.angle(s, deg=True),2)}\")\n```\n\n----------------------------------------\n\nTITLE: Controlled GlobalPhase Gate\nDESCRIPTION: Creates a controlled version of the `GlobalPhase` gate and prints its representation and tensor contraction.  A controlled global phase gate is equivalent to a `ZPowGate`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/global_phase.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncgp = global_phase.controlled()\nprint(repr(cgp))\nprint(cgp.tensor_contract())\n```\n\n----------------------------------------\n\nTITLE: Instantiate GF2PolyAdd with symbolic parameters\nDESCRIPTION: Creates an instance of `GF2PolyAdd` with symbolic parameters 'n' and 'm' representing the degree of the polynomial and the extension degree of the finite field, respectively.  This allows for generic representation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran import QGF, QGFPoly\n\nn, m = sympy.symbols('n, m', positive=True, integers=True)\nqgf_poly = QGFPoly(n, QGF(2, m))\ngf2_poly_add_symbolic = GF2PolyAdd(qgf_poly)\n```\n\n----------------------------------------\n\nTITLE: GF2AddK Example Instance\nDESCRIPTION: Creates an instance of `GF2AddK` with bitsize 4 and constant 1.  This performs addition by 1 in GF(2^4).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_add_k.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngf16_add_k = GF2AddK(4, 1)\n```\n\n----------------------------------------\n\nTITLE: ControlledAddOrSubtract Import\nDESCRIPTION: Imports the `ControlledAddOrSubtract` class from the `qualtran.bloqs.arithmetic.controlled_add_or_subtract` module. This class is the core component demonstrated in the code.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_add_or_subtract.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.controlled_add_or_subtract import ControlledAddOrSubtract\n```\n\n----------------------------------------\n\nTITLE: Show graphical representation of CSwap gates\nDESCRIPTION: Generates and displays graphical representations of the `CSwap` gates (controlled swap) with symbolic and fixed bitsizes using the `show_bloqs` function. The gates are labeled accordingly.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cswap, cswap_small, cswap_large],\n           ['`cswap`', '`cswap_small`', '`cswap_large`'])\n```\n\n----------------------------------------\n\nTITLE: Import ScaleIntByReal Bloq\nDESCRIPTION: Imports the `ScaleIntByReal` class from the `qualtran.bloqs.arithmetic` module.  This bloq scales an integer by a fixed-point representation of a real number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import ScaleIntByReal\n```\n\n----------------------------------------\n\nTITLE: ZPowGate Graphical Signature\nDESCRIPTION: Generates and displays a graphical representation of the `ZPowGate` bloq. This visualization helps understand the gate's structure and input/output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([z_pow],\n           ['`z_pow`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph of LinearDepthHalfGreaterThan in Qualtran\nDESCRIPTION: This snippet generates and displays the call graph for `LinearDepthHalfGreaterThan` using `call_graph` and `show_call_graph`. The `ignore_split_join` generalizer is used for resource counting to assess the complexity of the comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlineardepthhalfgreaterthan_small_g, lineardepthhalfgreaterthan_small_sigma = lineardepthhalfgreaterthan_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lineardepthhalfgreaterthan_small_g)\nshow_counts_sigma(lineardepthhalfgreaterthan_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show Cast in Compute Graph\nDESCRIPTION: Illustrates an example where `Cast` re-interprets the input `QFxp` register as a `QUInt` for an addition operation. The compute graph wires are annotated with their quantum data types.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.for_testing import TestCastToFrom\nshow_bloq(TestCastToFrom().decompose_bloq(), type='dtype')\n```\n\n----------------------------------------\n\nTITLE: Importing ModDbl from qualtran.bloqs\nDESCRIPTION: This snippet imports the `ModDbl` class from the `qualtran.bloqs.mod_arithmetic` module, which is used to create modular doubling gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import ModDbl\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying a call graph for SingleQubitCompare\nDESCRIPTION: This generates a call graph for the `sq_cmp` bloq, which visualizes the dependencies and sub-components within the quantum circuit. It also computes and displays the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsq_cmp_g, sq_cmp_sigma = sq_cmp.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sq_cmp_g)\nshow_counts_sigma(sq_cmp_sigma)\n```\n\n----------------------------------------\n\nTITLE: Build Alt and Keep Values for Registers\nDESCRIPTION: This code defines a function `build_alt_keep_vals` which takes the two-particle reduced density matrix (`tpq`), the electron repulsion integrals (`eris`), the number of spin orbitals (`num_spin_orb`), and the number of bits for state preparation (`num_bits_state_prep`) as inputs.  It preprocesses these inputs using `preprocess_probabilities_for_reversible_sampling` to generate `alt` and `keep` values necessary for alias sampling used in the `PrepareSecondQuantizationDetailed` bloq. The function calculates and returns the `alt_pqrs` indices and `keep` values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.linalg.lcu_util import preprocess_probabilities_for_reversible_sampling\n\n\ndef build_alt_keep_vals(tpq, eris, num_spin_orb, num_bits_state_prep):\n    # Get some random hamiltonian matrix elements\n    lcu_coeffs = np.concatenate((tpq.ravel(), eris.ravel()))\n    alt, keep, mu = preprocess_probabilities_for_reversible_sampling(\n        np.abs(lcu_coeffs), epsilon=2**-num_bits_state_prep / len(lcu_coeffs)\n    )\n    # our alt value will be between 0 and len(lcu_coeffs), we need to map these\n    # back to p, q, and p, q, r, s indices\n    alt_pqrs = []\n    mat_size = (num_spin_orb // 2) ** 2\n    for k in alt:\n        if k < mat_size:\n            p, q = np.unravel_index(k, (num_spin_orb // 2,) * 2)\n            # we should flag the one-body part of the hamiltonian during select, so\n            # the r, and s values here won't be accessed.\n            alt_pqrs.append((p, q, 0, 0))\n        else:\n            p, q, r, s = np.unravel_index(k - mat_size, (num_spin_orb // 2,) * 4)\n            alt_pqrs.append((p, q, r, s))\n    alt_pqrs = np.array(alt_pqrs).T\n    alt_pqrs = tuple(tuple(int(_) for _ in x) for x in alt_pqrs)\n    return alt_pqrs, keep\n```\n\n----------------------------------------\n\nTITLE: Create MinusEffect Instance\nDESCRIPTION: Creates an instance of the `MinusEffect` bloq, representing the <-| quantum effect. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nminus_effect = MinusEffect()\n```\n\n----------------------------------------\n\nTITLE: Generating and Displaying the Call Graph for ECAdd in Qualtran\nDESCRIPTION: This code generates and displays the call graph for the `ec_add` bloq.  It uses `call_graph` to create the graph and `show_call_graph` to visualize it. It also calculates and displays the resource counts sigma using `show_counts_sigma`. The `ignore_split_join` generalizer is used to simplify the graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ec_add.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nec_add_g, ec_add_sigma = ec_add.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ec_add_g)\nshow_counts_sigma(ec_add_sigma)\n```\n\n----------------------------------------\n\nTITLE: GF2ShiftRight Instance\nDESCRIPTION: Creates an instance of the `GF2ShiftRight` bloq with `m_x = [5, 2, 0]` (corresponding to $x^5 + x^2 + 1$) and `k=3`.  This instance shifts a polynomial in GF(2^5) by 3 positions to the right.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nm_x = [5, 2, 0]  # x^5 + x^2 + 1\ngf2shiftright = GF2ShiftRight(QGF(2, 5, m_x), k=3)  # shift by 3\n```\n\n----------------------------------------\n\nTITLE: TGate Instantiation\nDESCRIPTION: Creates an instance of the TGate class. This demonstrates how to create a T gate object in Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/t_gate.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nt_gate = TGate()\n```\n\n----------------------------------------\n\nTITLE: Show MinusEffect Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `MinusEffect` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nminus_effect_g, minus_effect_sigma = minus_effect.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(minus_effect_g)\nshow_counts_sigma(minus_effect_sigma)\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloq Report Card for basic_gates\nDESCRIPTION: This snippet displays the Bloq report card specifically for the `basic_gates` package. It uses `report_card.query('package == \"basic_gates\"')` to filter the report card data to only include entries where the package is equal to 'basic_gates'. The filtered report card is then passed to `show_bloq_report_card()` for display.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq_report_card(report_card.query('package == \"basic_gates\"'))\n```\n\n----------------------------------------\n\nTITLE: Analyze bloq examples for tensor simulation\nDESCRIPTION: This snippet iterates through the bloq examples, excluding `ApplyGateToLthQubit`, and submits each bloq to `report_on_tensors` for analysis using `ExecuteWithTimeout`.  It collects the results and handles timeouts, storing the data in a list of records.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nexec = ExecuteWithTimeout(timeout=8., max_workers=4)\nfor i, be in enumerate(bes):\n\n    if be.bloq_cls == ApplyGateToLthQubit:\n        # This bloq uses a lambda function as one of its attributes, which\n        # can't be pickled and used with multiprocessing.\n        continue\n    \n    exec.submit(report_on_tensors, kwargs=dict(name=be.name, cls_name=be.bloq_cls.__name__, bloq=be.make()))\n\nrecords = []\nwhile exec.work_to_be_done:\n    kwargs, record = exec.next_result()\n    #print(kwargs['name'], end=' ', flush=True)\n    print('\\r', f'{exec.work_to_be_done:5d} remaining', end='', flush=True)\n    \n    if record is None:\n        records.append({\n            'name': kwargs['name'],\n            'cls': kwargs['cls_name'],\n            'err': 'Timeout',\n        })\n    else:\n        records.append(record)\n```\n\n----------------------------------------\n\nTITLE: Exporting Bloq Documentation as Text Files\nDESCRIPTION: This snippet iterates through notebook specs and bloq specs to generate text files containing the markdown docstrings for each bloq.  It creates a directory for each bloq and writes the documentation to a file named `docs.txt` within that directory.  It leverages the `get_markdown_docstring` function to extract the documentation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/ui-export.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom pathlib import Path\n\nfrom qualtran_dev_tools.notebook_specs import NB_BY_SECTION\nfrom qualtran_dev_tools.parse_docstrings import get_markdown_docstring\n\nfor section in NB_BY_SECTION:\n  for notebook_spec in section[1]:\n    for bloq_spec in notebook_spec.bloq_specs:\n      Path(f'ui_export/{bloq_spec.bloq_cls.__name__}').mkdir(parents=True, exist_ok=True)\n\n      doc_name = f'ui_export/{bloq_spec.bloq_cls.__name__}/docs.txt'\n      if not os.path.isfile(doc_name):\n        with open(doc_name, 'w') as doc_file:\n          doc_file.write('\\n'.join(get_markdown_docstring(bloq_spec.bloq_cls)))\n```\n\n----------------------------------------\n\nTITLE: IsingXUnitary Call Graph\nDESCRIPTION: Generates and displays the call graph of the `ising_x` bloq, along with its sigma counts.  This helps analyze the resource requirements and the internal structure of the bloq. The `ignore_split_join` generalizer is used to simplify the call graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nising_x_g, ising_x_sigma = ising_x.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ising_x_g)\nshow_counts_sigma(ising_x_sigma)\n```\n\n----------------------------------------\n\nTITLE: Visualize Bloqs\nDESCRIPTION: Visualizes the bloqs created with concrete and symbolic parameters, showcasing the quantum circuit representation of the polynomial addition operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf2_poly_4_8_add, gf2_poly_add_symbolic],\n           ['`gf2_poly_4_8_add`', '`gf2_poly_add_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: CRz Decomposition\nDESCRIPTION: Decomposes the `CRz` gate into its constituent bloqs and displays the musical score representation. This showcases the underlying gate-level implementation of the controlled rotation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(crz.decompose_bloq(), 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: PermutationCycle Class Definition\nDESCRIPTION: Defines the `PermutationCycle` class, which applies a single permutation cycle on the basis states. Given a permutation cycle, this bloq cyclically permutes the states within the cycle and leaves other states unchanged.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.permutation import PermutationCycle\n```\n\n----------------------------------------\n\nTITLE: GF2Multiplication Instance with plus_equal_prod=True\nDESCRIPTION: Creates an instance of the `GF2Multiplication` bloq for GF($2^4$) with the `plus_equal_prod` parameter set to True. This results in the Bloq performing the `|result> + |x * y>` operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngf16_multiplication = GF2Multiplication(4, plus_equal_prod=True)\n```\n\n----------------------------------------\n\nTITLE: Create ProgrammableRotationGateArray Instance\nDESCRIPTION: Creates an instance of `ProgrammableRotationGateArray` with specified parameters. It initializes the rotation gate array with rotation angles [1, 2, 3, 4], a kappa value of 2, and uses cirq.Z as the rotation gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/programmable_rotation_gate_array.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprogrammable_rotation_gate_array = ProgrammableRotationGateArray(\n    [1, 2, 3, 4], kappa=2, rotation_gate=cirq.Z\n)\n```\n\n----------------------------------------\n\nTITLE: Importing Phase Block Encoding\nDESCRIPTION: Imports the `Phase` class from the `qualtran.bloqs.block_encoding` module. This class is used to apply a phase to a block encoding, which is a fundamental operation in quantum algorithms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/phase.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import Phase\n```\n\n----------------------------------------\n\nTITLE: Create IntState Instance\nDESCRIPTION: Creates an instance of the `IntState` bloq, representing the |val> quantum state for a non-negative integer val. It takes the integer value and the bitsize as parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nint_state = IntState(55, bitsize=8)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of GF2MulK\nDESCRIPTION: Generates and displays the call graph for `gf2_multiply_by_constant`, ignoring split-join operations. This call graph shows how the multiplication by a constant is decomposed, with a maximum depth of 1. Also displays the associated resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf2_multiply_by_constant_g, gf2_multiply_by_constant_sigma = gf2_multiply_by_constant.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf2_multiply_by_constant_g)\nshow_counts_sigma(gf2_multiply_by_constant_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiating QubitizationQPE for Sparse Chemistry Hamiltonian\nDESCRIPTION: This snippet shows how to instantiate `QubitizationQPE` for a sparse chemistry Hamiltonian. It builds random test integrals, gets the walk operator, sets `algo_eps`, calculates `qlambda` and `qpe_eps`, and creates an instance of `QubitizationQPE` with the calculated parameters and walk operator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nfrom qualtran.bloqs.chemistry.sparse.prepare_test import build_random_test_integrals\nfrom qualtran.bloqs.chemistry.sparse.walk_operator import get_walk_operator_for_sparse_chem_ham\nfrom qualtran.bloqs.phase_estimation import LPResourceState, QubitizationQPE\n\nnum_spatial = 6\ntpq, eris = build_random_test_integrals(num_spatial // 2, seed=7)\nwalk = get_walk_operator_for_sparse_chem_ham(\n    tpq, eris, num_bits_rot_aa=8, num_bits_state_prep=16\n)\n\nalgo_eps = 0.0016\nqlambda = np.sum(np.abs(tpq)) + 0.5 * np.sum(np.abs(eris))\nqpe_eps = algo_eps / (qlambda * np.sqrt(2))\nqubitization_qpe_sparse_chem = QubitizationQPE(\n    walk, LPResourceState.from_standard_deviation_eps(qpe_eps)\n)\n```\n\n----------------------------------------\n\nTITLE: Import SU2RotationGate from Qualtran\nDESCRIPTION: This snippet imports the SU2RotationGate class from the qualtran.bloqs.basic_gates module. This gate implements an arbitrary SU(2) rotation and is used in subsequent examples.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/su2_rotation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import SU2RotationGate\n```\n\n----------------------------------------\n\nTITLE: Import StatePreparationViaRotations\nDESCRIPTION: Imports the `StatePreparationViaRotations` class from the `qualtran.bloqs.state_preparation` module. This class is used for preparing a quantum state from a given list of coefficients using Ry and Rz rotations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.state_preparation import StatePreparationViaRotations\n```\n\n----------------------------------------\n\nTITLE: MultiTargetCNOT Symbolic Instance\nDESCRIPTION: Creates a symbolic instance of `MultiTargetCNOT` with a symbolic bit size `n`. This allows defining the gate with variable size for later specialization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nc_multi_not_symb = MultiTargetCNOT(bitsize=n)\n```\n\n----------------------------------------\n\nTITLE: ZPowGate Import\nDESCRIPTION: Imports the `ZPowGate` class from the `qualtran.bloqs.basic_gates` module. This gate represents a power of the Pauli Z operator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import ZPowGate\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph\nDESCRIPTION: This snippet generates and displays the call graph and sigma counts for the `unitary_block_encoding` instance. It uses the `call_graph` method with a generalizer to simplify the graph, and then uses `show_call_graph` and `show_counts_sigma` to visualize the resource usage.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/unitary.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nunitary_block_encoding_g, unitary_block_encoding_sigma = unitary_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(unitary_block_encoding_g)\nshow_counts_sigma(unitary_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Single Factorization Bloqs\nDESCRIPTION: This snippet imports necessary modules from Qualtran, including Bloq, CompositeBloq, Signature, Register, QBit, QInt, QUInt, QAny and drawing utilities, as well as standard Python libraries like typing, numpy, sympy and cirq. These modules are used to define and manipulate quantum circuit blocks within the Qualtran framework.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Type Checking with QDTypeCheckingSeverity in Qualtran\nDESCRIPTION: This snippet shows how to use the `check_dtypes_consistent` function in Qualtran to check the compatibility of different quantum data types. It demonstrates the use of `QDTypeCheckingSeverity` to control the strictness of the type checking, highlighting the compatibility rules for `QAny`, `QUInt`, and `QInt`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QDTypeCheckingSeverity, check_dtypes_consistent\n\nprint('same  ', check_dtypes_consistent(QUInt(3), QUInt(3)))\nprint('1bit  ', check_dtypes_consistent(QBit(), QAny(1)))\nprint('qany  ',\n    check_dtypes_consistent(QAny(3), QUInt(3)),\n    check_dtypes_consistent(QAny(3), QUInt(3), QDTypeCheckingSeverity.STRICT)\n)\nfrom qualtran import QInt\nprint('qint  ', \n    check_dtypes_consistent(QUInt(3), QInt(3)),\n    check_dtypes_consistent(QUInt(3), QInt(3), QDTypeCheckingSeverity.STRICT)\n)\nprint('diff  ', check_dtypes_consistent(QAny(3), QAny(4)))\n```\n\n----------------------------------------\n\nTITLE: Testing MultiAnd with states and effects\nDESCRIPTION: This code tests the `MultiAnd` gate by preparing input states using `ZeroState` and `OneState`, applying the `MultiAnd` gate, and then measuring the output state using `ZeroEffect` and `OneEffect`. This verifies the truth table behavior of the classical logic implemented by the gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import OneEffect, OneState, ZeroEffect, ZeroState\n\nstate = [ZeroState(), OneState()]\neff = [ZeroEffect(), OneEffect()]\n\n# Experiment with changing the following:\ncvs = (1, 1, 1)\nctrl_string = (1, 1, 1)\n\n\nbb = BloqBuilder()\nctrl_qs = [bb.add(state[c]) for c in ctrl_string]\nctrl_qs, junk, res = bb.add_from(MultiAnd(cvs), ctrl=ctrl_qs)\nfor c, q in zip(ctrl_string, ctrl_qs):\n    bb.add(eff[c], q=q)\n\ncbloq = bb.finalize(junk=junk, res=res)\nshow_bloq(cbloq)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran Bloqs and Dependencies - Python\nDESCRIPTION: This code snippet imports necessary modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `BloqBuilder`, `Signature`, `Register`, `QBit`, `QInt`, `QUInt`, `QAny` for defining quantum circuits and data structures. It also imports standard Python libraries such as `typing`, `numpy`, `sympy`, and `cirq` for additional functionality.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/block_encoding.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: BitonicMerge Definition in Qualtran\nDESCRIPTION: Defines the `BitonicMerge` bloq to merge two sorted sequences of n-bit integers. The `half_length` parameter specifies the length of each sorted input sequence, and `bitsize` specifies the number of bits per integer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.sorting import BitonicMerge\n```\n\n----------------------------------------\n\nTITLE: Importing SelectSparse class\nDESCRIPTION: This imports the `SelectSparse` class from the `qualtran.bloqs.chemistry.sparse` module. This class is used to implement the SELECT oracle for the sparse chemistry Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.sparse import SelectSparse\n```\n\n----------------------------------------\n\nTITLE: Concrete PermutationCycle Definition\nDESCRIPTION: Creates a concrete `PermutationCycle` instance with a specific size `N=4` and cycle `(0, 1, 2)`. This instance represents a cycle that permutes states |0> to |1>, |1> to |2>, and |2> to |0>.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\npermutation_cycle = PermutationCycle(4, (0, 1, 2))\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloq Signatures\nDESCRIPTION: This snippet visualizes the graphical signatures of several `CtrlSpecAnd` instances. It uses the `show_bloqs` function from `qualtran.drawing` to display `ctrl_on_int`, `ctrl_on_bits`, `ctrl_on_nd_bits`, `ctrl_on_multiple_values`, `ctrl_on_symbolic_cv`, and `ctrl_on_symbolic_cv_multi` with labels.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ctrl_on_int, ctrl_on_bits, ctrl_on_nd_bits, ctrl_on_multiple_values, ctrl_on_symbolic_cv, ctrl_on_symbolic_cv_multi],\n           ['`ctrl_on_int`', '`ctrl_on_bits`', '`ctrl_on_nd_bits`', '`ctrl_on_multiple_values`', '`ctrl_on_symbolic_cv`', '`ctrl_on_symbolic_cv_multi`'])\n```\n\n----------------------------------------\n\nTITLE: Displaying: Backreferences with Class Names\nDESCRIPTION: This code displays the backreference index, showing which bloq classes refer to each URL. It iterates through the `backrefs` dictionary (sorted by the number of referring classes) and formats the information into a Markdown string using the URL's title if available. It then displays this string using `IPython.display.Markdown`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfor url, clss in sorted(backrefs.items(), key=lambda x: -len(x[1])):\n    text = f'### [{titles[url]}]({url})\\n'\n    class_names = [f'{cls._class_name_in_pkg_()}' for cls in clss]\n    for cn in sorted(class_names):\n        text += f' - {cn}\\n'\n\n    display(Markdown(text))\n```\n\n----------------------------------------\n\nTITLE: GF2MulViaKaratsuba Import\nDESCRIPTION: Imports the `GF2MulViaKaratsuba` class from the `qualtran.bloqs.gf_arithmetic` module. This is a necessary prerequisite for using the class in any code.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2MulViaKaratsuba\n```\n\n----------------------------------------\n\nTITLE: ParallelComparators Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph for `parallel_compare` using `parallel_compare.call_graph`. The `ignore_split_join` generalizer is used to simplify the graph. The graph and sigma counts are displayed using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nparallel_compare_g, parallel_compare_sigma = parallel_compare.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(parallel_compare_g)\nshow_counts_sigma(parallel_compare_sigma)\n```\n\n----------------------------------------\n\nTITLE: Approximate QFT T-Count Expression\nDESCRIPTION: This snippet defines a function `get_t_counts_aqft` that calculates the T-count for an `ApproximateQFT` instance given the number of qubits `n` and the error tolerance `eps`. It uses the `.call_graph()` method and `t_counts_from_sigma` to derive the symbolic T-count expression, which is then evaluated for symbolic `n` and `epsilon`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/approximate_qft.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.t_counts_from_sigma import t_counts_from_sigma\n\ndef get_t_counts_aqft(n, eps):\n    _, sigma = ApproximateQFT.from_epsilon(n, eps).call_graph()\n    return t_counts_from_sigma(sigma)\n\nget_t_counts_aqft(*sympy.symbols('n, \\epsilon'))\n```\n\n----------------------------------------\n\nTITLE: Instantiate PrepareUVFirstQuantization in Python\nDESCRIPTION: Creates an instance of the `PrepareUVFirstQuantization` class with specified parameters. It takes in `num_bits_p`, `eta`, `num_atoms`, `m_param`, `lambda_zeta`, and `num_bits_nuc_pos` as parameters to configure the preparation of UV states for the first quantization method.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 5\neta = 10\nnum_atoms = 10\nlambda_zeta = 10\nm_param = 2**8\nnum_bits_nuc_pos = 16\n\nprepare_uv = PrepareUVFirstQuantization(\n    num_bits_p=num_bits_p,\n    eta=eta,\n    num_atoms=num_atoms,\n    m_param=m_param,\n    lambda_zeta=lambda_zeta,\n    num_bits_nuc_pos=num_bits_nuc_pos,\n)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures of SwapWithZero\nDESCRIPTION: Displays the graphical signatures of the SwapWithZero instances (standard, small and multi-dimensional) using the show_bloqs function.  This gives a visual depiction of the registers being manipulated.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([swz, swz_small, swz_multi_dimensional],\n           ['`swz`', '`swz_small`', '`swz_multi_dimensional`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature Visualization\nDESCRIPTION: Visualizes the graphical signatures of both the concrete and symbolic instances of `GF2AddK` using `show_bloqs`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_add_k.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf16_add_k, gf2_add_k_symbolic],\n           ['`gf16_add_k`', '`gf2_add_k_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Import necessary libraries\nDESCRIPTION: This snippet imports the required libraries for building and simulating quantum circuits using Cirq and Qualtran, including modules for qubitization and phase estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nimport numpy as np\n\nfrom qualtran._infra.gate_with_registers import get_named_qubits\nfrom qualtran.bloqs.qubitization import QubitizationWalkOperator\nfrom qualtran.bloqs.qubitization.qubitization_walk_operator_test import get_walk_operator_for_1d_ising_model\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import get_walk_operator_for_hubbard_model\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasing Import\nDESCRIPTION: Imports the `HammingWeightPhasing` class from the `qualtran.bloqs.rotations` module. This class implements the Hamming weight phasing algorithm for applying Z rotations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import HammingWeightPhasing\n```\n\n----------------------------------------\n\nTITLE: Import PrepareUVFirstQuantization in Python\nDESCRIPTION: Imports the `PrepareUVFirstQuantization` class from the `qualtran.bloqs.chemistry.pbc.first_quantization.prepare_uv` module. This module is used to prepare the UV states for first quantization chemistry simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.prepare_uv import PrepareUVFirstQuantization\n```\n\n----------------------------------------\n\nTITLE: Call Graph of SingleFactorizationBlockEncoding\nDESCRIPTION: This code snippet generates and displays the call graph of the `sf_block_encoding` bloq, similar to the `SingleFactorizationOneBody` example. It uses `call_graph` with a `max_depth` of 1 and the `ignore_split_join` generalizer and then displays the graph and sigma counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsf_block_encoding_g, sf_block_encoding_sigma = sf_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sf_block_encoding_g)\nshow_counts_sigma(sf_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph for ModAdd\nDESCRIPTION: Generates the call graph for the `mod_add` bloq to analyze resource costs. It uses the `call_graph` method with a maximum depth of 1 and the `ignore_split_join` generalizer to simplify the graph. The `show_call_graph` and `show_counts_sigma` functions then visualize the graph and associated resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmod_add_g, mod_add_sigma = mod_add.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(mod_add_g)\nshow_counts_sigma(mod_add_sigma)\n```\n\n----------------------------------------\n\nTITLE: Cast Bloq Definition\nDESCRIPTION: Defines the `Cast` bloq, which casts a register from one QCDType to another. This re-interprets the register's data and is a bookkeeping operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import Cast\n```\n\n----------------------------------------\n\nTITLE: Import RectangularWindowState from Qualtran\nDESCRIPTION: Imports the `RectangularWindowState` class from the `qualtran.bloqs.phase_estimation.qpe_window_state` module. This class is used for creating rectangular window states in quantum phase estimation algorithms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation.qpe_window_state import RectangularWindowState\n```\n\n----------------------------------------\n\nTITLE: Building a Quantum Circuit with State Preparation\nDESCRIPTION: This code builds a quantum circuit using `BloqBuilder` and the `StatePreparationViaRotations` bloq. It allocates qubits for the state, prepares a phase gradient state, applies the state preparation bloq, uncomputes the phase gradient state, and then finalizes the circuit. Finally, it uses tensor contraction to extract the coefficients of the prepared state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nbb = BloqBuilder()\nstate = bb.allocate(state_bitsize)\nphase_gradient = bb.add(PhaseGradientState(phase_bitsize))\nstate, phase_gradient = bb.add(\n    qsp, target_state=state, phase_gradient=phase_gradient\n)\nbb.add(PhaseGradientState(bitsize=phase_bitsize).adjoint(), phase_grad=phase_gradient)\ncircuit = bb.finalize(state=state)\n\nshow_bloq(circuit)\ncoefficients = circuit.tensor_contract()\n```\n\n----------------------------------------\n\nTITLE: Symbolic Hubbard Model Hamiltonian Simulation Instance\nDESCRIPTION: Creates a symbolic instance of `HamiltonianSimulationByGQSP` where the parameters `tau`, `t`, and `inv_eps` are symbolic variables. This allows for creating symbolic expressions that represent Hamiltonian simulation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/hamiltonian_simulation/hamiltonian_simulation_by_gqsp.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import (\n    get_walk_operator_for_hubbard_model,\n)\n\ntau, t, inv_eps = sympy.symbols(r\"\\tau t \\epsilon^{-1}\", positive=True)\nwalk_op = get_walk_operator_for_hubbard_model(2, 2, tau, 4 * tau)\nsymbolic_hamsim_by_gqsp = HamiltonianSimulationByGQSP(walk_op, t=t, precision=1 / inv_eps)\n```\n\n----------------------------------------\n\nTITLE: Import statements and module dependencies\nDESCRIPTION: These import statements bring in necessary modules and classes from Qualtran, typing, NumPy, SymPy, and Cirq to define and work with quantum circuits, bloqs, and data structures.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_phase_gradient.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Generating and Displaying Call Graph and Sigma Counts\nDESCRIPTION: Generates the call graph and sigma counts for `qft_text_book` using `qft_text_book.call_graph`, ignoring split/join operations. The resulting call graph is then visualized with `show_call_graph`, and the counts are displayed with `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_text_book.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nqft_text_book_g, qft_text_book_sigma = qft_text_book.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(qft_text_book_g)\nshow_counts_sigma(qft_text_book_sigma)\n```\n\n----------------------------------------\n\nTITLE: Example Instance: Apply Z gate to odd indexed qubits\nDESCRIPTION: Defines a function `_z_to_odd` that returns a `cirq.Z` gate if the input `n` is odd, and `cirq.I` (Identity) gate otherwise. Then, it creates an instance of `ApplyGateToLthQubit` named `apply_z_to_odd` which applies the gate returned by `_z_to_odd` to the `selection`-th qubit, controlled by the 'control' register of size 2.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_gate_to_lth_target.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import BQUInt, Register\n\ndef _z_to_odd(n: int):\n    if n % 2 == 1:\n        return cirq.Z\n    return cirq.I\n\napply_z_to_odd = ApplyGateToLthQubit(\n    Register('selection', BQUInt(3, 4)),\n    nth_gate=_z_to_odd,\n    control_regs=Signature.build(control=2),\n)\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for PairPotential\nDESCRIPTION: This snippet generates and displays the call graph for the `PairPotential` bloq, up to a depth of 1. It uses `ignore_split_join` as a generalizer and visualizes the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\npair_potential_g, pair_potential_sigma = pair_potential.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(pair_potential_g)\nshow_counts_sigma(pair_potential_sigma)\n```\n\n----------------------------------------\n\nTITLE: Create a TrotterizedUnitary instance\nDESCRIPTION: Creates an instance of the `TrotterizedUnitary` bloq.  It first defines the IsingXX and IsingZZ unitaries using `nsites`, `j_zz`, `gamma_x` and `dt`. The instance is constructed using the defined bloqs, indices, coeffs, and timestep parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/trotterized_unitary.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.ising import IsingXUnitary, IsingZZUnitary\n\nnsites = 3\nj_zz = 2\ngamma_x = 0.1\ndt = 0.01\nindices = (0, 1, 0)\ncoeffs = (0.5 * gamma_x, j_zz, 0.5 * gamma_x)\n# The angles for the Trotter bloqs will be overwritten, so these are placeholder values.\nzz_bloq = IsingZZUnitary(nsites=nsites, angle=2 * dt * j_zz)\nx_bloq = IsingXUnitary(nsites=nsites, angle=0.5 * 2 * dt * gamma_x)\ntrott_unitary = TrotterizedUnitary(\n    bloqs=(x_bloq, zz_bloq), indices=indices, coeffs=coeffs, timestep=dt\n)\n```\n\n----------------------------------------\n\nTITLE: SparseMatrixHermitian Example (Symbolic)\nDESCRIPTION: Demonstrates the creation of a `SparseMatrixHermitian` instance using symbolic dimensions. It first defines a symbolic variable `n` for the system bitsize.  Then, it creates `TopLeftRowColumnOracle` and `UniformSqrtEntryOracle` instances. Finally, it instantiates `SparseMatrixHermitian` with these oracles and `eps=0`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix_hermitian.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding.sparse_matrix import TopLeftRowColumnOracle\nfrom qualtran.bloqs.block_encoding.sparse_matrix_hermitian import UniformSqrtEntryOracle\n\nn = sympy.Symbol('n', positive=True, integer=True)\ncol_oracle = TopLeftRowColumnOracle(system_bitsize=n)\nentry_oracle = UniformSqrtEntryOracle(system_bitsize=n, entry=0.3)\nsparse_matrix_symb_hermitian_block_encoding = SparseMatrixHermitian(\n    col_oracle, entry_oracle, eps=0\n)\n```\n\n----------------------------------------\n\nTITLE: Wiring Bloqs with BloqBuilder (Way 1) - Python\nDESCRIPTION: Demonstrates wiring up two instances of a `CNOT` Bloq using the `BloqBuilder`. It creates two registers, 'q0' and 'q1', and connects them sequentially through two `CNOT` gates. The `finalize` method creates a `CompositeBloq` from the constructed circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, BloqBuilder, Signature, Soquet\nfrom qualtran.drawing import show_bloq\n\n# An example Bloq:\nfrom qualtran.bloqs.basic_gates import CNOT\nbloq = CNOT()\n\n# Wire up (way 1)\nbb = BloqBuilder()\nq0 = bb.add_register('q0', 1)\nq1 = bb.add_register('q1', 1)\nq0, q1 = bb.add(bloq, ctrl=q0, target=q1)\nq0, q1 = bb.add(bloq, ctrl=q0, target=q1)\ncbloq = bb.finalize(q0=q0, q1=q1)\nshow_bloq(cbloq)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of RealGivensRotationByPhaseGradient\nDESCRIPTION: Generates and displays the graphical signature of the `real_givens` bloq using the `show_bloqs` function. This provides a visual representation of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([real_givens],\n           ['`real_givens`'])\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures of Tensor Products\nDESCRIPTION: Visualize the block diagrams (graphical signatures) of the created `TensorProduct` instances, allowing for a visual representation of their structure and connections. Uses `show_bloqs` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/tensor_product.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([tensor_product_block_encoding, tensor_product_block_encoding_properties, tensor_product_block_encoding_symb],\n           ['`tensor_product_block_encoding`', '`tensor_product_block_encoding_properties`', '`tensor_product_block_encoding_symb`'])\n```\n\n----------------------------------------\n\nTITLE: PrepareTFirstQuantization bloq definition\nDESCRIPTION: This snippet imports the `PrepareTFirstQuantization` class from `qualtran.bloqs.chemistry.pbc.first_quantization.prepare_t`.  This bloq is responsible for preparing the quantum state representing the kinetic energy (T) operator in the first quantized chemistry Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.prepare_t import PrepareTFirstQuantization\n```\n\n----------------------------------------\n\nTITLE: Summarizing Results for All Packages\nDESCRIPTION: This snippet summarizes the results of the entire Bloq report card. It passes the complete `report_card` to the `summarize_results()` function. This will generate a summary of all Bloqs and their associated data.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsummarize_results(report_card)\n```\n\n----------------------------------------\n\nTITLE: Approximate QFT Call Graph Analysis\nDESCRIPTION: This snippet performs call graph analysis on the `approximate_qft_small` instance.  It generates a call graph and a sigma (resource counts) using the `.call_graph()` method with `max_depth=1` and a generalizer to ignore split/join operations. The results are then visualized using `show_call_graph` and `show_counts_sigma` to understand the bloq's internal structure and resource requirements.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/approximate_qft.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\napproximate_qft_small_g, approximate_qft_small_sigma = approximate_qft_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(approximate_qft_small_g)\nshow_counts_sigma(approximate_qft_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules for Bloq construction\nDESCRIPTION: This code snippet imports necessary modules from the `qualtran` library for building quantum circuits and data structures, along with standard Python libraries like `numpy` and `sympy` for numerical and symbolic computations. These modules are essential for defining and manipulating quantum operations within the Qualtran framework.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: SymmetricDifference Example Instance\nDESCRIPTION: Creates an instance of the `SymmetricDifference` class with specific parameters. It sets the number of elements in the left-hand side set (`n_lhs`) to 4, the number of elements in the right-hand side set (`n_rhs`) to 2, and the expected number of elements in the symmetric difference (`n_diff`) to 4. The data type (`dtype`) of each element is set to `QUInt(4)`, which represents an unsigned integer with 4 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndtype = QUInt(4)\nsymm_diff = SymmetricDifference(n_lhs=4, n_rhs=2, n_diff=4, dtype=dtype)\n```\n\n----------------------------------------\n\nTITLE: Custom JSON Encoder for Qualtran Objects\nDESCRIPTION: This snippet defines a custom JSON encoder (`BloqEncoder`) to serialize objects that are not natively JSON serializable, such as `sympy.Symbol` and `Side`. It provides specific handling for these types, converting them into string representations for JSON compatibility.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/ui-export.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom sympy import Symbol\nfrom typing import Any\n\nfrom qualtran.drawing.musical_score import MusicalScoreEncoder\nfrom qualtran._infra.registers import Side\n\nclass BloqEncoder(MusicalScoreEncoder):\n\n  def default(self, o: Any) -> Any:\n    if isinstance(o, (Symbol)):\n      return f'Symbol({o})'\n    if isinstance(o, complex):\n      return f'{o.real}+{o.imag}i'\n    if isinstance(o, Side):\n      return 'Side.LEFT' if o == Side.LEFT else 'Side.RIGHT' if o == Side.RIGHT else 'Side.THRU'\n\n    try:\n      return super().default(o)\n    except:\n      return 'NOT_SERIALIZABLE'\n```\n\n----------------------------------------\n\nTITLE: Define GFPolySplit operation in Qualtran\nDESCRIPTION: Defines a `GFPolySplit` bloq, which splits a register representing coefficients of a polynomial into an array of `QGF` types. It takes a `QGFPoly` instance as a parameter, representing the polynomial to be split, and transforms it into an array of `QGF` registers representing the polynomial's coefficients.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf_poly_split_and_join.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_poly_arithmetic import GFPolySplit\n```\n\n----------------------------------------\n\nTITLE: Show Bloq Graphical Signatures\nDESCRIPTION: This snippet uses `qualtran.drawing.show_bloqs` to visualize the graphical signatures of the created `GF2PolyAddK` instances (`gf2_poly_4_8_add_k` and `gf2_poly_add_k_symbolic`). This provides a visual representation of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add_k.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf2_poly_4_8_add_k, gf2_poly_add_k_symbolic],\n           ['`gf2_poly_4_8_add_k`', '`gf2_poly_add_k_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Flattening a CompositeBloq Once in Qualtran\nDESCRIPTION: This snippet flattens a `CompositeBloq` once using the `flatten_once()` method. It takes the flattened `CompositeBloq` named `flat_three_p` as input and produces a `CompositeBloq` with one less level of nesting.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nflat_three_p = three_p.flatten_once()\nshow_bloq(flat_three_p)\n```\n\n----------------------------------------\n\nTITLE: Plotting Bloq Counts Distribution for Select Bloq (First Quantization)\nDESCRIPTION: This snippet plots the bloq counts distribution within the `SelectFirstQuantization` bloq for various eta values. It retrieves the bloq counts, sorts them by name, and displays them as a pie chart using `matplotlib` for each eta value.  It uses `ignore_split_join` and `ignore_alloc_free` for generalizing.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join, ignore_alloc_free\n# let's just get the names of the relevant bloqs in select first\nfig, ax = plt.subplots(nrows=1, ncols=5)\neta_vals = [10, 20, 40, 60, 80]\nfor ieta, eta in enumerate(eta_vals):\n    sel_fq = SelectFirstQuantization(num_bits_p, eta, eta, eta)\n    bloq_counts = sel_fq.bloq_counts(generalizer=[ignore_split_join, ignore_alloc_free])\n    # dictionary returned does not preserve any order so sort by the pretty names of the bloqs\n    sorted_bloqs = sorted(\n        [bloq for bloq in sel_fq.bloq_counts(generalizer=[ignore_split_join, ignore_alloc_free]).keys()],\n        key=lambda x: str(x),\n    )\n    keys = [str(b) for b in sorted_bloqs]\n    toffoli_counts = []\n    for bloq in sorted_bloqs:\n        count = bloq_counts[bloq]\n        toffoli_counts.append(count * get_toffoli_counts(bloq))\n    ax[ieta].set_title(rf'$\\eta = {eta}$')\n    ax[ieta].pie(toffoli_counts, autopct='%1.1f%%')\nax[-1].legend(\n    labels=keys, loc='best', bbox_to_anchor=(2, 1)\n)\nfig.set_size_inches(10, 6)\n```\n\n----------------------------------------\n\nTITLE: Import And bloq from qualtran.bloqs.mcmt\nDESCRIPTION: This code snippet imports the `And` class from the `qualtran.bloqs.mcmt` module, which is necessary to instantiate and use the two-bit AND operation bloq. This makes the `And` gate available for use in larger quantum circuits and algorithms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mcmt import And\n```\n\n----------------------------------------\n\nTITLE: Import TextbookQPE from qualtran.bloqs\nDESCRIPTION: Imports the TextbookQPE class from the qualtran.bloqs.phase_estimation module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation import TextbookQPE\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: Imports necessary modules from the `qualtran` library and standard Python libraries for defining and manipulating quantum circuits and data structures. This includes modules for defining Bloqs (quantum operations), Composites, registers, and data types for QBits, QInts, QUInts, and QAny, along with drawing utilities for visualizing quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Importing LessThanConstant Bloq\nDESCRIPTION: This line imports the `LessThanConstant` class from the `qualtran.bloqs.arithmetic` module. The `LessThanConstant` bloq is used to compare an integer against a constant value to check if it's less than.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import LessThanConstant\n```\n\n----------------------------------------\n\nTITLE: T Gate as SU2RotationGate\nDESCRIPTION: This snippet defines a T gate by instantiating the SU2RotationGate with specific parameters (theta = 0, phi = 3*pi/4, lambda = 0, global_shift = -3*pi/4). This further demonstrates the versatility of the SU2RotationGate in representing other quantum gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/su2_rotation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nt_gate = SU2RotationGate(0, 3 * np.pi / 4, 0, -3 * np.pi / 4)\n```\n\n----------------------------------------\n\nTITLE: Displaying Graphical Signatures of QROM Instances\nDESCRIPTION: This snippet demonstrates how to display the graphical signatures of various `SelectSwapQROM` instances using `qualtran.drawing.show_bloqs`. It imports the `show_bloqs` function and then calls it with a list of QROM instances (`qroam_multi_data`, `qroam_multi_dim`, etc.) and their corresponding names. This allows for visual inspection of the QROM structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([qroam_multi_data, qroam_multi_dim, qroam_symb_dirty_1d, qroam_symb_dirty_2d, qroam_symb_clean_1d, qroam_symb_clean_2d],\n           ['`qroam_multi_data`', '`qroam_multi_dim`', '`qroam_symb_dirty_1d`', '`qroam_symb_dirty_2d`', '`qroam_symb_clean_1d`', '`qroam_symb_clean_2d`'])\n```\n\n----------------------------------------\n\nTITLE: Import ZeroState Bloq\nDESCRIPTION: Imports the `ZeroState` class from the `qualtran.bloqs.basic_gates` module. `ZeroState` represents the |0> quantum state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import ZeroState\n```\n\n----------------------------------------\n\nTITLE: Visualize PrepareFirstQuantization bloq\nDESCRIPTION: This snippet uses `show_bloqs` from `qualtran.drawing` to visualize the `prep_first_quant` bloq. This allows for a graphical representation of the bloq's structure and connections, aiding in understanding and debugging.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prep_first_quant],\n           ['`prep_first_quant`'])\n```\n\n----------------------------------------\n\nTITLE: Import SelectTHC\nDESCRIPTION: Imports the `SelectTHC` class from the `qualtran.bloqs.chemistry.thc` module. This is a prerequisite for using the `SelectTHC` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.thc import SelectTHC\n```\n\n----------------------------------------\n\nTITLE: Import InvertRealNumber Bloq\nDESCRIPTION: Imports the `InvertRealNumber` class from the `qualtran.bloqs.arithmetic` module. This bloq inverts a fixed-point representation of a real number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import InvertRealNumber\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports\nDESCRIPTION: Imports necessary modules from the `qualtran` library, including Bloq, CompositeBloq, BloqBuilder, Signature, Register, QBit, QInt, QUInt, and QAny. Also imports `typing`, `numpy`, `sympy`, and `cirq` for type hinting, numerical computation, symbolic computation and quantum circuit construction, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix_hermitian.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Clone and install Qualtran from source\nDESCRIPTION: These commands clone the Qualtran repository from GitHub, navigate to the directory, and install the library in editable mode using pip. This allows for inspecting and modifying the source code.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/quantumlib/Qualtran.git\ncd Qualtran/\npip install -e .\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for PolynmomialEvaluationInverseSquareRoot\nDESCRIPTION: This snippet generates and displays the call graph for the `PolynmomialEvaluationInverseSquareRoot` bloq, up to a depth of 1. It uses `ignore_split_join` as a generalizer and visualizes the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` from `qualtran.drawing`. The call graph provides insight into the internal structure and dependencies of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\npoly_inv_sqrt_g, poly_inv_sqrt_sigma = poly_inv_sqrt.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(poly_inv_sqrt_g)\nshow_counts_sigma(poly_inv_sqrt_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for SelectPauliLCU\nDESCRIPTION: This snippet generates and visualizes the call graph for the `select_pauli_lcu` instance. It uses the `call_graph` method with a specified `max_depth` and `generalizer` (`ignore_split_join`) to simplify the graph. The `show_call_graph` and `show_counts_sigma` functions display the call graph and the count sigma respectively, aiding in resource estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/select_pauli_lcu.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nselect_pauli_lcu_g, select_pauli_lcu_sigma = select_pauli_lcu.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(select_pauli_lcu_g)\nshow_counts_sigma(select_pauli_lcu_sigma)\n```\n\n----------------------------------------\n\nTITLE: Example: Get Walk Operator for Sparse Chemistry Hamiltonian\nDESCRIPTION: This code constructs a walk operator for a sparse chemistry Hamiltonian. It uses `get_walk_operator_for_sparse_chem_ham` and generates random test integrals using `build_random_test_integrals`.  The parameters `num_bits_rot_aa` and `num_bits_state_prep` control the precision of rotations and state preparation respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.sparse.prepare_test import build_random_test_integrals\nfrom qualtran.bloqs.chemistry.sparse.walk_operator import get_walk_operator_for_sparse_chem_ham\n\nnum_spin_orb = 8\nnum_bits_rot_aa = 8\nnum_bits_state_prep = 12\ntpq, eris = build_random_test_integrals(num_spin_orb // 2)\nwalk_op_chem_sparse = get_walk_operator_for_sparse_chem_ham(\n    tpq, eris, num_bits_rot_aa=num_bits_rot_aa, num_bits_state_prep=num_bits_state_prep\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a Signature with QBits in Qualtran\nDESCRIPTION: This code snippet shows how to create a `Signature` object in Qualtran that defines the input and output registers of a bloq. It uses `Register` and `QBit` to declare two registers, 'arg1' and 'arg2', as qubits. The `n_qubits()` method is then used to determine the total number of qubits in the signature.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Signature, Register, QBit\n\nsignature = Signature([\n    Register('arg1', QBit()),\n    Register('arg2', QBit()),\n])\nprint(signature.n_qubits())\n```\n\n----------------------------------------\n\nTITLE: Sparse State Preparation with Symbolic Parameters\nDESCRIPTION: This code prepares a sparse state using the `SparseStatePreparationAliasSampling` class with symbolic parameters. It defines symbolic variables for the number of coefficients (`n_coeffs`), number of non-zero coefficients (`n_nonzero_coeffs`), sum of coefficients (`sum_coeff`), and desired precision (`eps`). The `from_n_coeff` method is used to create a `SparseStatePreparationAliasSampling` instance with these symbolic parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nn_coeffs, n_nonzero_coeffs, sum_coeff, eps = sympy.symbols(r\"L d \\lambda \\epsilon\")\nsparse_state_prep_alias_symb = SparseStatePreparationAliasSampling.from_n_coeff(\n    n_coeffs, n_nonzero_coeffs, sum_coeff, precision=eps\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing SelectSwapQROM with Symbolic Dimensions (1D, Dirty Ancilla)\nDESCRIPTION: This snippet shows how to initialize a `SelectSwapQROM` instance using symbolic dimensions defined with the `sympy` library. It defines symbolic variables for N, b, k, and c, and then uses `build_from_bitsize` to create `qroam_symb_dirty_1d`. `use_dirty_ancilla` defaults to True, and this creates a QROM with symbolic dimensions for analysis purposes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nN, b, k, c = sympy.symbols('N b k c', positive=True, integers=True)\nqroam_symb_dirty_1d = SelectSwapQROM.build_from_bitsize(\n    (N,), (b,), log_block_sizes=(k,), num_controls=c\n)\n```\n\n----------------------------------------\n\nTITLE: Example Instance of SingleFactorizationOneBody\nDESCRIPTION: This code snippet demonstrates how to create an instance of the `SingleFactorizationOneBody` bloq. It sets the parameters `num_aux`, `num_bits_state_prep`, `num_bits_rot_aa`, and `num_spin_orb` and initializes the `sf_one_body` object with these values, setting `is_adjoint` to `False`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnum_aux = 50\nnum_bits_state_prep = 12\nnum_bits_rot_aa = 7\nnum_spin_orb = 10\nsf_one_body = SingleFactorizationOneBody(\n    num_aux=num_aux,\n    num_spin_orb=num_spin_orb,\n    num_bits_state_prep=num_bits_state_prep,\n    num_bits_rot_aa=num_bits_rot_aa,\n    is_adjoint=False,\n)\n```\n\n----------------------------------------\n\nTITLE: Display tensor simulable bloq examples\nDESCRIPTION: Prints the number of tensor simulable Bloq examples and displays the dataframe.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(len(df[df['width'] <= 25]))\ndf[df['width'] <= 25]\n```\n\n----------------------------------------\n\nTITLE: Importing EqualsAConstant Bloq\nDESCRIPTION: This line imports the `EqualsAConstant` class from the `qualtran.bloqs.arithmetic` module. The `EqualsAConstant` bloq is used to compare an integer against a constant value to check for equality.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import EqualsAConstant\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: Imports the necessary modules, including typing and numpy. This is a standard practice to ensure that all dependencies are available before proceeding with further code execution.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import *\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: TensorProduct Instance with Symbolic Parameters\nDESCRIPTION: Demonstrates creating a `TensorProduct` instance with symbolic parameters for `alpha`, `ancilla_bitsize`, and `epsilon` using the `sympy` library. This allows for representing the block encoding properties symbolically for later analysis.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/tensor_product.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.basic_gates import Hadamard, TGate\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\nalpha1 = sympy.Symbol('alpha1')\na1 = sympy.Symbol('a1')\neps1 = sympy.Symbol('eps1')\nalpha2 = sympy.Symbol('alpha2')\na2 = sympy.Symbol('a2')\neps2 = sympy.Symbol('eps2')\ntensor_product_block_encoding_symb = TensorProduct(\n    (\n        Unitary(TGate(), alpha=alpha1, ancilla_bitsize=a1, epsilon=eps1),\n        Unitary(Hadamard(), alpha=alpha2, ancilla_bitsize=a2, epsilon=eps2),\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a GateWithRegisters Subclass\nDESCRIPTION: This snippet defines a custom quantum gate, `MyGate`, by subclassing `GateWithRegisters`. It overrides the `signature` property to define the gate's input registers and implements the `decompose_from_registers` method to define how the gate is decomposed into simpler gates (in this case, CNOT gates).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport cirq\nfrom qualtran import GateWithRegisters\n\nclass MyGate(GateWithRegisters):\n    \n    @property\n    def signature(self):\n        return Signature.build(\n            control=2,\n            target=3,\n        )\n    \n    def decompose_from_registers(self, context, control, target):\n        assert len(control) == 2\n        assert len(target) == 3\n        \n        for c in control:\n            for t in target:\n                yield cirq.CNOT(c, t)\n```\n\n----------------------------------------\n\nTITLE: Generating and Displaying Call Graph for a QROM Instance\nDESCRIPTION: This snippet demonstrates generating and displaying the call graph for the `qroam_multi_data` instance using `qualtran.resource_counting`. It imports `ignore_split_join` from `qualtran.resource_counting.generalizers` and then calls the `call_graph` method with `max_depth=1` and the generalizer. It then uses `show_call_graph` and `show_counts_sigma` to visualize the call graph and associated resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nqroam_multi_data_g, qroam_multi_data_sigma = qroam_multi_data.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(qroam_multi_data_g)\nshow_counts_sigma(qroam_multi_data_sigma)\n```\n\n----------------------------------------\n\nTITLE: Composite Bloq Construction for QPE\nDESCRIPTION: This defines a function `construct_composite_boq` that takes a `TextbookQPE` bloq as input and wraps it within `OneState` and `OneEffect` bloqs, effectively preparing the input state and measuring the output state.  It returns a `CompositeBloq` representing the full QPE circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef construct_composite_boq(bloq: TextbookQPE) -> CompositeBloq:\n    bb = BloqBuilder()\n    q = bb.add(OneState())\n    phase_reg, q = bb.add(bloq, q=q)\n    bb.add(OneEffect(), q=q)\n    return bb.finalize(phase_reg=phase_reg)\n```\n\n----------------------------------------\n\nTITLE: SparseMatrix Explicit Entry Example\nDESCRIPTION: Creates a `SparseMatrix` instance using explicit matrix data via `ExplicitEntryOracle`. The example defines a 2x2 matrix and uses `TopLeftRowColumnOracle` for row and column selection.  `entry_bitsize` is used to specify the bit precision of the explicit entry.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding.sparse_matrix import (\n    ExplicitEntryOracle,\n    TopLeftRowColumnOracle,\n)\n\ndata = np.array([[0.0, 0.25], [1 / 3, 0.467]])\nrow_oracle = TopLeftRowColumnOracle(system_bitsize=1)\ncol_oracle = TopLeftRowColumnOracle(system_bitsize=1)\nentry_oracle = ExplicitEntryOracle(system_bitsize=1, data=data, entry_bitsize=10)\nexplicit_matrix_block_encoding = SparseMatrix(row_oracle, col_oracle, entry_oracle, eps=0)\n```\n\n----------------------------------------\n\nTITLE: Imports for Qualtran Bloq Construction\nDESCRIPTION: This code snippet imports necessary modules from Qualtran and other libraries like NumPy, SymPy, and Cirq to define and manipulate quantum bloqs. These modules are essential for creating quantum circuits and performing symbolic calculations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_lth_bloq.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of LPRSInterimPrep\nDESCRIPTION: This snippet uses `show_bloqs` from `qualtran.drawing` to display the graphical signature of the `lprs_interim_prep` Bloq. This provides a visual representation of the Bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lprs_interim_prep],\n           ['`lprs_interim_prep`'])\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and related libraries\nDESCRIPTION: Imports necessary modules from the Qualtran library and other dependencies like numpy, sympy, and cirq, enabling the construction and manipulation of quantum circuits and data structures.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasing Example Instance\nDESCRIPTION: Creates an instance of `HammingWeightPhasing` with a bitsize of 4 and an exponent of pi/2. This example demonstrates how to instantiate the `HammingWeightPhasing` bloq with specific parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nhamming_weight_phasing = HammingWeightPhasing(4, np.pi / 2.0)\n# Applying this unitary to |1111> should be the identity, and |0101> will flip the sign.\n```\n\n----------------------------------------\n\nTITLE: SelectHubbard Instance Example\nDESCRIPTION: Creates an instance of the `SelectHubbard` class with specified dimensions `x_dim` and `y_dim`. This example demonstrates how to initialize the SELECT operation for a Hubbard model with a 4x4 grid.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx_dim = 4\ny_dim = 4\nsel_hubb = SelectHubbard(x_dim, y_dim)\n```\n\n----------------------------------------\n\nTITLE: SquareRealNumber Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `SquareRealNumber` instance, using the `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsquare_real_number_g, square_real_number_sigma = square_real_number.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(square_real_number_g)\nshow_counts_sigma(square_real_number_sigma)\n```\n\n----------------------------------------\n\nTITLE: Update Local Main and Merge (Git)\nDESCRIPTION: These commands update the local `main` branch with the latest changes from the upstream repository and then merges those changes into the working branch `YOUR_BRANCH_NAME`. This helps to keep the working branch up-to-date with the main development line and minimizes merge conflicts.  It assumes an upstream remote named 'upstream' is configured.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# Track the upstream repo (if your local repo hasn't):\ngit remote add upstream https://github.com/quantumlib/Qualtran.git\n\n# Update your local main.\ngit fetch upstream\ngit checkout main\ngit merge upstream/main\n# Merge local main into your branch.\ngit checkout YOUR_BRANCH_NAME\ngit merge main\n```\n\n----------------------------------------\n\nTITLE: Show MultiplyTwoReals Bloq\nDESCRIPTION: Displays the `MultiplyTwoReals` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([multiply_two_reals],\n           ['`multiply_two_reals`'])\n```\n\n----------------------------------------\n\nTITLE: Import MultiplyTwoReals Bloq\nDESCRIPTION: Imports the `MultiplyTwoReals` class from the `qualtran.bloqs.arithmetic` module.  This bloq multiplies two fixed-point representations of real numbers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import MultiplyTwoReals\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation\nDESCRIPTION: This snippet demonstrates how to generate and visualize the call graph of the `linear_combination_block_encoding` using the `call_graph` method and `show_call_graph` function. The `ignore_split_join` generalizer is used to simplify the graph. `show_counts_sigma` visualizes the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/linear_combination.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlinear_combination_block_encoding_g, linear_combination_block_encoding_sigma = linear_combination_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(linear_combination_block_encoding_g)\nshow_counts_sigma(linear_combination_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import CAdd from Qualtran\nDESCRIPTION: This snippet imports the `CAdd` class from the `qualtran.bloqs.arithmetic` module, which represents the controlled addition gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_addition.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import CAdd\n```\n\n----------------------------------------\n\nTITLE: Qualtran List Functions Imports\nDESCRIPTION: Imports necessary modules from the `qualtran` library and standard Python libraries like `typing`, `numpy`, `sympy`, and `cirq`. These modules are used for defining and manipulating quantum building blocks (Bloqs), creating composite structures, defining signatures and registers, and generating visualizations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: SparseMatrix Symbolic Example\nDESCRIPTION: Creates a `SparseMatrix` instance using symbolic dimensions. The row and column oracles are `TopLeftRowColumnOracle` and the entry oracle is `UniformEntryOracle`, all parameterized by a sympy symbol `n`. This showcases the ability to define the sparse matrix block encoding with symbolic sizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding.sparse_matrix import (\n    TopLeftRowColumnOracle,\n    UniformEntryOracle,\n)\n\nn = sympy.Symbol('n', positive=True, integer=True)\nrow_oracle = TopLeftRowColumnOracle(system_bitsize=n)\ncol_oracle = TopLeftRowColumnOracle(system_bitsize=n)\nentry_oracle = UniformEntryOracle(system_bitsize=n, entry=0.3)\nsparse_matrix_symb_block_encoding = SparseMatrix(row_oracle, col_oracle, entry_oracle, eps=0)\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup (Python)\nDESCRIPTION: Imports necessary modules from the `qualtran` library for defining and manipulating quantum bloqs, as well as standard Python libraries for typing, numerical computation, symbolic mathematics, and circuit simulation with Cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of ApplyLthBloq\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the instantiated `apply_lth_bloq`. This visualization helps understand the bloq's inputs, outputs, and internal structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_lth_bloq.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([apply_lth_bloq],\n           ['`apply_lth_bloq`'])\n```\n\n----------------------------------------\n\nTITLE: Building: Creating a Backreference Index\nDESCRIPTION: This code builds a backreference index that maps URLs to the bloq classes that reference them. It iterates through the `references` dictionary and checks if a reference has a `url` attribute. If it does, it adds the corresponding bloq class to the list of classes associated with that URL in the `backrefs` defaultdict.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom collections import defaultdict\nbackrefs = defaultdict(list)\n\nfor bloq_cls, refs in references.items():\n    for ref in refs:\n        if not hasattr(ref, 'url'):\n            continue\n\n        backrefs[ref.url].append(bloq_cls)\nbackrefs = dict(backrefs)\n```\n\n----------------------------------------\n\nTITLE: Example Instance with QvrZPow\nDESCRIPTION: This snippet creates an instance of `PhasingViaCostFunction` using `QvrZPow` as the phase oracle.  It defines a `QFxp` register, a `Square` cost evaluation oracle, and a `QvrZPow` phase oracle, then combines them into a `PhasingViaCostFunction` instance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phasing_via_cost_function.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QFxp, Register\nfrom qualtran.bloqs.arithmetic import Square\nfrom qualtran.bloqs.rotations.quantum_variable_rotation import QvrZPow\n\nn, gamma, eps = 5, 0.1234, 1e-8\ncost_reg = Register('result', QFxp(2 * n, 2 * n, signed=False))\ncost_eval_oracle = Square(n)\nphase_oracle = QvrZPow(cost_reg, gamma, eps)\nsquare_via_zpow_phasing = PhasingViaCostFunction(cost_eval_oracle, phase_oracle)\n```\n\n----------------------------------------\n\nTITLE: Printing Cost Comparison for DoubleFactorizationBlockEncoding\nDESCRIPTION: This snippet calculates and prints a cost comparison for the double factorization block encoding.  It compares the qualtran cost (toffoli counts) to a paper reference cost, taking into account the cost associated with reflections and QPE (Quantum Phase Estimation).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nrefl_cost_and_qpe = (df_bloq.num_aux -1).bit_length() + (num_spin_orb // 2 - 1).bit_length() + num_bits_state_prep + 1 + 2\nprint(f'qualtran cost = {get_toffoli_counts(df_bloq)} vs paper = {21753 - refl_cost_and_qpe}')\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Count Display\nDESCRIPTION: This snippet generates and displays the call graph and resource counts for the `gf16_square` instance. It uses `ignore_split_join` to simplify the call graph by ignoring split and join operations, and then displays the call graph and the corresponding sigma counts using `show_call_graph` and `show_counts_sigma` respectively. This allows for analyzing the resource requirements of the GF(2^m) squaring operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_square.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf16_square_g, gf16_square_sigma = gf16_square.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf16_square_g)\nshow_counts_sigma(gf16_square_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph in Python\nDESCRIPTION: This snippet generates a call graph and counts sigma for the `black_box_prepare` bloq, using the `call_graph` method with a maximum depth of 1 and the `ignore_split_join` generalizer. The resulting call graph and sigma counts are then displayed using `show_call_graph` and `show_counts_sigma` respectively. This helps with resource analysis of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nblack_box_prepare_g, black_box_prepare_sigma = black_box_prepare.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(black_box_prepare_g)\nshow_counts_sigma(black_box_prepare_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Representation of GF2Addition Instances\nDESCRIPTION: Visualize the graphical representations of `gf16_addition` and `gf2_addition_symbolic` using `show_bloqs` from `qualtran.drawing`. This function renders the block diagrams representing the quantum operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_addition.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf16_addition, gf2_addition_symbolic],\n           ['`gf16_addition`', '`gf2_addition_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signature of DoubleFactorizationOneBody\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `df_one_body` bloq created in the previous example. The signature visualizes the inputs, outputs, and internal structure of the bloq, providing a high-level representation of its functionality.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([df_one_body],\n           ['`df_one_body`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiating a CNOT Gate\nDESCRIPTION: This code demonstrates how to create an instance of the `CNOT` gate. The resulting `cnot` object can then be used in larger quantum circuits within Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/cnot.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncnot = CNOT()\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and other modules\nDESCRIPTION: Imports necessary modules from the Qualtran library for defining and manipulating quantum circuits, including `Bloq`, `CompositeBloq`, `Signature`, and register types. Also imports `numpy`, `sympy`, and `cirq` for numerical computation, symbolic manipulation, and circuit simulation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for Dense State Preparation\nDESCRIPTION: This code generates and displays the call graph for the `state_prep_alias` bloq, using `call_graph` method with a maximum depth of 1 and the `ignore_split_join` generalizer. It also displays the counts sigma data.  This provides information about the resource requirements of the `state_prep_alias` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nstate_prep_alias_g, state_prep_alias_sigma = state_prep_alias.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(state_prep_alias_g)\nshow_counts_sigma(state_prep_alias_sigma)\n```\n\n----------------------------------------\n\nTITLE: Checkout and Create Branch (Git)\nDESCRIPTION: This command checks out the `main` branch and creates a new branch named `YOUR_BRANCH_NAME` from it.  It's a common step in a Git workflow to isolate changes in a separate branch. `YOUR_BRANCH_NAME` should be replaced with a descriptive name for the new branch.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout main -b YOUR_BRANCH_NAME\n```\n\n----------------------------------------\n\nTITLE: Import ArcSin from Qualtran\nDESCRIPTION: Imports the `ArcSin` class from the `qualtran.bloqs.arithmetic.trigonometric` module. This class implements the arcsine function for fixed-point numbers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/trigonometric/trigonometric.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.trigonometric import ArcSin\n```\n\n----------------------------------------\n\nTITLE: Generate and Display Call Graph\nDESCRIPTION: Generates and displays the call graph for the symbolic `SparseMatrixHermitian` instance using `call_graph` method and `show_call_graph` function.  It sets `max_depth=1` and uses `ignore_split_join` as a generalizer. It then shows the call graph and the counts sigma using `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix_hermitian.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsparse_matrix_symb_hermitian_block_encoding_g, sparse_matrix_symb_hermitian_block_encoding_sigma = sparse_matrix_symb_hermitian_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sparse_matrix_symb_hermitian_block_encoding_g)\nshow_counts_sigma(sparse_matrix_symb_hermitian_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of Symbolic GuidingState (c*k)\nDESCRIPTION: This snippet generates and displays the call graph for the symbolic `GuidingState` instance with \\( \\ell = c*k \\). It uses `call_graph` method with `ignore_split_join` generalizer for resource counting and visualizes the call graph and resource counts using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nguiding_state_symb_c_g, guiding_state_symb_c_sigma = guiding_state_symb_c.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(guiding_state_symb_c_g)\nshow_counts_sigma(guiding_state_symb_c_sigma)\n```\n\n----------------------------------------\n\nTITLE: Validating a Bloq Decomposition - Python\nDESCRIPTION: Shows how to use a suite of assertion helpers from `qualtran.testing` to validate the structural integrity of a `CompositeBloq`. Checks include register matching, soquet ownership, and connection compatibility, ensuring the bloq adheres to Qualtran's invariants.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.testing import (\n    assert_registers_match_parent,\n    assert_registers_match_dangling,\n    assert_soquets_belong_to_registers,\n    assert_soquets_used_exactly_once,\n    assert_connections_compatible\n)\n\nbloq = TestTwoCNOT()\nassert_registers_match_parent(bloq)\n\ncbloq = bloq.decompose_bloq()\nassert_registers_match_dangling(cbloq)\nassert_soquets_belong_to_registers(cbloq)\nassert_soquets_used_exactly_once(cbloq)\nassert_connections_compatible(cbloq)\n```\n\n----------------------------------------\n\nTITLE: Initializing SelectSwapQROM with Symbolic Dimensions (1D, Clean Ancilla)\nDESCRIPTION: This snippet shows how to initialize a `SelectSwapQROM` with 1D symbolic dimensions, forcing clean ancilla use. It defines symbols N, b, k, and c, then creates `qroam_symb_clean_1d` using `build_from_bitsize` and sets `use_dirty_ancilla=False`. This shows how ancilla usage impacts QROM creation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nN, b, k, c = sympy.symbols('N b k c', positive=True, integers=True)\nqroam_symb_clean_1d = SelectSwapQROM.build_from_bitsize(\n    (N,), (b,), log_block_sizes=(k,), num_controls=c, use_dirty_ancilla=False\n)\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: Imports necessary modules from the `qualtran` library, including Bloq, CompositeBloq, Signature, Register, QBit, QInt, QUInt, and QAny. It also imports modules for drawing and visualization, as well as standard Python libraries like `numpy`, `sympy`, and `cirq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: ChebyshevPolynomial Example Instance (Even Order)\nDESCRIPTION: This code creates an instance of `ChebyshevPolynomial` with an even order (4). It uses a `LinearCombination` of `Unitary` operations (XGate and Hadamard) as the block encoding of the input Hermitian matrix. The `lambd_bits` parameter is set to 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard, XGate\nfrom qualtran.bloqs.block_encoding import LinearCombination, Unitary\n\nbloq = LinearCombination((Unitary(XGate()), Unitary(Hadamard())), (0.5, 0.5), lambd_bits=1)\nchebyshev_poly_even = ChebyshevPolynomial(bloq, order=4)\n```\n\n----------------------------------------\n\nTITLE: LCUBlockEncoding with BlackBoxSelect/Prepare\nDESCRIPTION: This snippet constructs an example of `LCUBlockEncoding` using `BlackBoxSelect` and `BlackBoxPrepare` wrappers.  This provides a 'black box' interface to the underlying `SelectHubbard` and `PrepareHubbard` bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import PrepareHubbard, SelectHubbard\nfrom qualtran.bloqs.multiplexers.black_box_select import BlackBoxSelect\nfrom qualtran.bloqs.state_preparation.black_box_prepare import BlackBoxPrepare\n\n# 3x3 hubbard model U/t = 4\ndim = 3\nselect = SelectHubbard(x_dim=dim, y_dim=dim)\nU = 4\nt = 1\nprepare = PrepareHubbard(x_dim=dim, y_dim=dim, t=t, u=U)\nblack_box_lcu_block = LCUBlockEncoding(\n    select=BlackBoxSelect(select), prepare=BlackBoxPrepare(prepare)\n)\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Qualtran and Cirq\nDESCRIPTION: Imports necessary modules from the Qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, Register, QBit, QInt, QUInt, QAny, along with drawing utilities (show_bloq, show_call_graph, show_counts_sigma).  Also imports typing, numpy, sympy, and cirq for general use.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/global_phase.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Sign Extend Fixed Point Example Instance\nDESCRIPTION: Creates an instance of `SignExtend` to extend an 8-bit fixed-point number (`QFxp(8, 4, signed=True)`) to a 16-bit fixed-point number (`QFxp(16, 4, signed=True)`). This demonstrates how to use the `SignExtend` class with fixed-point data types.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QFxp\n\nsign_extend_fxp = SignExtend(QFxp(8, 4, signed=True), QFxp(16, 4, signed=True))\n```\n\n----------------------------------------\n\nTITLE: Analyze SelectFirstQuantization call graph\nDESCRIPTION: This snippet generates and visualizes the call graph and sigma counts for the `sel_first_quant` bloq, up to a maximum depth of 1. The `ignore_split_join` generalizer is used to simplify the call graph.  The resulting graph and counts provide insight into the resources used by the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsel_first_quant_g, sel_first_quant_sigma = sel_first_quant.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sel_first_quant_g)\nshow_counts_sigma(sel_first_quant_sigma)\n```\n\n----------------------------------------\n\nTITLE: CRz Graphical Signature\nDESCRIPTION: Generates and displays a graphical representation of the `CRz` bloq. This visualization aids in understanding the gate's structure, including the control and target qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([crz],\n           ['`crz`'])\n```\n\n----------------------------------------\n\nTITLE: IsingZZUnitary Example Instance\nDESCRIPTION: Creates an instance of the `IsingZZUnitary` bloq with specified parameters, including the number of sites (`nsites`), the coupling constant (`j_zz`), and the time step (`dt`). This demonstrates how to create and configure an `IsingZZUnitary` object.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnsites = 3\nj_zz = 2\ndt = 0.01\nising_zz = IsingZZUnitary(nsites=nsites, angle=2 * dt * j_zz)\n```\n\n----------------------------------------\n\nTITLE: GF2Square Instance Creation\nDESCRIPTION: This code snippet creates an instance of the `GF2Square` class with a `bitsize` of 4, effectively implementing squaring for elements in GF(2^4). This creates a `gf16_square` object which can be used in quantum circuit constructions within Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_square.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngf16_square = GF2Square(4)\n```\n\n----------------------------------------\n\nTITLE: Mypy Dependency Configuration\nDESCRIPTION: This snippet configures the dependencies for the mypy static type checker within the Qualtran project. It specifies the required version of mypy and pins sympy to a specific version range to mitigate known mypy-related issues with newer sympy versions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/requirements/deps/mypy.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nmypy~=1.9\nmypy-protobuf\n\n# Newer sympy versions cause many [operator] mypy errors\n# including ones seemingly unrelated to sympy\n# https://github.com/quantumlib/Qualtran/pull/1167\nsympy<1.13\n```\n\n----------------------------------------\n\nTITLE: Import KineticEnergy\nDESCRIPTION: This snippet imports the `KineticEnergy` class from the `qualtran.bloqs.chemistry.trotter.grid_ham` module. This class implements the kinetic energy unitary.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.grid_ham import KineticEnergy\n```\n\n----------------------------------------\n\nTITLE: Create CModAdd instance with symbolic parameters in Python\nDESCRIPTION: Creates an instance of the `CModAdd` class with symbolic parameters `n` and `p` for the data type size and modulus, respectively. The data type is specified using `QUInt(n)`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\ncmodadd_symbolic = CModAdd(QUInt(n), p)\n```\n\n----------------------------------------\n\nTITLE: GF2PolyAddK Example Instance\nDESCRIPTION: This snippet creates an instance of `GF2PolyAddK` with concrete polynomial values. It defines a `QGFPoly` object, a `galois.Poly` object representing the constant polynomial, and then instantiates `GF2PolyAddK` with these objects. This performs an in-place addition of a classical constant polynomial $g(x)$ to a quantum register $|f(x)\\rangle$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add_k.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom galois import Poly\n\nfrom qualtran import QGF, QGFPoly\n\nqgf_poly = QGFPoly(4, QGF(2, 3))\ng_x = Poly(qgf_poly.qgf.gf_type([1, 2, 3, 4, 5]))\ngf2_poly_4_8_add_k = GF2PolyAddK(qgf_poly, g_x)\n```\n\n----------------------------------------\n\nTITLE: Free Bloq Definition\nDESCRIPTION: Defines the `Free` bloq, which de-allocates a register. It assumes the register is in the zero state before being freed, and can optionally represent the adjoint of a borrowing operation with potentially dirty qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import Free\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran modules\nDESCRIPTION: Imports necessary modules from the Qualtran library and other standard libraries like NumPy, SymPy, and Cirq. These modules provide classes and functions for defining and manipulating quantum circuits, data structures for representing quantum registers, and tools for visualizing quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: GF2MulK Instance from Galois Field\nDESCRIPTION: Creates an instance of the `GF2MulK` bloq using the `galois` library to define a Galois field and a constant. It multiplies the input by the constant 5 (x^2 + 1) modulo the irreducible polynomial x^3 + x + 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport galois\n\nfrom qualtran import QGF\n\nmx = galois.Poly.Degrees([0, 1, 3])  # x^3 + x + 1\ngf = galois.GF(2, 3, irreducible_poly=mx)\nconst = 5  # x^2 + 1\ngf2_multiply_by_constant = GF2MulK(QGF(2, 3, mx), const)\n```\n\n----------------------------------------\n\nTITLE: Call Graph for LCUBlockEncoding\nDESCRIPTION: This snippet generates the call graph for the `lcu_block` with a maximum depth of 1, ignoring split/join operations using the `ignore_split_join` generalizer. The resulting call graph and counts sigma are then displayed using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlcu_block_g, lcu_block_sigma = lcu_block.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lcu_block_g)\nshow_counts_sigma(lcu_block_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show Decomposed BlackBoxBloq\nDESCRIPTION: Displays the decomposition of the `BlackBoxBloq`, illustrating how the `Partition` bloq is used to split the \"system\" register into the quantum interface expected by the sub-bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# The `Partition` bloq partitions the one \"system\" register into the quantum interface\n# expected by the subbloq (and back again).\nshow_bloq(BlackBoxBloq(subbloq).decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: LCU Block Encoding with SelectTHC and PrepareTHC in Qualtran\nDESCRIPTION: This snippet constructs an `LCUBlockEncoding` using the previously defined `sel_thc` (SelectTHC) and `prep_thc` (PrepareTHC) objects. It initializes the block encoding with an arbitrary epsilon value (1e-4) and sets up the block encoding for resource estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import LCUBlockEncoding\nepsilon = 1e-4  # choosing this arbitrarily at this point. See: https://github.com/quantumlib/Qualtran/issues/985\nblock_encoding_bloq = LCUBlockEncoding(\n    select=sel_thc, prepare=prep_thc\n)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and Related Libraries\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, Register, QBit, QInt, QUInt, and QAny, along with typing, numpy, sympy, and cirq for numerical and symbolic computation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_addition.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Define addition by a constant gate with AddK\nDESCRIPTION: Defines a gate `AddK` that adds a classical integer `k` to a quantum register `x`, taking |x> to |x + k>. This is achieved by XORing the constant and performing quantum-quantum addition. This method has a low T-count but requires $n$ auxiliary qubits. The gate also supports a controlled version.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import AddK\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Qualtran\nDESCRIPTION: This code imports necessary modules from the `qualtran` library, along with standard Python libraries such as `typing`, `numpy`, `sympy`, and `cirq`. These imports provide the building blocks for defining and manipulating quantum circuits and operations within the Qualtran framework.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Classical Call of `ECAddR`\nDESCRIPTION: Demonstrates calling the `ECAddR` bloq classically for a range of multiples of point P.  It iterates from 1 to 20, calculating `j*P` and then calling `bloq.call_classically` with `ctrl=1`, `x=P.x`, and `y=P.y`. The results are then printed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfor j in range(1, 20+1):\n    bloq = ECAddR(n=5, R=j*P)\n    ctrl, x, y = bloq.call_classically(ctrl=1, x=P.x, y=P.y)\n    print(f'+[{j:2d}] P  ->  ({x:2d}, {y:2d})')\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for ScaledChebyshevPolynomial (Even)\nDESCRIPTION: This snippet generates and displays the call graph and sigma counts for the `scaled_chebyshev_poly_even` instance. It uses `ignore_split_join` as a generalizer to simplify the graph. The call graph shows the dependencies between different bloqs within the scaled Chebyshev polynomial block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nscaled_chebyshev_poly_even_g, scaled_chebyshev_poly_even_sigma = scaled_chebyshev_poly_even.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(scaled_chebyshev_poly_even_g)\nshow_counts_sigma(scaled_chebyshev_poly_even_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of SingleFactorizationOneBody\nDESCRIPTION: This code snippet generates and displays the call graph of the `sf_one_body` bloq. It uses the `call_graph` method with a `max_depth` of 1 and the `ignore_split_join` generalizer.  The resulting graph and sigma counts are then displayed using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsf_one_body_g, sf_one_body_sigma = sf_one_body.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sf_one_body_g)\nshow_counts_sigma(sf_one_body_sigma)\n```\n\n----------------------------------------\n\nTITLE: Git Clean Generated Outputs (Local Preview)\nDESCRIPTION: This snippet uses `git clean` to remove all the generated output files from the documentation directory. The `-n` option is for a dry run, while `-f` actually performs the deletion. The `-dX` options remove untracked files and directories, including those ignored by `.gitignore`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/how-to-build-the-docs.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd docs/\ngit clean -ndX  # delete all generated outputs: change -n to -f to actually do it.\n```\n\n----------------------------------------\n\nTITLE: GlobalPhase Gate Definition\nDESCRIPTION: Defines the `GlobalPhase` class which applies a global phase to the circuit as a whole. It takes an `exponent` parameter, `t`, such that the unitary effect is to multiply the state vector by (-1)^t.  The global phase does not affect any observable quantity, but keeping track of it can be useful for testing circuit identities.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/global_phase.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import GlobalPhase\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloq Report Card for Other Packages\nDESCRIPTION: This snippet displays the Bloq report card for packages that are not `basic_gates`, `arithmetic`, or `factoring`, and also not starting with `qualtran.bloqs.chemistry`. It chains two `query` calls to filter the report card data. The filtered report card is then passed to `show_bloq_report_card()` for display.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq_report_card(report_card.query('package not in '\n                                        '[\"basic_gates\",'\n                                        ' \"arithmetic\", '\n                                        ' \"factoring\"]')\n                                 .query('not package.str.startswith(\"qualtran.bloqs.chemistry\")'))\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Ising Trotter Bloqs\nDESCRIPTION: Imports necessary libraries and modules from qualtran, typing, numpy, sympy and cirq used in the Ising Trotter Bloqs implementation. These include core Qualtran classes, type hints, numerical computation, symbolic math, and quantum circuit operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Example Instance of LCUBlockEncoding\nDESCRIPTION: This snippet creates an example instance of `LCUBlockEncoding` using `PrepareHubbard` and `SelectHubbard` for a 3x3 Hubbard model with specified parameters U and t. The resulting `lcu_block` object represents the LCU-based block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import PrepareHubbard, SelectHubbard\n\n# 3x3 hubbard model U/t = 4\ndim = 3\nselect = SelectHubbard(x_dim=dim, y_dim=dim)\nU = 4\nt = 1\nprepare = PrepareHubbard(x_dim=dim, y_dim=dim, t=t, u=U)\nlcu_block = LCUBlockEncoding(select=select, prepare=prepare)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for Chebyshev Polynomial\nDESCRIPTION: This snippet imports necessary modules from the qualtran library and other common libraries like typing, numpy, sympy, and cirq. These modules provide the building blocks for defining and manipulating quantum circuits and data structures within Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Generating Call Graph for QubitizationQPE\nDESCRIPTION: This snippet generates and displays the call graph for `qubitization_qpe_hubbard_model_small`. It uses `call_graph` method with `ignore_split_join` generalizer and then calls `show_call_graph` and `show_counts_sigma` functions to visualize the call graph and counts sigma, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nqubitization_qpe_hubbard_model_small_g, qubitization_qpe_hubbard_model_small_sigma = qubitization_qpe_hubbard_model_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(qubitization_qpe_hubbard_model_small_g)\nshow_counts_sigma(qubitization_qpe_hubbard_model_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Drawing Musical Score of a ModExp Bloq in Qualtran\nDESCRIPTION: This snippet demonstrates how to create a `ModExp` bloq, decompose it, and then draw its musical score representation using Qualtran's drawing utilities.  It imports `ModExp` for modular exponentiation and `get_musical_score_data` and `draw_musical_score` for visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/ui-export.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.factoring.rsa import ModExp\nfrom qualtran.drawing import get_musical_score_data, draw_musical_score\n\nmodexp_small = ModExp(base=3, mod=16, exp_bitsize=3, x_bitsize=2048)\nms = get_musical_score_data(modexp_small.decompose_bloq())\n\ndraw_musical_score(ms)\n```\n\n----------------------------------------\n\nTITLE: Instantiating the Gate\nDESCRIPTION: This snippet instantiates the `MyGate` class and prints the gate object. This demonstrates the creation of an instance of the custom quantum gate defined previously.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngate = MyGate()\ngate\n```\n\n----------------------------------------\n\nTITLE: Import QuantumVariableRotation\nDESCRIPTION: This snippet imports the `QuantumVariableRotation` class from the `qualtran.bloqs.chemistry.trotter.grid_ham.qvr` module. This class implements Quantum Variable Rotation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.grid_ham.qvr import QuantumVariableRotation\n```\n\n----------------------------------------\n\nTITLE: CModSub Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma of the `CModSub` bloq. It utilizes `ignore_split_join` to simplify the graph for resource estimation of controlled modular subtraction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncmodsub_symb_g, cmodsub_symb_sigma = cmodsub_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cmodsub_symb_g)\nshow_counts_sigma(cmodsub_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counts for SelectSparse\nDESCRIPTION: This code generates and displays the call graph and resource counts for the `sel_sparse` bloq. It simplifies the graph using the `ignore_split_join` generalizer and then displays the graph and sigma counts using `show_call_graph` and `show_counts_sigma`, respectively. This analysis provides insights into the bloq's complexity and resource requirements.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsel_sparse_g, sel_sparse_sigma = sel_sparse.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sel_sparse_g)\nshow_counts_sigma(sel_sparse_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: This snippet imports necessary modules and classes from `qualtran` and other libraries like `numpy`, `sympy`, and `cirq`. These imports enable the use of Qualtran's features for quantum algorithm design, circuit representation, and resource estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/unitary.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Evolve Unitary Properties\nDESCRIPTION: This snippet uses the `evolve` function from the `attrs` library to create a new instance of the `Unitary` class with modified properties. It shows how to change parameters such as `alpha`, `ancilla_bitsize`, `resource_bitsize`, and `epsilon` to customize the block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/unitary.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom attrs import evolve\n\nfrom qualtran.bloqs.basic_gates import TGate\n\nunitary_block_encoding_properties = evolve(\n    Unitary(TGate()), alpha=0.5, ancilla_bitsize=2, resource_bitsize=1, epsilon=0.01\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing SelectSwapQROM with Numerical Data (1D)\nDESCRIPTION: This snippet demonstrates how to initialize a `SelectSwapQROM` instance using two 1D numpy arrays. It creates two arrays, `data1` and `data2`, and then uses the `build_from_data` method to construct the `qroam_multi_data` object. This creates a QROM using pre-existing data for lookup.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndata1 = np.arange(5)\ndata2 = np.arange(5) + 1\nqroam_multi_data = SelectSwapQROM.build_from_data(data1, data2)\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Qualtran Rz Rotation\nDESCRIPTION: This code snippet imports necessary modules from the `qualtran` library and other standard libraries such as `numpy`, `sympy`, and `cirq`. These modules are used to define and manipulate quantum circuits and data types.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/rz_via_phase_gradient.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Elliptic Curve Windowed Addition by Constant R (Qualtran)\nDESCRIPTION: Defines the `ECWindowAddR` bloq, which performs elliptic curve addition of multiple powers of a constant point $R$, effectively adding R, 2R, ..., 2^window_size R. It uses a window of control bits to select which multiples of R to add.  The x and y coordinates of the input point are assumed to be in Montgomery form.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.cryptography.ecc import ECWindowAddR\n```\n\n----------------------------------------\n\nTITLE: Importing Qualtran and other libraries\nDESCRIPTION: This code snippet imports necessary modules from the `qualtran` library and other supporting libraries like `numpy`, `sympy`, and `cirq`. These modules provide the fundamental building blocks and functionalities required to define and manipulate quantum circuits and data structures.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for NewtonRaphsonApproxInverseSquareRoot\nDESCRIPTION: This snippet generates and displays the call graph for the `NewtonRaphsonApproxInverseSquareRoot` bloq, up to a depth of 1. It uses `ignore_split_join` as a generalizer and visualizes the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nnr_inv_sqrt_g, nr_inv_sqrt_sigma = nr_inv_sqrt.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(nr_inv_sqrt_g)\nshow_counts_sigma(nr_inv_sqrt_sigma)\n```\n\n----------------------------------------\n\nTITLE: Using @bloq_example decorator for ModExp Bloq (Python)\nDESCRIPTION: These code snippets demonstrate the use of the `@bloq_example` decorator to define example instantiations of the `ModExp` Bloq for automatic testing and documentation. The examples cover different initialization scenarios, including small values, Shor's algorithm, and symbolic representations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Autodoc.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@bloq_example\ndef _modexp_small() -> ModExp:\n    modexp_small = ModExp(base=3, mod=15, exp_bitsize=3, x_bitsize=2048)\n    return modexp_small\n```\n\nLANGUAGE: python\nCODE:\n```\n@bloq_example\ndef _modexp() -> ModExp:\n    modexp = ModExp.make_for_shor(big_n=15 * 17, g=9)\n    return modexp\n```\n\nLANGUAGE: python\nCODE:\n```\n@bloq_example\ndef _modexp_symb() -> ModExp:\n    g, N, n_e, n_x = sympy.symbols('g N n_e, n_x')\n    modexp_symb = ModExp(base=g, mod=N, exp_bitsize=n_e, x_bitsize=n_x)\n    return modexp_symb\n```\n\n----------------------------------------\n\nTITLE: Instantiate PrepareHubbard and BlackBoxPrepare in Python\nDESCRIPTION: This snippet demonstrates how to instantiate the `PrepareHubbard` class with specific parameters and then wrap it within a `BlackBoxPrepare` instance. The `PrepareHubbard` class represents the prepare state for the Hubbard model, while the `BlackBoxPrepare` encapsulates this preparation step as a black box.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import PrepareHubbard\n\nprepare = PrepareHubbard(2, 2, 1, 4)\nblack_box_prepare = BlackBoxPrepare(prepare=prepare)\n```\n\n----------------------------------------\n\nTITLE: Show Call Graph and Counts Sigma of RealGivensRotationByPhaseGradient\nDESCRIPTION: Generates and displays the call graph and counts sigma for the `real_givens` bloq using the `call_graph` method and `show_call_graph`, `show_counts_sigma` functions respectively. The `ignore_split_join` generalizer simplifies the call graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nreal_givens_g, real_givens_sigma = real_givens.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(real_givens_g)\nshow_counts_sigma(real_givens_sigma)\n```\n\n----------------------------------------\n\nTITLE: Classical period finding of modular exponentiation in Python\nDESCRIPTION: This snippet demonstrates period finding of modular exponentiation using a classical `for` loop. It calculates `(g ** e) % N` for different exponent values `e` and prints the result. The '*' indicates when the result equals 1, which helps identify the period.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor e in range(20):\n    f = (g ** e) % N\n    \n    star = ' *' if f == 1 else ''\n    print(f'{e:5d} {f:5d}{star}')\n```\n\n----------------------------------------\n\nTITLE: Display: Showing References for a Bloq Class\nDESCRIPTION: This function `show_references` takes a bloq class and its associated references as input. It formats the references into a Markdown string and displays them using `IPython.display.Markdown`. The function handles the case where no references are found for a class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom IPython.display import Markdown\n\ndef show_references(bloq_cls, refs):\n    if not refs:\n        return\n    \n    text = f'### {bloq_cls.__name__}\\n'\n    for ref in refs:\n        text += f' - {ref.text}\\n'\n    \n    display(Markdown(text))\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph for ModAddK\nDESCRIPTION: Generates and displays the call graph and resource counts sigma for `mod_add_k` using `call_graph` with `ignore_split_join` to simplify the graph. It uses `show_call_graph` and `show_counts_sigma` to display the generated graph and resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmod_add_k_g, mod_add_k_sigma = mod_add_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(mod_add_k_g)\nshow_counts_sigma(mod_add_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display SignExtend Bloq\nDESCRIPTION: Displays the graphical representation of the `sign_extend` Bloq using the `show_bloqs` function. This visual representation helps understand the quantum circuit implemented by `SignExtend`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sign_extend],\n           ['`sign_extend`'])\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasing Call Graph\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `HammingWeightPhasing` bloq, ignoring split and join operations. This helps visualize the bloq's dependencies and resource usage.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nhamming_weight_phasing_g, hamming_weight_phasing_sigma = hamming_weight_phasing.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(hamming_weight_phasing_g)\nshow_counts_sigma(hamming_weight_phasing_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show Reflection Bloqs Graphically\nDESCRIPTION: Visualizes the `refl_using_prep` and `refl_around_zero` bloqs using the `show_bloqs` function from the `qualtran.drawing` module. This helps in understanding the structure and connections of the quantum operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([refl_using_prep, refl_around_zero],\n           ['`refl_using_prep`', '`refl_around_zero`'])\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientUnitary Definition\nDESCRIPTION: Defines the `PhaseGradientUnitary` Bloq, which implements a (controlled-)PhaseGradient unitary gate on an n-bit register. The implementation decomposes into n (controlled-) rotations, one on each qubit, with an exponent parameter to control the phase.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations.phase_gradient import PhaseGradientUnitary\n```\n\n----------------------------------------\n\nTITLE: Import IntState Bloq\nDESCRIPTION: Imports the `IntState` class from the `qualtran.bloqs.basic_gates` module. `IntState` represents the |val> quantum state for a non-negative integer val.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import IntState\n```\n\n----------------------------------------\n\nTITLE: Estimating Toffoli Count for Block Encoding Bloq in Qualtran\nDESCRIPTION: This code calculates the Toffoli count for the previously constructed `block_encoding_bloq` using Qualtran's resource counting tools. It defines a function `get_toffoli_counts` that utilizes `get_cost_value` with `QECGatesCost` and `generalize_cswap_approx` to estimate the number of Toffoli gates required for the block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq\nfrom qualtran.symbolics import SymbolicInt\nfrom qualtran.bloqs import block_encoding\nfrom qualtran.resource_counting import get_bloq_call_graph\nimport attrs\nfrom qualtran.bloqs.bookkeeping import Partition, Split, Join, Allocate, Free\nfrom qualtran.bloqs.basic_gates import CSwap, TGate\nfrom qualtran.drawing import show_call_graph\nfrom qualtran.resource_counting import QECGatesCost, get_cost_value\nfrom qualtran.resource_counting.generalizers import generalize_cswap_approx\n\ndef get_toffoli_counts(bloq: Bloq) -> SymbolicInt:\n    return get_cost_value(bloq, QECGatesCost(), generalizer=generalize_cswap_approx).total_t_and_ccz_count(ts_per_rotation=0)['n_ccz']\n\nnum_toff = get_toffoli_counts(block_encoding_bloq)\nprint(num_toff)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures of CAdd Instances\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signatures of the `cadd_small` and `cadd_large` instances, providing a visual representation of the gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_addition.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cadd_small, cadd_large],\n           ['`cadd_small`', '`cadd_large`'])\n```\n\n----------------------------------------\n\nTITLE: Importing Qualtran and Other Libraries\nDESCRIPTION: This snippet imports necessary modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `Signature`, `Register`, and quantum data types. It also imports standard Python libraries like `typing`, `numpy`, `sympy`, and `cirq` for numerical and symbolic computations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Resource Estimates for 2D Hubbard Model\nDESCRIPTION: This snippet estimates resources for the 2D Hubbard model, using SELECT and PREPARE circuits as described in the cited paper. It defines parameters for the Hubbard model, calculates the required bits of accuracy for phase estimation, and then constructs and analyzes the resulting quantum circuit using Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nx_dim, y_dim = 20, 20\nt = 20\nmu = 4 * t\nN = x_dim * y_dim * 2\nqlambda = 2 * N * t + (N * mu) // 2\ndelta_E = t / 100\nm_bits = int(np.ceil(np.log2(qlambda * np.pi * np.sqrt(2) / delta_E)))\nwalk = get_walk_operator_for_hubbard_model(x_dim, y_dim, t, mu)\ncircuit = cirq.Circuit(phase_estimation(walk, m=m_bits))\n%time result = get_qec_gates_cost_for_circuit(circuit)\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Instantiate ZGate\nDESCRIPTION: This code instantiates the `ZGate` class, creating an object `zgate` representing the Z gate. This object can then be used within a quantum circuit definition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nzgate = ZGate()\n```\n\n----------------------------------------\n\nTITLE: Show AutoPartition Bloqs Graphically\nDESCRIPTION: Uses the `show_bloqs` function to display the graphical signatures of the `auto_partition` and `auto_partition_unused` bloqs, providing a visual representation of their structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([auto_partition, auto_partition_unused],\n           ['`auto_partition`', '`auto_partition_unused`'])\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: Imports necessary libraries from Qualtran, including modules for defining quantum bloqs, registers, signatures, and data types. It also imports standard Python libraries for typing, numerical computation, symbolic math, and quantum circuit simulation using Cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: Import necessary modules from qualtran, typing, numpy, sympy, and cirq. These modules provide functionalities for defining quantum building blocks, creating composite bloqs, managing registers, defining data types, symbolic computation, and quantum circuit simulation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_addition.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: IsingZZUnitary Call Graph\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `ising_zz` bloq. The call graph visualizes the bloq's internal structure and resource requirements, while sigma counts provide further details on resource consumption. The `ignore_split_join` generalizer simplifies the call graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nising_zz_g, ising_zz_sigma = ising_zz.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ising_zz_g)\nshow_counts_sigma(ising_zz_sigma)\n```\n\n----------------------------------------\n\nTITLE: Flame Graph Visualization for 2D Hubbard Model\nDESCRIPTION: This snippet shows how to visualize the cost of phase estimation on a qubitized walk operator for the 2D Hubbard model using flame graphs provided by Qualtran. It first computes the T-complexity and then generates the flame graph visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation.qubitization_qpe import _qubitization_qpe_hubbard_model_small\nfrom qualtran.drawing import show_flame_graph\n\nqpe_small = _qubitization_qpe_hubbard_model_small.make()\nprint(qpe_small.t_complexity())\nshow_flame_graph(qpe_small)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and related libraries\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library for defining quantum circuits and data structures. It also imports standard Python libraries such as typing, numpy, sympy, and cirq for general programming and quantum computation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Creating Operation with on_registers\nDESCRIPTION: This snippet creates a `cirq.Operation` from the `gate` instance using the `on_registers` method, passing in the named qubits obtained in the previous snippet. `on_registers` is an extension of Cirq's `on` method that allows specifying the qubits to operate on by register name, increasing clarity and reducing errors.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\noperation = gate.on_registers(**quregs)\noperation\n```\n\n----------------------------------------\n\nTITLE: Classically simulating ModExp and its decomposition in Python\nDESCRIPTION: This snippet performs a classical simulation of the `ModExp` bloq and its decomposition for various exponent values. It compares the results of the original bloq and its decomposition to verify their correctness.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QUInt\nfor e in range(20):\n    ref = (g ** e) % N\n    _, bloq_eval = mod_exp.call_classically(exponent=e)\n    _, decomp_eval = mod_exp_decomp.call_classically(exponent=e)\n    \n    star = ' *' if ref == 1 else ''\n    print(f'{e:5d} {ref:5d} {bloq_eval:5d} {decomp_eval:5d} {star}')\n```\n\n----------------------------------------\n\nTITLE: Import statements\nDESCRIPTION: Imports necessary modules and classes from Qualtran, typing, NumPy, SymPy, and Cirq. This includes core Qualtran components like Bloq, CompositeBloq, Signature, Register, QBit, QInt, QUInt, QAny, and drawing utilities.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Define in-place quantum addition gate with Add\nDESCRIPTION: Defines an n-bit in-place addition gate `Add` using the Qualtran library. This gate implements the transformation |a>|b> -> |a>|a+b> with a resource cost of 4n - 4 T gates. The `a_dtype` and `b_dtype` parameters define the data types of the input registers, and the `b_dtype` must be large enough to hold the result.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Add\n```\n\n----------------------------------------\n\nTITLE: Symmetric Banded SparseMatrix Example\nDESCRIPTION: Demonstrates `SparseMatrix` construction using `SymmetricBandedRowColumnOracle` suitable for symmetric banded matrices. This example configures oracles for a matrix of size 3 with a band size of 1, alongside a `UniformEntryOracle` for entry values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding.sparse_matrix import SymmetricBandedRowColumnOracle\n\nrow_oracle = SymmetricBandedRowColumnOracle(3, bandsize=1)\ncol_oracle = SymmetricBandedRowColumnOracle(3, bandsize=1)\nentry_oracle = UniformEntryOracle(3, entry=0.3)\nsymmetric_banded_matrix_block_encoding = SparseMatrix(\n    row_oracle, col_oracle, entry_oracle, eps=0\n)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and related modules\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library and standard Python libraries. It includes modules for defining bloqs, composite bloqs, signatures, registers, quantum bits and integers, drawing, typing, numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Phase Block Encoding Example\nDESCRIPTION: Creates an instance of the `Phase` block encoding. It takes a `Unitary` block encoding (in this case, based on a Hadamard gate) and a phase angle as input. The `eps` parameter controls the precision of the phase angle.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/phase.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\nphase_block_encoding = Phase(Unitary(Hadamard()), phi=0.25, eps=0)\n```\n\n----------------------------------------\n\nTITLE: Show Call Graph of LPRSInterimPrep\nDESCRIPTION: This code snippet generates and displays the call graph of the `lprs_interim_prep` Bloq using `lprs_interim_prep.call_graph` and `show_call_graph`.  The `ignore_split_join` generalizer is used. `show_counts_sigma` displays the sigma counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlprs_interim_prep_g, lprs_interim_prep_sigma = lprs_interim_prep.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lprs_interim_prep_g)\nshow_counts_sigma(lprs_interim_prep_sigma)\n```\n\n----------------------------------------\n\nTITLE: UniformSuperpositionTHC Call Graph\nDESCRIPTION: Generates and displays the call graph for the `UniformSuperpositionTHC` bloq using `thc_uni.call_graph`. This helps visualize the internal structure and dependencies of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nthc_uni_g, thc_uni_sigma = thc_uni.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(thc_uni_g)\nshow_counts_sigma(thc_uni_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signature of DoubleFactorizationBlockEncoding\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `df_block_encoding` bloq created in the previous example. The signature visualizes the inputs, outputs, and internal structure of the bloq, providing a high-level representation of its functionality.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([df_block_encoding],\n           ['`df_block_encoding`'])\n```\n\n----------------------------------------\n\nTITLE: Defining CtrlSpec with multiple QBit registers\nDESCRIPTION: This code shows how to define a `CtrlSpec` with multiple `QBit` registers. The controlled bloq is active when the first register has values `[0, 1]` and the second register has values `[1, 0]`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nctrl_spec = CtrlSpec(qdtypes=[QBit(), QBit()], cvs=[[0, 1], [1, 0]])\nassert ctrl_spec.is_active([0, 1], [1, 0])\ncx = x.controlled(ctrl_spec=ctrl_spec)\nshow_bloq(cx, type='musical_score')\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph of PrepareUVFirstQuantization in Python\nDESCRIPTION: Generates and displays the call graph and resource counts for the `prepare_uv` bloq. It utilizes `ignore_split_join` as a generalizer and sets the maximum depth to 1. The resulting call graph and sigma counts are then visualized using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprepare_uv_g, prepare_uv_sigma = prepare_uv.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prepare_uv_g)\nshow_counts_sigma(prepare_uv_sigma)\n```\n\n----------------------------------------\n\nTITLE: TStateMaker Tensor Contraction Comparison in Qualtran\nDESCRIPTION: This snippet calculates the tensor contraction of `TStateMaker` and its adjoint, then verifies that the adjoint's tensor contraction is the conjugate transpose of the original bloq's tensor contraction. Finally, prints \"Check!\" if the assertion passes. Relies on numpy for array comparison.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nunitary = TStateMaker().tensor_contract()\nadj_unitary = TStateMaker().adjoint().tensor_contract()\nnp.testing.assert_allclose(unitary.conj().T, adj_unitary)\nprint(\"Check!\")\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature Visualization\nDESCRIPTION: Displays the graphical representation of the defined `Permutation` instances, including the dense, symbolic, and sparse permutations. This uses `show_bloqs` to create a visual of the bloqs and label them with their variable names.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([permutation, permutation_symb, permutation_symb_with_cycles, sparse_permutation, sparse_permutation_with_symbolic_N],\n           ['`permutation`', '`permutation_symb`', '`permutation_symb_with_cycles`', '`sparse_permutation`', '`sparse_permutation_with_symbolic_N`'])\n```\n\n----------------------------------------\n\nTITLE: GQSP Call Graph and Sigma Counts\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `gqsp` instance. The call graph is limited to a depth of 1, and `ignore_split_join` generalizer is used. The resulting call graph and sigma counts are then displayed using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qsp/generalized_qsp.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngqsp_g, gqsp_sigma = gqsp.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gqsp_g)\nshow_counts_sigma(gqsp_sigma)\n```\n\n----------------------------------------\n\nTITLE: Copying a Composite Bloq - Python\nDESCRIPTION: Demonstrates how to create a copy of a `CompositeBloq` using the `copy()` method. While `CompositeBloq` are immutable, copying is a basis for more complex modification operations. The example also displays the original and copied diagrams.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.for_testing import TestAtom, TestSerialCombo, TestParallelCombo\n\ncbloq = TestParallelCombo().decompose_bloq()\ncbloq2 = cbloq.copy()\n\n# They're the same!\nshow_bloq(cbloq)\nshow_bloq(cbloq2)\n```\n\n----------------------------------------\n\nTITLE: Create and Display Call Graph of ArcSin\nDESCRIPTION: Generates and displays the call graph of the `ArcSin` bloq using `arcsin.call_graph` with a maximum depth of 1 and the `ignore_split_join` generalizer. The call graph visualizes the dependencies and internal structure of the `ArcSin` bloq. Additionally, it shows counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/trigonometric/trigonometric.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\narcsin_g, arcsin_sigma = arcsin.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(arcsin_g)\nshow_counts_sigma(arcsin_sigma)\n```\n\n----------------------------------------\n\nTITLE: SparseMatrix Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `sparse_matrix_block_encoding` instance, using the `ignore_split_join` generalizer. This call graph provides insight into the decomposition of the `SparseMatrix` operation into its sub-operations and their resource requirements.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsparse_matrix_block_encoding_g, sparse_matrix_block_encoding_sigma = sparse_matrix_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sparse_matrix_block_encoding_g)\nshow_counts_sigma(sparse_matrix_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Parsing: Extracting References from Bloq Classes\nDESCRIPTION: This code extracts references from the docstrings of each bloq class. It iterates through the `bloq_classes` list and uses the `get_references` function from `qualtran_dev_tools.parse_docstrings` to retrieve references for each class, storing the results in a dictionary.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran_dev_tools.parse_docstrings import get_references, Reference, UnparsedReference\nreferences = {bloq_cls: get_references(bloq_cls) for bloq_cls in bloq_classes}\n```\n\n----------------------------------------\n\nTITLE: Call Graph of ControlledAddOrSubtract\nDESCRIPTION: Generates and displays the call graph and resource counts sigma for the symbolic instance of `ControlledAddOrSubtract` up to a depth of 1, ignoring split-join operations for simplification. This helps in understanding the dependencies and resource requirements of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_add_or_subtract.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nctrl_add_or_sub_signed_symb_g, ctrl_add_or_sub_signed_symb_sigma = ctrl_add_or_sub_signed_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ctrl_add_or_sub_signed_symb_g)\nshow_counts_sigma(ctrl_add_or_sub_signed_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiate Subtract gate with different register sizes\nDESCRIPTION: Creates an instance of the `Subtract` gate with registers of different sizes (4 and 16 qubits). This highlights the gate's ability to handle inputs of varying sizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsub_diff_size_regs = Subtract(QInt(bitsize=4), QInt(bitsize=16))\n```\n\n----------------------------------------\n\nTITLE: ScaledChebyshevPolynomial Example Instance (Even Order)\nDESCRIPTION: This code creates an instance of `ScaledChebyshevPolynomial` with an even order (4). It uses a `LinearCombination` of `Unitary` operations (XGate and Hadamard) as the block encoding of the input Hermitian matrix. The `lambd_bits` parameter is set to 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard, XGate\nfrom qualtran.bloqs.block_encoding import LinearCombination, Unitary\n\nbloq = LinearCombination((Unitary(XGate()), Unitary(Hadamard())), (1.0, 1.0), lambd_bits=1)\nscaled_chebyshev_poly_even = ScaledChebyshevPolynomial(bloq, order=4)\n```\n\n----------------------------------------\n\nTITLE: Plotting Toffoli counts for PrepareSecondQuantization with QROAM\nDESCRIPTION: This code plots the Toffoli gate count of the `PrepareSecondQuantization` bloq as a function of the number of spin orbitals for different QROAM block sizes.  It iterates over a range of block sizes (1, 2, 8, 32, None) and for each block size, computes the Toffoli count for a range of spin orbital values. Then, plots the results on a log-log scale.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nbasis_vals = np.linspace(50, 200, 10, dtype=int)\nfor ib, block_size in enumerate([1, 2, 8, 32, None]):\n    toff_counts = [toffoli_count(PrepareSecondQuantization(int(n), qroam_block_size=block_size)) for n in basis_vals]\n    if block_size is None:\n        block_size = 'opt'\n    plot_linear_log_log(ax, basis_vals, np.array(toff_counts), label=f'block size = {block_size}: ', color=f'C{ib}')\nax.set_xlabel(\"$N$\")\nax.set_ylabel(\"Tofflis count\")\n```\n\n----------------------------------------\n\nTITLE: Split Example Instance\nDESCRIPTION: Creates an instance of the `Split` bloq, configured to split a register of type `QUInt(4)` into an array of 4 `QBit`s.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nsplit = Split(QUInt(4))\n```\n\n----------------------------------------\n\nTITLE: Classical simulation of And gate\nDESCRIPTION: This code demonstrates how to classically simulate the `And` gate by calling the `call_classically` method with an input control array. The function returns the updated control array and the output bit, allowing for verification of the gate's classical behavior.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nctrl, out = And().call_classically(ctrl=np.array([1, 1]))\nout\n```\n\n----------------------------------------\n\nTITLE: Displaying ECAdd Bloqs Graphically Using Qualtran Drawing Tools\nDESCRIPTION: This code uses `show_bloqs` to display graphical representations of the `ec_add` and `ec_add_small` bloqs.  This allows for visual inspection of the bloq structure. The second argument is a list of strings to be used as labels for the bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ec_add.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ec_add, ec_add_small],\n           ['`ec_add`', '`ec_add_small`'])\n```\n\n----------------------------------------\n\nTITLE: Import RzViaPhaseGradient from qualtran\nDESCRIPTION: This code snippet imports the `RzViaPhaseGradient` class from the `qualtran.bloqs.rotations` module. This class is used to implement the controlled-Rz rotation gate using a phase gradient.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/rz_via_phase_gradient.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import RzViaPhaseGradient\n```\n\n----------------------------------------\n\nTITLE: Display ToContiguousIndex Bloq\nDESCRIPTION: Displays the graphical representation of the `to_contg_index` Bloq using the `show_bloqs` function. This provides a visual representation of the quantum circuit implemented by the `ToContiguousIndex` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([to_contg_index],\n           ['`to_contg_index`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate LPResourceState with a symbolic bitsize\nDESCRIPTION: This code creates an instance of the `LPResourceState` Bloq with a symbolic `bitsize` represented by `sympy.Symbol('n')`. This allows for representing the resource state preparation with a variable number of qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nlp_resource_state_symbolic = LPResourceState(sympy.Symbol('n'))\n```\n\n----------------------------------------\n\nTITLE: Swap instantiation with symbolic bitsize\nDESCRIPTION: Instantiates a `Swap` object with a symbolic bitsize 'n' using `sympy.Symbol`. This creates a generic swap gate that can operate on registers of size 'n'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Swap\n```\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n', positive=True, integer=True)\nswap = Swap(bitsize=n)\n```\n\n----------------------------------------\n\nTITLE: Import RealGivensRotationByPhaseGradient\nDESCRIPTION: Imports the `RealGivensRotationByPhaseGradient` class from the `qualtran.bloqs.chemistry.quad_fermion.givens_bloq` module. This class implements a real-valued Givens rotation using a phase gradient.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.quad_fermion.givens_bloq import RealGivensRotationByPhaseGradient\n```\n\n----------------------------------------\n\nTITLE: Import ZGate from qualtran.bloqs.basic_gates\nDESCRIPTION: This snippet imports the `ZGate` class from the `qualtran.bloqs.basic_gates` module. The `ZGate` represents the Z quantum gate, which applies a phase flip to the |1> state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import ZGate\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures\nDESCRIPTION: This snippet uses `show_bloqs` to display the graphical signatures of `select_block` and `black_box_select_block`. It provides visual representations of the bloqs and their interfaces.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([select_block, black_box_select_block],\n           ['`select_block`', '`black_box_select_block`'])\n```\n\n----------------------------------------\n\nTITLE: Show graphical representation of SubtractFrom gates\nDESCRIPTION: Generates and displays a graphical representation of the `SubtractFrom` gate instances.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sub_from_symb, sub_from_small, sub_from_large],\n           ['`sub_from_symb`', '`sub_from_small`', '`sub_from_large`'])\n```\n\n----------------------------------------\n\nTITLE: GF2Multiplication Bloq Definition\nDESCRIPTION: Defines the `GF2Multiplication` bloq, which implements out-of-place multiplication over GF($2^m$) using quantum registers.  It is based on upper and lower triangular matrix computations and a reduction matrix that depends on the irreducible polynomial of the Galois field. The `plus_equal_prod` parameter determines whether it performs `result + x * y` or simply `x * y`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2Multiplication\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules\nDESCRIPTION: This snippet imports necessary modules from the qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, Register, and various quantum data types. It also imports modules from typing, numpy, sympy, and cirq for general use.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Annotating Bloqs with T-Complexity data using GraphvizCallGraph (Python)\nDESCRIPTION: This code snippet demonstrates how to annotate each bloq in the call graph with its T-complexity data using the `GraphvizCallGraph` class. It first collects the T-complexity data for each bloq in the call graph, then initializes the `GraphvizCallGraph` with the call graph and the bloq data, and finally calls `get_svg()` to generate and display the annotated call graph as an SVG. This requires that the `call_graph` is already defined.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/drawing/drawing_call_graph.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Collect T-Complexity data\nbloq_data = {}\nfor bloq in call_graph.nodes:\n    tcomp = bloq.t_complexity()\n    record = {\n        'T count': tcomp.t,\n        'clifford': tcomp.clifford,\n        'rot': tcomp.rotations,\n    }\n    bloq_data[bloq] = record\n\n# Draw the call graph with the additional data\nGraphvizCallGraph(call_graph, bloq_data=bloq_data).get_svg()\n```\n\n----------------------------------------\n\nTITLE: Showing Comparator Bloqs\nDESCRIPTION: Displays the graphical signatures of the `comparator` and `comparator_symb` bloqs using the `show_bloqs` function from `qualtran.drawing`. It visualizes the structure and input/output registers of the comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([comparator, comparator_symb],\n           ['`comparator`', '`comparator_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate Subtract gate with small size\nDESCRIPTION: Creates an instance of the `Subtract` gate with a fixed size of 4 qubits. This provides a concrete example of the gate's usage.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsub_small = Subtract(QInt(bitsize=4))\n```\n\n----------------------------------------\n\nTITLE: Example: Get Walk Operator for 1D Ising Model\nDESCRIPTION: This snippet demonstrates how to obtain a walk operator for a 1D Ising model using the `get_walk_operator_for_1d_ising_model` function from `qualtran.bloqs.chemistry.ising.walk_operator`. It showcases a simple instantiation of the walk operator for a system with 4 qubits and an interaction strength of 0.2.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.ising.walk_operator import get_walk_operator_for_1d_ising_model\n\nwalk_op, _ = get_walk_operator_for_1d_ising_model(4, 2e-1)\n```\n\n----------------------------------------\n\nTITLE: HasDuplicates Graphical Signatures\nDESCRIPTION: Generates and displays graphical signatures of both the symbolic (`has_duplicates_symb`) and concrete (`has_duplicates`) instances of the `HasDuplicates` class using `show_bloqs` from `qualtran.drawing`. This provides visual representations of the quantum circuits implemented by the HasDuplicates bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([has_duplicates_symb, has_duplicates],\n           ['`has_duplicates_symb`', '`has_duplicates`'])\n```\n\n----------------------------------------\n\nTITLE: Classical simulation of MultiAnd gate\nDESCRIPTION: This snippet simulates the `MultiAnd` gate classically with a given control input.  It calls `call_classically` on the `MultiAnd` instance and returns the updated control qubits, junk qubits, and the result qubit. This simulation helps in understanding the gate's behavior on classical inputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nctrl = np.array([1,1,1,1])\nctrl, junk, out = MultiAnd((1,1,1,1)).call_classically(ctrl=ctrl)\nout\n```\n\n----------------------------------------\n\nTITLE: Initializing and showing the ModExp bloq from Qualtran in Python\nDESCRIPTION: This snippet initializes the `ModExp` bloq from the `qualtran` library with the given base `g`, modulus `N`, and exponent bitsize. It then displays the bloq's structure using `show_bloq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.cryptography.rsa.rsa_mod_exp import ModExp\nfrom qualtran.drawing import show_bloq\n\nmod_exp = ModExp(base=g, mod=N, exp_bitsize=32, x_bitsize=32)\nshow_bloq(mod_exp)\n```\n\n----------------------------------------\n\nTITLE: ControlledViaAnd with QInt and QUInt\nDESCRIPTION: Creates an instance of `ControlledViaAnd` with Hadamard as the subbloq and a `CtrlSpec` specifying control qubits as `QUInt(4)` and `QInt(4)` with control values specified by numpy arrays.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import CtrlSpec, QInt, QUInt\nfrom qualtran.bloqs.basic_gates import Hadamard\n\ncontrolled_via_and_ints = ControlledViaAnd(\n    Hadamard(),\n    CtrlSpec(\n        qdtypes=(QUInt(4), QInt(4)), cvs=(np.array([0, 1, 2, 3]), np.array([0, 1, -1, -2]))\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signature\nDESCRIPTION: Shows the graphical signatures of the symbolic and concrete `SparseMatrixHermitian` instances using `show_bloqs` function from `qualtran.drawing`. It displays the bloqs with their respective names for visual inspection.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix_hermitian.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sparse_matrix_symb_hermitian_block_encoding, sparse_matrix_hermitian_block_encoding],\n           ['`sparse_matrix_symb_hermitian_block_encoding`', '`sparse_matrix_hermitian_block_encoding`'])\n```\n\n----------------------------------------\n\nTITLE: Comparator Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph for the comparator using `comparator.call_graph`. The `ignore_split_join` generalizer is used to simplify the graph.  `show_call_graph` and `show_counts_sigma` are used to present the call graph and sigma counts respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncomparator_g, comparator_sigma = comparator.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(comparator_g)\nshow_counts_sigma(comparator_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiate ApplyLthBloq with Basic Gates\nDESCRIPTION: This code demonstrates how to instantiate the `ApplyLthBloq` with an array of basic quantum gates (TGate, Hadamard, ZGate, XGate). The `control_val` parameter is set to 1, indicating that the bloq is controlled.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_lth_bloq.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard, TGate, XGate, ZGate\n\nops = np.array((TGate(), Hadamard(), ZGate(), XGate()))\napply_lth_bloq = ApplyLthBloq(ops, control_val=1)\n```\n\n----------------------------------------\n\nTITLE: Adding CompositeBloq with `bb.add` - Python\nDESCRIPTION: Demonstrates the use of `bb.add` to connect `TestParallelCombo` bloqs serially. The `add` function creates new instances and connects them directly within the builder.  Registers are passed and returned in the add calls.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Just call add\nbb = BloqBuilder()\nstuff = bb.add_register('stuff', 3)\nstuff = bb.add(TestParallelCombo(), reg=stuff)\nstuff = bb.add(TestParallelCombo(), reg=stuff)\nbloq = bb.finalize(stuff=stuff)\nshow_bloq(bloq)\n```\n\n----------------------------------------\n\nTITLE: Show ZeroEffect Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `ZeroEffect` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nzero_effect_g, zero_effect_sigma = zero_effect.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(zero_effect_g)\nshow_counts_sigma(zero_effect_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show OneEffect Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `OneEffect` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\none_effect_g, one_effect_sigma = one_effect.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(one_effect_g)\nshow_counts_sigma(one_effect_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show IntEffect Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `IntEffect` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nint_effect_g, int_effect_sigma = int_effect.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(int_effect_g)\nshow_counts_sigma(int_effect_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display Signed Integer to Two's Complement Call Graph\nDESCRIPTION: Generates and displays the call graph of the `signed_to_twos` Bloq using the `call_graph` method and the `show_call_graph` function. It also computes and displays the resource counts sigma using `show_counts_sigma`. The `ignore_split_join` generalizer is used to simplify the call graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsigned_to_twos_g, signed_to_twos_sigma = signed_to_twos.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(signed_to_twos_g)\nshow_counts_sigma(signed_to_twos_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of `ECWindowAddR`\nDESCRIPTION: Generates and displays the graphical signature of the `ECWindowAddR` instance `ec_window_add_r_small`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ec_window_add_r_small],\n           ['`ec_window_add_r_small`'])\n```\n\n----------------------------------------\n\nTITLE: Execute Notebooks and Build Reference Docs (Local Preview)\nDESCRIPTION: This snippet executes the Jupyter notebooks to generate updated documentation files and then builds the reference documentation from docstrings. The `--no-only-out-of-date` flag ensures that all notebooks are executed, not just those that are out of date.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/how-to-build-the-docs.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd ../dev_tools/\npython execute-notebooks.py --no-only-out-of-date\npython build-reference-docs.py\ncd ../docs\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloq Report Card for arithmetic\nDESCRIPTION: This snippet displays the Bloq report card specifically for the `arithmetic` package. It uses `report_card.query('package == \"arithmetic\"')` to filter the report card data to only include entries where the package is equal to 'arithmetic'. The filtered report card is then passed to `show_bloq_report_card()` for display.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq_report_card(report_card.query('package == \"arithmetic\"'))\n```\n\n----------------------------------------\n\nTITLE: CZPowGate Decomposition\nDESCRIPTION: Decomposes the `CZPowGate` into its constituent bloqs and displays the resulting musical score representation. This reveals the underlying gate-level implementation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(cz_pow.decompose_bloq(), 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for CAdd\nDESCRIPTION: This snippet generates the call graph for the `cadd_small` instance using `cadd_small.call_graph` with a maximum depth of 1 and ignoring split/join operations. It then displays the call graph and counts using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_addition.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncadd_small_g, cadd_small_sigma = cadd_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cadd_small_g)\nshow_counts_sigma(cadd_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Defining BloqDocSpec for ModExp Bloq (Python)\nDESCRIPTION: This code snippet demonstrates how to define a `BloqDocSpec` to group examples with the `ModExp` Bloq class for automatic Jupyter notebook generation. The `BloqDocSpec` specifies the bloq class and the example instantiations to be included in the documentation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Autodoc.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n_MODEXP_DOC = BloqDocSpec(\n    bloq_cls=ModExp,\n    examples=[_modexp_symb, _modexp_small, _modexp],\n)\n```\n\n----------------------------------------\n\nTITLE: Summarizing Results for arithmetic\nDESCRIPTION: This snippet summarizes the results of the Bloq report card for the `arithmetic` package. It uses `report_card.query('package == \"arithmetic\"')` to filter the report card data to only include entries where the package is equal to 'arithmetic'. The filtered report card is then passed to `summarize_results()` for summarization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsummarize_results(report_card.query('package == \"arithmetic\"'))\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Qualtran and Cirq\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library for defining and manipulating quantum circuits and bloqs. It also imports Cirq, NumPy, SymPy, and typing utilities for general use.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/su2_rotation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Generate and display call graph and counts sigma for MultiAnd bloq\nDESCRIPTION: This snippet generates and displays the call graph and resource counts for the `multi_and` bloq. It uses the `ignore_split_join` generalizer for simplification and visualizes the results using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmulti_and_g, multi_and_sigma = multi_and.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(multi_and_g)\nshow_counts_sigma(multi_and_sigma)\n```\n\n----------------------------------------\n\nTITLE: Git Switch to Docs Branch\nDESCRIPTION: This snippet shows how to switch to the 'docs' branch, fetch the latest changes from the 'main' branch, and check the .gitignore file to verify that generated outputs are un-ignored. This is part of the production deployment process.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/how-to-build-the-docs.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit switch docs\ngit fetch origin && git merge origin/main\ncat docs/.gitignore  # verify that outputs are un-ignored\n```\n\n----------------------------------------\n\nTITLE: Instantiate PolynmomialEvaluationInverseSquareRoot\nDESCRIPTION: This snippet instantiates the `PolynmomialEvaluationInverseSquareRoot` class with specific parameters.  The parameters define the input bitsize (7), output bitsize (8), and some other parameter (12) relevant to the polynomial evaluation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npoly_inv_sqrt = PolynmomialEvaluationInverseSquareRoot(7, 8, 12)\n```\n\n----------------------------------------\n\nTITLE: Push Changes to Fork (Git)\nDESCRIPTION: This command pushes the changes from the local branch `YOUR_BRANCH_NAME` to the forked repository on GitHub. It uploads the commits to the remote repository, making them available for creating a pull request. It assumes a remote named 'origin' which usually points to the forked repository.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit push origin YOUR_BRANCH_NAME\n```\n\n----------------------------------------\n\nTITLE: Initializing: Retrieving Bloq Classes\nDESCRIPTION: This snippet retrieves all available bloq classes using the `get_bloq_classes` function from the `qualtran_dev_tools.bloq_finder` module.  The length of the resulting list of classes is then calculated, presumably to indicate the number of discovered bloq classes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran_dev_tools.bloq_finder import get_bloq_classes\nbloq_classes = get_bloq_classes()\nlen(bloq_classes)\n```\n\n----------------------------------------\n\nTITLE: Generating Bloq Report Card\nDESCRIPTION: This snippet imports necessary functions from `qualtran_dev_tools.bloq_report_card` to generate a Bloq report card. It calls `get_bloq_report_card()` to create the report card and stores it in the `report_card` variable. The report card contains data about the different Bloqs in the qualtran library.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran_dev_tools.bloq_report_card import get_bloq_report_card, show_bloq_report_card, summarize_results\nreport_card = get_bloq_report_card()\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: Imports necessary modules from the `qualtran` library for defining and manipulating quantum bloqs, registers, and signatures. It also imports typing, numpy, sympy, and cirq for general-purpose programming and mathematical operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/contiguous_index.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Bloq graphical signature\nDESCRIPTION: This snippet uses `show_bloqs` to display the graphical signature of the two `PhasingViaCostFunction` instances created earlier (`square_via_phase_gradient` and `square_via_zpow_phasing`). This allows for a visual representation of the bloqs and their inputs/outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phasing_via_cost_function.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([square_via_phase_gradient, square_via_zpow_phasing],\n           ['`square_via_phase_gradient`', '`square_via_zpow_phasing`'])\n```\n\n----------------------------------------\n\nTITLE: Installing Qualtran from Source using git and pip (shell)\nDESCRIPTION: This snippet demonstrates how to install the Qualtran library from source using git clone and pip install. It clones the Qualtran repository, navigates to the directory, and installs it in editable mode. Prerequisites: git, pip, and a Python environment.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/quantumlib/Qualtran.git\ncd Qualtran/\npip install -e .\n```\n\n----------------------------------------\n\nTITLE: Controlling OnEach with custom controlled sub-bloqs\nDESCRIPTION: This example demonstrates controlling an `OnEach` bloq, which uses custom controlled behavior for its sub-bloqs (XGate, Split/Join). It creates a doubly-controlled (Toffoli) gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Use the default fallback for `OnEach`; but the subbloqs all have custom\n# controlled behavior: \n#  C^2[X]        -> Toffoli\n#  C[Split/Join] -> Split/Join\nfrom qualtran.bloqs.basic_gates import OnEach\n\nccx3 = OnEach(n=3, gate=x).controlled(CtrlSpec(cvs=(1,1)))\nshow_bloq(ccx3.decompose_bloq(), type='musical_score')\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: This snippet imports necessary modules from Qualtran for building quantum circuits and data structures. It also includes standard libraries like typing, numpy, sympy, and cirq for general-purpose programming.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/select_swap_qrom.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures of State Preparation Bloqs\nDESCRIPTION: Uses `show_bloqs` from `qualtran.drawing` to display the graphical signatures of the `state_prep_via_rotation`, `state_prep_via_rotation_symb`, and `state_prep_via_rotation_symb_phasegrad` instances. This provides a visual representation of the quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([state_prep_via_rotation, state_prep_via_rotation_symb, state_prep_via_rotation_symb_phasegrad],\n           ['`state_prep_via_rotation`', '`state_prep_via_rotation_symb`', '`state_prep_via_rotation_symb_phasegrad`'])\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph of CSwapApprox\nDESCRIPTION: Generates and displays the call graph and sigma counts of the symbolic CSwapApprox instance.  The `ignore_split_join` generalizer is used to simplify the graph.  This helps understand the internal structure and resource requirements.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\napprox_cswap_symb_g, approx_cswap_symb_sigma = approx_cswap_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(approx_cswap_symb_g)\nshow_counts_sigma(approx_cswap_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of SelectTHC\nDESCRIPTION: Generates and displays the call graph for the `SelectTHC` bloq using `call_graph` and `show_call_graph`. The `ignore_split_join` generalizer simplifies the graph by ignoring split/join operations. The counts are displayed using `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nthc_sel_g, thc_sel_sigma = thc_sel.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(thc_sel_g)\nshow_counts_sigma(thc_sel_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display graphical signatures of Add instances\nDESCRIPTION: Uses `show_bloqs` to display the graphical representation of the instantiated `Add` gates (`add_symb`, `add_small`, `add_large`, `add_diff_size_regs`). This visualization helps understand the register structure and data flow of the quantum addition operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([add_symb, add_small, add_large, add_diff_size_regs],\n           ['`add_symb`', '`add_small`', '`add_large`', '`add_diff_size_regs`'])\n```\n\n----------------------------------------\n\nTITLE: Calculating GCD to retrieve the factors in Python\nDESCRIPTION: This snippet calculates the greatest common divisor (GCD) of `p1 % N` and `N`, and `m1 % N` and `N` to find the factors of `N`. It imports the `math` module for the `gcd` function.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(f'gcd{p1%N, N}, gcd{m1%N, N}')\nimport math\nmath.gcd(p1%N, N), math.gcd(m1%N, N)\n```\n\n----------------------------------------\n\nTITLE: Show graphical signatures\nDESCRIPTION: This snippet utilizes the `show_bloqs` function to display the graphical signatures of the previously created walk operators: `walk_op`, `thc_walk_op`, and `walk_op_chem_sparse`. This visual representation helps understand the structure and complexity of these operators.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([walk_op, thc_walk_op, walk_op_chem_sparse],\n           ['`walk_op`', '`thc_walk_op`', '`walk_op_chem_sparse`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation\nDESCRIPTION: This snippet demonstrates generating and displaying the call graph and counts sigma for the `product_block_encoding` using the `call_graph` method and the `ignore_split_join` generalizer. This helps to analyze the resource requirements and structure of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/product.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nproduct_block_encoding_g, product_block_encoding_sigma = product_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(product_block_encoding_g)\nshow_counts_sigma(product_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Creating a LessThanConstant instance with symbolic parameters\nDESCRIPTION: This creates an instance of the `LessThanConstant` bloq with symbolic parameters for `bitsize` and `less_than_val` using the `sympy` library. This allows for the creation of a parameterized quantum circuit that can be later specialized with concrete values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nn, k = sympy.symbols(\"n k\")\nlt_k_symb = LessThanConstant(bitsize=n, less_than_val=k)\n```\n\n----------------------------------------\n\nTITLE: Generate call graph of Add gate\nDESCRIPTION: Generates and displays the call graph of the `Add` gate using `call_graph` and `show_call_graph`. This illustrates the internal structure of the gate and its dependencies. `ignore_split_join` is used as a generalizer for resource counting.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/addition.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nadd_symb_g, add_symb_sigma = add_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(add_symb_g)\nshow_counts_sigma(add_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Define MultiplexedCSwap\nDESCRIPTION: Imports the MultiplexedCSwap class from qualtran.bloqs.swap_network. It swaps the l-th register into an ancilla using unary iteration.  It uses CSwaps for conditional swapping.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.swap_network import MultiplexedCSwap\n```\n\n----------------------------------------\n\nTITLE: Free Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `Free` bloq, ignoring split and join operations using a generalizer. This provides insights into the bloq's dependencies and resource requirements.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nfree_g, free_sigma = free.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(free_g)\nshow_counts_sigma(free_sigma)\n```\n\n----------------------------------------\n\nTITLE: Drawing CLinearDepthGreaterThan bloq\nDESCRIPTION: This code visualizes the `CLinearDepthGreaterThan` bloq using `show_bloqs` from `qualtran.drawing`. It helps in understanding the structure and connections within the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([clineardepthgreaterthan_example],\n           ['`clineardepthgreaterthan_example`'])\n```\n\n----------------------------------------\n\nTITLE: Creating an instance of ZPowConstViaPhaseGradient with symbolic precision\nDESCRIPTION: Creates an instance of `ZPowConstViaPhaseGradient` with a specific angle (3/8) and a symbolic error tolerance (`eps`) for symbolic precision.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/zpow_via_phase_gradient.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\neps = sympy.symbols(\"eps\")\nzpow_const_via_phase_grad_symb_prec = ZPowConstViaPhaseGradient.from_precision(3 / 8, eps=eps)\n```\n\n----------------------------------------\n\nTITLE: Import TGate\nDESCRIPTION: Imports the TGate class from the qualtran.bloqs.basic_gates module. This allows the T gate to be used in subsequent code snippets.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/t_gate.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import TGate\n```\n\n----------------------------------------\n\nTITLE: Import MinusState Bloq\nDESCRIPTION: Imports the `MinusState` class from the `qualtran.bloqs.basic_gates` module. `MinusState` represents the |-> quantum state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import MinusState\n```\n\n----------------------------------------\n\nTITLE: Create ComplexGivensRotationByPhaseGradient Instance\nDESCRIPTION: Creates an instance of the `ComplexGivensRotationByPhaseGradient` class with a `phasegrad_bitsize` of 4.  This determines the precision of the phase gradient register used in the rotation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncplx_givens = ComplexGivensRotationByPhaseGradient(phasegrad_bitsize=4)\n```\n\n----------------------------------------\n\nTITLE: Instantiate QuantumVariableRotation\nDESCRIPTION: This snippet instantiates the `QuantumVariableRotation` class with a bitsize of 12, defining the precision for the phase angle.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nqvr = QuantumVariableRotation(12)\n```\n\n----------------------------------------\n\nTITLE: ToContiguousIndex Import\nDESCRIPTION: Imports the `ToContiguousIndex` class from the `qualtran.bloqs.arithmetic.conversions` module. This class is used to build a contiguous register 's' from registers 'mu' and 'nu'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/contiguous_index.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.conversions import ToContiguousIndex\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Representation of CZ\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical representation of the instantiated `cz` object. This visualization helps in understanding the gate's action within a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cz],\n           ['`cz`'])\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasingViaPhaseGradient Import\nDESCRIPTION: Imports the `HammingWeightPhasingViaPhaseGradient` class from the `qualtran.bloqs.rotations` module. This class implements the alternative Hamming weight phasing algorithm using a phase gradient register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import HammingWeightPhasingViaPhaseGradient\n```\n\n----------------------------------------\n\nTITLE: TGate Call Graph and Resource Counts\nDESCRIPTION: Generates and displays the call graph and resource counts (sigma) for the TGate. This helps analyze the gate's resource requirements and dependencies.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/t_gate.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nt_gate_g, t_gate_sigma = t_gate.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(t_gate_g)\nshow_counts_sigma(t_gate_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show IntEffect Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `IntEffect` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([int_effect],\n           ['`int_effect`'])\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientUnitary Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature for `phase_gradient_unitary` and `phase_gradient_unitary_symbolic` using `show_bloqs` from `qualtran.drawing`. It visualizes the inputs and outputs of the bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([phase_gradient_unitary, phase_gradient_unitary_symbolic],\n           ['`phase_gradient_unitary`', '`phase_gradient_unitary_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and Standard Libraries\nDESCRIPTION: Imports necessary modules from the `qualtran` library, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register classes, as well as type hints and numerical computation libraries.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: Import necessary modules from qualtran and other libraries like numpy, sympy, and cirq. These modules provide classes and functions for defining quantum circuits, representing qubits, and performing mathematical operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/t_gate.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasingViaPhaseGradient Call Graph\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `HammingWeightPhasingViaPhaseGradient` bloq, ignoring split and join operations. This helps visualize dependencies and resource usage.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nhamming_weight_phasing_via_phase_gradient_g, hamming_weight_phasing_via_phase_gradient_sigma = hamming_weight_phasing_via_phase_gradient.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(hamming_weight_phasing_via_phase_gradient_g)\nshow_counts_sigma(hamming_weight_phasing_via_phase_gradient_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate Graphical Signature in Python\nDESCRIPTION: This snippet generates a graphical signature of the `black_box_prepare` bloq using the `show_bloqs` function from `qualtran.drawing`. The graphical signature provides a visual representation of the bloq's structure and connections. This requires the `black_box_prepare` instance created in the previous step.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([black_box_prepare],\n           ['`black_box_prepare`'])\n```\n\n----------------------------------------\n\nTITLE: MultiControlX Call Graph\nDESCRIPTION: Generates and displays the call graph of the `MultiControlX` instance, ignoring split and join operations for resource analysis.  This shows the sub-components of the gate and their interdependencies.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nccpauli_g, ccpauli_sigma = ccpauli.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ccpauli_g)\nshow_counts_sigma(ccpauli_sigma)\n```\n\n----------------------------------------\n\nTITLE: ZeroState Adjoint Example in Qualtran\nDESCRIPTION: This code snippet demonstrates how to obtain and visualize the adjoint of a `ZeroState` bloq using the `adjoint()` method.  The example showcases the basic usage of the adjoint protocol by printing and showing the original `ZeroState` and its adjoint.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloq\nfrom qualtran.bloqs.basic_gates import ZeroState\n\nprint(ZeroState())\nshow_bloq(ZeroState())\nprint(ZeroState().adjoint())\nshow_bloq(ZeroState().adjoint())\n```\n\n----------------------------------------\n\nTITLE: Display ToContiguousIndex Call Graph\nDESCRIPTION: Generates and displays the call graph of the `to_contg_index` Bloq using the `call_graph` method and the `show_call_graph` function. It also computes and displays the resource counts sigma using `show_counts_sigma`.  The call graph is generalized using `ignore_split_join`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nto_contg_index_g, to_contg_index_sigma = to_contg_index.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(to_contg_index_g)\nshow_counts_sigma(to_contg_index_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of SelectSparse\nDESCRIPTION: This snippet shows how to generate and display the graphical signature of the `sel_sparse` bloq. This visualization provides an overview of the bloq's inputs and outputs, aiding in understanding its functionality within a larger quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sel_sparse],\n           ['`sel_sparse`'])\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and other libraries\nDESCRIPTION: Imports necessary modules from Qualtran, including Bloq, CompositeBloq, Signature, and Register, as well as modules for drawing and typing. It also imports common libraries like numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Instantiate PrepareZetaState in Python\nDESCRIPTION: Creates an instance of the `PrepareZetaState` class with the given parameters: `num_atoms`, `lambda_zeta`, and `num_bits_nuc_pos`. This instance prepares the superposition over atomic species weighted by $\\zeta_l$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nnum_atoms = 10\nlambda_zeta = 10\nnum_bits_nuc_pos = 8\n\nprepare_zeta = PrepareZetaState(\n    num_atoms=num_atoms, lambda_zeta=lambda_zeta, num_bits_nuc_pos=num_bits_nuc_pos\n)\n```\n\n----------------------------------------\n\nTITLE: Clean and Execute Notebooks and Build Reference Docs\nDESCRIPTION: This snippet cleans previously generated documentation outputs, executes the Jupyter notebooks to generate new outputs, and builds the reference documentation from docstrings. This part is used for generating stage-2 doc outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/how-to-build-the-docs.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd dev_tools/\npython clean-stage-2-doc-outputs.py  # delete all generated outputs\npython execute-notebooks.py --no-only-out-of-date\npython build-reference-docs.py\ncd ../docs\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of SingleFactorizationBlockEncoding\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `sf_block_encoding` bloq. It visually represents the bloq and its inputs/outputs, providing a high-level overview of its structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sf_block_encoding],\n           ['`sf_block_encoding`'])\n```\n\n----------------------------------------\n\nTITLE: Displaying graphical signatures of ZPowConstViaPhaseGradient instances\nDESCRIPTION: Displays the graphical signatures of three different instances of `ZPowConstViaPhaseGradient`: one with numeric precision, one with symbolic precision, and one with a symbolic angle using `qualtran.drawing.show_bloqs`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/zpow_via_phase_gradient.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([zpow_const_via_phase_grad, zpow_const_via_phase_grad_symb_prec, zpow_const_via_phase_grad_symb_angle],\n           ['`zpow_const_via_phase_grad`', '`zpow_const_via_phase_grad_symb_prec`', '`zpow_const_via_phase_grad_symb_angle`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate GFPolyJoin with QGFPoly in Qualtran\nDESCRIPTION: Creates an instance of the `GFPolyJoin` bloq using a `QGFPoly` instance. This showcases how to initialize the join operation with a specific polynomial defined over a Galois field, similar to the `GFPolySplit` example. The created object `gf_poly_join` is used to perform the actual join operation later.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf_poly_split_and_join.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QGF, QGFPoly\n\ngf_poly_join = GFPolyJoin(QGFPoly(4, QGF(2, 3)))\n```\n\n----------------------------------------\n\nTITLE: GF2ShiftRight Bloq Definition\nDESCRIPTION: Defines the `GF2ShiftRight` bloq, which multiplies by $2^k$ (or $x^k$ for polynomials) modulo the given irreducible polynomial $m_x$.  It implements the transformation $\\ket{f} \\rightarrow \\ket{x^k f \\mod m(x)}$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2ShiftRight\n```\n\n----------------------------------------\n\nTITLE: Cast Example Instance\nDESCRIPTION: Creates an instance of the `Cast` bloq, configured to cast a `QInt(32)` register to a `QFxp(32, 32)` register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QFxp, QInt\n\ncast = Cast(QInt(32), QFxp(32, 32))\n```\n\n----------------------------------------\n\nTITLE: Calculating T Complexity of a Two-Qubit And Gate in Qualtran\nDESCRIPTION: This snippet creates a two-qubit And gate using Qualtran and calculates its T complexity. The And gate doesn't directly support TComplexity but it's decomposable and its components are simple, allowing for T complexity calculation via decomposition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/cirq_interop/t_complexity.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngate = And() # create an And gate\n# this gate doesn't directly support TComplexity but it's decomposable and its components are simple.\nprint(t_complexity(gate))\n```\n\n----------------------------------------\n\nTITLE: BitonicSort Definition in Qualtran\nDESCRIPTION: Defines the `BitonicSort` bloq that sorts k n-bit integers in-place using a Bitonic sorting network. The `k` parameter specifies the number of integers to sort, and `bitsize` specifies the number of bits per integer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import BitonicSort\n```\n\n----------------------------------------\n\nTITLE: Instantiate NewtonRaphsonApproxInverseSquareRoot\nDESCRIPTION: This snippet instantiates the `NewtonRaphsonApproxInverseSquareRoot` class with specific parameters. These parameters define the bitsize for x_sq (7), the polynomial (poly) bitsize (8), and the output bitsize (12).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnr_inv_sqrt = NewtonRaphsonApproxInverseSquareRoot(7, 8, 12)\n```\n\n----------------------------------------\n\nTITLE: Showing Graphical Signatures of ChebyshevPolynomial instances\nDESCRIPTION: This snippet uses `show_bloqs` to display the graphical signatures of the `chebyshev_poly_even` and `chebyshev_poly_odd` instances created earlier. This provides a visual representation of the inputs and outputs of the block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([chebyshev_poly_even, chebyshev_poly_odd],\n           ['`chebyshev_poly_even`', '`chebyshev_poly_odd`'])\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports for GQSP\nDESCRIPTION: Imports necessary modules from Qualtran for defining and using quantum bloqs, signatures, registers, and data types. Also imports typing utilities, NumPy, SymPy, and Cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qsp/generalized_qsp.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: ChebyshevPolynomial Example Instance (Odd Order)\nDESCRIPTION: This code creates an instance of `ChebyshevPolynomial` with an odd order (5). It uses a simple `Unitary` operation (Hadamard) as the block encoding of the input Hermitian matrix.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard\nfrom qualtran.bloqs.block_encoding import Unitary\n\nbloq = Unitary(Hadamard())\nchebyshev_poly_odd = ChebyshevPolynomial(bloq, order=5)\n```\n\n----------------------------------------\n\nTITLE: Qualtran Modular Subtraction Imports\nDESCRIPTION: Imports necessary modules from the `qualtran` library for defining quantum circuits, bloqs, and registers. It also includes standard Python libraries like `typing`, `numpy`, `sympy`, and `cirq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Display SignTruncate Call Graph\nDESCRIPTION: Generates and displays the call graph of the `sign_truncate` Bloq using the `call_graph` method and the `show_call_graph` function. It also computes and displays the resource counts sigma using `show_counts_sigma`. The call graph is generalized using `ignore_split_join`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsign_truncate_g, sign_truncate_sigma = sign_truncate.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sign_truncate_g)\nshow_counts_sigma(sign_truncate_sigma)\n```\n\n----------------------------------------\n\nTITLE: QROAMClean Multi-dimensional build_from_data Example\nDESCRIPTION: Example constructing a `QROAMClean` instance from multi-dimensional numpy arrays. `data1` and `data2` are 5x5 arrays, and a log_block_sizes of (1, 1) is used for construction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndata1 = np.arange(25, dtype=int).reshape((5, 5))\ndata2 = (np.arange(25, dtype=int) + 1).reshape((5, 5))\nqroam_clean_multi_dim = QROAMClean.build_from_data(data1, data2, log_block_sizes=(1, 1))\n```\n\n----------------------------------------\n\nTITLE: Import DoubleFactorizationOneBody from qualtran\nDESCRIPTION: This line imports the `DoubleFactorizationOneBody` class from the specified module within the `qualtran` library. This bloq represents a block encoding of the double factorization one-body Hamiltonian.  It will be used in example code later on.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.df.double_factorization import DoubleFactorizationOneBody\n```\n\n----------------------------------------\n\nTITLE: Instantiate ArcSin with Specific Parameters\nDESCRIPTION: Creates an instance of the `ArcSin` class with a bitsize of 10 and 7 fractional bits. This configures the `ArcSin` object to compute the arcsine of a 10-bit fixed-point number with 7 bits of precision after the decimal point.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/trigonometric/trigonometric.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\narcsin = ArcSin(bitsize=10, num_frac=7)\n```\n\n----------------------------------------\n\nTITLE: Instantiate MultiAnd bloq with control variable settings\nDESCRIPTION: This snippet creates an instance of the `MultiAnd` bloq with specific control variable settings (`cvs`). The `cvs` parameter is a tuple indicating whether each control line is a positive control (1) or a negative control (0).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmulti_and = MultiAnd(cvs=(1, 0, 1, 0, 1, 0))\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and related libraries\nDESCRIPTION: Imports necessary modules from the Qualtran library for defining and visualizing quantum circuits, along with standard Python libraries like numpy and sympy for numerical and symbolic computations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: UniformSuperpositionTHC Example Instance\nDESCRIPTION: Creates an instance of the `UniformSuperpositionTHC` class with specified parameters for the number of mu indices and spin orbitals. This example demonstrates how to instantiate the bloq for use in a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnum_mu = 10\nnum_spin_orb = 4\nthc_uni = UniformSuperpositionTHC(num_mu=num_mu, num_spin_orb=num_spin_orb)\n```\n\n----------------------------------------\n\nTITLE: MultiTargetCNOT Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of both the symbolic and concrete `MultiTargetCNOT` instances using `qualtran.drawing.show_bloqs`. This visualization helps understand the gate's input and output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([c_multi_not_symb, c_multi_not],\n           ['`c_multi_not_symb`', '`c_multi_not`'])\n```\n\n----------------------------------------\n\nTITLE: Create MultiplexedCSwap Instance\nDESCRIPTION: Creates an instance of the MultiplexedCSwap class. It takes a Register named 'selection' with bitsize 3 and iteration length 5, and a target bitsize of 2. This configures a specific multiplexed swap operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import BQUInt\n\nselection_bitsize = 3\niteration_length = 5\ntarget_bitsize = 2\nmultiplexed_cswap = MultiplexedCSwap(\n    Register('selection', BQUInt(selection_bitsize, iteration_length)),\n    target_bitsize=target_bitsize,\n)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of Product Bloqs\nDESCRIPTION: This snippet uses the `show_bloqs` function to visualize the graphical signatures of the three `Product` block encodings created in the previous examples. This provides a visual representation of the bloqs and their properties.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/product.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([product_block_encoding, product_block_encoding_properties, product_block_encoding_symb],\n           ['`product_block_encoding`', '`product_block_encoding_properties`', '`product_block_encoding_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Displaying Graphical Signatures of QFT Instances\nDESCRIPTION: This code visualizes the `qft_text_book` and `symbolic_qft` instances by displaying their graphical signatures using the `show_bloqs` function from `qualtran.drawing`. This allows for visual inspection of the circuit structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_text_book.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([qft_text_book, symbolic_qft],\n           ['`qft_text_book`', '`symbolic_qft`'])\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signature of YPowGate\nDESCRIPTION: This snippet generates and displays the graphical signature of the y_pow gate using the show_bloqs function from qualtran.drawing. This visual representation helps understand the gate's operation and connections within a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([y_pow],\n           ['`y_pow`'])\n```\n\n----------------------------------------\n\nTITLE: Monkey-Patching BloqBuilder - Python\nDESCRIPTION: Uses a context manager and monkey-patching to temporarily override the `BloqBuilder`'s internal counter for numbering bloq instances. This allows verification of the copy operation by ensuring the copied version has different indices.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom contextlib import contextmanager\n\n@contextmanager\ndef hacked_bb_init():\n    # monkey-patch BloqBuilder to offset the bloq instance counter.\n    \n    old_bb_init_method = BloqBuilder.__init__\n    \n    def _new_init(self, *args, **kwargs):\n        old_bb_init_method(self, *args, **kwargs)\n        self._i = 100\n\n    try:\n        BloqBuilder.__init__ = _new_init\n        yield\n    finally:\n        BloqBuilder.__init__ = old_bb_init_method\n```\n\n----------------------------------------\n\nTITLE: Import necessary Qualtran modules\nDESCRIPTION: Imports the required modules from the Qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register. Also imports typing, numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of GFPolySplit\nDESCRIPTION: Demonstrates how to generate and display a graphical representation of the `GFPolySplit` bloq using `show_bloqs` from `qualtran.drawing`. This visualization aids in understanding the bloq's structure and functionality.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf_poly_split_and_join.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf_poly_split],\n           ['`gf_poly_split`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of ControlledAddOrSubtract Instances\nDESCRIPTION: Generates and displays the graphical signatures of the created instances of `ControlledAddOrSubtract`. This visualization helps understand the input and output registers of the bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/controlled_add_or_subtract.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ctrl_add_or_sub_signed_symb, ctrl_add_or_sub_unsigned, ctrl_add_or_sub_signed],\n           ['`ctrl_add_or_sub_signed_symb`', '`ctrl_add_or_sub_unsigned`', '`ctrl_add_or_sub_signed`'])\n```\n\n----------------------------------------\n\nTITLE: Flattening Repeatedly in Qualtran\nDESCRIPTION: This snippet repeatedly flattens a `CompositeBloq` using the `flatten()` method. It continues flattening until no more flattening can be performed. The original `three_p` `CompositeBloq` is used as input.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n# Note that in this example, we have gone back to the original `three_p` starting composite bloq.\n# This will perform two flattening operations.\nshow_bloq(\n    three_p.flatten()\n)\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules\nDESCRIPTION: Imports necessary modules from Qualtran, typing, numpy, sympy, and cirq. These modules provide the building blocks for defining quantum circuits, data structures, and visualizations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/trotterized_unitary.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Importing the GeneralizedQSP class\nDESCRIPTION: Imports the `GeneralizedQSP` class from the `qualtran.bloqs.qsp.generalized_qsp` module. This class is used to implement the GQSP algorithm.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qsp/generalized_qsp.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.qsp.generalized_qsp import GeneralizedQSP\n```\n\n----------------------------------------\n\nTITLE: Iterating Bloqsoqs for Copying - Python\nDESCRIPTION: Demonstrates how to iterate over the contents of a `CompositeBloq` using `CompositeBloq.iter_bloqsoqs()` in conjunction with `map_soqs` for copying (with potential modifications).  This snippet reproduces the core logic used in the `copy` method.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import SoquetT\n\n# Start a new BloqBuilder to build up our copy\nbb, _ = BloqBuilder.from_signature(cbloq.signature)\n\n# We'll have to \"map\" the soquets from our template cbloq to our new one\nsoq_map: List[Tuple[SoquetT, SoquetT]] = []\n    \n# Iteration yields each bloq instance as well as its input and output soquets.\nfor binst, in_soqs, old_out_soqs in cbloq.iter_bloqsoqs():\n    # We perform the mapping\n    in_soqs = bb.map_soqs(in_soqs, soq_map)\n    \n    # Optional modification can go here!\n    # We add a new bloq instance based on the template cbloq.\n    # We use `bb.add_t` so the return value is always a tuple, even\n    # if there's only one value returned.\n    new_out_soqs = bb.add_t(binst.bloq, **in_soqs)\n    \n    # We are responsible for updating the mapping from old soquets (provided\n    # to us) with our new soquets obtained from the bloq builder.\n    soq_map.extend(zip(old_out_soqs, new_out_soqs))\n\n# We finalize the new builder with a mapped version of the final,\n# right-dangling soquets.\nfsoqs = bb.map_soqs(cbloq.final_soqs(), soq_map)\ncopy = bb.finalize(**fsoqs)\nprint(copy)\n```\n\n----------------------------------------\n\nTITLE: Defining a Signature with QUInt in Qualtran\nDESCRIPTION: This snippet demonstrates how to define a `Signature` object in Qualtran using the `QUInt` data type. It creates two registers, 'x' and 'y', each representing a 32-bit quantum unsigned integer. The `n_qubits()` method is used to determine the total number of qubits required by the signature.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QUInt\n\nsignature = Signature([\n    Register('x', QUInt(32)),\n    Register('y', QUInt(32)),\n])\nprint(signature.n_qubits())\n```\n\n----------------------------------------\n\nTITLE: QROAMClean Symbolic build_from_bitsize Example (2D)\nDESCRIPTION: Example building `QROAMClean` symbolically using `build_from_bitsize` where the shape, bitsize, log_block_sizes and num_controls are sympy symbols.  The example is for a 2D array.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nN, M, b1, b2, k1, k2, c = sympy.symbols('N M b1 b2 k1 k2 c')\nlog_block_sizes = (k1, k2)\nqroam_clean_symb_2d = QROAMClean.build_from_bitsize(\n    (N, M), (b1, b2), log_block_sizes=log_block_sizes, num_controls=c\n)\n```\n\n----------------------------------------\n\nTITLE: Import statements\nDESCRIPTION: Imports necessary modules and classes from qualtran, typing, numpy, sympy, and cirq. These modules provide building blocks for defining quantum algorithms, data structures, and circuit drawing.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of GFPolyJoin\nDESCRIPTION: Generates and displays a graphical representation of the `GFPolyJoin` bloq using `show_bloqs` from `qualtran.drawing`. The resulting diagram provides a visual representation of how the QGF registers are combined into a QGFPoly register during the join operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf_poly_split_and_join.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf_poly_join],\n           ['`gf_poly_join`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph of CLinearDepthGreaterThan in Qualtran\nDESCRIPTION: This snippet generates and displays the call graph for `CLinearDepthGreaterThan` using `call_graph` and `show_call_graph`. The `ignore_split_join` generalizer is used for resource counting. This helps in analyzing the resource requirements of the comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nclineardepthgreaterthan_example_g, clineardepthgreaterthan_example_sigma = clineardepthgreaterthan_example.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(clineardepthgreaterthan_example_g)\nshow_counts_sigma(clineardepthgreaterthan_example_sigma)\n```\n\n----------------------------------------\n\nTITLE: Showing a Bloq Diagram - Python\nDESCRIPTION: Demonstrates how to display a visual representation of a defined `Bloq`, here `TestTwoCNOT`, using the `show_bloq` function.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(TestTwoCNOT())\n```\n\n----------------------------------------\n\nTITLE: Symbolic SimpleGuidingState Example\nDESCRIPTION: This snippet demonstrates how to create a `SimpleGuidingState` instance with symbolic parameters using the `sympy` library. It defines symbolic variables for `n`, `m`, and `k` to represent the parameters of the kXOR instance and then creates a symbolic `KXorInstance` and `SimpleGuidingState` object.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.optimization.k_xor_sat import KXorInstance\n\nn, m, k = sympy.symbols(\"n m k\", positive=True, integer=True)\ninst = KXorInstance.symbolic(n=n, m=m, k=k)\nsimple_guiding_state_symb = SimpleGuidingState(inst)\n```\n\n----------------------------------------\n\nTITLE: Symbolic Sparse Permutation Definition\nDESCRIPTION: Defines a `Permutation` instance from a partial permutation map where the total size `N` is a symbolic variable. This allows for the creation of partial permutations with a symbolic number of qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nN = sympy.symbols(\"N\", positive=True, integer=True)\nsparse_permutation_with_symbolic_N = Permutation.from_partial_permutation_map(\n    N, {0: 1, 1: 3, 2: 4, 3: 7}\n)\n```\n\n----------------------------------------\n\nTITLE: QROAMClean Symbolic build_from_bitsize Example (1D)\nDESCRIPTION: Example building `QROAMClean` symbolically using `build_from_bitsize` where the shape, bitsize, log_block_sizes and num_controls are sympy symbols.  The example is for a 1D array.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nN, b, k, c = sympy.symbols('N b k c')\nqroam_clean_symb_1d = QROAMClean.build_from_bitsize(\n    (N,), (b,), log_block_sizes=(k,), num_controls=c\n)\n```\n\n----------------------------------------\n\nTITLE: Small QROM Instance - Python\nDESCRIPTION: This snippet instantiates a `QROM` object with a small data set.  The data to load is `np.arange(5)`. The selection register requires 3 bits (`selection_bitsizes=(3,)`) and the target register requires 3 bits (`target_bitsizes=(3,)`).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndata = np.arange(5)\nqrom_small = QROM([data], selection_bitsizes=(3,), target_bitsizes=(3,))\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying a call graph for EqualsAConstant\nDESCRIPTION: This generates a call graph for the `eq_k` bloq, which visualizes the dependencies and sub-components within the quantum circuit. It also computes and displays the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\neq_k_g, eq_k_sigma = eq_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(eq_k_g)\nshow_counts_sigma(eq_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of PrepareFirstQuantizationWithProj\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `prep_first_quant` bloq, providing a visual representation of its inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prep_first_quant],\n           ['`prep_first_quant`'])\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientUnitary Call Graph\nDESCRIPTION: Generates and displays the call graph for `phase_gradient_unitary`. It uses `ignore_split_join` from `qualtran.resource_counting.generalizers` to simplify the graph by ignoring split and join operations. Also displays the counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nphase_gradient_unitary_g, phase_gradient_unitary_sigma = phase_gradient_unitary.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(phase_gradient_unitary_g)\nshow_counts_sigma(phase_gradient_unitary_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of SelectPauliLCU\nDESCRIPTION: This snippet uses `show_bloqs` from `qualtran.drawing` to display the graphical signature of the `select_pauli_lcu` instance. This visualization helps to understand the input and output registers of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/select_pauli_lcu.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([select_pauli_lcu],\n           ['`select_pauli_lcu`'])\n```\n\n----------------------------------------\n\nTITLE: Fully Symbolic PermutationCycle Definition\nDESCRIPTION: Defines a symbolic `PermutationCycle` instance where both the size `N` and the cycle are symbolic (represented by `Shaped((L,))`). This allows for creating completely generic permutation cycle operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.symbolics import Shaped\n\nN, L = sympy.symbols(\"N L\", positive=True, integer=True)\ncycle = Shaped((L,))\npermutation_cycle_symb = PermutationCycle(N, cycle)\n```\n\n----------------------------------------\n\nTITLE: Nested Control with ControlledViaAnd\nDESCRIPTION: Demonstrates nested controls by calling the `controlled` method on `controlled_via_and_qbits` with a new `CtrlSpec`, resulting in another `ControlledViaAnd` instance. The resulting bloq is then visualized using `show_bloqs`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnested_ctrl_bloq = controlled_via_and_qbits.controlled(CtrlSpec(cvs=[1, 1]))\nshow_bloqs([nested_ctrl_bloq])\n```\n\n----------------------------------------\n\nTITLE: Sign Extension\nDESCRIPTION: Imports the `SignExtend` class from `qualtran.bloqs.arithmetic.conversions`. This class implements sign extension, which increases the bitsize of a value while preserving its sign. This is often used before arithmetic operations with operands of differing sizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.conversions import SignExtend\n```\n\n----------------------------------------\n\nTITLE: Symbolic PermutationCycle Definition\nDESCRIPTION: Defines a symbolic `PermutationCycle` instance with a symbolic total size `N` and a concrete cycle `(3, 1, 2)`. This allows for flexible usage of the cycle with different sizes of registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nN = sympy.symbols(\"n\", positive=True, integer=True)\ncycle = (3, 1, 2)\npermutation_cycle_symb_N = PermutationCycle(N, cycle)\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for Xor\nDESCRIPTION: Generates and displays the call graph for the `xor` bloq using `xor.call_graph` and `show_call_graph`. The `ignore_split_join` generalizer simplifies the graph by ignoring split and join operations.  Also displays `counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nxor_g, xor_sigma = xor.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(xor_g)\nshow_counts_sigma(xor_sigma)\n```\n\n----------------------------------------\n\nTITLE: SumOfSquares Example Instance\nDESCRIPTION: Creates an instance of the `SumOfSquares` class with a specified bitsize and number of integers `k`. This bloq implements $U|a\\rangle|b\\rangle\\dots k\\rangle|0\\rangle \\rightarrow |a\\rangle|b\\rangle\\dots|k\\rangle|a^2+b^2+\\dots k^2\\rangle$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nsum_of_squares = SumOfSquares(bitsize=8, k=4)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures of CSwapApprox\nDESCRIPTION: Displays the graphical signatures of the symbolic, small, and large CSwapApprox instances using the show_bloqs function from qualtran.drawing.  This allows for visual representation of the bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([approx_cswap_symb, approx_cswap_small, approx_cswap_large],\n           ['`approx_cswap_symb`', '`approx_cswap_small`', '`approx_cswap_large`'])\n```\n\n----------------------------------------\n\nTITLE: Iterating: Displaying References for All Bloq Classes\nDESCRIPTION: This code iterates through all `bloq_classes` and their corresponding references (stored in the `references` dictionary) and calls the `show_references` function to display the references for each class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor bloq_cls in bloq_classes:\n    show_references(bloq_cls, references[bloq_cls])\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientState Call Graph\nDESCRIPTION: Generates and displays the call graph for `phase_gradient_state`. It uses `ignore_split_join` from `qualtran.resource_counting.generalizers` to simplify the graph by ignoring split and join operations. Also displays the counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nphase_gradient_state_g, phase_gradient_state_sigma = phase_gradient_state.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(phase_gradient_state_g)\nshow_counts_sigma(phase_gradient_state_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and related modules\nDESCRIPTION: Imports necessary modules from Qualtran for defining and visualizing quantum circuits and gates. Also imports standard libraries like typing, numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/identity.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Instantiate TextbookQPE with standard deviation\nDESCRIPTION: Demonstrates how to instantiate TextbookQPE using a symbolic variable for standard deviation (epsilon) and ZPowGate as the unitary operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.basic_gates import ZPowGate\nfrom qualtran.bloqs.phase_estimation import RectangularWindowState, TextbookQPE\n\ntheta = sympy.Symbol('theta')\nepsilon = sympy.symbols('epsilon')\ntextbook_qpe_from_standard_deviation_eps = TextbookQPE(\n    ZPowGate(exponent=2 * theta), RectangularWindowState.from_standard_deviation_eps(epsilon)\n)\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph of SwapWithZero\nDESCRIPTION: Generates and displays the call graph and sigma counts of the standard SwapWithZero instance. The ignore_split_join generalizer is used.  This helps analyze the resource costs and internal operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nswz_g, swz_sigma = swz.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(swz_g)\nshow_counts_sigma(swz_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of Equals in Qualtran\nDESCRIPTION: This snippet generates and displays the call graph for `Equals` using `call_graph` and `show_call_graph`. The `ignore_split_join` generalizer is used for resource counting. This helps in analyzing the resource requirements of the comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nequals_g, equals_sigma = equals.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(equals_g)\nshow_counts_sigma(equals_sigma)\n```\n\n----------------------------------------\n\nTITLE: MultiControlX Definition\nDESCRIPTION: Imports the `MultiControlX` class from `qualtran.bloqs.mcmt`. This gate implements a Toffoli (multi-controlled X) gate.  The number of controls and their values are specified by the `cvs` parameter.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mcmt import MultiControlX\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying the call graph of ZPowConstViaPhaseGradient\nDESCRIPTION: Generates and displays the call graph and resource counts sigma of a `ZPowConstViaPhaseGradient` instance, using `qualtran.resource_counting.generalizers.ignore_split_join` to simplify the graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/zpow_via_phase_gradient.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nzpow_const_via_phase_grad_g, zpow_const_via_phase_grad_sigma = zpow_const_via_phase_grad.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(zpow_const_via_phase_grad_g)\nshow_counts_sigma(zpow_const_via_phase_grad_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for GF2Addition\nDESCRIPTION: Generate a call graph for `gf16_addition` using `call_graph` with a maximum depth of 1 and a generalizer that ignores split/join operations. Then, visualize the call graph and the associated sigma counts using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_addition.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf16_addition_g, gf16_addition_sigma = gf16_addition.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf16_addition_g)\nshow_counts_sigma(gf16_addition_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiate Subtract gate with large size\nDESCRIPTION: Creates an instance of the `Subtract` gate with a large size of 64 qubits. This demonstrates the gate's scalability.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsub_large = Subtract(QInt(bitsize=64))\n```\n\n----------------------------------------\n\nTITLE: Instantiate CYGate (Python)\nDESCRIPTION: This snippet demonstrates how to create an instance of the `CYGate` by controlling the YGate. It also uses an assert statement to confirm that the resulting controlled gate is an instance of `CYGate`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncy_gate = YGate().controlled()\nassert isinstance(cy_gate, CYGate)\n```\n\n----------------------------------------\n\nTITLE: Instantiate SelectTFirstQuantization in Python\nDESCRIPTION: Creates an instance of the `SelectTFirstQuantization` class with specified parameters `num_bits_p` and `eta`. This configures the selection of the kinetic energy operator for the first quantization approach.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 5\neta = 10\n\nselect_t = SelectTFirstQuantization(num_bits_p=num_bits_p, eta=eta)\n```\n\n----------------------------------------\n\nTITLE: Display bloqs with the slowest tensor network construction time\nDESCRIPTION: Displays Bloq examples with the slowest tensor network construction time.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Slowest tn_dur\ndf.sort_values(by='tn_dur', ascending=False).head()\n```\n\n----------------------------------------\n\nTITLE: Showing LessThanEqual Bloqs\nDESCRIPTION: This snippet displays a graphical representation of the `leq` and `leq_symb` bloqs, providing visual representations of the quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([leq, leq_symb],\n           ['`leq`', '`leq_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate Subtract gate with symbolic size\nDESCRIPTION: Creates an instance of the `Subtract` gate with a symbolic size 'n'. This allows for representing the gate with a variable number of qubits. Requires the `sympy` library for symbolic representation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nsub_symb = Subtract(QInt(bitsize=n))\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph of SelectUVFirstQuantization in Python\nDESCRIPTION: Generates and displays the call graph and resource counts for the `select_uv` bloq. `ignore_split_join` is used as the generalizer to simplify the graph and the maximum depth is set to 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nselect_uv_g, select_uv_sigma = select_uv.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(select_uv_g)\nshow_counts_sigma(select_uv_sigma)\n```\n\n----------------------------------------\n\nTITLE: Visualize PolynmomialEvaluationInverseSquareRoot\nDESCRIPTION: This snippet visualizes the `PolynmomialEvaluationInverseSquareRoot` bloq's graphical signature using `show_bloqs` from `qualtran.drawing`. It displays the bloq with the label '`poly_inv_sqrt`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([poly_inv_sqrt],\n           ['`poly_inv_sqrt`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of SingleFactorizationOneBody\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `sf_one_body` bloq. It provides a visual representation of the bloq and its inputs/outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sf_one_body],\n           ['`sf_one_body`'])\n```\n\n----------------------------------------\n\nTITLE: Extracting: Reference Titles\nDESCRIPTION: This snippet extracts the title associated with each URL from the references.  It creates a dictionary called `titles` that maps each reference URL to its corresponding title.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# TODO: check for disagreement\ntitles = {ref.url: ref.title for refs in references.values() for ref in refs if hasattr(ref, 'url')}\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of ComplexGivensRotationByPhaseGradient\nDESCRIPTION: Generates and displays the graphical signature of the `cplx_givens` bloq using the `show_bloqs` function. This provides a visual representation of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cplx_givens],\n           ['`cplx_givens`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature visualization\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to visualize the graphical signature of the `linear_combination_block_encoding` instance. This provides a visual representation of the bloq and its input/output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/linear_combination.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([linear_combination_block_encoding],\n           ['`linear_combination_block_encoding`'])\n```\n\n----------------------------------------\n\nTITLE: GF2AddK Class Definition\nDESCRIPTION: Defines the `GF2AddK` class that performs in-place addition of a classical constant $k$ to a quantum register $|x\\rangle$ storing elements from GF($2^m$). The addition is implemented as a component-wise XOR using X gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_add_k.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2AddK\n```\n\n----------------------------------------\n\nTITLE: Visualize SelectFirstQuantization bloq\nDESCRIPTION: This snippet utilizes the `show_bloqs` function from `qualtran.drawing` to display a graphical representation of the `sel_first_quant` bloq. The visualization helps in understanding the structure and functionality of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sel_first_quant],\n           ['`sel_first_quant`'])\n```\n\n----------------------------------------\n\nTITLE: Endianness example with QUInt.to_bits in Qualtran\nDESCRIPTION: This snippet demonstrates the big-endian bit convention used by Qualtran data types using the `QUInt.to_bits` method. It converts the hexadecimal value 0x30 to its bit representation using an 8-bit `QUInt`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nQUInt(8).to_bits(x=0x30)\n```\n\n----------------------------------------\n\nTITLE: Visualizing CNOT Gate\nDESCRIPTION: This snippet uses the `show_bloqs` function to generate a graphical representation of the `cnot` instance. This visualization helps in understanding the gate's action and its place within a quantum circuit diagram.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/cnot.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cnot],\n           ['`cnot`'])\n```\n\n----------------------------------------\n\nTITLE: AddScaledValIntoPhaseReg Definition\nDESCRIPTION: Defines the `AddScaledValIntoPhaseReg` Bloq, which performs optimized quantum-quantum addition into a phase gradient register, scaled by a constant gamma. It multiplies the input 'x' by 'gamma' and adds the result to the phase gradient register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import AddScaledValIntoPhaseReg\n```\n\n----------------------------------------\n\nTITLE: Visualize KineticEnergy\nDESCRIPTION: This snippet visualizes the `KineticEnergy` bloq's graphical signature using `show_bloqs` from `qualtran.drawing`. It displays the bloq with the label '`kinetic_energy`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([kinetic_energy],\n           ['`kinetic_energy`'])\n```\n\n----------------------------------------\n\nTITLE: PrepareTHC Call Graph\nDESCRIPTION: Generates and displays the call graph for the `PrepareTHC` bloq using `thc_prep.call_graph`. This helps visualize the internal structure and dependencies of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nthc_prep_g, thc_prep_sigma = thc_prep.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(thc_prep_g)\nshow_counts_sigma(thc_prep_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate and display call graph for TextbookQPE\nDESCRIPTION: Generates the call graph for the `textbook_qpe_small` instance, ignoring split/join operations, and displays both the graph and the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ntextbook_qpe_small_g, textbook_qpe_small_sigma = textbook_qpe_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(textbook_qpe_small_g)\nshow_counts_sigma(textbook_qpe_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Create CModAddK instance with symbolic parameters in Python\nDESCRIPTION: Creates an instance of the `CModAddK` class using symbolic parameters 'n', 'm', and 'k' from the sympy library to represent the bitsize, modulus, and constant to add, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nn, m, k = sympy.symbols('n m k')\ncmod_add_k = CModAddK(bitsize=n, mod=m, k=k)\n```\n\n----------------------------------------\n\nTITLE: Summarizing Results for factoring\nDESCRIPTION: This snippet summarizes the results of the Bloq report card for packages starting with `factoring`. It uses `report_card.query('package.str.startswith(\"factoring\")')` to filter the report card data. The filtered report card is then passed to `summarize_results()` for summarization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsummarize_results(report_card.query('package.str.startswith(\"factoring\")'))\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloq Report Card for chemistry\nDESCRIPTION: This snippet displays the Bloq report card specifically for packages starting with `chemistry`. It uses `report_card.query('package.str.startswith(\"chemistry\")')` to filter the report card data. The filtered report card is then passed to `show_bloq_report_card()` for display.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq_report_card(report_card.query('package.str.startswith(\"chemistry\")'))\n```\n\n----------------------------------------\n\nTITLE: UniformSuperpositionTHC Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `UniformSuperpositionTHC` bloq using the `show_bloqs` function from `qualtran.drawing`. This visual representation helps understand the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([thc_uni],\n           ['`thc_uni`'])\n```\n\n----------------------------------------\n\nTITLE: Import PolynmomialEvaluationInverseSquareRoot\nDESCRIPTION: This snippet imports the `PolynmomialEvaluationInverseSquareRoot` class from the `qualtran.bloqs.chemistry.trotter.grid_ham.inverse_sqrt` module. This class is used to evaluate a polynomial approximation to the inverse square root.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.grid_ham.inverse_sqrt import PolynmomialEvaluationInverseSquareRoot\n```\n\n----------------------------------------\n\nTITLE: GF2MulK Bloq Definition\nDESCRIPTION: Defines the `GF2MulK` bloq for multiplying by a constant in GF(2^m). It takes a constant and a Galois field as parameters and multiplies the input polynomial by this constant modulo the irreducible polynomial defining the field.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2MulK\n```\n\n----------------------------------------\n\nTITLE: SquareRealNumber Example Instance\nDESCRIPTION: Creates an instance of the `SquareRealNumber` class with a specified bitsize. This bloq implements $|a\\rangle|0\\rangle \\rightarrow |a\\rangle|a^2\\rangle$. The real numbers are assumed to be in the range [0, 1).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nsquare_real_number = SquareRealNumber(bitsize=10)\n```\n\n----------------------------------------\n\nTITLE: Verifying Copied Bloq Indices - Python\nDESCRIPTION: Demonstrates how to verify that a copied `CompositeBloq` has different bloq instance indices by iterating through the connections of the original and copied bloqs after monkey-patching the `BloqBuilder`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ncbloq = TestParallelCombo().decompose_bloq()\n\nwith hacked_bb_init():\n    cbloq2 = cbloq.copy()\n\nfor cxn1, cxn2 in zip(cbloq.connections, cbloq2.connections):\n    print(cxn1)\n    print(cxn2)\n    print()\n```\n\n----------------------------------------\n\nTITLE: Installing Qualtran from GitHub using pip (shell)\nDESCRIPTION: This snippet demonstrates how to install the latest version of Qualtran directly from the main branch on GitHub using pip. Prerequisites: pip, git, and a Python environment.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install git+https://github.com/quantumlib/Qualtran\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of RzViaPhaseGradient\nDESCRIPTION: This code snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `rz_via_phase_gradient` object. This visualization helps understand the inputs, outputs, and overall structure of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/rz_via_phase_gradient.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([rz_via_phase_gradient],\n           ['`rz_via_phase_gradient`'])\n```\n\n----------------------------------------\n\nTITLE: Showing a SingleQubitCompare Bloq\nDESCRIPTION: This snippet displays a graphical representation of the `sq_cmp` bloq, providing a visual representation of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sq_cmp],\n           ['`sq_cmp`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of GF2MulK Instances\nDESCRIPTION: Shows the graphical signatures of the two `GF2MulK` instances: `gf2_multiply_by_constant` and `gf2_poly_multiply_by_constant`. It helps visualize the inputs and outputs of these bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf2_multiply_by_constant, gf2_poly_multiply_by_constant],\n           ['`gf2_multiply_by_constant`', '`gf2_poly_multiply_by_constant`'])\n```\n\n----------------------------------------\n\nTITLE: Displaying a Qualtran Bloq's Call Graph with show_call_graph (Python)\nDESCRIPTION: This code snippet demonstrates how to display the call graph of a Qualtran bloq using the `show_call_graph` function. It first imports the necessary modules, creates an instance of `TestBloqWithCallGraph`, obtains the call graph from the bloq, and then calls `show_call_graph` to visualize the graph. This requires the qualtran library to be installed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/drawing/drawing_call_graph.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.for_testing.with_call_graph import TestBloqWithCallGraph\nfrom qualtran.drawing import show_call_graph\n\nbloq = TestBloqWithCallGraph()\ncall_graph, _ = bloq.call_graph()\nshow_call_graph(call_graph)\n```\n\n----------------------------------------\n\nTITLE: Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph for the `to_contg_index` bloq, showing the dependencies and interactions within the bloq. The `ignore_split_join` generalizer is used to simplify the graph by ignoring split and join operations. It also shows the counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/contiguous_index.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nto_contg_index_g, to_contg_index_sigma = to_contg_index.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(to_contg_index_g)\nshow_counts_sigma(to_contg_index_sigma)\n```\n\n----------------------------------------\n\nTITLE: Call Graph of Symbolic SimpleGuidingState\nDESCRIPTION: This snippet generates and displays the call graph for the symbolic `SimpleGuidingState` instance.  It uses `call_graph` method with `ignore_split_join` generalizer for resource counting and visualizes the call graph and resource counts using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsimple_guiding_state_symb_g, simple_guiding_state_symb_sigma = simple_guiding_state_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(simple_guiding_state_symb_g)\nshow_counts_sigma(simple_guiding_state_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: InvertRealNumber Example Instance\nDESCRIPTION: Creates an instance of the `InvertRealNumber` class with specified bitsize and number of fractional bits. This bloq implements $|a\\rangle|0\\rangle \\rightarrow |a\\rangle|1/a\\rangle$ where $a \\ge 1$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ninvert_real_number = InvertRealNumber(bitsize=10, num_frac=7)\n```\n\n----------------------------------------\n\nTITLE: Summarizing Results for chemistry\nDESCRIPTION: This snippet summarizes the results of the Bloq report card for packages starting with `chemistry`. It uses `report_card.query('package.str.startswith(\"chemistry\")')` to filter the report card data. The filtered report card is then passed to `summarize_results()` for summarization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsummarize_results(report_card.query('package.str.startswith(\"chemistry\")'))\n```\n\n----------------------------------------\n\nTITLE: Import necessary libraries\nDESCRIPTION: This snippet imports required modules from the `qualtran` library and other common libraries such as `typing`, `numpy`, `sympy`, and `cirq`. These libraries are used for building quantum circuits and defining custom quantum operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/linear_combination.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Analyze and display Identity gate call graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the symbolic identity gate (`identity_symb`). It ignores split/join operations during call graph generation using `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/identity.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nidentity_symb_g, identity_symb_sigma = identity_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(identity_symb_g)\nshow_counts_sigma(identity_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Decomposition of Adjointed TestSerialCombo in Qualtran\nDESCRIPTION: This example demonstrates how the decomposition of an adjointed bloq (specifically `TestSerialCombo`) is obtained using `decompose_bloq()`. The decompositions of both the original and adjointed bloq are visualized using `show_bloq`. It relies on `TestSerialCombo` from `qualtran.bloqs.for_testing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# The decomposition is the adjoint of the wrapped bloq's decomposition\nshow_bloq(bloq.decompose_bloq())\nshow_bloq(bloq.adjoint().decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: Product Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `Product` instance, using the `ignore_split_join` generalizer to simplify the graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nproduct_g, product_sigma = product.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(product_g)\nshow_counts_sigma(product_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Unitary Class\nDESCRIPTION: This snippet imports the `Unitary` class from the `qualtran.bloqs.block_encoding` module. This import is necessary to use the `Unitary` class for creating block encodings of unitary operators.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/unitary.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import Unitary\n```\n\n----------------------------------------\n\nTITLE: Holevo Variance Calculation\nDESCRIPTION: The `holevo_variance` function calculates the Holevo variance of a set of phase estimates, which provides a measure of the uncertainty in the estimated phase. This is calculated based on cosine values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef holevo_variance(thetas):\n    mu = np.mean(np.cos(thetas - theta))\n    return 1 / mu**2 - 1\n```\n\n----------------------------------------\n\nTITLE: Adjointed TStateMaker Decomposition in Qualtran\nDESCRIPTION: This example visualizes the decomposition of the adjoint of the `TStateMaker` bloq, demonstrating the application of the default adjoint fallback. It uses the `adjoint()` method and `decompose_bloq()` to obtain and visualize the adjoint's decomposition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Use the default fallback for `.adjoint()`\nshow_bloq(TStateMaker().adjoint().decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature using show_bloqs\nDESCRIPTION: Generates a graphical representation of the `xor` and `xor_symb` bloqs using the `show_bloqs` function from `qualtran.drawing`. This helps visualize the quantum circuit elements and their connections.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([xor, xor_symb],\n           ['`xor`', '`xor_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Import BlackBoxPrepare from qualtran\nDESCRIPTION: This snippet imports the `BlackBoxPrepare` class from `qualtran.bloqs.state_preparation.black_box_prepare`. `BlackBoxPrepare` offers a black-box interface to Prepare bloqs, combining descriptive selection registers into a single 'selection' register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.state_preparation.black_box_prepare import BlackBoxPrepare\n```\n\n----------------------------------------\n\nTITLE: Musical Score Visualization for PrepareTHC\nDESCRIPTION: Generates and displays a musical score visualization of the `PrepareTHC` bloq. This provides a detailed view of the quantum circuit's operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing.musical_score import draw_musical_score, get_musical_score_data\n\n\nmsd = get_musical_score_data(thc_prep.decompose_bloq())\nfig, ax = draw_musical_score(msd)\nfig.set_size_inches(10, 10)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures for LCUBlockEncoding\nDESCRIPTION: This snippet uses the `show_bloqs` function to display the graphical signatures of `lcu_block` and `black_box_lcu_block`, providing visual representations of their interfaces and functionalities.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lcu_block, black_box_lcu_block],\n           ['`lcu_block`', '`black_box_lcu_block`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature using show_bloqs for BitwiseNot\nDESCRIPTION: Generates a graphical representation of the `bitwise_not` and `bitwise_not_symb` bloqs using the `show_bloqs` function. This visualizes the bitwise NOT gate and its symbolic variant.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([bitwise_not, bitwise_not_symb],\n           ['`bitwise_not`', '`bitwise_not_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules\nDESCRIPTION: Imports necessary modules from qualtran, typing, numpy, sympy, and cirq to define and work with quantum circuits and data structures.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/two_bit_ffft.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Adding CompositeBloq with `bb.add_from` (First Instance) - Python\nDESCRIPTION: Demonstrates using `bb.add_from` on the *first* instance of `TestParallelCombo`. This demonstrates how it can be used regardless of position in the sequence.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# `add_from` on first one\nbb = BloqBuilder()\nstuff = bb.add_register('stuff', 3)\nstuff, = bb.add_from(TestParallelCombo(), reg=stuff)\nstuff, = bb.add_t(TestParallelCombo(), reg=stuff)\nbloq = bb.finalize(stuff=stuff)\n\nshow_bloq(bloq)\n```\n\n----------------------------------------\n\nTITLE: IsingXUnitary Import Statement\nDESCRIPTION: Imports the `IsingXUnitary` class from the `qualtran.bloqs.chemistry.trotter.ising` module.  This class implements the unitary evolution operator corresponding to the X interaction term in the Ising Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.ising import IsingXUnitary\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: Imports necessary modules from Qualtran, typing, NumPy, and Cirq to define and use quantum building blocks and mathematical operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_add_k.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph of MultiplexedCSwap\nDESCRIPTION: Generates and displays the call graph and sigma counts for the MultiplexedCSwap instance.  The ignore_split_join generalizer simplifies the call graph for easier analysis.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmultiplexed_cswap_g, multiplexed_cswap_sigma = multiplexed_cswap.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(multiplexed_cswap_g)\nshow_counts_sigma(multiplexed_cswap_sigma)\n```\n\n----------------------------------------\n\nTITLE: Symbolic Permutation Definition\nDESCRIPTION: Defines a symbolic `Permutation` instance with symbolic parameters N and k, representing the size of the permutation and the shape of the cycles, respectively. This allows creating more general and parameterized permutations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.symbolics import Shaped\n\nN, k = sympy.symbols(\"N k\", positive=True, integer=True)\npermutation_symb = Permutation(N, Shaped((k,)))\n```\n\n----------------------------------------\n\nTITLE: Display Signed Integer to Two's Complement Bloq\nDESCRIPTION: Displays the graphical representation of the `signed_to_twos` Bloq using `show_bloqs` function from `qualtran.drawing`. This visual representation helps understand the structure and functionality of the Bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([signed_to_twos],\n           ['`signed_to_twos`'])\n```\n\n----------------------------------------\n\nTITLE: Show graphical signatures of Identity gates\nDESCRIPTION: Generates and displays the graphical representations of the identity gates created in the previous steps.  It visualizes the `identity_symb`, `identity`, and `identity_n` bloqs using `show_bloqs` function.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/identity.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([identity_symb, identity, identity_n],\n           ['`identity_symb`', '`identity`', '`identity_n`'])\n```\n\n----------------------------------------\n\nTITLE: PrepareIdentity Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma for `prepare_identity`. The `ignore_split_join` generalizer simplifies the graph, and `max_depth` limits the depth of the call graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprepare_identity_g, prepare_identity_sigma = prepare_identity.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prepare_identity_g)\nshow_counts_sigma(prepare_identity_sigma)\n```\n\n----------------------------------------\n\nTITLE: Controlling XGate with QInt and Custom Control Value\nDESCRIPTION: This code shows how to control an `XGate` with a `QInt` and a specific control value (255).  This does not result in a `CNOT` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QInt\nc255x = XGate().controlled(CtrlSpec(QInt(8), cvs=255))\nshow_bloq(c255x, type='musical_score')\nprint(c255x)\n```\n\n----------------------------------------\n\nTITLE: Show PlusState Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `PlusState` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([plus_state],\n           ['`plus_state`'])\n```\n\n----------------------------------------\n\nTITLE: Show ZeroEffect Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `ZeroEffect` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([zero_effect],\n           ['`zero_effect`'])\n```\n\n----------------------------------------\n\nTITLE: SimpleGuidingState Definition\nDESCRIPTION: This snippet imports the `SimpleGuidingState` class from the `qualtran.bloqs.optimization.k_xor_sat` module. The `SimpleGuidingState` bloq prepares a guiding state for a kXOR instance with Kikuchi parameter \\( \\ell = k \\).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.optimization.k_xor_sat import SimpleGuidingState\n```\n\n----------------------------------------\n\nTITLE: Show MinusEffect Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `MinusEffect` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([minus_effect],\n           ['`minus_effect`'])\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules for tensor report\nDESCRIPTION: This snippet imports the required modules for generating the tensor report card. It imports `get_bloq_examples` to retrieve bloq examples and `report_on_tensors` and `ExecuteWithTimeout` for tensor simulation analysis.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran_dev_tools.bloq_finder import get_bloq_examples\nfrom qualtran_dev_tools.tensor_report_card import report_on_tensors, ExecuteWithTimeout\n```\n\n----------------------------------------\n\nTITLE: Create SwapWithZero Instance\nDESCRIPTION: Creates an instance of the SwapWithZero class with selection bitsizes of 8, a target bitsize of 32, and 4 target registers. This sets up a specific swap configuration for use in quantum algorithms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nswz = SwapWithZero(selection_bitsizes=8, target_bitsize=32, n_target_registers=4)\n```\n\n----------------------------------------\n\nTITLE: Import ComplexGivensRotationByPhaseGradient\nDESCRIPTION: Imports the `ComplexGivensRotationByPhaseGradient` class from the `qualtran.bloqs.chemistry.quad_fermion.givens_bloq` module. This class implements a complex-valued Givens rotation using a phase gradient.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.quad_fermion.givens_bloq import ComplexGivensRotationByPhaseGradient\n```\n\n----------------------------------------\n\nTITLE: Split Bloq Definition\nDESCRIPTION: Defines the `Split` bloq, which splits a register of a given data type (`dtype`) into an array of `QBit`s. This is useful for operating on individual bits of a quantum integer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import Split\n```\n\n----------------------------------------\n\nTITLE: Allocate Bloq Definition\nDESCRIPTION: Defines the `Allocate` bloq, which allocates an `n` bit register of a specified quantum data type.  It can optionally represent a borrowing operation where allocated qubits can be dirty.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import Allocate\n```\n\n----------------------------------------\n\nTITLE: Displaying the graphical representation of the bloq\nDESCRIPTION: This code snippet uses `show_bloqs` to display the graphical representation of the `qft_phase_gradient_small` bloq, providing a visual overview of its structure and connections.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_phase_gradient.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([qft_phase_gradient_small],\n           ['`qft_phase_gradient_small`'])\n```\n\n----------------------------------------\n\nTITLE: Show graphical signatures of TextbookQPE instances\nDESCRIPTION: Displays the graphical signatures of different TextbookQPE instances created earlier, showing their structure and connectivity.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([textbook_qpe_small, textbook_qpe_using_m_bits, textbook_qpe_from_standard_deviation_eps, textbook_qpe_from_precision_and_delta],\n           ['`textbook_qpe_small`', '`textbook_qpe_using_m_bits`', '`textbook_qpe_from_standard_deviation_eps`', '`textbook_qpe_from_precision_and_delta`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate KineticEnergy\nDESCRIPTION: This snippet instantiates the `KineticEnergy` class with specific parameters for the number of electrons (12) and the number of grid points (2 * 8 + 1).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nnelec = 12\nngrid_x = 2 * 8 + 1\nkinetic_energy = KineticEnergy(nelec, ngrid_x)\n```\n\n----------------------------------------\n\nTITLE: Instantiate PotentialEnergy\nDESCRIPTION: This snippet instantiates the `PotentialEnergy` class with specific parameters for the number of electrons (12) and the number of grid points (2 * 8 + 1).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nnelec = 12\nngrid_x = 2 * 8 + 1\npotential_energy = PotentialEnergy(nelec, ngrid_x)\n```\n\n----------------------------------------\n\nTITLE: Import PrepareFirstQuantizationWithProj\nDESCRIPTION: This code imports the `PrepareFirstQuantizationWithProj` class from the `qualtran.bloqs.chemistry.pbc.first_quantization.projectile` module. This class is used for state preparation for the first quantized chemistry Hamiltonian with a quantum projectile.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.projectile import PrepareFirstQuantizationWithProj\n```\n\n----------------------------------------\n\nTITLE: Import GF2PolyAddK\nDESCRIPTION: This snippet imports the `GF2PolyAddK` class from `qualtran.bloqs.gf_poly_arithmetic`. This class is used for adding a constant polynomial to a quantum register storing another polynomial over GF(2^m).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add_k.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_poly_arithmetic import GF2PolyAddK\n```\n\n----------------------------------------\n\nTITLE: Import QubitizationWalkOperator\nDESCRIPTION: This snippet imports the `QubitizationWalkOperator` class from the `qualtran.bloqs.qubitization` module. This class is used to construct a Szegedy quantum walk operator using LCU oracles SELECT and PREPARE.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.qubitization import QubitizationWalkOperator\n```\n\n----------------------------------------\n\nTITLE: Import LPRSInterimPrep from qualtran.bloqs\nDESCRIPTION: This code imports the `LPRSInterimPrep` class from the `qualtran.bloqs.phase_estimation.lp_resource_state` module. This bloq is used to prepare an intermediate resource state for amplitude amplification.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation.lp_resource_state import LPRSInterimPrep\n```\n\n----------------------------------------\n\nTITLE: Import SelectTFirstQuantization in Python\nDESCRIPTION: Imports the `SelectTFirstQuantization` class from the `qualtran.bloqs.chemistry.pbc.first_quantization.select_t` module. This class represents the SELECT operation for the kinetic energy operator in the first quantized chemistry Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.select_t import SelectTFirstQuantization\n```\n\n----------------------------------------\n\nTITLE: Permutation Class Definition\nDESCRIPTION: Defines the `Permutation` class, which applies a permutation to basis states. This permutation can be constructed from a dense permutation mapping or a partial permutation mapping. The class decomposes the permutation into cycles and applies them.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.permutation import Permutation\n```\n\n----------------------------------------\n\nTITLE: Symbolic Xor example instantiation\nDESCRIPTION: Demonstrates the instantiation of the `Xor` class with a symbolic `QAny` data type. The size of the register is defined by the sympy symbol 'n', allowing for parameterized circuit generation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nxor_symb = Xor(QAny(sympy.Symbol(\"n\")))\n```\n\n----------------------------------------\n\nTITLE: Initializing LinearDepthHalfLessThanEqual in Qualtran\nDESCRIPTION: This snippet demonstrates how to initialize the `LinearDepthHalfLessThanEqual` comparator with a `QUInt` of size 3. It is used to check if one quantum integer is less than or equal to another.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nlineardepthhalflessthanequal_small = LinearDepthHalfLessThanEqual(QUInt(3))\n```\n\n----------------------------------------\n\nTITLE: GF2MulViaKaratsuba Graphical Signature\nDESCRIPTION: Generates and displays a graphical signature of the `GF2MulViaKaratsuba` object using `qualtran.drawing.show_bloqs`.  This visualization provides an overview of the quantum circuit structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf2mulviakaratsuba],\n           ['`gf2mulviakaratsuba`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate GF2Addition with a Symbolic Size\nDESCRIPTION: Instantiate the `GF2Addition` class with a symbolic size `m` using the `sympy` library. This allows for representing addition over GF($2^m$) where `m` is a symbolic variable.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_addition.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nm = sympy.Symbol('m')\ngf2_addition_symbolic = GF2Addition(m)\n```\n\n----------------------------------------\n\nTITLE: Cirq Implementation of Controlled Hadamard Gate (Python)\nDESCRIPTION: Provides a Cirq implementation of the controlled Hadamard gate using `cirq.decompose_multi_controlled_rotation`. This shows how to express the gate using Cirq primitives, even though the Qualtran bloq itself is atomic.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncircuit = cirq.Circuit(cirq.decompose_multi_controlled_rotation(\n    cirq.unitary(cirq.H),\n    controls=[cirq.NamedQubit('ctrl')],\n    target=cirq.NamedQubit('q'),\n))\ncircuit\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counting for `ECWindowAddR`\nDESCRIPTION: Generates and displays the call graph and resource counts for the `ECWindowAddR` instance `ec_window_add_r_small`. The call graph displays the sub-bloqs up to depth 1, using the `ignore_split_join` generalizer. The resource counts are stored in `ec_window_add_r_small_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nec_window_add_r_small_g, ec_window_add_r_small_sigma = ec_window_add_r_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ec_window_add_r_small_g)\nshow_counts_sigma(ec_window_add_r_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import necessary libraries for Qualtran\nDESCRIPTION: Imports required modules from the `qualtran` library for defining quantum circuits, registers, and drawing tools, along with standard Python libraries for typing, numerical computation, and symbolic mathematics.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import Statements for State Preparation\nDESCRIPTION: This code imports necessary modules from the qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register for defining quantum blocks and registers. It also imports typing, numpy, sympy, and cirq for various computations and quantum circuit manipulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Create PlusState Instance\nDESCRIPTION: Creates an instance of the `PlusState` bloq, representing the |+> quantum state. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nplus_state = PlusState()\n```\n\n----------------------------------------\n\nTITLE: AddScaledValIntoPhaseReg Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature for `add_scaled_val_into_phase_reg` using `show_bloqs` from `qualtran.drawing`. It visualizes the inputs and outputs of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([add_scaled_val_into_phase_reg],\n           ['`add_scaled_val_into_phase_reg`'])\n```\n\n----------------------------------------\n\nTITLE: Import the Negate bloq\nDESCRIPTION: Imports the `Negate` class from the `qualtran.bloqs.arithmetic` module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/negate.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Negate\n```\n\n----------------------------------------\n\nTITLE: AutoPartition Example with Swap Bloq\nDESCRIPTION: Demonstrates the instantiation of `AutoPartition` with a `Controlled(Swap(1))` bloq. It shows how to map registers to specific parts of the bloq's signature, using a tuple to specify which register parts ('ctrl', 'x', 'y') correspond to which registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Controlled, CtrlSpec\nfrom qualtran.bloqs.basic_gates import Swap\n\nbloq = Controlled(Swap(1), CtrlSpec())\nauto_partition = AutoPartition(\n    bloq, [(Register('x', QAny(2)), ['ctrl', 'x']), (Register('y', QAny(1)), ['y'])]\n)\n```\n\n----------------------------------------\n\nTITLE: Flame Graph of SelectTHC\nDESCRIPTION: Generates and displays a flame graph visualization of the `SelectTHC` bloq using `show_flame_graph`. This allows for performance analysis and identification of computational hotspots within the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_flame_graph\nshow_flame_graph(thc_sel)\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Phase Estimation Resource States\nDESCRIPTION: This code snippet imports necessary modules from Qualtran, including Bloq, CompositeBloq, Signature, and Register types, as well as drawing and utility functions. It also imports standard Python libraries such as typing, numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Count for DoubleFactorizationOneBody\nDESCRIPTION: This code generates and displays the call graph for the `df_one_body` bloq, visualizing the interdependencies of sub-bloqs within it.  It also shows the resource counts sigma. The `ignore_split_join` generalizer is used to simplify the call graph by ignoring split and join operations, which are often considered overhead.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ndf_one_body_g, df_one_body_sigma = df_one_body.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(df_one_body_g)\nshow_counts_sigma(df_one_body_sigma)\n```\n\n----------------------------------------\n\nTITLE: BlackBoxSelect Example Instance\nDESCRIPTION: This snippet creates an instance of `BlackBoxSelect` using a `SelectHubbard` object. It demonstrates how to wrap a specific `SelectOracle` implementation with the black box interface.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.hubbard_model.qubitization import SelectHubbard\n\nselect = SelectHubbard(2, 2)\nblack_box_select = BlackBoxSelect(select=select)\n```\n\n----------------------------------------\n\nTITLE: Visualize NewtonRaphsonApproxInverseSquareRoot\nDESCRIPTION: This snippet visualizes the `NewtonRaphsonApproxInverseSquareRoot` bloq's graphical signature using `show_bloqs` from `qualtran.drawing`. It displays the bloq with the label '`nr_inv_sqrt`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([nr_inv_sqrt],\n           ['`nr_inv_sqrt`'])\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph for RectangularWindowState\nDESCRIPTION: Generates and displays the call graph for the `rectangular_window_state_small` instance.  It uses `call_graph` with `max_depth=1` and `ignore_split_join` generalizer to simplify the graph. The graph and associated counts are then displayed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nrectangular_window_state_small_g, rectangular_window_state_small_sigma = rectangular_window_state_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(rectangular_window_state_small_g)\nshow_counts_sigma(rectangular_window_state_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Importing GreaterThan Bloq\nDESCRIPTION: This line imports the `GreaterThan` class from the `qualtran.bloqs.arithmetic` module. The `GreaterThan` bloq is used to compare two integers and determine if the first integer is greater than the second.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import GreaterThan\n```\n\n----------------------------------------\n\nTITLE: Create Multi-Dimensional SwapWithZero Instance\nDESCRIPTION: Creates a multi-dimensional instance of SwapWithZero. `selection_bitsizes` and `n_target_registers` are tuples, specifying the dimensions of the selection register and the target register array, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nswz_multi_dimensional = SwapWithZero(\n    selection_bitsizes=(4, 3), target_bitsize=2, n_target_registers=(15, 5)\n)\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasing Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `HammingWeightPhasing` bloq using `show_bloqs`. This provides a visual representation of the bloq's inputs, outputs, and internal structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([hamming_weight_phasing],\n           ['`hamming_weight_phasing`'])\n```\n\n----------------------------------------\n\nTITLE: Initializing LinearDepthHalfGreaterThanEqual in Qualtran\nDESCRIPTION: This snippet demonstrates how to initialize the `LinearDepthHalfGreaterThanEqual` comparator with a `QUInt` of size 3.  The `LinearDepthHalfGreaterThanEqual` comparator checks if one quantum integer is greater than or equal to another.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nlineardepthhalfgreaterthanequal_small = LinearDepthHalfGreaterThanEqual(QUInt(3))\n```\n\n----------------------------------------\n\nTITLE: Instantiating QFTTextBook with a Numerical Bitsize\nDESCRIPTION: Creates an instance of the `QFTTextBook` class with a fixed `bitsize` of 3, representing a QFT operating on 3 qubits. This is a concrete instantiation with a specific number of qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_text_book.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nqft_text_book = QFTTextBook(3)\n```\n\n----------------------------------------\n\nTITLE: Using the Default Fallback for Controlled Bloqs\nDESCRIPTION: This snippet demonstrates the default fallback mechanism for creating controlled bloqs using the `Controlled` meta-bloq when a custom `get_ctrl_system` is not provided. It controls a `TestAtom` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.for_testing import TestAtom\n\natom = TestAtom()\ncatom = atom.controlled()\ncatom\n```\n\n----------------------------------------\n\nTITLE: CModNeg Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `CModNeg` bloq, illustrating its input and output registers. This visualization aids in understanding the controlled modular negation gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cmod_neg],\n           ['`cmod_neg`'])\n```\n\n----------------------------------------\n\nTITLE: MultiplyPolyByOnePlusXk Instance\nDESCRIPTION: Creates an instance of the `MultiplyPolyByOnePlusXk` bloq with `n=5` and `k=3`. This instance multiplies by $(1 + x^3)$ in a polynomial ring of degree 5.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nn = 5\nk = 3\nmultiplypolybyoneplusxk = MultiplyPolyByOnePlusXk(n, k)\n```\n\n----------------------------------------\n\nTITLE: Import LCUBlockEncoding from qualtran\nDESCRIPTION: This snippet imports the `LCUBlockEncoding` class from the `qualtran.bloqs.block_encoding` module. The LCUBlockEncoding class implements a block encoding construction specific to Linear Combination of Unitaries (LCU).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import LCUBlockEncoding\n```\n\n----------------------------------------\n\nTITLE: Import SGate from qualtran.bloqs.basic_gates\nDESCRIPTION: This snippet imports the `SGate` class from the `qualtran.bloqs.basic_gates` module. The `SGate` represents the S quantum gate, which applies a phase of 'i' to the |1> state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import SGate\n```\n\n----------------------------------------\n\nTITLE: AddScaledValIntoPhaseReg Example Instance\nDESCRIPTION: Creates an instance of the `AddScaledValIntoPhaseReg` Bloq with specified data types for the input, scaling factor, and phase register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QFxp\n\nadd_scaled_val_into_phase_reg = AddScaledValIntoPhaseReg(\n    QFxp(2, 2), phase_bitsize=2, gamma=2, gamma_dtype=QFxp(2, 2)\n)\n```\n\n----------------------------------------\n\nTITLE: Drawing LinearDepthHalfGreaterThanEqual bloq\nDESCRIPTION: This code visualizes the `LinearDepthHalfGreaterThanEqual` bloq using `show_bloqs` from `qualtran.drawing`. It helps in understanding the structure of the quantum circuit implementing the comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lineardepthhalfgreaterthanequal_small],\n           ['`lineardepthhalfgreaterthanequal_small`'])\n```\n\n----------------------------------------\n\nTITLE: Validating Bloq Decomposition with Helper - Python\nDESCRIPTION: Demonstrates using the `assert_valid_bloq_decomposition` helper function from `qualtran.testing` to perform all standard validity checks on a bloq's decomposition in one call.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.testing import assert_valid_bloq_decomposition\n\nassert_valid_bloq_decomposition(bloq)\nprint(\"Checks out!\")\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of Phase\nDESCRIPTION: Displays the graphical signature of the `phase_block_encoding` object using `qualtran.drawing.show_bloqs`. This visual representation shows the inputs, outputs, and internal structure of the block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/phase.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([phase_block_encoding],\n           ['`phase_block_encoding`'])\n```\n\n----------------------------------------\n\nTITLE: Creating a GreaterThan instance\nDESCRIPTION: This creates an instance of the `GreaterThan` bloq with `a_bitsize=4` and `b_bitsize=4`, specifying that the two integers to be compared are each represented by 4 bits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngreater_than = GreaterThan(a_bitsize=4, b_bitsize=4)\n```\n\n----------------------------------------\n\nTITLE: SelectHubbard Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `SelectHubbard` instance using `show_bloqs`. This visualization provides a high-level overview of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sel_hubb],\n           ['`sel_hubb`'])\n```\n\n----------------------------------------\n\nTITLE: Deriving Number of Qubits\nDESCRIPTION: This snippet calls `cirq.num_qubits` on the `gate` instance. This showcases how to derive the number of qubits required by the gate from the register definitions within the `GateWithRegisters` subclass.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Number of qubits is derived from registers\ncirq.num_qubits(gate)\n```\n\n----------------------------------------\n\nTITLE: XPowGate Example\nDESCRIPTION: Creates an instance of the `XPowGate` with a specified exponent and precision. This example demonstrates how to instantiate the gate, setting the rotation angle and error tolerance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nx_pow = XPowGate(exponent=0.123, eps=1e-8)\n```\n\n----------------------------------------\n\nTITLE: Importing ScaledChebyshevPolynomial class\nDESCRIPTION: This snippet imports the `ScaledChebyshevPolynomial` class from the `qualtran.bloqs.block_encoding` module. This class is used for block encoding scaled Chebyshev polynomials of a Hermitian matrix.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import ScaledChebyshevPolynomial\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signatures of CModAddK instances in Python\nDESCRIPTION: Uses `show_bloqs` to display the graphical signatures for the symbolic instance `cmod_add_k` and the small constant instance `cmod_add_k_small` of the CModAddK class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cmod_add_k, cmod_add_k_small],\n           ['`cmod_add_k`', '`cmod_add_k_small`'])\n```\n\n----------------------------------------\n\nTITLE: Defining QubitizationQPE Bloq\nDESCRIPTION: This snippet imports the `QubitizationQPE` class from `qualtran.bloqs.phase_estimation`. This class implements the Heisenberg-limited phase estimation circuit for learning the eigenphase of a walk operator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/qubitization_qpe.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation import QubitizationQPE\n```\n\n----------------------------------------\n\nTITLE: Importing the BitwiseNot class\nDESCRIPTION: Imports the `BitwiseNot` class from `qualtran.bloqs.arithmetic`, enabling the use of bitwise NOT gates in quantum circuits. This gate flips the state of each qubit in a register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import BitwiseNot\n```\n\n----------------------------------------\n\nTITLE: UniformSuperpositionTHC Flame Graph\nDESCRIPTION: Generates and displays a flame graph for the `UniformSuperpositionTHC` bloq. This visualization helps identify the most computationally intensive parts of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_flame_graph\nshow_flame_graph(thc_uni)\n```\n\n----------------------------------------\n\nTITLE: Import BlackBoxSelect from qualtran\nDESCRIPTION: This snippet imports the `BlackBoxSelect` class from `qualtran.bloqs.multiplexers.black_box_select`. `BlackBoxSelect` provides a simplified interface to `SelectOracle` implementations by unifying selection registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.multiplexers.black_box_select import BlackBoxSelect\n```\n\n----------------------------------------\n\nTITLE: Initializing LinearDepthHalfGreaterThan in Qualtran\nDESCRIPTION: This snippet demonstrates how to initialize the `LinearDepthHalfGreaterThan` comparator with a `QUInt` of size 3. The `LinearDepthHalfGreaterThan` comparator checks if one quantum integer is greater than another.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nlineardepthhalfgreaterthan_small = LinearDepthHalfGreaterThan(QUInt(3))\n```\n\n----------------------------------------\n\nTITLE: Initializing CLinearDepthGreaterThan in Qualtran\nDESCRIPTION: This snippet demonstrates how to initialize the `CLinearDepthGreaterThan` comparator with a `QInt` of size 5. The `CLinearDepthGreaterThan` comparator determines if a quantum integer is greater than a specified value.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nclineardepthgreaterthan_example = CLinearDepthGreaterThan(QInt(5))\n```\n\n----------------------------------------\n\nTITLE: Controlling a Serial Combo Bloq\nDESCRIPTION: This example demonstrates controlling a `TestSerialCombo` bloq. It shows the decomposition of both the original and controlled bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.for_testing import TestSerialCombo\n\nserial = TestSerialCombo()\ncserial = serial.controlled()\nshow_bloq(serial.decompose_bloq(), type='musical_score')\nshow_bloq(cserial.decompose_bloq(), type='musical_score')\n```\n\n----------------------------------------\n\nTITLE: ZPowGate Example\nDESCRIPTION: Creates an instance of the `ZPowGate` with a specified exponent and precision. This example demonstrates how to instantiate the `ZPowGate` with a specific rotation angle and error tolerance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nz_pow = ZPowGate(exponent=0.123, eps=1e-8)\n```\n\n----------------------------------------\n\nTITLE: Initializing LinearDepthHalfLessThan in Qualtran\nDESCRIPTION: This snippet demonstrates how to initialize the `LinearDepthHalfLessThan` comparator with a `QUInt` of size 3. This comparator checks if one quantum integer is less than another.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nlineardepthhalflessthan_small = LinearDepthHalfLessThan(QUInt(3))\n```\n\n----------------------------------------\n\nTITLE: PrepareTHC Flame Graph\nDESCRIPTION: Generates and displays a flame graph for the `PrepareTHC` bloq. This visualization helps identify the most computationally intensive parts of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_flame_graph\nshow_flame_graph(thc_prep)\n```\n\n----------------------------------------\n\nTITLE: Hadamard Gate Definition (Python)\nDESCRIPTION: Defines the `Hadamard` gate as a Qualtran Bloq, representing a single-qubit gate that converts between the X and Z bases. Includes mathematical representation and register definitions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard\n```\n\n----------------------------------------\n\nTITLE: Showing LessThanConstant Bloqs\nDESCRIPTION: This snippet displays a graphical representation of the `lt_k` and `lt_k_symb` bloqs, providing visual representations of the quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lt_k, lt_k_symb],\n           ['`lt_k`', '`lt_k_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of the Bloqs\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signatures of the `prep_uniform` and `c_prep_uniform` bloqs. This visualization helps understand the structure and connectivity of these quantum circuits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/prepare_uniform_superposition.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prep_uniform, c_prep_uniform],\n           ['`prep_uniform`', '`c_prep_uniform`'])\n```\n\n----------------------------------------\n\nTITLE: Clifford+T circuit for TwoBitCSwap\nDESCRIPTION: Retrieves the Clifford+T circuit implementation of the `TwoBitCSwap` gate using the `to_clifford_t_circuit()` method. This provides a decomposition of the gate into Clifford and T gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncswap_bit.to_clifford_t_circuit()\n```\n\n----------------------------------------\n\nTITLE: Sign Truncation\nDESCRIPTION: Imports the `SignTruncate` class from `qualtran.bloqs.arithmetic.conversions`. This class implements sign truncation, which reduces the bitsize of a value while preserving its sign. This is often used after arithmetic operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.conversions import SignTruncate\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of PrepareZetaState in Python\nDESCRIPTION: Displays the graphical representation of the `prepare_zeta` bloq using `show_bloqs` from `qualtran.drawing`. This provides a visual representation of the quantum circuit that prepares the Zeta state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prepare_zeta],\n           ['`prepare_zeta`'])\n```\n\n----------------------------------------\n\nTITLE: TensorProduct Instance with Specific Properties\nDESCRIPTION: Create another instance of `TensorProduct` with specific `alpha`, `ancilla_bitsize`, `resource_bitsize`, and `epsilon` properties using `evolve` from the `attrs` library.  Demonstrates how to customize the block encoding properties of the underlying unitaries.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/tensor_product.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom attrs import evolve\n\nfrom qualtran.bloqs.basic_gates import CNOT, TGate\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\nu1 = evolve(Unitary(TGate()), alpha=0.5, ancilla_bitsize=2, resource_bitsize=1, epsilon=0.01)\nu2 = evolve(Unitary(CNOT()), alpha=0.5, ancilla_bitsize=1, resource_bitsize=1, epsilon=0.1)\ntensor_product_block_encoding_properties = TensorProduct((u1, u2))\n```\n\n----------------------------------------\n\nTITLE: ReflectionUsingPrepare Import\nDESCRIPTION: Imports the `ReflectionUsingPrepare` class from the `qualtran.bloqs.reflections.reflection_using_prepare` module. This class implements a reflection operation around a state prepared by a given `prepare_gate`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.reflections.reflection_using_prepare import ReflectionUsingPrepare\n```\n\n----------------------------------------\n\nTITLE: Show MinusState Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `MinusState` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([minus_state],\n           ['`minus_state`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph Visualization of Phase Block Encoding\nDESCRIPTION: Generates and displays the call graph for the `phase_block_encoding` object, illustrating its dependencies and resource usage. `ignore_split_join` is used as a generalizer. The `show_call_graph` and `show_counts_sigma` functions are used to visualize the call graph and associated resource counts, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/phase.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nphase_block_encoding_g, phase_block_encoding_sigma = phase_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(phase_block_encoding_g)\nshow_counts_sigma(phase_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Creating DirtyOutOfPlaceMontgomeryModMul Instance\nDESCRIPTION: This snippet creates a `DirtyOutOfPlaceMontgomeryModMul` instance with a larger bit size, window size and modulus.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndirtyoutofplacemontgomerymodmul_medium = DirtyOutOfPlaceMontgomeryModMul(\n    bitsize=16, window_size=4, mod=2**15 - 1\n)\n```\n\n----------------------------------------\n\nTITLE: Import statements for Qualtran and related libraries\nDESCRIPTION: Imports necessary modules from qualtran for defining quantum building blocks (Bloqs), composite bloqs, registers, and signatures. It also imports typing, numpy, sympy, and cirq for type hinting, numerical operations, symbolic calculations, and quantum circuit simulation, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_gate_to_lth_target.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran Libraries\nDESCRIPTION: Import necessary modules from the `qualtran` library for defining and manipulating quantum blocks and their signatures. Also imports standard Python libraries like typing, numpy, and sympy for type hints and symbolic calculations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/tensor_product.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show MinusState Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `MinusState` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nminus_state_g, minus_state_sigma = minus_state.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(minus_state_g)\nshow_counts_sigma(minus_state_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show PlusState Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `PlusState` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nplus_state_g, plus_state_sigma = plus_state.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(plus_state_g)\nshow_counts_sigma(plus_state_sigma)\n```\n\n----------------------------------------\n\nTITLE: BitonicSort Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph for `bitonic_sort` using `bitonic_sort.call_graph`. `ignore_split_join` is used to simplify the graph. `show_call_graph` and `show_counts_sigma` functions display the call graph and sigma counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nbitonic_sort_g, bitonic_sort_sigma = bitonic_sort.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(bitonic_sort_g)\nshow_counts_sigma(bitonic_sort_sigma)\n```\n\n----------------------------------------\n\nTITLE: Example Instance with QvrPhaseGradient\nDESCRIPTION: This snippet creates an instance of `PhasingViaCostFunction` using `QvrPhaseGradient` as the phase oracle. It defines a `QFxp` register, a `Square` cost evaluation oracle, and a `QvrPhaseGradient` phase oracle, then combines them into a `PhasingViaCostFunction` instance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phasing_via_cost_function.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QFxp, Register\nfrom qualtran.bloqs.arithmetic import Square\nfrom qualtran.bloqs.rotations.quantum_variable_rotation import QvrPhaseGradient\n\nn, gamma, eps = 5, 0.1234, 1e-8\ncost_reg = Register('result', QFxp(2 * n, 2 * n, signed=False))\ncost_eval_oracle = Square(n)\nphase_oracle = QvrPhaseGradient(cost_reg, gamma, eps)\nsquare_via_phase_gradient = PhasingViaCostFunction(cost_eval_oracle, phase_oracle)\n```\n\n----------------------------------------\n\nTITLE: PermutationCycle Graphical Signature Visualization\nDESCRIPTION: Displays the graphical representation of the defined `PermutationCycle` instances, including the symbolic and concrete cycles. This uses `show_bloqs` to create a visual representation of the bloqs and label them with their respective variable names.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([permutation_cycle_symb_N, permutation_cycle_symb, permutation_cycle],\n           ['`permutation_cycle_symb_N`', '`permutation_cycle_symb`', '`permutation_cycle`'])\n```\n\n----------------------------------------\n\nTITLE: MultiTargetCNOT Concrete Instance\nDESCRIPTION: Creates a concrete instance of `MultiTargetCNOT` with a fixed bit size of 5.  This creates a MultiTargetCNOT gate operating on 5 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nc_multi_not = MultiTargetCNOT(bitsize=5)\n```\n\n----------------------------------------\n\nTITLE: Show graphical representation of TwoBitSwap\nDESCRIPTION: Generates and displays a graphical representation of the `TwoBitSwap` gate using the `show_bloqs` function from `qualtran.drawing`. The gate is labeled as '`swap_bit`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([swap_bit],\n           ['`swap_bit`'])\n```\n\n----------------------------------------\n\nTITLE: Creating an instance of QFTPhaseGradient\nDESCRIPTION: This line creates an instance of the `QFTPhaseGradient` class with a `bitsize` of 3, initializing a QFT object for a 3-qubit register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_phase_gradient.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nqft_phase_gradient_small = QFTPhaseGradient(3)\n```\n\n----------------------------------------\n\nTITLE: CZPowGate Graphical Signature\nDESCRIPTION: Generates and displays a graphical representation of the `CZPowGate` bloq. This visualization helps understand the gate's structure and input/output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cz_pow],\n           ['`cz_pow`'])\n```\n\n----------------------------------------\n\nTITLE: Clean and Build HTML Documentation (Local Preview)\nDESCRIPTION: This snippet cleans the previous HTML build and then builds the HTML documentation from the sources using `make`. This allows local preview of the generated documentation website.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/how-to-build-the-docs.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake clean && make html\n```\n\n----------------------------------------\n\nTITLE: SortInPlace Import\nDESCRIPTION: Imports the `SortInPlace` function from the `qualtran.bloqs.arithmetic.lists` module. This function sorts a list of numbers in-place using ancilla bits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.lists import SortInPlace\n```\n\n----------------------------------------\n\nTITLE: Free Example Instance\nDESCRIPTION: Creates an instance of the `Free` bloq with a symbolic size `n`.  This demonstrates how to create a `Free` bloq for a dynamically sized register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n')\nfree = Free(QUInt(n))\n```\n\n----------------------------------------\n\nTITLE: Importing PrepareSparse class\nDESCRIPTION: This imports the `PrepareSparse` class from the `qualtran.bloqs.chemistry.sparse` module. This class is used to prepare the oracle for the sparse chemistry Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sparse/sparse.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.sparse import PrepareSparse\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of GF2ShiftRight\nDESCRIPTION: Displays the graphical signature of the `gf2shiftright` bloq, visualizing the input and output register for the shift right operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf2shiftright],\n           ['`gf2shiftright`'])\n```\n\n----------------------------------------\n\nTITLE: Symbolic BitwiseNot example instantiation\nDESCRIPTION: Demonstrates the instantiation of the `BitwiseNot` class with a symbolic `QUInt` data type.  The size of the register is parameterized by the sympy symbol 'n'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol(\"n\")\nbitwise_not_symb = BitwiseNot(QUInt(n))\n```\n\n----------------------------------------\n\nTITLE: Import SelectOracle from qualtran\nDESCRIPTION: This snippet imports the `SelectOracle` class from `qualtran.bloqs.multiplexers.select_base`. `SelectOracle` serves as the abstract base class for defining SELECT oracles.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.multiplexers.select_base import SelectOracle\n```\n\n----------------------------------------\n\nTITLE: Importing LessThanEqual Bloq\nDESCRIPTION: This line imports the `LessThanEqual` class from the `qualtran.bloqs.arithmetic` module. The `LessThanEqual` bloq checks if a number is less than or equal to another.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import LessThanEqual\n```\n\n----------------------------------------\n\nTITLE: HasDuplicates Import\nDESCRIPTION: Imports the `HasDuplicates` function from the `qualtran.bloqs.arithmetic.lists` module. This function checks if a sorted list contains any duplicate elements.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic.lists import HasDuplicates\n```\n\n----------------------------------------\n\nTITLE: Drawing LinearDepthHalfLessThan bloq\nDESCRIPTION: This code visualizes the `LinearDepthHalfLessThan` bloq using `show_bloqs` from `qualtran.drawing`. This helps visualize the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lineardepthhalflessthan_small],\n           ['`lineardepthhalflessthan_small`'])\n```\n\n----------------------------------------\n\nTITLE: CSwap instantiation with fixed bitsize\nDESCRIPTION: Instantiates `CSwap` objects with fixed bitsizes of 4 and 64, representing controlled swap gates for registers of those sizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# A small version on four bits.\ncswap_small = CSwap(bitsize=4)\n```\n\nLANGUAGE: python\nCODE:\n```\n# A large version that swaps 64-bit registers.\ncswap_large = CSwap(bitsize=64)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for State Preparation Via Rotation\nDESCRIPTION: This code imports necessary modules from the `qualtran` library for implementing state preparation via rotations. It imports the `StatePreparationViaRotations` class, drawing utilities, bloq building tools, basic gates, phase gradient state, and numpy for numerical calculations and random state generation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.state_preparation.state_preparation_via_rotation import StatePreparationViaRotations\nfrom qualtran.drawing import show_bloq\nfrom qualtran import BloqBuilder\nfrom qualtran.bloqs.basic_gates import ZeroState, OneState, OneEffect, PlusState, CNOT\nfrom qualtran.bloqs.rotations.phase_gradient import PhaseGradientState\nimport numpy as np\nimport random\n```\n\n----------------------------------------\n\nTITLE: PrepareIdentity Example\nDESCRIPTION: Creates an instance of `PrepareIdentity` with selection registers having bitsizes of 10, 4, and 1, respectively. This creates an identity state preparation gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprepare_identity = PrepareIdentity.from_bitsizes((10, 4, 1))\n```\n\n----------------------------------------\n\nTITLE: Import KaliskiModInverse class\nDESCRIPTION: This code imports the `KaliskiModInverse` class from the `qualtran.bloqs.mod_arithmetic` module. This class is used to compute the modular multiplicative inverse of a number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_division.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import KaliskiModInverse\n```\n\n----------------------------------------\n\nTITLE: ApplyGateToLthQubit Import\nDESCRIPTION: Imports the `ApplyGateToLthQubit` class from the `qualtran.bloqs.multiplexers.apply_gate_to_lth_target` module. This class implements a controlled SELECT operation for single-qubit gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_gate_to_lth_target.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.multiplexers.apply_gate_to_lth_target import ApplyGateToLthQubit\n```\n\n----------------------------------------\n\nTITLE: Instantiate Negate with symbolic QInt\nDESCRIPTION: Creates an instance of the `Negate` bloq with a symbolic data type `QInt(n)`, where `n` is a sympy symbol.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/negate.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nn = sympy.Symbol(\"n\")\nnegate_symb = Negate(QInt(n))\n```\n\n----------------------------------------\n\nTITLE: SparseMatrixHermitian Import\nDESCRIPTION: Imports the `SparseMatrixHermitian` class from the `qualtran.bloqs.block_encoding` module. This class is used for implementing block encoding of sparse Hermitian matrices.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix_hermitian.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import SparseMatrixHermitian\n```\n\n----------------------------------------\n\nTITLE: CRz Example\nDESCRIPTION: Creates an instance of the `CRz` gate with a symbolic angle. This demonstrates how to define a controlled rotation with a symbolic representation for the angle.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntheta = sympy.Symbol(r'\\theta')\ncrz = CRz(angle=theta)\n```\n\n----------------------------------------\n\nTITLE: BitonicSort Instance Example\nDESCRIPTION: An example of instantiating the `BitonicSort` class to sort 8 integers, each with a bitsize of 4.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nbitonic_sort = BitonicSort(8, 4)\n```\n\n----------------------------------------\n\nTITLE: Hadamard Gate Example (Python)\nDESCRIPTION: Instantiates the `Hadamard` gate and provides a code example of how to create an instance. This example demonstrates basic usage of the `Hadamard` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nhadamard = Hadamard()\n```\n\n----------------------------------------\n\nTITLE: Tensor Contraction of GlobalPhase\nDESCRIPTION: Calculates and returns the tensor representation (just a number) of the `GlobalPhase` gate. This demonstrates how to access the underlying numerical representation of the gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/global_phase.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nglobal_phase.tensor_contract()\n```\n\n----------------------------------------\n\nTITLE: Create ModAddK instance with small constant parameters in Python\nDESCRIPTION: Creates an instance of the `ModAddK` class with specific constant parameters: bitsize=4, mod=7, and add_val=1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmod_add_k_small = ModAddK(bitsize=4, mod=7, add_val=1)\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientUnitary Example Instance\nDESCRIPTION: Creates an instance of the `PhaseGradientUnitary` Bloq with a bitsize of 4.  This creates an operation that applies a phase gradient unitary to a 4 qubit register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nphase_gradient_unitary = PhaseGradientUnitary(4)\n```\n\n----------------------------------------\n\nTITLE: Create ModAddK instance with larger constant parameters in Python\nDESCRIPTION: Creates an instance of the `ModAddK` class with larger specific constant parameters: bitsize=64, mod=500, and add_val=23.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmod_add_k_large = ModAddK(bitsize=64, mod=500, add_val=23)\n```\n\n----------------------------------------\n\nTITLE: Create CModAddK instance with small constant parameters in Python\nDESCRIPTION: Creates an instance of the `CModAddK` class with specific constant parameters: bitsize=4, mod=7, and k=1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ncmod_add_k_small = CModAddK(bitsize=4, mod=7, k=1)\n```\n\n----------------------------------------\n\nTITLE: Import SquareRealNumber Bloq\nDESCRIPTION: Imports the `SquareRealNumber` class from the `qualtran.bloqs.arithmetic` module.  This bloq squares a fixed-point representation of a real number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import SquareRealNumber\n```\n\n----------------------------------------\n\nTITLE: BlackBoxBloq Class Definition\nDESCRIPTION: Defines a `BlackBoxBloq` class that wraps another `Bloq` and uses `Partition` to adapt its signature to a single \"system\" register.  This simplifies the interface to the underlying bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nimport attrs\n\n@attrs.frozen\nclass BlackBoxBloq(Bloq):\n    subbloq: Bloq\n\n    @property\n    def signature(self) -> Signature:\n        return Signature.build(system=self.bitsize)\n\n    @property\n    def bitsize(self):\n        return sum(reg.total_bits() for reg in self.subbloq.signature)\n\n    def build_composite_bloq(self, bb: 'BloqBuilder', system: 'SoquetT') -> Dict[str, 'Soquet']:\n        bloq_regs = self.subbloq.signature\n        partition = Partition(self.bitsize, bloq_regs)\n        partitioned_vars = bb.add(partition, x=system)\n        partitioned_vars = bb.add(\n            self.subbloq, **{reg.name: sp for reg, sp in zip(bloq_regs, partitioned_vars)}\n        )\n        system = bb.add(\n            partition.adjoint(), **{reg.name: sp for reg, sp in zip(bloq_regs, partitioned_vars)}\n        )\n        return {'system': system}\n```\n\n----------------------------------------\n\nTITLE: Check if result matches desired logical function\nDESCRIPTION: This snippet calculates the expected output (`should_be`) based on the control variable settings (`cvs`) and control string (`ctrl_string`). It then compares this expected output with the actual result obtained from the quantum simulation to verify the correctness of the `MultiAnd` gate's implementation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# The truthiness of the non-zero res index should match the desired logical function.\nshould_be = np.all(ctrl_string == cvs)\nshould_be\n```\n\n----------------------------------------\n\nTITLE: Convert to Contiguous Index\nDESCRIPTION: Imports the `ToContiguousIndex` class from `qualtran.bloqs.arithmetic`. This class is likely used to convert a non-contiguous index to a contiguous index, potentially for memory addressing or similar purposes within a quantum algorithm.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import ToContiguousIndex\n```\n\n----------------------------------------\n\nTITLE: Importing the Xor class\nDESCRIPTION: Imports the `Xor` class from the `qualtran.bloqs.arithmetic` module, enabling the use of the XOR gate in quantum circuits. This gate performs a bitwise XOR operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Xor\n```\n\n----------------------------------------\n\nTITLE: Elliptic Curve Addition by Constant R (Qualtran)\nDESCRIPTION: Defines the `ECAddR` bloq, which performs controlled elliptic curve point addition with a constant point $R$. It takes a control bit and an input point $A$, and outputs $A + R$ if the control bit is set. The elliptic curve points are represented by their $x$ and $y$ coordinates.  The `n` parameter specifies the bitsize of the x and y registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.cryptography.ecc import ECAddR\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counting for `ECPhaseEstimateR`\nDESCRIPTION: Generates and displays the call graph and resource counts for `ECPhaseEstimateR`.  The call graph shows the sub-bloqs called by `ECPhaseEstimateR` with max depth 1, using `ignore_split_join` generalizer. Resource counts are stored in `ec_pe_sigma` and displayed using `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nec_pe_g, ec_pe_sigma = ec_pe.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ec_pe_g)\nshow_counts_sigma(ec_pe_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show graphical representation of Subtract gates\nDESCRIPTION: Generates and displays a graphical representation of the `Subtract` gate instances, including the symbolic, small, large, and different-sized versions, as well as the decomposed version. Requires the `qualtran.drawing` module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sub_symb, sub_small, sub_large, sub_diff_size_regs, sub_symp_decomposition],\n           ['`sub_symb`', '`sub_small`', '`sub_large`', '`sub_diff_size_regs`', '`sub_symp_decomposition`'])\n```\n\n----------------------------------------\n\nTITLE: Show Square Bloq\nDESCRIPTION: Displays the `Square` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([square],\n           ['`square`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph of LinearDepthHalfGreaterThanEqual in Qualtran\nDESCRIPTION: This snippet generates and displays the call graph for `LinearDepthHalfGreaterThanEqual` using `call_graph` and `show_call_graph`. The call graph helps to analyze the resource requirements and complexity of the quantum comparator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlineardepthhalfgreaterthanequal_small_g, lineardepthhalfgreaterthanequal_small_sigma = lineardepthhalfgreaterthanequal_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lineardepthhalfgreaterthanequal_small_g)\nshow_counts_sigma(lineardepthhalfgreaterthanequal_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of BinaryPolynomialMultiplication\nDESCRIPTION: Displays the graphical signature of the `binarypolynomialmultiplication` bloq, visualizing the input and output registers for binary polynomial multiplication.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([binarypolynomialmultiplication],\n           ['`binarypolynomialmultiplication`'])\n```\n\n----------------------------------------\n\nTITLE: AddIntoPhaseGrad Definition\nDESCRIPTION: Defines the `AddIntoPhaseGrad` Bloq, which performs quantum-quantum addition into a phase gradient register. It adds the value of an input register 'x' into a phase gradient register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import AddIntoPhaseGrad\n```\n\n----------------------------------------\n\nTITLE: Calculating period differences in Python\nDESCRIPTION: This snippet calculates the differences between periods for verification purposes. It shows that the period is a consistent value.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n16-8, 8-0\n```\n\n----------------------------------------\n\nTITLE: Create PlusEffect Instance\nDESCRIPTION: Creates an instance of the `PlusEffect` bloq, representing the <+| quantum effect. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nplus_effect = PlusEffect()\n```\n\n----------------------------------------\n\nTITLE: Display graphical signatures of Negate instances\nDESCRIPTION: Uses `show_bloqs` to display the graphical signatures of the `negate` and `negate_symb` instances created earlier.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/negate.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([negate, negate_symb],\n           ['`negate`', '`negate_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Create MinusState Instance\nDESCRIPTION: Creates an instance of the `MinusState` bloq, representing the |-> quantum state. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nminus_state = MinusState()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Circuit\nDESCRIPTION: This snippet visualizes a `cirq.Circuit` containing the `operation` using `cirq.contrib.svg.SVGCircuit`.  This provides a visual representation of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom cirq.contrib.svg import SVGCircuit\nSVGCircuit(cirq.Circuit(operation))\n```\n\n----------------------------------------\n\nTITLE: Import TrotterizedUnitary\nDESCRIPTION: Imports the `TrotterizedUnitary` class from the `qualtran.bloqs.chemistry.trotter` module. This class is used to construct Trotterized unitary operators.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/trotterized_unitary.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.trotterized_unitary import TrotterizedUnitary\n```\n\n----------------------------------------\n\nTITLE: PrepareTHC Class Import\nDESCRIPTION: Imports the `PrepareTHC` class from the `qualtran.bloqs.chemistry.thc` module, enabling preparation of the THC Hamiltonian state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.thc import PrepareTHC\n```\n\n----------------------------------------\n\nTITLE: Importing LinearDepthHalfGreaterThanEqual from qualtran\nDESCRIPTION: This snippet imports the `LinearDepthHalfGreaterThanEqual` class from the `qualtran.bloqs.arithmetic` module. This class implements a comparison to determine if a >= b for quantum integers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import LinearDepthHalfGreaterThanEqual\n```\n\n----------------------------------------\n\nTITLE: Swap instantiation with fixed bitsize\nDESCRIPTION: Instantiates `Swap` objects with fixed bitsizes of 4 and 64.  These gates swap registers of the specified sizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nswap_small = Swap(bitsize=4)\n```\n\nLANGUAGE: python\nCODE:\n```\nswap_large = Swap(bitsize=64)\n```\n\n----------------------------------------\n\nTITLE: Showing a GreaterThan Bloq\nDESCRIPTION: This snippet displays a graphical representation of the `greater_than` bloq, providing a visual representation of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([greater_than],\n           ['`greater_than`'])\n```\n\n----------------------------------------\n\nTITLE: Showing a GreaterThanConstant Bloq\nDESCRIPTION: This snippet displays a graphical representation of the `gt_k` bloq, providing a visual representation of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gt_k],\n           ['`gt_k`'])\n```\n\n----------------------------------------\n\nTITLE: Import OneState Bloq\nDESCRIPTION: Imports the `OneState` class from the `qualtran.bloqs.basic_gates` module. `OneState` represents the |1> quantum state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import OneState\n```\n\n----------------------------------------\n\nTITLE: Import CtrlScaleModAdd from qualtran.bloqs.mod_arithmetic\nDESCRIPTION: Imports the `CtrlScaleModAdd` class, which implements controlled scaled modular addition, from the `qualtran.bloqs.mod_arithmetic` module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import CtrlScaleModAdd\n```\n\n----------------------------------------\n\nTITLE: Import MinusEffect Bloq\nDESCRIPTION: Imports the `MinusEffect` class from the `qualtran.bloqs.basic_gates` module. `MinusEffect` represents the <-| quantum effect.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import MinusEffect\n```\n\n----------------------------------------\n\nTITLE: Import OneEffect Bloq\nDESCRIPTION: Imports the `OneEffect` class from the `qualtran.bloqs.basic_gates` module. `OneEffect` represents the <1| quantum effect.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import OneEffect\n```\n\n----------------------------------------\n\nTITLE: Import PlusState Bloq\nDESCRIPTION: Imports the `PlusState` class from the `qualtran.bloqs.basic_gates` module. `PlusState` represents the |+> quantum state.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import PlusState\n```\n\n----------------------------------------\n\nTITLE: Show InvertRealNumber Bloq\nDESCRIPTION: Displays the `InvertRealNumber` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([invert_real_number],\n           ['`invert_real_number`'])\n```\n\n----------------------------------------\n\nTITLE: Create pandas DataFrame from analysis records\nDESCRIPTION: This snippet creates a pandas DataFrame from the collected records for further analysis and reporting.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\ndf = pd.DataFrame(records)\n```\n\n----------------------------------------\n\nTITLE: QROAMClean import\nDESCRIPTION: Imports the QROAMClean class, which represents a lower-cost variant of SelectSwapQROM, from the qualtran.bloqs.data_loading module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.data_loading.qroam_clean import QROAMClean\n```\n\n----------------------------------------\n\nTITLE: Importing ModNeg class\nDESCRIPTION: Imports the `ModNeg` class from the `qualtran.bloqs.mod_arithmetic` module, which is used for performing modular negation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import ModNeg\n```\n\n----------------------------------------\n\nTITLE: Create Small SwapWithZero Instance\nDESCRIPTION: Creates a smaller instance of the SwapWithZero class with selection bitsizes of 3, a target bitsize of 2, and 2 target registers. This configuration is useful for testing and demonstration purposes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# A small version on four bits.\nswz_small = SwapWithZero(selection_bitsizes=3, target_bitsize=2, n_target_registers=2)\n```\n\n----------------------------------------\n\nTITLE: GQSP Instance with XPowGate\nDESCRIPTION: Creates an instance of `GeneralizedQSP` using `XPowGate` as the unitary and (0.5, 0.5) as the QSP polynomial coefficients. This example demonstrates the basic usage of the `from_qsp_polynomial` method.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qsp/generalized_qsp.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import XPowGate\n\ngqsp = GeneralizedQSP.from_qsp_polynomial(XPowGate(), (0.5, 0.5))\n```\n\n----------------------------------------\n\nTITLE: Visualize PotentialEnergy\nDESCRIPTION: This snippet visualizes the `PotentialEnergy` bloq's graphical signature using `show_bloqs` from `qualtran.drawing`. It displays the bloq with the label '`potential_energy`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([potential_energy],\n           ['`potential_energy`'])\n```\n\n----------------------------------------\n\nTITLE: CRz Call Graph\nDESCRIPTION: Generates and displays the call graph of the `CRz` bloq, ignoring split/join operations. This reveals the gate's internal structure and dependencies.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncrz_g, crz_sigma = crz.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(crz_g)\nshow_counts_sigma(crz_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show OneEffect Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `OneEffect` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([one_effect],\n           ['`one_effect`'])\n```\n\n----------------------------------------\n\nTITLE: Concrete SimpleGuidingState Example\nDESCRIPTION: This snippet demonstrates how to create a `SimpleGuidingState` instance with concrete parameters. It defines a `KXorInstance` with specific values for `n`, `k`, and the constraints.  The snippet then creates a `SimpleGuidingState` object using this instance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.optimization.k_xor_sat import Constraint, KXorInstance\n\ninst = KXorInstance(\n    n=4,\n    k=2,\n    constraints=(\n        Constraint(S=(0, 1), b=1),\n        Constraint(S=(2, 3), b=-1),\n        Constraint(S=(1, 2), b=1),\n    ),\n)\nsimple_guiding_state = SimpleGuidingState(inst)\n```\n\n----------------------------------------\n\nTITLE: Create Symbolic CSwapApprox Instance\nDESCRIPTION: Creates a symbolic instance of the CSwapApprox class, where the bitsize is defined using a sympy symbol 'n'. This enables working with the CSwapApprox at a symbolic level before specifying the actual bit size.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# A symbolic version. The bitsize is the symbol 'n'.\nfrom sympy import sympify\n\napprox_cswap_symb = CSwapApprox(bitsize=sympify('n'))\n```\n\n----------------------------------------\n\nTITLE: Show SplitJoin Bloq Musical Score\nDESCRIPTION: Displays the `SplitJoin` bloq in the \"musical score\" diagram style, emphasizing the split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(split_join, 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: Join Bloq Definition\nDESCRIPTION: Defines the `Join` bloq, which joins an array of `QBit`s into a single register of a specified data type (`dtype`). This is the inverse operation of `Split`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import Join\n```\n\n----------------------------------------\n\nTITLE: Show PlusEffect Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `PlusEffect` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nplus_effect_g, plus_effect_sigma = plus_effect.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(plus_effect_g)\nshow_counts_sigma(plus_effect_sigma)\n```\n\n----------------------------------------\n\nTITLE: Displaying CModMulK Bloqs Graphically\nDESCRIPTION: This snippet uses the `show_bloqs` function to display the graphical representations of the symbolic and concrete `CModMulK` Bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([modmul_symb, modmul],\n           ['`modmul_symb`', '`modmul`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate Negate with QInt(8)\nDESCRIPTION: Creates an instance of the `Negate` bloq with an 8-bit signed integer (`QInt(8)`) data type.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/negate.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnegate = Negate(QInt(8))\n```\n\n----------------------------------------\n\nTITLE: Import ModAddK from qualtran.bloqs.mod_arithmetic\nDESCRIPTION: Imports the `ModAddK` class, representing modular addition by a constant `k`, from the `qualtran.bloqs.mod_arithmetic` module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import ModAddK\n```\n\n----------------------------------------\n\nTITLE: AddIntoPhaseGrad Example Instance\nDESCRIPTION: Creates an instance of the `AddIntoPhaseGrad` Bloq with both x_bitsize and phase_bitsize set to 4.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nadd_into_phase_grad = AddIntoPhaseGrad(4, 4)\n```\n\n----------------------------------------\n\nTITLE: Display bloqs with large tensor networks\nDESCRIPTION: Displays Bloq examples whose tensor network size exceeds the limit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndf[df['width'] > 25].sort_values(by='width')\n```\n\n----------------------------------------\n\nTITLE: Show Bloq Graphical Signatures\nDESCRIPTION: Generates graphical signatures for `qroam_clean_multi_data` and `qroam_clean_multi_dim`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qroam_clean.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([qroam_clean_multi_data, qroam_clean_multi_dim],\n           ['`qroam_clean_multi_data`', '`qroam_clean_multi_dim`'])\n```\n\n----------------------------------------\n\nTITLE: Display bloqs without tensors\nDESCRIPTION: Displays Bloq examples that do not have tensors, caused by flattening errors.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndf[df['width'].isna()]\n```\n\n----------------------------------------\n\nTITLE: TwoBitSwap instantiation\nDESCRIPTION: Instantiates a `TwoBitSwap` object from the `qualtran.bloqs.basic_gates` module, representing a two-qubit swap gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import TwoBitSwap\n```\n\nLANGUAGE: python\nCODE:\n```\nswap_bit = TwoBitSwap()\n```\n\n----------------------------------------\n\nTITLE: Importing ModSub class\nDESCRIPTION: Imports the `ModSub` class from the `qualtran.bloqs.mod_arithmetic` module, which is used to perform modular subtraction.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import ModSub\n```\n\n----------------------------------------\n\nTITLE: Instantiate YGate (Python)\nDESCRIPTION: This snippet demonstrates how to create an instance of the `YGate` class. This creates a Pauli Y gate object which can then be used in a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ny_gate = YGate()\n```\n\n----------------------------------------\n\nTITLE: Decomposition and Compilation Display\nDESCRIPTION: Demonstrates how to display the gate decomposition and compilation for `apply_z_to_odd` using `GateHelper` and `display_gate_and_compilation` from `qualtran.cirq_interop`. This shows how the high-level `ApplyGateToLthQubit` is broken down into lower-level quantum gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_gate_to_lth_target.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport qualtran.cirq_interop.testing as cq_testing\nfrom qualtran.cirq_interop.jupyter_tools import display_gate_and_compilation\n\ng = cq_testing.GateHelper(\n    apply_z_to_odd\n)\n\ndisplay_gate_and_compilation(g)\n```\n\n----------------------------------------\n\nTITLE: Rz Example\nDESCRIPTION: Creates an instance of the `Rz` gate with a symbolic angle. This demonstrates how to use symbolic representations for rotation angles.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\na = sympy.Symbol('a')\nrz = Rz(a)\n```\n\n----------------------------------------\n\nTITLE: AutoPartition Example with Unused Registers\nDESCRIPTION: Illustrates how to use the `Unused` class within `AutoPartition` to indicate that certain parts of the input register should not be used by the wrapped bloq. This example extends the previous one to include unused registers in the partition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Controlled, CtrlSpec\nfrom qualtran.bloqs.basic_gates import Swap\nfrom qualtran.bloqs.bookkeeping.auto_partition import Unused\n\nbloq = Controlled(Swap(1), CtrlSpec())\nauto_partition_unused = AutoPartition(\n    bloq,\n    [\n        (Register('x', QAny(3)), ['ctrl', 'x', Unused(1)]),\n        (Register('y', QAny(1)), ['y']),\n        (Register('z', QAny(2)), [Unused(2)]),\n    ],\n)\n```\n\n----------------------------------------\n\nTITLE: Create Small CSwapApprox Instance\nDESCRIPTION: Creates a small instance of the CSwapApprox class with a bitsize of 4. This allows testing and experimentation with a smaller register size before scaling up to larger sizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# A small version on four bits.\napprox_cswap_small = CSwapApprox(bitsize=4)\n```\n\n----------------------------------------\n\nTITLE: Display bloqs with the slowest contraction width duration\nDESCRIPTION: Displays Bloq examples with the slowest contraction width duration.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# Slowest width_dur\ndf.sort_values(by='width_dur', ascending=False).head()\n```\n\n----------------------------------------\n\nTITLE: Getting the CNOT from Controlled XGate\nDESCRIPTION: This snippet demonstrates that controlling an `XGate` results in a `CNOT` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncx = XGate().controlled()\nprint(cx)\n```\n\n----------------------------------------\n\nTITLE: Install Graphviz using Conda\nDESCRIPTION: This command installs Graphviz, a diagram drawing tool, using Conda. Graphviz is a Qualtran dependency for generating diagrams.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nconda install graphviz\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph for CModAdd example instance\nDESCRIPTION: Generates and displays the call graph and resource counts for the `cmodadd_example` using `call_graph` and `ignore_split_join`. The results are visualized using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncmodadd_example_g, cmodadd_example_sigma = cmodadd_example.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cmodadd_example_g)\nshow_counts_sigma(cmodadd_example_sigma)\n```\n\n----------------------------------------\n\nTITLE: Create an instance of TwoBitFFFT\nDESCRIPTION: Creates an instance of the TwoBitFFFT gate with k=2 and n=3, demonstrating how to instantiate the gate with specific parameter values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/two_bit_ffft.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntwo_bit_ffft = TwoBitFFFT(2, 3)\n```\n\n----------------------------------------\n\nTITLE: Install Qualtran developer dependencies\nDESCRIPTION: This command installs all optional and developer dependencies from the repository root. It's useful for contributing to Qualtran's development.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npip install -r dev_tools/requirements/envs/dev.env.txt\n```\n\n----------------------------------------\n\nTITLE: Create Symbolic SwapWithZero Instance\nDESCRIPTION: Creates a symbolic instance of the SwapWithZero class, where parameters such as selection bitsizes, target bitsize, and number of target registers are defined as sympy symbols. This allows for generalized analysis before specifying concrete values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# A small version on four bits.\nselection = sympy.symbols(\"p q r\")\ntarget_bitsize = sympy.Symbol(\"b\")\nn_target_registers = sympy.symbols(\"P Q R\")\nswz_multi_symbolic = SwapWithZero(\n    selection_bitsizes=selection,\n    target_bitsize=target_bitsize,\n    n_target_registers=n_target_registers,\n)\n```\n\n----------------------------------------\n\nTITLE: Graphical Representation of GlobalPhase\nDESCRIPTION: Generates and displays a graphical representation of the `GlobalPhase` gate using Qualtran's drawing utilities. The `show_bloqs` function renders the gate's symbol for visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/global_phase.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([global_phase],\n           ['`global_phase`'])\n```\n\n----------------------------------------\n\nTITLE: Visualize QuantumVariableRotation\nDESCRIPTION: This snippet visualizes the `QuantumVariableRotation` bloq's graphical signature using `show_bloqs` from `qualtran.drawing`. It displays the bloq with the label '`qvr`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([qvr],\n           ['`qvr`'])\n```\n\n----------------------------------------\n\nTITLE: Show PlusEffect Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `PlusEffect` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([plus_effect],\n           ['`plus_effect`'])\n```\n\n----------------------------------------\n\nTITLE: Draw Musical Score of the Bloq Decomposition\nDESCRIPTION: This code uses `get_musical_score_data` and `draw_musical_score` to create a visualization of the decomposed `prep` bloq.  This allows for a visual inspection of the circuit structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/writing_algorithms.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import get_musical_score_data, draw_musical_score\nmsd = get_musical_score_data(prep.decompose_bloq()) \nfig, ax = draw_musical_score(msd)\nfig.set_size_inches(8, 6)\n```\n\n----------------------------------------\n\nTITLE: Example Instance of PrepareFirstQuantizationWithProj\nDESCRIPTION: This example demonstrates how to create an instance of the `PrepareFirstQuantizationWithProj` class with specific parameter values. These parameters define the properties of the quantum system, such as the number of bits for momentum representation, the number of electrons, and the number of atoms.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 6\nnum_bits_n = 8\neta = 10\nnum_atoms = 10\nlambda_zeta = 10\nprep_first_quant = PrepareFirstQuantizationWithProj(\n    num_bits_p, num_bits_n, eta, num_atoms, lambda_zeta\n)\n\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Elliptic Curve Operations in Qualtran\nDESCRIPTION: This code snippet imports necessary libraries from Qualtran and other Python packages like numpy, sympy, and cirq. These libraries provide functionalities for defining quantum building blocks (Bloqs), creating composite bloqs, managing registers, and performing symbolic calculations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ec_add.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph of PrepareZetaState in Python\nDESCRIPTION: Generates and displays the call graph and resource counts for the `prepare_zeta` bloq. The call graph is simplified using `ignore_split_join` as a generalizer, and the maximum depth is limited to 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprepare_zeta_g, prepare_zeta_sigma = prepare_zeta.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prepare_zeta_g)\nshow_counts_sigma(prepare_zeta_sigma)\n```\n\n----------------------------------------\n\nTITLE: Resource State Preparation\nDESCRIPTION: This function prepares the resource state required for Heisenberg-limited phase estimation as defined in the referenced paper. It returns a numpy array representing the state vector.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef get_resource_state(m: int):\n    r\"\"\"Returns a state vector representing the resource state on m qubits from Eq.17 of Ref-1.\n    \n    Returns a numpy array of size 2^{m} representing the state vector corresponding to the state\n    $$\n        \\sqrt{\\frac{2}{2^m + 1}} \\sum_{n=0}^{2^{m}-1} \\sin{\\frac{\\pi(n + 1)}{2^{m}+1}}\\ket{n}\n    $$\n    \n    Args:\n        m: Number of qubits to prepare the resource state on.\n    \n    Ref:\n        1) [Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity]\n            (https://arxiv.org/abs/1805.03662)\n            Eq. 17\n    \"\"\"\n    den = 1 + 2 ** m\n    norm = np.sqrt(2 / den)\n    return norm * np.sin(np.pi * (1 + np.arange(2**m)) / den)\n```\n\n----------------------------------------\n\nTITLE: Install Qualtran using pip (after Conda setup)\nDESCRIPTION: This command installs Qualtran using pip after setting up a Conda environment and installing Graphviz.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\npip install qualtran\n```\n\n----------------------------------------\n\nTITLE: Initializing N and n for factoring in Python\nDESCRIPTION: This snippet initializes the composite number `N` to be factored and calculates the bit size `n` required to represent it. The `numpy` library is used to calculate the base-2 logarithm and round up to the nearest integer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/rsa/factoring-via-modexp.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nN = 13*17\nn = int(np.ceil(np.log2(N)))\nN, n\n```\n\n----------------------------------------\n\nTITLE: Number of bloq examples with tensors\nDESCRIPTION: Prints the number of bloq examples containing tensors.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(len(df[df['width'] > 0]))\n```\n\n----------------------------------------\n\nTITLE: Instantiate Identity gate with size 4\nDESCRIPTION: Creates an instance of the `Identity` gate with a specific size of 4 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/identity.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nn = 4\nidentity_n = Identity(n)\n```\n\n----------------------------------------\n\nTITLE: Import IntEffect Bloq\nDESCRIPTION: Imports the `IntEffect` class from the `qualtran.bloqs.basic_gates` module. `IntEffect` represents the <val| quantum effect for a non-negative integer val.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import IntEffect\n```\n\n----------------------------------------\n\nTITLE: Defining CtrlSpec with QBit array for Controlled Bloq\nDESCRIPTION: This snippet demonstrates how to use `CtrlSpec` with an array of `QBit` types to control a bloq. The controlled XGate is active only when the input register has values `[0, 1, 1, 0]`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Controlled.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nctrl_spec = CtrlSpec(cvs=[0, 1, 1, 0])\nassert ctrl_spec.is_active([0, 1, 1, 0])\ncx = x.controlled(ctrl_spec=ctrl_spec)\nshow_bloq(cx, type='musical_score')\n```\n\n----------------------------------------\n\nTITLE: IsingZZUnitary Import Statement\nDESCRIPTION: Imports the `IsingZZUnitary` class from the `qualtran.bloqs.chemistry.trotter.ising.unitaries` module. This class represents the unitary evolution operator corresponding to the ZZ interaction term in the Ising Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.ising.unitaries import IsingZZUnitary\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: Imports necessary modules from Qualtran, typing, NumPy, SymPy, and Cirq. These modules are used for defining quantum gates, building quantum circuits, numerical computation, symbolic manipulation, and interfacing with quantum simulators.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import TensorProduct from Qualtran\nDESCRIPTION: Import the `TensorProduct` class from the `qualtran.bloqs.block_encoding` module. This class is used to construct the tensor product of a sequence of block encodings.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/tensor_product.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import TensorProduct\n```\n\n----------------------------------------\n\nTITLE: Show TGate Graphical Signature\nDESCRIPTION: Generates and displays a graphical representation of the TGate using the show_bloqs function. This visualization helps understand the gate's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/t_gate.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([t_gate],\n           ['`t_gate`'])\n```\n\n----------------------------------------\n\nTITLE: Calculating System Volume\nDESCRIPTION: This function calculates the system volume from a fixed electron density parameter `rs` and the number of electrons `eta`. It returns the volume of the cell in bohr.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef volume_from_rs_eta(rs: float, eta: int) -> float:\n    \"\"\"Get the system volume from fixed rs and electron count eta.\n\n    Args:\n        rs: The electron density parameter.\n        eta: The number of electrons\n\n    Returns:\n        volume: The volume of the cell in bohr.\n    \"\"\"\n    volume = (rs**3.0) * (4.0 * np.pi * eta / 3)\n    return volume\n```\n\n----------------------------------------\n\nTITLE: SelectHubbard Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts of the `SelectHubbard` instance. The `ignore_split_join` generalizer is used to simplify the graph. This helps analyze the resource requirements of the operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsel_hubb_g, sel_hubb_sigma = sel_hubb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sel_hubb_g)\nshow_counts_sigma(sel_hubb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Create ModAdd instance with symbolic parameters in Python\nDESCRIPTION: Creates an instance of the `ModAdd` class with symbolic parameters 'n' and 'p' for the bitsize and modulus, respectively, using the sympy library. This allows for creating a modular addition gate with generic parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\nmod_add = ModAdd(n, mod=p)\n```\n\n----------------------------------------\n\nTITLE: Qualtran Library Imports and Setup\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library and standard Python libraries like numpy, sympy, and cirq. These modules are used for defining and manipulating quantum circuits, bloqs, registers, and other related objects within the Qualtran framework. It sets up the environment for defining quantum algorithms related to kXOR problems.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Bloqs\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical representation of two `Unitary` instances: the basic one and the one with evolved properties. This allows for visual inspection of the created `Bloq` objects.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/unitary.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([unitary_block_encoding, unitary_block_encoding_properties],\n           ['`unitary_block_encoding`', '`unitary_block_encoding_properties`'])\n```\n\n----------------------------------------\n\nTITLE: Creating CModMulK Instances with Symbols\nDESCRIPTION: This snippet demonstrates how to create an instance of the `CModMulK` class with symbolic parameters using `sympy`. This allows for a more general representation of the modular multiplication operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nk, N, n_x = sympy.symbols('k N n_x')\nmodmul_symb = CModMulK(QUInt(n_x), k=k, mod=N)\n```\n\n----------------------------------------\n\nTITLE: Print the total number of bloq examples\nDESCRIPTION: Prints the number of Bloq examples considered in the report.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(len(df))\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran in Python\nDESCRIPTION: This Python command imports the Qualtran library. Successful import indicates a correct installation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/docs/index.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport qualtran\n```\n\n----------------------------------------\n\nTITLE: Controlled Hadamard Gate Graphical Signature (Python)\nDESCRIPTION: Generates a graphical representation of the controlled Hadamard gate using Qualtran's drawing utilities. This visualization shows the control and target registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([chadamard],\n           ['`chadamard`'])\n```\n\n----------------------------------------\n\nTITLE: CZPowGate Call Graph\nDESCRIPTION: Generates and displays the call graph of the `CZPowGate` bloq, ignoring split/join operations. This visualization helps understand the dependencies and structure within the gate's implementation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncz_pow_g, cz_pow_sigma = cz_pow.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cz_pow_g)\nshow_counts_sigma(cz_pow_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signatures of CtrlScaleModAdd instances\nDESCRIPTION: Displays the graphical signatures of the symbolic and small constant instances of `CtrlScaleModAdd` using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ctrl_scale_mod_add, ctrl_scale_mod_add_small],\n           ['`ctrl_scale_mod_add`', '`ctrl_scale_mod_add_small`'])\n```\n\n----------------------------------------\n\nTITLE: SelectPauliLCU Import\nDESCRIPTION: This snippet imports the `SelectPauliLCU` class from the `qualtran.bloqs.multiplexers.select_pauli_lcu` module. This class is essential for creating instances of the SELECT unitary for Pauli String Linear Combinations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/select_pauli_lcu.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.multiplexers.select_pauli_lcu import SelectPauliLCU\n```\n\n----------------------------------------\n\nTITLE: Symbolic Product Block Encoding\nDESCRIPTION: This example demonstrates creating a `Product` block encoding using symbolic variables from the `sympy` library for the parameters of the `Unitary` block encodings. This allows for creating generic block encodings that can be evaluated with different parameter values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/product.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.basic_gates import Hadamard, TGate\nfrom qualtran.bloqs.block_encoding.unitary import Unitary\n\nalpha1 = sympy.Symbol('alpha1')\na1 = sympy.Symbol('a1')\neps1 = sympy.Symbol('eps1')\nalpha2 = sympy.Symbol('alpha2')\na2 = sympy.Symbol('a2')\neps2 = sympy.Symbol('eps2')\nproduct_block_encoding_symb = Product(\n    (\n        Unitary(TGate(), alpha=alpha1, ancilla_bitsize=a1, epsilon=eps1),\n        Unitary(Hadamard(), alpha=alpha2, ancilla_bitsize=a2, epsilon=eps2),\n    )\n)\n```\n\n----------------------------------------\n\nTITLE: Using Negate Bloq with QUInt in Qualtran\nDESCRIPTION: This code snippet illustrates how to use the `Negate` bloq in Qualtran with a `QUInt` data type. It creates a `Negate` object, specifying the `dtype` as a 2048-bit `QUInt`. The `decompose_bloq()` method is then called to decompose the bloq, and `show_bloq` displays the decomposed bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/DataTypes.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Negate\n\nnegate = Negate(dtype=QUInt(2048))\nshow_bloq(negate.decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: Adding CompositeBloq with `bb.add_from` - Python\nDESCRIPTION: Demonstrates the use of `bb.add_from` to add the contents of a `TestParallelCombo` bloq to the current builder.  `add_from` effectively flattens the added bloq's internal structure into the current construction context. This is used on the second bloq instance.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# `add_from` on second one\nbb = BloqBuilder()\nstuff = bb.add_register('stuff', 3)\nstuff, = bb.add_t(TestParallelCombo(), reg=stuff)\nstuff, = bb.add_from(TestParallelCombo(), reg=stuff)\nbloq = bb.finalize(stuff=stuff)\n\nshow_bloq(bloq)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature for BlackBoxSelect\nDESCRIPTION: This snippet uses the `show_bloqs` function to display the graphical signature of the `black_box_select` object, visualizing its input and output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/lcu_block_encoding.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([black_box_select],\n           ['`black_box_select`'])\n```\n\n----------------------------------------\n\nTITLE: Creating a SingleQubitCompare instance\nDESCRIPTION: This creates an instance of the `SingleQubitCompare` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nsq_cmp = SingleQubitCompare()\n```\n\n----------------------------------------\n\nTITLE: Instantiate SGate\nDESCRIPTION: This code instantiates the `SGate` class, creating an object `s_gate` representing the S gate. This object can then be used within a quantum circuit definition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ns_gate = SGate()\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientState Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature for `phase_gradient_state` using `show_bloqs` from `qualtran.drawing`. It visualizes the inputs and outputs of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([phase_gradient_state],\n           ['`phase_gradient_state`'])\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: Imports necessary modules from Qualtran, typing, numpy, sympy, and cirq for defining and using quantum bloqs, data structures, and mathematical operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/zpow_via_phase_gradient.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph\nDESCRIPTION: Generates the call graph and resource counts sigma for `state_prep_via_rotation` using `call_graph` and `ignore_split_join`. The resulting graph and counts are then displayed using `show_call_graph` and `show_counts_sigma`, providing insight into the resources required for the state preparation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nstate_prep_via_rotation_g, state_prep_via_rotation_sigma = state_prep_via_rotation.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(state_prep_via_rotation_g)\nshow_counts_sigma(state_prep_via_rotation_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display GF2Inverse Graphical Signature\nDESCRIPTION: Uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `gf16_inverse` instance. This provides a visual representation of the bloq's inputs, outputs, and internal structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_inverse.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf16_inverse],\n           ['`gf16_inverse`'])\n```\n\n----------------------------------------\n\nTITLE: Generating and displaying a call graph for LessThanEqual\nDESCRIPTION: This generates a call graph for the `leq` bloq, which visualizes the dependencies and sub-components within the quantum circuit. It also computes and displays the resource counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nleq_g, leq_sigma = leq.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(leq_g)\nshow_counts_sigma(leq_sigma)\n```\n\n----------------------------------------\n\nTITLE: CModNeg Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma of the `CModNeg` bloq, using the `ignore_split_join` generalizer. This helps in resource estimation for the controlled modular negation operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncmod_neg_g, cmod_neg_sigma = cmod_neg.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cmod_neg_g)\nshow_counts_sigma(cmod_neg_sigma)\n```\n\n----------------------------------------\n\nTITLE: Cost Calculation for Cirq Circuit\nDESCRIPTION: This function calculates the quantum error correction (QEC) gate cost for a given Cirq circuit containing Qualtran Bloqs. It iterates through the operations in the circuit, retrieves the cost of each Bloq, and returns the total cost as a QECGatesCost object.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq\nfrom qualtran.resource_counting import get_cost_value, QECGatesCost, GateCounts\n\ndef get_qec_gates_cost_for_circuit(circuit):\n    # Usually, you'd combine this into a bloq of its own, but we\n    # use this helper function to add up the costs of the bloqs\n    # found within the circuit.\n    cost_key = QECGatesCost()\n    costs_cache = {}\n    total_cost = cost_key.zero()\n    for op in circuit.all_operations():\n        if not isinstance(op.gate, Bloq):\n            # Skip state prep and QFT for now\n            continue\n    \n        bloq = op.gate\n        total_cost += get_cost_value(bloq, cost_key, costs_cache=costs_cache)\n    \n    return total_cost\n\nget_qec_gates_cost_for_circuit(circuit)\n```\n\n----------------------------------------\n\nTITLE: Calculating T Complexity of Adjoint of Two-Qubit And Gate in Qualtran\nDESCRIPTION: This snippet creates the adjoint of a two-qubit And gate and calculates its T complexity. The decomposition of the adjoint And gate involves H gate, measurement, CZ gate, and Reset.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/cirq_interop/t_complexity.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngate = And() ** -1 # adjoint of And\n# the deomposition is H, measure, CZ, and Reset\nprint(t_complexity(gate))\n```\n\n----------------------------------------\n\nTITLE: CtrlSpecAnd with Symbolic Control Value\nDESCRIPTION: This example demonstrates the use of symbolic control values in `CtrlSpecAnd`. `Shaped((2,))` creates a symbolic representation for a vector of length 2 which is then used as control values\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import CtrlSpec\nfrom qualtran.symbolics import Shaped\n\nctrl_on_symbolic_cv = CtrlSpecAnd(CtrlSpec(cvs=Shaped((2,))))\n```\n\n----------------------------------------\n\nTITLE: GlobalPhase Instance Creation\nDESCRIPTION: Creates an instance of the `GlobalPhase` gate with an exponent of 0.5. This example demonstrates how to instantiate the `GlobalPhase` class with a specific phase.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/global_phase.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nglobal_phase = GlobalPhase(exponent=0.5)\n```\n\n----------------------------------------\n\nTITLE: Approximating Alpha for First Quantization\nDESCRIPTION: This function computes a rough estimate of the first quantized one-norm (alpha). It takes the volume of the simulation cell, the number of electrons, and the number of bits representing the basis as input. It returns an approximation of alpha.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef approximate_alpha_first_quantization(vol: float, eta: int, num_bits_p: int) -> float:\n    \"\"\"Compute a very rough estimate of the first quantized one-norm.\n\n    Args:\n        vol: The volume of the simulation cell.\n        eta: The number of electrons.\n        num_bits_p: The number of bits for representing the basis.\n\n    References:\n    [Fault-Tolerant Quantum Simulations of Chemistry in First Quantization](https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.2.040332)\n        Eq. 25.\n    \"\"\"\n    # simple cubic simulation_cell\n    num_pw = (2**num_bits_p - 1) ** 3\n    lambda_t = 6 * eta * np.pi**2 / (vol**(2.0/3.0)) * (2**(num_bits_p - 1) - 1)**2\n    lambda_u = eta**2 * (num_pw  / vol)**(1.0/3.0)\n    lambda_v = eta**2 * (num_pw / vol)**(1.0/3.0)\n    return lambda_t + lambda_u + lambda_v\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of KaiserWindowState Bloqs\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical representation (signature) of the previously created `kaiser_window_state_small` and `kaiser_window_state_symbolic` bloqs.  Visualizing bloqs aids in understanding their structure and connections.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([kaiser_window_state_small, kaiser_window_state_symbolic],\n           ['`kaiser_window_state_small`', '`kaiser_window_state_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Create ZeroState Instance\nDESCRIPTION: Creates an instance of the `ZeroState` bloq, representing the |0> quantum state. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nzero_state = ZeroState()\n```\n\n----------------------------------------\n\nTITLE: Define and visualize a bloq with interior allocation\nDESCRIPTION: Defines a bloq `InteriorAlloc` with an interior allocation using `sympy` to define a symbolic size 'n' and then visualizes the bloq using `show_bloq`. The visualization includes the original bloq and its decomposition, shown as a musical score.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/resource_counting/qubit_counts.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.Symbol('n', positive=True, integer=True)\nbloq = InteriorAlloc(n=n)\nshow_bloq(bloq)\nshow_bloq(bloq.decompose_bloq(), 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: Show Call Graph for QvrZPow\nDESCRIPTION: This snippet generates and displays the call graph for `square_via_zpow_phasing`. It generates the call graph and sigma counts using `call_graph` with default parameters. It then displays the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phasing_via_cost_function.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsquare_via_zpow_phasing_g, square_via_zpow_phasing_sigma = square_via_zpow_phasing.call_graph()\nshow_call_graph(square_via_zpow_phasing_g)\nshow_counts_sigma(square_via_zpow_phasing_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show Product Bloq\nDESCRIPTION: Displays the `Product` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([product],\n           ['`product`'])\n```\n\n----------------------------------------\n\nTITLE: SelectFirstQuantization bloq definition\nDESCRIPTION: This snippet imports the `SelectFirstQuantization` class from `qualtran.bloqs.chemistry.pbc.first_quantization`. This class is a Qualtran `Bloq` implementing the SELECT operation for the first quantized chemistry Hamiltonian, enabling the selection of Hamiltonian terms during quantum simulation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization import SelectFirstQuantization\n```\n\n----------------------------------------\n\nTITLE: Show Musical Score of CYGate (Python)\nDESCRIPTION: This snippet utilizes `show_bloq` to create and display a 'musical score' representation of the CY gate, providing an alternative visualization of its quantum operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(cy_gate, 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: CtrlSpecAnd with Multi-Dimensional Bit Controls\nDESCRIPTION: This snippet showcases how to create a `CtrlSpecAnd` instance with a control specification based on a NumPy array of bits. The `CtrlSpec` is defined with `QBit` data type and a 2D NumPy array `[[0, 1], [1, 0]]` as control values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nfrom qualtran import CtrlSpec, QBit\n\nctrl_on_nd_bits = CtrlSpecAnd(CtrlSpec(qdtypes=QBit(), cvs=np.array([[0, 1], [1, 0]]]))\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library and other standard Python libraries like typing, numpy, sympy, and cirq. These modules provide functionalities for defining quantum algorithms, creating quantum gates, and performing symbolic calculations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/product.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Cost Calculation with Included Bloq Example\nDESCRIPTION: This snippet demonstrates how to directly calculate the cost of a pre-defined Bloq for phase estimation of the Hubbard model, using `get_cost_value` and `QECGatesCost` from Qualtran.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/phase_estimation_of_quantum_walk.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Or, we can just use the included bloq example directly\n\nfrom qualtran.bloqs.phase_estimation.qubitization_qpe import _qubitization_qpe_hubbard_model_large\nqpe = _qubitization_qpe_hubbard_model_large.make()\n%time result = get_cost_value(qpe, QECGatesCost())\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Importing the Toffoli gate from qualtran\nDESCRIPTION: This snippet imports the `Toffoli` class from the `qualtran.bloqs.basic_gates` module, which represents the Toffoli gate implementation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/toffoli.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Toffoli\n```\n\n----------------------------------------\n\nTITLE: Create Multi-Dimensional SwapWithZero Instance (Duplicated)\nDESCRIPTION: Creates another multi-dimensional SwapWithZero instance, identical to the earlier one.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nswz_multi_dimensional = SwapWithZero(\n    selection_bitsizes=(2, 2), target_bitsize=2, n_target_registers=(3, 4)\n)\n```\n\n----------------------------------------\n\nTITLE: Import Statements\nDESCRIPTION: Imports necessary libraries and modules from qualtran, typing, numpy, sympy, and cirq. These are used for defining quantum circuits, data types, and visualization tools.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import ZeroEffect Bloq\nDESCRIPTION: Imports the `ZeroEffect` class from the `qualtran.bloqs.basic_gates` module. `ZeroEffect` represents the <0| quantum effect.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import ZeroEffect\n```\n\n----------------------------------------\n\nTITLE: Calculating T Complexity of N-Qubit And Gate in Qualtran\nDESCRIPTION: This snippet creates an And gate operating on 'n' qubits and calculates its T complexity. The MultiAnd gate is used to implement the AND operation across multiple control qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/cirq_interop/t_complexity.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn = 5\ngate = MultiAnd((1,)*n)\nprint(t_complexity(gate))\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature Display\nDESCRIPTION: Displays the graphical representation of the `apply_z_to_odd` bloq using the `show_bloqs` function from `qualtran.drawing`. This provides a visual representation of the bloq and its registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_gate_to_lth_target.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([apply_z_to_odd],\n           ['`apply_z_to_odd`'])\n```\n\n----------------------------------------\n\nTITLE: Importing the QFTPhaseGradient class\nDESCRIPTION: This line imports the `QFTPhaseGradient` class from the `qualtran.bloqs.qft` module, enabling its usage in the subsequent code.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/qft_phase_gradient.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.qft import QFTPhaseGradient\n```\n\n----------------------------------------\n\nTITLE: Instantiate LPResourceState with a fixed bitsize\nDESCRIPTION: This code creates an instance of the `LPResourceState` Bloq with a specified `bitsize` of 5. This instance will prepare the optimal resource state using 5 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nlp_resource_state_small = LPResourceState(5)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature Display\nDESCRIPTION: This snippet uses `qualtran.drawing.show_bloqs` to display graphical signatures of `gf16_square` and `gf2_square_symbolic`. This visualization helps understand the input and output registers of the GF(2^m) squaring bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_square.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([gf16_square, gf2_square_symbolic],\n           ['`gf16_square`', '`gf2_square_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules\nDESCRIPTION: This snippet imports necessary modules from qualtran, typing, numpy, sympy and cirq for defining and manipulating quantum circuits and data structures.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phasing_via_cost_function.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import * \nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of SimpleGuidingState\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display graphical representations of the symbolic and concrete `SimpleGuidingState` instances. This allows for visualizing the structure and registers of the quantum bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([simple_guiding_state_symb, simple_guiding_state],\n           ['`simple_guiding_state_symb`', '`simple_guiding_state`'])\n```\n\n----------------------------------------\n\nTITLE: ParallelComparators Instance Example\nDESCRIPTION: An example of instantiating `ParallelComparators` with a list of size 7, an offset of 2, and a bitsize of 3. This creates a `ParallelComparators` object for comparing and swapping elements in parallel.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/sorting.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nparallel_compare = ParallelComparators(7, 2, bitsize=3)\n```\n\n----------------------------------------\n\nTITLE: BinaryPolynomialMultiplication Bloq Definition\nDESCRIPTION: Defines the `BinaryPolynomialMultiplication` bloq for out-of-place multiplication of binary polynomials. It performs the transformation |f>|g>|h> -> |f>|g>|h + fg>. The construction has a Toffoli cost of $n^{\\log_2{3}}$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import BinaryPolynomialMultiplication\n```\n\n----------------------------------------\n\nTITLE: Importing CModNeg class\nDESCRIPTION: Imports the `CModNeg` class from the `qualtran.bloqs.mod_arithmetic` module. `CModNeg` performs controlled modular negation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import CModNeg\n```\n\n----------------------------------------\n\nTITLE: Creating Instances of ECAdd with Small Concrete Values in Qualtran\nDESCRIPTION: This code snippet demonstrates creating an instance of the `ECAdd` class with concrete values for its parameters. It creates an `ECAdd` instance with a bitsize of 5 and a modulus of 7. This provides a small example that can be used for simulation and verification.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ec_add.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nec_add_small = ECAdd(5, mod=7)\n```\n\n----------------------------------------\n\nTITLE: Import Product Bloq\nDESCRIPTION: Imports the `Product` class from the `qualtran.bloqs.arithmetic` module. This bloq computes the product of two integers a and b.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import Product\n```\n\n----------------------------------------\n\nTITLE: Comparing Bloq Instances for Value Equality in Python\nDESCRIPTION: Illustrates how Bloqs implement value-equality based on their attributes.  This snippet shows that two MultiCNOT Bloqs with the same n value (100 in this case) are considered equal.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/Readme.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> MultiCNOT(n=100) == MultiCNOT(n=100)\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules for GF(2^m) polynomial addition\nDESCRIPTION: Imports modules from qualtran for defining quantum registers, bloqs, and other quantum operations. It also imports standard python libraries like numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import statements for ECC bloqs\nDESCRIPTION: Imports necessary modules from Qualtran, including bloq building blocks, data structures for qubits, integers, and generic data types. It also imports standard Python libraries like `numpy`, `sympy`, and `cirq` for numerical computations, symbolic manipulation, and quantum circuit operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Verifying State Preparation Accuracy\nDESCRIPTION: This snippet verifies the accuracy of the state preparation circuit by comparing the obtained coefficients with the original state coefficients. It calculates the dot product between the obtained coefficients and the conjugate of the original coefficients. It also prints the coefficients in polar form for comparison.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\naccuracy = np.dot(coefficients, np.array(state_coefs).conj())\n\nprint(f\"original state used: {tuple(state_coefs)}\")\nprint(f\"circuit result:      {tuple(coefficients)}\\n\")\nprint(f\"accuracy: {abs(accuracy)}\\n\")\n\nprint(\"Comparison (coefficients in polar form):\")\nfor i, (c, s) in enumerate(zip(coefficients, state_coefs)):\n    print(f\"  |{i:0{state_bitsize}b}> result: {round(abs(c),4)} {round(np.angle(c, deg=True),2)}  \"+\\\n          f\"exact: {round(abs(s),4)} {round(np.angle(s, deg=True),2)}\")\n```\n\n----------------------------------------\n\nTITLE: Show the graphical signature\nDESCRIPTION: Generates and displays the graphical signature of the `trott_unitary` bloq. This visual representation illustrates the inputs and outputs of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/trotterized_unitary.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([trott_unitary],\n           ['`trott_unitary`'])\n```\n\n----------------------------------------\n\nTITLE: Import SelectFirstQuantizationWithProj\nDESCRIPTION: This imports the `SelectFirstQuantizationWithProj` class from the specified module. This class is responsible for the SELECT operation within the first quantized chemistry Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.projectile import SelectFirstQuantizationWithProj\n```\n\n----------------------------------------\n\nTITLE: Allocate Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `Allocate` bloq. It uses the `show_bloqs` function to visualize the bloq's input and output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([alloc],\n           ['`alloc`'])\n```\n\n----------------------------------------\n\nTITLE: QROM Imports and Setup - Python\nDESCRIPTION: This snippet imports necessary modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `QBit`, `QInt`, `QUInt`, `QAny`, and tools for visualization such as `show_bloq`, `show_call_graph`, and `show_counts_sigma`. It also imports standard Python libraries like `typing`, `numpy`, `sympy`, and `cirq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: ReflectionAroundZero Example\nDESCRIPTION: Creates an instance of `ReflectionUsingPrepare` that reflects around the zero state. The `bitsizes` parameter specifies the size of the registers. The `global_phase` is set to -1, and the `control_val` is set to 1, making it a controlled reflection.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nrefl_around_zero = ReflectionUsingPrepare.reflection_around_zero(\n    bitsizes=(1, 2, 3), global_phase=-1, control_val=1\n)\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation with AutoPartition\nDESCRIPTION: Generates the call graph for the `auto_partition` bloq using `call_graph`. The `ignore_split_join` generalizer is used to simplify the graph, and the resulting call graph and counts sigma are displayed using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nauto_partition_g, auto_partition_sigma = auto_partition.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(auto_partition_g)\nshow_counts_sigma(auto_partition_sigma)\n```\n\n----------------------------------------\n\nTITLE: HamiltonianSimulationByGQSP Import\nDESCRIPTION: Imports the `HamiltonianSimulationByGQSP` class from the `qualtran.bloqs.hamiltonian_simulation.hamiltonian_simulation_by_gqsp` module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/hamiltonian_simulation/hamiltonian_simulation_by_gqsp.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.hamiltonian_simulation.hamiltonian_simulation_by_gqsp import HamiltonianSimulationByGQSP\n```\n\n----------------------------------------\n\nTITLE: Example Instance of SelectFirstQuantizationWithProj\nDESCRIPTION: This code creates an instance of the `SelectFirstQuantizationWithProj` class. It configures the object with specific values for parameters such as `num_bits_p`, `num_bits_n`, `eta`, `num_atoms`, and `lambda_zeta`, which represent properties of the quantum system being simulated.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_p = 6\nnum_bits_n = 8\neta = 10\nnum_atoms = 10\nlambda_zeta = 10\nsel_first_quant = SelectFirstQuantizationWithProj(\n    num_bits_p, num_bits_n, eta, num_atoms, lambda_zeta\n)\n\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Modular Division\nDESCRIPTION: This code imports necessary modules from the qualtran library for defining and manipulating quantum circuits, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register. It also imports type hinting modules, numpy, sympy, and cirq for numerical and symbolic calculations and circuit simulation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_division.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Call Graph\nDESCRIPTION: This snippet generates and displays the call graph for the `walk_op` bloq. The `ignore_split_join` generalizer is used to simplify the graph by ignoring split and join operations. The resulting graph `walk_op_g` is then visualized using `show_call_graph`, and the counts sigma `walk_op_sigma` is shown with `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nwalk_op_g, walk_op_sigma = walk_op.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(walk_op_g)\nshow_counts_sigma(walk_op_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generating Call Graph for MontgomeryModMul\nDESCRIPTION: Generates and displays the call graph for the `dirtyoutofplacemontgomerymodmul_small` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ndirtyoutofplacemontgomerymodmul_small_g, dirtyoutofplacemontgomerymodmul_small_sigma = dirtyoutofplacemontgomerymodmul_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(dirtyoutofplacemontgomerymodmul_small_g)\nshow_counts_sigma(dirtyoutofplacemontgomerymodmul_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of SelectFirstQuantizationWithProj\nDESCRIPTION: This code generates and displays the graphical signature of the `sel_first_quant` object, allowing users to visualize its structure and understand its functionality within the larger quantum algorithm. The `show_bloqs` function displays a visual representation of the quantum bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sel_first_quant],\n           ['`sel_first_quant`'])\n```\n\n----------------------------------------\n\nTITLE: Display Call Graph and Sigma Counts for Negate\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `negate` instance, using `ignore_split_join` as a generalizer to simplify the graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/negate.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nnegate_g, negate_sigma = negate.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(negate_g)\nshow_counts_sigma(negate_sigma)\n```\n\n----------------------------------------\n\nTITLE: CtrlSpecAnd with Integer Control\nDESCRIPTION: This example demonstrates how to instantiate `CtrlSpecAnd` with an integer control. A `CtrlSpec` is created with a `QUInt(4)` data type and a control value of `0b0101`. The `CtrlSpecAnd` instance is then created using this `CtrlSpec`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import CtrlSpec, QUInt\n\nctrl_on_int = CtrlSpecAnd(CtrlSpec(qdtypes=QUInt(4), cvs=[0b0101]))\n```\n\n----------------------------------------\n\nTITLE: Show Call Graph for QvrPhaseGradient\nDESCRIPTION: This snippet generates and displays the call graph for `square_via_phase_gradient`. It first generates the call graph and sigma counts using `call_graph` with a maximum depth of 1 and the `ignore_split_join` generalizer. It then displays the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phasing_via_cost_function.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsquare_via_phase_gradient_g, square_via_phase_gradient_sigma = square_via_phase_gradient.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(square_via_phase_gradient_g)\nshow_counts_sigma(square_via_phase_gradient_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show PlusEqualProduct Bloq\nDESCRIPTION: Displays the `PlusEqualProduct` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([plus_equal_product],\n           ['`plus_equal_product`'])\n```\n\n----------------------------------------\n\nTITLE: Example `ECWindowAddR` instantiation\nDESCRIPTION: Demonstrates how to instantiate the `ECWindowAddR` bloq with concrete values: $n=16$, $mod=7$, $curve_a=3$, $P = (2, 2)$, and `add_window_size=4`. An instance `ec_window_add_r_small` is created.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nn = 16\nP = ECPoint(2, 2, mod=7, curve_a=3)\nec_window_add_r_small = ECWindowAddR(n=n, R=P, add_window_size=4)\n```\n\n----------------------------------------\n\nTITLE: Show OneState Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `OneState` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([one_state],\n           ['`one_state`'])\n```\n\n----------------------------------------\n\nTITLE: Generate call graph for Subtract gate\nDESCRIPTION: Generates and displays the call graph for the `Subtract` gate with a symbolic size 'n'. The call graph shows the gate's dependencies on other gates. The `ignore_split_join` generalizer simplifies the graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsub_symb_g, sub_symb_sigma = sub_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sub_symb_g)\nshow_counts_sigma(sub_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import the GF2PolyAdd class\nDESCRIPTION: Imports the `GF2PolyAdd` class from the `qualtran.bloqs.gf_poly_arithmetic` module to perform polynomial addition over GF(2^m).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_poly_arithmetic import GF2PolyAdd\n```\n\n----------------------------------------\n\nTITLE: Import ModAdd from qualtran.bloqs.mod_arithmetic\nDESCRIPTION: Imports the `ModAdd` class from the `qualtran.bloqs.mod_arithmetic` module. This class implements a modular addition gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import ModAdd\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: Imports necessary modules from Qualtran and other libraries such as NumPy, SymPy, and Cirq. This sets up the environment for defining and using block encodings and other quantum operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/phase.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Allocating Named Qubits\nDESCRIPTION: This snippet demonstrates how to allocate a dictionary of named qubits based on the signature of the `MyGate` instance using the `get_named_qubits` function.  These named qubits can be used to create a `cirq.Operation` from the gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran._infra.gate_with_registers import get_named_qubits\n\nr = gate.signature\nquregs = get_named_qubits(r)\nquregs\n```\n\n----------------------------------------\n\nTITLE: ToContiguousIndex Instantiation\nDESCRIPTION: Creates an instance of the `ToContiguousIndex` class with specified bitsizes for input and output registers. The `bitsize` parameter determines the number of bits for the 'mu' and 'nu' registers, while `s_bitsize` determines the number of bits for the contiguous register 's'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/contiguous_index.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nto_contg_index = ToContiguousIndex(bitsize=4, s_bitsize=8)\n```\n\n----------------------------------------\n\nTITLE: GF2Square Class Import\nDESCRIPTION: This snippet imports the `GF2Square` class from the `qualtran.bloqs.gf_arithmetic` module. The `GF2Square` class is used for implementing in-place squaring of elements in a Galois field GF(2^m).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_square.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2Square\n```\n\n----------------------------------------\n\nTITLE: Visualize PairPotential\nDESCRIPTION: This snippet visualizes the `PairPotential` bloq's graphical signature using `show_bloqs` from `qualtran.drawing`. It displays the bloq with the label '`pair_potential`'.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([pair_potential],\n           ['`pair_potential`'])\n```\n\n----------------------------------------\n\nTITLE: Distinguishing Bloq Instances within CompositeBloq in Python\nDESCRIPTION: Explains that BloqInstance objects represent unique instantiations of a Bloq within a CompositeBloq. Even if the same Bloq (e.g., Hadamard) is added multiple times, each instance is distinct due to its position in the data flow.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/Readme.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> binst1, (q,) = bb.add_2(H, q=q)\n>>> binst2, (q,) = bb.add_2(H, q=q)\n>>> binst1 != binst2  # one `H` comes before the other.\n```\n\n----------------------------------------\n\nTITLE: TestMultiRegister Bloq\nDESCRIPTION: Shows the bloq diagram for `TestMultiRegister`, a bloq with many registers used as an example sub-bloq. This is used in conjunction with the `Partition` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.for_testing.many_registers import TestMultiRegister\n\nsubbloq = TestMultiRegister()\nshow_bloq(subbloq)\n```\n\n----------------------------------------\n\nTITLE: Create IntEffect Instance\nDESCRIPTION: Creates an instance of the `IntEffect` bloq, representing the <val| quantum effect for a non-negative integer val. It takes the integer value and the bitsize as parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nint_effect = IntEffect(55, bitsize=8)\n```\n\n----------------------------------------\n\nTITLE: PhaseGradientUnitary Symbolic Example Instance\nDESCRIPTION: Creates an instance of the `PhaseGradientUnitary` Bloq with a symbolic bitsize 'n'. This creates an operation with a parameter 'n' which determines the bitsize of the phase gradient unitary.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn = sympy.symbols('n')\nphase_gradient_unitary_symbolic = PhaseGradientUnitary(bitsize=n)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of GuidingState\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display graphical representations of the symbolic and concrete `GuidingState` instances. This allows for visualizing the structure and registers of the quantum bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([guiding_state_symb_c, guiding_state_symb, guiding_state],\n           ['`guiding_state_symb_c`', '`guiding_state_symb`', '`guiding_state`'])\n```\n\n----------------------------------------\n\nTITLE: Show ScaleIntByReal Bloq\nDESCRIPTION: Displays the `ScaleIntByReal` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([scale_int_by_real],\n           ['`scale_int_by_real`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for Sparse State Preparation\nDESCRIPTION: This code generates and displays the call graph for the `sparse_state_prep_alias` bloq using the `call_graph` method with a specified maximum depth and generalizer. The call graph provides information on the resource requirements for the sparse state preparation.  The `ignore_split_join` generalizer simplifies the graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsparse_state_prep_alias_g, sparse_state_prep_alias_sigma = sparse_state_prep_alias.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sparse_state_prep_alias_g)\nshow_counts_sigma(sparse_state_prep_alias_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature Visualization\nDESCRIPTION: Generates and displays a graphical representation of the `to_contg_index` bloq using `show_bloqs` from `qualtran.drawing`. This helps visualize the input and output registers and the overall structure of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/contiguous_index.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([to_contg_index],\n           ['`to_contg_index`'])\n```\n\n----------------------------------------\n\nTITLE: MultiControlX Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `MultiControlX` instance using `qualtran.drawing.show_bloqs`. This provides a visual representation of the gate and its control and target registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ccpauli],\n           ['`ccpauli`'])\n```\n\n----------------------------------------\n\nTITLE: Summarizing Results for basic_gates\nDESCRIPTION: This snippet summarizes the results of the Bloq report card for the `basic_gates` package. It uses `report_card.query('package == \"basic_gates\"')` to filter the report card data to only include entries where the package is equal to 'basic_gates'. The filtered report card is then passed to `summarize_results()` for summarization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsummarize_results(report_card.query('package == \"basic_gates\"'))\n```\n\n----------------------------------------\n\nTITLE: ModNeg Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `ModNeg` bloq using the `show_bloqs` function. This visualization helps understand the input and output registers of the gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([mod_neg],\n           ['`mod_neg`'])\n```\n\n----------------------------------------\n\nTITLE: Free Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `Free` bloq. This visualization helps understand the flow of quantum data through the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([free],\n           ['`free`'])\n```\n\n----------------------------------------\n\nTITLE: Qualtran Imports and Setup\nDESCRIPTION: Imports necessary modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `BloqBuilder`, `Signature`, `Register`, `QBit`, `QInt`, `QUInt`, and `QAny`. Also imports `typing`, `numpy`, `sympy`, and `cirq` for use in the examples.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/hamiltonian_simulation/hamiltonian_simulation_by_gqsp.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Creating an instance of ZPowConstViaPhaseGradient with numeric precision\nDESCRIPTION: Creates an instance of `ZPowConstViaPhaseGradient` with a specific angle (3/8) and error tolerance (1e-11) for numerical precision.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/zpow_via_phase_gradient.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nzpow_const_via_phase_grad = ZPowConstViaPhaseGradient.from_precision(3 / 8, eps=1e-11)\n```\n\n----------------------------------------\n\nTITLE: XPowGate Call Graph\nDESCRIPTION: Generates and displays the call graph of the `XPowGate` bloq, ignoring split/join operations. This reveals the gate's internal structure and dependencies for resource estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nx_pow_g, x_pow_sigma = x_pow.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(x_pow_g)\nshow_counts_sigma(x_pow_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiate LPRSInterimPrep\nDESCRIPTION: This code creates an instance of the `LPRSInterimPrep` Bloq with a specified `bitsize` of 5. This instance will prepare the intermediate resource state with 5 qubits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlprs_interim_prep = LPRSInterimPrep(5)\n```\n\n----------------------------------------\n\nTITLE: Instantiate CZ\nDESCRIPTION: This code instantiates the `CZ` class, creating an object `cz` representing the CZ gate. This object can then be used within a quantum circuit definition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncz = CZ()\n```\n\n----------------------------------------\n\nTITLE: Import PotentialEnergy\nDESCRIPTION: This snippet imports the `PotentialEnergy` class from the `qualtran.bloqs.chemistry.trotter.grid_ham` module. This class implements the Coulombic unitary.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.grid_ham import PotentialEnergy\n```\n\n----------------------------------------\n\nTITLE: Create ZeroEffect Instance\nDESCRIPTION: Creates an instance of the `ZeroEffect` bloq, representing the <0| quantum effect. This instance can be used in larger quantum circuits or simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nzero_effect = ZeroEffect()\n```\n\n----------------------------------------\n\nTITLE: Instantiate RectangularWindowState with symbolic size\nDESCRIPTION: Re-creates an instance of `RectangularWindowState` with a symbolic size 'n' using `sympy.Symbol`. This allows for the creation of a symbolic instance that can be used for resource estimation or other symbolic calculations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nrectangular_window_state_symbolic = RectangularWindowState(sympy.Symbol('n'))\n```\n\n----------------------------------------\n\nTITLE: Import SubtractFrom gate from Qualtran\nDESCRIPTION: Imports the `SubtractFrom` gate from the `qualtran.bloqs.arithmetic` module. This gate performs an in-place subtraction operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import SubtractFrom\n```\n\n----------------------------------------\n\nTITLE: Show IntState Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `IntState` bloq using `show_bloqs` from `qualtran.drawing`. This visualization helps understand the bloq's inputs, outputs, and overall structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([int_state],\n           ['`int_state`'])\n```\n\n----------------------------------------\n\nTITLE: Adding Flattened CompositeBloq - Python\nDESCRIPTION: Demonstrates `bb.add_from` with a decomposed `TestParallelCombo`. This flattens the substructure inline as opposed to simply flattening one layer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/composite_bloq.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# `add_from` on middle one\nbb = BloqBuilder()\nstuff = bb.add_register('stuff', 3)\nstuff, = bb.add_t(TestParallelCombo(), reg=stuff)\nstuff, = bb.add_from(TestParallelCombo().decompose_bloq(), reg=stuff)\nstuff, = bb.add_t(TestParallelCombo(), reg=stuff)\n\nbloq = bb.finalize(stuff=stuff)\nshow_bloq(bloq)\n```\n\n----------------------------------------\n\nTITLE: Citation information for Qualtran (bibtex)\nDESCRIPTION: This is the BibTeX entry to cite Qualtran in publications. It provides the necessary information for proper attribution.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/README.md#_snippet_4\n\nLANGUAGE: bibtex\nCODE:\n```\n@misc{harrigan2024qualtran,\n    title={Expressing and Analyzing Quantum Algorithms with Qualtran},\n    author={Matthew P. Harrigan and Tanuj Khattar\n        and Charles Yuan and Anurudh Peduri and Noureldin Yosri\n        and Fionn D. Malone and Ryan Babbush and Nicholas C. Rubin},\n    year={2024},\n    eprint={2409.04643},\n    archivePrefix={arXiv},\n    primaryClass={quant-ph},\n    doi={10.48550/arXiv.2409.04643},\n    url={https://arxiv.org/abs/2409.04643},\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying: Displaying Unparsed References\nDESCRIPTION: This snippet identifies and prints unparsed references. It iterates through the `references` dictionary and checks if a reference is an instance of `UnparsedReference`. If so, it prints the name of the bloq class and the unparsed reference text.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bibliography.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfor bloq_cls, refs in references.items():\n    for ref in refs:\n        if isinstance(ref, UnparsedReference):\n            print(bloq_cls.__name__)\n            print(ref.text)\n```\n\n----------------------------------------\n\nTITLE: Instantiate And bloq\nDESCRIPTION: This code snippet creates an instance of the `And` bloq without any parameters. This `and_bloq` instance can then be used to perform the two-bit AND operation within a larger quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/and_bloq.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nand_bloq = And()\n```\n\n----------------------------------------\n\nTITLE: Import statements for Qualtran and dependencies\nDESCRIPTION: This snippet imports necessary modules from the Qualtran library, including Bloq, CompositeBloq, BloqBuilder, Signature, and Register, as well as type hints and external libraries like numpy, sympy, and cirq. These imports are fundamental for defining and manipulating quantum circuits within the Qualtran framework.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/prepare_uniform_superposition.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show Call Graph of LPResourceState\nDESCRIPTION: This code snippet generates and displays the call graph of the `lp_resource_state_small` Bloq using `lp_resource_state_small.call_graph` and `show_call_graph`. The `ignore_split_join` generalizer is used. `show_counts_sigma` displays the sigma counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nlp_resource_state_small_g, lp_resource_state_small_sigma = lp_resource_state_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(lp_resource_state_small_g)\nshow_counts_sigma(lp_resource_state_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import SingleFactorizationOneBody Bloq\nDESCRIPTION: This line imports the `SingleFactorizationOneBody` class from the `qualtran.bloqs.chemistry.sf.single_factorization` module. This bloq represents the block encoding of the single factorization one-body Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.sf.single_factorization import SingleFactorizationOneBody\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures of SU2RotationGates\nDESCRIPTION: This snippet generates and displays the graphical signatures of the `su2_rotation_gate`, `hadamard`, and `t_gate` instances. It uses the `show_bloqs` function from `qualtran.drawing` to visualize the gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/su2_rotation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([su2_rotation_gate, hadamard, t_gate],\n           ['`su2_rotation_gate`', '`hadamard`', '`t_gate`'])\n```\n\n----------------------------------------\n\nTITLE: CtrlSpecAnd with Multiple Symbolic Control Values\nDESCRIPTION: This example demonstrates the use of multiple symbolic control values in `CtrlSpecAnd`. `Shaped((3,))` creates a symbolic representation for a vector of length 3 which is then used as control values\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import CtrlSpec\nfrom qualtran.symbolics import Shaped\n\nctrl_on_symbolic_cv_multi = CtrlSpecAnd(CtrlSpec(cvs=Shaped((3,))))\n```\n\n----------------------------------------\n\nTITLE: Instantiate RzViaPhaseGradient with QFxp data types\nDESCRIPTION: This code snippet creates an instance of the `RzViaPhaseGradient` class, specifying `QFxp(4, 4)` as the data type for both the `angle_dtype` and `phasegrad_dtype` parameters. QFxp represents a fixed-point number with 4 integer bits and 4 fractional bits.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/rz_via_phase_gradient.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import QFxp\n\nrz_via_phase_gradient = RzViaPhaseGradient(angle_dtype=QFxp(4, 4), phasegrad_dtype=QFxp(4, 4))\n```\n\n----------------------------------------\n\nTITLE: Import CtrlSpecAnd from Qualtran\nDESCRIPTION: This line imports the `CtrlSpecAnd` class from the `qualtran.bloqs.mcmt` module. `CtrlSpecAnd` is used to compute a single qubit that is 1 only if the control specification of And clauses is satisfied.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/ctrl_spec_and.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mcmt import CtrlSpecAnd\n```\n\n----------------------------------------\n\nTITLE: Call Graph of GF2ShiftRight\nDESCRIPTION: Generates and displays the call graph for the `gf2shiftright` bloq, ignoring split-join operations. This call graph shows the decomposition of the bloq with a maximum depth of 1. Also displays the associated resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf2shiftright_g, gf2shiftright_sigma = gf2shiftright.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf2shiftright_g)\nshow_counts_sigma(gf2shiftright_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate call graph for SubtractFrom gate\nDESCRIPTION: Generates and displays the call graph for the `SubtractFrom` gate with a symbolic size 'n'.  Uses `ignore_split_join` for simplification.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/subtraction.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsub_from_symb_g, sub_from_symb_sigma = sub_from_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sub_from_symb_g)\nshow_counts_sigma(sub_from_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: GQSP with large negative power\nDESCRIPTION: Creates an instance of `GeneralizedQSP` with a larger `negative_power` of 5. The QSP polynomial coefficients remain (0.5, 0, 0.5), and the unitary is `XPowGate`. This highlights the flexibility in setting the `negative_power` parameter.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qsp/generalized_qsp.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import XPowGate\n\ngqsp_with_large_negative_power = GeneralizedQSP.from_qsp_polynomial(\n    XPowGate(), (0.5, 0, 0.5), negative_power=5\n)\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph for CtrlScaleModAdd\nDESCRIPTION: Generates the call graph and associated resource counts for `ctrl_scale_mod_add` with a maximum depth of 1 and using the `ignore_split_join` generalizer. The call graph is displayed using `show_call_graph` and the resource counts are displayed using `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nctrl_scale_mod_add_g, ctrl_scale_mod_add_sigma = ctrl_scale_mod_add.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ctrl_scale_mod_add_g)\nshow_counts_sigma(ctrl_scale_mod_add_sigma)\n```\n\n----------------------------------------\n\nTITLE: ScaledChebyshevPolynomial Example Instance (Odd Order with alpha)\nDESCRIPTION: This code creates an instance of `ScaledChebyshevPolynomial` with an odd order (5). It uses a `Unitary` operation (Hadamard) as the block encoding and evolves it to include an `alpha` parameter of 3.14.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom attrs import evolve\n\nfrom qualtran.bloqs.basic_gates import Hadamard\nfrom qualtran.bloqs.block_encoding import Unitary\n\nbloq = evolve(Unitary(Hadamard()), alpha=3.14)\nscaled_chebyshev_poly_odd = ScaledChebyshevPolynomial(bloq, order=5)\n```\n\n----------------------------------------\n\nTITLE: Import statements\nDESCRIPTION: This code snippet imports necessary modules from the `qualtran` library, including `Bloq`, `CompositeBloq`, `BloqBuilder`, `Signature`, and `Register`, as well as type hinting tools and numerical libraries like `numpy` and `sympy`. It also imports `cirq`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: XPowGate Import\nDESCRIPTION: Imports the `XPowGate` class from the `qualtran.bloqs.basic_gates` module. This gate represents a power of the Pauli X operator.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import XPowGate\n```\n\n----------------------------------------\n\nTITLE: Documenting Args with Docstrings in Qualtran Bloqs (Python)\nDESCRIPTION: This code snippet demonstrates how to document the initialization arguments of a Qualtran Bloq using the 'Args' section in the class docstring. It documents the `n` and `cvs` arguments of the `PrepareUniformSuperposition` class, specifying their purpose and type.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Autodoc.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@attrs.frozen\nclass PrepareUniformSuperposition(Bloq):\n    r\"\"\"Prepares a uniform superposition over first $n$ basis states using $O(log(n))$ T-gates.\n\n    Args:\n        n: The gate prepares a uniform superposition over first $n$ basis states.\n        cvs: Control values for each control qubit. If specified, a controlled version\n            of the gate is constructed.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Sparse State Preparation from Dense List\nDESCRIPTION: This code demonstrates creating `SparseStatePreparationAliasSampling` from a dense list of probabilities `coeffs`. It uses the `from_dense_probabilities` method, specifying a precision calculated from `mu` and the number of non-zero elements in the list. This creates a state preparation bloq that leverages the sparsity.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_alias_sampling.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = [1.0, 0, 0, 1, 0, 3, 0, 2, 0]\nmu = 3\nsparse_state_prep_alias_from_list = (\n    SparseStatePreparationAliasSampling.from_dense_probabilities(coeffs, precision=2**-mu / 4)\n)\n```\n\n----------------------------------------\n\nTITLE: CModSub Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `CModSub` bloq, visualizing its inputs and outputs. This helps to understand the controlled modular subtraction gate's interface.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cmodsub_symb],\n           ['`cmodsub_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Generate and Visualize Qualtran Call Graph\nDESCRIPTION: This code snippet generates a call graph for the `interaction_hwp` component using the `call_graph` method with a specified maximum depth and a generalizer. It then visualizes the graph using `show_call_graph` and displays the resource counts using `show_counts_sigma`.  It depends on `qualtran.resource_counting.generalizers.ignore_split_join` to simplify the call graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/hubbard/hubbard.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ninteraction_hwp_g, interaction_hwp_sigma = interaction_hwp.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(interaction_hwp_g)\nshow_counts_sigma(interaction_hwp_sigma)\n```\n\n----------------------------------------\n\nTITLE: Simulating Theta Estimate from QPE\nDESCRIPTION: The `simulate_theta_estimate` function constructs a composite bloq from a given TextbookQPE bloq, performs a tensor contraction to obtain the final state vector, and samples from this state vector using Cirq.  It then converts the sampled bitstrings into phase estimates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef simulate_theta_estimate(bloq: TextbookQPE, n_samples: int) -> float:\n    cbloq = construct_composite_boq(bloq)\n    final_state = cbloq.tensor_contract()\n    samples = cirq.sample_state_vector(final_state, indices=[*range(bloq.m_bits)], repetitions=n_samples)\n    thetas = samples.dot(1 << np.arange(samples.shape[-1] - 1, -1, -1))\n    return thetas\n```\n\n----------------------------------------\n\nTITLE: Display Graphical Signature of ModAdd in Python\nDESCRIPTION: Uses the `show_bloqs` function from `qualtran.drawing` to display the graphical signature of the `mod_add` bloq.  It takes a list of bloqs and their corresponding labels as input.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([mod_add],\n           ['`mod_add`'])\n```\n\n----------------------------------------\n\nTITLE: Import GF2Inverse from qualtran.bloqs.gf_arithmetic\nDESCRIPTION: Imports the GF2Inverse class from the qualtran.bloqs.gf_arithmetic module.  This class is used to perform out-of-place inversion for elements in GF(2^m).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_inverse.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import GF2Inverse\n```\n\n----------------------------------------\n\nTITLE: Call Graph of SelectFirstQuantizationWithProj\nDESCRIPTION: This code generates and displays the call graph of `sel_first_quant`. The `call_graph` method provides insight into the internal structure and dependencies of the quantum operation.  The `ignore_split_join` generalizer simplifies the visualization by treating split and join operations as trivial.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsel_first_quant_g, sel_first_quant_sigma = sel_first_quant.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sel_first_quant_g)\nshow_counts_sigma(sel_first_quant_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import SelectOracle base class\nDESCRIPTION: This snippet imports the `SelectOracle` base class from the `qualtran.bloqs.multiplexers.select_base` module. `SelectOracle` is an abstract base class that defines the interface for a SELECT Oracle.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.multiplexers.select_base import SelectOracle\n```\n\n----------------------------------------\n\nTITLE: Join Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `Join` bloq, visualizing the transformation from an array of `QBit`s to a `QUInt(4)` register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([join],\n           ['`join`'])\n```\n\n----------------------------------------\n\nTITLE: Import SelectUVFirstQuantization in Python\nDESCRIPTION: Imports the `SelectUVFirstQuantization` class from the `qualtran.bloqs.chemistry.pbc.first_quantization.select_uv` module. This class is responsible for selecting the U and V operators for the first quantized chemistry Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.pbc.first_quantization.select_uv import SelectUVFirstQuantization\n```\n\n----------------------------------------\n\nTITLE: Import TwoBitFFFT from qualtran\nDESCRIPTION: Imports the TwoBitFFFT class from the qualtran.bloqs.qft module, making it available for use in defining and constructing fermionic Fourier transform gates.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/two_bit_ffft.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.qft import TwoBitFFFT\n```\n\n----------------------------------------\n\nTITLE: Showing an EqualsAConstant Bloq\nDESCRIPTION: This snippet displays a graphical representation of the `eq_k` bloq, providing a visual representation of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([eq_k],\n           ['`eq_k`'])\n```\n\n----------------------------------------\n\nTITLE: Importing ZPowConstViaPhaseGradient\nDESCRIPTION: Imports the `ZPowConstViaPhaseGradient` class from the `qualtran.bloqs.rotations` module, which is used for applying a Z**t rotation using a phase gradient.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/zpow_via_phase_gradient.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.rotations import ZPowConstViaPhaseGradient\n```\n\n----------------------------------------\n\nTITLE: Instantiate Identity gate with sympy symbol\nDESCRIPTION: Creates an instance of the `Identity` gate with a symbolic size `n` using the sympy library. This allows defining the gate size at runtime.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/identity.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nn = sympy.Symbol(\"n\")\nidentity_symb = Identity(n)\n```\n\n----------------------------------------\n\nTITLE: Calculating Toffoli Counts for Bloqs\nDESCRIPTION: This snippet calculates the Toffoli counts for three bloqs: `sel_thc`, `prep_thc`, and `prep_thc.adjoint()`. It iterates through the bloqs, calculates the Toffoli counts for each, and stores the results in a list.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntoffoli_counts = [get_toffoli_counts(b) for b in [sel_thc, prep_thc, prep_thc.adjoint()]]\nprint(toffoli_counts)\n```\n\n----------------------------------------\n\nTITLE: ReflectionUsingPrepare Example Instance\nDESCRIPTION: This snippet creates an instance of `ReflectionUsingPrepare` using a `StatePreparationAliasSampling` gate. It prepares the state using probabilities derived from the `data` list with a specified precision `eps`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/reflections/reflections.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.state_preparation import StatePreparationAliasSampling\n\ndata = [1] * 5\neps = 1e-2\nprepare_gate = StatePreparationAliasSampling.from_probabilities(data, precision=eps)\n\nrefl_using_prep = ReflectionUsingPrepare(prepare_gate)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran Modules\nDESCRIPTION: Imports necessary modules from the Qualtran library for defining quantum building blocks (Bloqs), composite blocks, and signatures.  Also imports standard Python libraries for numerical computation, symbolic math, and type hints.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: PrepareTHC Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `PrepareTHC` bloq using `show_bloqs`. This visual representation provides an overview of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([thc_prep],\n           ['`thc_prep`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph of GF2Multiplication\nDESCRIPTION: Generates and displays the call graph for the `gf16_multiplication` instance, ignoring split-join operations. The call graph provides insights into the decomposition of the bloq into its constituent operations, up to a maximum depth of 1. It also shows the `sigma` which is a dictionary of resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf16_multiplication_g, gf16_multiplication_sigma = gf16_multiplication.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf16_multiplication_g)\nshow_counts_sigma(gf16_multiplication_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display bloqs slowest to flatten\nDESCRIPTION: Displays Bloq examples that took the longest time to flatten.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndf.sort_values(by='flat_dur', ascending=False).head()\n```\n\n----------------------------------------\n\nTITLE: Create CtrlScaleModAdd instance with symbolic parameters in Python\nDESCRIPTION: Creates an instance of the `CtrlScaleModAdd` class with symbolic parameters 'n', 'm', and 'k' from the sympy library, representing bitsize, modulus, and scaling factor, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nn, m, k = sympy.symbols('n m k')\nctrl_scale_mod_add = CtrlScaleModAdd(bitsize=n, mod=m, k=k)\n```\n\n----------------------------------------\n\nTITLE: Decompose `FindECCPrivateKey` and display\nDESCRIPTION: Decomposes the `FindECCPrivateKey` bloq into its constituent gates and displays the resulting quantum circuit using the `show_bloq` function.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(ecc.decompose_bloq())\n```\n\n----------------------------------------\n\nTITLE: GF2Square Symbolic Instance Creation\nDESCRIPTION: This code snippet demonstrates the creation of a symbolic `GF2Square` instance. It uses the `sympy` library to define a symbolic variable `m`, which is then passed as the `bitsize` parameter to the `GF2Square` constructor. This allows for the creation of a generic GF(2^m) squaring bloq where `m` can be substituted with a concrete value later.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_square.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nm = sympy.Symbol('m')\ngf2_square_symbolic = GF2Square(m)\n```\n\n----------------------------------------\n\nTITLE: MultiplyPolyByOnePlusXk Bloq Definition\nDESCRIPTION: Defines the `MultiplyPolyByOnePlusXk` bloq, which performs out-of-place multiplication of $(1 + x^k) fg$. It applies the transformation  |f>|g>|h> -> |f>|g>|h + (1 + x^k)fg>. The implementation includes a modification to the original algorithm to work for all $k \\leq n+1$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.gf_arithmetic import MultiplyPolyByOnePlusXk\n```\n\n----------------------------------------\n\nTITLE: MultiControlX Instance\nDESCRIPTION: Creates an instance of `MultiControlX` with control values (1, 0, 1, 0, 1). The `cvs` parameter defines the control values. The target qubit is flipped only if all control qubits match their corresponding values in `cvs`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/multi_control_multi_target_pauli.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nccpauli = MultiControlX(cvs=(1, 0, 1, 0, 1))\n```\n\n----------------------------------------\n\nTITLE: CModSub Example Instance\nDESCRIPTION: Creates an instance of the `CModSub` class with symbolic parameters `n` and `p` for the register size and modulus. This provides an example of how to instantiate a controlled modular subtraction gate with symbolic values.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_subtraction.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\ncmodsub_symb = CModSub(QUInt(n), p)\n```\n\n----------------------------------------\n\nTITLE: Allocate Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `Allocate` bloq, ignoring split and join operations. The `call_graph` method is used with a generalizer, and the results are visualized.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nalloc_g, alloc_sigma = alloc.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(alloc_g)\nshow_counts_sigma(alloc_sigma)\n```\n\n----------------------------------------\n\nTITLE: MultiplyTwoReals Example Instance\nDESCRIPTION: Creates an instance of the `MultiplyTwoReals` class with a specified bitsize. This bloq implements $|a\\rangle|b\\rangle|0\\rangle \\rightarrow |a\\rangle|b\\rangle|a \\times b\\rangle$. The real numbers are assumed to be in the range [0, 1).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nmultiply_two_reals = MultiplyTwoReals(bitsize=10)\n```\n\n----------------------------------------\n\nTITLE: Verifying Uncomputing Accuracy\nDESCRIPTION: This code snippet verifies the accuracy of the uncomputing process. The uncomputing process should return the state back to |0>. Therefore, the first element of the tensor product, corresponding to |0>, should be close to 1 and other coefficients should be close to 0. The accuracy and coefficients in polar form are printed for visual verification.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation_tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\naccuracy = coefficients[0] # <coefficients|0> = coefficients[0]\nprint(f\"accuracy: {abs(accuracy)}\\n\")\n\nprint(\"Coefficients in polar form:\")\n# zero out small coefficients\ncoefficients[np.where(abs(coefficients) < 1e-16)] = 0.0\nfor i, c in enumerate(coefficients):\n    print(f\"  |{i:0{state_bitsize}b}> result: {round(abs(c),4)} {round(np.angle(c, deg=True),2)}\")\n```\n\n----------------------------------------\n\nTITLE: TestSerialCombo Adjoint in Qualtran\nDESCRIPTION: This snippet shows how the `Adjoint` meta-bloq is used as a default fallback when a bloq does not override `.adjoint()`. A `TestSerialCombo` bloq is instantiated and its `adjoint()` method is called.  It leverages `TestSerialCombo` from `qualtran.bloqs.for_testing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Adjoint.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.for_testing import TestSerialCombo\n\nbloq = TestSerialCombo()\nbloq.adjoint()\n```\n\n----------------------------------------\n\nTITLE: BinaryPolynomialMultiplication Instance\nDESCRIPTION: Creates an instance of the `BinaryPolynomialMultiplication` bloq with `n=5`. This instance multiplies two binary polynomials of degree 5.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nn = 5\nbinarypolynomialmultiplication = BinaryPolynomialMultiplication(n)\n```\n\n----------------------------------------\n\nTITLE: Partition Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `Partition` bloq, showing the transformation from a single register to multiple registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([partition],\n           ['`partition`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of SelectTHC\nDESCRIPTION: Generates and displays a graphical representation of the `SelectTHC` bloq using `show_bloqs`. This provides a visual representation of the bloq's structure and interfaces.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([thc_sel],\n           ['`thc_sel`'])\n```\n\n----------------------------------------\n\nTITLE: Call graph generation for CSwap gate\nDESCRIPTION: Generates and displays the call graph and resource counts sigma for the `CSwap` gate (controlled swap), using the `call_graph` method and `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/swap.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncswap_g, cswap_sigma = cswap.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cswap_g)\nshow_counts_sigma(cswap_sigma)\n```\n\n----------------------------------------\n\nTITLE: Display the graphical signature of TwoBitFFFT\nDESCRIPTION: Displays the graphical signature of the instantiated TwoBitFFFT gate using qualtran's show_bloqs function, providing a visual representation of the gate's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qft/two_bit_ffft.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([two_bit_ffft],\n           ['`two_bit_ffft`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Count for DoubleFactorizationBlockEncoding\nDESCRIPTION: This code generates and displays the call graph for the `df_block_encoding` bloq, visualizing the interdependencies of sub-bloqs within it.  It also shows the resource counts sigma. The `ignore_split_join` generalizer is used to simplify the call graph by ignoring split and join operations, which are often considered overhead.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ndf_block_encoding_g, df_block_encoding_sigma = df_block_encoding.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(df_block_encoding_g)\nshow_counts_sigma(df_block_encoding_sigma)\n```\n\n----------------------------------------\n\nTITLE: Analyze PrepareFirstQuantization call graph\nDESCRIPTION: This snippet generates and visualizes the call graph and sigma counts for the `prep_first_quant` bloq.  The `ignore_split_join` generalizer simplifies the graph. The call graph shows the bloqs called by `prep_first_quant`, and the sigma counts show the resource costs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprep_first_quant_g, prep_first_quant_sigma = prep_first_quant.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prep_first_quant_g)\nshow_counts_sigma(prep_first_quant_sigma)\n```\n\n----------------------------------------\n\nTITLE: Creating a BiQubitsMixer instance\nDESCRIPTION: This creates an instance of the `BiQubitsMixer` bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nbi_qubits_mixer = BiQubitsMixer()\n```\n\n----------------------------------------\n\nTITLE: Cast Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `Cast` bloq, showing the transformation from one data type to another.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cast],\n           ['`cast`'])\n```\n\n----------------------------------------\n\nTITLE: SparseMatrix Definition\nDESCRIPTION: Defines the `SparseMatrix` class for block encoding of sparse-access matrices, given row, column, and entry oracles. The implementation supports embedding irregular matrices into power-of-two dimensions and handling matrices with at most s non-zero entries by treating some zeroes as non-zero.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding import SparseMatrix\n```\n\n----------------------------------------\n\nTITLE: Drawing Musical Score for Select Bloq (First Quantization)\nDESCRIPTION: This snippet draws the musical score representation of the `SelectFirstQuantization` bloq. It evolves the bloq attributes, decomposes it, retrieves musical score data, and plots the data using `matplotlib`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nmsd = get_musical_score_data(attrs.evolve(sel_fq, eta=2).decompose_bloq())\nfig, ax = draw_musical_score(msd)\nfig.set_size_inches(18, 12)\nax.set_title('Select')\nplt.tick_params(left=False, right=False, labelleft=False, labelbottom=False, bottom=False)\n```\n\n----------------------------------------\n\nTITLE: Permutation Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph for the `permutation` instance. The call graph visualizes the internal structure and dependencies of the `Permutation` bloq. This utilizes `ignore_split_join` to simplify the visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\npermutation_g, permutation_sigma = permutation.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(permutation_g)\nshow_counts_sigma(permutation_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import PairPotential and related functions\nDESCRIPTION: This snippet imports the `PairPotential` class, `build_qrom_data_for_poly_fit` function, and `get_inverse_square_root_poly_coeffs` function from the specified modules. These are used for calculating potential energy between pairs of particles.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.trotter.grid_ham.potential import PairPotential, build_qrom_data_for_poly_fit\nfrom qualtran.bloqs.chemistry.trotter.grid_ham.inverse_sqrt import get_inverse_square_root_poly_coeffs\n```\n\n----------------------------------------\n\nTITLE: Displaying Bloq Report Card for factoring\nDESCRIPTION: This snippet displays the Bloq report card specifically for the `factoring` package. It uses `report_card.query('package == \"factoring\"')` to filter the report card data to only include entries where the package is equal to 'factoring'. The filtered report card is then passed to `show_bloq_report_card()` for display.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/bloq-report-card.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq_report_card(report_card.query('package == \"factoring\"'))\n```\n\n----------------------------------------\n\nTITLE: Square Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `Square` instance, using the `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsquare_g, square_sigma = square.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(square_g)\nshow_counts_sigma(square_sigma)\n```\n\n----------------------------------------\n\nTITLE: GF2Inverse Instance with Symbolic bitsize\nDESCRIPTION: Creates an instance of the `GF2Inverse` class with a symbolic `bitsize` represented by `sympy.Symbol('m')`. This allows for defining GF2Inverse instances with variable bitsizes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_inverse.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nm = sympy.Symbol('m')\ngf2_inverse_symbolic = GF2Inverse(m)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and related modules\nDESCRIPTION: This code snippet imports necessary modules from the `qualtran` library and other standard libraries like `typing`, `numpy`, `sympy`, and `cirq`. These modules are essential for defining quantum circuits and performing related operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Creating DoubleFactorizationBlockEncoding Bloq\nDESCRIPTION: This snippet creates a `DoubleFactorizationBlockEncoding` bloq with specified parameters for the FeMoCo Hamiltonian. It defines the number of auxiliary modes, number of eigenvectors, and number of bits for state preparation and rotation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.df.double_factorization import DoubleFactorizationBlockEncoding\n\n# papameters for the FeMoCo hamiltonian\nnum_aux = 360\nnum_eig = 13031\ndf_bloq = DoubleFactorizationBlockEncoding(num_spin_orb, num_aux, num_eig, num_bits_state_prep, num_bits_rot=num_bits_theta)\n```\n\n----------------------------------------\n\nTITLE: Generate and Display GF2Inverse Call Graph\nDESCRIPTION: Generates a call graph for the `gf16_inverse` instance, ignoring split and join operations for simplification. The call graph visualizes the dependencies and interactions between different bloqs within the GF2Inverse implementation.  It then displays the call graph and counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_inverse.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf16_inverse_g, gf16_inverse_sigma = gf16_inverse.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf16_inverse_g)\nshow_counts_sigma(gf16_inverse_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show BlackBoxBloq Signature\nDESCRIPTION: Displays the signature of the `BlackBoxBloq`, which consists of a single register named \"system\".\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# The signature is now just one register named \"system\"\nshow_bloq(BlackBoxBloq(subbloq))\n```\n\n----------------------------------------\n\nTITLE: Symbolic GuidingState Example\nDESCRIPTION: This snippet creates a `GuidingState` instance with symbolic parameters. It defines symbolic variables for `n`, `m`, and `k` to represent the parameters of the kXOR instance, and then sets \\( \\ell = 2k \\).  It creates a symbolic `KXorInstance` and `GuidingState` object.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.optimization.k_xor_sat import KXorInstance\n\nn, m, k = sympy.symbols(\"n m k\", positive=True, integer=True)\ninst = KXorInstance.symbolic(n=n, m=m, k=k)\nc = 2\nguiding_state_symb = GuidingState(inst, ell=c * inst.k)\n```\n\n----------------------------------------\n\nTITLE: Get bloq examples and exclude specific bloqs\nDESCRIPTION: This snippet retrieves bloq examples using `get_bloq_examples()` and excludes a specific bloq, `ApplyGateToLthQubit`, from the analysis due to pickling issues with its lambda function attributes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbes = get_bloq_examples()\n\n# Imports to exclude certain bloqs, see following comment\nfrom qualtran.bloqs.multiplexers.apply_gate_to_lth_target import ApplyGateToLthQubit\n```\n\n----------------------------------------\n\nTITLE: EC Phase Estimation (Qualtran)\nDESCRIPTION: Defines the `ECPhaseEstimateR` bloq which estimates the phase associated with adding a constant point on an elliptic curve. This function adds the same point multiple times in superposition and measures the phase angle to determine the number of times the point has been added. It takes an elliptic curve point as input and performs phase estimation using ECAddR. It is a subroutine in `FindECCPrivateKey`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.cryptography.ecc import ECPhaseEstimateR\n```\n\n----------------------------------------\n\nTITLE: KaiserWindowState Import\nDESCRIPTION: This snippet imports the `KaiserWindowState` class from the `qualtran.bloqs.phase_estimation.kaiser_window_state` module. This class is used to prepare a Kaiser window state, which is optimal for minimizing the probability of error outside a given confidence interval in Quantum Phase Estimation (QPE).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation.kaiser_window_state import KaiserWindowState\n```\n\n----------------------------------------\n\nTITLE: PermutationCycle Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph for the `permutation_cycle_symb_N` instance. The call graph visualizes the internal structure and dependencies of the `PermutationCycle` bloq, using `ignore_split_join` to simplify the visualization.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\npermutation_cycle_symb_N_g, permutation_cycle_symb_N_sigma = permutation_cycle_symb_N.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(permutation_cycle_symb_N_g)\nshow_counts_sigma(permutation_cycle_symb_N_sigma)\n```\n\n----------------------------------------\n\nTITLE: Number of bloq examples successfully flattened\nDESCRIPTION: Prints the number of bloq examples that were successfully flattened.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/tensor-report-card.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(len(df[df['flat_dur'] > 0]))\n```\n\n----------------------------------------\n\nTITLE: Call Graph of KaiserWindowState\nDESCRIPTION: This snippet generates and displays the call graph of the `kaiser_window_state_small` bloq using `kaiser_window_state_small.call_graph` and `show_call_graph`.  The `ignore_split_join` generalizer helps simplify the call graph. It also calculates and displays sigma counts, which are resource estimates associated with the bloq's operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/kaiser_window_state.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nkaiser_window_state_small_g, kaiser_window_state_small_sigma = kaiser_window_state_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(kaiser_window_state_small_g)\nshow_counts_sigma(kaiser_window_state_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: DoubleFactorizationOneBody Example Instance\nDESCRIPTION: This snippet demonstrates how to instantiate the `DoubleFactorizationOneBody` bloq with specific parameters. It defines the number of bits for state preparation and rotations, the number of spin orbitals, the dimension of the auxiliary index, and the total number of eigenvalues. It then creates an instance of the `DoubleFactorizationOneBody` class with these parameters.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/df/double_factorization.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnum_bits_state_prep = 12\nnum_bits_rot = 7\nnum_spin_orb = 10\nnum_aux = 50\nnum_eig = num_aux * (num_spin_orb // 2)\ndf_one_body = DoubleFactorizationOneBody(\n    num_aux=num_aux,\n    num_spin_orb=num_spin_orb,\n    num_eig=num_eig,\n    num_bits_state_prep=num_bits_state_prep,\n    num_bits_rot=num_bits_rot,\n)\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation and Display\nDESCRIPTION: Generates and displays the call graph for `apply_z_to_odd` using `apply_z_to_odd.call_graph`. The `ignore_split_join` generalizer simplifies the graph. The call graph visually represents the dependencies between different bloqs within the `apply_z_to_odd` implementation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_gate_to_lth_target.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\napply_z_to_odd_g, apply_z_to_odd_sigma = apply_z_to_odd.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(apply_z_to_odd_g)\nshow_counts_sigma(apply_z_to_odd_sigma)\n```\n\n----------------------------------------\n\nTITLE: Visualize RectangularWindowState instances\nDESCRIPTION: Visualizes the previously created `RectangularWindowState` instances (`rectangular_window_state_small` and `rectangular_window_state_symbolic`) using `qualtran.drawing.show_bloqs`. This allows for a graphical representation of the bloqs, which is useful for understanding their structure and behavior.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([rectangular_window_state_small, rectangular_window_state_symbolic],\n           ['`rectangular_window_state_small`', '`rectangular_window_state_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of Hamiltonian Simulations\nDESCRIPTION: Uses `show_bloqs` to display the graphical signatures of the `hubbard_time_evolution_by_gqsp` and `symbolic_hamsim_by_gqsp` instances.  This visualizes the quantum circuits that implement the respective simulations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/hamiltonian_simulation/hamiltonian_simulation_by_gqsp.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([hubbard_time_evolution_by_gqsp, symbolic_hamsim_by_gqsp],\n           ['`hubbard_time_evolution_by_gqsp`', '`symbolic_hamsim_by_gqsp`'])\n```\n\n----------------------------------------\n\nTITLE: UniformSuperpositionTHC Class Import\nDESCRIPTION: Imports the `UniformSuperpositionTHC` class from the `qualtran.bloqs.chemistry.thc` module. This class prepares a uniform superposition state for THC.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.thc import UniformSuperpositionTHC\n```\n\n----------------------------------------\n\nTITLE: IsingXUnitary Example Instance\nDESCRIPTION: Creates an instance of the `IsingXUnitary` bloq with specified parameters such as the number of sites (`nsites`), coupling constant (`j_zz`), and time step (`dt`). This example demonstrates how to instantiate the IsingXUnitary class and set its attributes.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/ising/ising.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnsites = 3\nj_zz = 2\ndt = 0.01\nising_x = IsingXUnitary(nsites=nsites, angle=2 * dt * j_zz)\n```\n\n----------------------------------------\n\nTITLE: Drawing Equals bloq\nDESCRIPTION: This code visualizes the `Equals` bloq using `show_bloqs` from `qualtran.drawing`. It helps in understanding the structure and connections within the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([equals],\n           ['`equals`'])\n```\n\n----------------------------------------\n\nTITLE: Import PrepareOracle base class\nDESCRIPTION: This snippet imports the `PrepareOracle` base class from the `qualtran.bloqs.state_preparation.prepare_base` module. `PrepareOracle` is an abstract base class that defines the API for a PREPARE Oracle.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qubitization/qubitization_walk_operator.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.state_preparation.prepare_base import PrepareOracle\n```\n\n----------------------------------------\n\nTITLE: GuidingState Definition\nDESCRIPTION: This snippet imports the `GuidingState` class from the `qualtran.bloqs.optimization.k_xor_sat` module.  The `GuidingState` bloq prepares a guiding state for a kXOR instance with a Kikuchi parameter \\( \\ell \\) which is a multiple of \\( k \\).\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/optimization/k_xor_sat/kikuchi_guiding_state.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.optimization.k_xor_sat import GuidingState\n```\n\n----------------------------------------\n\nTITLE: ControlledViaAnd with QBits\nDESCRIPTION: Creates an instance of `ControlledViaAnd` with Hadamard as the subbloq and a `CtrlSpec` specifying control qubits with control values as a numpy array of [0, 1, 1, 0].\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Hadamard\n\ncontrolled_via_and_qbits = ControlledViaAnd(Hadamard(), CtrlSpec(cvs=(np.array([0, 1, 1, 0]),)))\n```\n\n----------------------------------------\n\nTITLE: Import CModAddK from qualtran.bloqs.mod_arithmetic\nDESCRIPTION: Imports the `CModAddK` class from the `qualtran.bloqs.mod_arithmetic` module.  This class represents a controlled modular addition of a constant k.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import CModAddK\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of `FindECCPrivateKey`\nDESCRIPTION: Generates and displays the graphical signature of the `FindECCPrivateKey` bloq using `show_bloqs` function. This is a visual representation of the bloq, displaying its inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ecc],\n           ['`ecc`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate RectangularWindowState with fixed size\nDESCRIPTION: Creates an instance of `RectangularWindowState` with a fixed size of 5. This allows for the creation of a concrete instance that can be used directly in simulations or other computations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nrectangular_window_state_small = RectangularWindowState(5)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of QROMs - Python\nDESCRIPTION: This snippet uses the `show_bloqs` function to display the graphical signatures of the previously created QROM instances (`qrom_small`, `qrom_multi_data`, `qrom_multi_dim`, and `qrom_symb`). This allows for a visual representation of the QROM objects and their registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([qrom_small, qrom_multi_data, qrom_multi_dim, qrom_symb],\n           ['`qrom_small`', '`qrom_multi_data`', '`qrom_multi_dim`', '`qrom_symb`'])\n```\n\n----------------------------------------\n\nTITLE: Rz Graphical Signature\nDESCRIPTION: Generates and displays a graphical representation of the `Rz` bloq. This visualization helps understand the gate's structure and input/output registers.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([rz],\n           ['`rz`'])\n```\n\n----------------------------------------\n\nTITLE: Plotting Toffoli Count Distribution\nDESCRIPTION: This snippet generates a pie chart visualizing the distribution of Toffoli counts among SELECT, PREPARE, and PREPARE$^{\\dagger}$ operations. It uses `matplotlib` to create the pie chart with labels and percentages.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nplt.pie(toffoli_counts, labels=['SELECT', 'PREPARE', r'PREPARE^{\\dagger}$'], autopct='%1.1f%%')\n```\n\n----------------------------------------\n\nTITLE: Analyze Call Graph\nDESCRIPTION: Generates and displays the call graph for the `gf2_poly_4_8_add` bloq, which helps to visualize the composition of the quantum circuit and understand the resource requirements of the operation. The `ignore_split_join` generalizer simplifies the graph.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf2_poly_4_8_add_g, gf2_poly_4_8_add_sigma = gf2_poly_4_8_add.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf2_poly_4_8_add_g)\nshow_counts_sigma(gf2_poly_4_8_add_sigma)\n```\n\n----------------------------------------\n\nTITLE: Instantiate TextbookQPE with symbolic m_bits\nDESCRIPTION: Illustrates the instantiation of TextbookQPE using a symbolic variable for the number of qubits (m_bits) and ZPowGate for the unitary operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/text_book_qpe.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport sympy\n\nfrom qualtran.bloqs.basic_gates import ZPowGate\nfrom qualtran.bloqs.phase_estimation import RectangularWindowState, TextbookQPE\n\ntheta = sympy.Symbol('theta')\nm_bits = sympy.Symbol('m')\ntextbook_qpe_using_m_bits = TextbookQPE(\n    ZPowGate(exponent=2 * theta), RectangularWindowState(m_bits)\n)\n```\n\n----------------------------------------\n\nTITLE: Import YGate from Qualtran (Python)\nDESCRIPTION: This snippet imports the `YGate` class from the `qualtran.bloqs.basic_gates` module. This class represents the Pauli Y gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import YGate\n```\n\n----------------------------------------\n\nTITLE: QROM Call Graph and Resource Counting - Python\nDESCRIPTION: This snippet generates and displays the call graph and resource counts sigma for the `qrom_small` instance. It uses the `call_graph` method with `max_depth=1` and `generalizer=ignore_split_join`. The resulting graph and sigma are displayed using `show_call_graph` and `show_counts_sigma` respectively, providing insights into the resource requirements of the QROM.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/data_loading/qrom.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nqrom_small_g, qrom_small_sigma = qrom_small.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(qrom_small_g)\nshow_counts_sigma(qrom_small_sigma)\n```\n\n----------------------------------------\n\nTITLE: Hamming Weight Phasing Imports\nDESCRIPTION: Imports necessary modules from qualtran, typing, numpy, sympy and cirq. These modules are used for defining bloqs, building composite bloqs, creating signatures and registers, type hinting, numerical computation, symbolic computation and quantum circuit manipulation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Printing Toffoli Count Comparison\nDESCRIPTION: This snippet prints a comparison of the Toffoli counts between the Qualtran implementation and a reference value. It calculates the difference between the two counts and displays the results using an f-string.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/resource_estimation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(f'qualtran = {num_toff} vs. ref = 10880, delta = {num_toff - 10880}')\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph for KineticEnergy\nDESCRIPTION: This snippet generates and displays the call graph for the `KineticEnergy` bloq, up to a depth of 1. It uses `ignore_split_join` as a generalizer and visualizes the call graph and sigma counts using `show_call_graph` and `show_counts_sigma` from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nkinetic_energy_g, kinetic_energy_sigma = kinetic_energy.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(kinetic_energy_g)\nshow_counts_sigma(kinetic_energy_sigma)\n```\n\n----------------------------------------\n\nTITLE: Showing a BiQubitsMixer Bloq\nDESCRIPTION: This snippet displays a graphical representation of the `bi_qubits_mixer` bloq, providing a visual representation of the quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([bi_qubits_mixer],\n           ['`bi_qubits_mixer`'])\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Representation of CYGate (Python)\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display a graphical representation of the `cy_gate`. This helps visualize the controlled Y gate in a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([cy_gate],\n           ['`cy_gate`'])\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of PrepareUVFirstQuantization in Python\nDESCRIPTION: This code snippet uses `show_bloqs` from `qualtran.drawing` to display the graphical representation of the `prepare_uv` bloq. This visualization provides a schematic overview of the quantum circuit represented by the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prepare_uv],\n           ['`prepare_uv`'])\n```\n\n----------------------------------------\n\nTITLE: Display SignExtend Call Graph\nDESCRIPTION: Generates and displays the call graph of the `sign_extend` Bloq using the `call_graph` method and the `show_call_graph` function. It also computes and displays the resource counts sigma using `show_counts_sigma`. The call graph is generalized using `ignore_split_join`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/conversions/conversions.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsign_extend_g, sign_extend_sigma = sign_extend.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sign_extend_g)\nshow_counts_sigma(sign_extend_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran and other dependencies\nDESCRIPTION: Imports necessary modules from Qualtran for defining and manipulating quantum bloqs, as well as standard Python libraries like typing, numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/negate.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: GQSP with negative power\nDESCRIPTION: Creates an instance of `GeneralizedQSP` with `negative_power` set to 1. The QSP polynomial coefficients are (0.5, 0, 0.5), and the unitary is `XPowGate`. This demonstrates the usage of Laurent polynomials.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/qsp/generalized_qsp.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import XPowGate\n\ngqsp_with_negative_power = GeneralizedQSP.from_qsp_polynomial(\n    XPowGate(), (0.5, 0, 0.5), negative_power=1\n)\n```\n\n----------------------------------------\n\nTITLE: SumOfSquares Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `SumOfSquares` instance, using the `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nsum_of_squares_g, sum_of_squares_sigma = sum_of_squares.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(sum_of_squares_g)\nshow_counts_sigma(sum_of_squares_sigma)\n```\n\n----------------------------------------\n\nTITLE: Create RealGivensRotationByPhaseGradient Instance\nDESCRIPTION: Creates an instance of the `RealGivensRotationByPhaseGradient` class with a `phasegrad_bitsize` of 4. This determines the precision of the phase gradient register used in the rotation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreal_givens = RealGivensRotationByPhaseGradient(phasegrad_bitsize=4)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signatures of LPResourceState instances\nDESCRIPTION: This snippet uses `show_bloqs` from `qualtran.drawing` to display the graphical signatures of both the `lp_resource_state_small` and `lp_resource_state_symbolic` Bloq instances. This provides a visual representation of their inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/phase_estimation/lp_resource_state.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([lp_resource_state_small, lp_resource_state_symbolic],\n           ['`lp_resource_state_small`', '`lp_resource_state_symbolic`'])\n```\n\n----------------------------------------\n\nTITLE: Estimate qubit count of a decomposed bloq\nDESCRIPTION: Decomposes the original `bloq` and then estimates the qubit count of the composite bloq (`cbloq`) using `get_cost_value` and the `QubitCount` cost key. This allows for estimating resource usage after decomposition.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/resource_counting/qubit_counts.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncbloq = bloq.decompose_bloq()\nget_cost_value(cbloq, QubitCount())\n```\n\n----------------------------------------\n\nTITLE: Rz Import\nDESCRIPTION: Imports the `Rz` class from the `qualtran.bloqs.basic_gates` module. This gate represents a rotation around the Z axis of the Bloch sphere.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/rotation.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Rz\n```\n\n----------------------------------------\n\nTITLE: HammingWeightPhasingViaPhaseGradient Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `HammingWeightPhasingViaPhaseGradient` bloq using `show_bloqs`. This provides a visual representation of the bloq and its internal structure.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/hamming_weight_phasing.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([hamming_weight_phasing_via_phase_gradient],\n           ['`hamming_weight_phasing_via_phase_gradient`'])\n```\n\n----------------------------------------\n\nTITLE: AddScaledValIntoPhaseReg Call Graph\nDESCRIPTION: Generates and displays the call graph for `add_scaled_val_into_phase_reg`. It uses `ignore_split_join` from `qualtran.resource_counting.generalizers` to simplify the graph by ignoring split and join operations. Also displays the counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nadd_scaled_val_into_phase_reg_g, add_scaled_val_into_phase_reg_sigma = add_scaled_val_into_phase_reg.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(add_scaled_val_into_phase_reg_g)\nshow_counts_sigma(add_scaled_val_into_phase_reg_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of MultiplyPolyByOnePlusXk\nDESCRIPTION: Displays the graphical signature of the `multiplypolybyoneplusxk` bloq, visualizing the input and output registers for polynomial multiplication by $(1 + x^k)$.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([multiplypolybyoneplusxk],\n           ['`multiplypolybyoneplusxk`'])\n```\n\n----------------------------------------\n\nTITLE: ScaleIntByReal Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `ScaleIntByReal` instance, using the `ignore_split_join` generalizer.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nscale_int_by_real_g, scale_int_by_real_sigma = scale_int_by_real.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(scale_int_by_real_g)\nshow_counts_sigma(scale_int_by_real_sigma)\n```\n\n----------------------------------------\n\nTITLE: Controlled Hadamard Gate Musical Score (Python)\nDESCRIPTION: Displays the `CHadamard` bloq as a musical score diagram. This provides an alternative visual representation of the gate.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/hadamard.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(chadamard, 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: Register and Signature Creation\nDESCRIPTION: This snippet creates two registers, `control_reg` and `target_reg`, using the `Register` class from the `qualtran` library. `control_reg` is a 2-bit register named 'control', and `target_reg` is a 3-bit register named 'target'.  The `QAny` type indicates that the register can hold any kind of quantum data. The registers are then printed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/_infra/gate_with_registers.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Register, Signature, QAny\n\ncontrol_reg = Register('control', QAny(bitsize=2))\ntarget_reg = Register('target', QAny(bitsize=3))\ncontrol_reg, target_reg\n```\n\n----------------------------------------\n\nTITLE: Import ECPoint data structure\nDESCRIPTION: Imports the `ECPoint` data structure from `qualtran.bloqs.cryptography.ecc`.  This is needed to represent points on the elliptic curve in other bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.cryptography.ecc import ECPoint\n```\n\n----------------------------------------\n\nTITLE: Draw Musical Score Diagram using Matplotlib in Python\nDESCRIPTION: This snippet generates a musical score diagram of a composite bloq using matplotlib.  It calls `get_musical_score_data` to lay out the symbols on the score, then uses `draw_musical_score` to render the diagram. The diagram is then displayed. This requires the `matplotlib` library to be installed.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/drawing/musical_score.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import get_musical_score_data, draw_musical_score\nmsd = get_musical_score_data(cbloq)\nfig, ax = draw_musical_score(msd)\nfig.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: PlusEqualProduct Call Graph Visualization\nDESCRIPTION: Generates and displays the call graph and sigma counts for the `PlusEqualProduct` instance, using the `ignore_split_join` generalizer to simplify the graph by ignoring split and join operations for resource estimation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nplus_equal_product_g, plus_equal_product_sigma = plus_equal_product.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(plus_equal_product_g)\nshow_counts_sigma(plus_equal_product_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import Statements and Type Hints\nDESCRIPTION: This snippet imports necessary modules from `qualtran`, including `Bloq`, `CompositeBloq`, `BloqBuilder`, `Signature`, `Register`, `QBit`, `QInt`, `QUInt`, `QAny` for defining quantum circuits and data structures. It also imports `show_bloq`, `show_call_graph`, `show_counts_sigma` for visualization purposes. Finally, it imports standard Python libraries such as `typing`, `numpy`, `sympy`, and `cirq` for type hinting, numerical operations, symbolic calculations, and quantum gate definitions.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/select_pauli_lcu.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation for BitwiseNot\nDESCRIPTION: Generates and displays the call graph for the `bitwise_not` bloq using `bitwise_not.call_graph` and `show_call_graph`. The `ignore_split_join` generalizer is used to simplify the graph and also displays `counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/bitwise.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nbitwise_not_g, bitwise_not_sigma = bitwise_not.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(bitwise_not_g)\nshow_counts_sigma(bitwise_not_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate call graph and visualize costs\nDESCRIPTION: Generates a call graph for the bloq and visualizes the costs associated with each sub-bloq. The `query_costs` function retrieves cost information, and `GraphvizCallGraph` creates a graphical representation of the call structure with cost annotations, which is then rendered as an SVG.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/resource_counting/qubit_counts.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import GraphvizCallGraph\n\ng, _ = bloq.call_graph()\ncosts = query_costs(bloq, [QubitCount()])\nGraphvizCallGraph(g, costs).get_svg()\n```\n\n----------------------------------------\n\nTITLE: Split Graphical Signature\nDESCRIPTION: Displays the graphical signature of the `Split` bloq, showing the transformation from a `QUInt(4)` register to an array of `QBit`s.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([split],\n           ['`split`'])\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of SelectUVFirstQuantization in Python\nDESCRIPTION: This snippet visualizes the `select_uv` bloq using `show_bloqs` from `qualtran.drawing`, providing a graphical representation of the quantum circuit for selecting U and V operators.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([select_uv],\n           ['`select_uv`'])\n```\n\n----------------------------------------\n\nTITLE: Bloq with add_and_partition\nDESCRIPTION: Demonstrates the use of `BloqBuilder.add_and_partition` as a shorthand for creating and adding an `AutoPartition` instance. This further simplifies the code required to wrap bloqs and hide partition/unpartition operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n@attrs.frozen\nclass Wrapped(Bloq):\n    bitsize: int = 10\n\n    @cached_property\n    def signature(self) -> Signature:\n        return Signature((Register('x', QBit(), shape=(self.bitsize,)), Register('y', QAny(20))))\n\n    def build_composite_bloq(\n        self, bb: BloqBuilder, x: 'SoquetT', y: 'SoquetT'\n    ) -> Dict[str, 'SoquetT']:\n        for i in range(5):\n            hwp = HammingWeightPhasing(2, i * 0.11)\n            x[i * 2 : i * 2 + 2] = bb.add_and_partition(\n                hwp, [(Register('reg_1', QBit(), shape=(2,)), ('x',))], reg_1=x[i * 2 : i * 2 + 2]\n            )\n        many = ManyBit()\n        y = bb.add_and_partition(many, [(Register('y', QAny(20)), ('xs',))], y=y)\n        return {'x': x, 'y': y}\n\n\nbloq = Wrapped()\ndraw_musical_score(get_musical_score_data(bloq.decompose_bloq()))\n```\n\n----------------------------------------\n\nTITLE: Generating UI Export with Call Graph and Musical Scores\nDESCRIPTION: This code generates JSON files for each bloq with information about its attributes, musical score data, and callees (dependencies) based on a call graph. It iterates through examples, builds a call graph, and then generates a JSON file for each bloq, including its attributes, a musical score representation (if possible), and a list of callees with their filenames.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/ui-export.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport json\nimport os\nfrom pathlib import Path\n\nfrom qualtran_dev_tools.all_call_graph import get_all_call_graph\nfrom qualtran_dev_tools.notebook_specs import NB_BY_SECTION\nfrom qualtran import Adjoint, Controlled\nfrom qualtran.drawing.musical_score import get_musical_score_data\n\nexamples = [\n  example\n  for section in NB_BY_SECTION\n  for notebook_spec in section[1]\n  for bloq_spec in notebook_spec.bloq_specs\n  for example in bloq_spec.examples\n]\n\ncall_graph = get_all_call_graph(examples)\n\ndef bloq_score(bloq):\n  try:\n    return get_musical_score_data(bloq.decompose_bloq())\n  except:\n    return None\n\ndef bloq_name(bloq):\n  if (isinstance(bloq, (Adjoint, Controlled))):\n    return bloq_name(bloq.subbloq)\n\n  return bloq.__class__.__name__\n\ndef write_example(bloq):\n  file_name = f'ui_export/{bloq_name(bloq)}/{bloq_filename(bloq)}'\n  if not os.path.isfile(file_name):\n    bloq_dict = {\n      'name': str(bloq),\n      'attrs': bloq_attrs(bloq),\n      'msd': bloq_score(bloq),\n      'callees': list(\n        {\n          'name': bloq_name(child_bloq),\n          'filename': bloq_filename(child_bloq)\n        }\n        for child_bloq in call_graph.neighbors(bloq)\n      )\n    }\n\n    Path(f'ui_export/{bloq_name(bloq)}').mkdir(parents=True, exist_ok=True)\n\n    with open(file_name, 'w') as f:\n      json.dump(bloq_dict, f, indent=2, cls=BloqEncoder)\n\nfor bloq, _ in call_graph.nodes.items():\n  write_example(bloq)\n```\n\n----------------------------------------\n\nTITLE: T-Count Analysis for UniformSuperpositionTHC\nDESCRIPTION: Analyzes the T-count of the `UniformSuperpositionTHC` bloq and compares it with theoretical costs from a reference paper. This includes categorizing T-counts by bloq type and identifying discrepancies between the implementation and the theoretical analysis.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/thc/thc.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.classify_bloqs import classify_t_count_by_bloq_type\n\nbinned_counts = classify_t_count_by_bloq_type(thc_uni)\n\n# number of bits for mu register (nm in THC paper)\n# note this register should range up to num_mu + 1, not num_mu, hence it's just bit_length not (num_mu - 1).bit_length()\nnm = thc_uni.num_mu.bit_length()\n# Costs for THC paper\n# The factor of 4 is for Toffoli -> T conversion\npaper_costs = {\n    'arithmetic': 4*(4*(nm - 1) + (4*nm - 3)), # 4 comparitors of cost nm - 1 Toffolis\n    'rotations': 4*(4 + 4), # Given as br - 3, br = 7 is the number of bits of precision for rotations.\n    'reflection': 4*(3 + 2*nm-1), # 5 qubit reflection for comparitors and 2*nm + 1 qubits reflect after hadamards\n    'other': 4*3, # \"Checking the inequality test\" unclear if this is the multi-control not gate.\n}\nfor k in (paper_costs.keys() | binned_counts.keys()):\n    print(f\"{k+':':15s} qualtran = {binned_counts.get(k,0):5d} vs paper cost = {paper_costs.get(k,0):5d}.\")\n\nassert binned_counts['arithmetic'] == 276\n```\n\n----------------------------------------\n\nTITLE: Show Musical Score of YGate (Python)\nDESCRIPTION: This snippet utilizes `show_bloq` to create and display a 'musical score' representation of the Y gate, offering an alternative visualization of its quantum operation.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/y_gate.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nshow_bloq(y_gate, 'musical_score')\n```\n\n----------------------------------------\n\nTITLE: AddIntoPhaseGrad Call Graph\nDESCRIPTION: Generates and displays the call graph for `add_into_phase_grad`. It uses `ignore_split_join` from `qualtran.resource_counting.generalizers` to simplify the graph by ignoring split and join operations. Also displays the counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nadd_into_phase_grad_g, add_into_phase_grad_sigma = add_into_phase_grad.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(add_into_phase_grad_g)\nshow_counts_sigma(add_into_phase_grad_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import CModAdd from qualtran.bloqs.mod_arithmetic\nDESCRIPTION: Imports the `CModAdd` class, representing controlled modular addition, from the `qualtran.bloqs.mod_arithmetic` module.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_addition.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import CModAdd\n```\n\n----------------------------------------\n\nTITLE: Call Graph Generation and Visualization\nDESCRIPTION: This snippet generates and visualizes the call graph of the `gf2_poly_4_8_add_k` instance.  It uses `ignore_split_join` as a generalizer to simplify the call graph. `show_call_graph` displays the call graph and `show_counts_sigma` displays the counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_poly_arithmetic/gf2_poly_add_k.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf2_poly_4_8_add_k_g, gf2_poly_4_8_add_k_sigma = gf2_poly_4_8_add_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf2_poly_4_8_add_k_g)\nshow_counts_sigma(gf2_poly_4_8_add_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: Import SingleFactorizationBlockEncoding Bloq\nDESCRIPTION: This line imports the `SingleFactorizationBlockEncoding` class from the `qualtran.bloqs.chemistry.sf.single_factorization` module. This bloq represents the block encoding of the full single factorization Hamiltonian.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/sf/single_factorization.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.chemistry.sf.single_factorization import SingleFactorizationBlockEncoding\n```\n\n----------------------------------------\n\nTITLE: Call Graph of MultiplyPolyByOnePlusXk\nDESCRIPTION: Generates and displays the call graph for `multiplypolybyoneplusxk`, ignoring split-join operations. This call graph shows the decomposition of the bloq into its underlying quantum gates, with a maximum depth of 1. Also displays the associated resource counts.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_multiplication.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmultiplypolybyoneplusxk_g, multiplypolybyoneplusxk_sigma = multiplypolybyoneplusxk.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(multiplypolybyoneplusxk_g)\nshow_counts_sigma(multiplypolybyoneplusxk_sigma)\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Representation of SGate\nDESCRIPTION: This snippet uses the `show_bloqs` function from `qualtran.drawing` to display the graphical representation of the instantiated `s_gate` object. This visualization helps in understanding the gate's action within a quantum circuit.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/diag_gates.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([s_gate],\n           ['`s_gate`'])\n```\n\n----------------------------------------\n\nTITLE: Generate Call Graph of SelectTFirstQuantization in Python\nDESCRIPTION: Generates and displays the call graph and resource counts for the `select_t` bloq. It uses `ignore_split_join` as the generalizer to simplify the call graph, and the depth is limited to 1.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nselect_t_g, select_t_sigma = select_t.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(select_t_g)\nshow_counts_sigma(select_t_sigma)\n```\n\n----------------------------------------\n\nTITLE: SymmetricDifference Graphical Signature\nDESCRIPTION: Generates and displays a graphical signature of the `symm_diff` instance using `show_bloqs` from `qualtran.drawing`. This provides a visual representation of the quantum circuit implemented by the SymmetricDifference bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([symm_diff],\n           ['`symm_diff`'])\n```\n\n----------------------------------------\n\nTITLE: pip-compile Command\nDESCRIPTION: This snippet shows the command used to generate the `docs.env.txt` file. It uses `pip-compile` with constraints from `envs/dev.env.txt` and inputs from `deps/docs.txt` and `deps/runtime.txt`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/requirements/envs/docs.env.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npip-compile --constraint=envs/dev.env.txt --output-file=envs/docs.env.txt deps/docs.txt deps/runtime.txt\n```\n\n----------------------------------------\n\nTITLE: Visualizing SparseMatrix Bloqs\nDESCRIPTION: Visualizes the created `SparseMatrix` instances, including the standard, symbolic, explicit entry, and symmetric banded matrix encodings. It uses `show_bloqs` to display the circuit diagrams of these instances for inspection.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sparse_matrix_block_encoding, sparse_matrix_symb_block_encoding, explicit_matrix_block_encoding, symmetric_banded_matrix_block_encoding],\n           ['`sparse_matrix_block_encoding`', '`sparse_matrix_symb_block_encoding`', '`explicit_matrix_block_encoding`', '`symmetric_banded_matrix_block_encoding`'])\n```\n\n----------------------------------------\n\nTITLE: HasDuplicates Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts sigma of the symbolic `has_duplicates_symb` instance. `ignore_split_join` is used as a generalizer to simplify the call graph. `show_call_graph` and `show_counts_sigma` are used to visualize the call graph and resource counts, respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/lists/lists.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nhas_duplicates_symb_g, has_duplicates_symb_sigma = has_duplicates_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(has_duplicates_symb_g)\nshow_counts_sigma(has_duplicates_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Graphical Signature of `ECAddR`\nDESCRIPTION: Generates and displays the graphical signature of the `ECAddR` bloq, including both the symbolic instance `ec_add_r` and the smaller instance `ec_add_r_small`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([ec_add_r, ec_add_r_small],\n           ['`ec_add_r`', '`ec_add_r_small`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph of PrepareFirstQuantizationWithProj\nDESCRIPTION: This code snippet generates and displays the call graph of the `prep_first_quant` bloq, visualizing the dependencies and structure of the quantum circuit. It uses `ignore_split_join` to simplify the graph and then displays it using `show_call_graph` and `show_counts_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/projectile/projectile.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nprep_first_quant_g, prep_first_quant_sigma = prep_first_quant.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(prep_first_quant_g)\nshow_counts_sigma(prep_first_quant_sigma)\n```\n\n----------------------------------------\n\nTITLE: Dump Musical Score Data to JSON in Python\nDESCRIPTION: This snippet exports the musical score data to a JSON file for use with JavaScript-based rendering. It calls `dump_musical_score` to serialize the data structure, enabling visualization using tools like D3.js. The JSON file can then be loaded and rendered by external JavaScript applications.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/drawing/musical_score.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import dump_musical_score\n\ndump_musical_score(msd, name='musical_score_example')\n```\n\n----------------------------------------\n\nTITLE: Show Bloqs\nDESCRIPTION: Visualizes the created `controlled_via_and_ints` and `controlled_via_and_qbits` bloqs using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mcmt/controlled_via_and.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([controlled_via_and_ints, controlled_via_and_qbits],\n           ['`controlled_via_and_ints`', '`controlled_via_and_qbits`'])\n```\n\n----------------------------------------\n\nTITLE: Show Graphical Signature of SelectTFirstQuantization in Python\nDESCRIPTION: This snippet displays the graphical representation of the `select_t` bloq, illustrating the quantum circuit implementing the kinetic energy selection.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([select_t],\n           ['`select_t`'])\n```\n\n----------------------------------------\n\nTITLE: Instantiate StatePreparationViaRotations with Mixed Values\nDESCRIPTION: Creates another instance of `StatePreparationViaRotations` with a combination of numerical state coefficients and a symbolic phase bitsize. This showcases the flexibility of the class in handling different types of inputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/state_preparation/state_preparation_via_rotation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nstate_coefs = (\n    (-0.42677669529663675 - 0.1767766952966366j),\n    (0.17677669529663664 - 0.4267766952966367j),\n    (0.17677669529663675 - 0.1767766952966368j),\n    (0.07322330470336305 - 0.07322330470336309j),\n    (0.4267766952966366 - 0.17677669529663692j),\n    (0.42677669529663664 + 0.17677669529663675j),\n    (0.0732233047033631 + 0.17677669529663678j),\n    (-0.07322330470336308 - 0.17677669529663678j),\n)\n\nphase_bitsize = sympy.Symbol(r\"b_\\text{grad}\")\nstate_prep_via_rotation_symb_phasegrad = StatePreparationViaRotations(\n    state_coefficients=state_coefs, phase_bitsize=phase_bitsize\n)\n```\n\n----------------------------------------\n\nTITLE: Defining NotebookSpecV2 for Modular Exponentiation (Python)\nDESCRIPTION: This code snippet demonstrates how to define a `NotebookSpecV2` to specify the module, title, and `BloqDocSpec` for automatically generating a Jupyter notebook for modular exponentiation. The notebook will contain documentation and examples for the `ModExp` Bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Autodoc.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n    NotebookSpecV2(\n        title='Modular Exponentiation',\n        module=qualtran.bloqs.cryptography.mod_exp,\n        bloq_specs=[qualtran.bloqs.cryptography.mod_exp._MODEXP_DOC],\n    ),\n```\n\n----------------------------------------\n\nTITLE: Import PlusEffect Bloq\nDESCRIPTION: Imports the `PlusEffect` class from the `qualtran.bloqs.basic_gates` module. `PlusEffect` represents the <+| quantum effect.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import PlusEffect\n```\n\n----------------------------------------\n\nTITLE: Import Qualtran Modules\nDESCRIPTION: Imports necessary modules from the Qualtran library for defining and manipulating quantum bloqs, including data structures for registers, signatures, and drawing utilities for visualizing bloqs and call graphs. Also imports standard Python libraries such as typing, numpy, sympy, and cirq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Import ApplyLthBloq from Qualtran\nDESCRIPTION: This code snippet imports the `ApplyLthBloq` class from the `qualtran.bloqs.multiplexers` module. This class is used to implement a SELECT operation for conditionally applying a bloq based on a quantum index.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/multiplexers/apply_lth_bloq.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.multiplexers.apply_lth_bloq import ApplyLthBloq\n```\n\n----------------------------------------\n\nTITLE: Git Add, Commit and Push Documentation Changes\nDESCRIPTION: This snippet adds all the changed documentation files, commits them with a message and pushes the changes to the remote repository. It is part of the process of pushing the generated documentation for the 'docs' branch.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/dev_tools/how-to-build-the-docs.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit add .\n# .. verify the staged diff looks good ..\ngit commit -m 'Generate docs'\ngit push\n```\n\n----------------------------------------\n\nTITLE: Import necessary modules\nDESCRIPTION: This snippet imports necessary modules from the `qualtran` library and standard Python libraries for defining and manipulating quantum circuits and data structures.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/trotter/grid_ham/trotter.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Show SumOfSquares Bloq\nDESCRIPTION: Displays the `SumOfSquares` bloq diagram using the `show_bloqs` function from `qualtran.drawing`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/multiplication.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([sum_of_squares],\n           ['`sum_of_squares`'])\n```\n\n----------------------------------------\n\nTITLE: Example `ECPhaseEstimateR` instantiation\nDESCRIPTION: Demonstrates how to instantiate the `ECPhaseEstimateR` bloq with symbolic parameters using `sympy` for the curve order ($p$) and the point coordinates ($R_x, R_y$). It defines a symbolic elliptic curve point $R$ and instantiates `ECPhaseEstimateR` with it. A second instance `ec_pe_small` is also created using `n=3`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nn, p = sympy.symbols('n p')\nRx, Ry = sympy.symbols('R_x R_y')\nec_pe = ECPhaseEstimateR(n=n, point=ECPoint(Rx, Ry, mod=p))\n```\n\nLANGUAGE: python\nCODE:\n```\nn = 3\nRx, Ry, p = sympy.symbols('R_x R_y p')\nec_pe_small = ECPhaseEstimateR(n=n, point=ECPoint(Rx, Ry, mod=p))\n```\n\n----------------------------------------\n\nTITLE: Partition Example Instance\nDESCRIPTION: Creates an instance of the `Partition` bloq, configured to partition a register into two sub-registers: `xx` (shape=(2, 3)) and `yy`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nregs = (Register('xx', QAny(2), shape=(2, 3)), Register('yy', QAny(37)))\nbitsize = sum(reg.total_bits() for reg in regs)\npartition = Partition(n=bitsize, regs=regs)\n```\n\n----------------------------------------\n\nTITLE: Show ZeroState Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `ZeroState` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nzero_state_g, zero_state_sigma = zero_state.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(zero_state_g)\nshow_counts_sigma(zero_state_sigma)\n```\n\n----------------------------------------\n\nTITLE: Importing CLinearDepthGreaterThan Bloq\nDESCRIPTION: This line imports the `CLinearDepthGreaterThan` class from the `qualtran.bloqs.arithmetic` module.  `CLinearDepthGreaterThan` implements a controlled greater-than comparison between two integers with linear depth.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/comparison.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.arithmetic import CLinearDepthGreaterThan\n```\n\n----------------------------------------\n\nTITLE: SparseMatrix Example Instance\nDESCRIPTION: Creates a `SparseMatrix` instance using `TopLeftRowColumnOracle` for row and column oracles and `UniformEntryOracle` for the entry oracle. This example uses system bit size of 2 and an entry value of 0.3, with an encoding precision of 0.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/sparse_matrix.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.block_encoding.sparse_matrix import (\n    TopLeftRowColumnOracle,\n    UniformEntryOracle,\n)\n\nrow_oracle = TopLeftRowColumnOracle(system_bitsize=2)\ncol_oracle = TopLeftRowColumnOracle(system_bitsize=2)\nentry_oracle = UniformEntryOracle(system_bitsize=2, entry=0.3)\nsparse_matrix_block_encoding = SparseMatrix(row_oracle, col_oracle, entry_oracle, eps=0)\n```\n\n----------------------------------------\n\nTITLE: Show IntState Call Graph\nDESCRIPTION: Generates and displays the call graph and resource counts for the `IntState` bloq using methods from `qualtran.resource_counting`. The call graph shows the dependencies and sub-components of the bloq, while resource counts provide an estimate of the resources required to implement it.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/states_and_effects.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nint_state_g, int_state_sigma = int_state.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(int_state_g)\nshow_counts_sigma(int_state_sigma)\n```\n\n----------------------------------------\n\nTITLE: Documenting References with Docstrings in Qualtran Bloqs (Python)\nDESCRIPTION: This code snippet demonstrates how to document references in a Qualtran Bloq's docstring using the 'References' section. It showcases the markdown-style link format, author names, publication year, and relevant figures/equations for the `QROM` class.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/Autodoc.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass QROM(Bloq):\n    \"\"\"Bloq to load data[l] in the target register when the selection stores an index l.\n\n    References:\n        [Encoding Electronic Spectra in Quantum Circuits with Linear T Complexity](https://arxiv.org/abs/1805.03662).\n        Babbush et al. (2018). Figure 1.\n\n        [Compilation of Fault-Tolerant Quantum Heuristics for Combinatorial Optimization](https://arxiv.org/abs/2007.07391).\n        Babbush et al. (2020). Figure 3.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: AddIntoPhaseGrad Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature for `add_into_phase_grad` using `show_bloqs` from `qualtran.drawing`. It visualizes the inputs and outputs of the bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/phase_gradient.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([add_into_phase_grad],\n           ['`add_into_phase_grad`'])\n```\n\n----------------------------------------\n\nTITLE: Import Identity gate from qualtran\nDESCRIPTION: Imports the `Identity` class from the `qualtran.bloqs.basic_gates` module to be used in subsequent examples.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/basic_gates/identity.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import Identity\n```\n\n----------------------------------------\n\nTITLE: Import AutoPartition from qualtran\nDESCRIPTION: Imports the `AutoPartition` class from the `qualtran.bloqs.bookkeeping` module. This class is used to automatically partition registers for use with other bloqs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/bookkeeping/bookkeeping.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.bookkeeping import AutoPartition\n```\n\n----------------------------------------\n\nTITLE: Show Call Graph and Counts Sigma of ComplexGivensRotationByPhaseGradient\nDESCRIPTION: Generates and displays the call graph and counts sigma for the `cplx_givens` bloq using the `call_graph` method and `show_call_graph`, `show_counts_sigma` functions respectively. The `ignore_split_join` generalizer simplifies the call graph by ignoring split and join operations.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/quad_fermion/givens_bloq.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ncplx_givens_g, cplx_givens_sigma = cplx_givens.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(cplx_givens_g)\nshow_counts_sigma(cplx_givens_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generate and Show Call Graph of RzViaPhaseGradient\nDESCRIPTION: This code snippet generates a call graph for the `rz_via_phase_gradient` object using the `call_graph` method. It also employs `ignore_split_join` from `qualtran.resource_counting.generalizers` to simplify the graph. The generated graph and associated counts are then displayed using `show_call_graph` and `show_counts_sigma` respectively.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/rotations/rz_via_phase_gradient.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nrz_via_phase_gradient_g, rz_via_phase_gradient_sigma = rz_via_phase_gradient.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(rz_via_phase_gradient_g)\nshow_counts_sigma(rz_via_phase_gradient_sigma)\n```\n\n----------------------------------------\n\nTITLE: PrepareHubbard Graphical Signature\nDESCRIPTION: Generates and displays the graphical signature of the `PrepareHubbard` instance using `show_bloqs`. This visualization provides a high-level overview of the bloq's inputs and outputs.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/hubbard_model/qubitization/hubbard_model.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prep_hubb],\n           ['`prep_hubb`'])\n```\n\n----------------------------------------\n\nTITLE: Permutation Example Instance\nDESCRIPTION: Creates an instance of the `Permutation` class from a dense permutation mapping. The dense permutation maps index 0 to 1, 1 to 3, 2 to 0, and 3 to 2.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/permutation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npermutation = Permutation.from_dense_permutation([1, 3, 0, 2])\n```\n\n----------------------------------------\n\nTITLE: Showing Graphical Signatures of ScaledChebyshevPolynomial instances\nDESCRIPTION: This snippet uses `show_bloqs` to display the graphical signatures of the `scaled_chebyshev_poly_even` and `scaled_chebyshev_poly_odd` instances created earlier. This provides a visual representation of the inputs and outputs of the block encoding.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/block_encoding/chebyshev_polynomial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([scaled_chebyshev_poly_even, scaled_chebyshev_poly_odd],\n           ['`scaled_chebyshev_poly_even`', '`scaled_chebyshev_poly_odd`'])\n```\n\n----------------------------------------\n\nTITLE: Visualize PrepareTFirstQuantization bloq\nDESCRIPTION: This snippet utilizes the `show_bloqs` function to visualize the `prepare_t` bloq. The output will be a graphical representation of the bloq, showing its inputs, outputs, and internal structure, which aids in understanding its function.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/chemistry/pbc/first_quantization/first_quantization.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.drawing import show_bloqs\nshow_bloqs([prepare_t],\n           ['`prepare_t`'])\n```\n\n----------------------------------------\n\nTITLE: Call Graph and Resource Counting for `ECAddR`\nDESCRIPTION: Generates and displays the call graph and resource counts for the symbolic instance of the `ECAddR` bloq (`ec_add_r`).  The call graph displays the sub-bloqs up to depth 1, using the `ignore_split_join` generalizer. The resource counts are stored in `ec_add_r_sigma`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ecc.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nec_add_r_g, ec_add_r_sigma = ec_add_r.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(ec_add_r_g)\nshow_counts_sigma(ec_add_r_sigma)\n```\n\n----------------------------------------\n\nTITLE: Generating Call Graph for CModMulK\nDESCRIPTION: This snippet generates and displays the call graph and resource counts sigma for the symbolic `modmul_symb` Bloq.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\nmodmul_symb_g, modmul_symb_sigma = modmul_symb.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(modmul_symb_g)\nshow_counts_sigma(modmul_symb_sigma)\n```\n\n----------------------------------------\n\nTITLE: Importing the ECAdd Module from Qualtran\nDESCRIPTION: This code snippet imports the `ECAdd` class from the `qualtran.bloqs.cryptography.ecc` module. The `ECAdd` class is used to perform elliptic curve point addition within the Qualtran framework.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/cryptography/ecc/ec_add.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.cryptography.ecc import ECAdd\n```\n\n----------------------------------------\n\nTITLE: Importing Qualtran and Related Libraries\nDESCRIPTION: This snippet imports necessary modules from the `qualtran` library for defining and manipulating quantum circuits, as well as standard Python libraries for numerical computation and symbolic mathematics.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran import Bloq, CompositeBloq, BloqBuilder, Signature, Register\nfrom qualtran import QBit, QInt, QUInt, QAny\nfrom qualtran.drawing import show_bloq, show_call_graph, show_counts_sigma\nfrom typing import *\nimport numpy as np\nimport sympy\nimport cirq\n```\n\n----------------------------------------\n\nTITLE: Define SwapWithZero\nDESCRIPTION: Imports the SwapWithZero class from qualtran.bloqs.swap_network. This class swaps a specified register with a zero state, conditioned on a selection register.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/swap_network/swap_network.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.swap_network import SwapWithZero\n```\n\n----------------------------------------\n\nTITLE: Fixed-Point Multiplication with Integer - Python\nDESCRIPTION: Implements fixed-point multiplication of a real number with an integer using repeated additions, as described in Appendix D4 of the referenced paper. The `get_bitsize_for_fxp_mul_with_integer` function calculates the required bitsize based on the desired precision and the integer's bitsize. The `mul_with_int_via_repeated_add` function performs the multiplication, while `test_multiplication_with_integer_for_eps` tests the multiplication for given error tolerances by comparing the result to standard floating-point multiplication.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/arithmetic/error_analysis_for_fxp_arithmetic.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Multiplying a real numbers with an d_B-bit integer.\ndef get_bitsize_for_fxp_mul_with_integer(eps: float, d_B: int):\n    return d_B + int(np.ceil(np.log2(d_B / eps))) # Equation D7\n\ndef mul_with_int_via_repeated_add(a: float, b: int, d_A: int, d_B: int):\n    \"\"\"Multiplicaiton via repeated additions algorithm described in Appendix D5\"\"\"\n    a_fxp = fxp(a, d=d_A, d_word=d_A+d_B-1) # The paper proposes to use `d_A-1` bits of `a` but we instead need to use `d_A` bits.\n    res = fxp(0, d=d_A-d_B, d_word=d_A)\n    for i in range(d_B):\n        b_i = (b >> i) & 1\n        a_i = (a_fxp << i).like(res)\n        res += a_i * b_i\n    return res\n\ndef test_multiplication_with_integer_for_eps(eps: float, d_B: int, d_A: int):\n    rng = np.random.default_rng(int(eps * d_B * 1e9))\n    try:\n        for _ in range(100):\n            a, = rng.random(1)\n            b = rng.integers(0, 1 << d_B)\n            res = mul_with_int_via_repeated_add(a, b, d_A, d_B)\n            assert_allclose(res, a * b, eps)\n        print(f'Success! {eps=}, {d_A=}, {d_B=}')\n    except AssertionError:\n        print(f'Failed! {eps=}, {d_A=}, {d_B=}')\n\nfor eps in [1e-3, 1e-4, 1e-5, 1e-6, 1e-7, 1e-9]:\n    for d_B in [5, 8, 11]:\n        d_A = get_bitsize_for_fxp_mul_with_integer(eps, d_B)\n        test_multiplication_with_integer_for_eps(eps, d_B, d_A)\n```\n\n----------------------------------------\n\nTITLE: Call Graph Visualization\nDESCRIPTION: Generates and visualizes the call graph of the concrete `GF2AddK` instance (`gf16_add_k`). It utilizes `ignore_split_join` to simplify the graph and then displays the call graph and the counts sigma.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/gf_arithmetic/gf2_add_k.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.resource_counting.generalizers import ignore_split_join\ngf16_add_k_g, gf16_add_k_sigma = gf16_add_k.call_graph(max_depth=1, generalizer=ignore_split_join)\nshow_call_graph(gf16_add_k_g)\nshow_counts_sigma(gf16_add_k_sigma)\n```\n\n----------------------------------------\n\nTITLE: Importing DirtyOutOfPlaceMontgomeryModMul\nDESCRIPTION: Imports the `DirtyOutOfPlaceMontgomeryModMul` class from `qualtran.bloqs.mod_arithmetic`.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.mod_arithmetic import DirtyOutOfPlaceMontgomeryModMul\n```\n\n----------------------------------------\n\nTITLE: Creating ModDbl Instances\nDESCRIPTION: This snippet demonstrates how to create instances of the `ModDbl` class with different parameters. One instance uses a small modulus, while the other uses a larger prime number.\nSOURCE: https://github.com/quantumlib/qualtran/blob/main/qualtran/bloqs/mod_arithmetic/mod_multiplication.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmoddbl_small = ModDbl(QUInt(4), 13)\n```"
  }
]