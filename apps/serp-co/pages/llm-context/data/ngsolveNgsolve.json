[
  {
    "owner": "ngsolve",
    "repo": "ngsolve",
    "content": "TITLE: Defining Geometry with Lines and Splines (Python)\nDESCRIPTION: This snippet defines a geometry using a list of points and then adds lines and splines to the geometry.  Boundary conditions are set for each curve.  It also shows how to append the curves to the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\n\npnts =[(0,0),\n       #(0,0,0.05), # define a local mesh refinement for one point\n       (1,0),\n       (1,0.5),\n       (1,1),\n       (0.5,1),\n       (0,1)]\n\np1,p2,p3,p4,p5,p6 = [geo.AppendPoint(*pnt) for pnt in pnts]\n```\n\nLANGUAGE: python\nCODE:\n```\ncurves = [[[\"line\",p1,p2],\"bottom\"],\n          [[[\"line\",p2,p3],\"right\"],\n          [[[\"spline3\",p3,p4,p5],\"curve\"],\n          [[[\"line\",p5,p6],\"top\"],\n          [[[\"line\",p6,p1],\"left\"]]\n\n[geo.Append(c,bc=bc) for c,bc in curves]\n```\n\n----------------------------------------\n\nTITLE: Draw Mesh in NGSolve using Python\nDESCRIPTION: This snippet uses the `Draw` function to visualize the generated mesh within the NGSolve web GUI.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Calculating and drawing deformation\nDESCRIPTION: This snippet calculates a deformation field for mesh adaptation based on the level set function, then visualizes the deformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# for isoparametric mapping\nfrom xfem.lsetcurv import *\nlsetmeshadap = LevelSetMeshAdaptation(mesh, order=2)\ndeformation = lsetmeshadap.CalcDeformation(levelset)\nDraw(deformation, mesh, \"deformation\")\n```\n\n----------------------------------------\n\nTITLE: Create a Cube using CSG Primitives in Netgen\nDESCRIPTION: This snippet demonstrates how to create a cube using CSG primitives (planes) and boolean operations (intersection) within the netgen.csg module. It defines six planes representing the faces of the cube and intersects them to create a solid cube.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\n\nleft  = Plane (Pnt(0,0,0), Vec(-1,0,0) )\nright = Plane (Pnt(1,1,1), Vec( 1,0,0) )\nfront = Plane (Pnt(0,0,0), Vec(0,-1,0) )\nback  = Plane (Pnt(1,1,1), Vec(0, 1,0) )\nbot   = Plane (Pnt(0,0,0), Vec(0,0,-1) )\ntop   = Plane (Pnt(1,1,1), Vec(0,0, 1) )\n\ncube = left * right * front * back * bot * top\n```\n\n----------------------------------------\n\nTITLE: Glue Shapes Together - Python\nDESCRIPTION: This snippet glues the box and cylinder geometries together using `Glue`. This creates a composite solid that preserves the interface face between the solids.  The resulting geometry is then meshed and visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ngeo = Glue( [box, cyl])\nDrawGeo (geo)\n\nmesh = Mesh(OCCGeometry(geo).GenerateMesh(maxh=0.2)).Curve(3)\nDraw (mesh, clipping=True);\n```\n\n----------------------------------------\n\nTITLE: Marking Dofs and Compressing FESpace - Python\nDESCRIPTION: This snippet shows how to restrict a finite element space to active dofs. `GetDofsOfElements` is used to select dofs corresponding to elements of type HASNEG. Then, `Compress` reduces the finite element space to only the selected dofs. Alternatively, `Restrict` can directly restrict a finite element space to a set of elements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nVhbase = H1(mesh, order=1, dirichlet=[])\nVhC = Compress(Vhbase,GetDofsOfElements(Vhbase,ci.GetElementsOfType(HASNEG)))\nVhR = Restrict(Vhbase,ci.GetElementsOfType(HASNEG))\nprint(Vhbase.ndof, VhC.ndof, VhR.ndof) \n```\n\n----------------------------------------\n\nTITLE: Evaluating a CoefficientFunction at a Point\nDESCRIPTION: This snippet evaluates the `myfunc` CoefficientFunction at a specific point (0.2, 0.2) on the mesh. It demonstrates how to use `mesh` to create a `MappedIntegrationPoint` and then pass it to the CoefficientFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmip = mesh(0.2, 0.2)\nmyfunc(mip)\n```\n\n----------------------------------------\n\nTITLE: Using NGSolve's Newton Solver\nDESCRIPTION: This code demonstrates the use of NGSolve's built-in `Newton` solver. It sets the initial guess and calls the solver with specific parameters like maximum iterations, error tolerance, inverse solver, and damping factor. Demonstrates the usage of `help(Newton)` for documentation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.solvers import *\nhelp(Newton)\n```\n\nLANGUAGE: python\nCODE:\n```\ngfu.Set((x*(1-x))**4*(y*(1-y))**4) # initial guess\nNewton(a,gfu,freedofs=gfu.space.FreeDofs(),maxit=100,maxerr=1e-11,inverse=\"umfpack\",dampfactor=1,printing=True)\n```\n\n----------------------------------------\n\nTITLE: Define and Assemble Linear and Bilinear Forms in NGSolve\nDESCRIPTION: This snippet defines and assembles the bilinear and linear forms for the Poisson equation.  `BilinearForm(fes)` creates a bilinear form, and `a += grad(u)*grad(v)*dx` adds the diffusion term. `LinearForm(fes)` creates a linear form, and `f += x*v*dx` adds the source term.  `a.Assemble()` and `f.Assemble()` assemble the forms into matrices and vectors, respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(fes)\na += grad(u)*grad(v)*dx\na.Assemble()\n\nf = LinearForm(fes)\nf += x*v*dx\nf.Assemble();\n```\n\n----------------------------------------\n\nTITLE: Solving Stokes Equation\nDESCRIPTION: This snippet solves the Stokes equation using a direct solver (UMFPACK). The residual is calculated, the inverse of the stiffness matrix is computed, and the solution is updated. The velocity field is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nres = -a.mat * gf.vec\ninv = a.mat.Inverse(freedofs=X.FreeDofs(), inverse=\"umfpack\")\ngf.vec.data += inv * res\nDraw(gfu, mesh);\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve and Netgen modules in Python\nDESCRIPTION: This snippet imports the necessary modules from NGSolve and Netgen to enable finite element analysis and visualization. `ngsolve` provides the core functionality for solving PDEs, while `ngsolve.webgui` enables visualization within a web browser.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Setting up finite element problem with NGSolve\nDESCRIPTION: This snippet sets up a finite element problem using NGSolve, including creating a mesh, finite element space, bilinear form, linear functional, and solution function. The `Setup` function (not defined in the snippet but assumed to be defined elsewhere) initializes these components. The solution is then visualized using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nmesh, fes, a, f, gfu = Setup(h=0.5, p=3)\nDraw(gfu)\nmg = Preconditioner(a, 'multigrid')  # register mg to a\na.Assemble()                         # assemble on coarsest mesh \n```\n\n----------------------------------------\n\nTITLE: Creating a Periodic Square Mesh\nDESCRIPTION: This code creates a square geometry with periodic boundary conditions using Netgen OCC.  It defines a rectangle, names the edges, and then identifies opposite edges to enforce periodicity.  Finally, it generates a mesh from the OCC geometry with a specified maximum element size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/periodicity.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nshape = Rectangle(1,1).Face()\n\nshape.edges.Max(X).name = \"right\"\nshape.edges.Min(X).name = \"left\"\nshape.edges.Max(Y).name = \"top\"\nshape.edges.Min(Y).name = \"bot\"\n\nshape.edges.Max(Y).Identify(shape.edges.Min(Y), \"bt\")\nshape.edges.Max(X).Identify(shape.edges.Min(X), \"lr\")\n\nmesh = Mesh(OCCGeometry(shape, dim=2).GenerateMesh(maxh=0.1))\n```\n\n----------------------------------------\n\nTITLE: Defining a Preconditioner for a Bilinear Form in NGSolve (Python)\nDESCRIPTION: This code snippet demonstrates the canonical way to define a preconditioner for a bilinear form in NGSolve. The preconditioner is defined after the bilinear form but before assembling it. The preconditioner automatically registers itself with the bilinear form and gets updated whenever the form is updated.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_preconditioners.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(fes)\na += SymbolicBFI(grad(u)*grad(v))\nc = Preconditioner(a, \"local\")\na.Assemble()\n```\n\n----------------------------------------\n\nTITLE: One-liner Definition and Assembly of Forms\nDESCRIPTION: This snippet demonstrates a more concise way to define and assemble the bilinear and linear forms using one-liners.  It directly passes the expression to the `BilinearForm` and `LinearForm` constructors, then immediately calls `Assemble()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(grad(u)*grad(v)*dx).Assemble()\nf = LinearForm(x*v*dx).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Define Finite Element Space and Forms\nDESCRIPTION: This code defines the finite element space, bilinear form, and linear form for the magnetostatic problem. It uses HCurl elements, applies a regularization term, and defines the material properties and magnetization.  The 'nograds' flag removes gradient basis functions to allow gauging.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwell.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = HCurl(mesh, order=3, dirichlet=\"outer\", nograds=True)\nprint (\"ndof =\", fes.ndof)\nu,v = fes.TnT()\n\nfrom math import pi\nmu0 = 4*pi*1e-7\nmur = mesh.MaterialCF({\"magnet\" : 1000}, default=1)\n\na = BilinearForm(fes)\na += 1/(mu0*mur)*curl(u)*curl(v)*dx + 1e-8/(mu0*mur)*u*v*dx\nc = Preconditioner(a, \"bddc\")\n\nf = LinearForm(fes)\nmag = mesh.MaterialCF({\"magnet\" : (1,0,0)}, default=(0,0,0))\nf += mag*curl(v) * dx(\"magnet\")\n```\n\n----------------------------------------\n\nTITLE: Solving the 3D Contact Problem - Python\nDESCRIPTION: This code solves the nonlinear system arising from the contact condition using Newton's method with sparse Cholesky factorization. The results are printed during the iterations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager(pajetrace=10**9):\n    NewtonMinimization(a=a, u=gfu, printing=True, inverse=\"sparsecholesky\");\n```\n\n----------------------------------------\n\nTITLE: Declare Finite Element Space in NGSolve using Python\nDESCRIPTION: This snippet defines an H1 finite element space on the mesh. The `order` parameter specifies the polynomial order of the basis functions, and `dirichlet` specifies the Dirichlet boundary conditions on the \"bottom\" and \"right\" boundaries. `fes.ndof` returns the number of degrees of freedom in this space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=2, dirichlet=\"bottom|right\")\nfes.ndof  # number of unknowns in this space\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh from OCC Geometry\nDESCRIPTION: This snippet generates a mesh from the previously defined OCC geometry using NGSolve. The mesh is created with a specified maximum element size and then curved. The resulting mesh is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngeo = OCCGeometry(shape, dim=2)\nmesh = Mesh(geo.GenerateMesh(maxh=0.05))\nmesh.Curve(3)\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Boundary Condition Function - Python\nDESCRIPTION: This code snippet defines the boundary condition function `g = sin(y)` where 'y' is the coordinate on the boundary. This function will be used to specify the Dirichlet boundary condition on the designated boundary parts.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ng = sin(y)\n```\n\n----------------------------------------\n\nTITLE: Navier-Stokes Solver Implementation\nDESCRIPTION: This code snippet provides the complete implementation of the Navier-Stokes solver using NGSolve. It sets up the finite element spaces for velocity and pressure, defines the weak forms for the Stokes and Navier-Stokes equations, and implements the time-stepping scheme. The solver uses operator splitting for time integration and solves the equations iteratively. The code also includes visualization of the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/whetting_the_appetite/navierstokes.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: /../py_tutorials/navierstokes.py\n```\n\n----------------------------------------\n\nTITLE: Declare Test, Trial, and Grid Functions in NGSolve\nDESCRIPTION: This snippet declares test, trial, and grid functions within the finite element space. `fes.TrialFunction()` and `fes.TestFunction()` create symbolic objects for defining bilinear forms, while `GridFunction(fes)` creates a function object to store the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nu = fes.TrialFunction()  # symbolic object\nv = fes.TestFunction()   # symbolic object\ngfu = GridFunction(fes)  # solution \n```\n\n----------------------------------------\n\nTITLE: Defining Convection Term in Bilinear Form - Python\nDESCRIPTION: This code defines the convection term in the bilinear form `c`. It utilizes the upwind flux for the discontinuous Galerkin method, accessing neighboring element values with `u.Other()`. The `bnd` argument in `.Other()` handles boundary conditions by evaluating `ubnd` where there is no neighbor.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn = specialcf.normal(mesh.dim)\nupw_flux = b*n * IfPos(b*n, u, u.Other(bnd=ubnd))\ndS = dx(element_boundary=True)\nc += - b * grad(v) * u * dx + upw_flux * v * dS\n```\n\n----------------------------------------\n\nTITLE: Defining a CoefficientFunction in NGSolve\nDESCRIPTION: This code snippet defines a simple CoefficientFunction using the built-in 'x' coordinate variable. The created CoefficientFunction represents a parabolic function x*(1-x).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmyfunc = x*(1-x)\nmyfunc   # You have just created a CoefficientFunction\n```\n\n----------------------------------------\n\nTITLE: Define Linear and Bilinear Forms in Python\nDESCRIPTION: This snippet defines the linear and bilinear forms for the Poisson equation. The forms are expressed in terms of trial (`u`) and test (`v`) functions. The linear form `f` represents the source term, and the bilinear form `a` represents the Laplacian operator. The forms are then assembled to create the system matrix and load vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/poisson.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nu = fes.TrialFunction()\nv = fes.TestFunction()\n\nf = LinearForm(fes)\nf += 32 * (y*(1-y)+x*(1-x)) * v * dx\n\na = BilinearForm(fes)\na += grad(u)*grad(v)*dx\n\na.Assemble()\nf.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Solving Stokes with the Mini Element\nDESCRIPTION: This snippet demonstrates the use of the mini element (P1+ - P1). The velocity space is enriched with cubic bubble functions on triangles, and the pressure space is continuous P1.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nV = VectorH1(mesh, order=1, dirichlet=\"wall|inlet|cyl\")\nV.SetOrder(TRIG,3)\nV.Update()\nQ = H1(mesh, order=1)\nX = V*Q\n\ngfu = SolveStokes(X)\n```\n\n----------------------------------------\n\nTITLE: Defining Taylor-Hood Finite Element Spaces\nDESCRIPTION: This snippet defines the Taylor-Hood finite element spaces for velocity and pressure. Vector-valued continuous P2 elements are used for velocity, and continuous P1 elements are used for pressure. Dirichlet boundary conditions are applied on the wall, inlet, and cylinder boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nV = VectorH1(mesh, order=2, dirichlet=\"wall|inlet|cyl\")\nQ = H1(mesh, order=1)\nX = V*Q\n```\n\n----------------------------------------\n\nTITLE: Applying deformation and solving\nDESCRIPTION: This snippet applies the calculated deformation to the mesh, re-assembles the bilinear and linear forms, solves the linear system, and visualizes the solution. It also shows the deformed mesh and graph of the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# alternatively to passing the deformation to dCut me can do the mesh deformation by hand\nmesh.deformation = deformation\na.Assemble()\nf.Assemble()\nmesh.deformation = None\n\nSolveLinearSystem()\n\n\nDrawDC(lsetp1, gfu.components[0], gfu.components[1], mesh, \"u\", deformation=deformation, min=0, max=0.25)\n\nuh = IfPos(lsetp1, gfu.components[1], gfu.components[0])\ndeform_graph = CoefficientFunction((deformation[0], deformation[1], 4*uh))\nDrawDC(lsetp1, gfu.components[0], gfu.components[1], mesh, \"graph_of_u\", deformation=deform_graph, min=0, max=0.25)\n```\n\n----------------------------------------\n\nTITLE: Assembling the System\nDESCRIPTION: This code assembles the bilinear form `a` representing the weak form of the Helmholtz equation and the linear form `f` representing the source term.  The complex impedance boundary condition is implemented using the `ds(\"outer\")` domain. The forms are assembled into matrices.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/helmholtz.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Forms\na = BilinearForm(fes)\na += grad(u)*grad(v)*dx - omega**2*u*v*dx\na += -omega*1j*u*v * ds(\"outer\")\na.Assemble()\n\nf = LinearForm(pulse * v * dx).Assemble();\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Simulation\nDESCRIPTION: This snippet imports necessary libraries for the elasto-plasticity simulation in NGSolve. It includes NumPy for numerical operations, NGSolve for finite element analysis, IntegrationRuleSpace and NewtonCF for solving the problem, netgen for geometry creation and Draw for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nfrom ngsolve import *\nfrom ngsolve.comp import IntegrationRuleSpace\nfrom ngsolve.fem import MinimizationCF, NewtonCF\nfrom netgen.geom2d import CSG2d, Circle, Rectangle\nfrom ngsolve.webgui import Draw\nSetNumThreads(4)\n```\n\n----------------------------------------\n\nTITLE: Copying Surface Elements for Mesh Merging\nDESCRIPTION: This code copies the surface elements from the two input meshes (`m1` and `m2`) to the new mesh (`ngmesh`).  It first creates dictionaries (`pmap1` and `pmap2`) to map point numbers from the old meshes to the new mesh.  Then, it iterates through the surface elements of each input mesh, adding the corresponding elements to the new mesh with the appropriate face descriptor.  It ensures each point is added only once.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# copy all boundary points from first mesh to new mesh.\n# pmap1 maps point-numbers from old to new mesh\npmap1 = { }\nfor e in m1.Elements2D():\n    for v in e.vertices:\n        if (v not in pmap1):\n            pmap1[v] = ngmesh.Add (m1[v])\n\n\n# copy surface elements from first mesh to new mesh\n# we have to map point-numbers:\n\nfor e in m1.Elements2D():\n    ngmesh.Add (Element2D (fd_outside, [pmap1[v] for v in e.vertices]))\n\n# same for the second mesh:\npmap2 = { }\nfor e in m2.Elements2D():\n    for v in e.vertices:\n        if (v not in pmap2):\n            pmap2[v] = ngmesh.Add (m2[v])\n\nfor e in m2.Elements2D():\n    ngmesh.Add (Element2D (fd_inside, [pmap2[v] for v in e.vertices]))\n```\n\n----------------------------------------\n\nTITLE: Setup Mesh and Finite Element Space - Python\nDESCRIPTION: This snippet sets up the mesh and finite element space required for the simulation. It generates a mesh on the unit square, defines an H1 finite element space of order 1, and specifies Dirichlet boundary conditions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.3))\n\nfes = H1(mesh,order=1, dirichlet=\".*\", autoupdate=True)\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx)\n```\n\n----------------------------------------\n\nTITLE: Variational Formulation Implementation - Python\nDESCRIPTION: This code implements the variational formulation for the mixed Poisson problem. It includes terms for the flux-flux interaction (dX), divergence terms for the mixed formulation (dxbar), ghost penalty stabilization (dP, if enabled), and source term (dxbar). The Dirichlet boundary condition is weakly enforced via the ds integral.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\na += uh*vh * dX\na += (div(uh) * qT + div(vh) * pT) * dxbar\nif gamma_stab > 0: # ghost penalty\n    a += gamma_stab * (uh - uh.Other()) * (vh - vh.Other()) * dP\nf += -coeff_f * qT * dxbar\nf += p_exact * vh * n * ds\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up Finite Element Space and Bilinear Form\nDESCRIPTION: Defines the finite element space using `VectorH1` with order 3 and Dirichlet boundary conditions on the \"fix\" face.  A bilinear form is defined using the inner product of the stress and strain tensors.  A preconditioner is also created for solving the linear system.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfes = VectorH1(mesh, order=3, dirichlet=\"fix\")\nu,v = fes.TnT()\ngfu = GridFunction(fes)\n\nwith TaskManager():\n    a = BilinearForm(InnerProduct(Stress(Sym(Grad(u))), Sym(Grad(v))).Compile()*dx)\n    pre = Preconditioner(a, \"bddc\")\n    a.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Solving with Automatic Utility BVP (Python)\nDESCRIPTION: This snippet uses the `solvers.BVP` utility to solve the Poisson equation with static condensation automatically. It defines a preconditioner `c` and uses it within the `solvers.BVP` function.  It then calculates the error between the computed solution and the manufactured solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nu = GridFunction(fes)\nu.Set(U, BND) \n\nc = Preconditioner(a,\"direct\")\nc.Update()\nsolvers.BVP(bf=a, lf=f, gf=u, pre=c)\nsqrt(Integrate((U-u)*(U-u),mesh))\n```\n\n----------------------------------------\n\nTITLE: Defining Strain and Energy Functions\nDESCRIPTION: This code defines functions for computing the strain tensor, elastic strain energy density, tensor norm, and deviatoric stress tensor. These functions are essential for formulating the constitutive equations in the elasto-plasticity model. It assumes that `mu` and `lmbda` as material parameters are already defined as Parameters.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef strain(u):\n    # compute symmetric gradient (here a 2x2 block) and \"embed\" it in a 3x3 matrix via \"ExtendDimension\"\n    return Sym(Grad(u)).ExtendDimension((3, 3), pos=(0, 0))\n\n\ndef elastic_strain_energy_mu_lambda(eps, mu, lmbda):\n    return mu * InnerProduct(eps, eps) + lmbda/2 * Trace(eps)**2\n\n\ndef elastic_strain_energy(eps):\n    return elastic_strain_energy_mu_lambda(eps, mu, lmbda)\n\n\ndef tensor_norm(a, pert=0):\n    return sqrt(InnerProduct(a, a) + pert)\n\n\ndef dev(a):\n    return a - Trace(a) * Id(3) / 3\n```\n\n----------------------------------------\n\nTITLE: Applying Simple Newton Solver to PDE\nDESCRIPTION: This code applies the `SimpleNewtonSolve` function to solve the previously defined PDE. It initializes a `GridFunction`, provides an initial guess, calls the Newton solver, and visualizes the solution. Also stores the iterations in a multidim GridFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(V)\ngfu.Set((x*(1-x))**4*(y*(1-y))**4) # initial guess\ngfu_it = GridFunction(gfu.space,multidim=0)\ncb = lambda gfu : gfu_it.AddMultiDimComponent(gfu.vec) # store current state\nSimpleNewtonSolve(gfu, a, callback = cb)\n```\n\n----------------------------------------\n\nTITLE: Level Set Optimization Loop in NGSolve (Python)\nDESCRIPTION: This Python code implements the iterative level set optimization algorithm using NGSolve.  It initializes the level set function, defines the main optimization loop, computes the topological derivative, updates the level set based on this derivative, performs a line search to optimize the step size (kappa), and updates material properties and solves a PDE in each iteration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/05_Topological_Derivative_Transmission.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\niter_max = 20\nconverged = False\n\nxm=0.\nym=0.\npsi.Set( (x-xm)**2+(y-ym)**2-0.25**2)\npsinew.vec.data= psi.vec\nscene.Redraw()\n\nJ = Integrate(Cost(gfu),mesh)\n\nwith TaskManager():\n\n    for k in range(iter_max):\n        print(\"================ iteration \", k, \"===================\")\n\n        # copy new levelset data from psinew into psi\n        psi.vec.data = psinew.vec\n        scene.Redraw()\n        \n        \n        SolvePDE(adjoint=True)\n        \n        J_current = Integrate(Cost(gfu),mesh)\n\n        print( Integrate( (gfu-gfud)**2*dx, mesh) )\n\n        print(\"cost in beginning of iteration\", k, \": Cost = \", J_current)        \n        \n        # compute the piecewise constant topological derivative in each domain\n        TDPosNeg_pwc.Set( BetaPosNeg * grad(gfu) * grad(gfp)  + FPosNeg*gfp )\n        TDNegPos_pwc.Set( BetaNegPos * grad(gfu) * grad(gfp)  + FPosNeg*gfp )\n\n        # compute the cut ratio of the interface elements\n        InterpolateLevelSetToElems(psi, 1, 0, cutRatio, mesh, EPS)\n        scene_cr.Redraw()\n        \n        # compute the combined topological derivative using the cut ratio information\n        for j in range(len(TD_pwc.vec)):\n            TD_pwc.vec[j] = cutRatio.vec[j] * TDNegPos_pwc.vec[j] + (1-cutRatio.vec[j])*TDPosNeg_pwc.vec[j]\n        \n        TD_node.Set(TD_pwc)\n                \n        normTD = sqrt(Integrate(TD_node**2*dx, mesh)) # L2 norm of TD_node\n        TD_node.vec.data = 1/normTD * TD_node.vec # normalised TD_node\n        \n        normPsi = sqrt(Integrate(psi**2*dx, mesh)) # L2 norm of psi\n        psi.vec.data = 1/normPsi * psi.vec  # normalised psi\n        \n        linesearch = True\n       \n        for j in range(10): \n\n            # update the level set function\n            psinew.vec.data = (1-kappa)*psi.vec + kappa*TD_node.vec\n            \n            # update beta and f_rhs\n            InterpolateLevelSetToElems(psinew, beta1, beta2, beta, mesh, EPS)\n            InterpolateLevelSetToElems(psinew, f1, f2, f_rhs, mesh, EPS)\n\n            # solve PDE without adjoint\n            SolvePDE()\n            \n            Redraw(blocking=True)\n \n            Jnew = Integrate(Cost(gfu), mesh)\n            \n            if Jnew > J_current:\n                print(\"--------------------\")\n                print(\"-----line search ---\")\n                print(\"--------------------\")\n                kappa = kappa*0.8\n                print(\"kappa\", kappa)\n            else:\n                break\n        \n        Redraw(blocking=True)\n        print(\"----------- Jnew in  iteration \", k, \" = \", Jnew, \" (kappa = \", kappa, \")\")\n        print('')\n        print(\"iter\" + str(k) + \", Jnew = \" + str(Jnew) + \" (kappa = \", kappa, \")\")\n        kappa = min(1, kappa*1.2)\n\n        print(\"end of iter \" + str(k))\n```\n\n----------------------------------------\n\nTITLE: Defining Normal Vector\nDESCRIPTION: This snippet defines the normal vector using `specialcf.normal(mesh.dim)`. The normal vector is a coefficient function that can be used at the boundary. Its orientation depends on the geometry definition.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnormal = specialcf.normal(mesh.dim)\nprint (normal)\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Space with Dirichlet Boundary Conditions - Python\nDESCRIPTION: This code snippet defines a finite element space (fes) with H1 elements of order 2 on a mesh generated from a unit square. It specifies that Dirichlet boundary conditions are applied on the 'left' and 'right' boundaries.  It then compares it with a space without Dirichlet boundary conditions, demonstrating the impact on the number of degrees of freedom.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import unit_square\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\nmesh.GetBoundaries()\n\nfes = H1(mesh, order=2, dirichlet=\"left|right\")\nfs2 = H1(mesh, order=2)\nfes.ndof, fs2.ndof    # total number of unknowns\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System with Dirichlet Conditions - Python\nDESCRIPTION: This code snippet solves the linear system with inhomogeneous Dirichlet boundary conditions. It uses the `Inverse` method with the `freedofs` argument to solve only for the free degrees of freedom. The solution is then added to the grid function `gfu` and visualized using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngfu.vec.data += a.mat.Inverse(freedofs=fes.FreeDofs()) * r  \nDraw(gfu);\n```\n\n----------------------------------------\n\nTITLE: Solving with CG using Symmetric GS Preconditioner\nDESCRIPTION: Solves the linear system using the Conjugate Gradient (CG) method with the `SymmetricGS` preconditioner. It initializes the preconditioner `preGS` with the point Jacobi smoother `preJpoint` and then calls `solvers.CG` with the assembled matrix `a.mat`, the preconditioner `preGS`, the right-hand side vector `f.vec`, and the grid function vector `gfu.vec`. The solution is visualized using `Draw(gfu)`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npreGS = SymmetricGS(preJpoint)\nsolvers.CG(mat=a.mat, pre=preGS, rhs=f.vec, sol=gfu.vec)\nDraw(gfu)\n```\n\n----------------------------------------\n\nTITLE: Updating Time Slab Geometry (Python)\nDESCRIPTION: This snippet defines a function UpdateTimeSlabGeometry to update the geometry of the time slab for each time step. This involves calculating the deformation based on the level set, updating the markers in the space-time mesh, and re-computing the facets for stabilization.  Crucially, this function manages the dynamic changes arising from the moving domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef UpdateTimeSlabGeometry():\n    lsetadap.CalcDeformation(levelset)\n\n    # Update markers in (space-time) mesh\n    ci.Update(lsetadap.levelsetp1[INTERVAL], time_order=0)\n\n    # re-compute the facets for stabilization:\n    ba_facets[:] = GetFacetsWithNeighborTypes(mesh,\n                                              a=ci.GetElementsOfType(HASNEG),\n                                              b=ci.GetElementsOfType(IF))\n    active_dofs[:] = GetDofsOfElements(st_fes, ci.GetElementsOfType(HASNEG))\n```\n\n----------------------------------------\n\nTITLE: Shape Optimization Loop - Python\nDESCRIPTION: This code implements a shape optimization loop, iteratively updating the deformation field and mesh to minimize the cost functional. It incorporates a linesearch to adjust the step size at each iteration, ensuring a decrease in the cost functional.  The loop continues for a maximum of `iter_max` iterations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\n\niter_max = 50\ngfset.vec[:] = 0\nmesh.SetDeformation(gfset)\nscene = Draw(gfset,mesh,\"gfset\")\n\nconverged = False\n\nalpha =0.11#100.0 / Norm(gfX.vec)\n# input(\"A\")\nfor k in range(iter_max):\n    mesh.SetDeformation(gfset)\n    scene.Redraw()\n    Jold = Integrate(f, mesh)\n    print(\"cost at iteration \", k, ': ', Jold)\n    \n    # assemble bilinear form\n    aX.Assemble()\n    \n    # assemble shape derivative\n    dJOmega.Assemble()\n        \n    mesh.UnsetDeformation()\n\n    gfX.vec.data = aX.mat.Inverse(VEC.FreeDofs(), inverse=\"sparsecholesky\") * dJOmega.vec\n    \n    # step size control\n    \n    gfset_old = gfset.vec.CreateVector()\ngfset_old.data = gfset.vec    \n    \n    Jnew = Jold + 1\n    while Jnew > Jold:\n\n        gfset.vec.data = gfset_old\n        gfset.vec.data -= alpha * gfX.vec\n\n        mesh.SetDeformation(gfset)\n        \n        Jnew = Integrate(f, mesh)\n        \n        mesh.UnsetDeformation()\n\n        if Jnew > Jold:\n            print(\"reducing step size\")\n            alpha = 0.9*alpha\n        else:\n            print(\"linesearch step accepted\")\n            alpha = alpha*1.5\n            break\n            \n    print(\"step size: \", alpha, '\\n')\n\n    time.sleep(0.1)\n    Jold = Jnew\n```\n\n----------------------------------------\n\nTITLE: Generating HDiv Space\nDESCRIPTION: This snippet generates an HDiv (H(div)) finite element space using Raviart-Thomas elements (RT=True). It sets the order to 2, creates a `GridFunction`, and sets its values using the provided function `func`. It then draws the `GridFunction` as vectors and calculates the interpolation error.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfes = HDiv(mesh, order=2, RT=True)\nud = GridFunction(fes)\nfunc = x*y*(x,y)\nud.Set (func)\nDraw (ud, vectors = { \"grid_size\":30})\nprint (\"interpolation error:\", Integrate ((func-ud)**2, mesh))\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Gradient of a GridFunction\nDESCRIPTION: This snippet calculates and visualizes the gradient of a `GridFunction` that has been set using `myfunc`.  The gradient is computed using the `grad` function and visualized as a vector field using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nu.Set(myfunc)\ngradu = grad(u)\nDraw(gradu, mesh, vectors={\"grid_size\":30});\n```\n\n----------------------------------------\n\nTITLE: Solve Poisson Problem with BDDC Preconditioner\nDESCRIPTION: This code iterates through polynomial orders from 1 to 9, solving the Poisson problem with the 'bddc' (Balancing Domain Decomposition preconditioner with Constraints) preconditioner and static condensation enabled. The results (number of degrees of freedom and number of iterations) are printed for each polynomial order.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfor p in range(1,10):\n    r = SolveProblem(h=0.5, p=p, levels=4, condense=True, \n                     precond=\"bddc\")\n    print (\"p=\", p, \": ndof,nsteps=\", r)  \n```\n\n----------------------------------------\n\nTITLE: Bilinear Form Definition for Nonlinear PDE\nDESCRIPTION: This code defines the finite element space and the bilinear form for the nonlinear PDE. It sets up the variational formulation, including the nonlinear term (u**3*v), using NGSolve's symbolic differentiation capabilities. V is a H1 space with order 3 and dirichlet boundary conditions at all boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nV = H1(mesh, order=3, dirichlet=[1,2,3,4])\nu,v = V.TnT()\na = BilinearForm(V)\na += (grad(u) * grad(v) + 1/3*u**3*v- 10 * v)*dx\n```\n\n----------------------------------------\n\nTITLE: H1-AMG Preconditioner Example in Python\nDESCRIPTION: This code demonstrates the setup and usage of the `h1amg` preconditioner in NGSolve for a scalar problem. It defines a finite element space, a bilinear form, and then sets up the `h1amg` preconditioner. The eigenvalues of the preconditioned system are then computed and printed. A crucial step is assembling the bilinear form, which also sets up the preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.5-amg/amg.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# fes = H1(mesh, order=1, order_policy=ORDER_POLICY.CONSTANT)  # todo: fix withtout edge/face tables\nfes = FESpace(\"nodal\", mesh, order=1)\nprint (\"ndof=\", fes.ndof)\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx + 1e-3*u*v*dx)\npre = Preconditioner(a, \"h1amg\")\nwith TaskManager():\n    a.Assemble();\n    lam = EigenValues_Preconditioner(a.mat, pre.mat)\n    print (list(lam[0:3]), '...', list(lam[-3:-1]))\n```\n\n----------------------------------------\n\nTITLE: Defining Time-Dependent Data Functions (Python)\nDESCRIPTION: This snippet defines time-dependent data functions for the simulation, including the level set geometry, convection velocity, diffusion coefficient, exact solution, and right-hand side source term. These functions are essential for specifying the problem and evaluating the accuracy of the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Level set geometry\n# Radius of disk (the geometry)\nR = 0.5\n# Position shift of the geometry in time\nrho = (1 / (pi)) * sin(2 * pi * t)\n# Convection velocity:\nw = CoefficientFunction((0, rho.Diff(t)))\n# Level set\nr = sqrt(x**2 + (y - rho)**2)\nlevelset = r - R\n\n# Diffusion coefficient\nalpha = 1\n# Solution\nu_exact = cos(pi * r / R) * sin(pi * t)\n# R.h.s.\ncoeff_f = (u_exact.Diff(t)\n           - alpha * (u_exact.Diff(x).Diff(x) + u_exact.Diff(y).Diff(y))\n           + w[0] * u_exact.Diff(x) + w[1] * u_exact.Diff(y)).Compile()\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve modules and creating a mesh\nDESCRIPTION: This code snippet imports necessary modules from the NGSolve library, including ngsolve and ngsolve.webgui, as well as matplotlib for plotting. It then creates a mesh on the unit square with a specified maximum element size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nimport matplotlib.pyplot as plt\nmesh = Mesh (unit_square.GenerateMesh(maxh=0.2))\n```\n\n----------------------------------------\n\nTITLE: Multiplicative Multigrid Preconditioner Class - Python\nDESCRIPTION: This code defines a class `MGPreconditioner` that implements a multiplicative multigrid preconditioner. It performs pre-smoothing, coarse-grid correction, and post-smoothing steps. The `Mult` method applies the preconditioner to a vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass MGPreconditioner(BaseMatrix):\n    def __init__ (self, fes, level, mat, coarsepre):\n        super().__init__()\n        self.fes = fes\n        self.level = level\n        self.mat = mat\n        self.coarsepre = coarsepre\n        if level > 0:\n            self.localpre = mat.CreateSmoother(fes.FreeDofs())\n        else:\n            self.localpre = mat.Inverse(fes.FreeDofs())\n        \n    def Mult (self, d, w):\n        if self.level == 0:\n            w.data = self.localpre * d\n            return\n        \n        prol = self.fes.Prolongation().Operator(self.level)\n\n        w[:] = 0\n        self.localpre.Smooth(w,d)\n        res  = d - self.mat * w\n        w += prol @ self.coarsepre @ prol.T * res\n        self.localpre.SmoothBack(w,d)\n\n\n    def Shape (self):\n        return self.localpre.shape\n    def CreateVector (self, col):\n        return self.localpre.CreateVector(col)\n```\n\n----------------------------------------\n\nTITLE: Parallel Assembly with TaskManager in NGS-Py\nDESCRIPTION: This code snippet demonstrates parallel assembly of a bilinear form in NGS-Py using the TaskManager. The with TaskManager() statement creates worker threads for parallel execution within the code block.  The finite element space provides coloring for simultaneous processing of elements. Requires a finite element space 'fespace' to be defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_parallel.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n    a = BilinearForm(fespace)\n    a += SymbolicBFI(u*v)\n    a.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Energy Density and Dissipation Potential Definitions in Python\nDESCRIPTION: This snippet defines the energy density `Psi` and dissipation potential `Phi` functions, crucial for the plasticity model. `Psi` calculates the total energy density, including elastic strain energy and hardening effects. `Phi` defines the dissipation potential, proportional to the norm of the plastic strain rate.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n# The full energy density (incl. hardening)\ndef Psi(p, strain, p_k, alpha_k):\n    strain_energy = elastic_strain_energy(strain-p)\n    alpha = alpha_k + IfPos(H - 1e-16, sqrt(2/3) * sigma_Y * H * tensor_norm(p - p_k, pert=norm_pert), 0)\n    hardening    = 1/2 * alpha**2\n    return strain_energy + hardening\n\n\n# Dissipation potential: For rate-independent plasticity (homogeneous of degree 1 in the rate of p) \n# this is the dissipation! Also, because of rate independence, the parameter Delta_t is not needed for\n# the evolution.\ndef Phi(p, p_k):\n    return sqrt(2/3) * sigma_Y * tensor_norm(p - p_k, pert=norm_pert)\n```\n\n----------------------------------------\n\nTITLE: Create Cube with a Hole using CSG Primitives in Netgen\nDESCRIPTION: This snippet demonstrates creating a cube with a cylindrical hole using CSG primitives (OrthoBrick, Cylinder) and boolean operations (subtraction). It then generates a mesh of the resulting geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\n\ncube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )\nhole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)\n\ngeo = CSGeometry()\ngeo.Add (cube-hole.maxh(0.05))\nmesh = geo.GenerateMesh(maxh=0.1)\nRedraw()\n```\n\n----------------------------------------\n\nTITLE: Defining Stokes Solver Function\nDESCRIPTION: This snippet defines a function `SolveStokes` that encapsulates the Stokes equation solving process.  It takes the finite element space `X` as input, sets up the bilinear form, applies the inlet boundary condition, solves the linear system, and draws the velocity field.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef SolveStokes(X):\n    (u,p),(v,q) = X.TnT()\n\n    stokes = InnerProduct(Grad(u), Grad(v))*dx + div(u)*q*dx + div(v)*p*dx\n    a = BilinearForm(stokes).Assemble()    \n\n    gf = GridFunction(X)\ngfu, gfp = gf.components\n\nuin = CF ( (1.5*4*y*(0.41-y)/(0.41*0.41), 0) )\ngfu.Set(uin, definedon=mesh.Boundaries(\"inlet\"))\n    \n    res = -a.mat * gf.vec\n    inv = a.mat.Inverse(freedofs=X.FreeDofs(), inverse=\"umfpack\")\ngf.vec.data += inv * res\n     \n    Draw(gfu)\n    \n    return gfu\n```\n\n----------------------------------------\n\nTITLE: Projected Multigrid Class Definition - Python\nDESCRIPTION: This snippet defines the `ProjectedMG` class, which implements a multigrid preconditioner using projection matrices. The coarse grid matrices are calculated from the finest level matrix. It uses a recursive approach to construct the preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass ProjectedMG(BaseMatrix):\n    def __init__ (self, fes, mat, level):\n        super(ProjectedMG, self).__init__()\n        self.fes = fes\n        self.level = level\n        self.mat = mat\n        if level > 0:\n            self.prol = fes.Prolongation().CreateMatrix(level)\n            self.rest = self.prol.CreateTranspose()\n            coarsemat = self.rest @ mat @ self.prol # multiply matrices\n            self.localpre = mat.CreateSmoother(fes.FreeDofs())\n                \n            self.coarsepre = ProjectedMG(fes, coarsemat, level-1)\n        else:\n            self.localpre = mat.Inverse(fes.FreeDofs())\n        \n    def Mult (self, d, w):\n        if self.level == 0:\n            w.data = self.localpre * d\n            return\n        w[:] = 0\n        self.localpre.Smooth(w,d)\n        res = d - self.mat * w\n        w += self.prol @ self.coarsepre @ self.rest * res\n        self.localpre.SmoothBack(w,d)\n        \n    def Shape (self):\n        return self.localpre.shape\n    def CreateVector (self, col):\n        return self.localpre.CreateVector(col)\n```\n\n----------------------------------------\n\nTITLE: Updating the mesh and computing cost\nDESCRIPTION: This code updates the mesh deformation based on the computed deformation field 'gfX'. It scales the deformation field, updates the 'gfset' GridFunction, and redraws the scene. The cost at the initial and new designs are printed to the console using Integrate.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ngfset.Set((0,0))\nmesh.SetDeformation(gfset)\nprint('Cost at initial design', Integrate (CostAuto2(gfu), mesh))\n\nscale = 0.5 / Norm(gfX.vec)\ngfset.vec.data -= scale * gfX.vec\nsceneSet.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Time Loop for Dynamic Contact Simulation - Python\nDESCRIPTION: This code implements the time loop for the dynamic contact simulation. It updates the grid functions, updates the contact boundary, solves the nonlinear problem using NewtonMinimization, and redraws the scene.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n    while t < tend:\n        print (\"time\", t)\n        t += tau\n        uold.vec.data = unew.vec\n        aold.vec.data = anew.vec\n\n        contact.Update(uold, bfmstar, 5, 0.01)\n        NewtonMinimization (a=bfmstar, u=unew, printing=False, inverse=\"sparsecholesky\")\n\n        anew.vec.data = unew.vec-uold.vec-tau*vel.vec-tau**2/4*aold.vec\n        anew.vec.data *= 4/tau**2\n        vel.vec.data += 0.5*tau*aold.vec\n        vel.vec.data += 0.5*tau*anew.vec\n\n        scene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Mesh Generation and Visualization with Netgen and NGSolve\nDESCRIPTION: This snippet generates a simple square mesh using Netgen's OCC module and visualizes it using NGSolve's Draw function. It initializes a geometry, creates a mesh with a specified maximum element size (maxh=0.1), and then renders the mesh in the web GUI.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#imports, geometry and mesh:\nfrom netgen.occ import *\nfrom netgen.webgui import Draw as DrawGeo\ngeo = OCCGeometry(unit_square_shape.Scale((0,0,0),2).Move((-1,-1,0)), dim=2)\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nmesh = Mesh(geo.GenerateMesh(maxh=0.1))\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Obtaining Free Degrees of Freedom - Python\nDESCRIPTION: This snippet shows how to obtain the BitArray representing the free (unconstrained) degrees of freedom from a finite element space (FESpace). This BitArray is useful for identifying which degrees of freedom are not constrained by Dirichlet boundary conditions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_dirichlet.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfreedofs = V.FreeDofs()\nprint (freedofs)\n```\n\n----------------------------------------\n\nTITLE: Define Geometry and Mesh\nDESCRIPTION: This code defines the geometry of the problem, including the air domain and the magnet. It uses the OCCGeometry module from netgen to create a 3D model, defines boundary conditions, and generates a mesh suitable for finite element analysis. The mesh is curved to better represent the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwell.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# box = OrthoBrick(Pnt(-3,-3,-3),Pnt(3,3,3)).bc(\"outer\")\n# magnet = Cylinder(Pnt(-1,0,0),Pnt(1,0,0), 0.3) * OrthoBrick(Pnt(-1,-3,-3),Pnt(1,3,3))\n# air = box - magnet\nbox = Box( (-3,-3,-3), (3,3,3))\nbox.faces.name = \"outer\"\n\nmagnet = Cylinder((-1,0,0),X, r=0.3, h=2)\nmagnet.mat(\"magnet\")\nmagnet.faces.col = (1,0,0)\n\nair = box-magnet\nair.mat(\"air\")\nshape = Glue([air,magnet])\ngeo = OCCGeometry(shape)\n\nDraw (shape, clipping={ \"z\" : -1, \"function\":True})\n                       \nmesh = Mesh(geo.GenerateMesh(maxh=2, curvaturesafety=1))\nmesh.Curve(3);\n```\n\n----------------------------------------\n\nTITLE: Applying Essential Boundary Conditions\nDESCRIPTION: This snippet applies the essential boundary condition for the flux component using `gfsigma.Set(g*normal, BND)`.  The Neumann boundary condition `g` is multiplied by the normal vector and applied to the `gfsigma` GridFunction on the boundary. BND flag indicates that this is a boundary condition.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngfsigma.Set(g*normal, BND)\n```\n\n----------------------------------------\n\nTITLE: Drawing Velocity Field\nDESCRIPTION: This snippet visualizes the computed velocity field using the `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Define Diffusion Bilinear Form with Interior Penalty in NGSolve\nDESCRIPTION: This snippet defines the diffusion part of the bilinear form for the discontinuous Galerkin method, including the interior penalty terms to enforce weak continuity across element boundaries. It uses `dx(skeleton=True)` and `ds(skeleton=True)` to integrate over internal and boundary faces, respectively. `alpha` is a penalty parameter and `h` is the mesh size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nalpha = 4\nh = specialcf.mesh_size\ndiffusion = grad(u)*grad(v) * dx \\\n    +alpha*order**2/h*jump_u*jump_v * dx(skeleton=True) \\\n    +(-mean_dudn*jump_v-mean_dvdn*jump_u) * dx(skeleton=True) \\\n    +alpha*order**2/h*u*v * ds(skeleton=True) \\\n    +(-n*grad(u)*v-n*grad(v)*u)* ds(skeleton=True)\n\na = BilinearForm(diffusion).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Define Poisson Solver with Preconditioner\nDESCRIPTION: This function `SolveProblem` solves the Poisson equation using finite elements in NGSolve. It takes parameters for mesh size, polynomial order, refinement levels, static condensation, and the type of preconditioner. It returns the number of degrees of freedom and the number of iterations required for convergence.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef SolveProblem(h=0.5, p=1, levels=1, \n                 condense=False,\n                 precond=\"local\"):\n    \"\"\"\n    Solve Poisson problem on l refinement levels.\n    PARAMETERS:\n        h: coarse mesh size\n        p: polynomial degree \n        l: number of refinement levels\n        condense: if true, perform static condensations\n        precond: name of a built-in preconditioner\n    Returns: (ndof, niterations)\n        List of tuples of number of degrees of freedom and iterations\n    \"\"\"\n    mesh = Mesh(unit_square.GenerateMesh(maxh=h))\n    # mesh = Mesh(unit_cube.GenerateMesh(maxh=h))\n    fes = H1(mesh, order=p, dirichlet=\"bottom|left\")\n    \n    u, v = fes.TnT() \n    a = BilinearForm(grad(u)*grad(v)*dx, condense=condense)\n    f = LinearForm(v*dx)\n    gfu = GridFunction(fes)\n    Draw(gfu)\n    c = Preconditioner(a, precond) # Register c to a BEFORE assembly\n\n    steps = []\n    \n    for l in range(levels):\n        if l > 0: \n            mesh.Refine()\n        fes.Update()\n        gfu.Update()\n\n        with TaskManager():\n            a.Assemble()\n            f.Assemble()\n\n            # Conjugate gradient solver\n            inv = CGSolver(a.mat, c.mat, maxsteps=1000)\n\n            # Solve steps depend on condense \n            if condense:\n                f.vec.data += a.harmonic_extension_trans * f.vec\n            \n            gfu.vec.data = inv * f.vec\n            \n            if condense:\n                gfu.vec.data += a.harmonic_extension * gfu.vec\n                gfu.vec.data += a.inner_solve * f.vec\n        steps.append ( (fes.ndof, inv.GetSteps()) )\n        if fes.ndof < 15000:\n            Redraw()\n    return steps\n```\n\n----------------------------------------\n\nTITLE: Bilinear Form for Stationary Navier-Stokes\nDESCRIPTION: This code defines the bilinear form for the stationary Navier-Stokes equations. It uses Taylor-Hood discretization with VectorH1 for velocity, H1 for pressure, and NumberSpace for pressure constraint. Includes the viscous term, convection term, and pressure terms.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh (geom.GenerateMesh(maxh=0.05)); nu = Parameter(1)\nV = VectorH1(mesh,order=3,dirichlet=\"bottom|right|top|left\")\nQ = H1(mesh,order=2); \nN = NumberSpace(mesh); \nX = V*Q*N\n(u,p,lam), (v,q,mu) = X.TnT()\na = BilinearForm(X)\na += (nu*InnerProduct(grad(u),grad(v))+InnerProduct(grad(u)*u,v)\n      -div(u)*q-div(v)*p-lam*q-mu*p)*dx\n```\n\n----------------------------------------\n\nTITLE: Setting up the problem\nDESCRIPTION: This function sets up the finite element problem, including mesh generation, finite element space definition (H1), bilinear form definition, linear form definition, and the creation of a GridFunction. It returns the mesh, finite element space, bilinear form, linear form, and grid function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef Setup(h=0.1, p=3):\n    mesh = Mesh(unit_square.GenerateMesh(maxh=h))\n    fes = H1(mesh, order=p, dirichlet=\"left|bottom\")\n    u, v = fes.TnT()\n    a = BilinearForm(grad(u)*grad(v)*dx + u*v*dx)\n    f = LinearForm(v*dx)\n    gfu = GridFunction(fes)\n    return mesh, fes, a, f, gfu\n```\n\n----------------------------------------\n\nTITLE: Implement Time-Stepping Loop\nDESCRIPTION: This snippet implements the time-stepping loop using an implicit/explicit Euler splitting method. It calculates the residual, updates the GridFunction, and visualizes the solution at specified time intervals.  It also stores time snapshots in a multidimensional grid function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nt = 0; i = 0\ntend = 10\ngfut = GridFunction(V, multidim=0)\nvel = gfu.components[0]\n\nscene = Draw (gfu.components[0], mesh, min=0, max=2, autoscale=False)\ntw = widgets.Text(value='t = 0')\ndisplay(tw)\n\nwith TaskManager():\n    while t < tend:\n        res = conv.Apply(gfu.vec) + a.mat*gfu.vec\n        gfu.vec.data -= tau * inv * res    \n\n        t = t + tau; i = i + 1\n        if i%10 == 0: scene.Redraw()\n        if i%50 == 0: gfut.AddMultiDimComponent(vel.vec)\n        if i%100 == 0: tw.value = \"t = \" + str(t)\n    tw.value = \"t = \"+str(tend)\n```\n\n----------------------------------------\n\nTITLE: Define Bilinear Form with Variation\nDESCRIPTION: Defines a bilinear form using the `Variation` integrator to represent the energy functional. The functional includes terms for the gradient, quartic term, and linear term.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm (V, symmetric=True)\na += Variation ( (0.5*grad(u)*grad(u) + 1/12*u**4-10*u) * dx)\n```\n\n----------------------------------------\n\nTITLE: Assembling Forms for Mixed Problem\nDESCRIPTION: This code defines and assembles the bilinear and linear forms for the mixed formulation. The forms include terms for the flux, divergence, and boundary conditions. `Trace` operator projects to normal direction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nam = BilinearForm((1/lam*sigma*tau + div(sigma)*v + div(tau)*u)*dx).Assemble()\nfm = LinearForm(-source*v*dx + ud*(tau.Trace()*normal)*ds).Assemble()\n\ngfm = GridFunction(fesm)\n```\n\n----------------------------------------\n\nTITLE: Assemble HDG Bilinear Form in NGSolve\nDESCRIPTION: This snippet assembles the bilinear form for the HDG method. It includes terms for diffusion, penalty, and boundary fluxes.  The `condense` flag enables static condensation. `dS` integrates over the element boundaries, and `n` is the normal vector. The convection term is also included.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nalpha = 4\ncondense = True\nh = specialcf.mesh_size\nn = specialcf.normal(mesh.dim)\n\na = BilinearForm(fes, condense=condense)\ndS = dx(element_boundary=True)\na += grad(u)*grad(v)*dx + \\\n    alpha*order**2/h*jump_u*jump_v*dS + \\\n    (-grad(u)*n*jump_v - grad(v)*n*jump_u)*dS\n\nb = CF( (20,1) )\nuup = IfPos(b*n, u, uhat)\na += -b * u * grad(v)*dx + b*n*uup*jump_v *dS\na.Assemble()\n\nf = LinearForm(1*v*dx).Assemble()\n\ngfu = GridFunction(fes)\n\nprint (\"A non-zero elements:\", a.mat.nze)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This code snippet imports the required modules from netgen, ngsolve, and python's math library. These modules are essential for geometry creation, finite element analysis, visualization, and mathematical operations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.webgui import Draw as DrawGeo\nimport math\n```\n\n----------------------------------------\n\nTITLE: Setting Boundary Conditions for Navier-Stokes\nDESCRIPTION: This code sets the boundary conditions for the Navier-Stokes equations, specifically defining a tangential velocity on the top boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(X)\ngfu.components[0].Set(CF((4*x*(1-x),0)),\n                      definedon=mesh.Boundaries(\"top\"))\n```\n\n----------------------------------------\n\nTITLE: Define Convective Term\nDESCRIPTION: This snippet defines the non-linear convective term using a BilinearForm. The `nonassemble=True` flag indicates that this form will be assembled dynamically within the time loop.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nconv = BilinearForm(X, nonassemble=True)\nconv += (Grad(u) * u) * v * dx\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System with PETSc Solver\nDESCRIPTION: This code solves a linear system using the PETSc Krylov solver. It transfers the NGSolve vector `f.vec` to the PETSc vector `psc_f` using the `N2P` method of the `vecmap` object.  It then calls the `solve` method of the KSP object to solve the linear system `psc_mat * psc_u = psc_f`. Finally, it transfers the solution from the PETSc vector `psc_u` back to the NGSolve vector `gfu.vec` using the `P2N` method.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n%%px\nvecmap.N2P(f.vec, psc_f)\nksp.solve(psc_f, psc_u)   \nvecmap.P2N(psc_u, gfu.vec);\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces - Python\nDESCRIPTION: This snippet defines the Raviart-Thomas (RT) and L2 finite element spaces. HDiv is used for the flux and L2 for the scalar variable. These spaces are restricted to the active mesh (elements with negative level set values).  `dgjumps=True` is set when ghost penalty stabilization is used, increasing the number of couplings on cut elements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n#FESpaces\nShsbase = HDiv(mesh, order=order, dirichlet=[], dgjumps=(gamma_stab > 0), RT=True)\nVhbase = L2(mesh, order=order, dirichlet=[])\nVh = Restrict(Vhbase, hasneg)\nShs = Restrict(Shsbase, hasneg)\nWh = Shs*Vh\n```\n\n----------------------------------------\n\nTITLE: Geometry-Free Bilinear Form Assembly (Python)\nDESCRIPTION: This snippet demonstrates how to assemble a bilinear form with the geom_free flag set to True. This allows for geometry-free matrix multiplication, which can improve performance and reduce memory requirements.  The SetHeapSize function increases the heap size to accommodate larger problems. The dirichlet=[2] argument specifies boundary condition flags. The `tp=True` argument enables tensor-product finite elements within VectorL2 space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\norder=6\nSetHeapSize(100*1000*1000)\nSigma = VectorL2(mesh, order=order, piola=True, tp=True)\nVt = L2(mesh, order=order-1)\nVf = FacetFESpace(mesh, order=order, dirichlet=[2])\nV = Vt*Vf\nprint (\"Sigma.ndof =\", Sigma.ndof, \", V.ndof =\", V.ndof)\nsigma,tau = Sigma.TnT()\n(ut,uf), (vt,vf) = V.TnT()\n\nb = BilinearForm(trialspace=Sigma, testspace=V, geom_free=True)\nb += div(sigma) * vt * dx\nn = specialcf.normal(mesh.dim)\ndS = dx(element_boundary=True)\nb += -sigma*n*vf * dS\nb.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Identifying Cut Elements - Python\nDESCRIPTION: This code determines elements based on their intersection with the level set. `CutInfo` provides information on whether elements are fully inside (NEG), fully outside (POS), or cut by the level set (IF).  `GetElementsOfType` returns a BitArray indicating the element types.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nci = CutInfo(mesh, lsetp1)\nhasneg = ci.GetElementsOfType(HASNEG) # elements with negative level set (root elements)\npos = ci.GetElementsOfType(POS)       # outside elements\nhasif = ci.GetElementsOfType(IF)      # cut elements\nhasany = ci.GetElementsOfType(ANY)    # all elements (trivial array)\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh and Creating Curved Elements\nDESCRIPTION: Generates a finite element mesh from the OCC geometry using `OCCGeometry(geo).GenerateMesh(maxh=0.1)`. The mesh is then curved to a higher order using `.Curve(3)`.  The resulting mesh is visualized using NGSolve's `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nmesh = Mesh(OCCGeometry(geo).GenerateMesh(maxh=0.1)).Curve(3)\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Setting up Finite Element Space and Forms\nDESCRIPTION: This code defines the finite element space, bilinear form, and linear form for solving the heat conduction equation. It creates an H1 space with Dirichlet boundary conditions, defines the heat conductivity coefficient for each subdomain, and sets up the heat source in the chip subdomain.  A preconditioner is also created to improve solver performance.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=3, dirichlet=[1])\nu, v = fes.TnT()\n\n# one heat conductivity coefficient per sub-domain\nlam = CoefficientFunction([1, 1000, 10])\na = BilinearForm(lam*grad(u)*grad(v)*dx)\n\n# heat-source in inner subdomain\nf = LinearForm(fes)\nf = LinearForm(1*v*dx(definedon=\"chip\"))\n\nc = Preconditioner(a, type=\"multigrid\", inverse=\"sparsecholesky\")\n\ngfu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Solve Linear System in NGSolve and Visualize Solution\nDESCRIPTION: This snippet solves the linear system to obtain the solution and visualizes it using `Draw`. `a.mat.Inverse(freedofs=fes.FreeDofs())` computes the inverse of the assembled matrix, considering only the free degrees of freedom.  The result is assigned to the coefficient vector of the `gfu` GridFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ngfu.vec.data = \\\n    a.mat.Inverse(freedofs=fes.FreeDofs()) * f.vec\nDraw(gfu);\n```\n\n----------------------------------------\n\nTITLE: Define Neo-Hookean Energy Functional\nDESCRIPTION: Defines functions `Pow` and `NeoHook` to calculate the Neo-Hookean energy functional.  The bilinear form `a` is defined using `Variation` and incorporates the Neo-Hookian energy term and the gravity force. The `Compile()` method is called on these expressions, likely for optimization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef Pow(a, b):\n    return exp (log(a)*b)\n    \ndef NeoHook (C):\n    return 0.5 * mu * (Trace(C-I) + 2*mu/lam * Pow(Det(C), -lam/2/mu) - 1)\n\nI = Id(mesh.dim)\nF = I + Grad(u)\nC = F.trans * F\n\nfactor = Parameter(1.0)\n\na = BilinearForm(V, symmetric=True)\na += Variation(  NeoHook (C).Compile() * dx \n                -factor * (InnerProduct(force,u) ).Compile() * dx)\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form for HHJ Method\nDESCRIPTION: This code defines the bilinear form for the HHJ method. It includes terms for the inner product of bending moments, the divergence of bending moments multiplied by the gradient of displacement, and boundary terms involving the tangential component of the gradient of the test and trial functions and the normal stress. A small stabilization term is added to ensure coercivity.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.9-fourthorder/fourthorder.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nn = specialcf.normal(2)\n\ndef tang(u): return u-(u*n)*n\n\na = BilinearForm(X, symmetric=True)\na += (InnerProduct (sigma, tau) + div(sigma)*grad(v) \\\n      + div(tau)*grad(w) - 1e-10*w*v )*dx \\\n      + (-(sigma*n) * tang(grad(v)) - (tau*n)*tang(grad(w)))*dx(element_boundary=True)\na.Assemble()\n\nf = LinearForm(-1 * v * dx).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Simple Newton Solver Implementation\nDESCRIPTION: This code implements a simple Newton solver to solve the nonlinear equation. It iteratively computes the residual and its linearization, solves for the update, and updates the solution until convergence. Includes a callback function for storing intermediate solutions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef SimpleNewtonSolve(gfu,a,tol=1e-13,maxits=10, callback=lambda gfu: None):\n    res = gfu.vec.CreateVector()\n    du = gfu.vec.CreateVector()\n    fes = gfu.space\n    callback(gfu)\n    for it in range(maxits):\n        print (\"Iteration {:3}  \".format(it),end=\"\")\n        a.Apply(gfu.vec, res)\n        a.AssembleLinearization(gfu.vec)\n        du.data = a.mat.Inverse(fes.FreeDofs()) * res\n        gfu.vec.data -= du\n        callback(gfu)\n        #stopping criteria\n        stopcritval = sqrt(abs(InnerProduct(du,res)))\n        print (\"<A u\",it,\", A u\",it,\">_{-1}^0.5 = \", stopcritval)\n        if stopcritval < tol:\n            break\n```\n\n----------------------------------------\n\nTITLE: Calculate L2 Error in Python\nDESCRIPTION: This snippet calculates the L2 error between the computed solution `gfu` and the exact solution `exact`.  The error is computed by integrating the square of the difference between the two solutions over the mesh and taking the square root. The result is then printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/poisson.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nexact = 16*x*(1-x)*y*(1-y)\nprint (\"L2-error:\", sqrt (Integrate ( (gfu-exact)*(gfu-exact), mesh)))\n```\n\n----------------------------------------\n\nTITLE: Overwriting Cartesian Coordinates - Python\nDESCRIPTION: Illustrates the common mistake of overwriting predefined Cartesian coordinates (x, y, z) by using them as loop variables or in other contexts, which can lead to errors in NGSolve operations like integration. It showcases how using 'x' as a loop variable overrides the predefined coordinate 'x'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pitfalls/pitfalls.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfor x in np.linspace(1,5,10):\n   l.append (x)\n...\nIntegrate (x*y, mesh)\n```\n\n----------------------------------------\n\nTITLE: Solving and Drawing the Solution\nDESCRIPTION: This snippet calls the `SolveBVP` function to solve the boundary value problem, and then uses the `Draw` function from the `ngsolve.webgui` module to visualize the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nSolveBVP()\nDraw(gfu);\n```\n\n----------------------------------------\n\nTITLE: Initializing Geometry and Mesh - Python\nDESCRIPTION: This code snippet imports necessary libraries, defines the geometry as a unit square, and generates a mesh using Netgen. The edges of the rectangle are named for boundary condition specification.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# import libraries, define geometry and generate mesh\nfrom ngsolve import *\nfrom ngsolve.webgui import *\nfrom netgen.occ import *\nshape = Rectangle(1,1).Face()\nshape.edges.Min(X).name=\"left\"\nshape.edges.Max(X).name=\"right\"\nshape.edges.Min(Y).name=\"bottom\"\nshape.edges.Max(Y).name=\"top\"\ngeom = OCCGeometry(shape, dim=2)\nmesh = Mesh(geom.GenerateMesh(maxh=0.1))\n```\n\n----------------------------------------\n\nTITLE: Define Box and Cylinder - Python\nDESCRIPTION: This snippet defines a box and a cylinder using the OCCT geometry kernel. The box is defined by two points representing the minimum and maximum coordinates, while the cylinder is defined by a point on the axis, a direction vector, radius, and height.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nbox = Box(Pnt(0,0,0), Pnt(1,1,1))\ncyl = Cylinder(Pnt(1,0.5,0.5), X, r=0.3, h=0.5)\n```\n\n----------------------------------------\n\nTITLE: Defining Channel Geometry and Mesh\nDESCRIPTION: This snippet defines the channel geometry using the netgen.occ module and then meshes it using NGSolve. The shape is created as a rectangle with a circle removed, and boundary names are assigned to different edges. The mesh is then curved and visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\n\nshape = Rectangle(2,0.41).Circle(0.2,0.2,0.05).Reverse().Face()\nshape.edges.name=\"wall\"\nshape.edges.Min(X).name=\"inlet\"\nshape.edges.Max(X).name=\"outlet\"\nDraw (shape);\n```\n\n----------------------------------------\n\nTITLE: Calculating Error (Automated)\nDESCRIPTION: This function automates the error calculation process. It computes the flux, the error estimator, and appends the estimated total error to a list. It also marks elements for refinement based on a threshold relative to the maximum error, using a vectorized NumPy operation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nl = []    # l = list of estimated total error\n\ndef CalcError():\n\n    # compute the flux:\n    space_flux.Update()      \n    gf_flux.Update()\n    flux = lam * grad(gfu)        \n    gf_flux.Set(flux) \n    \n    # compute estimator:\n    err = 1/lam*(flux-gf_flux)*(flux-gf_flux)\n    eta2 = Integrate(err, mesh, VOL, element_wise=True)\n    maxerr = max(eta2)\n    l.append ((fes.ndof, sqrt(sum(eta2))))\n    print(\"ndof =\", fes.ndof, \" maxerr =\", maxerr)\n    \n    # mark for refinement (vectorized alternative)\n    mesh.ngmesh.Elements2D().NumPy()[\"refine\"] = eta2.NumPy() > 0.25*maxerr\n```\n\n----------------------------------------\n\nTITLE: Creating Geometry with Netgen OCC\nDESCRIPTION: Defines the geometry of the problem using Netgen OCC.  It creates a box and three cylinders, subtracts the cylinders from the box to form the domain, and visualizes the geometry. The `DrawGeo` function is used to display the created geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbox = Box((0,0,0), (3,0.6,1))\nbox.faces.name=\"outer\"\ncyl = sum( [Cylinder((0.5+i,0,0.5), Y, 0.25,0.8) for i in range(3)] )\ncyl.faces.name=\"cyl\"\ngeo = box-cyl\n\nDrawGeo(geo);\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form - Python\nDESCRIPTION: This code defines the bilinear form for the mixed finite element method.  If ghost penalty is used (`gamma_stab > 0`), then `RestrictedBilinearForm` with facet restriction is employed (using the EA patches).  Otherwise, a standard `BilinearForm` is created. Using `RestrictedBilinearForm` allows for a smaller sparsity pattern. The bilinear form is marked symmetric.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nif gamma_stab > 0:\n    a = RestrictedBilinearForm(Wh, element_restriction=hasneg, \n                               facet_restriction=EA.patch_interior_facets, symmetric=True)\nelse:\n    a = BilinearForm(Wh, symmetric=True,condense=False)\nf = LinearForm(Wh)\n```\n\n----------------------------------------\n\nTITLE: Defining Grid Functions and Trial/Test Functions - Python\nDESCRIPTION: This code defines the grid functions for the mixed finite element solution (flux and pressure), as well as trial and test functions for the variational formulation. Additionally, it sets up coefficient functions for mesh size (h) and the normal vector (n) to the level set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngfw = GridFunction(Wh)\ngfu, gfpT = gfw.components[0:2]\n(uh,pT), (vh,qT) = Wh.TnT()\n\nh = specialcf.mesh_size     # mesh size\nn = Normalize(grad(lsetp1)) # normal to level set\n```\n\n----------------------------------------\n\nTITLE: Generate Mesh and Refine\nDESCRIPTION: This snippet generates a mesh from the previously defined Fichera geometry using Netgen's OCCGeometry. It then refines the mesh using hierarchical p-refinement. The resulting mesh is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwellevp.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(OCCGeometry(fichera).GenerateMesh(maxh=0.4))\nmesh.RefineHP(levels=2, factor=0.2)\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear and Linear Forms - Python\nDESCRIPTION: This snippet defines the bilinear and linear forms that constitute the weak formulation of the heat equation.  The bilinear form `a` includes terms for the time derivative, spatial gradient, and a term from the discontinuous Galerkin time-stepping.  The linear form `f` includes terms from the right-hand side and the initial condition.  The forms are assembled, and the inverse of the bilinear form matrix is computed for solving the system.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(st_fes, symmetric=False)\na += (dt(u) * v + grad(u) * grad(v)) * dxt\na += u * v * dxold\na.Assemble()\nainv = a.mat.Inverse(st_fes.FreeDofs())\n\nf = LinearForm(st_fes)\nf += coeff_f * v * dxt\nf += u_last * v * dxold\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces in NGSolve\nDESCRIPTION: This snippet defines finite element spaces for the pressure (p) and velocity (u) fields using NGSolve's L2 and VectorL2 classes. It specifies the order of the spaces and sets the `all_dofs_together` and `piola` flags.  A `GridFunction` is created to store the solution on the composite finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\norder = 6\nfes_p = L2(mesh, order=order+1, all_dofs_together=True)\nfes_u = VectorL2(mesh, order=order, piola=True, all_dofs_together=True)\nfes = fes_p*fes_u\ngfu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Computing Condition Number of a Matrix with NumPy\nDESCRIPTION: This snippet computes the condition number of a matrix using NumPy's `linalg.cond()` function. It first converts the sparse matrix 'A' to a dense matrix using `A.todense()` before computing the condition number.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_numpy.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nnp.linalg.cond(A.todense())\n```\n\n----------------------------------------\n\nTITLE: Solving Stabilized Stokes with MinRes\nDESCRIPTION: This snippet solves the stabilized Stokes equation as a block system using the MinRes iterative solver. It uses a stabilization term `c` derived from the mesh size `h`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nmp = BilinearForm(p*q*dx).Assemble()\n\nf = LinearForm(V)\nf.Assemble()\n\ng = LinearForm(Q)\ng.Assemble()\n\ngfu = GridFunction(V, name=\"u\")\ngfp = GridFunction(Q, name=\"p\")\nuin = CF( (1.5*4*y*(0.41-y)/(0.41*0.41), 0) )\ngfu.Set(uin, definedon=mesh.Boundaries(\"inlet\"))\n\nK = BlockMatrix( [ [a.mat, b.mat.T], [b.mat, c.mat] ] )\nC = BlockMatrix( [ [a.mat.Inverse(V.FreeDofs()), None], [None, mp.mat.Inverse()] ] )\n\nrhs = BlockVector ( [f.vec, g.vec] )\nsol = BlockVector( [gfu.vec, gfp.vec] )\n\nsolvers.MinRes (mat=K, pre=C, rhs=rhs, sol=sol, printrates=True, initialize=False, maxsteps=200);\n```\n\n----------------------------------------\n\nTITLE: Applying Time Stepping Function in Python\nDESCRIPTION: This code snippet demonstrates the application of the `TimeStepping_app4` function with the sdirk5 method.  It initializes the time-stepping with a specific mass matrix (`m`), stiffness matrix (`a`), a SDIRK5 Butcher tableau, a time step (`dt`), initial condition (`initial_cond`), and end time (`tend`). The results are visualized using the Draw function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.1-parabolic/parabolic.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfut_a4 = TimeStepping_app4(m, a, butchertab = sdirk5(), \n                            dt = 0.25, initial_cond=CF(0),tend=10)\nDraw(gfut_a4, mesh, interpolate_multidim=True, animate=True, \n     order = 3, \n     deformation = True, min = 0, max = 0.2, autoscale = False)\n```\n\n----------------------------------------\n\nTITLE: Solving the Boundary Value Problem\nDESCRIPTION: This function solves the boundary value problem by assembling the bilinear and linear forms, and then solving the resulting linear system using a conjugate gradient solver with the specified preconditioner.  The solution is stored in the grid function `gfu`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef SolveBVP():\n    fes.Update()\n    gfu.Update()\n    a.Assemble()\n    f.Assemble()\n    inv = CGSolver(a.mat, c.mat)\n    gfu.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Accessing Free Degrees of Freedom - Python\nDESCRIPTION: This code snippet demonstrates how to access the free degrees of freedom (dofs) of a finite element space in NGSolve using the `FreeDofs` method. It prints the free dofs of a space without Dirichlet boundary conditions and a space with Dirichlet boundary conditions on the 'left' and 'right' boundaries, showing the difference in the free dofs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprint(\"free dofs of fs2 without \\\"dirichlet\\\" flag:\\n\",\n      fs2.FreeDofs())\nprint(\"free dofs of fes:\\n\", fes.FreeDofs())\n```\n\n----------------------------------------\n\nTITLE: Flux Function Definition - Python\nDESCRIPTION: This snippet defines the flux function F(U) for the shallow water equations. It takes a vector U = (h, hvx, hvy) as input, where h is the water height, and hvx and hvy are the momentum components. It calculates the velocity components vx and vy and returns the flux vector, which includes the mass flux and momentum flux components. The `dims=(3,2)` specifies that the flux is a vector with 3 components in 2 dimensions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef F(U):\n    h, hvx, hvy = U\n    vx = hvx/h\n    vy = hvy/h\n    return CF(((hvx,hvy),\n               (hvx*vx + 0.5*g*h**2, hvx*vy),\n               (hvx*vy, hvy*vy + 0.5*g*h**2)),dims=(3,2))\n```\n\n----------------------------------------\n\nTITLE: Creating Device Matrix for BDDC Preconditioner (Info)\nDESCRIPTION: This snippet focuses on creating a device matrix for the BDDC preconditioner and prints its operator information.  This is used to inspect the properties of the preconditioner on the CUDA device.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npredev = pre.mat.CreateDeviceMatrix()\nprint (predev.GetOperatorInfo())\n```\n\n----------------------------------------\n\nTITLE: Displaying the built-in x CoefficientFunction\nDESCRIPTION: This snippet demonstrates how to access and use the built-in x CoefficientFunction within NGSolve.  It shows that 'x' is readily available for defining other functions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx        # This is a built-in CoefficientFunction\n```\n\n----------------------------------------\n\nTITLE: Drilling a Hole Through a Cube using OrthoBrick and Cylinder in Netgen CSG (Python)\nDESCRIPTION: This code defines a cube using OrthoBrick and a cylinder to represent a hole. It then subtracts the cylinder from the cube to create a hole, adds the resulting solid to a CSGeometry object, generates a mesh, and saves the mesh to a file. It demonstrates the use of OrthoBrick, Cylinder primitives, and boolean subtraction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_3d_geometries.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\n\ncube = OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) )\nhole = Cylinder ( Pnt(0.5, 0.5, 0), Pnt(0.5, 0.5, 1), 0.2)\n   \ngeo = CSGeometry()\ngeo.Add (cube-hole)\nmesh = geo.GenerateMesh(maxh=0.1)\nmesh.Save(\"cube_hole.vol\")\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve and Netgen modules in Python\nDESCRIPTION: This snippet imports the necessary modules from NGSolve and Netgen. The `ngsolve` module provides the core functionality for finite element analysis, while `netgen.geom2d` is used for geometry definition. `netgen.gui` is used to enable GUI, and `%gui tk` sets up the GUI environment within the notebook.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/poisson.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.geom2d import unit_square\nimport netgen.gui\n%gui tk\n```\n\n----------------------------------------\n\nTITLE: Assemble bilinear form with enrichment\nDESCRIPTION: Assembles a bilinear form that includes diffusion terms on the inner and outer domains, and uses the enrichment space to model the interface resistivity at the right edge.  The solution is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfes = fes1 * fesext\n(u,uext), (v,vext) = fes.TnT()\n\na = BilinearForm(fes)\na += grad(u)*grad(v)*dx(\"inner\")\na += (grad(u)+grad(uext))* (grad(v)+grad(vext))*dx(\"outer\")\na += 3 * uext*vext * ds(\"interface_right\")\na.Assemble()\n\nf = LinearForm(1*v*dx(\"inner\")).Assemble()\n\ngfu = GridFunction(fes)\ngfu.vec.data = a.mat.Inverse(freedofs=fes.FreeDofs()) * f.vec\n\nsol = mesh.MaterialCF({\"inner\":gfu.components[0], \"outer\":gfu.components[0]+gfu.components[1]})\nDraw (sol, mesh);\n```\n\n----------------------------------------\n\nTITLE: Plotting a CoefficientFunction using Matplotlib\nDESCRIPTION: This snippet plots the values of a CoefficientFunction along a line using Matplotlib. It generates a set of x-coordinates, keeps the y-coordinate constant, evaluates the function at these points using the mesh, and then plots the x-values against the function values.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nX = np.linspace(0, 1, num=100)\nY = np.ones_like(X) * 0.2\nplt.plot(X, myfunc(mesh(X, Y)))\nplt.xlabel('x')\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Solve Poisson Problem with Multigrid for Varying p\nDESCRIPTION: This code snippet iterates through polynomial orders from 1 to 9, solving the Poisson problem with the 'multigrid' preconditioner for each order. The results (number of degrees of freedom and number of iterations) are printed for each polynomial order.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfor p in range(1,10):\n    r = SolveProblem(h=0.5, p=p, levels=4, condense=False, \n                     precond=\"multigrid\")\n    print (\"p=\", p, \": ndof,nsteps=\", r)          \n```\n\n----------------------------------------\n\nTITLE: Setting Boundary Values for Grid Function - Python\nDESCRIPTION: This code snippet interpolates the boundary condition function `g` onto the boundary of the domain, specifically on the parts marked as 'dirichlet'. It creates a `GridFunction` called `gfu` and uses the `Set` method with the `BND` flag to indicate that the interpolation should only occur on the Dirichlet boundary.  The result is visualized using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\ngfu.Set(g, BND)\nDraw(gfu);\n```\n\n----------------------------------------\n\nTITLE: Solve Nonlinear Elasticity Problem (Load Stepping)\nDESCRIPTION: Solves the nonlinear elasticity problem using a load-stepping approach. The load (factor) is gradually increased, using the previous solution as an initial guess for the next load step. The intermediate solutions are stored for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(V)\ngfu.vec[:] = 0\ngfu_l = GridFunction(V,multidim=0)\ngfu_l.AddMultiDimComponent(gfu.vec)\nfor loadstep in range(50):\n    print (\"loadstep\", loadstep)\n    factor.Set ((loadstep+1)/10)\n    SolveNonlinearMinProblem(a,gfu)\n    if (loadstep + 1) % 10 == 0:\n        gfu_l.AddMultiDimComponent(gfu.vec)\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh and Finite Element Space in NGSolve (Python)\nDESCRIPTION: This code snippet initializes a mesh and defines a finite element space using NGSolve. It creates a mesh on the unit square and defines an H1 finite element space of order 4 with Dirichlet boundary conditions on the bottom and right edges.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.4))\n\nfes = H1(mesh, order=4, dirichlet='bottom|right')\nu, v = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System with TaskManager - Python\nDESCRIPTION: This snippet assembles the bilinear form `a` and linear form `f`, then solves the resulting linear system using a conjugate gradient solver (`CGSolver`).  The `TaskManager` is used to distribute the assembly process and the linear solve for improved performance. The solution is stored in the `u` grid function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/maxwell.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n    a.Assemble()\n    f.Assemble()\n    solver = CGSolver(mat=a.mat, pre=c.mat)\n    u.vec.data = solver * f.vec\n```\n\n----------------------------------------\n\nTITLE: Marking Elements for Refinement\nDESCRIPTION: This code snippet marks elements for refinement based on the computed error estimator.  If the error estimator on an element is greater than 25% of the maximum error, the element is marked for refinement. A vectorized alternative using NumPy is also shown.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmaxerr = max(eta2)\nprint (\"maxerr = \", maxerr)\n\nfor el in mesh.Elements():\n    mesh.SetRefinementFlag(el, eta2[el.nr] > 0.25*maxerr)\n    # see below for vectorized alternative\n```\n\n----------------------------------------\n\nTITLE: Mesh Adaptation with Level Set - Python\nDESCRIPTION: This code snippet adapts the mesh to the level set function for improved accuracy. It creates a `LevelSetMeshAdaptation` object and calculates the deformation of the mesh based on the level set.  The level set function is also projected onto a P1 finite element space, and the threshold controls the refinement near the interface.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nlsetmeshadap = LevelSetMeshAdaptation(mesh, order=order+1, threshold=0.1,discontinuous_qn=True)\ndeformation = lsetmeshadap.CalcDeformation(levelset)\nlsetp1 = lsetmeshadap.lset_p1\n```\n\n----------------------------------------\n\nTITLE: Naming Faces for Boundary Conditions\nDESCRIPTION: Assigns names to specific faces of the geometry for applying boundary conditions.  The minimum X face is named \"fix\" for Dirichlet boundary conditions, and the maximum X face is named \"force\" for Neumann boundary conditions. The geometry is visualized after naming the faces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngeo.faces.Min(X).name = \"fix\"\ngeo.faces.Max(X).name = \"force\"\n\nDrawGeo(geo);\n```\n\n----------------------------------------\n\nTITLE: Defining Convection and Boundary Values - Python\nDESCRIPTION: This code defines the advection velocity `b` as a `CoefficientFunction` dependent on the y-coordinate. It also defines the boundary condition `ubnd` on the inflow boundary using `IfPos` to create a localized cosine function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nb = CF((1+sin(4*pi*y),2))\nubnd = 0.1 * IfPos(x-0.125,IfPos(0.625-x,1+cos(8*pi*x),0),0)\n```\n\n----------------------------------------\n\nTITLE: Solve with Conjugate Gradient - Python\nDESCRIPTION: This snippet sets up a linear form, a grid function, and uses a conjugate gradient solver (`CGSolver`) to solve the linear system.  It demonstrates how to apply the previously defined preconditioner to improve the convergence of the iterative solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(1*v*dx).Assemble()\ngfu = GridFunction(fes)\nfrom ngsolve.krylovspace import CGSolver\ninv = CGSolver(mat=a.mat, pre=pre, printrates=True)\ngfu.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Generating Volume Mesh and Drawing\nDESCRIPTION: This code generates the volume mesh from the merged surface mesh and then visualizes the resulting mesh using NGSolve.  It calls `ngmesh.GenerateVolumeMesh()` to create the volume elements. The generated mesh is then converted into an NGSolve `Mesh` object, and the `Draw` function from `ngsolve.webgui` is used to display the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nngmesh.GenerateVolumeMesh()\nimport ngsolve\nmesh = ngsolve.Mesh(ngmesh)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Assembling and solving the deformation equation\nDESCRIPTION: This code assembles and solves the deformation equation and visualizes the resulting deformation field.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nb.Assemble()\ndJOmegaAuto.Assemble()\nSolveDeformationEquationAuto()\nDraw(-gfX, mesh, \"gfX\")\n```\n\n----------------------------------------\n\nTITLE: Time-Stepping Loop for Phase-Field Simulation in NGSolve\nDESCRIPTION: This code performs the time-stepping loop for the phase-field simulation. It updates the old solution, solves the nonlinear minimization problem using `SolveNonlinearMinProblem`, and adds the current solution to the multi-dimensional GridFunction for visualization. `dt` is a Parameter.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nt = 0; tend = 5; cnt = 0; sample_rate = int(floor(0.5/dt.Get()))\nwhile t < tend - 0.5 * dt.Get():\n    gfuold.vec.data = gfu.vec\n    SolveNonlinearMinProblem(a,gfu)\n    if (cnt+1) % sample_rate == 0:\n        gfu_t.AddMultiDimComponent(0.1*gfu.vec)\n    t += dt.Get(); cnt += 1\n    print(\"t = \", t)\n```\n\n----------------------------------------\n\nTITLE: Running the Time Stepping and Visualizing Results - Python\nDESCRIPTION: This snippet executes the time-stepping loop and visualizes the resulting data using the ngsolve webgui. The `gfu.Set(U0)` initializes the solution with the initial conditions. The call to `TimeLoop` starts the time integration, and the returned `gfu_t` holds the solution at different time steps. The `Draw` function then visualizes the solution's height component over time using animation and deformation, allowing for dynamic inspection of results.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ngfu.Set(U0)\nwith TaskManager():\n    gfu_t = TimeLoop(a,gfu,dt=0.0025,T=15,multidim_draw=True,md_nsamplings=5)\n\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu_t.components[0],mesh,\"h\",interpolate_multidim=True,animate=True, \n     deformation=True, settings = {\"camera\" : \n                                   {\"transformations\" : \n                                    [{ \"type\": \"rotateX\", \"angle\": -20},\n                                     { \"type\": \"rotateZ\", \"angle\": 0}]}},\n     min=2, max=5, autoscale=False)\n```\n\n----------------------------------------\n\nTITLE: Integrating over the level set domain - Python\nDESCRIPTION: This snippet defines an integrand (constant function 1) and integrates it over the negative part of the level set domain using the dCut differential symbol. The integration order is specified, and the result along with the error compared to pi is printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nf = CoefficientFunction(1)\norder = 2\nintegral = Integrate(f * dCut(levelset=lset_approx, domain_type=NEG, order=order), mesh=mesh)\nerror = abs(integral - pi)\nprint(\"Result of the integration: \", integral)\nprint(\"Error of the integration: \", error)\n```\n\n----------------------------------------\n\nTITLE: Generating 2D Mesh - Python\nDESCRIPTION: Highlights the importance of specifying the dimension when creating a 2D mesh using OCCGeometry in NGSolve. For 2D geometries, dim=2 must be set. It creates a rectangle, defines a face, and generates a 2D mesh with a specified maximum mesh size (maxh).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pitfalls/pitfalls.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nrect = Rectangle(3,5).Face()\nmesh = OCCGeometry(rect, dim=2).GenerateMesh(maxh=1)\n```\n\n----------------------------------------\n\nTITLE: Defining Exact Solution and Source Term - Python\nDESCRIPTION: This code defines the exact solution for the Poisson equation and computes the corresponding source term. The exact solution is set to sin(x), and the source term is calculated as the negative Laplacian of the exact solution.  The exact solution for u = grad(p) is also defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\np_exact = sin(x)\ncoeff_f = - (p_exact.Diff(x).Diff(x) + p_exact.Diff(y).Diff(y)).Compile()\nu_exact = CF((p_exact.Diff(x),p_exact.Diff(y)))\n```\n\n----------------------------------------\n\nTITLE: Defining Test and Trial Functions and Mesh Size (Python)\nDESCRIPTION: This snippet defines the test and trial functions for the variational formulation using the TnT() method of the space-time finite element space. It also defines a CoefficientFunction h representing the mesh size, which is used in the ghost penalty stabilization term.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nu,v = st_fes.TnT()\nh = specialcf.mesh_size\n```\n\n----------------------------------------\n\nTITLE: Solving the Linear System for Displacement\nDESCRIPTION: Solves the linear system using a conjugate gradient (CG) solver with the assembled bilinear form and preconditioner.  The displacement solution is stored in the `gfu` grid function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.krylovspace import CGSolver\ninv = CGSolver(a.mat, pre, printrates=True, tol=1e-8)\ngfu.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Define enriched finite element space\nDESCRIPTION: Defines an enriched H1 finite element space that is discontinuous only at the right edge of the interface.  It starts with a standard H1 space and enriches it with functions defined on the interface.  The degrees of freedom are restricted to the interior of the right interface edge.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfes1 = H1(mesh, order=3, dirichlet=\"dir\")\n\nfesext = H1(mesh, order=3, definedon=\"outer\")\nactdofs = fesext.GetDofs(mesh.Boundaries(\"interface_right\")) & \\\n    ~fesext.GetDofs(mesh.Boundaries(\"interface\"))\nfesext = Compress (fesext, active_dofs=actdofs)\nprint (actdofs)\n```\n\n----------------------------------------\n\nTITLE: Solve with NewtonMinimization (NGSolve Solver)\nDESCRIPTION: Uses the built-in `NewtonMinimization` solver from NGSolve to solve the problem.  The initial guess is set before calling the solver, and visualization is performed after.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.solvers import *\ngfu.Set((x*(1-x))**4*(y*(1-y))**4) # initial guess\nNewtonMinimization(a,gfu)\n#Draw(gfu,mesh,\"u\", deformation = True)\n```\n\n----------------------------------------\n\nTITLE: Solving linear system for vector potential\nDESCRIPTION: This code defines a conjugate gradient solver (CGSolver) and applies it to solve the linear system resulting from the magnetostatic problem. The result is the magnetic vector potential, stored in the GridFunction `gfu`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.krylovspace import CGSolver\ninv = CGSolver(a.mat, pre, printrates=True)\ngfu = GridFunction(fes)\nwith TaskManager():\n    gfu.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Time Loop with Optimized Projection\nDESCRIPTION: This time loop is similar to the previous one, but it uses the modified `Mult` method of the `PropagateConvection` class, which employs the `ConvertL2Operator` for projection. This version of the time loop should be more efficient due to the optimized projection method.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfor s in scenes : s.Draw()\n```\n\nLANGUAGE: python\nCODE:\n```\ntend += 1\nconvpropagator = PropagateConvection(tau,substeps)\nwhile t < tend:\n    gfu.vec.data += inv @ (convpropagator - mstar) * gfu.vec\n    t += tau\n    print (\"\\r  t =\", t, end=\"\")\n    for s in scenes : s.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Creating an Identity Preconditioner\nDESCRIPTION: Creates an identity preconditioner by projecting onto the space of free degrees of freedom. The `Projector` function is used with `fes.FreeDofs()` as the mask and `range=True` to define the projection.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npreI = Projector(mask=fes.FreeDofs(), range=True)\n```\n\n----------------------------------------\n\nTITLE: Solving and Visualizing Navier-Stokes\nDESCRIPTION: Defines a function `SolveAndVisualize` that solves and visualizes the Navier-Stokes. Demonstrates the usage of `SimpleNewtonSolve` and stores the iterations if the `multidim` flag is set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef SolveAndVisualize(multidim=True):\n    gfu.components[0].Set(CF((4*x*(1-x),0)),\n                      definedon=mesh.Boundaries(\"top\"))\n    if multidim:\n        gfu_it = GridFunction(gfu.space,multidim=0)\n        cb = lambda gfu : gfu_it.AddMultiDimComponent(gfu.vec) # store current state\n        SimpleNewtonSolve(gfu, a, callback = cb)\n    else:\n        SimpleNewtonSolve(gfu, a)\n    Draw(gfu.components[0],mesh, vectors = {\"grid_size\" : 25})\n    print(\"above you see the solution after the Newton solve.\")\n    if multidim:\n        Draw(gfu_it.components[0], mesh, vectors = {\"grid_size\" : 25})\n        print(\"above you can inspect the results after each iteration of the Newton solve (use multidim-slider).\")\n```\n\n----------------------------------------\n\nTITLE: Additive Multilevel Preconditioner (Short) - Python\nDESCRIPTION: This is a shorter implementation of the additive multilevel preconditioner using operator notation in NGSolve. It uses the prolongation operator and local smoother to define the preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef MLPreconditioner2(fes, level, mat, coarsepre):\n    prol = fes.Prolongation().Operator(level)     # get P \n    localpre = mat.CreateSmoother(fes.FreeDofs()) # get inv(D)\n    return localpre + prol @ coarsepre @ prol.T   # Return: inv(D) + P * C[l-1] * P.T * x\n```\n\n----------------------------------------\n\nTITLE: Defining the bilinear form for the deformation equation\nDESCRIPTION: This snippet defines the bilinear form 'b' for the deformation equation. This form involves the inner product of gradients and the inner product of the deformation field itself.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nb = BilinearForm(VEC)\nb += InnerProduct(grad(X),grad(PHI))*dx + InnerProduct(X,PHI)*dx\n\ngfX = GridFunction(VEC)\n```\n\n----------------------------------------\n\nTITLE: Define L2 Finite Element Space with DG Jumps in NGSolve\nDESCRIPTION: This snippet defines an L2 finite element space with a specified order and enables discontinuous jumps (dgjumps). It then creates trial and test functions (TnT) within this space, which are used for defining the variational form.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\norder=4\nfes = L2(mesh, order=order, dgjumps=True)\nu,v = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Matrix CoefficientFunction creation\nDESCRIPTION: This code snippet illustrates how to create a matrix-valued CoefficientFunction using the `dims` argument. It takes four scalar CoefficientFunctions (f11, f12, f21, f22) and arranges them into a 2x2 matrix. Requires pre-defined CoefficientFunctions `f11`, `f12`, `f21`, and `f22`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/coefficient.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmat_cf = CoefficientFunction((f11,f12,f21,f22),dims=(2,2))\n```\n\n----------------------------------------\n\nTITLE: Creating Mass Matrix Inverse in NGSolve\nDESCRIPTION: This snippet demonstrates two ways to compute (or approximate) the inverse of the mass matrix in NGSolve. The first uses the `.Mass()` method of the `FESpace` which creates a diagonal mass matrix operator. The second approach builds the mass matrix as a bilinear form, assembles it, and then inverts the resulting matrix using `.Inverse()`. The assembled version allows more general mass matrices.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/examples/matrixfree.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.ngscuda import *\n#ainv = Sigma.Mass(rho=1).Inverse()\nainv = BilinearForm(sigma*tau*dx, diagonal=True).Assemble().mat.Inverse()\n```\n\n----------------------------------------\n\nTITLE: Reduced Basis Experiment - Python\nDESCRIPTION: This snippet explores reduced basis methods to reduce computational cost. It loops through different frequencies, assembles the bilinear form, solves the eigenvalue problem, and appends the eigenvectors to the reduced basis. After looping, the reduced basis is orthogonalized, and the projected eigenvalue problem is solved using the reduced basis. A MultiVector `Qred` stores the reduced basis vectors. The frequency `omega` is varied and for each frequency, eigenvectors corresponding to eigenvalues with small absolute values are appended to `Qred`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# help (Q)\nQred = MultiVector(Q[0], 0)\n\nfor fs in np.linspace(0,0.8,5):\n    omega.Set(2*math.pi*fs)\n    print (\"fs =\", fs)\n    a.Assemble()\n    \n    inv = a.mat.Inverse(freedofs=fes.FreeDofs(), inverse=\"sparsecholesky\")\n    M1 = -inv@b.mat\n    M2 = -inv@c.mat\n    Q = SOAR(M1,M2, nr_eigs)    \n    lams, vecs = SolveProjected(a.mat, b.mat, c.mat, Q)\n    Z = (Q * vecs).Evaluate()\n    for vec in Z: vec /= Norm(vec)    \n\n    for lam, vec in zip(lams, Z):\n      if abs(lam) < 6:\n        if lam.imag > 1e-8:\n            hvr = vec.CreateVector()\n            hvi = vec.CreateVector()\n            for i in range(len(vec)):\n                hvr[i] = vec[i].real\n                hvi[i] = vec[i].imag\n            Qred.Append (hvr)\n            Qred.Append (hvi)\n        if abs(lam.imag) < 1e-8:\n            hvr = vec.CreateVector()\n            for i in range(len(vec)):\n                hvr[i] = vec[i].real\n            Qred.Append (hvr)            \n\nQred.Orthogonalize()\nlamsred, vecsred = SolveProjected(a.mat, b.mat, c.mat, Qred)\n\nprint (\"dim Qred=\", len(Qred))\n```\n\n----------------------------------------\n\nTITLE: Defining HDG Spaces\nDESCRIPTION: This snippet defines the finite element spaces for the HDG formulation. It creates an H(div) conforming space (V1), a tangential facet space (V2), and an L2 space (Q) for pressure. These spaces are combined into a single FESpace V.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nV1 = HDiv ( mesh, order = order, dirichlet = \"wall|cyl|inlet\" )\nV2 = TangentialFacetFESpace(mesh, order = order, dirichlet = \"wall|cyl|inlet\" )\nQ = L2( mesh, order = order-1)\nV = FESpace ([V1,V2,Q])\n\nu, uhat, p = V.TrialFunction()\nv, vhat, q = V.TestFunction()\n```\n\n----------------------------------------\n\nTITLE: BDDC with AMG Coarse Solver\nDESCRIPTION: This snippet demonstrates using AMG (Algebraic MultiGrid) as a coarse solver within the BDDC preconditioner. It sets up a finite element space, bilinear form, and linear form, then configures the BDDC preconditioner to use `h1amg` as the coarse solver with `wb_withedges=False`. Finally, it solves the system using a CG solver and visualizes the result.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\np = 5\nmesh = Mesh(unit_cube.GenerateMesh(maxh=0.05))\nfes = H1(mesh, order=p, dirichlet=\"left|bottom|back\",\n         wb_withedges=False)\nprint(\"NDOF = \", fes.ndof)\nu,v = fes.TnT()\na = BilinearForm(fes)\na += grad(u)*grad(v)*dx\nf = LinearForm(fes)\nf += v*dx\n\nwith TaskManager():\n    pre = Preconditioner(a, \"bddc\", coarsetype=\"h1amg\")        \n    a.Assemble()\n    f.Assemble()\n    \n    gfu = GridFunction(fes)\n    solvers.CG(mat=a.mat, rhs=f.vec, sol=gfu.vec,\n               pre=pre, maxsteps=500)\nDraw(gfu)\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation with BDDC Preconditioner\nDESCRIPTION: This snippet demonstrates solving the Poisson equation using the Balancing Domain Decomposition with Constraints (BDDC) preconditioner. It sets up the finite element space, assembles the bilinear and linear forms, creates the BDDC preconditioner, and solves the system using the CG solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.1))\nfor l in range(3): mesh.Refine()\nfes = H1(mesh, order=10, dirichlet=\".*\")\nprint (\"ndof =\", fes.ndof)\n\nu, v = fes.TnT()\nwith TaskManager():\n    a = BilinearForm(grad(u)*grad(v)*dx+u*v*dx)\n    pre = Preconditioner(a, \"bddc\")\n    a.Assemble()\n    f = LinearForm(x*v*dx).Assemble()\n\ngfu = GridFunction(fes)\nwith TaskManager(): \n    inv = CGSolver(a.mat, pre, maxsteps=2000, printrates=False)\n    ts = time()\n    gfu.vec.data = (inv * f.vec).Evaluate()\n    te = time()\n    print (\"iterations =\", inv.GetSteps(), \"time =\", te-ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Mesh Rotation function\nDESCRIPTION: This snippet defines a function `MeshRotation` that computes the deformation field corresponding to a rotation by a specified angle around the center of the domain. It uses a coordinate-wise rotation matrix and applies the deformation only to the 'inner' material, representing the rotating part of the mesh. It sets deformation for mesh.Materials(\"inner\").\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfesdef = VectorH1(mesh, order=3)\n\ndeformation = GridFunction(fesdef)\ndefold = GridFunction(fesdef)\n\ndef MeshRotation(angle, deform=None):\n    mesh.UnsetDeformation()\n    if not deform: deform = GridFunction(fesdef)\n    rotmat = CF( (cos(angle), -sin(angle), sin(angle), cos(angle))).Reshape( (2,2))\n    center = CF( (0.5, 0.5) )\n    pos = CF( (x,y) )\n\n    deform.Set( (rotmat-Id(2))*(pos-center), definedon=mesh.Materials(\"inner\"))\n    return deform\n```\n\n----------------------------------------\n\nTITLE: Solving potential problem for current density\nDESCRIPTION: This code solves a potential problem to determine the current density in the coil. It defines a finite element space, assembles a bilinear form and a linear form, and solves the resulting system to obtain the electric potential. This electric potential is used to find the current density.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfespot = H1(mesh, order=3, definedon=\"coil\", dirichlet=\"out\")\nphi,psi = fespot.TnT()\nsigma = 58.7e6\nbfa = BilinearForm(sigma*grad(phi)*grad(psi)*dx).Assemble()\ninv = bfa.mat.Inverse(freedofs=fespot.FreeDofs(), inverse=\"sparsecholesky\")\nlff = LinearForm(1/crosssection*psi*ds(\"in\")).Assemble()\ngfphi = GridFunction(fespot)\ngfphi.vec.data = inv * lff.vec\n```\n\n----------------------------------------\n\nTITLE: Setting up GridFunctions and Boundary Conditions\nDESCRIPTION: This snippet sets up GridFunctions for the velocity and pressure fields, and applies an inhomogeneous Dirichlet boundary condition on the inlet boundary for the velocity.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(V, name=\"u\")\ngfp = GridFunction(Q, name=\"p\")\nuin = CoefficientFunction( (1.5*4*y*(0.41-y)/(0.41*0.41), 0) )\ngfu.Set(uin, definedon=mesh.Boundaries(\"inlet\"))\n```\n\n----------------------------------------\n\nTITLE: Setting up Bilinear Form for Stokes\nDESCRIPTION: This snippet sets up the bilinear form for the Stokes equation using the defined finite element spaces. It includes the viscous term, the pressure-velocity coupling terms, and assembles the bilinear form into a matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n(u,p),(v,q) = X.TnT()\n\nstokes = InnerProduct(Grad(u), Grad(v))*dx + div(u)*q*dx + div(v)*p*dx\na = BilinearForm(stokes).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Setting up Stabilized Stokes Formulation\nDESCRIPTION: This snippet sets up a stabilized lowest order formulation for the Stokes equation.  It includes a stabilization term based on the mesh size to improve the stability of the P1-P1 element pairing.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh( geo.GenerateMesh(maxh=0.02))\n\nV = VectorH1(mesh, order=1, dirichlet=\"wall|inlet|cyl\")\nQ = H1(mesh, order=1)\n\nu,v = V.TnT()\np,q = Q.TnT()\n\na = BilinearForm(InnerProduct(Grad(u),Grad(v))*dx).Assemble()\nb = BilinearForm(div(u)*q*dx).Assemble()\nh = specialcf.mesh_size\nc = BilinearForm(-0.1*h*h*grad(p)*grad(q)*dx).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear Forms for Hybrid Mixed Method (Python)\nDESCRIPTION: This snippet assembles the bilinear forms A and B for the hybrid mixed method.  The bilinear form 'a' represents the integral of sigma * tau over the domain. The bilinear form 'b' represents the divergence term and boundary term in the mixed formulation.  specialcf.normal calculates the normal vector on the element boundary. The Assemble() method computes the element matrices and assembles them into a global matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(Sigma)\na += sigma*tau * dx\n\nb = BilinearForm(trialspace=Sigma, testspace=V)\nb += div(sigma) * vt * dx\nn = specialcf.normal(mesh.dim)\ndS = dx(element_boundary=True)\nb += -sigma*n*vf * dS\nb.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Set Inflow Boundary Condition\nDESCRIPTION: This snippet sets a parabolic inflow boundary condition for the velocity at the inlet. It defines a CoefficientFunction representing the parabolic profile and applies it to the first component of the GridFunction (velocity) on the \"inlet\" boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nuin = CoefficientFunction( (1.5*4*y*(0.41-y)/(0.41*0.41), 0) )\ngfu.components[0].Set(uin, definedon=mesh.Boundaries(\"inlet\"))\nDraw (gfu.components[0], mesh, \"vel\");\n```\n\n----------------------------------------\n\nTITLE: Estimating eigenvalues with two-grid preconditioner\nDESCRIPTION: Estimates the eigenvalues of the preconditioned system using the two-grid preconditioner `twogrid`. The `EigenValues_Preconditioner` function is called with the assembled matrix `a.mat` and the two-grid preconditioner. This allows for an analysis of the two-grid preconditioner's effectiveness.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nlam = EigenValues_Preconditioner(mat=a.mat, pre=twogrid)\nlam\n```\n\n----------------------------------------\n\nTITLE: Solving with CG using Jacobi preconditioner\nDESCRIPTION: Solves the linear system using the Conjugate Gradient (CG) method from the `solvers` module. It takes the assembled matrix `a.mat`, the point Jacobi preconditioner `preJpoint`, the right-hand side vector `f.vec`, and the grid function vector `gfu.vec` as input. The solution is then visualized using `Draw(gfu)`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nsolvers.CG(mat=a.mat, pre=preJpoint, rhs=f.vec, sol=gfu.vec)\nDraw(gfu)\n```\n\n----------------------------------------\n\nTITLE: Performing refinements and calculating integrals for convergence study - Python\nDESCRIPTION: This snippet performs mesh refinements and calculates integrals for both curved and uncurved meshes within a convergence study loop.  It iterates through a specified number of refinement levels, refines the mesh, and calculates integrals over NEG, POS, and IF domains, using and not using the mesh deformation from `lsetmeshadap`. The calculated error values for curved and uncurved cases are stored in dictionaries. Refinement is performed at the level set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nf = CoefficientFunction (1.0)\nrefinements = 5\nfor reflevel in range(refinements):\n    if(reflevel > 0):\n        mesh.Refine()\n\n    for key in [NEG,POS,IF]:\n        # Applying the mesh deformation\n        deformation = lsetmeshadap.CalcDeformation(levelset)\n\n        integrals_uncurved = Integrate(f * dCut(levelset=lsetp1, domain_type=key, order=order), mesh=mesh)\n        # dCut deals with the mesh deformation internally\n        integrals_curved = Integrate(f * dCut(levelset=lsetp1, domain_type=key, order=order, deformation=deformation), mesh=mesh)\n        \n        errors_curved[key].append(abs(integrals_curved - referencevals[key]))\n        errors_uncurved[key].append(abs(integrals_uncurved - referencevals[key]))\n    # refine cut elements:\n    RefineAtLevelSet(gf=lsetmeshadap.lset_p1)\n```\n\n----------------------------------------\n\nTITLE: Flux and Numerical Flux Definition\nDESCRIPTION: This snippet defines the flux function for the Euler equations and a numerical flux function. The flux function calculates the mass, momentum, and energy fluxes based on the state variables. The numerical flux function calculates a numerical approximation to the flux at element boundaries using an upwinding scheme (here simply the average flux). It takes the state variables and the gas constant as input.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngamma = 1.4  # Gas constant\ndef Flux (U):\n    rho = U[0]\n    u = U[1:3]/rho\n    E = U[3]\n    p = (gamma-1)*(E-rho/2*(u*u))\n    return CF ( (rho*u, rho*OuterProduct(u,u)+p*Id(2), \n                 (E+p)*u)).Reshape((4,2))\n\nngsglobals.msg_level = 0\n\nn = specialcf.normal(2)\nstab = 1\ndef NumFlux(u, uo): \n    return 0.5*(Flux(u)+Flux(uo)) \n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation with CGSolver on CUDA\nDESCRIPTION: This snippet creates device matrices for the bilinear form and the smoother. It then solves the Poisson equation using the CG solver on the CUDA device, measures the time taken, and compares the result with the host-based solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nadev = a.mat.CreateDeviceMatrix()\njacdev = jac.CreateDeviceMatrix()\n\ninv = CGSolver(adev, jacdev, maxsteps=2000, printrates=False)\n\nts = time()\nres = (inv * fdev).Evaluate()\nte = time()\n\nprint (\"Time on device:\", te-ts)\ndiff = Norm(gfu.vec - res)\nprint (\"diff = \", diff)\n```\n\n----------------------------------------\n\nTITLE: Calculating and printing convergence rates - Python\nDESCRIPTION: This snippet calculates and prints the experimental order of convergence (EOC) for both curved and uncurved meshes based on the error values obtained during the refinement loop. It calculates the EOC using the formula log(a/b)/log(2), where 'a' and 'b' are consecutive error values.  The errors and EOC for each key (NEG, POS, IF) are printed to the console.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfor key in [NEG,POS,IF]:\n    eoc_curved[key] = [log(a/b)/log(2) for (a,b) in zip (errors_curved[key][0:-1],errors_curved[key][1:]) ]\n    eoc_uncurved[key] = [log(a/b)/log(2) for (a,b) in zip (errors_uncurved[key][0:-1],errors_uncurved[key][1:]) ]\n\nprint(\"errors (  curved):  \\n{}\\n\".format(  errors_curved))\nprint(\"   eoc (  curved):  \\n{}\\n\".format(     eoc_curved))\n```\n\n----------------------------------------\n\nTITLE: Generate Mesh from OCC Geometry - Python\nDESCRIPTION: This snippet generates a Netgen mesh from the fused OCCT geometry. It first creates an `OCCGeometry` object from the OCCT shape, then generates the mesh using `GenerateMesh`, and finally visualizes the mesh using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom ngsolve import Mesh\nfrom ngsolve.webgui import Draw\n\ngeo = OCCGeometry(fused)\nmesh = Mesh(geo.GenerateMesh(maxh=0.2))\nmesh.Curve(3)\nDraw (mesh, clipping=True);\n```\n\n----------------------------------------\n\nTITLE: Calculating and drawing the normal vector\nDESCRIPTION: This snippet calculates the normal vector to the interface using the gradient of the interpolated level set function lsetp1 and draws it on the mesh, labeling it as \"normal\".\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nn = Normalize(grad(lsetp1))\nDraw(n, mesh, \"normal\", vectors={'grid_size': 20})\n```\n\n----------------------------------------\n\nTITLE: Defining BitArrays for Facets and DOFs (Python)\nDESCRIPTION: This snippet defines BitArrays for the facets of the mesh and the degrees of freedom of the finite element space.  These BitArrays are used later in the definition of the Ghost-penalty stabilization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nba_facets = BitArray(mesh.nfacet)\nactive_dofs = BitArray(st_fes.ndof)\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System with CG Solver in NGSolve\nDESCRIPTION: This code demonstrates solving a linear system using the Conjugate Gradient (CG) solver in NGSolve. It compares the performance of the solver with and without a coarse-grid preconditioner.  It utilizes device matrices for potential GPU acceleration. It measures and prints the norm of the solution and the computation time for both CPU and device execution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/examples/matrixfree.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport time\n\n#ngsglobals.msg_level = 9\n\nadev = Laplace.CreateDeviceMatrix()\nprojdev = proj.CreateDeviceMatrix()\n\nfdev = UnifiedVector(f.vec)\ngfudev = UnifiedVector(gfu.vec)\n\nt = time.time()\nwith TaskManager():\n  solvers.CG(mat=Laplace, pre=proj, rhs=f.vec, sol=gfu.vec, maxsteps=5000, printrates=False)\nprint(Norm(gfu.vec))\nprint(time.time() - t)\n\nt = time.time()\nsolvers.CG(mat=adev, pre=projdev, rhs=fdev, sol=gfudev, maxsteps=5000, printrates=False)\nprint(Norm(gfudev))\nprint(time.time() - t)\n```\n\n----------------------------------------\n\nTITLE: Define geometry and mesh using Netgen OCC\nDESCRIPTION: Defines a geometry consisting of an inner and outer rectangle using the Netgen OCC module, then generates a mesh.  The edges are named for interface conditions and boundaries for Dirichlet conditions. The resulting mesh is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ninner = Rectangle(1,1).Face()\ninner.edges.name=\"interface\"\ninner.edges.Max(X).name=\"interface_right\"\n\nouter = MoveTo(-1,-1).Rectangle(3,3).Face()\nouter.edges.name=\"dir\"\nouter = outer-inner\n\ninner.faces.name=\"inner\"\nouter.faces.name=\"outer\"\ngeo = Glue ([inner,outer])\nmesh = Mesh(OCCGeometry(geo, dim=2).GenerateMesh(maxh=0.2))\n\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Computing Element Matrix for Bilinear Form B (Python)\nDESCRIPTION: This code snippet iterates through the mesh elements and computes the element matrix for the bilinear form 'b'. It retrieves the finite element spaces for both the trial and test spaces, creates a MixedFE object, obtains the transformation, and then calculates the element matrix using the CalcElementMatrix method. It iterates through the integrators to compute the element matrices.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor el in mesh.Elements():\n    felS = Sigma.GetFE(el)\n    felV = V.GetFE(el)\n    fel = MixedFE(felS, felV)\n    trafo = mesh.GetTrafo(el)\n\n    # try integratos 0 and 1 ...\n    elmat = b.integrators[0].CalcElementMatrix(fel, trafo)   \n    print (elmat)\n```\n\n----------------------------------------\n\nTITLE: Creating coarse grid preconditioner\nDESCRIPTION: Creates a coarse grid preconditioner by inverting the matrix associated with vertex degrees of freedom.  The `Inverse` function in NGSolve takes a bit array (in this case `vertexdofs`) which identifies the dofs to be inverted.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ncoarsepre = a.mat.Inverse(vertexdofs)\n```\n\n----------------------------------------\n\nTITLE: Solving a PDE and visualizing the solution\nDESCRIPTION: This snippet defines a `BilinearForm`, assembles it, and then solves the resulting system of equations to obtain the solution represented by the `GridFunction` `gfu`. The solution is then visualized using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(fes)\na += grad(u)*grad(v)*dx\na.Assemble()\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs()) * f.vec\nDraw(gfu);\n```\n\n----------------------------------------\n\nTITLE: Solve Nonlinear Minimization Problem\nDESCRIPTION: Defines a function `SolveNonlinearMinProblem` to solve the minimization problem using Newton's method. It iteratively solves the linearized problem and updates the solution until convergence or maximum iterations are reached. A callback function is used to store intermediate solutions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef SolveNonlinearMinProblem(a,gfu,tol=1e-13,maxits=10, callback=lambda gfu: None):\n    res = gfu.vec.CreateVector()\n    du  = gfu.vec.CreateVector()\n    callback(gfu)\n    for it in range(maxits):\n        print (\"Newton iteration {:3}\".format(it),\n               \", energy = {:16}\".format(a.Energy(gfu.vec)),end=\"\")\n    \n        #solve linearized problem:\n        a.Apply (gfu.vec, res)\n        a.AssembleLinearization (gfu.vec)\n        du.data = a.mat.Inverse(V.FreeDofs()) * res\n    \n        #update iteration\n        gfu.vec.data -= du\n        callback(gfu)\n\n        #stopping criteria\n        stopcritval = sqrt(abs(InnerProduct(du,res)))\n        print (\"<A u\",it,\", A u\",it,\">_{-1}^0.5 = \", stopcritval)\n        if stopcritval < tol:\n            break\n        Redraw(blocking=True)\n```\n\n----------------------------------------\n\nTITLE: Define shape derivative linear form - Python\nDESCRIPTION: This snippet defines the linear form `dJOmega` representing the shape derivative.  It uses test and trial functions from the vector space `VEC` and integrates the expression `div(PSI)*f + InnerProduct(grad_f, PSI)` over the domain. This form is later used in the computation of the shape gradient.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Test and trial functions\nPHI, PSI = VEC.TnT()\n\n# shape derivative\ndJOmega = LinearForm(VEC)\ndJOmega += (div(PSI)*f + InnerProduct(grad_f, PSI) )*dx\n```\n\n----------------------------------------\n\nTITLE: Setting up H(div) Space for Flux Recovery\nDESCRIPTION: This code sets up the H(div) space and a grid function to store the recovered flux. It computes the flux by multiplying the heat conductivity coefficient with the gradient of the solution and interpolates it into the H(div) space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nspace_flux = HDiv(mesh, order=2)\ngf_flux = GridFunction(space_flux, \"flux\")\n\nflux = lam * grad(gfu)\ngf_flux.Set(flux)\n```\n\n----------------------------------------\n\nTITLE: Defining Integration Domains - Python\nDESCRIPTION: This code defines various integration domains based on element types and level set values. `dxbar` is for the active mesh, `dxinner` for elements inside the domain, `dxcut` for cut elements, `ds` for the interface (zero level set), and `dX` for integration over the physical domain (Omega). The `definedonelements` argument restricts the integration to specific elements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# active mesh integrals:\ndxbar = dx(definedonelements=ci.GetElementsOfType(HASNEG), deformation=deformation)\n# uncut mesh integrals:\ndxinner = dx(definedonelements=ci.GetElementsOfType(NEG), deformation=deformation)\n# cut element integrals (full elements, no cut integral):\ndxcut = dx(definedonelements=ci.GetElementsOfType(IF), deformation=deformation)\n# integral on zero level set:\nds = dCut(lsetp1, IF, definedonelements=hasif, deformation=deformation)\n# integral on Omega (physical domain, this is a cut integral):\ndX = dCut(lsetp1, NEG, definedonelements=hasneg, deformation=deformation)\n```\n\n----------------------------------------\n\nTITLE: Defining Material Properties and Stress Function\nDESCRIPTION: Defines the material properties (Young's modulus E and Poisson's ratio nu) and calculates Lam parameters mu and lambda.  A `Stress` function is defined to compute the stress tensor from the strain tensor based on Hooke's law.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nE, nu = 210, 0.2\nmu  = E / 2 / (1+nu)\nlam = E * nu / ((1+nu)*(1-2*nu))\n\ndef Stress(strain):\n    return 2*mu*strain + lam*Trace(strain)*Id(3)    \n```\n\n----------------------------------------\n\nTITLE: Homogenization Implementation - Python\nDESCRIPTION: This code implements a do-it-yourself homogenization. It calculates the residual, then applies the inverse of the bilinear form's matrix (restricted to free dofs) to the residual, and adds this result to the solution vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_dirichlet.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nres = f.vec.CreateVector()\nres.data = f.vec - a.mat * u.vec\nu.vec.data += a.mat.Inverse(v.FreeDofs()) * res\n```\n\n----------------------------------------\n\nTITLE: Solve and Visualize DG Solution in NGSolve\nDESCRIPTION: This snippet solves the linear system `a.mat * gfu.vec = f.vec` to obtain the DG solution and visualizes it using the `Draw` function. It creates a `GridFunction` to store the solution and uses the inverse of the assembled bilinear form matrix to solve for the solution vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes, name=\"uDG\")\ngfu.vec.data = a.mat.Inverse() * f.vec\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Gradient Descent Shape Optimization with Armijo Linesearch - Python\nDESCRIPTION: This Python code implements a gradient descent algorithm for shape optimization. It uses the Armijo linesearch from scipy.optimize to determine the step size. The function takes an initial guess, the shape function `J_`, and its gradient `gradJ_` as input. It iteratively updates the shape until convergence or a maximum number of iterations is reached. It depends on numpy for vector operations and scipy.optimize.linesearch for the Armijo linesearch. Prints cost and gradient norm for each iteration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.optimize.linesearch import line_search_armijo\n\ndef gradient_descent(x0, J_, gradJ_):\n\n    xk_ = np.copy(x0)\n    \n    # maximal iteration\n    it_max = 50\n    # count number of function evals\n    nfval_total = 0\n\n    print('\\n')\n    for i in range(1, it_max):\n        \n        # Compute a step size using a line_search to satisfy the Wolf\n        # compute shape gradient grad J \n        grad_xk = gradJ_(xk_,euclid = False)\n        \n        # compute descent direction\n        pk = -gradJ_(xk_)\n        \n        # eval cost function\n        fold = J_(xk_)\n        \n        # perform armijo stepsize\n        \n        if CR == True:\n            alpha0 = 0.15\n        else:\n            alpha0 = 0.11\n            \n            \n        \n        step, nfval, b = line_search_armijo(J_, xk_, pk = pk, gfk = grad_xk, old_fval = fold, c1=1e-4, alpha0 = alpha0)\n        nfval_total += nfval\n        \n        # update the shape and print cost and gradient norm\n        xk_ = xk_ - step * grad_xk\n        print('Iteration ', i, '| Cost ', fold, '| grad norm', np.linalg.norm(grad_xk))\n        \n        mesh.SetDeformation(gfset)\n        scene.Redraw()\n        mesh.UnsetDeformation()\n        \n        if np.linalg.norm(gradJ_(xk_)) < 1e-4:\n\n            #print('#######################################')\n            print('\\n'+'{:<20}  {:<12} '.format(\"##################################\", \"\"))\n            print('{:<20}  {:<12} '.format(\"### success - accuracy reached ###\", \"\"))\n            print('{:<20}  {:<12} '.format(\"##################################\", \"\"))\n            print('{:<20}  {:<12} '.format(\"gradient norm: \", np.linalg.norm(gradJ_(xk_))))\n            print('{:<20}  {:<12} '.format(\"n evals f: \", nfval_total))\n            print('{:<20}  {:<12} '.format(\"f val: \", fold) + '\\n')\n            break\n        elif i == it_max-1:\n\n            #print('######################################')\n            print('\\n'+'{:<20}  {:<12} '.format(\"#######################\", \"\"))\n            print('{:<20}  {:<12} '.format(\"### maxiter reached ###\", \"\"))\n            print('{:<20}  {:<12} '.format(\"#######################\", \"\"))\n            print('{:<20}  {:<12} '.format(\"gradient norm: \", np.linalg.norm(gradJ_(xk_))))\n            print('{:<20}  {:<12} '.format(\"n evals f: \", nfval_total))\n            print('{:<20}  {:<12} '.format(\"f val: \", fold) + '\\n')\n        \n \n```\n\n----------------------------------------\n\nTITLE: Assemble and Initialize Preconditioner - Python\nDESCRIPTION: This snippet assembles the bilinear form and initializes the preconditioner at the coarsest level. The `Inverse` operator provides an exact inverse at the coarsest level.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()   # Make exact inverse at current/coarsest level\npre = a.mat.Inverse(fes.FreeDofs())\n```\n\n----------------------------------------\n\nTITLE: Defining the bilinear form for the state equation\nDESCRIPTION: This snippet defines the bilinear form 'aAuto' for the state equation using the finite element space 'fes'. It incorporates the PDE constraint defined in 'EquationFA'. The symmetric=True argument indicates that the form is symmetric.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nu, v = fes.TnT()\n\naAuto = BilinearForm(fes, symmetric=True)\naAuto += EquationFA(u,v)\n```\n\n----------------------------------------\n\nTITLE: Geometry Creation for Dam Break Problem - Python\nDESCRIPTION: This snippet creates the geometry for a dam break problem using the netgen.occ module. It defines the domain, creates fillets, mirrors the geometry, and assigns names to the boundaries (upperlevel, lowerlevel, wall, dam). It uses the OCCGeometry class to represent the geometry within NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# geometry description (including boundary/mat names)\nfrom ngsolve import * \nfrom netgen.occ import *\nfrom ngsolve.webgui import * \nwp = WorkPlane()\nwp.MoveTo(-12,-5).LineTo(-3,-5).NameVertex(\"fillet\")\nwp.LineTo(-3,-1).NameVertex(\"fillet\")\nwp.LineTo(0,-1).LineTo(0,0).LineTo(-12,0).Close()\ngeo = wp.Face()\ngeo = geo.MakeFillet(list(set(geo.vertices[\"fillet\"])),2)\ngeo = geo + geo.Mirror(Axis((0,0,0),X)).Reversed()\ngeo = Glue([geo,geo.Mirror(Axis((0,0,0),Y)).Reversed()])\ngeo.faces.Min(X).name=\"upperlevel\"\ngeo.faces.Max(X).name=\"lowerlevel\"\ngeo.edges.name = \"wall\"\ngeo.edges.Nearest((0,0)).name = \"dam\"\n#Draw(geo)\ngeo = OCCGeometry(geo,dim=2)\n```\n\n----------------------------------------\n\nTITLE: Refining the Mesh and Solving Again\nDESCRIPTION: This snippet refines the mesh based on the previously marked elements, solves the boundary value problem on the refined mesh, and visualizes the updated solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmesh.Refine()\nSolveBVP()\nDraw(gfu)\n```\n\n----------------------------------------\n\nTITLE: Defining H1 Finite Element Space on a Sub-domain (NGSolve, Python)\nDESCRIPTION: This snippet demonstrates how to define an H1 finite element space on a specific sub-domain within an NGSolve mesh. The `definedon` argument specifies the sub-domain, which can be a string (regex filter) or a list of sub-domain numbers.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_definedon.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfes1 = H1(mesh, definedon=\"inner\")\n```\n\n----------------------------------------\n\nTITLE: Compile C++ Module for Custom Assemblers (NGSolve)\nDESCRIPTION: This snippet compiles a C++ module containing custom assemblers using the `CompilePythonModule` function from `ngsolve.fem`. The `init_function_name` parameter specifies the name of the initialization function in the C++ module.  The compiled module is then available for use in Python.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nimport pyngcore   # for timers \n\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import unit_square\n\nfrom ngsolve.fem import CompilePythonModule\nfrom pathlib import Path\n\nm = CompilePythonModule(Path('myassemblemodule.cpp'), init_function_name='mymodule')\ndir (m)\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear Form - Python\nDESCRIPTION: This snippet defines and assembles a bilinear form `a` representing the Laplacian operator. It uses trial and test functions (u, v) from the finite element space `fes` and integrates the product of their gradients over the domain. The assembled matrix `a.mat` will be used in the linear system to solve for the unknown function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nu, v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx).Assemble();\n```\n\n----------------------------------------\n\nTITLE: Defining Ring Geometry with Level Set - Python\nDESCRIPTION: This code snippet defines a ring geometry using a level set function.  A square geometry is created, and a level set function is defined based on the radial distance from the center, allowing for the representation of the ring. The level set function is then visualized using DrawDC.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsquare = SplineGeometry()\nsquare.AddRectangle((-1, -1), (1, 1), bc=1)\nmesh = Mesh(square.GenerateMesh(maxh=0.2))\nr1, r2 = 1/4, 3/4  # inner/ outer radius\nrr, rc = (r2 - r1) / 2.0 , (r1 + r2) / 2.0\nr = sqrt(x**2 + y**2)\nlevelset = IfPos(r - rc, r - rc - rr, rc - r - rr)\nDrawDC(levelset,-1.0,2.0,mesh,\"x\") \n```\n\n----------------------------------------\n\nTITLE: Solve the Poisson Equation in Python\nDESCRIPTION: This snippet solves the Poisson equation by inverting the system matrix using a direct solver. The result is stored in a `GridFunction` object, `gfu`, which represents the solution on the mesh. The `FreeDofs()` method ensures that Dirichlet boundary conditions are enforced during the solve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/poisson.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs()) * f.vec\n```\n\n----------------------------------------\n\nTITLE: Numerical Flux Calculation (Lax-Friedrichs) - Python\nDESCRIPTION: This snippet defines the numerical flux function Fhatn(U) using the Lax-Friedrichs scheme. It calculates the flux at the element boundaries. It uses the normal vector to the boundary, `specialcf.normal(mesh.dim)`.  It computes the maximum characteristic speed, Fmax, based on the left (U) and right (Uhat) states, which is used to add dissipation. The `IfPos` function implements a conditional statement.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nn = specialcf.normal(mesh.dim)\ndef Max(u,v):\n    return IfPos(u-v,u,v)\ndef Fmax(A,B): # max. characteristic speed:\n    ha, hua, hva = A\n    hb, hub, hvb = B\n    vnorma = sqrt(hua**2+hva**2)/ha\n    vnormb = sqrt(hub**2+hvb**2)/hb\n    return Max(vnorma+sqrt(g*A[0]),vnormb+sqrt(g*B[0]))\n\ndef Fhatn(U): # numerical flux\n    Uhat = U.Other(bnd=Ubnd)\n    return (0.5*F(U)+0.5*F(Uhat))*n + Fmax(U,Uhat)/2*(U-Uhat)\n```\n\n----------------------------------------\n\nTITLE: Compiling Custom Finite Element Module in NGSolve\nDESCRIPTION: This Python code snippet compiles a custom C++ finite element module named 'mymodule.cpp' using NGSolve's CompilePythonModule function. It specifies the initialization function name as 'mymodule'. The compiled module is then loaded as a Python module.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom ngsolve.fem import CompilePythonModule\nfrom pathlib import Path\n\nm = CompilePythonModule(Path('mymodule.cpp'), init_function_name='mymodule')\n```\n\n----------------------------------------\n\nTITLE: Estimating condition number with Identity Preconditioner\nDESCRIPTION: This estimates the condition number of the matrix `a.mat` when preconditioned with the identity operator `preI`. It utilizes `EigenValues_Preconditioner` to compute the eigenvalues of the preconditioned system and then calculates the ratio of the maximum to minimum eigenvalue.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nlams = EigenValues_Preconditioner(mat=a.mat, pre=preI)\nmax(lams)/min(lams)\n```\n\n----------------------------------------\n\nTITLE: Visualize B-field\nDESCRIPTION: This code visualizes the calculated magnetic flux density (B-field) using the NGSolve webgui. It draws the curl of the computed GridFunction, applies clipping to show a cross-section, and displays vectors representing the field direction.  Min and max values control the color scale.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwell.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nDraw (curl(gfu), mesh, \"B-field\", draw_surf=False, \\\n      clipping = { \"z\" : -1, \"function\":True}, \\\n      vectors = { \"grid_size\":50}, min=0, max=2e-5);\n```\n\n----------------------------------------\n\nTITLE: Defining Space-Time Finite Element Space (Python)\nDESCRIPTION: This snippet defines the space-time finite element space by combining a spatial H1 finite element space with a scalar time finite element. The use of a nodal time finite element simplifies the extraction of spatial functions at fixed times.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Spatial FESpace for solution\nfes1 = H1(mesh, order=k_s, dgjumps=True)\n# Time finite element (nodal!)\ntfe = ScalarTimeFE(k_t)\n# (Tensor product) space-time finite element space\nst_fes = tfe * fes1\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation with Custom FESpace in NGSolve\nDESCRIPTION: This snippet demonstrates solving a Poisson equation using the custom finite element space.  It sets up a bilinear form representing the Laplacian, a linear form representing the source term, and then solves the resulting linear system using a sparse direct solver.  The solution is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx).Assemble()\nf = LinearForm(10*v*dx).Assemble()\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs())*f.vec\nDraw (gfu, order=3);\n```\n\n----------------------------------------\n\nTITLE: Parallel Conjugate Gradient Solver with TaskManager in NGS-Py\nDESCRIPTION: This code snippet illustrates a parallel conjugate gradient solver in NGS-Py utilizing the TaskManager.  The with TaskManager() statement enables parallel execution of matrix-vector products, vector updates, and inner products within the solver's loop. It assumes 'mat', 's', 'w', 'wdn', 'u', and 'd' are pre-defined variables representing matrices and vectors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_parallel.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n\n  ...\n  for it in range(maxsteps):\n      w.data = mat * s\n      wd = wdn\n      as_s = InnerProduct (s, w)\n      alpha = wd / as_s\n      u.data += alpha * s\n      d.data += (-alpha) * w\n```\n\n----------------------------------------\n\nTITLE: Define Geometry with Netgen OCC\nDESCRIPTION: This snippet uses the Netgen OCC module to define the geometry for the Schfer-Turek benchmark. It creates a rectangular shape with a circular obstacle, defines boundary names (wall, inlet, outlet), and visualizes the shape.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\n\nshape = Rectangle(2,0.41).Circle(0.2,0.2,0.05).Reverse().Face()\nshape.edges.name=\"wall\"\nshape.edges.Min(X).name=\"inlet\"\nshape.edges.Max(X).name=\"outlet\"\nDraw (shape);\n```\n\n----------------------------------------\n\nTITLE: Assembling and Solving Linear System in NGSolve (Python)\nDESCRIPTION: This code snippet demonstrates the assembly of the stiffness matrix `a` and load vector `f`, and then solves the linear system using the `Inverse` method on the free degrees of freedom. The result is stored in `gfw.vec.data`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()\nf.Assemble()\ngfw.vec.data = a.mat.Inverse(Wh.FreeDofs()) * f.vec\n```\n\n----------------------------------------\n\nTITLE: Setup for SciPy Optimization - Python\nDESCRIPTION: This snippet sets up the initial geometry, mesh, function `f`, and finite element space `VEC` for shape optimization using SciPy's optimization toolbox.  It defines the necessary components for formulating the optimization problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# The code in this cell is the same as in the example above.\n\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import SplineGeometry\n\nimport numpy as np\n\nngsglobals.msg_level = 1\n\ngeo = SplineGeometry()\ngeo.AddCircle((0,0), r = 2.5)\n\nngmesh = geo.GenerateMesh(maxh = 0.08)\nmesh = Mesh(ngmesh)\nmesh.Curve(2)\n\n# define the function f\n\na =4.0/5.0\nb = 2\nf = CoefficientFunction((sqrt((x - a)**2 + b * y**2) - 1) \\\n                * (sqrt((x + a)**2 + b * y**2) - 1) \\\n                * (sqrt(b * x**2 + (y - a)**2) - 1) \\\n                * (sqrt(b * x**2 + (y + a)**2) - 1) - 0.001)\n\n# Now we define the finite element space VEC in which we compute the shape gradient\n\n# element order\norder = 1\n\nVEC = H1(mesh, order=order, dim=2)\n\n# define test and trial functions\nPHI = VEC.TrialFunction()\nPSI = VEC.TestFunction()\n\n\n# define grid function for deformation of mesh\ngfset = GridFunction(VEC)\ngfset.Set((0,0))\n\n# only for new gui\n#scene = Draw(gfset, mesh, \"gfset\")\n\n#if scene:\n#    scene.setDeformation(True)\n\n# plot the mesh and visualise deformation\n#Draw(gfset,mesh,\"gfset\")\n#SetVisualization (deformation=True)\n```\n\n----------------------------------------\n\nTITLE: Trace of Derivatives in NGS-Py\nDESCRIPTION: This code snippet shows two equivalent ways to obtain the tangential derivative of an H1-function on the boundary using the Trace operator in NGSolve. The first approach calculates the trace of the function and then takes the derivative, while the second approach takes the derivative first and then restricts the result to the boundary.  Both methods produce the same result.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_traceoperator.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nu.Trace().Deriv()\n```\n\nLANGUAGE: python\nCODE:\n```\nu.Deriv().Trace()\n```\n\n----------------------------------------\n\nTITLE: Initializing Bilinear Form with Static Condensation (NGSolve, Python)\nDESCRIPTION: This code snippet initializes a bilinear form in NGSolve with the `eliminate_internal` flag set to `True`. This enables static condensation, eliminating element-internal unknowns during the assembly process. The bilinear form is then assembled with a symbolic BFI representing the Laplacian operator.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_staticcondensation.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import unit_square\nfrom ngsolve import *\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.3))\n\nfes = H1(mesh, order=10, dirichlet=[1,2])\nu = fes.TestFunction()\nv = fes.TrialFunction()\n\na = BilinearForm(fes, flags = { \"eliminate_internal\" : True } )\na += SymbolicBFI (grad(u) * grad(v))\na.Assemble()\n\nf = LinearForm(fes)\nf += SymbolicLFI (1 * v)\nf.Assemble()\n\nu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form for DG Method\nDESCRIPTION: This code defines the bilinear form for the DG method, incorporating the interior penalty terms.  It utilizes proxy functions for the Hessian and jump of the normal derivative. The bilinear form includes terms for the Hessian, jumps in normal derivatives, and penalty terms scaled by the element size and polynomial order.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.9-fourthorder/fourthorder.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn = specialcf.normal(2)\nh = specialcf.mesh_size\n\ndef jumpdn(v,vhat): \n    return n*(grad(v)-vhat)\ndef hesse(v):\n    return v.Operator(\"hesse\")\ndef hessenn(v):\n    return InnerProduct(n, hesse(v)*n)\n\ndS = dx(element_boundary=True)\na = BilinearForm(V)\na += InnerProduct (hesse(w), hesse(v)) * dx \\\n     - hessenn(w) * jumpdn(v,vhat) * dS \\\n     - hessenn(v) * jumpdn(w,what) * dS \\\n     + 3*order*order/h * jumpdn(w,what) * jumpdn(v,vhat) * dS\na.Assemble()\n\nf = LinearForm(1*v*dx).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Setting up DG Discretization (Python)\nDESCRIPTION: This snippet sets up a Discontinuous Galerkin (DG) discretization in NGSolve. It defines the finite element space (`L2` with `dgjumps=True`), formulates the bilinear form with jump terms for numerical flux stabilization, and assembles the form. It uses `specialcf.normal(2)` and `specialcf.mesh_size` for normal vector and mesh size respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.1))\norder=4\nfesDG = L2(mesh, order=order, dgjumps=True)\nu,v = fesDG.TnT()\naDG = BilinearForm(fesDG)\njump_u = u-u.Other()\njump_v = v-v.Other()\nn = specialcf.normal(2)\nmean_dudn = 0.5*n * (grad(u)+grad(u.Other()))\nmean_dvdn = 0.5*n * (grad(v)+grad(v.Other()))\nalpha = 4\nh = specialcf.mesh_size\naDG = BilinearForm(fesDG)\naDG += grad(u)*grad(v) * dx\naDG += alpha*order**2/h*jump_u*jump_v * dx(skeleton=True)\naDG += alpha*order**2/h*u*v * ds(skeleton=True)\naDG += (-mean_dudn*jump_v -mean_dvdn*jump_u) * dx(skeleton=True)\naDG += (-n*grad(u)*v-n*grad(v)*u)* ds(skeleton=True)\naDG.Assemble()\n\nfDG = LinearForm(fesDG)\nfDG += 1*v * dx\nfDG.Assemble()\ngfuDG = GridFunction(fesDG)\n```\n\n----------------------------------------\n\nTITLE: RestrictedBilinearForm Definition and Assembly - Python\nDESCRIPTION: This snippet demonstrates how to define a RestrictedBilinearForm in NGSolve, restricting the matrix couplings to elements of a specific type (IF). It compares the assembly process with a standard BilinearForm. The snippet requires NGSolve and a defined finite element space (Vhbase) and a Mesh with a CellInformation named 'ci'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n#help(RestrictedBilinearForm)\na_full = BilinearForm(Vhbase, check_unused=False)\na = RestrictedBilinearForm(Vhbase,element_restriction=ci.GetElementsOfType(IF),\n                           facet_restriction=None, check_unused=False)\na_full.Assemble()\na.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form\nDESCRIPTION: This code defines the bilinear form for the coupled problem. It includes terms for the FEM region (Laplacian and Helmholtz term), and coupling terms on the interface between the FEM and wave regions. The `epsilon` variable defines the permittivity, which is 10 in the \"obstacle\" material and 1 elsewhere.  It uses the ultra-weak variational formulation for coupling. `a.Assemble()` assembles the bilinear form into a matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nu,v = fes.TnT()\n(uf,uw), (vf,vw) = fes.TnT()\nuwdx = uw.Operator(\"dn\")\nvwdx = vw.Operator(\"dn\")\n\nepsilon = mesh.MaterialCF( { \"obstacle\" : 10 }, 1)\n\na = BilinearForm(fes)\na += (grad(uf))*grad(vf)*dx(\"fem.*\") - omega**2*epsilon*uf*vf*dx(\"fem.*\")\na += (-uf*vwdx-vf*uwdx+uw.Trace()*vwdx)*ds(\"coupling\")\na.Assemble()\n\nf = LinearForm(1*vf*dx(\"femsource\")).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Solving the Mixed Problem\nDESCRIPTION: This code solves the mixed problem by inverting the system matrix using `am.mat.Inverse` and updating the `gfm` GridFunction.  It applies a direct solver (umfpack) to find the solution and visualizes the flux and scalar variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nres = fm.vec.data - am.mat * gfm.vec\ngfm.vec.data += am.mat.Inverse(freedofs=fesm.FreeDofs(), inverse=\"umfpack\") * res\n# solvers.BVP(bf=am, lf=fm, gf=gfm)\nDraw (gfsigma, mesh, \"flux-mixed\")\nDraw (gfu, mesh, \"u-mixed\");\n```\n\n----------------------------------------\n\nTITLE: Creating Mesh from Geometry\nDESCRIPTION: This code generates a mesh from the defined geometry using Netgen. It specifies the maximum element size (`maxh=0.2`) and curves the mesh elements to order 3. The generated mesh is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngeo = OCCGeometry(shape, dim=2)\nmesh = Mesh(geo.GenerateMesh(maxh=0.2)).Curve(3)\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Bilinear Form Definition with geom_free (NGSolve)\nDESCRIPTION: This code defines two bilinear forms, `c1` and `c2`, using the `geom_free=True` flag for performance optimization. `c1` represents a convection term, while `c2` adds a boundary term based on the `IfPos` condition. The integration in `c1` is performed over the domain and the integration in `c2` is done over element boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# part 1\nuT, vT = VT.TnT()\nc1 = BilinearForm(space=VT, nonassemble=True, geom_free=True)\nc1 += -uT * b * grad(vT) * dx\n# part 2\nuT,uF = V.TrialFunction() \nc2 = BilinearForm(trialspace=V, testspace=VT, nonassemble=True, geom_free=True)\n# here uf-u = u_me + u_other - u_me is the neighbor value\nc2 += b*n * IfPos(b*n, uT, uF-uT) * vT * dx(element_boundary=True)\n```\n\n----------------------------------------\n\nTITLE: Creating Intersection DomainTypeArray (Python)\nDESCRIPTION: This snippet creates a DomainTypeArray representing the region outside of two triangles, by taking the tensor intersection of the complement of the DomainTypeArrays representing the two triangles. The resulting DomainTypeArray is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\ndta_outside = TensorIntersection(~dta1, ~dta2)\nDrawDC(dta_outside.Indicator(level_sets1 + level_sets2), -3.5, 2.5, mesh, \"outside\")\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve and Netgen Modules\nDESCRIPTION: This snippet imports necessary modules from NGSolve and Netgen. `ngsolve` provides the core functionality for finite element simulations. `ngsolve.webgui` enables visualization in a web browser. `netgen.occ` is used for constructive solid geometry operations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/periodicity.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\n```\n\n----------------------------------------\n\nTITLE: Assemble Bilinear and Linear Forms with Custom Integrators (NGSolve)\nDESCRIPTION: This snippet defines a bilinear form `a` and a linear form `f`. It adds custom integrators `MyLaplace` and `MySource` from the compiled C++ module `m` to these forms, respectively. The `Assemble()` method is then called on each form to compute the system matrix and load vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(fes)\na += m.MyLaplace(1)\na.Assemble()\n\nf = LinearForm(fes)\nf += m.MySource(x)\nf.Assemble();\n```\n\n----------------------------------------\n\nTITLE: Computing Boundary with DomainTypeArray (Python)\nDESCRIPTION: This snippet calculates the boundary of a DomainTypeArray and visualizes it using IndicatorSmoothed and DrawDC. It demonstrates the difference between DomainTypeArrays created with and without persistent compression when computing the boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nz_disc = DomainTypeArray((NEG,ANY,ANY,ANY)) & ~DomainTypeArray((NEG,NEG,NEG,NEG))\nbnd1 = z_disc.Boundary()\nDrawDC(bnd1.IndicatorSmoothed(level_sets_p1,0.08/interactive), -3.5, 2.5, mesh, \"bnd1\")\nbnd1.as_list\n```\n\n----------------------------------------\n\nTITLE: Setting and Drawing Grid Function in NGSolve (Python)\nDESCRIPTION: This snippet defines a finite element space (H1), creates a GridFunction to represent a solution, sets the GridFunction values using a function (x*x*x*x), draws the GridFunction, and prints the GridFunction vector. The `H1` space is a standard conforming finite element space. `GridFunction` holds the numerical solution. `Set` projects a function into the finite element space. `Draw` visualizes the grid function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=3, low_order_space=False)  \n\nfunc = x*x*x*x\ngfu = GridFunction(fes)\ngfu.Set(func)\nDraw (gfu)\nprint (gfu.vec)\n```\n\n----------------------------------------\n\nTITLE: Calculating Element-wise Error Estimator\nDESCRIPTION: This code calculates the element-wise error estimator based on the difference between the computed flux and the recovered flux in the H(div) space.  The error is then drawn on the mesh for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nerr = 1/lam*(flux-gf_flux)*(flux-gf_flux)\nDraw(err, mesh, 'error_representation')\n```\n\n----------------------------------------\n\nTITLE: Setting up Contact Condition for 3D Problem - Python\nDESCRIPTION: This code defines the contact boundary for the 3D problem and sets up the contact condition using an energy-based formulation.  The contact is between 'contact1' and 'contact2' boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ncontact = ContactBoundary(mesh.Boundaries(\"contact1\"), mesh.Boundaries(\"contact2\"))\nX = CoefficientFunction((x,y,z))\ncf = (X + u - (X.Other() + u.Other())) * specialcf.normal(3)\ncontact.AddEnergy(IfPos(cf, 1e4*cf*cf, 0))\ncontact.Update(gfu, a, 20, 4)\n```\n\n----------------------------------------\n\nTITLE: Time-Stepping Loop for Solving the Heat Equation - Python\nDESCRIPTION: This snippet implements the time-stepping loop to solve the heat equation. It assembles the linear form, solves the system of equations, extracts the solution at the new time level, stores it for visualization, and calculates the L2 error.  The `RestrictGFInTime` function extracts a spatial GridFunction from a space-time GridFunction at a fixed reference time. It updates the time variable `told` and prints the L2 error at each time step.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nscene = Draw(u_last, mesh,\"u\", autoscale=False,min=0,max=1,deformation=True)\ntimestep = 0\nwhile tend - told.Get() > delta_t / 2:\n    if timestep % 4 == 0:\n        gfut.AddMultiDimComponent(u_last.vec)    \n    timestep += 1\n    f.Assemble()\n    gfu.vec.data = ainv * f.vec\n    RestrictGFInTime(spacetime_gf=gfu, reference_time=1.0, space_gf=u_last)\n    l2error = sqrt(Integrate((u_exact - gfu)**2 * dxnew, mesh))\n    scene.Redraw()\n    told.Set(told.Get() + delta_t)\n    print(\"\\rt = {0:12.9f}, L2 error = {1:12.9e}\".format(told.Get(), l2error), end=\"\")\ngfut.AddMultiDimComponent(u_last.vec)    \n```\n\n----------------------------------------\n\nTITLE: Defining Parameters for Space-Time FEM - Python\nDESCRIPTION: This snippet defines parameters required for space-time finite element discretization. It sets the spatial and temporal finite element orders, final simulation time, and time step size. The order parameters control the polynomial degree of the finite element basis functions. These parameters affect accuracy and computational cost.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Space finite element order\norder = 1\n# Time finite element order\nk_t = 1\n# Final simulation time\ntend = 1.0\n# Time step\ndelta_t = 1 / 32\n```\n\n----------------------------------------\n\nTITLE: Integrating with DomainTypeArray (Python)\nDESCRIPTION: This snippet performs integration over a domain defined by a DomainTypeArray using dCut.  The area_zd variable calculates the expected area using analytical geometry.  The error is then calculated between the integrated area and the analytical area.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom math import pi\narea_zd = pi - 2 / 3 * (0.5 + sqrt(2) * 2 / 3)\narea_zd += - (2 * asin(1 / 3) - sin(2 * asin(1 / 3))) / 2\n\narea = Integrate(CoefficientFunction(1) * dCut(level_sets_p1, z_disc2, order=0), mesh)\n\nprint(\"Area 2 = {:12.10f}\".format(area))\nprint(\"Error: {:4.2e}\".format(abs(area - area_zd)))\n```\n\n----------------------------------------\n\nTITLE: Load Step Iteration and Solver in NGSolve\nDESCRIPTION: This snippet iterates through a list of load steps to simulate a loading process and solves a linear system using NGSolve. It includes assembling bilinear and linear forms (`a.Assemble()`, `L.Assemble()`), solving the linear system with `a.mat.Inverse()`, and updating the solution vector (`gfu.vec.data -= w`). The internal states are evolved using `evolve_internal()` within a `TaskManager`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Load steps (chosen based on experience)\nloadsteps = [0.1,0.3,0.5,0.7,0.8,0.9,0.95,1.0]\n\n# Set solution to zero initially\ngfu.vec[:] = 0\ngfint.vec[:] = 0\ngfhist.vec[:] = 0\ngftrial.vec[:] = 0\n\n\n# Iterate through load steps\nfor ls in loadsteps:\n    loadfactor.Set(ls)\n        \n    # Update old solution at time t = t_k\n    store_internal()\n    \n    with TaskManager():\n        for i in range(20):\n            \n            a.Assemble()\n            L.Assemble()\n            \n            w.data = a.mat.Inverse(freedofs=fes_u.FreeDofs(False), inverse=\"umfpack\") * L.vec\n            gfu.vec.data -= w\n            \n            # Solve the evolution equation (quadrature-point-wise)\n            evolve_internal()\n                        \n            if np.isnan(np.max(np.abs(gfp.vec.FV().NumPy()))):\n                raise Exception(\"Evolution solver failed\")\n            \n            # NOTE: This problem is not a minimization problem. \n            # Therefore, we compute || |W| . |R| || instead of || W . R ||.\n            err = np.linalg.norm(np.abs(w.FV().NumPy()) * np.abs(L.vec.FV().NumPy()))\n            print(\"step \", i, \"err = \", err)\n            \n            # Check convergence\n            if err < 1e-6: break\n        \n    print(\"force = \", ls * force, \", uy_A =\", gfu(node_A)[1], \", ux_B =\", gfu(node_B)[0],\\\n          \", int u2 =\", Integrate(gfu[1] * ds(\"top\"),mesh))\n```\n\n----------------------------------------\n\nTITLE: Solving BVP with Automatic Utility - Python\nDESCRIPTION: This code snippet demonstrates the usage of the `BVP` (Boundary Value Problem) utility in NGSolve to solve the Dirichlet problem automatically.  It sets the boundary values, constructs a preconditioner, calls the BVP solver, and draws the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngfu.Set(g, BND)\nc = Preconditioner(a,\"local\")   #<- Jacobi preconditioner\n#c = Preconditioner(a,\"direct\") #<- sparse direct solver\nc.Update()\nsolvers.BVP(bf=a, lf=f, gf=gfu, pre=c)\nDraw(gfu)\n```\n\n----------------------------------------\n\nTITLE: Approximating the level set function with P1 elements - Python\nDESCRIPTION: This snippet approximates the level set function with a piecewise linear function (P1) on the mesh. This is done by creating a GridFunction on an H1 space and interpolating the level set function onto it. The P1 approximation is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nV = H1(mesh,order=1,autoupdate=True)\nlset_approx = GridFunction(V,autoupdate=True)\nInterpolateToP1(levelset, lset_approx)\nDrawDC(lset_approx, -3.5, 2.5, mesh, 'levelset_p1')\n```\n\n----------------------------------------\n\nTITLE: Defining 3D Geometry for Contact Problem - Python\nDESCRIPTION: This code snippet defines the geometry for a 3D contact problem using the netgen.occ module. It creates a box and a cylinder, defines boundary names for contact and fixed conditions, and generates a compound geometry. The mesh is then created and curved.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom ngsolve import *\nfrom ngsolve.solvers import *\nfrom ngsolve.webgui import Draw\nfrom netgen.webgui import Draw as DrawGeo\n```\n\nLANGUAGE: python\nCODE:\n```\nbox = Box((0,0,0), (1,1,0.5))\nrod = Cylinder((0.5, 0.5, -0.5),Z,0.2,1.5)\nrod.faces.name=\"contact1\"\nblock = box-rod\nblock.faces.Min(X).name=\"fix\"\nrod.faces.name=\"contact2\"\nrod.faces.Max(Z).name=\"force\"\nrod.faces.Min(Z).name=\"free\"\ngeo = Compound([block, rod])\nDrawGeo (geo);\nmesh = Mesh(OCCGeometry(geo).GenerateMesh(maxh=0.1)).Curve(3)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Visualize the Solution and Flux in Python\nDESCRIPTION: This snippet visualizes the solution `gfu` and its negative gradient (flux) on the mesh using the `Draw` function. This allows for visual inspection of the solution and its properties.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/poisson.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfu)\nDraw (-grad(gfu), mesh, \"Flux\")\n```\n\n----------------------------------------\n\nTITLE: Generate Mesh from Geometry - Python\nDESCRIPTION: This snippet generates a mesh from the defined geometry using the `GenerateMesh` method. The `maxh` parameter specifies the maximum desired mesh size. The resulting mesh can then be used for further analysis or simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh = geo.GenerateMesh (maxh=0.1)\n```\n\n----------------------------------------\n\nTITLE: Skeleton Formulation of C - Python\nDESCRIPTION: This code provides the skeleton formulation of the bilinear form `c` for the DG method. It includes volume integrals, inner facet integrals using the upwind flux, and boundary facet integrals.  It also shows an alternative implementation using named boundaries for inflow and outflow.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nc = BilinearForm(VT,nonassemble=True)\nc += -b * grad(v) * u * dx\nc += upw_flux * (v-v.Other()) * dskel_inner\n\nc += b*n * IfPos(b*n,u,ubnd) * v * dskel_bound\n#alternatively (if you know in/out beforehand):\n#c += b*n * ubnd * v * dskel_inflow\n#c += b*n * u * v * dskel_outflow\n```\n\n----------------------------------------\n\nTITLE: Algorithmic Linearization Term in ngsolve (Python)\nDESCRIPTION: This snippet computes the algorithmic linearization term, which accounts for the linearization of internal states. This term is added to the bilinear form to ensure consistent tangent stiffness in the Newton-Raphson scheme.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nlinearization_term = delta_eps * (dint_sigma * (dext_int * Delta_eps))\n```\n\n----------------------------------------\n\nTITLE: Defining Restricted Bilinear Form\nDESCRIPTION: This snippet defines a RestrictedBilinearForm, which is used for unfitted problems. It specifies the element and facet restrictions for the bilinear form.  The `check_unused` flag is set to `False` to suppress warnings related to unused elements in the integration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\na = RestrictedBilinearForm(V, element_restriction=els_hasneg, facet_restriction=facets_gp, check_unused=False)\n```\n\n----------------------------------------\n\nTITLE: Element-wise Post-processing Setup in NGSolve (Python)\nDESCRIPTION: This code snippet sets up the finite element spaces and forms for element-wise post-processing, which is a simpler scheme when GP stabilization has been used.  It defines FE spaces, trial and test functions, a bilinear form, and a linear form, which are then assembled and solved. The solution is stored in gfz.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n#FE Spaces for el-wise post-processing\nVhpbase = L2(mesh, order=order+1, dgjumps=False, dirichlet=[]) # order+1\nLhbase = L2(mesh, order=0, dgjumps=False, dirichlet=[])\n\nVhp = Restrict(Vhpbase, hasneg)\nLh = Restrict(Lhbase, hasneg)\nZh = Vhp * Lh\n\ngflh = GridFunction(Lh)\n\ngfz = GridFunction(Zh)\ngfps, gflam = gfz.components\n\n#Test- & Trialfunction\n(ps,lam),(vs,mu) = Zh.TnT()\n\n#Bilinear Form\np = RestrictedBilinearForm(Zh, symmetric=False)\np += grad(ps) * grad(vs) * dxbar\np += (lam * vs + mu * ps) * dxinner\np += (lam * vs + mu * ps) * ds\n\n# R.h.s. term:\npf = LinearForm(Zh)\npf += gfu * grad(vs) * dxbar\n\npf += p_exact * mu * ds\npf += gfpT * mu * dxinner\n\n#Assembly\np.Assemble()\npf.Assemble()\n\n#Solving the system\ngfz.vec.data = p.mat.Inverse(Zh.FreeDofs(),inverse=\"umfpack\") * pf.vec\n\n#For visualization:\ngflh.Set(p_exact, definedonelements=ci.GetElementsOfType(HASNEG))\ngflam.Set(gfps, definedonelements=ci.GetElementsOfType(HASNEG))\n```\n\n----------------------------------------\n\nTITLE: Solving Stokes with Discontinuous Pressure on Alfeld-Split Mesh\nDESCRIPTION: This snippet solves the Stokes equation with discontinuous pressure elements (P2-P1) on a sub-divided simplicial mesh using Alfeld splits. This stabilization technique allows the use of P2-P1 elements. The number of degrees of freedom for velocity and pressure are printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmesh2 = Mesh(geo.GenerateMesh(maxh=0.05)).Curve(3)\nmesh2.SplitElements_Alfeld()\nV = VectorH1(mesh2, order=2, dirichlet=\"wall|inlet|cyl\")\nQ = L2(mesh2, order=1)\nprint (\"V.ndof =\", V.ndof, \", Q.ndof =\", Q.ndof)\nX = V*Q\ngfu = SolveStokes(X)\n```\n\n----------------------------------------\n\nTITLE: Creating Chamfers on the Geometry\nDESCRIPTION: Finds edges between the box and cylinder and creates chamfers along these edges.  This step smooths the sharp corners and edges of the geometry. Requires OCC 7.4 or newer.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncylboxedges = geo.faces[\"outer\"].edges * geo.faces[\"cyl\"].edges\ncylboxedges.name = \"cylbox\"\ngeo = geo.MakeChamfer(cylboxedges, 0.03)\n```\n\n----------------------------------------\n\nTITLE: Assemble Matrix with Custom Assembling Function (NGSolve)\nDESCRIPTION: This snippet demonstrates the assembly of a matrix using a custom assembling function `MyAssembleMatrix` from the compiled C++ module `m`. It initializes timers, assembles the matrix using both the custom integrator `MyLaplace` and the built-in symbolic integrator, and compares the timings. The result is stored in `mymatrix`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npyngcore.ResetTimers()\nprint (\"num elements =\", mesh.ne, \", ndof =\", fes.ndof)\nwith TaskManager(pajetrace=10**8):\n    # using our integrator\n    mymatrix = m.MyAssembleMatrix(fes, m.MyLaplace(CF(1)), parallel=False)\n    \n    # using NGSolve built-in symbolic integrator\n    # mymatrix = m.MyAssembleMatrix(fes, (grad(u)*grad(v)*dx)[0].MakeBFI(), parallel=True)\n\n# print (\"my matrix = \", mymat)\n\nif fes.ndof < 100000:\n    gfu.vec.data = mymatrix.Inverse(fes.FreeDofs()) * f.vec\n    Draw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Space\nDESCRIPTION: This snippet defines the finite element space V as an H1 space with a specified polynomial order (k) and discontinuous jumps. A GridFunction gfu is created to store the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nk = 3\n\nV = H1(mesh, order=k, dgjumps=True)\ngfu = GridFunction(V)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Simulation - Python\nDESCRIPTION: This snippet imports necessary libraries for the simulation. `netgen.csg` is used for constructive solid geometry, `ngsolve` for finite element analysis, and `ngsolve.webgui` for visualization within a web browser.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/maxwell.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Assembling and solving the deformation equation\nDESCRIPTION: This code assembles the deformation bilinear form and linear form and then solves the deformation equation. The resulting deformation is visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nb.Assemble()\ndJOmegaAuto.Assemble()\nSolveDeformationEquationAuto()\nDraw(-gfX, mesh, \"-gfX\")\n```\n\n----------------------------------------\n\nTITLE: Operator Application - Python\nDESCRIPTION: This code demonstrates the operator application using the `BilinearForm` `c`, utilizing `c.mat * gfu.vec` for efficient computation without assembling the matrix. The result is stored in a new vector `res`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(VT) \n#Draw(gfu,mesh, settings = { \"subdivision\" : 10 },\n#     min=-0.1,max=2.1,autoscale=False)\n\n#Operator application (equivalent to assemble and mult but faster)\nres = gfu.vec.CreateVector()\nres.data = c.mat * gfu.vec \n```\n\n----------------------------------------\n\nTITLE: Initializing Hybrid Mixed Method Spaces in NGSolve (Python)\nDESCRIPTION: This code snippet initializes finite element spaces for a hybrid mixed method using NGSolve. It defines a VectorL2 space for the flux variable (sigma), L2 spaces for the scalar variables (Vt, Vf), and a mixed space V.  The piola=True argument indicates the use of Piola transformation for the VectorL2 space, suitable for mapping vector fields between physical and reference elements.  order specifies the polynomial order for the finite element spaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import unit_square\nfrom ngsolve.fem import MixedFE\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.3))\norder=1\nSigma = VectorL2(mesh, order=order, piola=True)\nVt = L2(mesh, order=order-1)\nVf = FacetFESpace(mesh, order=order)\nV = Vt*Vf\nsigma,tau = Sigma.TnT()\n(ut,uf), (vt,vf) = V.TnT()\n```\n\n----------------------------------------\n\nTITLE: Bilinear Form Assembly\nDESCRIPTION: This snippet assembles the bilinear form for the Euler equations. It includes terms for the interior elements, boundary terms, and numerical stabilization. It utilizes a matrix-free method, which minimizes the need to assemble the full matrix. It also calculates operators to pass information between elements on the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntruecompile = False\n\n(u,uhat), (v,vhat) = fes.TnT()\n# bfa1 = BilinearForm(fes, nonassemble=True)\n\nterm1a = InnerProduct (NumFlux(u, 2*uhat-u), v.Operator(\"normal\")).Compile(truecompile, wait=True)*dx(element_boundary=True)\nterm1b = (2*stab*v*(u-uhat)).Compile(truecompile, wait=True)*dx(element_vb=BND)\nterm2 = (-InnerProduct(Flux(u),Grad(v))).Compile(truecompile, wait=True)*dx\n\nbfa = BilinearForm (term1a+term1b+term2, nonlinear_matrix_free_bdb=True).Assemble()\n\nembT, embhat = fes.embeddings\nresT, reshat = fes.restrictions\nrangeT = fes.Range(0)\nrangehat = fes.Range(1)\n\ninvm1 = embT@fesT.Mass(1).Inverse()@embT.T\n# traceop = fesT.TraceOperator(feshat, average=True)\ntraceop = 0.5*fesT.TraceOperator(feshat, average=False)\ntraceop = traceop.CreateDeviceMatrix()\n\nuT, vT = fesT.TnT()\nwith TaskManager():\n    invm = BilinearForm(uT*vT*dx, diagonal=True).Assemble().mat.Inverse()\ninvm_host =  embT@invm@embT.T\ninvm = invm_host.CreateDeviceMatrix()\n\nprint(rangeT, rangehat)\n```\n\n----------------------------------------\n\nTITLE: Access MeshNode from NodeId\nDESCRIPTION: This snippet demonstrates how to access a `MeshNode` object from a `NodeId` object using the mesh. It retrieves coordinate information associated with the node. The snippet showcases accessing MeshNode object associated with a NodeId by indexing the mesh object with the NodeId.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmeshv = mesh[v]\nprint (\"type = \", type(meshv))\nprint (\"point = \", meshv.point)\n```\n\n----------------------------------------\n\nTITLE: Operator Splitting Setup\nDESCRIPTION: This code sets up the mass matrix with the added stiffness matrix scaled by the timestep (`mstar`), which is used for the implicit part of the operator splitting. It then calculates its inverse using UMFPACK.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nt = 0; tend = 0\ntau = 0.01; substeps = 10\n\nmstar = m.mat.CreateMatrix()\nmstar.AsVector().data = m.mat.AsVector() + tau * a.mat.AsVector()\ninv = mstar.Inverse(V.FreeDofs(), inverse=\"umfpack\")\n```\n\n----------------------------------------\n\nTITLE: Newton Solve with Damping\nDESCRIPTION: Solves stationary Navier-Stokes equation with very small viscosity. Damping has to be activated to achieve convergence.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nnu.Set(0.001)\ngfu.components[0].Set(CF((4*x*(1-x),0)),definedon=mesh.Boundaries(\"top\"))\nNewton(a,gfu,maxit=20,dampfactor=0.1)\nDraw(gfu.components[0],mesh, vectors = {\"grid_size\" : 25})\n```\n\n----------------------------------------\n\nTITLE: Analyzing Parallel Dofs in Python\nDESCRIPTION: This snippet retrieves and prints information about the parallel degrees of freedom. It iterates through local dofs and identifies the ranks that share them. It also prints the ranks with which the current process shares dofs and the dofs shared with each rank. This helps understand the connectivity of the distributed system.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.2-pardofs/pardofs.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n%%px\npardofs = fes.ParallelDofs()\nfor k in range(pardofs.ndoflocal):\n    print (\"dof\", k, \"is shard with ranks\", list(pardofs.Dof2Proc(k)))\n```\n\nLANGUAGE: python\nCODE:\n```\n%%px\nprint (\"I share dofs with ranks:\", list(pardofs.ExchangeProcs()))\nfor k in range(MPI.COMM_WORLD.size):\n    print (\"with rank\", k, \"I share dofs\", list(pardofs.Proc2Dof(k)))\n```\n\n----------------------------------------\n\nTITLE: Mesh Generation and Setup\nDESCRIPTION: This code snippet initializes the problem by importing necessary libraries (ngsolve, webgui, netgen), setting up the geometry using netgen.occ, and generating a mesh. The mesh is then curved to a specified order for higher accuracy.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\norder = 3\n# import libraries, set up geometry and generate mesh\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\nshape = Rectangle(2,0.41).Circle(0.2,0.2,0.05).Reverse().Face()\nshape.edges.name=\"cyl\"\nshape.edges.Min(X).name=\"inlet\"\nshape.edges.Max(X).name=\"outlet\"\nshape.edges.Min(Y).name=\"wall\"\nshape.edges.Max(Y).name=\"wall\"\nmesh = Mesh(OCCGeometry(shape, dim=2).GenerateMesh(maxh=0.07)).Curve(order)\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Conditions\nDESCRIPTION: This snippet sets the initial condition for the velocity field by solving a Stokes problem. It defines an inflow profile using a CoefficientFunction (uin) and sets it on the inlet boundary. It then solves the Stokes equations to obtain an initial velocity field.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(V)\n\nU0 = 1.5\nuin = CF( (U0*4*y*(0.41-y)/(0.41*0.41),0) )\ngfu.components[0].Set(uin, definedon=mesh.Boundaries(\"inlet\"))\n\ninvstokes = a.mat.Inverse(V.FreeDofs(), inverse=\"umfpack\")\ngfu.vec.data += invstokes @ -a.mat * gfu.vec\n```\n\n----------------------------------------\n\nTITLE: Solve and Visualize Scalar Minimization\nDESCRIPTION: Initializes a `GridFunction`, sets an initial guess, and calls the `SolveNonlinearMinProblem` function to solve the problem. It stores the current state using `cb` and prints final energy. It uses Draw for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(V)\ngfu.Set((x*(1-x))**4*(y*(1-y))**4) # initial guess\ngfu_it = GridFunction(gfu.space,multidim=0)\ncb = lambda gfu : gfu_it.AddMultiDimComponent(gfu.vec) # store current state\nSolveNonlinearMinProblem(a,gfu, callback = cb)\nprint (\"energy = \", a.Energy(gfu.vec))    \n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu,mesh,\"u\", deformation = True)\n#Draw(gfu_it,mesh,\"u\", deformation = True)\n```\n\n----------------------------------------\n\nTITLE: FETI-DP Setup and Solver Experiment - NGSolve/Python\nDESCRIPTION: This section demonstrates the setup and execution of a FETI-DP solver in NGSolve, incorporating functions to load meshes, set up the finite element space, configure the FETI-DP system, prepare the right-hand side, and solve the system. It also includes post-processing steps to analyze the solution and jump conditions. This comprehensive code segment allows for experimenting with different parameters and configurations of the FETI-DP solver to analyze its performance.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nimport netgen.meshing as ngmeshing\nfrom ngsolve.la import ParallelMatrix, FETI_Jump\nfrom dd_toolbox import FindFEV, LocGlobInverse, ScaledMat\n\ndef load_mesh(nref=0):\n    ngmesh = ngmeshing.Mesh(dim=3)\n    ngmesh.Load('cube.vol')\n    for l in range(nref):\n        ngmesh.Refine()\n    return Mesh(ngmesh)\n\ndef setup_space(mesh, order=1):\n    comm = MPI_Init()\n    fes = H1(mesh, order=order, dirichlet='right|top')\n    a = BilinearForm(fes)\n    u,v = fes.TnT()\n    a += SymbolicBFI(grad(u)*grad(v))\n    a.Assemble()\n    f = LinearForm(fes)\nf += SymbolicLFI(x*y*v)\n    f.Assemble()\n    avg_dof = comm.Sum(fes.ndof) / comm.size\n    if comm.rank==0:\n        print('global,  ndof =', fes.ndofglobal, ', lodofs =', fes.lospace.ndofglobal)\n        print('avg DOFs per core: ', avg_dof)\n    return [fes, a, f]\n\ndef setup_FETIDP(fes, a):\n    faces, edges, vertices = FindFEV(mesh.dim, mesh.nv, \\\n                                     fes.ParallelDofs(), fes.FreeDofs())\n    primal_dofs = BitArray([ v in set(vertices) for v in range(fes.ndof) ]) & fes.FreeDofs() \n    dp_pardofs = fes.ParallelDofs().SubSet(primal_dofs)\n    nprim = comm.Sum(sum([1 for k in range(fes.ndof) if primal_dofs[k] and comm.rank<fes.ParallelDofs().Dof2Proc(k)[0] ]))\n    if comm.rank==0:\n        print('# of global primal dofs: ', nprim)  \n    A_dp = ParallelMatrix(a.mat.local_mat, dp_pardofs)\n    dual_pardofs = fes.ParallelDofs().SubSet(BitArray(~primal_dofs & fes.FreeDofs()))\n    B = FETI_Jump(dual_pardofs, u_pardofs=dp_pardofs)\n    if comm.rank==0:\n        print('# of global multipliers = :', B.col_pardofs.ndofglobal)\n    A_dp_inv = LocGlobInverse(A_dp, fes.FreeDofs(), \n                              invtype_loc='sparsecholesky',\\\n                              invtype_glob='masterinverse')\n    F = B @ A_dp_inv @ B.T\n    innerdofs = BitArray([len(fes.ParallelDofs().Dof2Proc(k))==0 for k in range(fes.ndof)]) & fes.FreeDofs()\n    A = a.mat.local_mat\n    Aiinv = A.Inverse(innerdofs, inverse='sparsecholesky')\n    scaledA = ScaledMat(A, [1.0/(1+len(fes.ParallelDofs().Dof2Proc(k))) for k in range(fes.ndof)])\n    scaledBT = ScaledMat(B.T, [1.0/(1+len(fes.ParallelDofs().Dof2Proc(k))) for k in range(fes.ndof)])\n    Fhat = B @ A @ (IdentityMatrix() - Aiinv @ A) @ B.T\n    Fhat2 = B @ scaledA @ (IdentityMatrix() - Aiinv @ A) @ scaledBT\n    return [A_dp, A_dp_inv, F, Fhat, Fhat2, B, scaledA, scaledBT]\n    \ndef prep(B, Ainv, f):\n    rhs.data = (B @ Ainv) * f.vec\n    return rhs\n\ndef solve(mat, pre, rhs, sol):\n    t = comm.WTime()\n    solvers.CG(mat=mat, pre=pre, rhs=rhs, sol=sol, \\\n               maxsteps=100, printrates=comm.rank==0, tol=1e-6)\n    return comm.WTime() - t\n    \ndef post(B, Ainv, gfu, lam):\n    hv = B.CreateRowVector()\n    hv.data = f.vec - B.T * lam\n    gfu.vec.data = Ainv * hv\n    jump = lam.CreateVector()\n    jump.data = B * gfu.vec\n    norm_jump = Norm(jump)\n    if comm.rank==0:\n        print('\\nnorm jump u: ', norm_jump)   \n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh in NGSolve\nDESCRIPTION: This snippet initializes a mesh using NGSolve's unit_square and GenerateMesh functions. The maxh parameter controls the maximum mesh size. This sets up the geometry on which the finite element problem is to be solved.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.1))\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form with geom_free flag in NGSolve\nDESCRIPTION: This code defines a bilinear form for the hybrid mixed method, specifically highlighting the use of the `geom_free` flag. It sets up the finite element spaces for the vector field (Sigma) and the mixed variable (V), then defines the bilinear form using these spaces.  The `geom_free=False` setting impacts how the bilinear form is assembled, potentially affecting performance.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/examples/matrixfree.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\norder=5\nSetHeapSize(100*1000*1000)\nSigma = VectorL2(mesh, order=order, piola=True)\nVt = L2(mesh, order=order-1)\nVf = FacetFESpace(mesh, order=order, dirichlet=[2])\nV = Vt*Vf\nprint (\"Sigma.ndof =\", Sigma.ndof, \", V.ndof =\", V.ndof)\nsigma,tau = Sigma.TnT()\n(ut,uf), (vt,vf) = V.TnT()\n\nb = BilinearForm(trialspace=Sigma, testspace=V, geom_free=False)\nb += div(sigma) * vt * dx\nn = specialcf.normal(mesh.dim)\ndS = dx(element_boundary=True)\nb += -sigma*n*vf * dS\nb.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces for Post-processing in NGSolve (Python)\nDESCRIPTION: This snippet defines the finite element spaces required for element-wise post-processing, including spaces for the post-processed variable (Vhpbase), Lagrange multiplier (Lhbase), and their restrictions. It also creates GridFunctions to store the solutions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n#FE Spaces for el-wise post-processing\nVhpbase = L2(mesh, order=order+1, dgjumps=True, dirichlet=[]) # for p\nLhbase = L2(mesh, order=0, dgjumps=True, dirichlet=[])        # for integral constraints\nVhp = Restrict(Vhpbase, hasneg)\nLh = Restrict(Lhbase, ci.GetElementsOfType(NEG)) # one constraint per patch / root element\nZh = Vhp * Lh\n(ps,lam),(vs,mu) = Zh.TnT()\n\ngfz = GridFunction(Zh)\ngfps, gflam = gfz.components\n```\n\n----------------------------------------\n\nTITLE: Visualizing Results in NGSolve\nDESCRIPTION: This snippet visualizes the computed solution components (sigma and u) using the Draw function from NGSolve. This allows for visual inspection of the results.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.7-hybrid/hybrid.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfu.components[0], mesh, \"sigma\")\nDraw (gfu.components[1], mesh, \"u\");\n```\n\n----------------------------------------\n\nTITLE: Define Time-Stepping Parameters\nDESCRIPTION: This snippet defines the time step size (tau) and assembles the bilinear form for the implicit time-stepping scheme.  It also computes the sparse cholesky inverse.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntau = 0.001 # timestep\n\nmstar = BilinearForm(u*v*dx+tau*stokes).Assemble()\ninv = mstar.mat.Inverse(X.FreeDofs(), inverse=\"sparsecholesky\")\n```\n\n----------------------------------------\n\nTITLE: Solving Helmholtz Equation with PML\nDESCRIPTION: This snippet defines the finite element space, bilinear form, and linear form for the Helmholtz equation. It assembles the system and solves for the grid function `gfu`.  Robin boundary conditions are applied on the outer boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=4, complex=True)\nu = fes.TrialFunction()\nv = fes.TestFunction()\n\nomega = 10\n\na = BilinearForm(fes)\na += grad(u)*grad(v)*dx - omega**2*u*v*dx\na += -1j*omega*u*v*ds(\"outerbnd\")\na.Assemble()\n\nb = LinearForm(f * v * dx).Assemble()\n\ngfu = GridFunction(fes)\ngfu.vec.data = a.mat.Inverse() * b.vec\nDraw(gfu);\n```\n\n----------------------------------------\n\nTITLE: Generating Outer Normals (Python)\nDESCRIPTION: This snippet generates the outward pointing unit normal vectors for each section of the boundary of a domain defined by a compressed DomainTypeArray. It requires the level sets (as GridFunctions).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nnormals = z_disc2.GetOuterNormals(level_sets_p1)\nnormals\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear Forms with geom_free=True\nDESCRIPTION: This snippet assembles the bilinear forms Bel and Btr using volume contributions and couplings between the trace (obtained through the trace operator) and the volume, with the `geom_free=True` flag. This flag makes the integrals independent of the physical element. It then combines these forms using embedding operators to create the final bilinear form B.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nBel = BilinearForm(trialspace=fes_p, testspace=fes_u, geom_free = True)\nBel += grad(p)*v * dx -p*(v*n) * dx(element_boundary=True)\n%time Bel.Assemble()\n\nBtr = BilinearForm(trialspace=fes_tr, testspace=fes_u, geom_free = True)\nBtr += 0.5 * phat * (v*n) *dx(element_boundary=True)\n%time Btr.Assemble()\n\nB = emb_u @ (Bel.mat + Btr.mat @ traceop) @ emb_p.T\n```\n\n----------------------------------------\n\nTITLE: Mesh Refinement Setup for AMG in Python\nDESCRIPTION: This code snippet initializes a mesh and refines it, preparing it for use with AMG solvers. It also minimizes memory requirements by disabling edge and face tables. The `TaskManager` context ensures proper management of resources during mesh generation and refinement. The `netgen.meshing.Mesh.EnableTableClass` is crucial for memory optimization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.5-amg/amg.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.la import EigenValues_Preconditioner\n\n# minimize memory requirements by switching off tables which we don't need here\nimport netgen.meshing\nnetgen.meshing.Mesh.EnableTableClass(\"edges\", False)\nnetgen.meshing.Mesh.EnableTableClass(\"faces\", False)\n\nwith TaskManager():\n    mesh = Mesh(unit_cube.GenerateMesh(maxh=0.1))\n    for l in range(3): mesh.Refine()\n```\n\n----------------------------------------\n\nTITLE: Defining Space-Time Finite Element Space - Python\nDESCRIPTION: This snippet creates the finite element spaces needed for the space-time discretization. It first creates a mesh of the unit square, then defines a spatial finite element space `V` using `H1` elements of a specified order.  A time finite element space `tfe` is created using `ScalarTimeFE`, and the space-time finite element space `st_fes` is formed by taking the tensor product of `tfe` and `V`.  Dirichlet boundary conditions are applied to the spatial finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.05, quad_dominated=False))\n\nV = H1(mesh, order=order, dirichlet=\".*\")\ntfe = ScalarTimeFE(k_t)\nst_fes = tfe * V # tensor product of a space finite element space and a 1D finite element\n```\n\n----------------------------------------\n\nTITLE: Calculating the Right-Hand Side Coefficient - Python\nDESCRIPTION: This snippet calculates the coefficient for the right-hand side of the heat equation based on the exact solution. It takes the time derivative and second spatial derivatives of the exact solution and compiles the resulting expression for efficient evaluation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncoeff_f = u_exact.Diff(t) - (u_exact.Diff(x).Diff(x) + u_exact.Diff(y).Diff(y))\ncoeff_f = coeff_f.Compile()\n```\n\n----------------------------------------\n\nTITLE: Adding Interface Integrals to BilinearForm\nDESCRIPTION: This code adds the interface integrals to the bilinear form 'a' using the previously defined average fluxes and jumps. It implements the Nitsche formulation on the interface.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\na += (average_flux_u * jump_v + average_flux_v * jump_u + stab * jump_u * jump_v) * ds\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Mesh Size for a Curve (Python)\nDESCRIPTION: This snippet demonstrates how to set a maximum mesh size specifically for a curve using the `maxh` argument in `geo.Append`.  This allows for finer mesh control in specific regions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\n\np1,p2,p3,p4,p5,p6 = [geo.AppendPoint(*pnt) for pnt in pnts]\n\ngeo.Append([\"line\",p1,p2],maxh=0.02)\ngeo.Append([\"line\",p2,p4])\ngeo.Append([\"line\",p4,p6])\ngeo.Append([\"line\",p6,p1])\n\nngmesh = geo.GenerateMesh(maxh=0.2)#,quad_dominated=True)\nDraw (Mesh(ngmesh))\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear and Linear Forms for MITC in NGSolve\nDESCRIPTION: This snippet defines the bilinear and linear forms for the MITC method.  It sets up the variational formulation, including terms for bending and shear, incorporating the interpolation operator (Interpolate). It then defines a linear form corresponding to the applied force. Finally, it creates a GridFunction to store the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nGamma = HCurl(mesh,order=order,orderedge=order-1, autoupdate=True)\n\na = BilinearForm(fes)\na += t**3/12*(2*mu*InnerProduct(Sym(grad(beta)),Sym(grad(dbeta))) + lam*div(beta)*div(dbeta))*dx\n#a += t*k*G*InnerProduct( grad(u)-beta, grad(du)-dbeta )*dx\na += t*k*G*InnerProduct(Interpolate(grad(u)-beta,Gamma), Interpolate(grad(du)-dbeta,Gamma))*dx\n\nf = LinearForm(fes)\nf += -fz*du*dx\n\ngfsol = GridFunction(fes, autoupdate=True)\ngfbeta, gfu = gfsol.components\n```\n\n----------------------------------------\n\nTITLE: Performance Test on GPU\nDESCRIPTION: This snippet performs a performance test by running the time-stepping loop for a fixed number of steps and measuring the execution time. It prints the time per step.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nts = time()\nsteps = 10\nfor i in range(steps):\n    devu += op1 * devp\n    devp -= op2 * devu\nte = time()\nprint (\"ndof = \", gfp.space.ndof, \"+\", gfu.space.ndof, \", time per step =\", (te-ts)/steps)\n```\n\n----------------------------------------\n\nTITLE: Define Mesh and Finite Element Space (NGSolve)\nDESCRIPTION: This snippet defines a mesh on a unit square using `netgen.occ`. It then defines a finite element space `fes` using `H1` elements of order 1. The `dirichlet` parameter specifies Dirichlet boundary conditions on all boundaries. Test and trial functions `u` and `v` are created within the finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\nfes = H1(mesh, order=1, dirichlet=\".*\")\nu, v = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries\nDESCRIPTION: This snippet imports necessary modules from netgen.occ, ngsolve, and ngsolve.webgui. These modules provide functionalities for creating geometries, performing finite element analysis, and visualizing the results using Webgui.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Define Fichera Geometry using OCC\nDESCRIPTION: This snippet defines the Fichera geometry (a cube with a smaller cube removed) using the OCC (Open Cascade) module within Netgen.  It creates two boxes, subtracts one from the other, and marks edges for geometric refinement. It then visualizes the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwellevp.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\n\ncube1 = Box( (-1,-1,-1), (1,1,1) )\n\ncube2 = Box( (0,0,0), (2,2,2) )\ncube2.edges.hpref=1    # mark edges for geometric refinement\n\nfichera = cube1-cube2\n\nDraw (fichera);\n```\n\n----------------------------------------\n\nTITLE: Solve Poisson Problem with Multigrid and Condensation\nDESCRIPTION: This code iterates through polynomial orders from 1 to 9, solving the Poisson problem with the 'multigrid' preconditioner and static condensation enabled. The results (number of degrees of freedom and number of iterations) are printed for each polynomial order.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfor p in range(1,10):\n    r = SolveProblem(h=0.5, p=p, levels=4, condense=True, \n                     precond=\"multigrid\")\n    print (\"p=\", p, \": ndof,nsteps=\", r)       \n```\n\n----------------------------------------\n\nTITLE: Solving and Visualizing the Solution\nDESCRIPTION: This code solves the linear system `a.mat * gfu.vec = f.vec` using an inverse operation with consideration for free degrees of freedom and visualizes the solution. It retrieves the solution vector, splits it into components corresponding to the FEM and wave regions, and then visualizes the solution using a `MaterialCF` to map the solution components onto the mesh based on region.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs()) * f.vec\n\ngfu2 = mesh.MaterialCF( { \"fem.*\" : gfu.components[0], \"waves\" : gfu.components[1] })\nDraw (gfu2, mesh, animate_complex=True );\n```\n\n----------------------------------------\n\nTITLE: Solving transport problem\nDESCRIPTION: This snippet sets up and solves a transport problem on the rotating mesh. It defines finite element spaces for the concentration field and its trace, creates a transport operator, and defines a bilinear form with upwinding to stabilize the transport equation. It calculates wind velocity from mesh velocity and the gradient of the flow potential, solves a transport equation and draws.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfes = L2(mesh, order=3) \nu,v = fes.TnT()\n\nfeshat = FacetFESpace(mesh, order=3)\nuhat, vhat = feshat.TnT()\ntraceop = fes.TraceOperator(feshat, average=True)\n\nmesh.SetDeformation(MeshRotation(0))\n\nwind = -(meshVelocity - gfutgrad)\n\na = BilinearForm(fes) \na += -wind*u*grad(v)*dx\nuup = IfPos(wind*n, u, u.Other(bnd=0))\na += wind*n*uup*v * dx(element_boundary=True) # upwind\n\n\nahat = BilinearForm(feshat)\n\nf = LinearForm(fes)\nf.Assemble()\n\ngfu = GridFunction(fes)\ngfu.Set(exp(-10**2*((x-0.15)**2 +(y-0.5)**2)))\n\nsolveWind(gfut,at,ft)\nscene = Draw(gfu, min=0, max=2, order=3, autoscale=False)\n```\n\n----------------------------------------\n\nTITLE: Evolution Objective Definition in NGSolve\nDESCRIPTION: This snippet defines the evolution objective function using `Psi` and `Phi` for solving the internal variable `p` via `MinimizationCF`. It compiles the objective function for efficiency.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nevolution_objective = (Psi(p, strain(gfu), gfp_k, alpha_k) + Phi(p,gfp_k)).Compile(realcompile=realcompile)\n```\n\n----------------------------------------\n\nTITLE: Defining Forcing Term\nDESCRIPTION: This snippet defines the forcing term for the Poisson equation based on the exact solution.  A LinearForm `f` is constructed, and the forcing term is added using the `dx` integration measure, ensuring correct integration over the unfitted domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(V)\nf += 32 * (y * (1 - y) + x * (1 - x)) * v * dx\n```\n\n----------------------------------------\n\nTITLE: Estimating condition number with Symmetric GS\nDESCRIPTION: Estimates the condition number of the matrix preconditioned by the symmetric Gauss-Seidel preconditioner. It calls the EigenValues_Preconditioner function with the system matrix and the preGS preconditioner, then computes the ratio of the largest to the smallest eigenvalue.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nlams = EigenValues_Preconditioner(mat=a.mat, pre=preGS)\nmax(lams)/min(lams)\n```\n\n----------------------------------------\n\nTITLE: Creating Level Set Mesh Adaptation Object (Python)\nDESCRIPTION: This snippet creates an instance of the LevelSetMeshAdaptation_Spacetime class.  This class handles the isoparametric mapping required for higher-order accuracy in space and time.  Key parameters include the polynomial order in space and time for the level set approximation, a threshold for adaptation, and an indicator for discontinuous quadrature.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Space time version of Levelset Mesh Adapation object. Also offers integrator\n# helper functions that involve the correct mesh deformation\nlsetadap = LevelSetMeshAdaptation_Spacetime(mesh, order_space=k_s,\n                                            order_time=lset_order_time,\n                                            threshold=0.5,\n                                            discontinuous_qn=True)\n```\n\n----------------------------------------\n\nTITLE: Calculating Error Norms\nDESCRIPTION: This code calculates the L2 error norms for the scalar variable `u` and the flux `sigma`. It integrates the squared difference between the primal and mixed solutions over the mesh to quantify the error.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint (\"err-u:   \", sqrt(Integrate( (gfup-gfu)**2, mesh)))\nerrflux = lam * grad(gfup) - gfsigma\nprint (\"err-flux:\", sqrt(Integrate(errflux*errflux, mesh)))\n```\n\n----------------------------------------\n\nTITLE: Initial and Boundary Conditions Setup - Python\nDESCRIPTION: This snippet sets up the initial and boundary conditions for the shallow water simulation. It defines the trial and test functions, specifies the initial water height based on the 'upperlevel' and 'lowerlevel' regions, and sets up boundary conditions for the 'wall' and 'dam' boundaries, including zero flux conditions. A constant `g` is set for the gravitational force.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nU,V = fes.TnT() # \"Trial\" and \"Test\" function\nh, hu, hv = U\n\n# initial conditions\nh0mat = {\"upperlevel\" : 10, \"lowerlevel\" : 2}\nU0 = CF((mesh.MaterialCF(h0mat),0,0))\n\n# boundary conditions\nhbndreg = mesh.BoundaryCF({\"wall\" : h, \"dam\" : 0})\nhubndreg = mesh.BoundaryCF({\"wall\" : -hu, \"dam\" : 0})\nhvbndreg = mesh.BoundaryCF({\"wall\" : -hv, \"dam\" : 0})\n\nUbnd = CF((hbndreg,hubndreg,hvbndreg))\n\n# constant for gravitational force\ng=1\n```\n\n----------------------------------------\n\nTITLE: Creating the coil geometry\nDESCRIPTION: This code creates the 3D geometry of a coil using the OCC (Open Cascade CAD kernel) interface in Netgen. It defines geometric primitives like cylinders, segments, and Bezier curves to construct the coil shape. The faces are named for boundary conditions and the coil is assigned a material.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncyl = Cylinder((0,0,0), Z, r=0.01, h=0.03).faces[0]\nheli = Edge(Segment((0,0), (12*math.pi, 0.03)), cyl)\nps = heli.start\nvs = heli.start_tangent\npe = heli.end\nve = heli.end_tangent\n\ne1 = Segment((0,0,-0.03), (0,0,-0.01))\nc1 = BezierCurve( [(0,0,-0.01), (0,0,0), ps-vs, ps])\ne2 = Segment((0,0,0.04), (0,0,0.06))\nc2 = BezierCurve( [pe, pe+ve, (0,0,0.03), (0,0,0.04)])\nspiral = Wire([e1, c1, heli, c2, e2])\ncirc = Face(Wire([Circle((0,0,-0.03), Z, 0.001)]))\ncoil = Pipe(spiral, circ)\n\ncoil.faces.maxh=0.2\ncoil.faces.name=\"coilbnd\"\ncoil.faces.Max(Z).name=\"in\"\ncoil.faces.Min(Z).name=\"out\"\ncoil.mat(\"coil\")\ncrosssection = coil.faces.Max(Z).mass\n```\n\n----------------------------------------\n\nTITLE: Calculating Post-processed Error in NGSolve (Python)\nDESCRIPTION: This code calculates the L2 error of the post-processed solution `gfps` compared to the exact solution `p_exact`, integrating over the physical domain. The calculated error is then printed to the console.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nps_l2error = sqrt(Integrate((gfps - p_exact)**2*dX.order(2*order+3), mesh))\nprint(\"ps_l2error = \", ps_l2error)\n```\n\n----------------------------------------\n\nTITLE: Energy Density, Dissipation Potential, Evolution Equations in ngsolve (Python)\nDESCRIPTION: This code defines functions for the energy density, dissipation potential, and evolution equations in the elastoplastic model.  It computes the stress and hardening variables, and uses `IfPos` to solve the evolution equations only when the elastic trial state is beyond the yield surface.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Energy density\ndef Psi(strain, p, alpha):\n    strain_energy = elastic_strain_energy(strain-p)\n    hardening     = 1/2 * alpha**2\n    return strain_energy + hardening\n\n\n# The yield condition: result > 0 ==> plastic evolution\ndef yield_condition(sigma, beta, pert=0):\n    return tensor_norm(dev(sigma), pert=pert) - sqrt(2/3) * sigma_Y * (1 - H*beta)\n\n\n# The objective function defining the dissipation potential\ndef Phi_obj(sigma, beta, p_dot, alpha_dot, Lambda):\n    return InnerProduct(sigma, p_dot) + InnerProduct(beta, alpha_dot) - \\\n            Lambda * yield_condition(sigma, beta, pert=norm_pert)\n\n\n# The evolution equations\ndef evolution_eqs(strain, p, alpha, Lambda, evol_tol):\n    p_dot = (p - gfp_k) / Delta_t\n    alpha_dot = (alpha - gfalpha_k) / Delta_t\n    sigma = -Psi(strain, p, alpha).Diff(p)\n    sigma = sigma.MakeVariable()\n    beta = -Psi(strain, p, alpha).Diff(alpha)\n    beta = beta.MakeVariable()\n    _Phi_obj = Phi_obj(sigma, beta, p_dot, alpha_dot, Lambda)\n    \n    dsigma = _Phi_obj.Diff(sigma)\n    \n    # only active when there is hardening\n    dbeta = IfPos(H - 1e-16, _Phi_obj.Diff(beta), alpha_dot)\n    \n    dLambda = _Phi_obj.Diff(Lambda)\n\n    # Only solve the evolution equations if the elastic trial state is beyond the yield surface.\n    # This essentially leads to the fulfillment of Lambda >= 0\n    return IfPos(yield_condition(gfsigma_trial, gfbeta_trial) - evol_tol, \n                 CF((dsigma, dbeta, dLambda)),\n                 CF((p_dot, alpha_dot, Lambda - gfLambda_k)))\n```\n\n----------------------------------------\n\nTITLE: Visualizing Grid Function and Gradient in NGSolve\nDESCRIPTION: This snippet creates a GridFunction on the finite element space and sets its values according to a given function (x*x*y*y). It then visualizes the GridFunction and the x-component of its gradient using `Draw`.  This allows for visual inspection of the solution and its derivatives.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ngfu = GridFunction(fes)\ngfu.Set(x*x*y*y)\n\nDraw (gfu)\nDraw (grad(gfu)[0], mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Geometry using Netgen CSG (Python)\nDESCRIPTION: This code defines a complex 3D geometry using the Netgen CSG (Constructive Solid Geometry) module. It creates a sphere and subtracts several cylinders and another sphere to create a complex shape.  The geom.GenerateMesh(maxh=25) generates a mesh of the defined geometry with a maximum element size of 25. mesh.Curve(5) applies a curved representation to the mesh, increasing the approximation order to 5.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\ngeom = CSGeometry()\ngeom.Add (Sphere(Pnt(50,50,50),80) \\\n          -Cylinder(Pnt(-100,0,0),Pnt(200,0,0), 40) \\\n          -Cylinder(Pnt(100,-100,100),Pnt(100,200,100),40)\n          -Cylinder(Pnt(0,100,-100), Pnt(0,100,200),40)\n          -Sphere(Pnt(50,50,50),50))\n# geom.Draw()\n\nmesh = Mesh(geom.GenerateMesh(maxh=25))\nmesh.Curve(5)\n# Draw (mesh)\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation with Block Smoother\nDESCRIPTION: This snippet demonstrates solving the Poisson equation using a block smoother preconditioner. It sets up the finite element space, assembles the bilinear and linear forms, creates the block smoother, and solves the system using the CG solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=5, dirichlet=\".*\")\nprint (\"ndof =\", fes.ndof)\n\nu, v = fes.TnT()\nwith TaskManager():\n    a = BilinearForm(grad(u)*grad(v)*dx+u*v*dx).Assemble()\n    f = LinearForm(x*v*dx).Assemble()\n\ngfu = GridFunction(fes)\n\njac = a.mat.CreateBlockSmoother(fes.CreateSmoothingBlocks())\nlospace = fes.lospace\nloinv = a.loform.mat.Inverse(inverse=\"sparsecholesky\", freedofs=lospace.FreeDofs())\nloemb = fes.loembedding\n\npre = jac + loemb@loinv@loemb.T\nprint (\"mat\", a.mat.GetOperatorInfo())\nprint (\"preconditioner:\") \nprint(pre.GetOperatorInfo())\n\nwith TaskManager(): \n    inv = CGSolver(a.mat, pre, maxsteps=2000, printrates=False)\n    ts = time()\n    gfu.vec.data = inv * f.vec\n    te = time()\n    print (\"iterations =\", inv.GetSteps(), \"time =\", te-ts) \n```\n\n----------------------------------------\n\nTITLE: Initializing Implicit Euler SDIRK Method in Python\nDESCRIPTION: This code snippet defines the implicit Euler method, a first-order SDIRK method, within a Python class. It initializes the Butcher tableau coefficients, including the 'a' (stage coefficients), 'b' (weights), and 'c' (nodes) arrays, as well as the 'astar' value. The `stages` variable defines the number of stages in the method.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.1-parabolic/parabolic.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass sdirk1: #order 1 (implicit Euler)\n    stages = 1\n    a = [[1]]\n    b = [1]\n    c = [1]\n    astar = 1\n```\n\n----------------------------------------\n\nTITLE: Defining Neo-Hookean Material Model and Dynamic Contact Condition - Python\nDESCRIPTION: This code defines the material properties and sets up a Neo-Hookean material model for the dynamic contact problem. It defines the finite element space, bilinear form, force, grid functions, and the contact boundary. An energy-based contact formulation is added.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nE, nu = 210e6, 0.2\nrho = 7e3\nmu  = E / 2 / (1+nu)\nlam = E * nu / ((1+nu)*(1-2*nu))\n\nI = Id(mesh.dim)\n\ndef C(u): \n    F = I+Grad(u)\n    return F.trans*F\ndef NeoHooke (C):\n    return 0.5 * mu * (Trace(C-I) + 2*mu/lam * Det(C)**(-lam/2/mu) - 1)\n\nfes = VectorH1(mesh, order=3, dirichlet=\"fix\")\nu,v = fes.TnT()\n\nforce = CF((0,-9.81*rho))\n\nuold = GridFunction(fes)\nunew = GridFunction(fes)\nvel = GridFunction(fes)\nanew = GridFunction(fes)\naold = GridFunction(fes)\n\ntau = 2e-4\n\nbfmstar = BilinearForm(fes)\nbfmstar += Variation( NeoHooke (C(u)).Compile(False)*dx )\nbfmstar += Variation( -force*u*dx )\nbfmstar += Variation( rho/2* 2/tau**2 * (u-uold-tau*vel-tau**2/4*aold)**2 * dx )\n\ntend = 1\n\nscene = Draw (unew, mesh, \"disp\", deformation=unew)\n\nt = 0\nunew.Set( (0,0) )\nvel.Set( (0,0) )\ncontact = ContactBoundary(mesh.Boundaries(\"contact|balls\"), mesh.Boundaries(\"contact|balls\"))\n\nX = CoefficientFunction((x,y))\n\nif True:\n    cf = (X + u-uold - (X.Other() + u.Other() - uold.Other())) * (-specialcf.normal(2).Other())\n    # cf = (X + u-uold)*specialcf.normal(2) + \\\n    #    (X.Other() + u.Other() - uold.Other()) * specialcf.normal(2).Other()\n    contact.AddEnergy(IfPos(cf, 1e9*cf*cf, 0), deformed=True)\nelse:\n    cf = (X + u - (X.Other() + u.Other())) * contact.normal\n    contact.AddEnergy(IfPos(cf, 1e9*cf*cf, 0), deformed=False)\n```\n\n----------------------------------------\n\nTITLE: Performing Gauss-Seidel smoothing\nDESCRIPTION: This code performs Gauss-Seidel smoothing iteratively using the `preJpoint.Smooth()` method. It initializes the grid function `gfu.vec` to zero, creates residual and projected residual vectors, and then iterates 500 times, applying one step of Gauss-Seidel smoothing in each iteration. The residual norm is printed in each iteration, and the solution is visualized using `Draw(gfu)`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngfu.vec[:] = 0\nres = f.vec.CreateVector()              # residual \nprojres = f.vec.CreateVector()          # residual projected to freedofs\nproj = Projector(fes.FreeDofs(), True)\n\nfor i in range(500):\n    preJpoint.Smooth(gfu.vec, f.vec)    # one step of point Gauss-Seidel\n    res.data = f.vec - a.mat*gfu.vec      \n    projres.data = proj * res\n    print (\"it#\", i, \", res =\", Norm(projres))\nDraw (gfu)\n```\n\n----------------------------------------\n\nTITLE: Convection Operator Definition\nDESCRIPTION: This snippet defines the convection operator using standard upwinding. It calculates the upwind flux based on the normal velocity and uses it in the bilinear form. The H(div)-conforming velocity from the HDG space is used as the advection velocity.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nvel = gfu.components[0]\nconvL2 = BilinearForm( (-InnerProduct(Grad(vL2) * vel, uL2)) * dx, nonassemble=True )\nun = InnerProduct(vel,n)\nupwindL2 = IfPos(un, un*uL2, un*uL2.Other(bnd=uin))\n\ndskel_inner  = dx(skeleton=True)\ndskel_bound  = ds(skeleton=True)\n\nconvL2 += InnerProduct (upwindL2, vL2-vL2.Other()) * dskel_inner\nconvL2 += InnerProduct (upwindL2, vL2) * dskel_bound\n```\n\n----------------------------------------\n\nTITLE: Define Jump Terms and Mean Derivatives in NGSolve\nDESCRIPTION: This snippet defines jump terms and mean derivatives for the discontinuous Galerkin method. It calculates the jump of the solution `u` and test function `v` across element boundaries, and computes the average of the normal derivatives of `u` and `v` using the `Other()` operator to access values from neighboring elements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\njump_u = u-u.Other()\njump_v = v-v.Other()\nn = specialcf.normal(2)\nmean_dudn = 0.5*n * (grad(u)+grad(u.Other()))\nmean_dvdn = 0.5*n * (grad(v)+grad(v.Other()))\n```\n\n----------------------------------------\n\nTITLE: Creating a rectangle on a workplane\nDESCRIPTION: This snippet demonstrates how to create a rectangle on a workplane in ngsolve. It initializes a WorkPlane object, draws a rectangle of specified width and height, and then creates a Face object from the workplane. Finally, it uses DrawGeo to visualize the face.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/workplane.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwp = WorkPlane()\nwp.Rectangle(5,2)\nface = wp.Face()\nDrawGeo(face);\n```\n\n----------------------------------------\n\nTITLE: Interpolating a CoefficientFunction into a Finite Element Space\nDESCRIPTION: This snippet demonstrates how to interpolate a CoefficientFunction into a finite element space using a `GridFunction`. It creates a finite element space `fes`, a `GridFunction` `u`, and then sets `u` to the values of `myfunc`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=1)\nu = GridFunction(fes)\nu.Set(myfunc)\nDraw(u); \n```\n\n----------------------------------------\n\nTITLE: Variational Formulation of Naghdi Shell Model (Python)\nDESCRIPTION: This snippet sets up the bilinear form for the Naghdi shell model, including membrane, bending, and shear energy terms. It calculates strain tensors, defines the bilinear form using `BilinearForm`, and adds variational terms corresponding to the energy components.  An external force is also defined using a `Parameter`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nPtau = Id(3) - OuterProduct(nsurf,nsurf)\nFtau = Grad(u).Trace() + Ptau\nCtautau = Ftau.trans * Ftau\nEtautau = 0.5*(Ctautau - Ptau)\n\neps_beta = Sym(Ptau*Grad(beta).Trace())\ngradu = Grad(u).Trace()\nngradu = gradu.trans*nsurf\n#Average normal vector for affine geometry\nif order == 1:\n    gfn = GridFunction(fes1)\n    gfn.Set(nsurf,definedon=mesh.Boundaries(\".*\"))\nelse:\n    gfn = nsurf\n\na = BilinearForm(fes, symmetric=True)\n#membrane energy\na += Variation( thickness*InnerProduct(Etautau, Etautau)*ds )\n#bending energy\na += Variation( 0.5*thickness**3*InnerProduct(eps_beta-Sym(gradu.trans*Grad(gfn)),eps_beta-Sym(gradu.trans*Grad(gfn)))*ds )\n#shearing energy\na += Variation( thickness*(ngradu-beta)*(ngradu-beta)*ds )\n\n# external force\nfactor = Parameter(0.0)\na += Variation( -thickness*factor*y*u[1]*ds )\n\ngfu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Defining a LinearForm with integration on regions\nDESCRIPTION: This snippet demonstrates how to define a `LinearForm` that involves integration over both a subdomain (inner) and a boundary segment (t).  The `dx` and `ds` objects are used to define volume and surface integrals, respectively, with the `definedon` parameter specifying the integration region.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nterm1 = u1 * v * dx(definedon=mesh.Materials(\"inner\")) \nterm2 = 0.1 * v * ds(definedon=mesh.Boundaries(\"t\"))\nf = LinearForm(term1 + term2).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Drawing Post-processed Solution in NGSolve (Python)\nDESCRIPTION: This code draws the post-processed solution `gfps` on the physical domain using `DrawDC`, with deformation applied. It sets the minimum and maximum values for the color scale to -1 and 1, respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(lsetp1,gfps,-1,mesh,\"p\",deformation=deformation, min=-1, max=1)\n```\n\n----------------------------------------\n\nTITLE: Add Circle Shape - Python\nDESCRIPTION: This snippet adds a circle to the geometry using the `AddCircle` method. It specifies the center `c`, radius `r`, and the domain numbers left and right of the circle's boundary. It simplifies circle creation compared to defining points and splines manually.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ngeo.AddCircle(c=(5,0), r=0.5, leftdomain=2, rightdomain=1)\n```\n\n----------------------------------------\n\nTITLE: Frequency-Wave Number Relationship - Python\nDESCRIPTION: This snippet computes the frequency-wave number relationship using the reduced basis. It loops through different frequencies, sets the parameter omega, solves the projected eigenvalue problem using the reduced basis, and stores the real and imaginary parts of the eigenvalues corresponding to wave number and attenuation and the frequency, filtering according to certain criteria.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfs = []\nks =[]\nksi =[]\n\nA1m = InnerProduct(Qred, a1.mat*Qred, conjugate = True)\nA2m = InnerProduct(Qred, a2.mat*Qred, conjugate = True)\nBm = InnerProduct(Qred, b.mat*Qred, conjugate = True)\nCm = InnerProduct(Qred, c.mat*Qred, conjugate = True)\n\nfor fi in np.linspace(0, 0.7, 1000): \n    # print (\"fi =\", fi)\n    omega.Set(2*math.pi*fi)\n    Am = A1m - omega.Get()**2 * A2m\n    lamsred, vecsred = SolveProjectedSmall(Am, Bm, Cm)\n    \n    for lamred in lamsred:\n        if abs(lamred.real) < 2 and lamred.imag >= 0 and lamred.imag < 6.29:\n            fs.append(fi)\n            ks.append(lamred.imag)\n            ksi.append(lamred.real)\n```\n\n----------------------------------------\n\nTITLE: Visualize Time Evolution\nDESCRIPTION: This snippet visualizes the time evolution of the solution using the multidimensional GridFunction gfut. It interpolates between the time steps and creates an animation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfut, mesh, interpolate_multidim=True, animate=True, min=0, max=2, autoscale=False);\n```\n\n----------------------------------------\n\nTITLE: Taking the complement of a region\nDESCRIPTION: This snippet demonstrates taking the complement of a region using the ~ operator. The resulting region contains all elements that are *not* in the original region. The mask of the complement region is then printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nc = ~mesh.Materials(\"inner\")\nprint(c.Mask())\n```\n\n----------------------------------------\n\nTITLE: Solve HDG System in NGSolve\nDESCRIPTION: This snippet solves the HDG system, handling both condensed and uncondensed cases. If `condense` is False, it directly inverts the matrix. Otherwise, it applies static condensation, solves the reduced system, and reconstructs the full solution. Finally, the solution is visualized using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nif not condense:\n    inv = a.mat.Inverse(fes.FreeDofs(), \"umfpack\")\n    gfu.vec.data = inv * f.vec\nelse:\n    fmod = (f.vec + a.harmonic_extension_trans * f.vec).Evaluate()\n    \n    inv = a.mat.Inverse(fes.FreeDofs(True), \"umfpack\")\n    gfu.vec.data = inv * fmod\n    \n    gfu.vec.data += a.harmonic_extension * gfu.vec\n    gfu.vec.data += a.inner_solve * f.vec\n\nDraw (gfu.components[0], mesh, \"u-HDG\");\n```\n\n----------------------------------------\n\nTITLE: Setting Parameters and Defining Tangential Projection\nDESCRIPTION: This code sets the viscosity parameter and defines a function to calculate the tangential projection of a vector onto the mesh's surface. The normal vector is obtained using specialcf.normal.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnu = 0.001 # viscosity\nn = specialcf.normal(mesh.dim)\nh = specialcf.mesh_size\ndef tang(vec):\n    return vec - (vec*n)*n\n```\n\n----------------------------------------\n\nTITLE: Assemble Bilinear Forms and Solve Eigenvalue Problem with PINVIT\nDESCRIPTION: This snippet assembles the bilinear forms, constructs the gradient matrix for the Poisson projection, and then solves the Maxwell eigenvalue problem using the PINVIT solver. The Poisson projection enforces orthogonality to gradient fields.  It also sets up and uses the operator algebra.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwellevp.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n    a.Assemble()\n    m.Assemble()\n    apre.Assemble()\n\n    # build gradient matrix as sparse matrix (and corresponding scalar FESpace)\n    gradmat, fesh1 = fes.CreateGradient()\n    \n    \n    gradmattrans = gradmat.CreateTranspose() # transpose sparse matrix\n    math1 = gradmattrans @ m.mat @ gradmat   # multiply matrices \n    math1[0,0] += 1     # fix the 1-dim kernel\n    invh1 = math1.Inverse(inverse=\"sparsecholesky\")\n\n    # build the Poisson projector with operator Algebra:\n    proj = IdentityMatrix() - gradmat @ invh1 @ gradmattrans @ m.mat\n\n    projpre = proj @ pre.mat\n\n    evals, evecs = solvers.PINVIT(a.mat, m.mat, pre=projpre, num=12, maxit=20)\n```\n\n----------------------------------------\n\nTITLE: Solve with CG for Projected MG - Python\nDESCRIPTION: This snippet demonstrates how to solve a linear system using a conjugate gradient solver (`CGSolver`) with the `ProjectedMG` preconditioner.  It defines a linear form, a grid function to hold the solution, and then applies the conjugate gradient solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(1*v*dx).Assemble()\ngfu = GridFunction(fes)\nfrom ngsolve.krylovspace import CGSolver\ninv = CGSolver(mat=a.mat, pre=pre, printrates=True)\ngfu.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Values for Phase-Field Simulation in NGSolve\nDESCRIPTION: This snippet initializes the `gfu` GridFunction with an initial condition. The initial condition can be a simple sine function or a more complex, essentially random function. It also initializes a multi-dimensional GridFunction gfu_t to store time samples.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom math import pi\ngfu = GridFunction(V)\n#gfu.Set(sin(2*pi*x)) # regular initial values\ngfu.Set(sin(1e7*(x+y*y))) #<- essentially a random function\ngfu_t = GridFunction(V, multidim=0)\ngfu_t.AddMultiDimComponent(0.1*gfu.vec)\n```\n\n----------------------------------------\n\nTITLE: Defining and interpolating level set functions\nDESCRIPTION: This snippet defines three level set functions representing an isosceles triangle and interpolates them onto P1 finite element spaces. The interpolated level set functions are stored in a tuple of `GridFunction` objects and visualized using `DrawDC`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nlevel_sets = (y-1, 2*x-y, -2*x-y)\nnr_ls = len(level_sets)\nlevel_sets_p1 = tuple(GridFunction(H1(mesh, order=1)) for i in range(nr_ls))\n\nfor i, lset_p1 in enumerate(level_sets_p1):\n    InterpolateToP1(level_sets[i], lset_p1)\n    DrawDC(lset_p1, -3.5, 2.5, mesh, \"lset_p1_{}\".format(i))\n```\n\n----------------------------------------\n\nTITLE: PropagateConvection Class Definition\nDESCRIPTION: This class defines a custom `BaseMatrix` to solve the convection problem using explicit Euler steps. It projects the HDG solution to an L2 space, performs several explicit Euler steps, and then returns the result.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass PropagateConvection(BaseMatrix):\n    def __init__(self,tau,steps):\n        super(PropagateConvection, self).__init__()\n        self.tau = tau; self.steps = steps\n        self.h = V.ndof; self.w = V.ndof # operator domain and range\n        self.mL2 = VL2.Mass(Id(mesh.dim)); self.invmL2 = self.mL2.Inverse()\n        self.vecL2 = bfmixed.mat.CreateColVector() # temp vector\n    def Mult(self, x, y):\n        self.vecL2.data = self.invmL2 @ bfmixed.mat * x # <- project from Hdiv to L2\n        for i in range(self.steps):\n            self.vecL2.data -= self.tau/self.steps * self.invmL2 @ convL2.mat * self.vecL2\n        y.data = bfmixedT.mat * self.vecL2\n    def CreateColVector(self):\n        return CreateVVector(self.h)\n```\n\n----------------------------------------\n\nTITLE: Defining and drawing the background mesh - Python\nDESCRIPTION: This snippet defines a square geometry using SplineGeometry from netgen and generates a mesh. The mesh is then visualized using the Draw function from ngsolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsquare = SplineGeometry()\nsquare.AddRectangle([-1.5,-1.5], [1.5,1.5], bc=1)\nmesh = Mesh(square.GenerateMesh(maxh=0.8, quad_dominated=False))\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Generating HCurl Space\nDESCRIPTION: This snippet generates an HCurl (H(curl)) finite element space on the mesh.  It sets the order of the space to 2 and creates a `GridFunction` to represent solutions within this space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfes = HCurl(mesh, order=2)\nuc = GridFunction(fes, name=\"uc\")\n```\n\n----------------------------------------\n\nTITLE: Solving state equation at new design\nDESCRIPTION: This code solves the state equation at the new design after the mesh has been deformed. It resets the state GridFunction 'gfu' to zero and calls Newton's method. Finally, the cost at this new design is printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ngfu.vec[:]=0\nNewton(aAuto, gfu, fes.FreeDofs())\nprint('Cost at new design', Integrate (CostAuto2(gfu), mesh))\n```\n\n----------------------------------------\n\nTITLE: Refine Mesh and Update Preconditioner - Python\nDESCRIPTION: This snippet refines the mesh iteratively and updates the preconditioner at each level. It also calculates and prints the condition number of the preconditioned system using `EigenValues_Preconditioner`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfor l in range(9):\n    mesh.Refine()\n    a.Assemble()\n    pre = MLPreconditioner(fes,l+1, a.mat, pre)    \n    lam = EigenValues_Preconditioner(a.mat, pre)\n    print(\"ndof=%7d:  minew=%.4f  maxew=%1.4f  Cond# = %5.3f\" \n          %(fes.ndof, lam[0], lam[-1], lam[-1]/lam[0]))\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Solution\nDESCRIPTION: This snippet defines the exact solution and its gradient, and then visualizes the computed solution using DrawDC, overlayed on the indicator function of the active domain. This allows the user to inspect the quality of the numerical solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nu_ex = 16 * x * (1 - x) * y * (1 - y)\ngrad_u_ex = CoefficientFunction((16 * (1 - 2 * x) * y * (1 - y), \n                                 16 * x * (1 - x) * (1 - 2 * y)))\nDrawDC(square.Indicator(level_sets_p1), 0, gfu, mesh, \"solution\")\n```\n\n----------------------------------------\n\nTITLE: Variational Formulation of Koiter Shell Model (Python)\nDESCRIPTION: This snippet defines the bilinear form `bfA` for the Koiter shell model. It incorporates terms for membrane energy, bending energy (using either Etautau or C depending on whether Regge interpolation is used), and boundary terms involving the hybrid variable `hyb`. A load parameter `par` is used to apply an external moment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nbfA = BilinearForm(fes, symmetric=True, condense=True)\nbfA += Variation( (-6/thickness**3*MaterialNormInv(sigma, E, nu)                    + InnerProduct(sigma, Hn + (1-nphys*nsurf)*gradn))*ds ).Compile()\nif regge:\n    bfA += Variation( 0.5*thickness*MaterialNorm(C, E, nu)*ds )\n    bfA += Variation( InnerProduct(C-Etautau, R)*ds(element_vb=BND) )\n    bfA += Variation( InnerProduct(C-Etautau, R)*ds(element_vb=VOL) )\nelse:\n    bfA += Variation( 0.5*thickness*MaterialNorm(Etautau, E, nu)*ds )\nbfA += Variation( -(acos(nel*cfnR)-acos(nelphys*pnaverage)-hyb*nel)*(sigma*nel)*nel*ds(element_boundary=True) ).Compile()\npar = Parameter(0.0)\nbfA += Variation( -par*moment*(hyb*nel)*ds(element_boundary=True) )\n```\n\n----------------------------------------\n\nTITLE: Calculate Element Matrix with Custom Integrator (NGSolve)\nDESCRIPTION: This snippet demonstrates how to calculate the element matrix for a specific element using the custom integrator `MyLaplace`. It retrieves the finite element object `fes.GetFE(ei)` and the transformation `mesh.GetTrafo(ei)` for the element `ei`. These are then passed to `CalcElementMatrix` to compute the element matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmylap = m.MyLaplace(1)\nei = ElementId(VOL,17)\nmylap.CalcElementMatrix(fes.GetFE(ei), mesh.GetTrafo(ei))\n```\n\n----------------------------------------\n\nTITLE: Creating Geometry and Mesh\nDESCRIPTION: This code defines the geometry consisting of an air region (circle) and a scatterer (rectangle), then generates a mesh.  The `air` and `scatterer` are combined using boolean operations, and edge names are assigned for later use in boundary conditions. The `maxh` parameter controls the mesh size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/helmholtz.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nair = Circle((0.5, 0.5), 0.8).Face()\nair.edges.name = 'outer'\nscatterer = MoveTo(0.7, 0.3).Rectangle(0.05, 0.4).Face()\nscatterer.edges.name = 'scat'\ngeo = OCCGeometry(air - scatterer, dim=2)\nmesh = Mesh(geo.GenerateMesh(maxh=0.05))\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces\nDESCRIPTION: This code defines the finite element spaces.  `fesfem` is a standard H1 space defined on the 'fem' region with Dirichlet boundary conditions on the 'dir' boundaries. `feswaves` is a `GlobalSpace` defined on 'waves', using the previously defined plane waves as basis functions. An operator 'dn' is added to `feswaves` to represent the normal derivative of the basis functions. The code then creates a mixed finite element space `fes` combining `fesfem` and `feswaves`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.comp import GlobalSpace\n\nfesfem = H1(mesh, order=4, definedon=\"fem.*\", dirichlet=\"dir\", complex=True)\nprofile=sin(pi*y)\nfeswaves = GlobalSpace (mesh, definedon=\"waves\", basis = shapes) \nfeswaves.AddOperator(\"dn\", BND, dshapesx) \nfes = fesfem*feswaves\n```\n\n----------------------------------------\n\nTITLE: Print Eigenvalues\nDESCRIPTION: This snippet prints the computed eigenvalues to the console.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwellevp.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint (\"Eigenvalues\")\nfor lam in evals: \n    print (lam)\n```\n\n----------------------------------------\n\nTITLE: Getting Facets for Ghost Penalty Stabilization\nDESCRIPTION: This snippet retrieves facets needed for ghost penalty stabilization using the GetFacetsWithNeighborTypes function. It identifies facets where one neighbor is inside the domain and the other is on the boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfacets_gp = GetFacetsWithNeighborTypes(mesh, a=els_hasneg, b=els_if, \n                                       use_and=True)\n\nfreedofs = GetDofsOfElements(V, els_hasneg) & V.FreeDofs()\n```\n\n----------------------------------------\n\nTITLE: Defining Weak Form Parameters\nDESCRIPTION: This snippet defines parameters for the weak form, including the penalty parameters gamma_n and gamma_s, the trial and test functions u and v, and the mesh size function h.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngamma_n = 10\ngamma_s = 0.5\n\nu, v = V.TnT()\nh = specialcf.mesh_size\n```\n\n----------------------------------------\n\nTITLE: Solve Stokes Problem\nDESCRIPTION: This snippet solves the Stokes problem using the assembled bilinear form and linear form. It computes the inverse of the stiffness matrix and applies it to the residual to update the GridFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ninv_stokes = a.mat.Inverse(X.FreeDofs())\n\nres = f.vec - a.mat*gfu.vec\ngfu.vec.data += inv_stokes * res\n\nDraw (gfu.components[0], mesh);\n```\n\n----------------------------------------\n\nTITLE: Define Linear Form for Right-Hand Side in NGSolve\nDESCRIPTION: This snippet defines a linear form representing the right-hand side of the equation. It integrates a constant function (1) multiplied by the test function `v` over the domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(1*v*dx).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Evaluating Convergence Rate of Custom FESpace in NGSolve\nDESCRIPTION: This code snippet evaluates the convergence rate of the custom finite element space. It loops through different polynomial orders `p`, creates a corresponding FESpace, projects a smooth function onto it, calculates the error, and stores the order and error in a list. The error is computed as the L2 norm of the difference between the exact solution and the finite element solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nerrlist = []\nfor p in range(1,13):\n    fes = m.MyHighOrderFESpace(mesh, order=p)\n    func = sin(pi*x)*sin(pi*y)\n    gfu = GridFunction(fes)\n    gfu.Set(func)\n    err = sqrt(Integrate( (func-gfu)**2, mesh, order=5+2*p))\n    errlist.append((p,err))\nprint (errlist)\n```\n\n----------------------------------------\n\nTITLE: Explicit Euler Time Stepping Loop - Python\nDESCRIPTION: This snippet implements the explicit Euler time-stepping scheme to solve the shallow water equations. The TimeLoop function takes the bilinear form `a`, the grid function `gfu`, the time step size `dt`, and the total time `T` as inputs. It iterates through the time steps, updating the solution at each step using `gfu.vec.data -= dt * res`.  The code includes visualization updates during the time loop.  The `multidim_draw` option enables storage of solution at different time steps for animation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef TimeLoop(a,gfu,dt,T,nsamplings=100,scenes=scenes,multidim_draw=False,md_nsamplings=20):\n    if multidim_draw:\n        gfu_t = GridFunction(gfu.space,multidim=True)\n    #gfu.Set(U0)\n    res = gfu.vec.CreateVector()\n    fes = a.space\n    t = 0; i = 0\n    nsteps = int(ceil(T/dt))    \n    invma = fes.Mass(1).Inverse() @ a.mat\n    if multidim_draw:\n        gfu_t.AddMultiDimComponent(gfu.vec)\n    with TaskManager():\n        while t <= T - 0.5*dt:\n            res = invma * gfu.vec\n            gfu.vec.data -= dt * res\n            t += dt\n            if (i+1) % int(nsteps/nsamplings) == 0:\n                for s in scenes: s.Redraw()     \n            if multidim_draw and (i+1) % int(nsteps/md_nsamplings) == 0:\n                gfu_t.AddMultiDimComponent(gfu.vec)\n            i+=1\n            print(\"\\rt = {:.10}\".format(t),end=\"\")\n    for s in scenes: s.Redraw()\n    if multidim_draw:\n        return gfu_t\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh and Level Sets with NGSolve (Python)\nDESCRIPTION: This snippet creates a geometry, generates a mesh, and defines level sets. It then interpolates these level sets to P1 finite element functions and visualizes them using DrawDC.  The interactive variable is used to control mesh density in a notebook environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\ngeo.AddRectangle((-1.1, -1.1), (1.1, 1.1), bc=1)\nmesh = Mesh(geo.GenerateMesh(maxh=0.2/interactive))\n\nlevel_sets = [x * x + y * y - 1, -x - 1 / 3, x - 1 / 3, y - 0.5]\nlevel_sets_p1 = tuple(GridFunction(H1(mesh, order=1)) \n                      for i in range(len(level_sets)))\n\nfor i, lsetp1 in enumerate(level_sets_p1):\n    InterpolateToP1(level_sets[i], lsetp1)\n    DrawDC(lsetp1, -3.5, 2.5, mesh, \"lset_p1_\" + str(i))\n```\n\n----------------------------------------\n\nTITLE: Create Anisotropic Meshes with CloseSurfaces in Netgen\nDESCRIPTION: This snippet demonstrates how to create anisotropic meshes using CloseSurfaces for geometries with thin layers. This avoids elements with small angles.  The CloseSurfaces method identifies nearly touching surfaces for tailored meshing.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\n\ngeo = CSGeometry()\n\nbox = OrthoBrick(Pnt(0,0,0),Pnt(1,1,1))\ntop = Plane(Pnt(0,0,0.52),Vec(0,0,1))\nbot = Plane(Pnt(0,0,0.48),Vec(0,0,-1))\nplate = box * top * bot\n\ngeo.Add((box-top).mat(\"air\"))\ngeo.Add(plate.mat(\"plate\"))\ngeo.Add((box-bot).mat(\"air\"))\n\nslices = [2**(-i) for i in reversed(range(1,6))]\n# define the close surfaces\ngeo.CloseSurfaces(bot,top)#,slices)\nnmesh = geo.GenerateMesh(maxh=0.3)\n# refine the mesh between the close surfaces\n# ZRefinement(nmesh,geo)\n```\n\n----------------------------------------\n\nTITLE: Solving the deformation equation\nDESCRIPTION: This code defines a function to solve the deformation equation. It assembles the right-hand side vector and solves the system using the inverse of the bilinear form 'b'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef SolveDeformationEquationAuto():\n    rhs = gfX.vec.CreateVector()\n    rhs.data = dJOmegaAuto.vec - b.mat * gfX.vec\n    update = gfX.vec.CreateVector()\n    update.data = b.mat.Inverse(VEC.FreeDofs()) * rhs\n    gfX.vec.data += update\n```\n\n----------------------------------------\n\nTITLE: Defining Geometry and Mesh in NGSolve\nDESCRIPTION: This snippet creates a geometry using Netgen OCC and generates a mesh with a specified maximum element size. The mesh is curved to a specific order. The mesh is then visualized using the Draw function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.occ import *\nfrom time import time\n\nfrom ngsolve.webgui import Draw\nfrom netgen.webgui import Draw as DrawGeo\n\nbox = Box((-1,-1,-1), (1,1,0))\nsp = Sphere((0.5,0,0), 0.2)\nshape = box-sp\ngeo = OCCGeometry(shape)\n\nh = 0.1\n        \nmesh = Mesh( geo.GenerateMesh(maxh=h))\nmesh.Curve(3)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Time Stepping Implementation with SDIRK methods in Python\nDESCRIPTION: This Python function `TimeStepping_app4` implements the time-stepping procedure using a specified SDIRK method. It takes the mass matrix (`m`), stiffness matrix (`a`), Butcher tableau (`butchertab`), time step (`dt`), initial condition (`initial_cond`), start time (`t0`), end time (`tend`), and number of samples (`nsamples`) as input. It updates the `Mstar` matrix, calculates the inverse mass matrix, and then performs the time integration loop. The results are sampled and stored in a GridFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.1-parabolic/parabolic.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef TimeStepping_app4(m, a, butchertab, dt,\n                      initial_cond = None, t0 = 0, tend = 2, \n                      nsamples = 10):\n    mstar.AsVector().data = m.mat.AsVector() + butchertab.astar * dt * a.mat.AsVector()\n    invmstar = mstar.Inverse(freedofs=fes.FreeDofs())\n    invmass = m.mat.Inverse(freedofs=fes.FreeDofs())    \n    \n    rhsi, Mu0, ui = gfu.vec.CreateVector(),gfu.vec.CreateVector(),gfu.vec.CreateVector()   \n    k = [gfu.vec.CreateVector() for i in range(butchertab.stages)]    \n\n    if initial_cond:\n        gfu.Set(initial_cond)\n    cnt = 0; time = t0\n    sample_int = int(floor(tend / dt / nsamples)+1)\n    gfuD = GridFunction(gfu.space)\n    gfut = GridFunction(gfu.space,multidim=0)\n    gfut.AddMultiDimComponent(gfu.vec)\n    while time < tend - 0.5 * dt:\n        Mu0.data = m.mat * gfu.vec\n        for i in range(butchertab.stages):\n            rhsi.data = Mu0\n            for j in range(0,i):\n                rhsi.data += dt * butchertab.a[i][j] * k[j]\n            t.Set(time+butchertab.c[i]*dt)\n            gfu.Set(uD,BND)\n            ui.data = gfu.vec; rhsi.data -= mstar * ui\n            ui.data += invmstar * rhsi\n            k[i].data = - a.mat * ui\n        t.Set(time+dt)\n        gfu.Set(uD,BND)\n        Mu0.data -= m.mat * gfu.vec\n        for i in range(0,butchertab.stages):\n            Mu0.data += dt * butchertab.b[i] * k[i]\n        gfu.vec.data += invmass * Mu0        \n        print(\"\\r\",time,end=\"\")\n        if cnt % sample_int == 0:\n            gfut.AddMultiDimComponent(gfu.vec)\n        cnt += 1; time = cnt * dt\n    return gfut\n```\n\n----------------------------------------\n\nTITLE: Adding regions using the + operator\nDESCRIPTION: This snippet shows how to combine two regions (inner and outer) using the + operator. The resulting region contains all elements from both original regions. The mask of the combined region is then printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nio = mesh.Materials(\"inner\") + mesh.Materials(\"outer\")\nprint(io.Mask())\n```\n\n----------------------------------------\n\nTITLE: Setting up Parallel Krylov Solver\nDESCRIPTION: This code sets up a parallel Krylov-space solver using PETSc. It creates a KSP object, configures it to use the Conjugate Gradient (CG) method with a Geometric Algebraic Multi-Grid (GAMG) preconditioner, and sets solver tolerances and maximum iterations. The matrix used for solving is the previously created PETSc matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n%%px\nksp = psc.KSP()\nksp.create()\nksp.setOperators(psc_mat)\nksp.setType(psc.KSP.Type.CG)\nksp.setNormType(psc.KSP.NormType.NORM_NATURAL)\nksp.getPC().setType(\"gamg\")\nksp.setTolerances(rtol=1e-6, atol=0, divtol=1e16, max_it=400)\n```\n\n----------------------------------------\n\nTITLE: Compute gradient step and deform mesh - Python\nDESCRIPTION: This snippet computes the gradient `gfX`, performs a gradient descent step, and updates the mesh deformation. It solves the linear system `aX.mat * gfX.vec = dJOmega.vec` using a sparse Cholesky decomposition.  The mesh is then deformed based on the updated `gfset`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# compute X_0\ngfX.vec.data = aX.mat.Inverse(VEC.FreeDofs(), inverse=\"sparsecholesky\") * dJOmega.vec\n\nprint(\"current cost \", Integrate(f*dx, mesh))\nprint(\"Gradient norm \", Norm(gfX.vec))\n\nalpha = 20.0 / Norm(gfX.vec)\n\ngfset.vec[:]=0\nscene = Draw(gfset)\n# input(\"A\")\ngfset.vec.data -= alpha * gfX.vec\nmesh.SetDeformation(gfset)\n#draw deformed shape\nscene.Redraw()\n# input(\"B\")\n\nprint(\"cost after gradient step:\", Integrate(f, mesh))\nmesh.UnsetDeformation()\nscene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Setting up Radial PML\nDESCRIPTION: This snippet sets up the radial PML in the defined `pmlregion`. It uses the `SetPML` function with parameters for the radius, PML strength (alpha), and origin. This transformation allows for truncating the unbounded domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh.SetPML(pml.Radial(rad=1,alpha=1j,origin=(0,0)), \"pmlregion\")\n```\n\n----------------------------------------\n\nTITLE: Solving the Linear System\nDESCRIPTION: This snippet assembles the linear system, creates a sparsecholesky inverse for preconditioning, and solves the system using PreconditionedRichardson iteration. The freedofs parameter specifies the degrees of freedom that are not constrained.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nf.Assemble()\na.Assemble()\ninv = a.mat.Inverse(freedofs=freedofs, inverse=\"sparsecholesky\")\n\ngfu.vec.data = PreRic(a=a, rhs=f.vec, pre=inv, freedofs=freedofs)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Stress Norm with Deformation\nDESCRIPTION: Visualizes the norm of the stress tensor on the mesh, with the mesh deformed according to the displacement field. The displacement is scaled by 1e4 for visualization, and volume rendering is disabled for a clearer view of the surface stress.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nDraw (Norm(gfstress), mesh, deformation=1e4*gfu, draw_vol=False, order=3);\n```\n\n----------------------------------------\n\nTITLE: Printing region masks\nDESCRIPTION: This snippet showcases how to print the masks associated with different regions. It demonstrates selecting a specific region, using a regular expression for region selection, and selecting multiple regions using a pipe-separated string.  Masks are boolean arrays indicating which elements belong to the region.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nprint(mesh.Materials(\"inner\").Mask())\nprint(mesh.Materials(\"[a-z]*\").Mask())  # can use regexp\nprint(mesh.Boundaries('t|l').Mask())\n```\n\n----------------------------------------\n\nTITLE: Visualizing Normal Vectors and Boundaries (Python)\nDESCRIPTION: These snippets visualize the computed normal vectors for different boundary sections of the DomainTypeArray, along with their corresponding boundary sections using IndicatorSmoothed. The grid_size parameter controls the density of the visualized vectors, and the eps parameter controls the smoothing of the indicator.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nngsolve.internal.visoptions.showsurfacesolution=1\nDraw(normals[(IF,NEG,NEG,POS)], mesh, \"normal_1\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((IF,NEG,NEG,POS)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5, mesh, \"boundary_1\")\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(normals[(NEG,NEG,NEG,IF)], mesh, \"normal_2\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((NEG,NEG,NEG,IF)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5,  mesh, \"boundary_2\")\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(normals[(IF,NEG,POS,NEG)], mesh, \"normal_3\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((IF,NEG,POS,NEG)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5,  mesh, \"boundary_3\")\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(normals[(NEG,NEG,IF,NEG)], mesh, \"normal_4\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((NEG,NEG,IF,NEG)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5,  mesh, \"boundary_4\")\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(normals[(IF,POS,NEG,POS)], mesh, \"normal_5\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((IF,POS,NEG,POS)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5,  mesh, \"boundary_5\")\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(normals[(IF,POS,NEG,NEG)], mesh, \"normal_6\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((IF,POS,NEG,NEG)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5,  mesh, \"boundary_6\")\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(normals[(NEG,IF,NEG,NEG)], mesh, \"normal_7\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((NEG,IF,NEG,NEG)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5,  mesh, \"boundary_7\")\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(normals[(IF,NEG,POS,POS)], mesh, \"normal_8\", vectors={'grid_size': 14})\nDrawDC(DomainTypeArray((IF,NEG,POS,POS)).IndicatorSmoothed(level_sets_p1, eps=0.08/interactive), -3.5, 2.5,  mesh, \"boundary_8\")\n```\n\n----------------------------------------\n\nTITLE: Marking Elements for Individual Boundary Segments\nDESCRIPTION: This snippet iterates through each boundary segment and retrieves the corresponding elements using GetElementsWithContribution. The element markers are stored in a dictionary, using the domain tuple as the key.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nels_if_single = {}\nfor i, dtt in enumerate(boundary):\n    els_if_single[dtt] = mlci.GetElementsWithContribution(dtt)\n    Draw(BitArrayCF(els_if_single[dtt]), mesh, \"els_if_singe\"+str(i))\n```\n\n----------------------------------------\n\nTITLE: Visualize Eigenfunctions\nDESCRIPTION: This snippet creates a GridFunction to store the computed eigenfunctions, and then visualizes the norm of the eigenfunctions on the mesh.  The order of the visualization is increased for better visual quality.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwellevp.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes, multidim=len(evecs))\nfor i in range(len(evecs)):\n    gfu.vecs[i].data = evecs[i]\nDraw (Norm(gfu), mesh, order=4, min=0, max=2);\n```\n\n----------------------------------------\n\nTITLE: Instantiating Custom High Order FESpace in NGSolve\nDESCRIPTION: This code creates an instance of the custom high-order finite element space defined in the compiled module.  It takes the mesh, order, and Dirichlet boundary conditions as arguments. The custom finite element space `MyHighOrderFESpace` is defined in the compiled C++ module.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfes = m.MyHighOrderFESpace(mesh, order=4, dirichlet=\"left|bottom|top\")\n```\n\n----------------------------------------\n\nTITLE: Solving Laplace Equation using CG Solver (Python)\nDESCRIPTION: This snippet solves the Laplace equation using the Conjugate Gradient (CG) solver. It defines a linear form 'f', assembles it, creates a projector for the free degrees of freedom, and then calls the CG solver.  The Projector is used as a preconditioner. The maxsteps parameter limits the number of iterations. TaskManager is used to enable multithreading.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm (V)\nf += 1*vt * dx\nf.Assemble()\n\nproj = Projector(V.FreeDofs(), True)\n\ngfu = GridFunction (V)\nfrom time import time\nstart = time()\nwith TaskManager():\n  solvers.CG(mat=Laplace, pre=proj, rhs=f.vec, sol=gfu.vec, maxsteps=5000, printrates=False)\nprint (\"time =\", time()-start)\n```\n\n----------------------------------------\n\nTITLE: Adding Nitsche Boundary Terms\nDESCRIPTION: This snippet adds Nitsche boundary terms to the bilinear form to weakly enforce Dirichlet boundary conditions. It iterates through each boundary segment and adds the corresponding terms using the outer normal vectors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfor bnd, n in normals.items():\n    a += -InnerProduct(Grad(u) * n, v) * ds[bnd]\n    a += -InnerProduct(Grad(v) * n, u) * ds[bnd]\n    a += (gamma_n * k * k / h) * InnerProduct(u, v) * ds[bnd]\n```\n\n----------------------------------------\n\nTITLE: Defining Periodic FE Space and Bilinear Form in NGSolve\nDESCRIPTION: This code snippet sets up a periodic finite element space `V` using `Periodic(H1(...))`. It then defines a bilinear form `a` for the phase-field equation, including terms for the Ginzburg-Landau energy and a time-stepping term. `H1` represents the Sobolev space of order 1.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n#use a periodic fe space correspondingly\nV = Periodic(H1(mesh, order=3))\nu = V.TrialFunction()\n\neps = 4e-3\ndt = Parameter(1e-1)\ngfu = GridFunction(V)\ngfuold = GridFunction(V)\na = BilinearForm (V, symmetric=False)\na += Variation( (eps/2*grad(u)*grad(u) + ((1-u*u)*(1-u*u)) \n                     + 0.5/dt*(u-gfuold)*(u-gfuold)) * dx)\n```\n\n----------------------------------------\n\nTITLE: Solving with TaskManager (NGSolve)\nDESCRIPTION: This snippet solves the linear system using `SolveAndVisualize` within a `TaskManager` context. The `TaskManager` enables parallel execution of tasks, potentially speeding up the solving process. The `%%time` magic command is used to measure the execution time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n%%time\nwith TaskManager():\n    gfu_t = SolveAndVisualize(c, rhs_vec=rhs.vec)\n```\n\n----------------------------------------\n\nTITLE: Assemble bilinear form for interface resistivity\nDESCRIPTION: Assembles a bilinear form that includes diffusion terms on the inner and outer domains, as well as a Robin-like term on the interface to model the interface resistivity. A linear form is assembled and the system is solved.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nalpha = 10\n\na = BilinearForm(fes)\na += grad(ui)*grad(vi)*dx(\"inner\")\na += grad(uo)*grad(vo)*dx(\"outer\")\na += alpha * (ui-uo) * (vi-vo) * ds(\"interface\")\na.Assemble()\n\nf = LinearForm(1*vi*dx(\"inner\")).Assemble()\n\ngfu = GridFunction(fes)\ngfu.vec.data = a.mat.Inverse(freedofs=fes.FreeDofs()) * f.vec\n\nsol = mesh.MaterialCF({\"inner\":gfu.components[0], \"outer\":gfu.components[1]})\nDraw (sol, mesh);\n```\n\n----------------------------------------\n\nTITLE: Setting up Stokes as a Block-System\nDESCRIPTION: This snippet defines the Stokes problem as a block system, with separate bilinear forms and matrices for the momentum and continuity equations. It assembles the matrices for the viscous term (a), the divergence term (b), and the pressure mass matrix (mp).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nV = VectorH1(mesh, order=3, dirichlet=\"wall|inlet|cyl\")\nQ = H1(mesh, order=2)\n\nu,v = V.TnT()\np,q = Q.TnT()\n\na = BilinearForm(InnerProduct(Grad(u),Grad(v))*dx).Assemble()\nb = BilinearForm(div(u)*q*dx).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Assembling and solving adjoint equation\nDESCRIPTION: This snippet assembles the linear form and solves the adjoint equation, then redraws the scene to update visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfadjoint.Assemble()\nSolveAdjointEquation()\nscene_p.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Drawing Facets Between Domains - Python\nDESCRIPTION: This snippet calls `SelectFacetsToDraw` to draw the facets between elements of type CDOM_IF and CDOM_NEG, visualizing the elements surrounding that interface.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nSelectFacetsToDraw(CDOM_IF,CDOM_NEG)\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve Modules - Python\nDESCRIPTION: This snippet imports the necessary modules from NGSolve, including the core `ngsolve` module and the `Draw` function from `ngsolve.webgui` for visualizing results. These modules provide the functionality for creating meshes, finite element spaces, and grid functions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Solving Nonlinear Elasticity Equation in NGSolve\nDESCRIPTION: This code snippet defines and solves the geometric nonlinear elasticity equation using NGSolve. It utilizes a hyper-elastic energy density within a variational formulation defined using `SymbolicEnergy`. The Newton's method is employed to solve the stationary equation, and an incremental load method is used to control the loading process. The implementation is based on the `elasticity.py` script.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/whetting_the_appetite/elasticity.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. literalinclude:: /../py_tutorials/elasticity.py\n```\n\n----------------------------------------\n\nTITLE: Defining Dirichlet Boundaries in FESpace - Python\nDESCRIPTION: This code snippet demonstrates how to define Dirichlet boundaries in the FESpace in NGSolve using a regular expression of boundary names defined in the mesh's geometry. The 'dirichlet' parameter specifies which boundaries are subject to Dirichlet conditions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_dirichlet.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nV = FESpace(mesh,order=3,dirichlet=\"top|back\")\nu = GridFunction(V)\n```\n\n----------------------------------------\n\nTITLE: Defining Cut FE spaces with Compression\nDESCRIPTION: This snippet improves the previous approach by using the Compress functionality to reduce the number of unused degrees of freedom. It creates a cut finite element space VhG using compressed versions of the standard H1 space, based on the positive and negative domains defined by the level set.  It sets the components of gfu, visualizes the solution, and prints the number of degrees of freedom.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nVh = H1(mesh, order=2, dirichlet=[1,2,3,4])\nci = CutInfo(mesh, lsetp1)\nVhG = FESpace([Compress(Vh,GetDofsOfElements(Vh,ci.GetElementsOfType(cdt))) for cdt in [HASNEG,HASPOS]])\n\nfreedofs = VhG.FreeDofs()\ngfu = GridFunction(VhG)\ngfu.components[0].Set(1)\ngfu.components[1].Set(-1)\nDrawDC(lsetp1, gfu.components[0], gfu.components[1], mesh, \"u\")\nprint(Vh.ndof, VhG.components[0].ndof, VhG.components[1].ndof)\n```\n\n----------------------------------------\n\nTITLE: Solving Boundary Value Problem - Python\nDESCRIPTION: This code solves a boundary value problem (BVP) using the provided bilinear form 'a', linear form 'f', grid function 'u', and preconditioner 'c'. The solver keeps Dirichlet values unchanged and solves only for the free values.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_dirichlet.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nBVP(bf=a,lf=f,gf=u, pre=c).Do()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Identified Nodes\nDESCRIPTION: This snippet visualizes the identified nodes on the periodic mesh.  It iterates through the identification pairs in the mesh and extracts the node coordinates.  These coordinates are then used to draw lines connecting the identified nodes, highlighting the periodic connections.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/periodicity.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nplist = []\nfor pair in mesh.ngmesh.GetIdentifications():\n    plist += list(mesh.ngmesh[pair[0]].p) \n    plist += list(mesh.ngmesh[pair[1]].p)\nDraw(mesh, objects=[{\"type\" : \"lines\", \"position\" : plist, \"name\": \"identification\", \"color\": \"purple\"}]);\n```\n\n----------------------------------------\n\nTITLE: Time Stepping and Visualization\nDESCRIPTION: This snippet implements a time-stepping scheme to solve the Euler equations. It initializes the solution, sets boundary conditions, projects onto a boundary function space, calculates physical quantities like density, velocity, pressure, and Mach number. It then iteratively updates the solution using a semi-implicit scheme and visualizes the results using the NGSolve web GUI. The main loop iterates until the target end time is reached.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nrho0 = 0.2+1*exp(-400*( (x-0.5)**2 + (y-0.5)**2))\nwith TaskManager():\n    gfu.components[0].Set( (rho0, 0, 0, rho0) )\n\ngfubnd = GridFunction(fes)\ngfubnd.components[1].vec.data = traceop * gfu.components[0].vec\nProjector(fes.GetDofs(mesh.Boundaries(\".*\")), True).Project(gfubnd.vec)\n\ngf_rho = gfu.components[0][0]\ngf_u = gfu.components[0][1:3] / gf_rho\ngf_E = gfu.components[0][3]\ngf_p = (gamma-1)*(gf_E-gf_rho/2*(gf_u*gf_u))  # pressure\ngf_a = sqrt(gamma*gf_p/gf_rho)        # speed of sound\ngf_M = Norm(gf_u) / gf_a              # Mach number\n\nprint (\"Density\")\nscene_rho = Draw (gf_rho, mesh, deformation=True)\nprint (\"Velocity\")\nscene_u = Draw(gf_u, mesh, vectors={\"grid_size\":100})\nprint (\"Mach number\")\nscene_M = Draw(Norm(gf_u)/gf_a, mesh)\n\nt = 0\ntend = 0.3\ntau = 1e-4 \ni = 0\nbfamat = bfa.mat.CreateDeviceMatrix()\ntraceop = traceop.CreateDeviceMatrix()\nvec = gfu.vec.CreateDeviceVector()\nvecbnd = gfubnd.vec.CreateDeviceVector()\nhv = gfu.vec.CreateDeviceVector()\nfrom time import time\n\nwith TaskManager():\n    while t < tend:\n        vec[rangehat] = traceop * vec[rangeT] + vecbnd[rangehat]\n        hv.data = bfamat * vec\n        vec -= tau * invm * hv\n        \n        t += tau\n        i += 1\n        if i%20 == 0:\n            gfu.vec.data = vec\n            scene_rho.Redraw()\n            scene_u.Redraw()\n            scene_M.Redraw()           \n```\n\n----------------------------------------\n\nTITLE: Marking Active Elements\nDESCRIPTION: This snippet retrieves elements with a specific contribution using the GetElementsWithContribution method of the MultiLevelsetCutInfo class. It obtains elements inside the domain (square) and on the boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nels_hasneg = mlci.GetElementsWithContribution(square)\nels_if = mlci.GetElementsWithContribution(boundary)\n\nDraw(BitArrayCF(els_hasneg), mesh, \"els_hasneg\")\nDraw(BitArrayCF(els_if), mesh, \"els_if\")\n```\n\n----------------------------------------\n\nTITLE: Solving Standard Problem using Custom FE Space\nDESCRIPTION: This Python code solves a standard finite element problem using the custom finite element space `fes`. It defines a bilinear form `a` and a linear form `f`, assembles them, and solves the resulting linear system to obtain the solution. The solution is then visualized using the `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx).Assemble()\nf = LinearForm(1*v*dx).Assemble()\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs())*f.vec\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Generate mesh using Netgen in Python\nDESCRIPTION: This snippet generates a mesh of the unit square using Netgen's `unit_square` geometry. The `maxh` parameter controls the maximum mesh element size. The generated mesh is then visualized using the `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/poisson.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\nDraw (mesh)\n```\n\n----------------------------------------\n\nTITLE: Computing L2 and H1 Errors\nDESCRIPTION: This snippet computes the L2 and H1 errors between the computed solution and the exact solution. It uses the Integrate function with specified quadrature orders for accurate integration over the cut domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nerr_l2 = sqrt(Integrate((gfu - u_ex)**2 * dx.order(2 * k), mesh=mesh))\nerr_h1 = sqrt(Integrate((Grad(gfu) - grad_u_ex)**2 * dx.order(2 * (k - 1)), mesh=mesh))\nprint(\"L2 error = {:1.3e}\".format(err_l2))\nprint(\"H1 error = {:1.3e}\".format(err_h1))\n```\n\n----------------------------------------\n\nTITLE: Visualizing Iterations of Newton Solver\nDESCRIPTION: This code visualizes the iterations of the Newton Solver. Allows inspecting intermediate solutions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu_it,mesh,\"u\", deformation = True)\n```\n\n----------------------------------------\n\nTITLE: Inverse Mass Matrix - Python\nDESCRIPTION: This code obtains the inverse of the mass matrix using `VT.Mass(1).Inverse()`.  The resulting `invm` operator is not a sparse matrix, which is typical for DG methods where the mass matrix is block diagonal or even diagonal.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ninvm = VT.Mass(1).Inverse() # not a sparse matrix\nprint(invm)\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve and Matplotlib\nDESCRIPTION: This snippet imports the necessary libraries for NGSolve and plotting.  `ngsolve` provides the finite element functionality, while `matplotlib.pyplot` is used for generating plots.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nimport matplotlib.pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Inverting the Schur Complement (Python)\nDESCRIPTION: This code inverts the Schur complement matrix obtained from the condensed bilinear form. It utilizes `fes.FreeDofs(coupling=True)` to specify that only non-local and non-Dirichlet degrees of freedom should be used in the inverse computation. This corresponds to the interface degrees of freedom (edge and vertex dofs in this example).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ninvS = a.mat.Inverse(freedofs=fes.FreeDofs(coupling=True))\n```\n\n----------------------------------------\n\nTITLE: Assembling Forms in NGSolve\nDESCRIPTION: This code assembles the bilinear and linear forms for the mixed problem. It defines the trial and test functions, sets up the bilinear form including terms for the equation and boundary conditions, and then defines the linear form including the source term and boundary flux. The bilinear form is assembled, and the number of non-zero entries is printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.7-hybrid/hybrid.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsigma,u,uhat = X.TrialFunction()\ntau,v,vhat = X.TestFunction()\n\na = BilinearForm(X, condense=True)\na += (1/lam * sigma*tau + div(sigma)*v + div(tau)*u) * dx\nn = specialcf.normal(mesh.dim)\na += (-sigma*n*vhat-tau*n*uhat) * dx(element_boundary=True)\n\nc = Preconditioner(a, \"bddc\")\n\nf = LinearForm(X)\nf += -source*v * dx - g*vhat.Trace() * ds\n\na.Assemble()\nprint (\"A non-zero\", a.mat.nze)\n\ngfu = GridFunction(X)\n```\n\n----------------------------------------\n\nTITLE: Compressing DomainTypeArray After Tensor Operation (Python)\nDESCRIPTION: This snippet compresses a DomainTypeArray after a tensor operation to remove non-existent regions.  First grid functions are created from the level sets, then the DomainTypeArray is compressed and the number of regions is printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nP1 = H1(mesh, order=1)\nlevelsets_p1 = tuple([GridFunction(P1) for _l in level_sets1 + level_sets2])\nfor lsetp1, lset in zip(levelsets_p1, level_sets1 + level_sets2):\n    InterpolateToP1(lset, lsetp1)\n\ndta_outside.Compress(levelsets_p1)\nprint(\"Number of regions in DomainTypeArray after compression:\", len(dta_outside))\n```\n\n----------------------------------------\n\nTITLE: Solving Primal Problem in NGSolve\nDESCRIPTION: This snippet sets up and solves the primal variational formulation of the diffusion equation. It defines the finite element space, assembles the bilinear and linear forms, applies the Dirichlet boundary condition using `gfup.Set(ud, BND)`, and solves the resulting linear system using the inverse of the stiffness matrix. Finally, it visualizes the solution and flux.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfesp = H1(mesh, order=4, dirichlet=\"bottom\")\nup, vp = fesp.TnT()\n\nap = BilinearForm(lam*grad(up)*grad(vp)*dx).Assemble()\nfp = LinearForm(source*vp*dx + g*vp * ds).Assemble()\n\ngfup = GridFunction(fesp)\ngfup.Set(ud, BND)\n\nr = fp.vec - ap.mat * gfup.vec\ngfup.vec.data += ap.mat.Inverse(freedofs=fesp.FreeDofs()) * r\nDraw (gfup)\nDraw (lam * grad(gfup), mesh, \"flux-primal\");\n```\n\n----------------------------------------\n\nTITLE: Defining Trial and Test Functions, Normal Vector\nDESCRIPTION: This snippet defines the trial and test functions for the pressure (p) and velocity (u), as well as the trial function for the trace (phat). It also defines the normal vector to the mesh boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\np = fes_p.TrialFunction()\nv = fes_u.TestFunction()\nphat = fes_tr.TrialFunction()\n\nn = specialcf.normal(mesh.dim)\n```\n\n----------------------------------------\n\nTITLE: Compare Sparsity Patterns with and without DGJumps in NGSolve\nDESCRIPTION: This snippet compares the sparsity patterns of matrices assembled with and without the `dgjumps=True` flag in the L2 finite element space. It creates two bilinear forms, assembles them, converts them to sparse matrices using `scipy.sparse`, and visualizes the sparsity patterns using `matplotlib.pylab`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\na1 = BilinearForm(L2(mesh, order=order, dgjumps=False)); a1.Assemble()\na2 = BilinearForm(L2(mesh, order=order, dgjumps=True)); a2.Assemble()\nA1 = sp.csr_matrix(a1.mat.CSR())\nA2 = sp.csr_matrix(a2.mat.CSR())\nfig = plt.figure(); ax1 = fig.add_subplot(121); ax2 = fig.add_subplot(122)\nax1.set_xlabel(\"dgjumps=False\"); ax1.spy(A1,precision=-1)\nax2.set_xlabel(\"dgjumps=True\"); ax2.spy(A2,precision=-1)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Drawing with deformation - Python\nDESCRIPTION: This snippet visualizes the deformation field and levelset approximation after applying LevelSetMeshAdaptation. The Draw and DrawDC functions are used with the deformation parameter to visualize the modified geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nscene1 = Draw(deformation, mesh, \"deformation\", autoscale=False, min=0.0, max=0.028)\nscene2 = DrawDC(lsetmeshadap.lset_p1, -3.5, 2.5, mesh, \"lsetp1_ho\", deformation=deformation)\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form for Minimal Energy Extension in NGSolve\nDESCRIPTION: This code snippet defines the bilinear form for the minimal energy extension problem. It includes terms for the energy functional and the constraint enforcing continuity between the high-order and low-order spaces. BBND is related to boundary conditions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(fes)\na += Variation(0.5 * grad(uho)*grad(uho)*dx \n               - 1*uho*dx \n               + (uho-ulo)*lam*dx(element_vb=BBND))\ngfu = GridFunction(fes)\nNewtonMinimization(a=a, u=gfu)\nDraw(gfu.components[0],mesh,deformation=True)\n```\n\n----------------------------------------\n\nTITLE: Variational Formulation Setup in NGSolve\nDESCRIPTION: This snippet sets up the variational formulation for the minimization problem in NGSolve. It defines a bilinear form `a` using `BilinearForm` and adds variations corresponding to the energy density, dissipation potential, and external force.  The `Compile` method optimizes the expressions for performance.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nrealcompile = False\n\n# Possible optimization: use static condensation for p\na = BilinearForm(fes, symmetric=True)\na += Variation( Psi(p, strain(u), gfp_k, alpha_k) * irs_dx ).Compile(realcompile=realcompile)\na += Variation( Phi(p, gfp_k) * irs_dx ).Compile(realcompile=realcompile)\na += Variation( -u[1] * force * loadfactor * ds(\"top\") ).Compile(realcompile=realcompile)\n```\n\n----------------------------------------\n\nTITLE: Mesh Creation and Initial Condition\nDESCRIPTION: This snippet creates a mesh on the unit square and initializes the finite element space.  It then sets the initial density based on a Gaussian distribution centered at (0.5, 0.5), and initializes the GridFunction 'gfu' with this density.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.02))\n\norder=3\nfesT = L2(mesh, order=order)**4\nfeshat = FacetFESpace(mesh, order=order)**4\nfes = fesT*feshat\n\ngfu = GridFunction(fes)\nrho0 = 1+1*exp(-400*( (x-0.5)**2 + (y-0.5)**2))\nwith TaskManager():\n    gfu.components[0].Set( (rho0, 0, 0, 1) )\n```\n\n----------------------------------------\n\nTITLE: FETI-DP Solver Setup\nDESCRIPTION: This code defines the core functions for setting up and solving a FETI-DP problem using NGSolve. It includes functions for loading a mesh, setting up the finite element space, constructing the FETI-DP matrices (A_dp, B, F, Fhat), and performing the solve. It relies on MPI for parallel computation and custom toolboxes such as FindFEV and DPSpace_Inverse.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n%%px\nfrom ngsolve import *\nimport netgen.meshing as ngmeshing\nfrom ngsolve.la import ParallelMatrix, FETI_Jump, SparseMatrixd, ParallelDofs\nfrom dd_toolbox import FindFEV, DPSpace_Inverse, ScaledMat\n\ndef load_mesh(nref=0):\n    ngmesh = ngmeshing.Mesh(dim=3)\n    ngmesh.Load('cube.vol')\n    for l in range(nref):\n        ngmesh.Refine()\n    return Mesh(ngmesh)\n\ndef setup_space(mesh, order=1):\n    comm = MPI_Init()\n    fes = H1(mesh, order=order, dirichlet='right|top')\n    a = BilinearForm(fes)\n    u,v = fes.TnT()\n    a += SymbolicBFI(grad(u)*grad(v))\n    a.Assemble()\n    f = LinearForm(fes)\n    f += SymbolicLFI(x*y*v)\n    f.Assemble()\n    avg_dof = comm.Sum(fes.ndof) / comm.size\n    if comm.rank==0:\n        print('global,  ndof =', fes.ndofglobal, ', lodofs =', fes.lospace.ndofglobal)\n        print('avg DOFs per core: ', avg_dof)\n    return [fes, a, f]\n\ndef setup_FETIDP(fes, a):\n    faces, edges, vertices = FindFEV(mesh.dim, mesh.nv, \\\n                                     fes.ParallelDofs(), fes.FreeDofs())\n    primal_dofs = BitArray([ v in set(vertices) for v in range(fes.ndof) ]) & fes.FreeDofs() \n    dp_pardofs = fes.ParallelDofs().SubSet(primal_dofs)\n    ar = [(num_e[0],d,1.0) for num_e in enumerate(edges) for d in num_e[1] ]\n    rows, cols, vals = [list(x) for x in zip(*ar)] if len(ar) else [[],[],[]]\n    B_p = SparseMatrixd.CreateFromCOO(rows, cols, vals, len(edges), fes.ndof)\n    edist_procs = [sorted(set.intersection(*[set(fes.ParallelDofs().Dof2Proc(v)) for v in edge])) for edge in edges]\n    eavg_pardofs = ParallelDofs(edist_procs, comm)\n    nprim = comm.Sum(sum([1 for k in range(fes.ndof) if primal_dofs[k] and comm.rank<fes.ParallelDofs().Dof2Proc(k)[0] ]))\n    if comm.rank==0:\n        print('# of global primal dofs: ', nprim)  \n    A_dp = ParallelMatrix(a.mat.local_mat, dp_pardofs)\n    dual_pardofs = fes.ParallelDofs().SubSet(BitArray(~primal_dofs & fes.FreeDofs()))\n    B = FETI_Jump(dual_pardofs, u_pardofs=dp_pardofs)\n    if comm.rank==0:\n        print('# of global multipliers = :', B.col_pardofs.ndofglobal)\n    A_dp_inv = DPSpace_Inverse(mat=a.mat, freedofs=fes.FreeDofs(), \\\n                               c_points=primal_dofs, \\\n                               c_mat=B_p, c_pardofs=eavg_pardofs, \\\n                               invtype_loc='sparsecholesky', \\\n                               invtype_glob='masterinverse')\n    F = B @ A_dp_inv @ B.T\n    innerdofs = BitArray([len(fes.ParallelDofs().Dof2Proc(k))==0 for k in range(fes.ndof)]) & fes.FreeDofs()\n    A = a.mat.local_mat\n    Aiinv = A.Inverse(innerdofs, inverse='sparsecholesky')\n    scaledA = ScaledMat(A, [1.0/(1+len(fes.ParallelDofs().Dof2Proc(k))) for k in range(fes.ndof)])\n    scaledBT = ScaledMat(B.T, [1.0/(1+len(fes.ParallelDofs().Dof2Proc(k))) for k in range(fes.ndof)])\n    Fhat = B @ scaledA @ (IdentityMatrix() - Aiinv @ A) @ scaledBT\n    return [A_dp, A_dp_inv, F, Fhat, B, scaledA, scaledBT]\n    \ndef prep(B, Ainv, f):\n    rhs.data = (B @ Ainv) * f.vec\n    return rhs\n\ndef solve(mat, pre, rhs, sol):\n    t = comm.WTime()\n    solvers.CG(mat=mat, pre=pre, rhs=rhs, sol=sol, \\\n               maxsteps=100, printrates=comm.rank==0, tol=1e-6)\n    return comm.WTime() - t\n    \ndef post(B, Ainv, gfu, lam):\n    hv = B.CreateRowVector()\n    hv.data = f.vec - B.T * lam\n    gfu.vec.data = Ainv * hv\n    jump = lam.CreateVector()\n    jump.data = B * gfu.vec\n    norm_jump = Norm(jump)\n    if comm.rank==0:\n        print('\\nnorm jump u: ', norm_jump)   \n```\n\n----------------------------------------\n\nTITLE: Generating Compile and Link Scripts (CMake)\nDESCRIPTION: This snippet generates batch files (`ngscxx.bat`, `ngsld.bat`) for Windows and shell scripts (`ngscxx`, `ngsld`) for other systems, which encapsulate the compilation and linking commands. It also handles the installation of these generated scripts. Conditional logic determines whether to use CCACHE if found.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_47\n\nLANGUAGE: CMake\nCODE:\n```\nif(WIN32)\n    set(NGSCXX_COMMAND ngscxx.bat)\n    file(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/ngscxx.bat\n                  CONTENT \"${ngscxx_set_script_dir}\\n cl /c ${ngscxx_flags} ${ngscxx_includes} %*\\n\"\n                  CONDITION $<CONFIG:${CMAKE_BUILD_TYPE}>\n                  )\n    file(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/ngsld.bat\n                  CONTENT \"${ngscxx_set_script_dir}\\n ${ngsld_header}\\nlink /DLL %* ${ngsld_flags}\\n\")\n    install (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/ngscxx.bat DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve_devel )\n    install (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/ngsld.bat DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve_devel )\nelse(WIN32)\n    set(NGSCXX_COMMAND ngscxx)\n    set(ngscxx_compile_command \"$NGSCXX ${ngscxx_flags} ${ngscxx_includes} $*\")\n    if(CCACHE_FOUND)\n      set(ngscxx_compile_command \"\nif [ -f ${CCACHE_FOUND} ]\n  then ${CCACHE_FOUND} ${ngscxx_compile_command}\n  else ${ngscxx_compile_command}\nfi\")\n    endif(CCACHE_FOUND)\n    file(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/ngscxx\n                  CONTENT \"${ngscxx_header}\\n${ngscxx_compile_command}\\n\"\n                  CONDITION $<\nfile(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/ngsld CONTENT \"${ngsld_header}\\n$NGSCXX ${ngsld_flags} $*\\n\")\n    install (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/ngscxx DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve_devel )\n    install (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/ngsld DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve_devel )\nendif(WIN32)\n```\n\n----------------------------------------\n\nTITLE: Solving for flow potential\nDESCRIPTION: This code defines a finite element space, bilinear form, and linear form to solve for a flow potential. The flow potential represents the velocity field.  The code defines a contact boundary condition using Nitsche's method to couple different parts of the domain.  The `solveWind` function is defined to solve this potential.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfest = H1(mesh, order=3, dirichlet=\"inlet|outlet\")\n\nfestgrad = VectorH1(mesh, order=3)\ngfutgrad = GridFunction(festgrad)\n\nut,vt = fest.TnT()\n\nn = specialcf.normal(2)\nh = specialcf.mesh_size\n\ngfut = GridFunction(fest)\n    \nmeshVelocity = (deformation-defold) / tau\n\nat = BilinearForm(grad(ut)*grad(vt)*dx)\nft = LinearForm(fest)\nft += -InnerProduct(meshVelocity,n)*vt*ds(definedon=\"hole\")\n\ncontactt = ContactBoundary(mesh.Boundaries(\"gammai\"), mesh.Boundaries(\"gammao\"), volume=True)\ncontactt.AddIntegrator (3/h*(ut-ut.Other())*(vt-vt.Other()))\ncontactt.AddIntegrator (n*grad(ut)*(vt.Other()-vt)+n*grad(vt)*(ut.Other()-ut))\n\n\ndef solveWind(gfut,at,ft):\n    contactt.Update (deformation, bf=at, intorder=10)\n\n    at.Assemble()\n    ft.Assemble()\n\n    # the solution field \n    gfut.Set((x), BND)\n    rt = ft.vec.CreateVector()\n    rt.data = ft.vec - at.mat * gfut.vec\n    gfut.vec.data += at.mat.Inverse(freedofs=fest.FreeDofs(), inverse = \"sparsecholesky\") * rt\n    gfutgrad.Set(Grad(gfut))\n```\n\n----------------------------------------\n\nTITLE: Defining simulation parameters\nDESCRIPTION: This snippet defines the simulation parameters, including the time step (tau), end time (tend), and angular velocity (omega). These parameters control the duration and granularity of the simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntau = 0.0003\ntend = 1\nomega = 2*pi\n```\n\n----------------------------------------\n\nTITLE: Magnetic Field Calculation with NGSolve\nDESCRIPTION: This code snippet demonstrates how to calculate the magnetic field generated by a coil on a C-core using NGSolve in Python. It covers the setup of the geometry, material properties, and the definition of bilinear and linear forms for solving the magnetostatic problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/whetting_the_appetite/cmagnet.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport netgen.gui\nfrom netgen.ngsolve import *\nfrom netgen.csg import *\n\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\ngeo = CSGeometry()\n\n# air\ngeo.Add (Sphere (Pnt(0,0,0), 5).bc(\"outer\"))\n\n# iron C\ncore = OrthoBrick(Pnt(-3,-1.5,-1), Pnt(3,1.5,1))\ncore.bc(\"outer\")\ngeo.Add (core)\n\n# remove air\ngeo.Add (Sphere (Pnt(0,0,0), 4).mat(\"iron\"))\n\n# cut hole in iron\ncol1 = Cylinder (Pnt (-1.5,0,-1), Pnt (-1.5,0,1), 0.5)\ncol2 = Cylinder (Pnt ( 1.5,0,-1), Pnt ( 1.5,0,1), 0.5)\ncore.Remove (col1)\ncore.Remove (col2)\n\n# coil\ncoil = (Cylinder (Pnt (-1.5,0,-1), Pnt (-1.5,0,1), 0.4)\n        + Cylinder (Pnt ( 1.5,0,-1), Pnt ( 1.5,0,1), 0.4))\ncoil.mat(\"coil\").bc(\"coil\")\ngeo.Add (coil)\n\nmesh = Mesh(geo.GenerateMesh(maxh=0.5))\n\nDraw (mesh)\n\n\nfes = HCurl(mesh, order=3, dirichlet=\"outer\")\nA = fes.TrialFunction()\nB = fes.TestFunction()\n\nmu_0 = 1.257e-6\nmu_iron = 700 * mu_0\n\n\ndef coef(element):\n    if element.mat == \"iron\":\n        return mu_iron\n    elif element.mat == \"coil\":\n        return mu_0\n    else:\n        return mu_0\n\nmu = mesh.Materials(coef)\n\nprint (\"mu:\", mu)\n\nJ = CoefficientFunction((0,10,0))\n\na = BilinearForm(fes, symmetric=True)\na += (1/mu * curl(A) * curl(B)) * dx\nf = LinearForm(fes)\nf += (J*B)*dx(\"coil\")\n\na.Assemble()\nf.Assemble()\n\nA = a.mat.Solve(f.vec)\nDraw (curl(A), mesh, \"B-field\")\n\n```\n\n----------------------------------------\n\nTITLE: Defining Facet Patch Integral for GP - Python\nDESCRIPTION: This snippet defines the integration domain for the ghost penalty stabilization term. The `dFacetPatch` integral is restricted to the interior facets of the stabilization patches, defined by `EA.patch_interior_facets`. This integral is only created if ghost penalty stabilization is used.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nif gamma_stab > 0:\n    #Integration domain for ghost penalty\n    dP = dFacetPatch(definedonelements=EA.patch_interior_facets, deformation=deformation)\n\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Unfitted Mixed FEM - Python\nDESCRIPTION: This code snippet imports necessary libraries for performing unfitted mixed finite element simulations. It imports functionalities from netgen for mesh generation, ngsolve for finite element analysis, ngsolve.internal for internal functions, and xfem for extended finite element methods including level set calculations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#basic imports\nfrom netgen.geom2d import SplineGeometry\nfrom ngsolve import *\nfrom ngsolve.internal import *\nfrom xfem import *\nfrom xfem.lsetcurv import *\n```\n\n----------------------------------------\n\nTITLE: Drawing the Grid Function Component (Python)\nDESCRIPTION: This code snippet draws a component of the grid function 'gfu' on the mesh. The Draw function from ngsolve.webgui visualizes the solution. gfu.components[1] selects the second component of the grid function. draw_vol=False prevents drawing the volume elements, focusing on the surface visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfu.components[1], mesh, \"gfu1\", draw_vol=False);\n```\n\n----------------------------------------\n\nTITLE: Instantiate Projected Multigrid - Python\nDESCRIPTION: This snippet instantiates the `ProjectedMG` class, creating the preconditioner based on the finest level matrix. The `fes.mesh.levels-1` argument specifies the number of mesh levels.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npre = ProjectedMG(fes, a.mat, fes.mesh.levels-1)\n```\n\n----------------------------------------\n\nTITLE: Bilinear form for gradient (SciPy) - Python\nDESCRIPTION: This snippet defines the bilinear form `aX` for computing the shape gradient within the SciPy optimization framework.  It includes an optional Cauchy-Riemann regularization term. The assembled bilinear form is then inverted to compute the gradient.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Cauchy-Riemann descent CR\nCR = False\n\n# bilinear form for gradient\naX = BilinearForm(VEC)\naX += InnerProduct(grad(PHI)+grad(PHI).trans, grad(PSI))*dx + InnerProduct(PHI,PSI)*dx\n\n## Cauchy-Riemann regularisation\n\nif CR == True:\n    gamma = 100\n    aX += gamma * (PHI.Deriv()[0,0] - PHI.Deriv()[1,1])*(PSI.Deriv()[0,0] - PSI.Deriv()[1,1]) *dx\n    aX += gamma * (PHI.Deriv()[1,0] + PHI.Deriv()[0,1])*(PSI.Deriv()[1,0] + PSI.Deriv()[0,1]) *dx\n\n\naX.Assemble()\ninvaX = aX.mat.Inverse(VEC.FreeDofs(), inverse=\"sparsecholesky\")\n\ngfX = GridFunction(VEC)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This code snippet imports the required modules from the NGSolve library, including functionalities for finite element analysis, web GUI visualization, and linear algebra operations specifically for preconditioners.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom ngsolve.la import EigenValues_Preconditioner\n```\n\n----------------------------------------\n\nTITLE: Creating Mesh from Unit Square for NGSolve FEM\nDESCRIPTION: This snippet creates a mesh from a unit square using Netgen's OCC module and initializes it within NGSolve. The `maxh` parameter controls the mesh size, and `quad_dominated` specifies whether quadrilateral elements should dominate. This mesh is then used for finite element analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom netgen.occ import unit_square\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2, quad_dominated=False))\n```\n\n----------------------------------------\n\nTITLE: Setting up the Formulation for Patchwise Post-processing in NGSolve (Python)\nDESCRIPTION: This code defines the integration domain for the ghost penalty and sets up the integrals for the left-hand side (lhs_integrals) and right-hand side (rhs_integrals) of the patchwise post-processing formulation. These integrals represent the weak form of the equations being solved.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n#Integration domain for ghost penalty\ndP = dFacetPatch(definedonelements=EA.patch_interior_facets, deformation=deformation)\n\nlhs_integrals = [grad(ps) * grad(vs) * dX,\n                 (lam * vs + mu * ps) * dxinner,\n                 1/h**2 * (ps - ps.Other()) * (vs - vs.Other()) * dP]\nrhs_integrals = [gfu * grad(vs) * dX,\n                 gfpT * mu * dxinner]\n```\n\n----------------------------------------\n\nTITLE: Setting up Finite Element Spaces for Minimization in NGSolve\nDESCRIPTION: This snippet sets up finite element spaces for a minimization-based formulation of plasticity using NGSolve. It defines a matrix-valued finite element space `fes_p`, creates a mixed finite element space `fes`, defines `TrialFunction`s and `GridFunction`s for the solution variables and previous state, and initializes the `alpha_k` GridFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfes_p = MatrixValued(fes_ir, symmetric=True, deviatoric=True, dim=3)\n\nfes = fes_u * fes_p\nu, p = fes.TrialFunction()\n\n# GridFunction for solution\ngfsol = GridFunction(fes)\ngfu, gfp = gfsol.components\n\n# Save previous solution\ngfsol_k = GridFunction(fes)\ngfu_k, gfp_k = gfsol_k.components\n\n# alpha_0 = 0\nalpha_k = GridFunction(fes_ir)\n```\n\n----------------------------------------\n\nTITLE: Calculating Eigenvalues with Condensation\nDESCRIPTION: This snippet calls the `TestPreconditioner` function with static condensation enabled and prints the first and last three eigenvalues of the preconditioned matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlams = TestPreconditioner(5, condense=True)\nprint (lams[0:3], \"...\\n\", lams[-3:])\n```\n\n----------------------------------------\n\nTITLE: Adding Mesh Points in 2D\nDESCRIPTION: This code adds mesh points to the 2D mesh. The points are arranged in a grid-like structure to represent a square domain. `pnums` stores `PointId`s generated using `ngmesh.Add`. The code iterates through rows and columns, adding points at regular intervals to form a square grid.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nN=5\npnums = []\nfor i in range(N + 1):\n    for j in range(N + 1):\n        pnums.append(ngmesh.Add(MeshPoint(Pnt(i / N, j / N, 0))))\n```\n\n----------------------------------------\n\nTITLE: Defining the linear form for the adjoint equation\nDESCRIPTION: This code defines the linear form 'fadjoint' for the adjoint equation. It uses the Diff command to compute the derivative of the cost functional with respect to the state variable 'gfu'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\np, w = fes.TnT()\n\nfadjoint = LinearForm(fes)\nfadjoint += -1*(CostAutoFA(gfu)).Diff(gfu,w)\n```\n\n----------------------------------------\n\nTITLE: Comparing NGSolve and TensorFlow Solutions\nDESCRIPTION: This snippet evaluates the trained TensorFlow model for a specific input, compares the model's output with the NGSolve solution by visualizing both, and calculates the L2 error between them. It provides a visual and quantitative comparison of the two solutions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\noutput = model(np.array([[0.1,0.2]]))\noutputvec = output.numpy().flatten()\n\nSolve (0.1, 0.2)\nDraw (gfu)\n\ngfumodel = GridFunction(fes)\ngfumodel.vec.FV()[:] = outputvec\n    \nDraw (gfumodel)\nDraw (gfu-gfumodel, mesh);\nprint (\"err = \", Integrate((gfu-gfumodel)**2, mesh)**0.5)\n```\n\n----------------------------------------\n\nTITLE: Set Boundary Condition - Python\nDESCRIPTION: This snippet shows how to set a boundary condition number for a segment using the `bc` parameter. This boundary condition can then be used in simulation software to apply specific conditions to that boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngeo.Append ([\"line\", p1, p2], bc=3)\n```\n\n----------------------------------------\n\nTITLE: Defining FE Spaces for Minimal Energy Extension in NGSolve\nDESCRIPTION: This code defines finite element spaces for the minimal energy extension problem. It creates discontinuous high-order (`fes_ho`), continuous low-order (`fes_lo`), and Lagrange multiplier (`fes_lam`) spaces. Dirichlet boundary conditions are specified for `fes_lo`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(geom.GenerateMesh(maxh=0.1))\nfes_ho = Discontinuous(H1(mesh, order=10))\nfes_lo = H1(mesh, order=1, dirichlet=\".*\")\nfes_lam = Discontinuous(H1(mesh, order=1))\nfes = fes_ho*fes_lo*fes_lam\nuho, ulo, lam = fes.TrialFunction()\n```\n\n----------------------------------------\n\nTITLE: Creating Solution GridFunction (Python)\nDESCRIPTION: This snippet creates a GridFunction to store the solution of the space-time problem. It also creates a TimeRestricted GridFunction to store the solution at the end of each time step, which is used as the initial condition for the next time step.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(st_fes)\nu_last = CreateTimeRestrictedGF(gfu, 1)\n```\n\n----------------------------------------\n\nTITLE: Shape Optimization loop\nDESCRIPTION: This code implements the shape optimization loop.  It iteratively solves the state equation, adjoint equation, and deformation equation. It updates the mesh deformation and performs a line search (optional) to ensure a decrease in the cost functional.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n#reset to and solve for initial configuration\ngfset.Set((0,0))\nmesh.SetDeformation(gfset)\nscene_u.Redraw()\ngfu.vec[:]=0\nNewton(aAuto, gfu, fes.FreeDofs())\n\nLineSearch = False\n\n\niter_max = 600\nJold = Integrate(CostAuto2(gfu), mesh)\nconverged = False\nfor k in range(iter_max):\n    print('cost at iteration', k, ': ', Jold)\n    mesh.SetDeformation(gfset)\n    scene_u.Redraw()\n    \n    gfu.vec[:]=0\n    Newton(aAuto, gfu, fes.FreeDofs(), printing = False)\n    \n    fadjoint.Assemble()\n    SolveAdjointEquation()\n    \n    b.Assemble()\n    dJOmegaAuto.Assemble()\n    SolveDeformationEquationAuto()\n\n    scale = 0.01 / Norm(gfX.vec)\n    gfsetOld = gfset\n    gfset.vec.data -= scale * gfX.vec\n    \n    Jnew = Integrate(CostAuto2(gfu), mesh)\n    \n    if LineSearch:\n        while Jnew > Jold and scale > 1e-12:\n            # input('a')\n            scale = scale / 2\n            \n            if scale <= 1e-12:\n                converged = True\n                break\n\n            gfset.vec.data = gfsetOld.vec - scale * gfX.vec\n            mesh.SetDeformation(gfset)\n            \n            gfu.vec[:]=0\n            Newton(aAuto, gfu, fes.FreeDofs(), printing = False)\n            Jnew = Integrate(CostAuto(gfu), mesh)\n    \n    if converged==True:\n        break\n    Jold = Jnew\n\n    Redraw(blocking=True)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Nonlinear PDE Solution\nDESCRIPTION: This code visualizes the solution of the nonlinear PDE using NGSolve's `Draw` function. It shows the deformed solution (deformation = True).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu,mesh,\"u\", deformation = True)\n```\n\n----------------------------------------\n\nTITLE: Assembling with Trace Operator in NGS-Py\nDESCRIPTION: This code snippet demonstrates how to assemble a term using the Trace operator within the NGSolve framework. The Trace operator restricts the functions 'u' and 'v' to the boundary (BND) of the domain.  It's typically used to evaluate boundary integrals. The a.Assemble() function integrates the product of u.Trace() and v.Trace() over the boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_traceoperator.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\na.Assemble(u.Trace()*v.Trace(), BND)\n```\n\n----------------------------------------\n\nTITLE: Solve Convection-Diffusion Problem in NGSolve\nDESCRIPTION: This snippet solves the convection-diffusion problem using the assembled bilinear form `acd` and linear form `f`. It creates a `GridFunction` to store the solution, applies the inverse of the matrix (using UMFPACK as the direct solver), and visualizes the result.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\ngfu.vec.data = acd.mat.Inverse(freedofs=fes.FreeDofs(),inverse=\"umfpack\") * f.vec\nDraw (gfu)\n```\n\n----------------------------------------\n\nTITLE: Define finite element spaces for inner and outer domains\nDESCRIPTION: Defines H1 finite element spaces separately for the inner and outer domains.  Dirichlet boundary conditions are applied on the outer domain.  A product space is created to combine the two spaces, and trial and test functions are defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfesi = H1(mesh, order=3, definedon=mesh.Materials(\"inner\"))\nfeso = H1(mesh, order=3, definedon=mesh.Materials(\"outer\"), dirichlet=\"dir\")\nfes = fesi*feso\n\n(ui,uo), (vi,vo) = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Time Evolution - Python\nDESCRIPTION: This snippet visualizes the time evolution of the solution using the `multidim` functionality.  It draws the `gfut` GridFunction, which contains the solution at multiple time steps, and allows for animation and interpolation between the time steps.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfut, mesh, interpolate_multidim=True, animate=True, deformation=True, min=0, max=1, autoscale=False)\n```\n\n----------------------------------------\n\nTITLE: Defining Discretization Parameters (Python)\nDESCRIPTION: This snippet defines key discretization parameters for the space-time simulation, including the number of time steps, refinement levels, polynomial order in time and space, level set approximation order, integration order, time stepping parameters, mesh size, and ghost-penalty parameter.  These parameters control the accuracy and computational cost of the simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# DISCRETIZATION PARAMETERS:\n\n# Parameter for refinement study:\ni = 3\nn_steps = 2**i\nspace_refs = i\n\n# Polynomial order in time\nk_t = 2\n# Polynomial order in space\nk_s = k_t\n# Polynomial order in time for level set approximation\nlset_order_time = k_t\n# Integration order in time\ntime_order = 2 * k_t\n# Time stepping parameters\ntstart = 0\ntend = 0.5\ndelta_t = (tend - tstart) / n_steps\nmaxh = 0.5\n# Ghost-penalty parameter\ngamma = 0.05\n```\n\n----------------------------------------\n\nTITLE: Defining a finite element space on a subdomain\nDESCRIPTION: This snippet defines a finite element space (H1) specifically on the 'inner' subdomain. A `GridFunction` is created within this space and initialized with the function x*y. The `Draw` function visualizes the grid function on the specified subdomain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfes1 = H1(mesh, definedon=\"inner\")\nu1 = GridFunction(fes1, \"u1\")\nu1.Set(x*y)\nDraw(u1)\n```\n\n----------------------------------------\n\nTITLE: Creating MultiLevelsetCutInfo Object\nDESCRIPTION: This snippet creates a MultiLevelsetCutInfo object, which is used to handle cut information for multiple level sets. It requires the mesh and the level sets as input.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmlci = MultiLevelsetCutInfo(mesh, level_sets_p1)\n```\n\n----------------------------------------\n\nTITLE: Creating the ngbla Library\nDESCRIPTION: This snippet uses `add_library` to create the `ngbla` library, specifying its type and source files. It includes various cpp files for linear algebra functionalities such as band matrices, triangular matrices, Cholesky decomposition, LU decomposition, SVD, and eigensystem calculations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(ngbla ${NGS_LIB_TYPE}\n        bandmatrix.cpp triangular.cpp calcinverse.cpp cholesky.cpp\n        LUdecomposition.cpp householder.cpp svd.cpp\n        eigensystem.cpp LapackGEP.cpp\n        python_bla.cpp ngblas.cpp ngblasc.cpp timing_ngblas.cpp\n        )\n```\n\n----------------------------------------\n\nTITLE: Defining Coefficient Functions\nDESCRIPTION: This code defines several coefficient functions: `source` as a sine function, `ud` as a constant value, `g` as a boundary coefficient function depending on y, and `lam` as a constant representing a material property. These are used to define the problem's source term, Dirichlet boundary condition, Neumann boundary condition, and diffusion coefficient, respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsource = sin(3.14*x)\nud = CF(5)\ng = mesh.BoundaryCF( {\"left\" : y*(1-y)}, default=0)\nlam = 10\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh, FESpace, and GridFunction in ngsolve\nDESCRIPTION: This snippet initializes a mesh from a unit cube, defines an H1 finite element space of order 3, and creates a GridFunction on this space. It then sets the GridFunction to a simple function x*y.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/emscripten/example.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import *\n\nfrom netgen.geom2d import unit_square\nfrom netgen.occ import unit_cube\nm = unit_cube.GenerateMesh(maxh=.4)\n\nmesh = Mesh(m)\nfes = H1(mesh, order=3)\n#fes = L2(mesh, order=3) # L2 not working yet (some DiffOps missing in Archive registration)\nu = GridFunction(fes)\nu.Set(x*y)\nfrom webgui_jupyter_widgets import *\nimport ngsolve.comp as comp\n```\n\n----------------------------------------\n\nTITLE: Running CalcError and Refining the Mesh\nDESCRIPTION: This code calls the `CalcError` function to compute the error and mark elements for refinement. After the error is calculated and the elements are marked, the mesh is refined using the `mesh.Refine()` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nCalcError()\nmesh.Refine()\n```\n\n----------------------------------------\n\nTITLE: Eigenvalue Calculation for Projected MG - Python\nDESCRIPTION: This snippet calculates the minimum and maximum eigenvalues of the preconditioned system, and then computes and prints the condition number. The smaller the condition number, the better the convergence of iterative solvers.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nlam = EigenValues_Preconditioner(a.mat, pre)\nprint(\"ndof=%7d:  minew=%.4f  maxew=%1.4f  Cond# = %5.3f\" \n          %(fes.ndof, lam[0], lam[-1], lam[-1]/lam[0]))\n```\n\n----------------------------------------\n\nTITLE: Running the full shape optimization algorithm\nDESCRIPTION: This code implements the full shape optimization algorithm, iteratively updating the mesh deformation to minimize the cost function. It includes a line search to ensure that each iteration reduces the cost.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n#reset to and solve for initial configuration\ngfset.Set((0,0))\nmesh.SetDeformation(gfset)\nscene = Draw(gfset,mesh,\"gfset\")\nSetVisualization (deformation=True)\n\na.Assemble()\nfstate.Assemble()\nSolveStateEquation()\n\nLineSearch = False\n\niter_max = 600\nJold = Integrate(CostAuto(gfu), mesh)\nconverged = False\nfor k in range(iter_max):\n    scene.Redraw()\n    print('cost at iteration', k, ': ', Jold)\n    mesh.SetDeformation(gfset)\n    \n    a.Assemble()\n    fstate.Assemble()\n    SolveStateEquation()\n    \n    fadjoint.Assemble()\n    SolveAdjointEquation()\n    \n    b.Assemble()\ndJOmegaAuto.Assemble()\nSolveDeformationEquationAuto()\n\n    scale = 0.01 / Norm(gfX.vec)\n    gfsetOld = gfset\n    gfset.vec.data -= scale * gfX.vec\n    \n    Jnew = Integrate(CostAuto(gfu), mesh)\n    \n    if LineSearch:\n        while Jnew > Jold and scale > 1e-12:\n            scale = scale / 2\n            \n            if scale <= 1e-12:\n                converged = True\n                break\n\n            gfset.vec.data = gfsetOld.vec - scale * gfX.vec\n            mesh.SetDeformation(gfset)\n            \n            a.Assemble()\n            fstate.Assemble()\n            SolveStateEquation()\n            Jnew = Integrate(CostAuto(gfu), mesh)\n    \n    if converged==True:\n        break\n    Jold = Jnew\n\n```\n\n----------------------------------------\n\nTITLE: Defining the geometry and mesh\nDESCRIPTION: This code defines the geometry of the domain as a circle using the SplineGeometry class and generates a mesh from it using the GenerateMesh function. The maxh parameter controls the maximum mesh size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\ngeo.AddCircle(c=(0.5,0.5), r=0.5, bc = 'circle')\nmesh = Mesh(geo.GenerateMesh(maxh = 0.08))\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation with CGSolver on Host\nDESCRIPTION: This snippet sets up and solves the Poisson equation using the conjugate gradient (CG) solver on the host. It assembles the bilinear and linear forms, creates a smoother, and solves the system. It measures the time taken for the solution process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.1))\nfor l in range(5): mesh.Refine()\nfes = H1(mesh, order=2, dirichlet=\".*\")\nprint (\"ndof =\", fes.ndof)\n\nu, v = fes.TnT()\nwith TaskManager():\n    a = BilinearForm(grad(u)*grad(v)*dx+u*v*dx).Assemble()\n    f = LinearForm(x*v*dx).Assemble()\n\ngfu = GridFunction(fes)\n\njac = a.mat.CreateSmoother(fes.FreeDofs())\n\nwith TaskManager(): \n    inv_host = CGSolver(a.mat, jac, maxiter=2000)\n    ts = time()\n    gfu.vec.data = inv_host * f.vec\n    te = time()\n    print (\"steps =\", inv_host.GetSteps(), \", time =\", te-ts)\n\n# Draw (gfu);\n```\n\n----------------------------------------\n\nTITLE: H(curl)-AMG Preconditioner Example in Python\nDESCRIPTION: This code snippet demonstrates the setup for the `hcurlamg` preconditioner in NGSolve for an H(curl) problem. It defines an HCurl finite element space and a bilinear form representing the curl-curl operator. The commented-out code shows how to use the `hcurlamg` preconditioner and compute the eigenvalues, but it's noted to be potentially unstable. The bilinear form represents the electromagnetic energy.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.5-amg/amg.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = HCurl(mesh, order=0)\nprint (\"ndof = \", fes.ndof)\nu,v = fes.TnT()\n\na = BilinearForm(curl(u)*curl(v)*dx + 0.01*u*v*dx)\n\n# still crashes from time to time \n# pre = Preconditioner(a, \"hcurlamg\")\n# with TaskManager():\n#    a.Assemble()\n#    lam = EigenValues_Preconditioner(a.mat, pre.mat)\n#    print (list(lam[0:3]), '...', list(lam[-3:-1]))\n```\n\n----------------------------------------\n\nTITLE: Creating Geometry using OCC\nDESCRIPTION: This function creates a 2D geometry representing a heated chip embedded in a base material using Netgen's OCC (Open Cascade) module. It defines the base rectangle, chip, and top rectangle, subtracts the chip from the base, and then glues all the faces together to create a single geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef MakeGeometryOCC():\n    base = Rectangle(1, 0.6).Face()\n    chip = MoveTo(0.5,0.15).Line(0.15,0.15).Line(-0.15,0.15).Line(-0.15,-0.15).Close().Face()\n    top = MoveTo(0.2,0.6).Rectangle(0.6,0.2).Face()\n    base -= chip\n\n    base.faces.name=\"base\"\n    chip.faces.name=\"chip\"\n    chip.faces.col=(1,0,0)\n    top.faces.name=\"top\"\n    geo = Glue([base,chip,top])\n    geo.edges.name=\"default\"\n    geo.edges.Min(Y).name=\"bot\"\n    return OCCGeometry(geo, dim=2)\n\nmesh = Mesh(MakeGeometryOCC().GenerateMesh(maxh=0.2))\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Defining XFEM spaces\nDESCRIPTION: This snippet defines the XFEM spaces VhG. It creates a standard H1 space Vh and an XFESpace Vhx based on the cut information. The XFESpace enriches the standard space with functions that are non-zero only near the interface.  Then it creates a compound space combining the two.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nVh = H1(mesh, order=2, dirichlet=[1,2,3,4])\nVhx = XFESpace(Vh,ci)\nVhG = FESpace([Vh,Vhx])\n```\n\n----------------------------------------\n\nTITLE: Time-Stepping Loop for Wave Equation\nDESCRIPTION: This snippet implements the explicit time-stepping loop for solving the wave equation. It interpolates an initial condition, sets the initial velocity to zero, and then iterates through time, updating the velocity and pressure fields. It also visualizes the solution at regular intervals.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfp.Interpolate( exp(-100*(x**2+y**2+z**2)))\ngfu.vec[:] = 0\n\nscene = Draw (gftr, draw_vol=False, order=3, min=-0.05, max=0.05);\n\nt = 0\ndt = 0.3 * h / (order+1)**2 \ntend = 1\n\nop1 = dt * invmassu @ B\nop2 = dt * invmassp @ B.T\n\ncnt = 0\nwith TaskManager(): \n    while t < tend:\n        t = t+dt\n        gfu.vec.data += op1 * gfp.vec\n        gfp.vec.data -= op2 * gfu.vec\n        cnt = cnt+1\n        if cnt%10 == 0:\n            gftr.vec.data = traceop * gfp.vec\n            scene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh from Geometry (Python)\nDESCRIPTION: This code snippet shows how to generate a mesh from a `SplineGeometry` object using the `GenerateMesh()` method. The resulting mesh can then be used for finite element simulations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nngmesh = geo.GenerateMesh()\n```\n\n----------------------------------------\n\nTITLE: Inspecting Coupling Types\nDESCRIPTION: This snippet iterates through each degree of freedom in the finite element space and prints its coupling type. This information can be used, for example, in the BDDC preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(fes.ndof):\n    print (i,\":\", fes.CouplingType(i))\n```\n\n----------------------------------------\n\nTITLE: Define Facet Space with Highest Order DC in NGSolve\nDESCRIPTION: This snippet defines the facet space with the `highest_order_dc=True` flag, enabling projected jumps.  This setting reduces the polynomial order of the facet-space by one, reducing the number of matrix entries, preserving the order of convergence. Requires definition of trial and test functions for bilinear form.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\norder=4\nV = L2(mesh, order=order)\nF = FacetFESpace(mesh, order=order, dirichlet=\"bottom|left|right|top\", \\\n                          highest_order_dc=True)\nfes = V*F\nu,uhat = fes.TrialFunction()\nv,vhat = fes.TestFunction()\n\njump_u = u-uhat\njump_v = v-vhat\n\nalpha = 2\nh = specialcf.mesh_size\nn = specialcf.normal(mesh.dim)\n\na = BilinearForm(fes, condense=True)\ndS = dx(element_boundary=True)\na += grad(u)*grad(v)*dx + \\\n    alpha*(order+1)**2/h*jump_u*jump_v*dS + \\\n    (-grad(u)*n*jump_v - grad(v)*n*jump_u)*dS\na.Assemble()\n\nf = LinearForm(fes)\nf += 1*v*dx\nf.Assemble()\n\ngfu = GridFunction(fes)\n\nf.vec.data += a.harmonic_extension_trans * f.vec \n    \ninv = a.mat.Inverse(fes.FreeDofs(True), \"sparsecholesky\")\ngfu.vec.data = inv * f.vec\n    \ngfu.vec.data += a.harmonic_extension * gfu.vec\ngfu.vec.data += a.inner_solve * f.vec\n\nDraw (gfu.components[0], mesh, \"u-HDG\")\n\nprint (\"A non-zero elements:\", a.mat.nze)\n```\n\n----------------------------------------\n\nTITLE: Identifying Cut and Uncut Elements\nDESCRIPTION: This snippet uses the CutInfo class to identify cut and uncut elements based on the level set GridFunction. It then prints the indices of the bad (cut) elements and visualizes them on the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nci = CutInfo(mesh, gflset)\nroots = ci.GetElementsOfType(NEG)\nbads = ci.GetElementsOfType(IF)\nprint(\"bad element array: \", bads)\nprint(\"bad elements: \", [i for i in range(len(bads)) if bads[i]])\nDraw(BitArrayCF(bads), mesh, \"bad_elements\")\n```\n\n----------------------------------------\n\nTITLE: Define Geometry and Mesh (Nonlinear Elasticity)\nDESCRIPTION: Defines the geometry for the nonlinear elasticity problem as a rectangle and generates a mesh using Netgen's OCC module, setting boundary names and maxh parameters for specific edges.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# define geometry and generate mesh\nshape = Rectangle(1,0.1).Face()\nshape.edges.Min(X).name=\"left\"\nshape.edges.Min(X).maxh=0.01\nshape.edges.Max(X).name=\"right\"\nshape.edges.Min(Y).name=\"bot\"\nshape.edges.Max(Y).name=\"top\"\ngeom = OCCGeometry(shape, dim=2)\nmesh = Mesh(geom.GenerateMesh(maxh=0.05))\n```\n\n----------------------------------------\n\nTITLE: Define Finite Element Space in Python\nDESCRIPTION: This snippet defines a finite element space (H1) on the generated mesh. The `order` parameter specifies the polynomial order of the finite element space. The `dirichlet` parameter specifies the Dirichlet boundary conditions on the left, right, bottom, and top boundaries of the unit square. The number of degrees of freedom (ndof) is then printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/poisson.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=3, dirichlet=\"left|right|bottom|top\")\nprint (\"ndof =\", fes.ndof)\n```\n\n----------------------------------------\n\nTITLE: Compiling Custom NGSolve Module with CompilePythonModule\nDESCRIPTION: This snippet uses `CompilePythonModule` to compile a C++ module (mymodule.cpp) into a Python module that can be used within NGSolve. The `init_function_name` specifies the name of the initialization function in the C++ module. The module exposes the custom finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom ngsolve.fem import CompilePythonModule\nfrom pathlib import Path\n\nm = CompilePythonModule(Path('mymodule.cpp'), init_function_name='mymodule')\n```\n\n----------------------------------------\n\nTITLE: DomainTypeArray Negation\nDESCRIPTION: This snippet shows how to use the `~` operator to get the complement of a `DomainTypeArray`. The `triangle` is negated to get the region outside the triangle.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ntriangle = DomainTypeArray((NEG,NEG,NEG))\noutside_triangle = ~triangle\noutside_triangle.as_list\n```\n\n----------------------------------------\n\nTITLE: Assembling Symbolic Energy for Minimization problem in ngsolve using python\nDESCRIPTION: This code snippet demonstrates how to assemble the symbolic energy for a minimization problem. It adds the symbolic energy to the functional.  The result is a functional that can be minimized to solve the nonlinear problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/symbolic_integrators.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\na += Symbolic\n```\n\n----------------------------------------\n\nTITLE: Defining Mesh and Finite Element Space\nDESCRIPTION: This snippet defines the mesh, finite element space, bilinear form, linear form, and grid function using NGSolve. It sets up the basic components for solving a PDE.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\n\nfes = H1(mesh, order=2, dirichlet=\".*\")\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx)\nf = LinearForm(v*dx)\ngfu = GridFunction(fes)\n\ndeform = GridFunction(VectorH1(mesh, order=1))\n```\n\n----------------------------------------\n\nTITLE: Iterate and Print Face Centers - Python\nDESCRIPTION: This snippet iterates through the faces of a solid and prints the center of gravity for each face. It demonstrates how to access the faces of a solid and retrieve geometric properties.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nfor f in solid.faces:\n    print (\"center of gravity\", f.center)\n```\n\n----------------------------------------\n\nTITLE: Set Boundary Condition Label - Python\nDESCRIPTION: This snippet assigns a label (string) to a boundary condition using the `bc` parameter. This allows for more descriptive identification of boundary conditions in subsequent simulation or analysis steps.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngeo.Append ([\"line\", p1, p2], bc=\"bottom\")\n```\n\n----------------------------------------\n\nTITLE: Visualizing a CoefficientFunction on a Mesh\nDESCRIPTION: This snippet uses the `Draw` function from `ngsolve.webgui` to visualize the `myfunc` CoefficientFunction on the previously created mesh.  This provides a graphical representation of the function's values across the domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nDraw(myfunc, mesh);\n```\n\n----------------------------------------\n\nTITLE: Generating background mesh\nDESCRIPTION: This snippet creates a simple rectangular geometry using `SplineGeometry` and generates a mesh using `GenerateMesh`. The mesh is then visualized using the `Draw` function. The `maxh` parameter controls the maximum element size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\ngeo.AddRectangle([-1, -0.5], [1, 1.5], bc=1)\nmesh = Mesh (geo.GenerateMesh(maxh=0.3, quad_dominated=False))\nDraw(mesh, 0, 0)\n```\n\n----------------------------------------\n\nTITLE: Creating 1D Periodic Mesh Manually\nDESCRIPTION: This Python code snippet demonstrates how to manually create a 1D mesh with periodic identifications by adding points and setting boundary conditions. It highlights that adding periodic identifications to points lets NGSolve find the periodic vertices the same way as it finds the ones in higher dimensions. The added point numbers must be the ones returned from mesh.Add(MeshPoint). It requires the netgen and ngsolve libraries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/periodic.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.meshing import Mesh, MeshPoint, Element1D, FacetDescriptor\nfrom ngsolve import *\n\nmesh = Mesh()\n\np1 = mesh.Add (MeshPoint(Pnt(0)))\np2 = mesh.Add (MeshPoint(Pnt(1)))\n\nmesh.Add (Element1D ([p1,p2], index=1, mat=1, bc=1))\n\nmesh.AddPeriodicIdentification (p1,p2)\n\nmesh.Finalize()\n\n```\n\n----------------------------------------\n\nTITLE: Drawing component 1 of GridFunction\nDESCRIPTION: This snippet draws the second component of the GridFunction gfu on the mesh, labeling it as \"background_upos\".\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu.components[1], mesh, \"background_upos\")\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Guesses\nDESCRIPTION: This code sets initial guesses for the flux and scalar variable using coefficient functions. This can help with the convergence of the solver or provide a visual check of the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngfsigma.Set(CF( (sin(10*x), sin(10*y)) ))\ngfu.Set (x)\nDraw (gfsigma, mesh, \"flux-mixed\")\nDraw (gfu, mesh, \"u-mixed\");\n```\n\n----------------------------------------\n\nTITLE: Setting Local Mesh Size with CSGeometry in Netgen\nDESCRIPTION: This code snippet demonstrates how to set local mesh sizes on boundaries within a CSGeometry object in Netgen. It involves defining the geometry and specifying the desired mesh size when adding objects to the geometry. The code defines a box, a cylinder, and sets specific maxh values for the box.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/meshsize.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport netgen.gui\nfrom netgen.csg import *\n\ngeo = CSGeometry()\n\nbox = Box(Pnt(-1,-1,-1),Pnt(2,2,2)).bc(\"outer\")\ncyl = Cylinder(Pnt(0,0,0), Pnt(0,0,3), 0.8).bc(\"cyl\")\n\ngeo.Add (box.Cut(cyl))\ngeo.Add (cyl.Cut(box), maxh=0.2)\n\nmesh = geo.GenerateMesh(maxh=0.4)\n\n# netgen.gui.Draw (mesh)\n```\n\n----------------------------------------\n\nTITLE: CUDA Toolkit Integration - CMake\nDESCRIPTION: This snippet finds the CUDA toolkit, enables CUDA language support, and adds the CUDA definition.  It prepares the project to compile CUDA code by locating necessary CUDA tools and libraries. It also includes the current source directory to find headers.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(CUDAToolkit)\nenable_language(CUDA)\n\nadd_compile_definitions(CUDA)\n\ninclude_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Generate and Draw a Mesh\nDESCRIPTION: This snippet generates a mesh of the unit cube using `unit_cube.GenerateMesh` with a maximum element size of 1 and visualizes it using the `Draw` function. It relies on the `ngsolve` library for mesh generation and `ngsolve.webgui` for rendering.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_cube.GenerateMesh(maxh=1))\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Assembling Linear Form and Right-Hand Side - Python\nDESCRIPTION: This code assembles the linear form `f` which corresponds to the source term in the Poisson equation, and constructs the right-hand side vector `r` by subtracting the product of the assembled matrix `a.mat` and the boundary condition grid function `gfu.vec` from the assembled linear form vector `f.vec`.  This implements  r = f - A u_D\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.3-dirichlet/dirichlet.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(1*v*dx).Assemble()\nr = f.vec - a.mat * gfu.vec\n```\n\n----------------------------------------\n\nTITLE: Generate Mesh with NGSolve\nDESCRIPTION: This snippet generates a finite element mesh from the previously defined geometry using NGSolve. It specifies the maximum element size (maxh=0.07) and increases the polynomial order of the elements to 3.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(OCCGeometry(shape, dim=2).GenerateMesh(maxh=0.07)).Curve(3)\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom WebGL Scene with Binary Archive\nDESCRIPTION: This code defines a custom `NewWebGLScene` class that inherits from `BaseWebGuiScene`.  It uses `comp.ToArchive` to serialize the mesh and coefficient function into a binary archive for efficient transfer to the web browser. The `GetData` method returns a dictionary containing the archive type, the serialized data, and the order of the finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/emscripten/example.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass NewWebGLScene(BaseWebGuiScene):\n    def __init__(self, mesh, cf, binary=True, order=1):\n        self.mesh = mesh\n        self.cf = cf\n        self.binary = binary\n        self.order = order\n    def GetData(self, set_minmax=True):\n        return {\n                \"type\": \"BinaryArchive\" if self.binary else \"TextArchive\",\n                \"data\": comp.ToArchive(self.mesh, self.cf, self.binary),\n                \"order\": self.order\n        }\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear and Linear Forms for TDNNS in NGSolve\nDESCRIPTION: This snippet defines the bilinear and linear forms for the TDNNS method. It sets up the variational formulation, including terms for the stress tensor, rotation, and vertical deflection.  The snippet also defines the linear form corresponding to the applied force and creates a GridFunction to store the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nn = specialcf.normal(2)\n    \na = BilinearForm(fes)\na += (-12/t**3*InnerProduct(CMatInv(sigma, E, nu),dsigma) + InnerProduct(dsigma,grad(beta)) + InnerProduct(sigma,grad(dbeta)))*dx\na += ( -((sigma*n)*n)*(dbeta*n) - ((dsigma*n)*n)*(beta*n) )*dx(element_boundary=True)\na += t*k*G*InnerProduct( grad(u)-beta, grad(du)-dbeta )*dx\n\nf = LinearForm(fes)\nf += -fz*du*dx\n\ngfsol = GridFunction(fes, autoupdate=True)\ngfu, gfbeta, gfsigma = gfsol.components\n```\n\n----------------------------------------\n\nTITLE: Visualizing Displacement\nDESCRIPTION: Visualizes the displacement field `gfu` on the mesh. The displacement is scaled by a factor of 5e4 for better visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nDraw (5e4*gfu, mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Geometry and Mesh in NGSolve\nDESCRIPTION: This snippet defines the computational domain as a unit square with extended boundaries and generates a mesh using SplineGeometry from netgen. The mesh is created with a specified maximum element size (maxh).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\ngeo.AddRectangle((-0.2, -0.2), (1.2, 1.2), bcs=(\"bottom\", \"right\", \"top\", \"left\"))\nmesh = Mesh(geo.GenerateMesh(maxh=0.1))\n```\n\n----------------------------------------\n\nTITLE: Vector CoefficientFunction creation and component access\nDESCRIPTION: This snippet demonstrates how to create a vector-valued CoefficientFunction from two scalar CoefficientFunctions (fx, fy), and how to access individual components of the vector CoefficientFunction using the bracket operator. Requires pre-defined CoefficientFunctions `fx` and `fy`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/coefficient.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nvec_cf = CoefficientFunction( (fx,fy) )  # Creates a vector CF\nfx_again = vec_cf[0]                     # Creates a scalar CF from the first component\n```\n\n----------------------------------------\n\nTITLE: Creating GridFunctions for Space-Time Solution - Python\nDESCRIPTION: This snippet creates `GridFunction` objects for storing the space-time solution. `gfu` stores the full space-time solution.  `u_last` stores the solution from the previous time step, restricting the space-time GridFunction to a specific time. Trial and test functions `u` and `v` are defined on the space-time finite element space.  `CreateTimeRestrictedGF` creates a GridFunction for the spatial domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(st_fes)\nu_last = CreateTimeRestrictedGF(gfu, 1)\nu, v = st_fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Define Material Parameters (Nonlinear Elasticity)\nDESCRIPTION: Defines material parameters (E module and Poisson number), computes Lam constants, and sets up the finite element space using VectorH1 elements. It also defines a coefficient function for gravity.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# E module and poisson number:\nE, nu = 210, 0.2\n# Lam constants:\nmu  = E / 2 / (1+nu)\nlam = E * nu / ((1+nu)*(1-2*nu))\n\nV = VectorH1(mesh, order=2, dirichlet=\"left\")\nu  = V.TrialFunction()\n\n#gravity:\nforce = CoefficientFunction( (0,-1) )\n```\n\n----------------------------------------\n\nTITLE: Creating Geometry and Mesh for NGSolve Simulation\nDESCRIPTION: This snippet defines the geometry of a quarter circle using SplineGeometry from the netgen.geom2d library.  It appends points and lines to define the geometry, applies boundary conditions, generates a mesh, and curves the mesh to a specified order. It uses the Draw function for visualizing the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsg = SplineGeometry()\npnts = [ (0,0), (R,0), (R,R), (0,R) ]\npind = [ sg.AppendPoint(*pnt) for pnt in pnts ]\nsg.Append(['line',pind[0],pind[1]], leftdomain=1, rightdomain=0, bc=\"bottom\")\nsg.Append(['spline3',pind[1],pind[2],pind[3]], leftdomain=1, rightdomain=0, bc=\"circ\")\nsg.Append(['line',pind[3],pind[0]], leftdomain=1, rightdomain=0, bc=\"left\")\nmesh = Mesh(sg.GenerateMesh(maxh=R/3))\nmesh.Curve(order)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Smoothed Indicator of Boundary\nDESCRIPTION: This snippet shows how to visualize the smoothed indicator function of the boundary of the region. The `boundary.IndicatorSmoothed(level_sets_p1, eps)` returns a CoefficientFunction that has the value 1 in the `eps`-strip around the interface.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(boundary.IndicatorSmoothed(level_sets_p1, 0.05/interactive), -3.5, 2.5, mesh,\n       \"boundary_indicator\")\n```\n\n----------------------------------------\n\nTITLE: Create Catch2 Main Library (CMake)\nDESCRIPTION: This snippet creates a static library named `catch_main` from the `main.cpp` file, which provides the `main` function for the Catch2 testing framework. It includes the necessary Catch2 header files via `include_directories` and sets the C++ standard to 17.  It also establishes dependencies between `unit_tests`, `catch_main`, and `project_catch`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/catch/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories(${CATCH_INCLUDE_DIR})\nadd_library(catch_main STATIC main.cpp)\nset_target_properties(catch_main PROPERTIES CXX_STANDARD 17)\nadd_dependencies(unit_tests catch_main)\nadd_dependencies(catch_main project_catch)\n```\n\n----------------------------------------\n\nTITLE: Set Mesh Size for One Solid in Netgen\nDESCRIPTION: This snippet shows how to set a specific mesh size for one particular solid within a geometry by adding the maxh argument when adding the solid to the CSGeometry. This allows for local mesh refinement.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\n\nbrick = OrthoBrick(Pnt(-2,-2,-2),Pnt(2,2,2))\nsphere = Sphere(Pnt(0,0,0),1)\n\ngeo.Add(brick-sphere)\ngeo.Add(sphere,maxh=0.1)\nngmesh = geo.GenerateMesh(maxh=0.4)\n```\n\n----------------------------------------\n\nTITLE: Vectorized Evaluation of a CoefficientFunction using NumPy\nDESCRIPTION: This snippet demonstrates how to use NumPy for vectorized evaluation of a CoefficientFunction.  It creates NumPy arrays for the x and y coordinates and then evaluates `myfunc` at all points simultaneously using `mesh`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nX = np.linspace(0, 1, num=11)\nY = np.ones_like(X) * 0.2\nmyfunc(mesh(X, Y))\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System\nDESCRIPTION: This snippet defines a function `SolveLinearSystem` to solve the linear system arising from the finite element discretization. It homogenizes boundary conditions, subtracts the contribution from known boundary values, and solves the system using the inverse of the stiffness matrix restricted to the free degrees of freedom.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# homogenization of boundary data and solution of linear system\ndef SolveLinearSystem():\n    gfu.vec[:] = 0\n    f.vec.data -= a.mat * gfu.vec\n    gfu.vec.data += a.mat.Inverse(freedofs) * f.vec\nSolveLinearSystem()\n\nDrawDC(lsetp1, gfu.components[0], gfu.components[1], mesh, \"u\", min=0, max=0.25)\n```\n\n----------------------------------------\n\nTITLE: Applying Inhomogeneous Dirichlet Boundary Condition\nDESCRIPTION: This snippet applies an inhomogeneous Dirichlet boundary condition on the inlet boundary for the velocity field. A CoefficientFunction is used to define the inlet velocity profile, and the GridFunction is set on the inlet boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngf = GridFunction(X)\ngfu, gfp = gf.components\n\nuin = CF ( (1.5*4*y*(0.41-y)/(0.41*0.41), 0) )\ngfu.Set(uin, definedon=mesh.Boundaries(\"inlet\"))\nDraw(gfu, mesh, min=0, max=2)\nSetVisualization(max=2)\n```\n\n----------------------------------------\n\nTITLE: Multiplicative Multigrid Usage - Python\nDESCRIPTION: This snippet demonstrates how to use the `MGPreconditioner` class. It assembles the bilinear form, initializes the preconditioner, refines the mesh, and updates the preconditioner at each level. It also calculates and prints the condition number.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()\npre = MGPreconditioner(fes, 0, a.mat, None)\n    \nfor l in range(9):\n    mesh.Refine()\n    a.Assemble()\n    pre = MGPreconditioner(fes,l+1, a.mat, pre)    \n    lam = EigenValues_Preconditioner(a.mat, pre)\n    print(\"ndof=%7d:  minew=%.4f  maxew=%1.4f  Cond# = %5.3f\" \n          %(fes.ndof, lam[0], lam[-1], lam[-1]/lam[0]))\n```\n\n----------------------------------------\n\nTITLE: Calculating the shape derivative\nDESCRIPTION: This code calculates the shape derivative by defining a Lagrangian and differentiating it with respect to the shape transformation parameters. It defines a finite element space for the deformation field and a linear form representing the shape derivative.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nVEC = H1(mesh, order=2, dim=2)\nPHI, X = VEC.TnT()\n\nLagrangian = CostAuto(gfu) + Equation(gfu,gfp)\ndJOmegaAuto = LinearForm(VEC)\ndJOmegaAuto += Lagrangian.Diff(J, div(X))\ndJOmegaAuto += Lagrangian.Diff(F, grad(X).trans)   # grad(X).trans is Jacobian\ndJOmegaAuto += Lagrangian.Diff(x, X[0]) + Lagrangian.Diff(y, X[1])\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear Form and Setting GridFunction in Python\nDESCRIPTION: This snippet assembles a bilinear form and creates a GridFunction. It sets all values of the GridFunction to 1. The GridFunction is used to store finite element functions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.2-pardofs/pardofs.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%px\nu,v = fes.TnT()\nM = BilinearForm(u*v*dx).Assemble().mat\ngfu = GridFunction(fes)\ngfu.Set (1)\nprint (gfu.vec)\n```\n\n----------------------------------------\n\nTITLE: Assemble BilinearForm with Skeleton Integrals in NGSolve\nDESCRIPTION: This snippet sets up and assembles a bilinear form with integrals over the skeleton (internal facets). This is used to illustrate that memory is reserved for the matrix entries, even if they are numerically zero. `u.Other()` accesses the value of `u` from the neighboring element.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfes2 = L2(mesh, order=order, dgjumps=True)\nu,v=fes2.TnT()\na3 = BilinearForm(fes2)\na3 += u*v*dx + (u+u.Other())*v*dx(skeleton=True)\na3.Assemble();\n```\n\n----------------------------------------\n\nTITLE: Post-processing Scalar Variable\nDESCRIPTION: This snippet implements a post-processing technique to recover a more accurate scalar variable. It defines new finite element spaces `fespost_u` and `fespost_lam`, assembles the corresponding bilinear and linear forms, and solves for the post-processed solution `gfpost`.  Finally, the error is printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfespost_u = L2(mesh, order=order_flux+1)\nfespost_lam = L2(mesh, order=0)\nfes_post = fespost_u*fespost_lam\n\n(u,la),(v,mu) = fes_post.TnT()\n\na = BilinearForm( (lam*grad(u)*grad(v)+la*v+mu*u)*dx).Assemble()\nf = LinearForm((gfsigma*grad(v)+gfu*mu)*dx).Assemble()\n\ngfpost = GridFunction(fes_post)\ngfpost.vec.data = a.mat.Inverse() * f.vec\n\nDraw (gfpost.components[0], mesh, \"upost\")\nprint (\"err-upost:   \", sqrt(Integrate( (gfup-gfpost.components[0])**2, mesh)))\n```\n\n----------------------------------------\n\nTITLE: Drawing the Solution (Python)\nDESCRIPTION: This code snippet demonstrates how to draw the solution on the master process (rank 0) using NGSolve's `Draw` function.  The solution from process 0 is used. Requires ngsolve.webgui.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom ngsolve.webgui import Draw\nDraw (gfu[0]);\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories\nDESCRIPTION: Specifies the include directories for the NGSolve project. It includes directories for various submodules such as `ngstd`, `basiclinalg`, `fem`, and also the `NETGEN_INCLUDE_DIRS`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_25\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories (BEFORE\n  ${PROJECT_BINARY_DIR}\n  ${PROJECT_SOURCE_DIR}/include\n  ${PROJECT_SOURCE_DIR}/ngstd\n  ${PROJECT_SOURCE_DIR}/basiclinalg\n  ${PROJECT_SOURCE_DIR}/fem\n  ${PROJECT_SOURCE_DIR}/linalg\n  ${PROJECT_SOURCE_DIR}/comp\n  ${PROJECT_SOURCE_DIR}/multigrid\n  ${PROJECT_SOURCE_DIR}/parallel\n  ${PROJECT_SOURCE_DIR}/solve\n  ${PROJECT_SOURCE_DIR}/ngscuda\n  )\ninclude_directories (AFTER ${NETGEN_INCLUDE_DIRS})\n```\n\n----------------------------------------\n\nTITLE: Accessing Sparse Matrix Information in NGSolve\nDESCRIPTION: This snippet shows how to access the row indices, column indices, and values of a sparse matrix stored in NGSolve. The bilinear form 'a' is assumed to have a 'mat' attribute representing the sparse matrix. Note that if the matrix is symmetric, only one half of it is returned.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_numpy.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nrows,cols,vals = a.mat.COO()\n```\n\n----------------------------------------\n\nTITLE: Visualizing B-field - Python\nDESCRIPTION: This snippet visualizes the magnetic field (B-field) which is the curl of the solution `u`. The `Draw` function displays the B-field on the mesh.  Clipping planes and vector field options are also used for clearer visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/maxwell.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nDraw (curl(u), mesh, \"B-field\", draw_surf=False, \\\n      clipping = { \"pnt\" : (0,0,0), \"vec\" : (0,1,0), \"function\" : False },\n      vectors = { \"grid_size\" : 100 })\n```\n\n----------------------------------------\n\nTITLE: Printing Number of Degrees of Freedom in NGSolve FESpace\nDESCRIPTION: This snippet prints the number of degrees of freedom (ndof) in the finite element space. This provides information on the size of the linear system to be solved.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nprint (\"ndof = \", fes.ndof)\n```\n\n----------------------------------------\n\nTITLE: Creating Element Aggregation Patches\nDESCRIPTION: This code creates an ElementAggregation object using the mesh and the sets of root (uncut) and bad (cut) elements. It then visualizes the patch number for each element on the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nEA = ElementAggregation(mesh, roots, bads)\npatch_number_field = GridFunction(L2(mesh))\npatch_number_field.vec.FV()[:] = EA.element_to_patch\nDraw(patch_number_field, mesh, \"patch_number_field\", deformation=CF((0,0,0.02*patch_number_field)))\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This snippet imports the required modules from NGSolve, NGSolve's web GUI, and Netgen for geometry creation and meshing.  It's a standard starting point for NGSolve projects.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/helmholtz.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\nfrom netgen.geom2d import SplineGeometry\n```\n\n----------------------------------------\n\nTITLE: Visualizing the intersection of level sets\nDESCRIPTION: This snippet visualizes the region where all three level set functions are negative, representing the interior of the triangle. It uses a `CoefficientFunction` and a conditional expression to define the indicator function for this region, and displays it using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nDraw(CoefficientFunction((level_sets_p1[0], level_sets_p1[1], level_sets_p1[2], 0)),\n     mesh, \"NEG-NEG-NEG\", min=-1, max=1,\n     eval_function=\"value.x<0.0?(value.y<0.0?(value.z<0.0?1.0:-1.0):-1.0):-1.0\")\n```\n\n----------------------------------------\n\nTITLE: SymbolicLFI with coordinate CoefficientFunction\nDESCRIPTION: This code snippet demonstrates how to use the predefined coordinate coefficient functions (x, y, z) within a SymbolicLFI in NGSolve.  It initializes a LinearForm on a FESpace V and adds a term where the x coordinate is multiplied by the test function.  Requires NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/coefficient.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(V)\nf += SymbolicLFI( x * V.TestFunction())\n```\n\n----------------------------------------\n\nTITLE: Draw Element-wise Postprocessed Solution in NGSolve (Python)\nDESCRIPTION: This code draws the element-wise postprocessed solution `gfps` on the physical domain using `DrawDC` function. It sets the minimum and maximum of the color scale to -1 and 1, and also applies the deformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(lsetp1,gfps,-1,mesh,\"p\",deformation=deformation, min=-1, max=1)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Files (CMake)\nDESCRIPTION: Installs various Python files, including configuration scripts, modules, and solver implementations, into the `${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve` directory. The `DESTINATION` specifies the installation path, and `COMPONENT` labels these files as part of the `ngsolve` component.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/python/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninstall (FILES\n            ${CMAKE_CURRENT_BINARY_DIR}/config.py\n            config/__init__.py\n            config/__main__.py\n            DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/config/\n            COMPONENT ngsolve\n            )\n\n    install (FILES\n            __expr.py internal.py __console.py webgui.py\n            __init__.py utils.py solvers.py eigenvalues.py meshes.py\n            krylovspace.py nonlinearsolvers.py bvp.py preconditioners.py timing.py TensorProductTools.py\n            ngs2petsc.py ngscxx.py directsolvers.py timestepping.py\n            _scikit_build_core_dependencies.py\n            DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve\n            COMPONENT ngsolve\n            )\n```\n\n----------------------------------------\n\nTITLE: Defining Volume Integrals - Python\nDESCRIPTION: This code defines the element-local volume integrals for the DG formulation. It creates a bilinear form `c1` on the `VT` space and adds the term `-uT * b * grad(vT) * dx`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nuT, vT = VT.TnT()\nc1 = BilinearForm(space=VT, nonassemble=True)                     # part 1\nc1 += -uT * b * grad(vT) * dx\n```\n\n----------------------------------------\n\nTITLE: Defining Periodic Geometry and Generating Mesh in NGSolve\nDESCRIPTION: This snippet defines a periodic geometry using `Rectangle` and `Identify` to create periodic boundary conditions. It then generates a mesh using `OCCGeometry` and `GenerateMesh`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# define periodic geometry and generate mesh\nshape = Rectangle(1,1).Face()\nright=shape.edges.Max(X)\nright.name=\"right\"\nshape.edges.Min(X).Identify(right,name=\"left\")\ntop=shape.edges.Max(Y)\ntop.name=\"top\"\nshape.edges.Min(Y).Identify(top,name=\"bottom\")\ngeom = OCCGeometry(shape, dim=2)\nmesh = Mesh(geom.GenerateMesh(maxh=0.1))\n```\n\n----------------------------------------\n\nTITLE: Timing Matrix-Vector Multiplication (Python)\nDESCRIPTION: This code snippet measures the time it takes to perform a matrix-vector multiplication using the bilinear form's matrix.  The %timeit magic command in IPython/Jupyter Notebook runs the statement multiple times and reports the average execution time. This is used to compare the performance of matrix-vector multiplication with and without the geom_free flag.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nvx = b.mat.CreateRowVector()\nvy = b.mat.CreateColVector()\nvx[:] = 1\n\n%timeit vy.data = b.mat * vx\n```\n\n----------------------------------------\n\nTITLE: Matrix Dimension Comparison - Python\nDESCRIPTION: This snippet prints the height and width of the matrices generated by the RestrictedBilinearForm and the full BilinearForm, demonstrating that the restriction does not affect the matrix dimensions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nprint(a.mat.height,a.mat.width)\nprint(a_full.mat.height,a_full.mat.width)\n```\n\n----------------------------------------\n\nTITLE: Drawing the electric potential\nDESCRIPTION: This code snippet visualizes the calculated electric potential using the Draw function. Clipping is used to show a cross-section of the potential distribution within the coil.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfphi, draw_vol=False, clipping={\"y\":1, \"z\":0, \"dist\":0.012});\n```\n\n----------------------------------------\n\nTITLE: Generating Matrix Kernel Header Files\nDESCRIPTION: This snippet uses `add_custom_command` to generate multiple matrix kernel header files (matkernel_1.hpp, matkernel_2.hpp, matkernel_4.hpp, matkernel_8.hpp) by executing the kernel generator with different arguments.  The generated headers depend on the `kernel_generator` executable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_command(OUTPUT  matkernel_1.hpp matkernel_2.hpp matkernel_4.hpp matkernel_8.hpp\n  COMMAND ${kernel_command} matkernel_1.hpp 1\n  COMMAND ${kernel_command} matkernel_2.hpp 2\n  COMMAND ${kernel_command} matkernel_4.hpp 4\n  COMMAND ${kernel_command} matkernel_8.hpp 8\n  DEPENDS kernel_generator\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating over a region of co-dimension 2 (point evaluation)\nDESCRIPTION: This snippet performs point evaluation at the intersection of two level sets by integrating the function (x**2 + y**2) over the region where two level set functions are zero (IF) and the third one is negative. The result is compared to the exact value to calculate the error.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npoint_val = Integrate((x**2 + y**2) * dCut(level_sets_p1, (IF, IF, NEG), order=0), mesh)\n\nprint(\"Result of the integration: {}\".format(point_val))\nprint(\"Error of the integration: {:5.3e}\".format(abs(point_val - 1.25)))\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces for HHJ Method\nDESCRIPTION: This code defines the finite element spaces for the Hellan-Herrmann-Johnson (HHJ) mixed method.  It uses an HDivDiv space (V) for the bending moments and an H1 space (Q) for the displacement. The dirichlet boundary conditions are applied to the H1 space. These spaces are combined in X = V*Q.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.9-fourthorder/fourthorder.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\norder = 3\n\nV = HDivDiv(mesh, order=order-1) \nQ = H1(mesh, order=order, dirichlet=\"left|bottom|top|right\")\nX = V*Q\n\nprint (\"ndof-V:\", V.ndof, \", ndof-Q:\", Q.ndof)\n\nsigma, w = X.TrialFunction()\ntau, v = X.TestFunction()\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve Modules\nDESCRIPTION: This snippet imports the necessary modules from the NGSolve library, including the core NGSolve functionality and the web GUI for visualization. It then creates a mesh of the unit square with a specified maximum element size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.3))\n```\n\n----------------------------------------\n\nTITLE: Generating the mesh\nDESCRIPTION: This code snippet generates a finite element mesh of the combined coil and air geometry. It uses the OCCGeometry class to integrate with the CAD geometry and calls the GenerateMesh method to create the mesh.  The mesh is then curved using the Curve operator for higher-order accuracy. A task manager is used to handle the meshing process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngeo = OCCGeometry(Glue([coil,air]))\nwith TaskManager():\n    mesh = Mesh(geo.GenerateMesh(meshsize.coarse, maxh=0.01)).Curve(3)\n    \nDraw (mesh, clipping={\"y\":1, \"z\":0, \"dist\":0.012});\n```\n\n----------------------------------------\n\nTITLE: Importing ngscuda and Creating Device Vector\nDESCRIPTION: This snippet attempts to import the ngscuda module, which provides GPU acceleration for NGSolve. If the module is not available, it prints a message and uses replacement types on the host. It then creates a device vector for the linear form f, copying data to the device.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from ngsolve.ngscuda import *\nexcept:\n    print (\"no CUDA library or device available, using replacement types on host\")\n    \nngsglobals.msg_level=1\nfdev = f.vec.CreateDeviceVector(copy=True)\n```\n\n----------------------------------------\n\nTITLE: Visualizing HCurl Edge Basis Function\nDESCRIPTION: This snippet demonstrates how to access and visualize basis functions associated with an edge in the HCurl space. It retrieves the DOFs associated with edge 10, sets all `GridFunction` values to zero, sets the first DOF of the edge to 1, and visualizes the basis function and its curl.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nedge_dofs = fes.GetDofNrs(NodeId(EDGE,10))\nprint (\"edgedofs: \", edge_dofs)\nuc.vec[:] = 0\nuc.vec[edge_dofs[0]] = 1\nDraw (uc, min=0, max=3, vectors = { \"grid_size\":30})\nDraw (curl(uc), mesh, \"curl\", min=-25, max=25);\n```\n\n----------------------------------------\n\nTITLE: Animating mesh rotation\nDESCRIPTION: This snippet animates the rotation of the mesh by repeatedly calling the `MeshRotation` function with an increasing angle and setting the deformation of the mesh.  The simulation is visualized using the `Draw` function, which redraws the mesh after each rotation step.  It initializes the scene and sets mesh deformation according to the rotation function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nscene = Draw(mesh)\ntau1 = 1e-3\nfor step in range(int(tend/tau1)):\n    MeshRotation(step*omega*tau1, deformation)\n    mesh.SetDeformation(deformation)\n    scene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Creating Anisotropic Meshes Using Close Surface Identification in Netgen\nDESCRIPTION: This snippet shows how to create anisotropic meshes in Netgen using close surface identification. It constructs a geometry with a thin plate and uses the 'close surface' feature to generate a mesh suitable for thin layers, resulting in prism-shaped elements. The code defines a box with different x, y, and z dimensions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/meshsize.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport netgen.gui\nfrom netgen.csg import *\n\ngeo = CSGeometry()\n\nplate = Box(Pnt(-1,-1,-0.05), Pnt(1,1,0.05)).bc(\"plate\")\nair = Box(Pnt(-1.5,-1.5,-0.5), Pnt(1.5,1.5,0.5)).bc(\"air\")\n\ngeo.Add (plate)\ngeo.Add (air.Cut(plate))\n\ngeo.SetMaterial(\"plate\")\ngeo.SetCloseSurface (\"plate\")\n\nmesh = geo.GenerateMesh(maxh=0.2)\n\n# netgen.gui.Draw (mesh)\n```\n\n----------------------------------------\n\nTITLE: Adding Quadrilateral Elements in 2D\nDESCRIPTION: This snippet adds quadrilateral elements to the mesh, connecting the points created in the previous step.  It defines a region named \"mat\" and then iterates through the grid, creating `Element2D` objects using the `PointId` objects in the `pnums` array. The vertices are ordered to define the quadrilateral correctly.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nidx_dom = ngmesh.AddRegion(\"mat\", dim=2)\nfor j in range(N):\n    for i in range(N):\n        ngmesh.Add(Element2D(idx_dom, [pnums[i + j * (N + 1)],\n                               pnums[i + (j + 1) * (N + 1)],\n                               pnums[i + 1 + (j + 1) * (N + 1)],\n                               pnums[i + 1 + j * (N + 1)]]))\n```\n\n----------------------------------------\n\nTITLE: Drawing the magnetic field\nDESCRIPTION: This code snippet visualizes the magnetic field (curl of the magnetic vector potential) using the Draw function. Clipping is used to show a cross-section, and vectors are used to represent the field direction and magnitude.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nDraw (curl(gfu), mesh, draw_surf=False, \\\n      min=0, max=3e-4, clipping = { \"y\":1, \"z\" : 0, \"function\":False}, vectors = { \"grid_size\":100});\n```\n\n----------------------------------------\n\nTITLE: Creating wires and faces with holes\nDESCRIPTION: This example demonstrates how to create wires and faces with holes using workplanes. It creates a rectangle with two circular holes by creating circles and reversing their orientation using `.Reverse()`. `Compound(wp.Wires())` creates a compound object from the wires. `wp.Face()` creates a face from the wires, including the holes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/workplane.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwp=WorkPlane().RectangleC(2,1) \\\n    .Circle(0.5,0,0.2).Reverse() \\\n    .Circle(-0.5,0,0.2).Reverse()\nDrawGeo(Compound(wp.Wires()))\nDrawGeo(wp.Face());\n```\n\n----------------------------------------\n\nTITLE: Visualizing a boundary CoefficientFunction using a GridFunction\nDESCRIPTION: This snippet demonstrates visualizing a boundary `CoefficientFunction` by setting its values onto a `GridFunction` defined on the boundary regions ('b' and 'r'). This effectively extends the boundary values into the domain, allowing for visualization. This overcomes the limitation of not being able to directly draw the raw `BoundaryCF`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ng = GridFunction(H1(mesh), name='bdry')\ng.Set(cf, definedon=mesh.Boundaries('b|r'))\nDraw(g);\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System with SciPy CG Solver\nDESCRIPTION: This snippet demonstrates how to use SciPy's Conjugate Gradient (CG) solver to solve a linear system with an NGSolve matrix. It defines a `LinearOperator` that wraps the matrix-vector product of the NGSolve matrix and uses the CG solver to find the solution. Requires SciPy to be installed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_numpy.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport scipy\nimport scipy.sparse.linalg\n\ntmp1 = f.vec.CreateVector()\ntmp2 = f.vec.CreateVector()\ndef matvec(v):\n    tmp1.FV().NumPy()[:] = v\n    tmp2.data = a.mat * tmp1\n    return tmp2.FV().NumPy()\n\nA = scipy.sparse.linalg.LinearOperator( (a.mat.height,a.mat.width), matvec)\n\nu.vec.FV().NumPy()[:], succ = scipy.sparse.linalg.cg(A, f.vec.FV().NumPy())\n```\n\n----------------------------------------\n\nTITLE: Solving and Drawing the Solution\nDESCRIPTION: This snippet demonstrates solving the problem with specific parameter values (0.8, 0.5) and visualizing the solution using NGSolve's `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nSolve(0.8, 0.5)\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Add Solid to CSGeometry and Generate Mesh in Netgen\nDESCRIPTION: This snippet shows how to add the previously created cube solid to a CSGeometry object and generate a mesh with a specified maximum element size (maxh). The Redraw function updates the visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\ngeo.Add (cube)\n\nmesh = geo.GenerateMesh(maxh=0.25)\nRedraw()\n# mesh.Save(\"cube.vol\")\n```\n\n----------------------------------------\n\nTITLE: Creating 3D Periodic Mesh\nDESCRIPTION: This Python code snippet demonstrates how to create a 3D periodic mesh using Netgen and NGSolve. It defines a cube with periodicity in the x-direction using CSGeometry.PeriodicSurfaces and then creates a periodic NGSolve mesh from it. It requires the ngsolve library.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/periodic.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import SplineGeometry\nfrom netgen.csg import CSGeometry\nfrom netgen.meshing import Mesh, IntegrationPoint\n\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\n# cube with periodicity in x-direction\ngeo = CSGeometry()\ngeo.AddCube ((-0.1, -0.4, -0.4), (1.1, 0.4, 0.4), bc=1)\ngeo.PeriodicSurfaces(faces=[1,3], orientation=1) #left, right\nmesh = Mesh(geo.GenerateMesh(maxh=0.3))\n\n```\n\n----------------------------------------\n\nTITLE: Defining Geometry and Mesh\nDESCRIPTION: This snippet defines the geometry (plate with a hole) using netgen CSG2d and generates a mesh for finite element analysis. It also defines points of interest for post-processing, such as node_A and node_B.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# polynomial order for geometry and displacements\norder = 3\n\ngeo = CSG2d()\ncircle = Circle(center=(100,100), radius=10.0, bc=\"curve\").Maxh(1)\nrect = Rectangle(pmin=(0,100), pmax=(100,200), bottom=\"bottom\", left=\"left\", top=\"top\", right=\"right\")\ngeo.Add(rect-circle)\nmesh = Mesh(geo.GenerateMesh(maxh=5))\nmesh.Curve(order)\nDraw(mesh)\n\n# points of interest for post-processing\nnode_A = mesh(100,200)\nnode_B = mesh(0,200)\n```\n\n----------------------------------------\n\nTITLE: Solving and Visualizing HHJ Solution\nDESCRIPTION: This snippet solves the linear system resulting from the HHJ mixed formulation and visualizes the solution.  It initializes a GridFunction on the product space X, solves the system using a sparse direct solver, and then draws the bending moments and displacement fields.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.9-fourthorder/fourthorder.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(X)\ngfu.vec.data = a.mat.Inverse(X.FreeDofs()) * f.vec\n\nDraw (gfu.components[0], mesh, name=\"sigma\")\nDraw (gfu.components[1], mesh, name=\"disp\");\n```\n\n----------------------------------------\n\nTITLE: Defining integration domains\nDESCRIPTION: This snippet defines the integration domains for the Nitsche discretization, using the dCut differential symbol to integrate only on the subdomains or the interface. It marks the integrals as undefined where they would be zero anyway to speed up assembly.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndx_neg = dCut(levelset=lsetp1, domain_type=NEG, definedonelements=ci.GetElementsOfType(HASNEG))\ndx_pos = dCut(levelset=lsetp1, domain_type=POS, definedonelements=ci.GetElementsOfType(HASPOS))\nds = dCut(levelset=lsetp1, domain_type=IF, definedonelements=ci.GetElementsOfType(IF))\n```\n\n----------------------------------------\n\nTITLE: Defining a geometry with named subdomains and boundaries\nDESCRIPTION: This snippet defines a geometry with two subdomains (inner and outer) and assigns names to the boundaries of the outer rectangle (top, bottom, left, right) and the interface between the two subdomains. It utilizes OpenCascade for the geometry creation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nouter = Rectangle(2, 2).Face()\nouter.edges.name=\"outer\"\nouter.edges.Max(X).name = \"r\"\nouter.edges.Min(X).name = \"l\"\nouter.edges.Min(Y).name = \"b\"\nouter.edges.Max(Y).name = \"t\"\n\ninner = MoveTo(1, 0.9).Rectangle(0.3, 0.5).Face()\ninner.edges.name=\"interface\"\nouter = outer - inner\n\ninner.faces.name=\"inner\"\ninner.faces.col = (1, 0, 0)\nouter.faces.name=\"outer\"\n\ngeo = Glue([inner, outer])\nDraw(geo);\n```\n\n----------------------------------------\n\nTITLE: Initializing SplineGeometry for 2D Meshing (Python)\nDESCRIPTION: This snippet initializes a `SplineGeometry` object from the `netgen.geom2d` module and imports necessary modules from `ngsolve` and `ngsolve.webgui`.  It is the fundamental setup for creating 2D geometries in NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# import netgen.gui\nfrom ngsolve import Mesh\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import SplineGeometry\ngeo = SplineGeometry()\n```\n\n----------------------------------------\n\nTITLE: Testing BDDC Preconditioner\nDESCRIPTION: This function `TestPreconditioner` creates a finite element space, defines a bilinear form representing a Laplace-type operator, constructs a BDDC preconditioner, assembles the matrix, and computes the eigenvalues of the preconditioned matrix. It takes polynomial order `p` and condensation option as input.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef TestPreconditioner (p, condense=False, **args):\n    fes = H1(mesh, order=p, **args)\n    u,v = fes.TnT()\n    a = BilinearForm(fes, eliminate_internal=condense)\n    a += grad(u)*grad(v)*dx + u*v*dx\n    c = Preconditioner(a, \"bddc\")\n    a.Assemble()   \n    return EigenValues_Preconditioner(a.mat, c.mat)\n```\n\n----------------------------------------\n\nTITLE: Define Macro to Add Unit Tests (CMake)\nDESCRIPTION: This macro, `add_unit_test`, automates the process of adding unit tests. It takes a name and source file(s) as input. It creates an executable, links it against `catch_main`, `netgen_python`, and `ngsolve`, adds dependencies to the `unit_tests` target, and creates a test that runs the executable. It also sets the test properties to depend on the `unit_tests_built` target.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/catch/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nmacro(add_unit_test name sources)\n  add_executable(test_${name} ${sources} )\n  target_link_libraries(test_${name} catch_main netgen_python)\n  target_link_libraries(test_${name} ngsolve)\n\n  add_dependencies(unit_tests test_${name})\n  add_test(NAME unit_${name} COMMAND test_${name})\n  set_tests_properties(unit_${name} PROPERTIES DEPENDS unit_tests_built)\nendmacro()\n```\n\n----------------------------------------\n\nTITLE: Drawing Compressed DomainTypeArray (Python)\nDESCRIPTION: This snippet visualizes the compressed DomainTypeArray, showing the result after removing irrelevant regions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(dta_outside.Indicator(levelsets_p1), -3.5, 2.5, mesh, \"outside\")\n```\n\n----------------------------------------\n\nTITLE: Setting Source File Properties - CMake\nDESCRIPTION: This snippet sets the LANGUAGE property to CUDA for specific source files. This ensures that CMake uses the CUDA compiler (nvcc) for these files. This is essential for compiling CUDA code within a mixed C++/CUDA project.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nset_source_files_properties(cuda_linalg.cpp unifiedvector.cpp cuda_tasks.cpp dev_sparsecholesky.cpp dev_blockjacobi.cpp PROPERTIES LANGUAGE CUDA)\n```\n\n----------------------------------------\n\nTITLE: Visualizing DomainTypeArray Indicator\nDESCRIPTION: This snippet visualizes the indicator function of the region outside the triangle. The `outside_triangle.Indicator(level_sets_p1)` returns a CoefficientFunction that is 1 inside the region and 0 elsewhere. This is then visualized using `DrawDC`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(outside_triangle.Indicator(level_sets_p1), -3.5, 2.5, mesh, \"outside_indicator\")\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries and Setting Message Level (Python)\nDESCRIPTION: This snippet imports necessary libraries from ngsolve, netgen, and xfem, including specific modules for level set space-time methods. It also sets the message level to control the verbosity of the output during the simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.geom2d import SplineGeometry\nfrom xfem import *\nfrom math import pi\nfrom xfem.lset_spacetime import *\nngsglobals.msg_level = 1\n\n#import netgen.gui \nDrawDC = MakeDiscontinuousDraw(Draw)\n```\n\n----------------------------------------\n\nTITLE: Linearization with Assemble and GridFunction\nDESCRIPTION: This code snippet demonstrates linearization using `Assemble` and a `GridFunction` as a `CoefficientFunction` in an integrator.  Every time `Assemble` is called, the bilinear form is updated with the new values of the `GridFunction` (`gfu_old`).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/symbolic_integrators.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(fes)\na += SymbolicBFI(gfu_old * u * v)\n```\n\n----------------------------------------\n\nTITLE: Combined Communication (JS <-> Python) - Python\nDESCRIPTION: This example combines both directions of communication. When an edge is selected, it finds adjacent faces in Python, sends the result back to Javascript, and appends a tooltip text to the selected edge in the webgui.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\njs_code = \"\"\"\nscene.on(\"select\", ({dim, index}) => {\n    console.log(\"selected\", dim, index);\n    scene.widget.send({type: 'select', dim, index})\n})\n\nscene.widget.model.on('msg:custom', (faces)=> {\n    console.log(\"received faces\", faces)\n    scene.tooltip.textContent += \", Faces: \";\n\n    for ( let i =0; i < faces.length; i++)\n        scene.tooltip.textContent += faces[i][0] + \" \" + faces[i][1] + \", \"\n\n    // extend tooltip width\n    scene.tooltip.style.width = \"300px\"\n})\n\"\"\"\ns = Draw(m, js_code=js_code);\ndef onMessage(widget, content, buffers):\n    dim = content['dim']\n    index = content['index']\n    if dim == 1:\n        # find adjacent faces to selected edge\n        r = m.Region(BBND)\n        r.Mask().Clear()\n        r.Mask().Set(index)\n        nb = r.Neighbours(BND)\n        faces = []\n        boundaries = m.GetBoundaries()\n        faces = [ (i, boundaries[i]) for i, val in enumerate(nb.Mask()) if val ]\n        s.widget.send(faces)\ns.widget.on_msg(onMessage)\n```\n\n----------------------------------------\n\nTITLE: Defining 2D Geometry for Dynamic Contact - Python\nDESCRIPTION: This code snippet defines the geometry for a 2D dynamic contact problem using the netgen.occ module. It creates a bowl and three balls, defines boundary names for contact and symmetry conditions, and generates a compound geometry for dynamic analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom ngsolve import *\nfrom ngsolve.solvers import *\nfrom ngsolve.webgui import Draw\nfrom netgen.webgui import Draw as DrawGeo\n```\n\nLANGUAGE: python\nCODE:\n```\nbowl = MoveTo(0,-0.01).Arc(0.2,70).Rotate(90).Line(0.01).Rotate(90) \\\n    .Arc(0.19,-140).Rotate(90).Line(0.01).Rotate(90).Arc(0.2,70).Face()\nball1 = Circle((0,0.1),0.01).Face()\nball2 = Circle((0.05,0.1),0.01).Face()\nball3 = Circle((-0.05,0.1),0.01).Face()\nballs = Compound([ball1, ball2, ball3])\nballs.edges.name = \"balls\"\ngeo = Compound([bowl, balls])\nbowl.edges.name=\"contact\"\nbowl.edges.Min(Y+0.01*X).name=\"fix\"\nbowl.edges.Min(Y-0.01*X).name=\"fix\"\nDrawGeo(geo);\n```\n\n----------------------------------------\n\nTITLE: Modifying NGSolve Vector with NumPy\nDESCRIPTION: This snippet demonstrates how to get a NumPy array view of an NGSolve vector and modify its elements in place. This avoids copying the data, allowing for efficient operations on large vectors. Assumes 'b' is an NGSolve vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_numpy.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nb.FV().NumPy()[:] = abs(b.FV().NumPy()) - 1.0\n```\n\n----------------------------------------\n\nTITLE: Animating flow potential solve\nDESCRIPTION: This snippet animates the solution of the flow potential over time. It updates the deformation of the mesh, solves for the flow potential using the `solveWind` function, and redraws the scene to visualize the evolving flow field.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nscene = Draw(gfut)\ntau1 = 2e-3\nfor step in range(int(tend/tau1)):\n    defold.vec.data = deformation.vec\n    MeshRotation(step*omega*tau1, deformation)\n\n    mesh.SetDeformation(deformation)\n    solveWind(gfut,at,ft)\n    scene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Creating Block Jacobi Preconditioner\nDESCRIPTION: Creates a block Jacobi preconditioner using the `CreateBlockSmoother` method of the assembled matrix `a.mat`. It takes the `blocks` (a list of sets representing the blocks of degrees of freedom) as input. The condition number is then estimated.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nblockjac = a.mat.CreateBlockSmoother(blocks)\nlams = EigenValues_Preconditioner(mat=a.mat, pre=blockjac)\nmax(lams)/min(lams)\n```\n\n----------------------------------------\n\nTITLE: Define geometry and mesh\nDESCRIPTION: Defines the geometry as a square and generates a mesh using Netgen's OCC module. This is a crucial step for setting up the finite element problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# define geometry and generate mesh\nfrom ngsolve import *\nfrom ngsolve.webgui import *\nfrom netgen.occ import *\nshape = Rectangle(1,1).Face()\nshape.edges.Min(X).name=\"left\"\nshape.edges.Max(X).name=\"right\"\nshape.edges.Min(Y).name=\"bottom\"\nshape.edges.Max(Y).name=\"top\"\ngeom = OCCGeometry(shape, dim=2)\nmesh = Mesh(geom.GenerateMesh(maxh=0.3))\n```\n\n----------------------------------------\n\nTITLE: Defining and Visualizing Level Set Function - Python\nDESCRIPTION: This snippet defines a level set function and visualizes it using `DrawDC`.  The `DrawDC` function distinguishes between the negative and positive parts of the level set values to represent subdomains. The `help(DrawDC)` command provides documentation for this function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nlevelset = (sqrt(sqrt(x**4+y**4)) - 1.0)\nDrawDC(levelset, -1.0, 2.0, mesh, \"x\")\nhelp(DrawDC)\n```\n\n----------------------------------------\n\nTITLE: Solution Visualization Setup - Python\nDESCRIPTION: This snippet sets up the visualization of the solution quantities. It creates a `GridFunction` (gfu) to store the solution, extracts the components (gfh, gfhu, gfhv) corresponding to height and momentum.  It then calculates the velocity components (gfvu, gfvv). The code initializes the solution with the initial condition U0 using gfu.Set(U0).  Finally, it defines `scenes` for visualizing momentum, velocity, and height.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\ngfh, gfhu, gfhv = gfu\ngfvu = gfhu/gfh\ngfvv = gfhv/gfh\nmomentum = CF((gfhu,gfhv))\nvelocity = CF((gfvu,gfvv))\ngfu.Set(U0) \nscenes = [ \\\n    Draw(momentum,mesh,\"mom\"),\n    Draw(velocity,mesh,\"vel\"),\n    Draw(gfh,mesh,\"h\") ]\n```\n\n----------------------------------------\n\nTITLE: Evaluating the new design\nDESCRIPTION: This code re-assembles and solves the state equation with the updated mesh, and then prints the cost at the new design.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()\nfstate.Assemble()\nSolveStateEquation()\nprint('Cost at new design', Integrate (CostAuto(gfu), mesh))\n```\n\n----------------------------------------\n\nTITLE: Applying the Inverse Operator and Drawing the Solution (Python)\nDESCRIPTION: This code applies the inverse operator (`invA`) to the right-hand side vector (`f.vec`) to obtain the solution vector (`u.vec`). The solution is then visualized using the `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nu.vec.data = invA * f.vec\nDraw(u)\n```\n\n----------------------------------------\n\nTITLE: Displaying contents of a file\nDESCRIPTION: This code snippet utilizes the `cat` command through the shell to display the contents of the file \"vtk_example2.pvd\". This is useful for inspecting the structure and information contained within the PVD file, such as time stamps and associated VTK files.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-vtk/vtk.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n!cat vtk_example2.pvd\n```\n\n----------------------------------------\n\nTITLE: Small projected QEP Solver - Python\nDESCRIPTION: This snippet defines functions to solve the small projected quadratic eigenvalue problem. The `SolveProjectedSmall` function constructs a larger linear eigenvalue problem from the projected matrices and solves it using scipy.linalg.eig. The `SolveProjected` function projects the original matrices onto the subspace spanned by Q and calls `SolveProjectedSmall`. The input `Q` is the subspace onto which the matrices are projected.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef SolveProjectedSmall (Am, Bm, Cm):\n    half = Am.h\n    Cmi = Cm.I\n    K = Matrix(2*half, 2*half, complex = fes.is_complex)\n\n    K[:half, :half] = -Cmi*Bm\n    K[:half, half:] = -Cmi*Am\n    K[half:, :half] = Matrix(half, complex=True).Identity()\n    K[half:, half:] = 0\n\n    Kr = Matrix(2*half)\n    Kr.A = K.A.real\n    lam, eig = scipy.linalg.eig(Kr)\n    vecs = Matrix(eig)[0:len(Q),:] \n    lam = Vector(lam)\n\n    return lam, vecs    \n\ndef SolveProjected(mata, matb, matc, Q):\n    Am = InnerProduct(Q, mata*Q, conjugate = True)\n    Bm = InnerProduct(Q, matb*Q, conjugate = True)\n    Cm = InnerProduct(Q, matc*Q, conjugate = True)\n    return SolveProjectedSmall (Am, Bm, Cm)\n```\n\n----------------------------------------\n\nTITLE: Initial Guess and Gradient Descent Execution - Python\nDESCRIPTION: This Python snippet initializes the shape function `gfset` with zeros, creates an initial guess `x0` from the finite element vector associated with `gfset`, visualizes the initial shape, and then executes the gradient descent optimization algorithm using the defined shape function J and its gradient gradJ. It depends on the `Draw` method to visualize intermediate steps.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ngfset.vec[:]=0\nx0 = gfset.vec.FV().NumPy() # initial guess = 0 \nscene = Draw(gfset, mesh, \"gfset\")\ngradient_descent(x0, J, gradJ)\n```\n\n----------------------------------------\n\nTITLE: Creating the air box\nDESCRIPTION: This code creates a box representing the air surrounding the coil. It subtracts the coil geometry from the box to define the air domain and assigns a material to it. Boundary names are defined on the box for later use in boundary conditions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nbox = Box((-0.04,-0.04,-0.03), (0.04,0.04,0.06))\nbox.faces.name = \"outer\"\nair = box-coil\nair.mat(\"air\");\n```\n\n----------------------------------------\n\nTITLE: Pickling Expression Trees - Python\nDESCRIPTION: This snippet pickles a mesh and a `CoefficientFunction` expression.  The mesh is pickled separately, but could also be accessed from within the expression.  It then unpickles them and draws the unpickled function on the unpickled mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\noutfile = open(\"func.pkl\", \"wb\")\npickle.dump([mesh,func], outfile)\n\ninfile = open(\"func.pkl\", \"rb\")\nmesh2,func2 = pickle.load(infile)\n\nprint (func2)\n\nDraw (func2, mesh2);\n```\n\n----------------------------------------\n\nTITLE: Defining Exact Solutions for the Reissner-Mindlin Problem\nDESCRIPTION: This snippet defines the exact solutions for the vertical displacement of the Reissner-Mindlin plate problem under both simply supported and clamped boundary conditions. It calculates the radial coordinate (r) and the dimensionless coordinate (xi) and uses them to define the exact solutions w_s_ex and w_c_ex.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nr = sqrt(x**2+y**2)\nxi = r/R\nDb = E*t**3/(12*(1-nu**2))\n\nclamped = True\n\n#exact solution for simply supported bc\nw_s_ex = -fz*R**4/(64*Db)*(1-xi**2)*( (6+2*nu)/(1+nu) - (1+xi**2) + 8*(t/R)**2/(3*k*(1-nu)))\n#Draw(w_s_ex, mesh, \"w_s_ex\")\n#exact solution for clamped bc\nw_c_ex = -fz*R**4/(64*Db)*(1-xi**2)*( (1-xi**2) + 8*(t/R)**2/(3*k*(1-nu)))\nDraw(w_c_ex, mesh, \"w_c_ex\")\n```\n\n----------------------------------------\n\nTITLE: CoefficientFunction with list for region-based values\nDESCRIPTION: This code snippet shows how to create a CoefficientFunction that takes different values depending on the mesh region. It defines a dictionary mapping material names to values, then uses a list comprehension to create a CoefficientFunction based on the material of each region. Requires a mesh with defined material names retrievable via `mesh.GetMaterials()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/coefficient.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nalpha_d = {\"air\" : 1, \"box\" : 100}\nalpha = CoefficientFunction([alpha_d[mat] for mat in mesh.GetMaterials()])\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for NGSolve and XFEM\nDESCRIPTION: This snippet imports the necessary libraries for NGSolve, including netgen for geometry, ngsolve for FEM, and xfem for unfitted FEM capabilities. It also imports mlset for level set utilities and ngsolve.webgui for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Basic NGSolve things\nfrom netgen.geom2d import SplineGeometry\nfrom ngsolve import *\nfrom ngsolve.solvers import PreconditionedRichardson as PreRic\n\n# ngsxfem and the mlset convenience layer \nfrom xfem import *\nfrom xfem.mlset import *\n\n# Visualisation\nfrom ngsolve.webgui import *\nDrawDC = MakeDiscontinuousDraw(Draw)\n```\n\n----------------------------------------\n\nTITLE: Plot Iteration Counts for Local and Multigrid\nDESCRIPTION: This code plots the number of iterations against the number of degrees of freedom for both the 'local' and 'multigrid' preconditioners.  The x and y axes are set to logarithmic scales, and a legend is included to distinguish the two plots.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nplt.xscale(\"log\")\nplt.yscale(\"log\")\nplt.plot(*zip(*res_local), \"-*\")\nplt.plot(*zip(*res_mg), \"-+\")\nplt.legend(['local', 'mg'])\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Adding Diffusion and Ghost Penalty Terms\nDESCRIPTION: This snippet adds the diffusion term and the ghost penalty stabilization term to the bilinear form. The ghost penalty term penalizes jumps across the interface and stabilizes the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\na += InnerProduct(Grad(u), Grad(v)) * dx\na += gamma_s / (h**2) * (u - u.Other()) * (v - v.Other()) * dw\n```\n\n----------------------------------------\n\nTITLE: Set Domain Mesh Size - Python\nDESCRIPTION: This snippet sets the maximum mesh size for a specific domain using the `SetDomainMaxH` method. This allows controlling the mesh density within a particular subdomain of the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngeo.SetDomainMaxH(2, 0.01)\n```\n\n----------------------------------------\n\nTITLE: Generating Training Data\nDESCRIPTION: This snippet generates a set of random input data points (ax, ay) and calculates the corresponding NGSolve solutions for each data point, storing them in `data_out`. It creates a dataset for training the neural network.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nn_data = 50   # number of datapoints\ninput_dim = 2   # dimension of each datapoint\ndata_in = np.random.uniform(0,1,size=(n_data,input_dim))  # artificial datapoints\n# print (data_in)\noutput_dim = fes.ndof\ndata_out = np.zeros((n_data, output_dim))\n\nfor i, (ax,ay) in enumerate(data_in):\n    Solve (ax, ay)\n    data_out[i,:] = gfu.vec\n```\n\n----------------------------------------\n\nTITLE: Creating Mass Matrix Inverse Operator (Python)\nDESCRIPTION: This code creates an inverse operator for the mass matrix using the L2 finite element space. The Mass method generates a linear operator for multiplication with the diagonal mass matrix. The rho=1 argument specifies a constant density of 1. The Inverse() method returns the inverse of the mass matrix operator.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nainv = Sigma.Mass(rho=1).Inverse()\n```\n\n----------------------------------------\n\nTITLE: Storing Initial Value for Visualization - Python\nDESCRIPTION: This snippet stores the initial value of the solution for visualization purposes. A `GridFunction` `gfut` with `multidim=0` is created and the initial value (stored in `u_last.vec`) is added as a multi-dimensional component. This allows to visualize the solution at different time steps.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ngfut = GridFunction(u_last.space, multidim=0)\ngfut.AddMultiDimComponent(u_last.vec)\n```\n\n----------------------------------------\n\nTITLE: Computing Inner Products in Parallel in Python\nDESCRIPTION: This snippet computes the global inner product of two vectors and compares it to the local contributions.  It uses `InnerProduct` with cumulated vectors and then computes the inner product of local contributions, cumulating the results with `MPI.COMM_WORLD.allreduce`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.2-pardofs/pardofs.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n%%px\nprint (\"global ip =\", InnerProduct(gfu.vec, r))\nlocalip = InnerProduct(r.local_vec, gfu.vec.local_vec)\nprint (\"local contribution:\", localip)\nprint (\"cumulated:\", comm.allreduce(localip, MPI.SUM))\n```\n\n----------------------------------------\n\nTITLE: Mesh Generation for Nonlinear PDE\nDESCRIPTION: This code defines the geometry (unit square) and generates the mesh using Netgen for solving the nonlinear PDE. It defines boundary names for later use in boundary conditions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# define geometry and generate mesh\nfrom ngsolve import *\nfrom ngsolve.webgui import *\nfrom netgen.occ import *\nshape = Rectangle(1,1).Face()\nshape.edges.Min(X).name=\"left\"\nshape.edges.Max(X).name=\"right\"\nshape.edges.Min(Y).name=\"bottom\"\nshape.edges.Max(Y).name=\"top\"\ngeom = OCCGeometry(shape, dim=2)\nmesh = Mesh(geom.GenerateMesh(maxh=0.3))\n```\n\n----------------------------------------\n\nTITLE: Solve System using CG Iteration\nDESCRIPTION: This code solves the linear system resulting from the finite element discretization using the Conjugate Gradient (CG) method.  It utilizes the preconditioned CG solver within NGSolve.  The TaskManager is used to ensure proper parallelization.  The `printrates=True` argument enables printing of convergence information.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwell.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\nwith TaskManager():\n    solvers.CG(sol=gfu.vec, rhs=f.vec, mat=a.mat, pre=c.mat, printrates=True)\n```\n\n----------------------------------------\n\nTITLE: Iterate over Elements\nDESCRIPTION: This snippet iterates over the volume elements of a mesh and prints the type of each element, its vertices, and its edges. It utilizes `mesh.Elements(VOL)` to access the volume elements. The element object `el` has attributes `vertices` and `edges` that provide the corresponding topological information.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfor el in mesh.Elements(VOL):\n    print(type(el))\n    print (\"vertices: \", el.vertices)   # get vertices of an element \n    print (\"edges: \", el.edges)         # get edges of an element \n```\n\n----------------------------------------\n\nTITLE: Explode Faces and Edges - Python\nDESCRIPTION: This snippet extracts the faces and edges of a solid, moves them slightly outwards from the center, and then visualizes the exploded view using `Compound`. This demonstrates accessing the hierarchy of shapes in OCCT.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nsolid = Box((0,0,0), (1,1,1))\nexplodedF = sum( [f.Move(0.2 * (f.center-Pnt(0.5, 0.5, 0.5))) for f in solid.faces] )\nexplodedE = sum( [e.Move(0.2 * (e.center-Pnt(0.5, 0.5, 0.5))) for e in solid.edges] )\n    \nDrawGeo ( Compound( [explodedF, explodedE] ) );\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces and Grid Functions\nDESCRIPTION: This snippet defines the finite element spaces for the pressure (p), velocity (u), and trace.  It also initializes grid functions for these spaces and interpolates an initial condition for the pressure. It then computes the trace of the pressure onto the trace space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\norder = 4\nfes_p = L2(mesh, order=order, all_dofs_together=True)\nfes_u = VectorL2(mesh, order=order, piola=True)\nfes_tr = FacetFESpace(mesh, order=order)\n\nprint (\"ndof_p = \", fes_p.ndof, \"+\", fes_tr.ndof, \", ndof_u =\", fes_u.ndof)\n\ntraceop = fes_p.TraceOperator(fes_tr, average=True) \n\ngfu = GridFunction(fes_u)\ngfp = GridFunction(fes_p)\ngftr = GridFunction(fes_tr)\n\ngfp.Interpolate( exp(-400*(x**2+y**2+z**2)))\ngftr.vec.data = traceop * gfp.vec\n```\n\n----------------------------------------\n\nTITLE: Solving Stokes with Enhanced Velocity Space\nDESCRIPTION: This snippet demonstrates the use of an enhanced velocity space (P2+ - P1_dc). The velocity space is enriched with cubic bubble functions on triangles, and the pressure space is discontinuous P1. The number of degrees of freedom are printed before solving.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nV = VectorH1(mesh, order=2, dirichlet=\"wall|inlet|cyl\")\nV.SetOrder(TRIG,3)\nV.Update()\nprint (V.ndof)\nQ = L2(mesh, order=1)\nX = V*Q\nprint (\"V.ndof =\", V.ndof, \", Q.ndof =\", Q.ndof)\n\ngfu = SolveStokes(X)\n```\n\n----------------------------------------\n\nTITLE: Initializing Midpoint Rule SDIRK Method in Python\nDESCRIPTION: This code defines the midpoint rule, a second-order SDIRK method, as a Python class.  It initializes the Butcher tableau coefficients `a`, `b`, and `c`, which represent the stage coefficients, weights, and nodes, respectively. The `astar` value specifies the diagonal element of the 'a' matrix. The `stages` variable indicates that it's a single-stage method.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.1-parabolic/parabolic.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass MR: #order 2 (midpoint rule)\n    stages = 1\n    a = [[0.5]]\n    b = [1]\n    c = [0.5]\n    astar = 0.5\n```\n\n----------------------------------------\n\nTITLE: DG Bilinear Form Definition - Python\nDESCRIPTION: This snippet defines the bilinear form for the discontinuous Galerkin (DG) method.  It includes the volume integral term and the boundary integral term involving the numerical flux. The `nonassemble=True` argument signifies that the bilinear form will be used with explicit time stepping, where the matrix is not assembled explicitly. The `dx(element_boundary=True)` specifies the integration over the element boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef DGBilinearForm(fes,F,Fhatn,Ubnd):\n    a = BilinearForm(fes, nonassemble=True)    \n    a += - InnerProduct(F(U),Grad(V)) * dx \n    a += InnerProduct(Fhatn(U),V) * dx(element_boundary=True)\n    return a\n\na = DGBilinearForm(fes,F,Fhatn,Ubnd)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for NGSolve Simulation\nDESCRIPTION: This snippet imports necessary libraries for the NGSolve simulation: ngsolve for finite element computations, netgen.geom2d for geometry creation, and ngsolve.webgui for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.geom2d import SplineGeometry\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Iterative Solver for Minimization Formulation in NGSolve\nDESCRIPTION: This snippet implements an iterative solver for the minimization formulation using NGSolve. It sets up vectors, linear forms, and load steps. It includes assembling the linearization, applying the bilinear form, solving the linear system, and performing a linesearch with damping. The evolution equation for `p` is solved at each quadrature point using `MinimizationCF`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# a set of vectors for keeping data\nvec_k = gfsol.vec.CreateVector()\nw      = gfsol.vec.CreateVector()\nrhs    = gfsol.vec.CreateVector()\n\n# postprocess internal states\nfd = LinearForm(InnerProduct(gfp, qd)*irs_dx)\nfda = LinearForm(InnerProduct(gfalpha_k, qda)*irs_dx)\n\n# load steps (chosen based on experience)\nloadsteps = [0.1,0.3,0.5,0.7,0.8,0.9,0.95,1.0]\n\n# set solution to zero initially\ngfsol.vec[:] = 0\nalpha_k.vec[:] = 0\n\n# evolution params (default values of MinimizationCF at the time of writing)\ntol = 1e-6\nmaxiter = 20\n\n# iterate through load steps\nfor ls in loadsteps:\n    loadfactor.Set(ls)\n    \n    # update old solution at time t = t_k\ngfsol_k.vec.data = gfsol.vec\n    with TaskManager():\n        for i in range(20):\n            energy_k = a.Energy(gfsol.vec)\n            #print (\"energy(t_k) = \", energy_k)\n            \n            a.AssembleLinearization(gfsol.vec)\n            a.Apply(gfsol.vec, rhs)\n            \n            # static condensation could be employed to speedup solving\nw.data = a.mat.Inverse(freedofs=fes.FreeDofs(False), inverse=\"sparsecholesky\") * rhs\n\n            # linesearch ( with damping)\n            vec_k.data = gfsol.vec\n            scale = 1\n            while scale > 1e-7:\n                gfsol.vec.data -= scale * w\n                energy1 = a.Energy(gfsol.vec)\n                \n                # Here we solve the evolution equation at each quadrature point through evaluation of \n                # the MinimizationCF. This function takes the \"objective\", the initial guess (most \n                # likely the previous solution), tolerances and the maximum number of iterations.\n                gfp.Interpolate(MinimizationCF(evolution_objective, gfp, tol=tol, maxiter=maxiter))\n                \n                energy2 = a.Energy(gfsol.vec)\n                \n                if energy2 < energy_k + 1e-12: \n                    break\n                scale *= 0.5\n                gfsol.vec.data = vec_k\n                #print(scale)\n                \n            err = sqrt(InnerProduct(w, rhs))\n            print(\"step \", i, \"err = \", err)\n            \n            # check convergence\n            if err < 1e-6: break\n    \nalpha_k.Interpolate(alpha_k + sqrt(2/3) * sigma_Y * H * sqrt(InnerProduct(gfp - gfp_k, gfp - gfp_k)))\n    \n    print(\"force = \", ls * force, \", uy_A =\", gfu(node_A)[1], \", ux_B =\", gfu(node_B)[0],\\\n          \", int u2 =\", Integrate(gfu[1] * ds(\"top\"),mesh))\n```\n\n----------------------------------------\n\nTITLE: Elastic Contribution to BilinearForm in ngsolve (Python)\nDESCRIPTION: This code defines the elastic part of the `BilinearForm`, representing the elastic stiffness of the material. It calculates the elasticity tensor and incorporates it into the bilinear form using inner products of strain tensors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# elasticity tensor\ncc = sigma.Diff(strain_gf).Reshape((strain_gf.dim, strain_gf.dim))\n\n# reshape test and trial strians\ndelta_eps = strain(u_test).Reshape((strain_gf.dim, ))\nDelta_eps = strain(u).Reshape((strain_gf.dim, ))\n\na = BilinearForm(fes_u, symmetric=False)\n\n# \"elastic contribution\"\na += InnerProduct(delta_eps, cc * Delta_eps).Compile(realcompile=realcompile) * irs_dx\n```\n\n----------------------------------------\n\nTITLE: Adding Checkbox to GUI - Python\nDESCRIPTION: This example adds a checkbox to the webgui and moves the clipping plane when the checkbox is checked.  It modifies `scene.gui`, a dat.GUI object, to add a clipping plane control.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\njs_code = \"\"\"  \n  scene.gui.settings.panclipping = false;\n  scene.gui.add(scene.gui.settings, \"panclipping\").onChange(()=>scene.animate())\n    const clipping = scene.gui.settings.Clipping;\n    clipping.x = -1;\n    clipping.z = -1;\n    \n    clipping.enable = true;\n       \n   scene.on(\"afterrender\", (scene, dt) => {\n    if(scene.gui.settings.panclipping) {\n    clipping.dist += 0.5*dt;\n      if(clipping.dist >= 1)\n       clipping.dist = -1;\n      scene.controls.update();\n    }\n  })\n\"\"\"\nDraw(m, js_code=js_code);\n```\n\n----------------------------------------\n\nTITLE: Accessing DomainTypeArray Attributes\nDESCRIPTION: These snippets demonstrate how to access the `as_list` attribute to get the list of regions contained in the `DomainTypeArray` and the `codim` attribute to get the codimension of the resulting domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndomain.as_list\n```\n\nLANGUAGE: python\nCODE:\n```\ndomain.codim\n```\n\n----------------------------------------\n\nTITLE: Adding NETGENDIR to PATH (Bash)\nDESCRIPTION: This command adds the directory containing the Netgen executable to the `PATH` environment variable.  This allows you to run the `netgen` command from any location in the terminal without specifying the full path.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nexport PATH=$NETGENDIR:$PATH\n```\n\n----------------------------------------\n\nTITLE: Unpickling GridFunctions and Checking Shared Spaces - Python\nDESCRIPTION: This snippet unpickles the `GridFunction` objects from the file and verifies that they still share the same finite element space after unpickling. It prints the IDs of the spaces associated with each `GridFunction` to confirm that they are the same. Finally, it draws one of the GridFunctions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ninfile = open(\"gridfunction.pkl\", \"rb\")\ngfv1,gfv2 = pickle.load(infile)\nprint (\"the same spaces:\", id(gfv1.space), \"=?=\", id(gfv2.space))\n\nDraw (gfv1);\n```\n\n----------------------------------------\n\nTITLE: Creating Vector Plots\nDESCRIPTION: This snippet demonstrates how to create vector plots using Webgui. It defines a vector-valued coefficient function `rotfunc` and visualizes it on a unit square mesh. `vectors` controls the grid size and offset of the vectors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nrotfunc = CF( (y-0.5, 0.5-x) )\nusmesh = Mesh(unit_square.GenerateMesh(maxh=0.1))\nDraw (rotfunc, usmesh, max=0.7,  vectors={\"grid_size\" : 20, \"offset\" : 0.5 } );\n```\n\n----------------------------------------\n\nTITLE: Importing necessary libraries\nDESCRIPTION: This snippet imports the required modules from `netgen.geom2d`, `ngsolve`, and `xfem` for geometry creation, finite element analysis, and extended finite element methods, respectively. It also imports the `Draw` function from `ngsolve.webgui` for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Import geometry features, NGSolve and xfem\nfrom netgen.geom2d import SplineGeometry\nfrom ngsolve import *\nfrom xfem import *\n\n# Visualisation\nfrom ngsolve.webgui import *\nDrawDC = MakeDiscontinuousDraw(Draw)\n```\n\n----------------------------------------\n\nTITLE: Set Material Label - Python\nDESCRIPTION: This snippet sets a material label (string) for a specific domain using the `SetMaterial` method. This allows assigning material properties to different subdomains of the geometry for simulation purposes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ngeo.SetMaterial(2, \"iron\")\n```\n\n----------------------------------------\n\nTITLE: Creating DomainTypeArray with Compression (Python)\nDESCRIPTION: This snippet shows how to create a DomainTypeArray and compress it during initialization using the `lsets` and `persistent_compress` parameters. `persistent_compress=True` ensures that any derived DomainTypeArrays are also compressed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ntmp1 = DomainTypeArray((NEG,ANY,ANY,ANY), \n                       lsets=level_sets_p1, \n                       persistent_compress=True)\ntmp2 = DomainTypeArray((NEG,NEG,NEG,NEG), \n                       lsets=level_sets_p1, \n                       persistent_compress=True)\nz_disc2 = tmp1 & ~tmp2\nz_disc2.as_list\n```\n\n----------------------------------------\n\nTITLE: Defining Source Function\nDESCRIPTION: This snippet defines the source term `pulse` as a Gaussian function.  It's used as the right-hand side in the Helmholtz equation.  The function is then visualized using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/helmholtz.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nomega = 100\npulse = 5e4*exp(-(40**2)*((x-0.5)*(x-0.5) + (y-0.5)*(y-0.5)))\nDraw(pulse, mesh, order=3)\n```\n\n----------------------------------------\n\nTITLE: Inspecting DomainTypeArray Regions (Python)\nDESCRIPTION: This snippet displays the list of domain tuples that make up the `DomainTypeArray`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nz_disc.as_list\n```\n\n----------------------------------------\n\nTITLE: Set Test Properties (Timeout)\nDESCRIPTION: This CMake snippet uses `set_tests_properties` to set the `TIMEOUT` property for the `mpi_pytest` and `pytest` tests. This allows specifying a maximum execution time for the tests, preventing them from running indefinitely. It sets timeouts to 60 and 1500 respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/pytest/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(NETGEN_USE_PYTHON)\n  add_test(NAME pytest COMMAND ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n  if(NETGEN_USE_MPI)\n    add_test(NAME mpi_pytest COMMAND mpirun -np 5 --allow-run-as-root ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/mpi_only )\n    set_tests_properties ( mpi_pytest PROPERTIES TIMEOUT 60 )\n  endif()\n  set_tests_properties ( pytest PROPERTIES TIMEOUT 1500 )\n  add_custom_target(pytest ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\nendif(NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: Setting up PML for Eigenvalue Problem\nDESCRIPTION: This snippet sets up the radial PML for the eigenvalue problem within the region named \"pml\". Parameters for the radius, alpha and the origin are specified.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmesh.SetPML(pml.Radial(rad=1, alpha=1j, origin=(0,0)), \"pml\")\n```\n\n----------------------------------------\n\nTITLE: Get Vertices and Edges of Volume Element via NodeId\nDESCRIPTION: This snippet retrieves the vertices and edges of a volume element accessed via NodeId.  It allows verifying that elements accessed through different methods (NodeId and ElementId) return consistent information.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nel0.vertices, el0.edges\n```\n\n----------------------------------------\n\nTITLE: LinearForm for Global Boundary Value Problem in ngsolve (Python)\nDESCRIPTION: This snippet defines the `LinearForm` for the global boundary value problem. It includes the stress calculation based on the energy density and internal variables, as well as external forces applied to the boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Create a strain variable for partial differentiation\nstrain_gf = strain(gfu).MakeVariable()\n\n# stress\nsigma = Psi(strain_gf, gfp, gfalpha).Diff(strain_gf)\n\nL = LinearForm(fes_u)\nL += InnerProduct(sigma, strain(u_test)).Compile(realcompile=realcompile) * irs_dx\nL += -u_test[1] * force * loadfactor * ds(\"top\")\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation with BDDC on CUDA\nDESCRIPTION: This snippet extends the BDDC example by performing the computation on the CUDA device using device matrices. It creates device matrices for the bilinear form and the BDDC preconditioner, solves the system using the CG solver, and prints the number of iterations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nadev = a.mat.CreateDeviceMatrix()\npredev = pre.mat.CreateDeviceMatrix()\nfdev = f.vec.CreateDeviceVector()\n\nwith TaskManager(): \n    inv = CGSolver(adev, predev, maxsteps=2000, printrates=False)\n    gfu.vec.data = (inv * fdev).Evaluate()\n    print (\"iterations =\", inv.GetSteps())\n```\n\n----------------------------------------\n\nTITLE: Defining and drawing the level set function - Python\nDESCRIPTION: This snippet defines a level set function representing a circle with radius 'r' using the formula sqrt(x**2+y**2) - r. The level set function is then visualized using the DrawDC function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nr = 1\nlevelset = sqrt(x**2+y**2) - r\nDrawDC(levelset, -3.5, 2.5, mesh, 'levelset')\n```\n\n----------------------------------------\n\nTITLE: Timing Integration of a Compiled CoefficientFunction\nDESCRIPTION: This snippet uses the `%timeit` magic command to measure the time taken to integrate the compiled `finalc` CoefficientFunction over the mesh.  This allows for a direct comparison with the uncompiled version to demonstrate performance gains.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n%timeit Integrate(finalc, mesh, order=10)\n```\n\n----------------------------------------\n\nTITLE: FETI-DP Solver Execution with Scaling - NGSolve/Python\nDESCRIPTION: Executes the FETI-DP solver in NGSolve, comparing performance with and without multiplicity scaling. It initializes MPI, loads the mesh, sets up the finite element space, and configures the FETI-DP system. Then, it prepares the right-hand side, solves the system with and without scaling, and prints the time taken for each solve.  Finally, it performs a post-processing step. The scaled and unscaled solves are compared.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncomm = MPI_Init()\nmesh = load_mesh(nref=1)\nfes, a, f = setup_space(mesh, order=2)\nA_dp, A_dp_inv, F, Fhat, Fhat2, B, scaledA, scaledBT = setup_FETIDP(fes, a)\nrhs = B.CreateColVector()\nlam = B.CreateColVector()\nprep(B, A_dp_inv, f)\nif comm.rank==0:\n    print('\\nWithout multiplicity scaling:')\nt1 = solve(F,  Fhat,  rhs, lam)\nif comm.rank==0:\n    print('time to solve: ', t1)\n    print('\\nWith multiplicity scaling:')\nt2 = solve(F,  Fhat2,  rhs, lam)\nif comm.rank==0:\n    print('\\ntime solve without scaling: ', t1)\n    print('time solve with scaling: ', t2)\ngfu = GridFunction(fes)\npost(B, A_dp_inv, gfu, lam)\n```\n\n----------------------------------------\n\nTITLE: Evaluating a CoefficientFunction at a mapped integration point\nDESCRIPTION: This snippet shows how to evaluate a CoefficientFunction at a specific mapped integration point (mip) on the mesh. It first creates a mip at coordinates (0.2, 0.4), then defines a CoefficientFunction `cf` as x*x*y. The `cf(mip)` call evaluates the CoefficientFunction at the given mip and returns the result. Requires a mesh object.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/coefficient.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmip = mesh(0.2,0.4)\ncf = x*x*y\ncf(mip)\n```\n\n----------------------------------------\n\nTITLE: Running Time Simulation with Assembled Matrices\nDESCRIPTION: This snippet runs the time simulation using the assembled matrix B and its transpose. It measures the execution time using the `%time` magic command and runs the simulation both forward and backward in time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n%time Run(B, B.T, backward=False)\n%time Run(B, B.T, backward=True)\n```\n\n----------------------------------------\n\nTITLE: Poisson Equation Solver in NGSolve\nDESCRIPTION: This Python code snippet initializes the NGSolve environment and sets the message level. It's part of a larger script that solves the Poisson equation with NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/whetting_the_appetite/poisson.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nngsglobals.msg_level = 1\n```\n\n----------------------------------------\n\nTITLE: Post-processing and Visualization with NGSolve\nDESCRIPTION: This snippet performs post-processing and visualization of results using NGSolve. It assembles linear forms (`fd.Assemble()`, `fda.Assemble()`), computes derived quantities (`pdraw.vec.data = invad * fd.vec`, `adraw.vec.data = invada * fda.vec`), and visualizes them using `Draw()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfd.Assemble()\npdraw.vec.data = invad * fd.vec\nDraw(Norm(pdraw), mesh, \"p\")\nDraw(gfu,mesh, \"u\")\n\nif H.Get() > 1e-16:\n    fda.Assemble()\n    adraw.vec.data = invada * fda.vec\n    Draw(Norm(adraw), mesh, \"alpha\")\n```\n\n----------------------------------------\n\nTITLE: Defining FESpace for Hcurl problem in ngsolve using python\nDESCRIPTION: This code snippet defines the finite element space for an Hcurl problem. It sets the message level, creates a mesh, and defines the finite element space on that mesh. This is a prerequisite for defining the bilinear form.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/symbolic_integrators.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nngsglobals.msg_level\n```\n\n----------------------------------------\n\nTITLE: Define Quarter Circle Geometry - Python\nDESCRIPTION: This snippet defines a geometry with a quarter circle using second-order rational splines. It creates four points, defines a line segment, a spline (approximating a circular arc), and another line segment to form the boundary. The `spline3` segment type represents a second-order rational spline.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngeo = geom2d.SplineGeometry()\np1,p2,p3,p4 = [ geo.AppendPoint(x,y) for x,y in [(0,0), (1,0), (1,1), (0,1)] ]\ngeo.Append ([\"line\", p1, p2])\ngeo.Append ([\"spline3\", p2, p3, p4])\ngeo.Append ([\"line\", p4, p1])\n```\n\n----------------------------------------\n\nTITLE: Generating and visualizing Mesh - Python\nDESCRIPTION: This snippet generates a finite element mesh from the OCC geometry with a specified maximum element size. It then enhances the mesh curvature and visualizes it using NGSolve's Draw function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(OCCGeometry(shape, dim=2).GenerateMesh(maxh=0.1))\nmesh.Curve(5)\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Mesh Setup for H(curl)-AMG in Python\nDESCRIPTION: This snippet initializes and refines a mesh for use with the H(curl)-AMG solver (`hcurlamg`). It re-enables the edge and face tables in the mesh, which may have been disabled for memory optimization in earlier steps. The mesh is refined to create a finer discretization for the electromagnetic problem. The `netgen.meshing.Mesh.EnableTableClass` is important for correct mesh setup.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.5-amg/amg.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.la import EigenValues_Preconditioner\n# switch on again generation of tables  \nimport netgen.meshing\nnetgen.meshing.Mesh.EnableTableClass(\"edges\", True)\nnetgen.meshing.Mesh.EnableTableClass(\"faces\", True)\n\nwith TaskManager():\n    mesh = Mesh(unit_cube.GenerateMesh(maxh=0.1))\n    for l in range(1): mesh.Refine()\n```\n\n----------------------------------------\n\nTITLE: Print Mesh Materials and Boundaries\nDESCRIPTION: Prints the materials and boundaries defined in the mesh.  This is useful for debugging and verifying the mesh setup.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint (mesh.GetMaterials(), mesh.GetBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Creating SciPy Sparse Matrix from NGSolve Data\nDESCRIPTION: This snippet demonstrates how to create a SciPy sparse matrix from the row indices, column indices, and values obtained from an NGSolve sparse matrix. It uses the `scipy.sparse.csr_matrix` constructor to create a Compressed Sparse Row (CSR) matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_numpy.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport scipy.sparse as sp\nA = sp.csr_matrix((vals,(rows,cols)))\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh and Curving - Python\nDESCRIPTION: This snippet generates a finite element mesh from the previously defined geometry using `geo.GenerateMesh()`. The `maxh` parameter controls the maximum element size.  The mesh is then curved using `mesh.Curve(5)` to improve accuracy and the mesh is visualized with a clipping plane.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/maxwell.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(geo.GenerateMesh(maxh=0.5))\nmesh.Curve(5)\nDraw (mesh, clipping = { \"pnt\" : (0,0,0), \"vec\" : (0,1,0) })\n```\n\n----------------------------------------\n\nTITLE: Estimating Time Step - Python\nDESCRIPTION: This line provides a rough estimate of the time step `dt` based on the discretization order. It is crucial for the stability of the explicit time integration scheme.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# roughly estimated time step:\ndt = 1e-3 / (order+1)\n```\n\n----------------------------------------\n\nTITLE: Naming edges (BBoundaries) in CSG\nDESCRIPTION: This snippet illustrates how to name edges formed by the intersection of geometric objects. The `NameEdge` method associates a name with an edge defined by the intersection of two shapes.  The BBoundaries can then be accessed after mesh generation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\nsphere_bot = Sphere(Pnt(0,0,0),1).bc(\"bottom\")\nsphere_middle = Sphere(Pnt(0,1,0),0.7).bc(\"middle\")\nsphere_top = Sphere(Pnt(0,1.9,0),0.4).bc(\"top\")\ngeo.Add(sphere_bot+sphere_middle+sphere_top)\n\ngeo.NameEdge(sphere_bot,sphere_middle, \"lower\")\ngeo.NameEdge(sphere_middle,sphere_top, \"upper\")\n\nmesh = Mesh(geo.GenerateMesh(maxh=0.5, perfstepsend=MeshingStep.MESHSURFACE))\nprint(\"BBnd = \", mesh.GetBBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Analyzing preconditioner eigenvalues\nDESCRIPTION: This snippet calculates and displays the eigenvalues of the preconditioned system (a.mat preconditioned by mgblock). It uses `EigenValues_Preconditioner` to compute the eigenvalues, providing insight into the effectiveness of the preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nlam = EigenValues_Preconditioner(mat=a.mat, pre=mgblock)\nlam\n```\n\n----------------------------------------\n\nTITLE: Simultaneous Iteration Initialization\nDESCRIPTION: This snippet initializes the necessary data structures for simultaneous iteration to compute multiple eigenvalues.  It declares a GridFunction with multiple components, creates a list of help vectors, and sets random initial vectors with zero boundary conditions for the components of GridFunction `u`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.2-eigenvalues/pinvit.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnum = 5\nu = GridFunction(fes, multidim=num)\n\nr = u.vec.CreateVector()\nAv = u.vec.CreateVector()\nMv = u.vec.CreateVector()\n\nvecs = []\nfor v in u.vec.CreateVectors(2*num):\n    vecs.append(v)\n\nfor v in u.vecs:\n    r.SetRandom()\n    v.data = Projector(fes.FreeDofs(), True) * r\n```\n\n----------------------------------------\n\nTITLE: Generating the Boundary of DomainTypeArray\nDESCRIPTION: This snippet shows how to obtain the boundary of a region described by a DomainTypeArray using the `.Boundary()` method.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nboundary = triangle.Boundary()\nboundary.as_list\n```\n\n----------------------------------------\n\nTITLE: Mesh Generation and Curving - Python\nDESCRIPTION: This snippet generates a mesh from the previously defined geometry using `geo.GenerateMesh(maxh=2)`. The `maxh` parameter controls the maximum mesh size. It then curves the mesh elements using `mesh.Curve(3)` to improve accuracy, particularly for higher-order finite element spaces.  Finally, the mesh is visualized using `Draw(mesh)`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nmesh = Mesh(geo.GenerateMesh(maxh=2))\nmesh.Curve(3)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Get Edges and Elements of a Face\nDESCRIPTION: This snippet retrieves the edges and elements adjacent to a face using NodeId and MeshNode.  It demonstrates accessing the lower and higher dimensional entities linked to a face.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nf = NodeId(FACE, 2)\nmeshf = mesh[f]\nmeshf.edges, meshf.elements\n```\n\n----------------------------------------\n\nTITLE: Mass Matrix Assembly\nDESCRIPTION: This code snippet assembles the mass matrix for the HDG space.  The mass matrix is used in subsequent time-stepping procedures.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nm = BilinearForm(u * v * dx, symmetric=True).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Solving the BVP for MITC in NGSolve\nDESCRIPTION: This snippet defines a function, SolveBVP, to solve the boundary value problem (BVP). It updates the finite element space and grid function, assembles the bilinear and linear forms, and uses a sparse Cholesky inverse to solve the linear system. The solution is then stored in the grid function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef SolveBVP():\n    fes.Update()\n    gfsol.Update()\n    with TaskManager():\n        a.Assemble()\n        f.Assemble()\n        inv = a.mat.Inverse(fes.FreeDofs(), inverse=\"sparsecholesky\")\n        gfsol.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Visualization Setup\nDESCRIPTION: This code initializes the visualization scenes to display the velocity and pressure fields.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nscenes = [ \\\n    Draw( gfu.components[0], mesh, \"velocity\"), \\\n    Draw( gfu.components[2], mesh, \"pressure\")]\n```\n\n----------------------------------------\n\nTITLE: Solving the state equation using Newton's method\nDESCRIPTION: This code solves the state equation using Newton's method. The GridFunction 'gfu' is initialized to zero, and Newton's method is called using the bilinear form 'aAuto' and the free degrees of freedom defined by 'fes.FreeDofs()'. Finally the 'scene_u' is redrawn to visualize the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngfu.vec[:]=0\nNewton(aAuto,gfu,freedofs=fes.FreeDofs())\nscene_u.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Defining Cut FE spaces\nDESCRIPTION: This snippet defines the cut finite element spaces VhG based on the level set. It creates a compound space from two copies of a standard H1 space, restricts the degrees of freedom based on whether they are located in the positive or negative domain of the level set, and creates a GridFunction on this space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nVh = H1(mesh, order=2, dirichlet=\".*\")\nVhG = FESpace([Vh,Vh])\n\nci = CutInfo(mesh, lsetp1)\nfreedofs = VhG.FreeDofs()\nfreedofs &= CompoundBitArray([GetDofsOfElements(Vh,ci.GetElementsOfType(HASNEG)),\n                              GetDofsOfElements(Vh,ci.GetElementsOfType(HASPOS))])\n\ngfu = GridFunction(VhG)\n```\n\n----------------------------------------\n\nTITLE: MultiVector Simultaneous Iteration\nDESCRIPTION: This snippet implements the simultaneous iteration algorithm using MultiVectors. It computes residuals, applies preconditioner and orthogonalization and constructs and solves a small eigenvalue problem. Finally it updates the vectors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.2-eigenvalues/pinvit.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(20):\n    vecs[0:num] = a.mat * uvecs - (m.mat * uvecs).Scale (lams)\n    vecs[num:2*num] = pre * vecs[0:num]\n    vecs[0:num] = uvecs\n        \n    vecs.Orthogonalize() # m.mat)\n\n    asmall = InnerProduct (vecs, a.mat*vecs)\n    msmall = InnerProduct (vecs, m.mat*vecs)\n    \n    ev,evec = scipy.linalg.eigh(a=asmall, b=msmall)\n    lams = Vector(ev[0:num])\n    print (i, \":\", [l/pi**2 for l in lams])\n\n    uvecs[:] = vecs * Matrix(evec[:,0:num])\n```\n\n----------------------------------------\n\nTITLE: Setting up Auxiliary H1 Discretization (Python)\nDESCRIPTION: This snippet sets up an auxiliary H1 discretization in NGSolve. It defines the finite element space (`H1` with Dirichlet boundary conditions), formulates the bilinear form for the Laplace operator, and creates a preconditioner using the `bddc` method.  It also assembles the bilinear form.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfesH1 = H1(mesh, order=2, dirichlet=\".*\")\nu,v = fesH1.TnT()\naH1 = BilinearForm(fesH1)\naH1 += grad(u)*grad(v)*dx\npreH1 = Preconditioner(aH1, \"bddc\")\naH1.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Timing Integration of a Real-Compiled CoefficientFunction\nDESCRIPTION: This snippet uses the `%timeit` magic command to measure the time taken to integrate the 'real' compiled `finalcc` CoefficientFunction. This demonstrates the performance improvement after the compiler script optimization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n%timeit Integrate(finalcc, mesh, order=10)\n```\n\n----------------------------------------\n\nTITLE: Poisson Equation Solver Setup - NGSolve/Python\nDESCRIPTION: Sets up the finite element space, bilinear form, and linear form for solving Poisson's equation using NGSolve. It loads a mesh, refines it, defines the finite element space, assembles the bilinear and linear forms, and prints the global and local degrees of freedom. This code utilizes MPI for parallel computation, enabling the solution of the problem on distributed systems.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nimport netgen.meshing as ngmeshing\n\nnref = 0\n\ndim=3\nngmesh = ngmeshing.Mesh(dim=dim)\nngmesh.Load('cube.vol')\nfor l in range(nref):\n    ngmesh.Refine()\nmesh = Mesh(ngmesh)\ncomm = MPI_Init()\nfes = H1(mesh, order=2, dirichlet='right|top|top|left')\npardofs = fes.ParallelDofs()\na = BilinearForm(fes)\nu,v = fes.TnT()\na += SymbolicBFI(grad(u)*grad(v))\na.Assemble()\nf = LinearForm(fes)\nf += SymbolicLFI(x*y*v)\nf.Assemble()\navg_dof = comm.Sum(fes.ndof) / comm.size\nif comm.rank==0:\n    print('global,  ndof =', fes.ndofglobal, ', lodofs =', fes.lospace.ndofglobal)\n    print('avg DOFs per core: ', avg_dof)\n```\n\n----------------------------------------\n\nTITLE: Using TraceOperator with FacetFESpace\nDESCRIPTION: This snippet defines a `FacetFESpace` and a `TraceOperator`. It then defines trial and test functions for the pressure, velocity, and trace spaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfes_tr = FacetFESpace(mesh, order=order+1)\ntraceop = fes_p.TraceOperator(fes_tr, False) \n\np = fes_p.TrialFunction()\nv = fes_u.TestFunction()\nphat = fes_tr.TrialFunction()\n```\n\n----------------------------------------\n\nTITLE: Solving FETI-DP with GMRES in NGSolve Python\nDESCRIPTION: Solves the FETI-DP system using the GMRES solver with two different preconditioners. It sets up the right-hand side vector, configures the GMRES solver, solves the system, and prints performance statistics such as the number of iterations and solve time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n%%px\nsol = M_lin.CreateRowVector()\nrhs = sol.CreateVector()\nrhs[:] = 0.0\nrhs[0:fes.ndof] = f.vec.local_vec\nrhs.SetParallelStatus(f.vec.GetParallelStatus())\nngsglobals.msg_level = 3\nt1 = -comm.WTime()\ngmr = GMRESSolver(mat=M_lin, pre=Mhat_lin, maxsteps=100,\\\n                  precision=1e-6, printrates=True)\nsol.data = gmr * rhs\nt1 += comm.WTime()\nnsteps1 = gmr.GetSteps()\nt2 = -comm.WTime()\ngmr = GMRESSolver(mat=M_lin, pre=Mhat2_lin, maxsteps=100,\\\n                  precision=1e-6, printrates=True)\nsol.data = gmr * rhs\nt2 += comm.WTime()\nnsteps2 = gmr.GetSteps()\nif comm.rank==0:\n    print('\\ntook', nsteps1, 'steps for v1')\n    print('time solve v1: ', t1)\n    print('dofs per proc and second v1: ', fes.ndofglobal / ( t1 * comm.size))\n    print('\\ntook', nsteps2, 'steps for v2')\n    print('time solve v2: ', t2)\n    print('dofs per proc and second v2: ', fes.ndofglobal / ( t2 * comm.size))\n```\n\n----------------------------------------\n\nTITLE: Calculating Eigenvalues without Condensation\nDESCRIPTION: This snippet calls the `TestPreconditioner` function without static condensation and prints the first and last three eigenvalues of the preconditioned matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nlams = TestPreconditioner(5)\nprint (lams[0:3], \"...\\n\", lams[-3:])\n```\n\n----------------------------------------\n\nTITLE: Solving and Visualizing DG Solution\nDESCRIPTION: This snippet solves the linear system resulting from the DG formulation and visualizes the solution. It initializes a GridFunction on the product space V, solves the system using a sparse direct solver, and then draws the displacement, gradient, and Hessian of the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.9-fourthorder/fourthorder.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nu = GridFunction(V)\nu.vec.data = a.mat.Inverse(V.FreeDofs()) * f.vec\n\nDraw (u.components[0], mesh, \"disp_DG\")\nDraw (grad (u.components[0]), mesh, \"grad\")\nDraw (hesse (u.components[0]), mesh, \"hesse\");\n```\n\n----------------------------------------\n\nTITLE: Refine Mesh and Update Finite Element Space (NGSolve)\nDESCRIPTION: This snippet refines the mesh multiple times using `mesh.Refine()` and updates the finite element space and grid function to be compatible with the refined mesh using `fes.Update()` and `gfu.Update()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfor l in range(4): mesh.Refine()\nfes.Update()\ngfu.Update()\nf.Assemble();\n```\n\n----------------------------------------\n\nTITLE: Extending Basis Functions and Visualizing\nDESCRIPTION: This code defines a function to extend basis functions from root elements to bad elements within each patch.  It then creates a GridFunction to visualize these extended basis functions. The function uses the embedding matrix obtained from `AggEmbedding`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef ExtendedBasisFunctionsAsMultiDim(EA, fes):\n    E = AggEmbedding(EA, fes)\n    gfshow = GridFunction(fes, multidim=0)\n    gf = GridFunction(fes)\n    coefvec = E.CreateRowVector()\n    for i in range(E.width):\n        coefvec[:] = 0\n        coefvec[i] = 1\n        gf.vec.data = E * coefvec\n        gfshow.AddMultiDimComponent(gf.vec)\n    return gfshow\n```\n\n----------------------------------------\n\nTITLE: Solving and Visualizing (NGSolve)\nDESCRIPTION: This snippet uses the `SolveAndVisualize` function to solve the linear system defined by the operator `c` and the right-hand side vector `rhs.vec`. The `%%time` magic command measures the execution time of the solving process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n%%time\ngfu_t = SolveAndVisualize(c, rhs_vec=rhs.vec)\n```\n\n----------------------------------------\n\nTITLE: Pickling a Mesh - Python\nDESCRIPTION: This snippet demonstrates how to pickle an NGSolve mesh object. It opens a file in binary write mode (`wb`), then uses `pickle.dump` to serialize the `mesh` object into the file. The `pickle` module is a standard Python library for object serialization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pickle\noutfile = open(\"mesh.pkl\", \"wb\")\npickle.dump(mesh, outfile)\n```\n\n----------------------------------------\n\nTITLE: Canonical Interpolation with Dual Basis Functions (Python)\nDESCRIPTION: This snippet sets up and solves a variational problem for canonical interpolation using dual basis functions in NGSolve. It defines bilinear and linear forms using the `TnT()` operator for trial and test functions and the `Operator(\"dual\")` for accessing dual basis functions. The `Inverse()` method solves the linear system.  The code leverages the boundary elements to enforce interpolation conditions on vertices, edges and elements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nu,v = fes.TnT()\nvdual = v.Operator(\"dual\")\n\na = BilinearForm(fes)\na += u*vdual*dx + u*vdual*dx(element_vb=BND) + \\\n    u*vdual*dx(element_vb=BBND)\na.Assemble()\n\nf = LinearForm(fes)\nf += func*vdual*dx + func*vdual*dx(element_vb=BND) + \\\n    func*vdual*dx(element_vb=BBND)\nf.Assemble()\n\n# interpolation in vertices preserves values 0 and 1\ngfu.vec.data = a.mat.Inverse() * f.vec\nprint (gfu.vec)\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Compressing DomainTypeArray (Python)\nDESCRIPTION: This snippet demonstrates how to compress a DomainTypeArray using the `.Compress()` method, which removes irrelevant regions based on a set of level set functions.  It takes a tuple of GridFunctions as input (level_sets_p1) and eliminates domain tuples with zero measure with respect to these functions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nz_disc.Compress(level_sets_p1)\nz_disc.as_list\n```\n\n----------------------------------------\n\nTITLE: Creating Geometry with PML Region\nDESCRIPTION: This snippet defines the geometry for the source problem, creating an inner circle and an outer annulus representing the PML region. It assigns names to the faces and edges for later use in the simulation. The code also generates the mesh and draws the forcing function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nouter = Circle((0,0), 1.4).Face()\nouter.edges.name = 'outerbnd'\ninner = Circle((0,0), 1).Face()\ninner.edges.name = 'innerbnd'\ninner.faces.name ='inner'\npmlregion = outer - inner\npmlregion.faces.name = 'pmlregion'\ngeo = OCCGeometry(Glue([inner, pmlregion]), dim=2)\n\nmesh = Mesh(geo.GenerateMesh (maxh=0.1))\nmesh.Curve(3)\n\nf = exp(-20**2*((x-0.3)*(x-0.3)+y*y))\nDraw(f, mesh);\n```\n\n----------------------------------------\n\nTITLE: Generating a closed surface mesh from a sphere\nDESCRIPTION: This snippet demonstrates how to generate a closed surface mesh of a sphere using CSGeometry and Netgen. It creates a sphere, generates a mesh, and sets `perfstepsend` to `MeshingStep.MESHSURFACE` to stop after the surface is meshed, resulting in a surface mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\ngeo.Add(Sphere(Pnt(0,0,0),1))\nmesh = Mesh(geo.GenerateMesh(maxh=0.5, perfstepsend=MeshingStep.MESHSURFACE))\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Define Jump Term for HDG in NGSolve\nDESCRIPTION: This snippet defines the jump term for the HDG method, which is the difference between the element-wise variable `u` and the hybrid variable `uhat` on the element boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\njump_u = u-uhat\njump_v = v-vhat\n```\n\n----------------------------------------\n\nTITLE: Accessing Edge Basis Functions\nDESCRIPTION: This snippet demonstrates how to access and visualize basis functions associated with an edge in the H1 space. It retrieves the degrees of freedom (DOFs) associated with edge 10, sets all `GridFunction` values to zero, sets the first DOF of the edge to -1, and visualizes the basis function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# basis functions on edge nr:\nedge_dofs = fes.GetDofNrs(NodeId(EDGE,10))\nprint(\"edge_dofs =\", edge_dofs)\ngfu.vec[:] = 0\ngfu.vec[edge_dofs[0]] = -1\nDraw(gfu, order=3, min=-0.05, max=0.05, deformation=True);\n```\n\n----------------------------------------\n\nTITLE: Visualizing Vertex Basis Function\nDESCRIPTION: This snippet demonstrates how to visualize a basis function associated with a vertex in the H1 space. It sets all values in the `GridFunction` to 0, then sets the value at vertex 17 to 1, and uses `Draw` to display the basis function with deformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngfu.vec[:] = 0\n# vertex nr 17:\ngfu.vec[17] = 1\nDraw(gfu, min=0, max=1, deformation=True);\n```\n\n----------------------------------------\n\nTITLE: Simultaneous Iteration Algorithm\nDESCRIPTION: This snippet implements the simultaneous iteration algorithm to compute multiple eigenvalues. It computes residuals for each eigenvector, applies the preconditioner, sets up and solves a small eigenvalue problem, and updates the eigenvectors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.2-eigenvalues/pinvit.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasmall = Matrix(2*num, 2*num)\nmsmall = Matrix(2*num, 2*num)\nlams = num * [1]\n\nfor i in range(20):\n    \n    for j in range(num):\n        vecs[j].data = u.vecs[j]\n        r.data = a.mat * vecs[j] - lams[j] * m.mat * vecs[j]\n        vecs[num+j].data = pre.mat * r\n\n    for j in range(2*num):\n        Av.data = a.mat * vecs[j]\n        Mv.data = m.mat * vecs[j]\n        for k in range(2*num):\n            asmall[j,k] = InnerProduct(Av, vecs[k])\n            msmall[j,k] = InnerProduct(Mv, vecs[k])\n\n    ev,evec = scipy.linalg.eigh(a=asmall, b=msmall)\n    lams[:] = ev[0:num]\n    print (i, \":\", [lam/pi**2 for lam in lams])\n    \n    for j in range(num):\n        u.vecs[j][:] = 0.0\n        for k in range(2*num):\n            u.vecs[j].data += float(evec[k,j]) * vecs[k]\n            \nDraw (u);\n```\n\n----------------------------------------\n\nTITLE: Visualize Sparsity Pattern in NGSolve with Matplotlib\nDESCRIPTION: This snippet visualizes the sparsity pattern of the assembled matrix using `scipy.sparse` and `matplotlib.pylab`. It displays two plots: one showing the numerically non-zero entries and another showing all reserved entries (potentially non-zero) in the sparse matrix. This demonstrates that NGSolve reserves memory for potential non-zero entries a-priori.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport scipy.sparse as sp\nimport matplotlib.pylab as plt\nplt.rcParams['figure.figsize'] = (12, 12)\nA = sp.csr_matrix(a3.mat.CSR())\nfig = plt.figure(); ax1 = fig.add_subplot(121); ax2 = fig.add_subplot(122)\nax1.set_xlabel(\"numerically non-zero\"); ax1.spy(A)\nax2.set_xlabel(\"reserved entries (potentially non-zero)\"); ax2.spy(A,precision=-1)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Creating an additive two-grid preconditioner\nDESCRIPTION: Creates an additive two-grid preconditioner by combining the coarse grid correction `coarsepre` with the block Gauss-Seidel smoother `blockgs`. The addition of these two operators creates a new operator that represents the additive combination.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ntwogrid = coarsepre + blockgs\n```\n\n----------------------------------------\n\nTITLE: Iterate Mesh Points and Elements - Python\nDESCRIPTION: This code demonstrates how to iterate over the points and 2D elements of a generated mesh. It extracts the x, y, and z coordinates of each point and prints them, and it prints the vertices of each 2D element.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor p in mesh.Points():\n x,y,z = p.p\n print (\"x = \", x, \"y = \", y)\n for el in mesh.Elements2D():\n print (el.vertices)\n```\n\n----------------------------------------\n\nTITLE: Setting up the state equation\nDESCRIPTION: This code sets up the finite element space, trial and test functions, a grid function to store the solution, and visualizes the solution. It defines the bilinear form 'a' and the linear form 'fstate' for the state equation. The 'dirichlet=\".*\"' ensures that all boundaries are Dirichlet boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=2, dirichlet=\".*\")\nu, v = fes.TnT()\ngfu = GridFunction(fes)\nscene = Draw(gfu, mesh, \"state\")\n\na = BilinearForm(fes, symmetric=True)\na += grad(u)*grad(v)*dx\n\nfstate = LinearForm(fes)\nfstate += f*v*dx\n```\n\n----------------------------------------\n\nTITLE: Accessing subdomains by name\nDESCRIPTION: This snippet demonstrates how to access subdomains within the mesh by name using `mesh.Materials(name)`. This returns a `Region` object that represents the specified subdomain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmesh.Materials(\"inner\")\n```\n\n----------------------------------------\n\nTITLE: Windows-Specific Linking\nDESCRIPTION: This snippet conditionally links against MPI, VTUNE, PARDISO, and UMFPACK libraries on Windows. It also links against LAPACK and sets the output name of the library to `libngsolve`. Resource files are also added for Windows builds.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/solve/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif (WIN32)\n    target_link_libraries(ngsolve PUBLIC ${MPI_CXX_LIBRARIES} PRIVATE ${VTUNE_LIB} ${PARDISO_LIBS} ${UMFPACK_LIBRARIES} )\n    target_link_libraries(ngsolve ${LAPACK_CMAKE_LINK_INTERFACE} \"$<BUILD_INTERFACE:ngs_lapack>\")\n\n    set_target_properties( ngsolve PROPERTIES OUTPUT_NAME libngsolve )\n    enable_language(RC)\n    target_sources( ngsolve PRIVATE ../cmake/resources/ngsolve.rc )\n    set_target_properties( ngsolve PROPERTIES RULE_LAUNCH_COMPILE \"\" )\nendif(WIN32)\n```\n\n----------------------------------------\n\nTITLE: Generating a Mesh\nDESCRIPTION: This snippet generates a mesh, either a unit cube or a unit square, using NGSolve's built-in mesh generation capabilities. The `maxh` parameter controls the maximum mesh element size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_cube.GenerateMesh(maxh=0.5))\n# mesh = Mesh(unit_square.GenerateMesh(maxh=0.5))\n```\n\n----------------------------------------\n\nTITLE: Drawing the coil geometry\nDESCRIPTION: This code snippet uses the `DrawGeo` function from `netgen.webgui` to visualize the created coil geometry in a web browser. It helps verify the correctness of the geometric construction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nDrawGeo (coil);\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve and XFEM\nDESCRIPTION: This snippet imports the necessary modules from ngsolve, xfem, and ngsolve.webgui for creating and visualizing finite element simulations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom xfem import *\nfrom ngsolve.webgui import *\n```\n\n----------------------------------------\n\nTITLE: Solve and Visualize the Solution (NGSolve)\nDESCRIPTION: This snippet solves the linear system `a.mat * gfu.vec = f.vec` using the inverse of the assembled matrix `a.mat`. The result is stored in the grid function `gfu` and then visualized using the `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs()) * f.vec\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Generating Triangles Mesh and Level Sets (Python)\nDESCRIPTION: This snippet creates a geometry and generates a mesh. It then defines level sets for two triangles. These level sets will be used to create DomainTypeArrays, which in turn will be combined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\ngeo.AddRectangle((-2.5, -1), (1, 2.5), bc=1)\nmesh = Mesh(geo.GenerateMesh(maxh=0.3/interactive))\n\nlevel_sets1 = [-2*x + y - 1, 2*x + y - 1, -y + 2]\ndta1 = DomainTypeArray((POS, POS, POS))\nDrawDC(dta1.Indicator(level_sets1), -3.5, 2.5, mesh, \"dta1\")\n\nlevel_sets2 = [-2*x + y - 4, 2*x + y + 2, -y]\ndta2 = DomainTypeArray((NEG, NEG, NEG))\nDrawDC(dta2.Indicator(level_sets2), -3.5, 2.5, mesh, \"dta2\")\n```\n\n----------------------------------------\n\nTITLE: Creating vertex-based blocks\nDESCRIPTION: Creates vertex-based blocks for a block Jacobi preconditioner. For each vertex in the mesh, it identifies the degrees of freedom associated with elements connected to that vertex and adds them to a block. The function returns a list of sets, where each set represents a block of degrees of freedom.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef VertexPatchBlocks(mesh, fes):\n    blocks = []\n    freedofs = fes.FreeDofs()\n    for v in mesh.vertices:\n        vdofs = set()\n        for el in mesh[v].elements:\n            vdofs |= set(d for d in fes.GetDofNrs(el)\n                         if freedofs[d])\n        blocks.append(vdofs)\n    return blocks\n\nblocks = VertexPatchBlocks(mesh, fes)\nprint(blocks)\n```\n\n----------------------------------------\n\nTITLE: Plotting ksi vs fs - Python\nDESCRIPTION: This snippet generates a plot showing the relationship between the real part of the wave number (ksi) and frequency (fs).  It uses matplotlib to create the plot and display it. The x and y axis limits are explicitly set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nax.set_xlim(0,2)\nax.set_ylim(0,0.7)\nplt.plot(ksi, fs, \"*\", ms=2)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Solving (P1-iso-P2)-P1 Stokes with MinRes\nDESCRIPTION: This snippet solves the (P1-iso-P2)-P1 Stokes equation. It uses a prolongation operator to map the coarse space pressure solution to the refined velocity space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# prolongation operator from mesh-level 0 to level 1:\nprol = Q.Prolongation().Operator(1)\ninvmp2 = prol @ invmp @ prol.T\n\na = BilinearForm(InnerProduct(Grad(u),Grad(v))*dx).Assemble()\nb = BilinearForm(div(u)*q*dx).Assemble()\n\nf = LinearForm(V)\nf.Assemble()\n\ng = LinearForm(Q)\ng.Assemble()\n\ngfu = GridFunction(V, name=\"u\")\ngfp = GridFunction(Q, name=\"p\")\nuin = CF( (1.5*4*y*(0.41-y)/(0.41*0.41), 0) )\ngfu.Set(uin, definedon=mesh.Boundaries(\"inlet\"))\n\nK = BlockMatrix( [ [a.mat, b.mat.T], [b.mat, None] ] )\nC = BlockMatrix( [ [a.mat.Inverse(V.FreeDofs()), None], [None, invmp2] ] )\n\nrhs = BlockVector ( [f.vec, g.vec] )\nsol = BlockVector( [gfu.vec, gfp.vec] )\n\nsolvers.MinRes (mat=K, pre=C, rhs=rhs, sol=sol, \\\n                printrates=True, initialize=False, maxsteps=200);\n```\n\n----------------------------------------\n\nTITLE: Printing the Expression Tree of a Differentiated CoefficientFunction\nDESCRIPTION: This snippet prints the expression tree of the differentiated `myfunc` CoefficientFunction (`diff_myfunc`). It illustrates the application of the product rule in the differentiation process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint(diff_myfunc)\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh for Dynamic Contact Problem - Python\nDESCRIPTION: This code snippet generates the mesh for the previously defined dynamic contact geometry. It uses OCCGeometry to create the mesh and then curves it. Finally, it visualizes the mesh using Draw.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(OCCGeometry(geo, dim=2).GenerateMesh(maxh=0.005))\nmesh.Curve(4)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Setting Discretization Order - Python\nDESCRIPTION: This snippet defines the order of the higher-order discretization, which is set to 4.  This value affects the accuracy and computational cost of the simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\norder = 4\n```\n\n----------------------------------------\n\nTITLE: Calculating Eigenvalues with `wb_withedges`\nDESCRIPTION: This snippet calls the `TestPreconditioner` function with static condensation enabled and the `wb_withedges` flag set to `False`. It then prints the first and last three eigenvalues of the preconditioned matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nlams = TestPreconditioner(5, condense=True,\n                          wb_withedges=False)\nprint (lams[0:3], \"...\\n\", lams[-3:])\n```\n\n----------------------------------------\n\nTITLE: Getting Facets with Neighbor Types - Python\nDESCRIPTION: This snippet demonstrates how to get facets based on the types of their neighboring elements using `GetFacetsWithNeighborTypes`. It retrieves facets that are on the outer boundary of the NEG domain (neighboring both NEG and IF elements). It also gets the elements surrounding those facets using `GetElementsWithNeighborFacets`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n#help(GetFacetsWithNeighborTypes)\nba_facets = GetFacetsWithNeighborTypes(mesh,\n                                       a=ci.GetElementsOfType(NEG),\n                                       b=ci.GetElementsOfType(IF))\n#help(GetElementsWithNeighborFacets)\nba_surround_facets = GetElementsWithNeighborFacets(mesh,ba_facets)\n```\n\n----------------------------------------\n\nTITLE: Creating Geometry with Solid2d and Edge/Point Info in Python\nDESCRIPTION: This snippet demonstrates the creation of a 2D geometry using the `Solid2d` class, which allows specifying a closed chain of quadratic spline segments.  `EdgeInfo` and `PointInfo` are used to set boundary conditions and maximum mesh sizes on individual edges and points. The code then applies transformations like Scale, Move, and Rotate and visualizes the mesh using NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.2-csg2d/csg2d.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import EdgeInfo as EI, PointInfo as PI, Solid2d\n\ngeo = CSG2d()\n\nrect = Solid2d( [\n    (0,0),\n    (1,0),\n    PI(maxh=0.02),   # set maxh at point (1,0)\n    EI(bc=\"right\"),  # set bc for segment (1,0)-(1,1)\n    (1,1),\n    (0,1),\n    EI(maxh=0.05)    # set maxh for segment (0,1)-(0,0)\n  ], mat=\"rect\" )\n\ncircle = Solid2d( [\n    (0, -1),\n    EI(( 1,  -1)), # control point for quadratic spline\n    (1,0),\n    EI(( 1,  1), maxh=0.05), # spline with maxh\n    (0,1),\n    EI((-1,  1)),\n    (-1,0),\n    EI((-1, -1), bc=\"left\"), # spline with bc\n    ])\n\n# Solid2d has some methods to change it in-place:\n# Move(), Scale() and Rotate()\ncircle.Scale(0.5).Move((2,0))\ncircles = circle + circle.Copy().Move((-3,0))\n\nrect.Rotate(45, center=(0.5,0.5))\n\ngeo.Add(rect)\ngeo.Add(circles)\n\nmesh = Mesh(geo.GenerateMesh())\nmesh.Curve(3)\nprint(mesh.GetBoundaries())\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Setting up NGSolve Mesh and Finite Element Space\nDESCRIPTION: This code snippet sets up a NGSolve mesh and finite element space using the `ngsolve` library. It generates a mesh from a unit square, refines it, and defines an H1 finite element space with specified order and Dirichlet boundary conditions. It uses the `MPI.COMM_WORLD` communicator for parallel execution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%%px\nfrom ngsolve import *\nfrom netgen.occ import unit_square\ncomm = MPI.COMM_WORLD\n\nngmesh = unit_square.GenerateMesh(maxh=0.1, comm=comm)\n    \nfor l in range(2):\n    ngmesh.Refine()\nmesh = Mesh(ngmesh)\n```\n\n----------------------------------------\n\nTITLE: Solving Naghdi Shell Model with Newton's Method (Python)\nDESCRIPTION: This snippet demonstrates the solution of the nonlinear Naghdi shell model using Newton's method. It iteratively increases the load (controlled by the `factor` parameter) and solves the problem using `solvers.NewtonMinimization`. The results are printed for each load step.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n    for loadstep in range(6):\n        print(\"loadstep \", loadstep)\n        factor.Set (1.5*(loadstep+1))\n        solvers.NewtonMinimization(a, gfu, printing=False)\n```\n\n----------------------------------------\n\nTITLE: Refining mesh and integrating - Python\nDESCRIPTION: This snippet refines the mesh at the level set interface, interpolates the levelset onto the refined mesh, redraws the levelset approximation and then performs the integration again, appending the results for convergence analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nscene = Draw(lset_approx, mesh, \"lsetp1\", min=0, max=0.0)\ndef RefineAndIntegrate():\n    # refine cut elements only:\n    RefineAtLevelSet(gf=lset_approx)\n    mesh.Refine()\n\n    InterpolateToP1(levelset,lset_approx)\n    scene.Redraw()\n    integral = Integrate(f * dCut(levelset=lset_approx, domain_type=NEG, order=order), mesh=mesh)\n    AppendResultAndPostProcess(integral)\n```\n\n----------------------------------------\n\nTITLE: Initializing 5-Stage SDIRK Method in Python\nDESCRIPTION: This code initializes a 5-stage, fourth-order SDIRK method as a Python class. It defines the Butcher tableau coefficients 'a', 'b', and 'c', where 'a' represents the stage coefficients, 'b' the weights, and 'c' the nodes for the method. `astar` is the diagonal element of 'a', and `stages` is set to 5.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.1-parabolic/parabolic.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass sdirk5: #order 4\n    stages = 5\n    a = [[1/4, 0, 0, 0, 0], \n         [1/2, 1/4, 0, 0, 0], \n         [17/50,-1/25, 1/4, 0, 0],\n         [371/1360, -137/2720, 15/544, 1/4,0],\n         [25/24, -49/48, 125/16, -85/12, 1/4]]\n    b = [25/24, -49/48, 125/16, -85/12, 1/4]\n    c = [1/4, 3/4, 11/20, 1/2, 1]\n    astar = 1/4    \n```\n\n----------------------------------------\n\nTITLE: Import OCC and Netgen Draw modules - Python\nDESCRIPTION: This snippet imports the necessary modules from the netgen.occ library for creating and manipulating OCCT geometry, and the netgen.webgui module for visualizing the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom netgen.occ import *\nfrom netgen.webgui import Draw as DrawGeo\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form - Python\nDESCRIPTION: This code initializes the finite element space `VT` as an L2 space with the specified order. It then defines the trial and test functions `u` and `v`, and creates a `BilinearForm` `c` with `nonassemble=True` for efficient operator applications.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nVT = L2(mesh,order=order)\nu,v = VT.TnT()\nc = BilinearForm(VT, nonassemble=True)\n```\n\n----------------------------------------\n\nTITLE: Solving the System\nDESCRIPTION: This snippet solves the linear system `a.mat * gfu.vec = f.vec` to obtain the solution `gfu`.  The `a.mat.Inverse()` operation calculates the inverse of the system matrix. The solution `gfu` is then visualized using `Draw` with complex animation enabled.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/helmholtz.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes, name=\"u\")\ngfu.vec.data = a.mat.Inverse() * f.vec\nDraw(gfu, mesh, min=-1, max=1, order=3, animate_complex=True);\n```\n\n----------------------------------------\n\nTITLE: Defining Integrators on Sub-domains (NGSolve, Python)\nDESCRIPTION: This snippet illustrates how to define an integrator only on a specific sub-domain using the `definedon` argument. It requires the mesh region to be created beforehand, providing the necessary connection to the mesh object.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_definedon.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nf += SymbolicLFI (u1*v, definedon=mesh.Materials(\"inner\"))\n```\n\n----------------------------------------\n\nTITLE: Iterate over Vertices\nDESCRIPTION: This snippet demonstrates iterating over the vertices of a mesh and printing each vertex and its coordinates. It accesses the `mesh.vertices` attribute to iterate through vertex objects. Each vertex object `v` has a `point` attribute containing its coordinates.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor v in mesh.vertices:    \n    print (v, v.point)\n```\n\n----------------------------------------\n\nTITLE: Creating NGSolve Vectors\nDESCRIPTION: This code snippet demonstrates how to create a new vector in NGSolve with the same size and element type as an existing vector. It uses the `CreateVector()` method of the vector object.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_linalg.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nvu = u.vec\nhelp = vu.CreateVector()\n```\n\n----------------------------------------\n\nTITLE: H1 Aggregation\nDESCRIPTION: This snippet demonstrates the basis aggregation and visualization for an H1 finite element space (order=1), illustrating how continuity constraints affect the extended basis functions, which may involve averaging.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=1)\nShowPattern(AggEmbedding(EA, fes))\ngfshow = ExtendedBasisFunctionsAsMultiDim(EA,fes)\nDraw (gfshow, mesh, interpolate_multidim=False, animate=False, autoscale=True);\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This snippet imports the necessary modules from NGSolve, NGSolve WebGUI, Netgen OCC, and Matplotlib. These modules are used for finite element analysis, visualization, CAD geometry creation, and plotting.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\nimport matplotlib.pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Print Timings for Custom Assembler (NGSolve)\nDESCRIPTION: This snippet retrieves and prints the timings for the custom assembler `MyAssembleMatrix` using `pyngcore.Timers()`. It iterates through the timers and prints the name and time for any timer whose name starts with \"MyAssemble\".\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.2-C++Assemble/cppassembling.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfor t in pyngcore.Timers(): \n    if t[\"name\"].startswith(\"MyAssemble\"): \n        print (t[\"name\"],\"   \", t[\"time\"])\n```\n\n----------------------------------------\n\nTITLE: Subtracting regions\nDESCRIPTION: This snippet shows how to subtract one region from another using the - operator. In this case, the 'outer' region is subtracted from the union of 'inner' and 'outer' regions, effectively isolating the 'inner' region.  The mask of the resulting region is then printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndiff = mesh.Materials(\"inner|outer\") - mesh.Materials(\"outer\")\nprint(diff.Mask())\n```\n\n----------------------------------------\n\nTITLE: Calculate Element-wise Postprocessed L2 Error in NGSolve (Python)\nDESCRIPTION: This code calculates the L2 error of the element-wise postprocessed solution `gfps` by comparing to the `p_exact`. The `Integrate` function computes the error over the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nps_l2error = sqrt(Integrate((gfps - p_exact)**2*dX.order(2*order+3), mesh))\nprint(\"ps_l2error = \", ps_l2error)\n```\n\n----------------------------------------\n\nTITLE: Defining Plane Wave Basis Functions\nDESCRIPTION: This code defines outgoing plane wave basis functions.  It calculates wave numbers and then defines a multi-dimensional `CoefficientFunction` representing the plane waves based on the provided formula. The functions depend on spatial coordinates x and y.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nomega = 3.5*pi * (1+0j)\n\nky = [j*pi for j in range(1,5)]\nkx = [sqrt(omega**2-kyi**2) for kyi in ky]\nk = zip(ky,kx)\nshapes = CF(tuple(sin(kyi*y)*exp(1j*kxi*x) for kyi,kxi in k))\ndshapesx = shapes.Diff(x)\n```\n\n----------------------------------------\n\nTITLE: Time loop for transport solve\nDESCRIPTION: This snippet implements the time loop for solving the transport problem. In each time step, it updates the mesh deformation, solves for the flow potential, applies the transport operator, and updates the concentration field. The loop continues until the end time is reached, and the solution is visualized periodically.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nt = 0\ncnt = 0\ndeformation.vec[:] = 0\nw = gfu.vec.CreateVector()\ngfuhat = GridFunction(feshat)\n# what = gfuhat.vec.CreateVector()\n\ninvm = fes.Mass(rho=1).Inverse()\n\nwith TaskManager():\n    while t < tend:\n        defold.vec.data = deformation.vec\n        MeshRotation(t*omega, deformation)\n        \n        contact.Update (deformation, bf=ahat, intorder=10)\n        # apply the transport operator\n        mesh.SetDeformation(deformation)\n        solveWind(gfut,at,ft)\n        \n        gfuhat.vec[:] = traceop * gfu.vec\n        w[:] = a.Apply (gfu.vec) + traceop.T * ahat.Apply(gfuhat.vec)\n        \n        gfu.vec.data -= tau * invm * w\n        \n        if cnt%10 == 0:\n            mesh.SetDeformation(deformation)\n            scene.Redraw()   \n\n        t += tau\n        cnt +=1 \n\n```\n\n----------------------------------------\n\nTITLE: Drawing level set with GridFunction components\nDESCRIPTION: This snippet draws the level set along with the two components of the GridFunction gfu, labeling it as \"u\". It visualizes the solution across the interface.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(lsetp1, gfu.components[0], gfu.components[1], mesh, \"u\")\n```\n\n----------------------------------------\n\nTITLE: Upwind Scheme Boundary Integral in NGSolve (Python)\nDESCRIPTION: This code snippet demonstrates how to define a boundary integral for an upwind scheme in a Discontinuous Galerkin method for the convection equation using NGSolve. It utilizes `CoefficientFunction` to define the wind vector, `specialcf.normal` to get the outer normal vector, and `IfPos` to choose the trial function from either the current element or the neighbor based on the sign of the dot product of the wind vector and normal vector. The `Other` method is used to access the neighboring element.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/dg.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nb = CoefficientFunction( (y-0.5,0.5-x) ) \n                bn = b*specialcf.normal(2)\n                a += SymbolicBFI (bn*IfPos(bn, u, u.Other(bnd=ubnd)) * v, element_boundary=True)\n```\n\n----------------------------------------\n\nTITLE: Defining perturbed PDE and cost function\nDESCRIPTION: This code defines the perturbed PDE and cost function, introducing parameters 'J' and 'F' representing the Jacobian determinant and the Jacobian of a shape transformation. These parameters allow for differentiation with respect to shape changes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nJ = Parameter(1)\nF = Id(2)\n#Finv = 2*Id(2) - F    # consistent linearization at F = I (avoids calling Inv() for speedup)\n\ndef Equation(u,v):\n    return ( (Inv(F.trans)*grad(u))*(Inv(F.trans)*grad(v))-f*v)*J*dx\n#    return ( (Finv.trans*grad(u))*(Finv.trans*grad(v))-f*v)*J*dx\n\ndef CostAuto(u): \n    return J*(u-ud)**q*dx\n```\n\n----------------------------------------\n\nTITLE: Drawing Elements by Combined Domain Type - Python\nDESCRIPTION: This snippet iterates through combined domain types (`cdts`) and draws the corresponding elements using `BitArrayCF` and `Draw`. This demonstrates how to visualize elements based on combined criteria involving the level set function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfor dt in cdts: print(dt);Draw(BitArrayCF(ci.GetElementsOfType(dt)),mesh,\"elements_\"+str(dt),min=0,max=1)\n```\n\n----------------------------------------\n\nTITLE: ConvertL2Operator Usage\nDESCRIPTION: This snippet demonstrates a more elegant way to perform the projection between the HDG and L2 spaces using `ConvertL2Operator`. It creates an operator that converts from the HDG space (specifically, V1) to the VectorL2 space (VL2).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nHDG_to_L2 = V1.ConvertL2Operator(VL2) @ Embedding(V.ndof, V.Range(0)).T\n```\n\n----------------------------------------\n\nTITLE: Flag Vertex DOFs - NGSolve/Python\nDESCRIPTION: Flags DOFs as vertices if any rank thinks they should be one using MPI communication.  It creates a vector, sets the values corresponding to the vertices to 1, cumulates the vector across all processors using `vec.Cumulate()`, and creates a BitArray representing the primal DOFs based on the cumulated vector.  Finally, it prints the number of primal DOFs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nvec = f.vec.CreateVector()\nvec.local_vec[:] = 0.0\nfor v in vertices:\n    vec.local_vec[v] = 1\nfrom ngsolve.la import DISTRIBUTED\nvec.SetParallelStatus(DISTRIBUTED)\nvec.Cumulate()\nprimal_dofs = BitArray([vec.local_vec[k]!=0 for k in range(fes.ndof)]) & fes.FreeDofs()\n\nnprim = comm.Sum(sum([1 for k in range(fes.ndof) if primal_dofs[k] and comm.rank<pardofs.Dof2Proc(k)[0] ]))\nnpmin = comm.Min(primal_dofs.NumSet() if comm.rank else nprim)\nnpavg = comm.Sum(primal_dofs.NumSet())/comm.size\nnpmax = comm.Max(primal_dofs.NumSet())\nif comm.rank==0:\n    print('# primal dofs global: ', nprim)  \n    print('min, avg, max per rank: ', npmin, ' ', npavg, ' ', npmax)\n```\n\n----------------------------------------\n\nTITLE: Defining Periodic Unit Cell Geometry - Python\nDESCRIPTION: This snippet defines the geometry of the periodic unit cell using netgen.occ. It creates a rectangle with a circle removed and defines boundary conditions for periodicity. The created geometry consists of an outer and inner region.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom netgen.webgui import Draw as DrawGeo\n\na = 1\nr = 0.38\n\nrect = WorkPlane().RectangleC(a,a).Face()\ncirc = WorkPlane().Circle(0,0, r).Face()\n# r2 = WorkPlane().Rotate(30).RectangleC(a, a/10).Face()\n# circ += r2\n\nouter = rect-circ\ninner = rect*circ\n\nouter.faces.name = \"outer\"\nouter.faces.col=(1,1,0)\n    \ninner.faces.col=(1,0,0)\ninner.faces.name=\"inner\"\nshape = Glue([outer, inner])\n\nshape.edges.Max(X).name = \"right\"\nshape.edges.Max(-X).name = \"left\"\nshape.edges.Max(Y).name = \"top\"\nshape.edges.Max(-Y).name = \"bot\"\n\nshape.edges.Max(Y).Identify(shape.edges.Min(Y), \"bt\")\nshape.edges.Max(X).Identify(shape.edges.Min(X), \"lr\")\n```\n\n----------------------------------------\n\nTITLE: Defining nvcc Header - CMake\nDESCRIPTION: This snippet defines a string `ngs_nvcc_header` that contains shell script code to set the NVCC variable to the CUDA compiler path if available, otherwise defaults to `nvcc`. This ensures the script can find the CUDA compiler.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_9\n\nLANGUAGE: CMake\nCODE:\n```\nset( ngs_nvcc_header \"\\\n${ngscxx_set_script_dir}\nif [ -f ${CMAKE_CUDA_COMPILER} ]\n  then NVCC=${CMAKE_CUDA_COMPILER}\n  else NVCC=nvcc\nfi\n\")\n```\n\n----------------------------------------\n\nTITLE: Access Volume Element via ElementId\nDESCRIPTION: This snippet demonstrates accessing a volume element using `ElementId`.  It is an alternative way to identify elements (as opposed to NodeId).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nelt0 = mesh[ElementId(VOL, 0)]\ntype(elt0)\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear and Linear Forms\nDESCRIPTION: This code defines and assembles a bilinear and a linear form using NGSolve.  It defines a finite element space, sets up trial and test functions, and constructs the bilinear form based on gradient and function products. It then assembles a linear form defined by x*v*dx and also initializes a GridFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n%%px\nfes = H1(mesh, order=1, dirichlet=\"left|bottom\")\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx+u*v*ds).Assemble()\nf = LinearForm(x*v*dx).Assemble()\ngfu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh for Fourth Order Equations\nDESCRIPTION: This code snippet initializes the mesh for solving the fourth-order Kirchhoff plate equation. It imports the necessary modules from ngsolve and creates a mesh using the unit_square geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.9-fourthorder/fourthorder.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nmesh = Mesh (unit_square.GenerateMesh(maxh=0.1))\n```\n\n----------------------------------------\n\nTITLE: Inspecting DomainTypeArray Object (Python)\nDESCRIPTION: This snippet prints the DomainTypeArray object and the number of regions it contains. This reveals the potentially large number of regions in the description, even when many are non-existent.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nprint(dta_outside)\nprint(\"Number of regions in DomainTypeArray:\", len(dta_outside))\n```\n\n----------------------------------------\n\nTITLE: Setting Inhomogeneous Dirichlet Values - Python\nDESCRIPTION: This code sets inhomogeneous Dirichlet values on the specified boundaries using an L2 projection. It takes a function (x*y in this case) and the boundary names where the function should be applied. Arithmetic averaging is used for coupling dofs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_dirichlet.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nu.Set(x*y, definedon=mesh.Boundaries(\"top|back\"))\n```\n\n----------------------------------------\n\nTITLE: Customizing DOF Types for BDDC\nDESCRIPTION: This snippet demonstrates how to customize the degree-of-freedom (DOF) types in NGSolve to influence the behavior of the BDDC preconditioner. It iterates over mesh edges, setting all DOFs to `INTERFACE_DOF` initially, and then sets the first two edge DOFs to `WIREBASKET_DOF`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=10)\nu,v = fes.TnT()\n\nfor ed in mesh.edges:\n    dofs = fes.GetDofNrs(ed)\n    for d in dofs:\n        fes.SetCouplingType(d, COUPLING_TYPE.INTERFACE_DOF)\n\n    # Set the first two edge dofs to be conforming\n    fes.SetCouplingType(dofs[0], COUPLING_TYPE.WIREBASKET_DOF)\n    fes.SetCouplingType(dofs[1], COUPLING_TYPE.WIREBASKET_DOF)\n\na = BilinearForm(fes, eliminate_internal=True)\na += grad(u)*grad(v)*dx + u*v*dx\nc = Preconditioner(a, \"bddc\")\na.Assemble()\n\nlams=EigenValues_Preconditioner(a.mat, c.mat)\nmax(lams)/min(lams)\n```\n\n----------------------------------------\n\nTITLE: Reconstructing the Full Solution from the Condensed System (Python)\nDESCRIPTION: This snippet reconstructs the full solution vector from the condensed system's solution using harmonic extensions and inner solves.  It constructs operators corresponding to the inverse of the full matrix based on the inverse of the Schur complement, the harmonic extensions, and the inner solve, corresponding to degrees of freedom internal to each element.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ninvS = a.mat.Inverse(freedofs=fes.FreeDofs(coupling=True))\next = IdentityMatrix() + a.harmonic_extension\nextT = IdentityMatrix() + a.harmonic_extension_trans\ninvA =  ext @ invS @ extT + a.inner_solve\n```\n\n----------------------------------------\n\nTITLE: Solving and Normalizing Eigenvectors - Python\nDESCRIPTION: This snippet solves the projected eigenvalue problem and normalizes the resulting eigenvectors. The projected matrices from the bilinear forms and the subspace Q are passed to the `SolveProjected` function. The evaluated eigenvectors `Z` are then normalized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nlams, vecs = SolveProjected(a.mat, b.mat, c.mat, Q)\nZ = (Q * vecs).Evaluate()\nfor vec in Z: vec /= Norm(vec)\n```\n\n----------------------------------------\n\nTITLE: Newton iteration with AssembleLinearization\nDESCRIPTION: This snippet implies the use of AssembleLinearization for Newton Iteration to solve a minimization problem. It leverages the automatic differentiation capabilities of ngsolve to compute the linearization of the nonlinear functional.  It demonstrates one possible approach to solving the minimization problem defined earlier using a Newton-based iterative solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/symbolic_integrators.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nDraw\n```\n\n----------------------------------------\n\nTITLE: Visualizing the Time-Dependent Level Set Function (Python)\nDESCRIPTION: This snippet visualizes the time-dependent level set function on the interval [0, tend]. It calculates the level set for a single time step using tref and then uses helper functions to project the level set onto a multidimensional GridFunction for visualization with animation and deformation. It also uses the Draw function to visualize a scalar function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nr_one_timestep = sqrt(x**2 + (y - (1 / (pi)) * sin(2 * pi * tref * tend))**2)\nlevelset_one_timestep = r_one_timestep - R\n#TimeSlider_Draw(levelset_one_timestep,mesh,autoscale=False,min=-0.02,max=0.02,deformation=True)\n\nfrom helper import ProjectOnMultiDimGF\nlset_to_show = ProjectOnMultiDimGF(levelset_one_timestep,mesh,order=3,sampling=8)\nDraw(lset_to_show,mesh,\"u_exact\",autoscale=False,min=-0.5,max=1, interpolate_multidim=True, animate=True, deformation=True)\n```\n\n----------------------------------------\n\nTITLE: Drawing lines and arcs on a workplane\nDESCRIPTION: This snippet shows how to draw lines and arcs on a workplane using the Line and Arc methods. It creates a hexagonal pattern of lines and arcs. wp.MoveTo(3,0) moves the workplane's current position to coordinates (3,0). The angle parameter in Rotate and Arc is specified in degrees.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/workplane.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwp = WorkPlane()\nfor i in range(6):\n    wp.Line(1).Rotate(60)\nwp.MoveTo(3,0)\nfor i in range(6):\n    wp.Line(0.6).Arc(0.4, 60)\nface = wp.Face()\nDrawGeo(face);\n```\n\n----------------------------------------\n\nTITLE: Visualizing Results of Phase-Field Simulation in NGSolve\nDESCRIPTION: This snippet visualizes the results of the phase-field simulation using the `Draw` function. It interpolates the multi-dimensional GridFunction and animates the solution with specified min/max values and deformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu_t, mesh, interpolate_multidim=True, animate=True,\n     min=-0.1, max=0.1, autoscale=False, deformation=True)\n```\n\n----------------------------------------\n\nTITLE: Assemble LinearForm for Magnetic Field problem in ngsolve using python\nDESCRIPTION: This code snippet assembles the linear form for a magnetic field problem. The argument of the symbolic integrator must be a coefficient function depending linearly on the test and trial function. This linear form represents the right-hand side of the equation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/symbolic_integrators.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces for Koiter Shell Model (Python)\nDESCRIPTION: This snippet defines finite element spaces for the Koiter shell model. It includes spaces for displacement (`fes2`), stress (`fes1`), a hybrid variable (`fes3`), and optionally, if Regge interpolation is used (`regge = True`), spaces for curvature (`fes4`). Dirichlet boundary conditions are applied to the displacement space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# False -> membrane locking\nregge = True\norder = 2\n\nfes1 = HDivDivSurface(mesh, order=order-1, discontinuous=True)\nfes2 = VectorH1(mesh, order=order, dirichletx_bbnd=\"left\", dirichlety_bbnd=\"left|bottom\", dirichletz_bbnd=\"left\")\nfes3 = HDivSurface(mesh, order=order-1, orderinner=0, dirichlet_bbnd=\"left\")\nif regge: \n    fes4 = HCurlCurl(mesh, order=order-1, discontinuous=True)\n    fes  = fes2*fes1*fes3*fes4*fes4\n    u,sigma,hyb,C,R = fes.TrialFunction()\n    sigma, hyb, C, R = sigma.Trace(), hyb.Trace(), C.Trace(), R.Operator(\"dualbnd\")\nelse:\n    fes  = fes2*fes1*fes3\n    u,sigma,hyb = fes.TrialFunction()\n    sigma, hyb = sigma.Trace(), hyb.Trace()\n\nfesVF = VectorFacetSurface(mesh, order=order)\n        \ngfclamped = GridFunction(FacetSurface(mesh,order=0))\ngfclamped.Set(1,definedon=mesh.BBoundaries(\"left\"))\n\nsolution = GridFunction(fes, name=\"solution\")\naverednv = GridFunction(fesVF)\naverednv_start = GridFunction(fesVF)\n```\n\n----------------------------------------\n\nTITLE: Applying PML Transformation to Mesh - Python\nDESCRIPTION: Applies a PML transformation object `pmlobj` to a mesh `m` on a specified domain using the `SetPML` method. After applying the transformation, all symbolic integrators will respect the complex transformation. Note that PMLs are currently only tested on H1 spaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/pml.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nm.SetPML(pmlobj,'domain')\n```\n\n----------------------------------------\n\nTITLE: Defining BilinearForm on negative and positive domains\nDESCRIPTION: This snippet defines the bilinear form a, integrating over the negative and positive domains using the defined integration domains dx_neg and dx_pos.  It contributes terms related to the diffusion operator in each subdomain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(VhG, symmetric = True)\na += alpha[0] * grad(u[0]) * grad(v[0]) * dx_neg\na += alpha[1] * grad(u[1]) * grad(v[1]) * dx_pos\n```\n\n----------------------------------------\n\nTITLE: Define HCurl Finite Element Space and Bilinear Forms\nDESCRIPTION: This snippet defines the HCurl finite element space on the mesh, sets up bilinear forms for the Maxwell eigenvalue problem (curl-curl and mass matrix), and defines a preconditioner. The preconditioner uses a direct solver with sparse Cholesky factorization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwellevp.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# SetHeapSize(100*1000*1000)\n\nfes = HCurl(mesh, order=3)\nprint (\"ndof =\", fes.ndof)\nu,v = fes.TnT()\n\na = BilinearForm(curl(u)*curl(v)*dx)\nm = BilinearForm(u*v*dx)\n\napre = BilinearForm(curl(u)*curl(v)*dx + u*v*dx)\npre = Preconditioner(apre, \"direct\", inverse=\"sparsecholesky\")\n```\n\n----------------------------------------\n\nTITLE: Setting up NGSolve Preconditioner\nDESCRIPTION: This code sets up an NGSolve preconditioner, using the \"gamg\" option for Geometric Algebraic Multi-Grid. The preconditioner is initialized with the bilinear form, which defines the problem to be solved.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n%%px\na = BilinearForm(grad(u)*grad(v)*dx+u*v*ds)\n# pre = Preconditioner(a, \"petsc\", pctype=\"gamg\", levels=10)\npre = Preconditioner(a, \"gamg\")\na.Assemble();\n```\n\n----------------------------------------\n\nTITLE: Projected Multigrid Setup - Python\nDESCRIPTION: This code snippet sets up the mesh and finite element space for the projected multigrid method. It refines the mesh multiple times and assembles the bilinear form on the finest level only.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import unit_square\nfrom ngsolve import *\nfrom ngsolve.la import EigenValues_Preconditioner\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.3))\n\nfes = H1(mesh,order=1, dirichlet=\".*\", autoupdate=True)\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx)\n\nfor l in range(8):\n     mesh.Refine()\n    \na.Assemble();  # only matrix at the finest level provided to mg\n```\n\n----------------------------------------\n\nTITLE: Defining Nitsche discretization terms\nDESCRIPTION: This snippet defines the terms for the Nitsche discretization of the interface problem, including the test and trial functions, average fluxes, and jumps across the interface. It sets up the symbolic expressions that will be used in the bilinear and linear forms.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nh = specialcf.mesh_size\n\nalpha = [1.0,20.0]\n\n# Nitsche stabilization parameter:\nstab = 20*(alpha[1]+alpha[0])/h\n\n# expressions of test and trial functions (u and v are tuples):\nu,v = VhG.TnT()\n\naverage_flux_u = sum([- kappa[i] * alpha[i] * grad(u[i]) * n for i in [0,1]])\naverage_flux_v = sum([- kappa[i] * alpha[i] * grad(v[i]) * n for i in [0,1]])\n\njump_u = u[0] - u[1]\njump_v = v[0] - v[1]\n```\n\n----------------------------------------\n\nTITLE: Setting up the adjoint equation\nDESCRIPTION: This code sets up the adjoint equation by defining a cost function and its derivative with respect to the state variable. It also defines a finite element space, trial and test functions, and a grid function for the adjoint variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nq=4\ndef Cost(u): \n    return (u-ud)**q*dx\n\np, w = fes.TnT()\ngfp = GridFunction(fes)\nscene = Draw (gfp, mesh, \"adjoint\")\n\nfadjoint = LinearForm(fes)\nfadjoint += -1*Cost(gfu).Diff(gfu,w)\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation on 3D Periodic Cake\nDESCRIPTION: This code defines a periodic H1 finite element space on the refined cake mesh and solves a Poisson equation. The Dirichlet boundary condition is set on the bottom face. The bilinear and linear forms are assembled, and the solution is obtained by solving the linear system.  The result is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/periodicity.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfes = Periodic(H1(mesh, order=2, dirichlet=\"bot\"))\n\nu,v = fes.TnT()\n\na = BilinearForm(grad(u)*grad(v)*dx).Assemble()\nf = LinearForm(100*exp(-9*( (x-2.5)**2+y**2+(z-0.5)**2))*v*dx).Assemble()\n                 \ngfu = GridFunction(fes,\"u\")\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs()) * f.vec\n\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Adding Predefined Geometries: Rectangle and Circle (Python)\nDESCRIPTION: This snippet demonstrates how to add predefined geometries, specifically a rectangle and a circle, to a `SplineGeometry` object. It also sets boundary conditions for these shapes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngeo.AddRectangle((-1,-1),(1,1),bc=\"rectangle\")\ngeo.AddCircle((0,0),0.5,bc=\"circle\")\n```\n\n----------------------------------------\n\nTITLE: Unpickling a Mesh - Python\nDESCRIPTION: This snippet demonstrates how to unpickle an NGSolve mesh object from a file. It opens a file in binary read mode (`rb`), then uses `pickle.load` to deserialize the object from the file. It then accesses the number of vertices and elements of the unpickled mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ninfile = open(\"mesh.pkl\", \"rb\")\nmesh2 = pickle.load(infile)\nmesh2.nv, mesh2.ne\n```\n\n----------------------------------------\n\nTITLE: Variable Assignment Pitfall - Python\nDESCRIPTION: Demonstrates the pitfall of using the assignment operator '=' in Python, which creates a new object instead of assigning to an existing variable.  This can lead to unexpected behavior when manipulating NGSolve vectors. It initializes two vectors x and y, assigns a value to x, and then attempts to assign a scaled version of x to y, which actually creates a DynamicVectorExpression object.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pitfalls/pitfalls.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nx = CreateVVector(5)\ny = CreateVVector(5)\nx[:] = 3\ny = 2*x\n```\n\n----------------------------------------\n\nTITLE: Setting CMAKE_BUILD_TYPE\nDESCRIPTION: This snippet sets the CMAKE_BUILD_TYPE to \"RelWithDebInfo\" if it's not already defined. This build type provides optimized code with debugging information. The CACHE STRING INTERNAL specifies that it's a cached string variable intended for internal use.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT CMAKE_BUILD_TYPE)\n    set(CMAKE_BUILD_TYPE \"RelWithDebInfo\" CACHE STRING INTERNAL)\nendif(NOT CMAKE_BUILD_TYPE)\n```\n\n----------------------------------------\n\nTITLE: Solve Poisson Problem and Store Results (Multigrid)\nDESCRIPTION: This code solves the Poisson problem with the 'multigrid' preconditioner for 9 refinement levels and stores the results in `res_mg`. The `res_mg` variable will contain a list of tuples: (number of DoFs, number of iterations).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nres_mg = SolveProblem(levels=9, precond=\"multigrid\")\nres_mg\n```\n\n----------------------------------------\n\nTITLE: Setting Boundary Conditions - Python\nDESCRIPTION: Explains the correct way to set boundary conditions in NGSolve.  Using gfu.Set(x, BND) only sets boundary values on the Dirichlet boundary. To set values on the entire boundary, use `gfu.Set(x, mesh.Boundaries(\".*\"))`.  This snippet initializes a finite element space, a grid function, and then incorrectly sets the boundary conditions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pitfalls/pitfalls.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfes = H1(mesh, order=2, dirichlet=\"bot\")\ngfu = GridFunction(fes)\ngfu.Set(x,BND)\n```\n\n----------------------------------------\n\nTITLE: Setting interactive parameter\nDESCRIPTION: This snippet sets the `interactive` parameter, which controls the grid refinement level. A higher value (e.g., 2) results in finer grids for a better interactive experience, while a lower value (e.g., 1) is used for documentation to keep file sizes manageable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ninteractive = 1\n```\n\n----------------------------------------\n\nTITLE: Define Multiple Subdomains - Python\nDESCRIPTION: This snippet demonstrates how to define a geometry with multiple subdomains by specifying the `leftdomain` and `rightdomain` parameters when appending line segments. This allows for defining regions with different properties within the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngeo = geom2d.SplineGeometry()\np1,p2,p3,p4 = [ geo.AppendPoint(x,y) for x,y in [(0,0), (1,0), (1,1), (0,1)] ]\np5,p6 =  [ geo.AppendPoint(x,y) for x,y in [(2,0), (2,1)] ]\ngeo.Append ([\"line\", p1, p2], leftdomain=1, rightdomain=0)\ngeo.Append ([\"line\", p2, p3], leftdomain=1, rightdomain=2)\ngeo.Append ([\"line\", p3, p4], leftdomain=1, rightdomain=0)\ngeo.Append ([\"line\", p4, p1], leftdomain=1, rightdomain=0)\ngeo.Append ([\"line\", p2, p5], leftdomain=2, rightdomain=0)\ngeo.Append ([\"line\", p5, p6], leftdomain=2, rightdomain=0)\ngeo.Append ([\"line\", p6, p3], leftdomain=2, rightdomain=0)\n```\n\n----------------------------------------\n\nTITLE: Drawing NGSolve Mesh\nDESCRIPTION: This snippet shows how to draw an NGSolve mesh using Webgui. It generates a mesh from an OCC geometry and then uses the `Draw` function to visualize the mesh. The `Mesh` object is required.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh( OCCGeometry(shape).GenerateMesh(maxh=0.5))\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Comparing number of dofs between spaces\nDESCRIPTION: This snippet compares the total number of degrees of freedom (ndof) of a finite element space defined on the entire domain versus one defined on a subdomain. Although the total `ndof` may be similar, the number of *active* dofs on the subdomain space is smaller.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh)\nfes1.ndof, fes.ndof\n```\n\n----------------------------------------\n\nTITLE: Defining Grid Function for Wind (NGSolve)\nDESCRIPTION: This snippet defines a `GridFunction` called `gfwind` on the `HDiv` space and sets its value to `b`. The old `b` is then overwritten with `gfwind`, effectively Piola transforming the wind field.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ngfwind = GridFunction(HDiv(mesh, order=order))\ngfwind.Set(b)\nb=gfwind; # <- overwrite old name \"b\" \n```\n\n----------------------------------------\n\nTITLE: Printing Top Timers in Python\nDESCRIPTION: Prints the top timers with time greater than 0.5 seconds. This is helpful for identifying performance bottlenecks in the code.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n%%px --target 1\nfor t in sorted(filter(lambda t:t['time']>0.5, Timers()), key=lambda t:t['time'], reverse=True):\n    print(t['name'], ':  ', t['time'])\n```\n\n----------------------------------------\n\nTITLE: DomainTypeArray Union\nDESCRIPTION: This snippet demonstrates the use of the `|` operator to compute the union of two `DomainTypeArray` objects. Note that the DomainTypeArrays must have the same codimension.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndta1 = DomainTypeArray((POS, NEG)) | DomainTypeArray([(POS,POS),(NEG,POS)])\ndta1.as_list\n```\n\n----------------------------------------\n\nTITLE: Mixed Mass Matrices Definition\nDESCRIPTION: This code defines the mixed mass matrices used for projecting between the HDG space and the VectorL2 (DG) space. The bilinear forms `bfmixed` and `bfmixedT` are defined but not assembled, as only matrix-vector products are needed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nVL2 = VectorL2(mesh, order=order, piola=True)\nuL2, vL2 = VL2.TnT()\nbfmixed = BilinearForm ( vL2*u*dx, nonassemble=True )\nbfmixedT = BilinearForm ( uL2*v*dx, nonassemble=True)\n```\n\n----------------------------------------\n\nTITLE: Solving the adjoint equation\nDESCRIPTION: This code defines a function SolveAdjointEquation to solve the adjoint equation. It assembles the right-hand side vector 'rhs' and solves the system using the inverse of the bilinear form 'aAuto'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef SolveAdjointEquation():\n    rhs = gfp.vec.CreateVector()\n    rhs.data = fadjoint.vec - aAuto.mat.T * gfp.vec\n    update = gfp.vec.CreateVector()\n    update.data = aAuto.mat.Inverse(fes.FreeDofs()).T * rhs\n    gfp.vec.data += update\n```\n\n----------------------------------------\n\nTITLE: Setting boundary names after mesh generation\nDESCRIPTION: This snippet shows how to set boundary names after the mesh has been generated, using the `SetBCName` method. The boundary names are referenced by a 0-based index.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmesh.ngmesh.SetBCName(0, \"other_name\")\nprint(\"Bnd = \", mesh.GetBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh from Geometry\nDESCRIPTION: This snippet generates a finite element mesh from the previously defined geometry using NGSolve.  It initializes a Mesh object using geom.GenerateMesh(maxh=0.005), which specifies the maximum mesh size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.1-ngspice/NGSpiceNGSolve.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nmesh = Mesh(geom.GenerateMesh(maxh=0.005))\n# Draw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Problem in Parallel\nDESCRIPTION: This snippet uses NGSolve to define and solve a finite element problem in parallel. It initializes the mesh, defines the finite element space, assembles the bilinear and linear forms, and computes parallel dofs. It requires the `ngsolve` library and its dependencies.  MPI is used for parallelization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nimport netgen.meshing as ngmeshing\nfrom ngsolve.la import SparseMatrixd, ParallelMatrix, ParallelDofs\nfrom ngsolve.la import FETI_Jump, DISTRIBUTED, CUMULATED\n\nnref = 0\n\ndim=3\nngmesh = ngmeshing.Mesh(dim=dim)\nngmesh.Load('cube.vol')\nfor l in range(nref):\n    ngmesh.Refine()\nmesh = Mesh(ngmesh)\ncomm = MPI_Init()\nfes = H1(mesh, order=2, dirichlet='right|top|top|left')\na = BilinearForm(fes)\nu,v = fes.TnT()\na += SymbolicBFI(grad(u)*grad(v))\na.Assemble()\nf = LinearForm(fes)\nf += SymbolicLFI(x*y*v)\nf.Assemble()\npardofs = fes.ParallelDofs()\navg_dof = comm.Sum(fes.ndof) / comm.size\nif comm.rank==0:\n    print('global,  ndof =', fes.ndofglobal, ', lodofs =', fes.lospace.ndofglobal)\n    print('avg DOFs per core: ', avg_dof)\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Space and Forms - Python\nDESCRIPTION: This snippet defines the finite element space `fes` as a `HCurl` space, suitable for magnetostatics.  Bilinear and linear forms are then defined, representing the weak formulation of Maxwell's equations. Material properties (permeability) are incorporated through the `nu` coefficient function. Boundary conditions are also specified using `dirichlet=\"outer\"`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/maxwell.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = HCurl(mesh, order=4, dirichlet=\"outer\", nograds = True)\nprint (\"ndof =\", fes.ndof)\nu,v = fes.TnT()\n\nmur = { \"core\" : 1000, \"coil\" : 1, \"air\" : 1 }\nmu0 = 1.257e-6\nnu_coef = [ 1/(mu0*mur[mat]) for mat in mesh.GetMaterials() ]\n\nnu = CoefficientFunction(nu_coef)\na = BilinearForm(fes, symmetric=True)\na += nu*curl(u)*curl(v)*dx + 1e-6*nu*u*v*dx\n\nc = Preconditioner(a, type=\"bddc\")\n\nf = LinearForm(fes)\nf += CoefficientFunction((y,0.05-x,0)) * v * dx(\"coil\")\n\nu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Injecting Javascript Code - Python\nDESCRIPTION: This code demonstrates how to inject javascript code using the `js_code` argument of `ngsolve.webgui.Draw`. The javascript code rotates the camera for 3 seconds and hides the geometry edges.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\njs_code = \"\"\"\n  // Example: Rotate the view around the y axis for the first 3 seconds\n  // print message in javascript console of the browser (open with F12 for Chrome and Firefox)\n  console.log(\"hello from Javascript!\", \"Scene\", scene, \"render_data\", render_data)\n  \n  // hide geometry edges (see the 'Objects' menu in the GUI for entry names)\n  scene.gui.settings.Objects['Edges'] = false\n\n  // Track time since first draw\n  let t = 0;\n  const speed = 90*Math.PI/180;\n\n  // Register a callback function to the scene, which is called after a frame is rendered\n  scene.on(\"afterrender\", (scene, dt) => {\n    t += dt;\n    if(t<3) {\n      console.log(`time since last frame: ${dt} seconds`, \"total time: \", t, \"seconds\")\n\n      // rotate around y axis\n      scene.controls.rotateObject(new modules.THREE.Vector3(0,1,0), dt*speed)\n\n      // recalculate transformation matrices, also triggers rerendering of scene\n      scene.controls.update();\n    }\n  })\n\"\"\"\nfrom IPython.display import display, Markdown\ndisplay(Markdown(f\"```javascript\\n{js_code}```\"))\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw(m, js_code=js_code);\n```\n\n----------------------------------------\n\nTITLE: Javascript code adding checkbox and moving clipping plane\nDESCRIPTION: This is the javascript code injected to add a checkbox that can move the clipping plane.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nscene.gui.settings.panclipping = false;\nscene.gui.add(scene.gui.settings, \"panclipping\").onChange(()=>scene.animate())\n  const clipping = scene.gui.settings.Clipping;\n  clipping.x = -1;\n  clipping.z = -1;\n  \n  clipping.enable = true;\n     \n scene.on(\"afterrender\", (scene, dt) => {\n  if(scene.gui.settings.panclipping) {\n  clipping.dist += 0.5*dt;\n    if(clipping.dist >= 1)\n     clipping.dist = -1;\n    scene.controls.update();\n  })\n```\n\n----------------------------------------\n\nTITLE: Cloning the NGSolve Repository (Bash)\nDESCRIPTION: This script sets the base directory, creates the directory if it does not exist, navigates to that directory, and clones the ngsolve repository from GitHub, including all submodules. The `BASEDIR` variable should be set to the desired installation directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport BASEDIR=~/ngsuite\nmkdir -p $BASEDIR\ncd $BASEDIR\ngit clone --recurse-submodules https://github.com/NGSolve/ngsolve.git ngsolve-src\n```\n\n----------------------------------------\n\nTITLE: Assemble BilinearForm for Magnetic Field problem in ngsolve using python\nDESCRIPTION: This code snippet demonstrates how to assemble the bilinear form for a magnetic field problem. It defines the material parameter `nu` and the bilinear form `a` using symbolic integrators.  The `a.Assemble()` call is crucial to compute the matrix representation of the bilinear form.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/symbolic_integrators.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnu =\n  a = BilinearForm(curlcurl(u,v) + 1e-6*inner(u,v)*dx)\n```\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Patchwise Approximation of f in NGSolve (Python)\nDESCRIPTION: This code approximates f by a discrete extension using the ghost penalty stabilization. It defines a finite element space, sets up the bilinear and linear forms, and uses PatchwiseSolve to solve the system and store the solution in gfh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nkf = order\ngfh = GridFunction(L2(mesh,order=kf))\nfh, wh = gfh.space.TnT()\nlhs_integrals = fh * wh * dX + 0.01*(fh-fh.Other())*(wh-wh.Other()) * dFacetPatch(deformation=deformation)\nrhs_integrals = coeff_f * wh * dX\ngfh.vec.data = PatchwiseSolve(EA,gfh.space,lhs_integrals,rhs_integrals)\n```\n\n----------------------------------------\n\nTITLE: Defining Level Sets and DomainTypeArray\nDESCRIPTION: This snippet defines the domain as the intersection of multiple level sets. It creates GridFunctions to represent the level sets on a P1 finite element space. A DomainTypeArray is used to represent the domain and its boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlevel_sets = [-y, x - 1, y - 1, -x]\nlevel_sets_p1 = tuple(GridFunction(H1(mesh, order=1)) for i in range(len(level_sets)))\nfor i, lsetp1 in enumerate(level_sets_p1):\n    InterpolateToP1(level_sets[i], lsetp1)\n    DrawDC(lsetp1, -3.5, 2.5, mesh, \"lsetp1_{}\".format(i))\n\nsquare = DomainTypeArray((NEG, NEG, NEG, NEG))\nboundary = square.Boundary()\n```\n\n----------------------------------------\n\nTITLE: Checking mesh data\nDESCRIPTION: This code snippet prints out some information about the generated mesh, like the number of elements, vertices, material names, and boundary names. This allows the user to verify the mesh properties.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmesh.ne, mesh.nv, mesh.GetMaterials(), mesh.GetBoundaries()\n```\n\n----------------------------------------\n\nTITLE: Generating MPI Python Wrapper (CMake)\nDESCRIPTION: This snippet generates a Python wrapper script (`ngspy`) for MPI, which preloads necessary MKL and MPI libraries. It creates a shell script that sets the LD_PRELOAD environment variable and then executes the Netgen Python executable. It handles the case where MKL is used but is not statically linked or using SDL.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_48\n\nLANGUAGE: CMake\nCODE:\n```\nif (NETGEN_USE_MPI)\n    # generate python3 wrapper for mpi (to preload mkl and mpi libs)\n    set(ngspy_preload_libs \"${MPI_C_LIBRARIES}\")\n    if(USE_MKL AND NOT MKL_STATIC AND NOT MKL_SDL)\n      find_library(GOMP_LIBRARY NAMES libgomp.so.1 REQUIRED HINTS \"/usr/lib/x86_64-linux-gnu/\")\n      set(ngspy_preload_libs \"${ngspy_preload_libs}:${MKL_CORE_LIBRARY}:${MKL_THREADING_LIBRARY}:${MKL_INTERFACE_LIBRARY}:${MKL_BLACS_LIBRARY}:${GOMP_LIBRARY}\")\n    endif()\n    find_program(BASH bash)\n    file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/ngspy\n\"#! ${BASH}\nLD_PRELOAD=$LD_PRELOAD:${ngspy_preload_libs} ${NETGEN_PYTHON_EXECUTABLE} $*\\n\")\n    install (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/ngspy DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve_devel )\nendif (NETGEN_USE_MPI)\n```\n\n----------------------------------------\n\nTITLE: Define Finite Element Spaces\nDESCRIPTION: This snippet defines the finite element spaces for velocity and pressure using Taylor-Hood elements. It specifies the polynomial order for each space (3 for velocity, 2 for pressure) and defines the Dirichlet boundary conditions for the velocity.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nV = VectorH1(mesh,order=3, dirichlet=\"wall|cyl|inlet\")\nQ = H1(mesh,order=2)\nX = V*Q\n\nu,p = X.TrialFunction()\nv,q = X.TestFunction()\n\nnu = 0.001  # viscosity\nstokes = (nu*InnerProduct(grad(u), grad(v))+ \\\n    div(u)*q+div(v)*p - 1e-10*p*q)*dx\n\na = BilinearForm(stokes).Assemble()\n\n# nothing here ...\nf = LinearForm(X).Assemble()\n\n# gridfunction for the solution\ngfu = GridFunction(X)\n```\n\n----------------------------------------\n\nTITLE: Setting up finite element system - Python\nDESCRIPTION: This snippet sets up the finite element space (fes) with periodic boundary conditions and defines coefficient functions for material properties. It also defines bilinear forms a, b, and c for the eigenvalue problem. The material properties are defined using mesh.MaterialCF to specify different permittivity values for inner and outer regions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfes = Compress(Periodic(H1(mesh, complex=True, order=5)))\n# fes = Periodic(H1(mesh, complex=True, order=4))\n\nprint (fes.ndof)\nu,v = fes.TnT()  \n\ncf_mu = 1\ncf_eps = mesh.MaterialCF({\"inner\":9}, default=1)\n\na = BilinearForm( 1/cf_mu*grad(u)*grad(v)*dx-cf_eps*omega**2*u*v*dx )\nb = BilinearForm( 1/cf_mu*(u*grad(v)[0]-grad(u)[0]*v)*dx )\nc = BilinearForm( -1/cf_mu*u*v*dx )\na1 = BilinearForm( 1/cf_mu*grad(u)*grad(v)*dx )\na2 = BilinearForm( cf_eps*u*v*dx )\n# a = a1 - omega**2 * a2\n\n\na.Assemble()\nb.Assemble()\nc.Assemble()\na1.Assemble()\na2.Assemble();\n```\n\n----------------------------------------\n\nTITLE: Set Segment Mesh Size - Python\nDESCRIPTION: This snippet sets a segment-wise maximum mesh size using the `maxh` parameter when appending a line segment. This allows for finer control over the mesh density in specific areas of the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngeo.Append ([\"line\", p1, p2], maxh=0.1)\n```\n\n----------------------------------------\n\nTITLE: Trace Calculation with NumPy in NGSolve\nDESCRIPTION: This snippet calculates the trace of a matrix using NumPy. It retrieves data from a `GridFunction` at a specific point, reshapes it into a 3x3 matrix, and calculates the trace using `np.einsum()` and `np.eye()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n# confirm that the trace vanishes\np1 = np.array(pdraw(mesh(90, 100, 0))).reshape((3,3))\nnp.einsum('ij,ij', p1, np.eye(3))\n```\n\n----------------------------------------\n\nTITLE: Generate Quad-Dominated Mesh - Python\nDESCRIPTION: This snippet generates a quad-dominated mesh by setting the `quad_dominated` parameter to `True` in the `GenerateMesh` method. This results in a mesh primarily composed of quadrilateral elements, which can be beneficial for certain types of simulations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ngeo.GenerateMesh(maxh=..., quad_dominated=True)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Basis Functions in NGSolve\nDESCRIPTION: This Python code visualizes basis functions of the custom finite element space. It sets the `GridFunction` to zero, then sets specific degrees of freedom (mesh.nv-3 and fes.ndof-1) to one, and visualizes the resulting function. The `order=2` argument in the `Draw` function specifies the visualization order.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ngfu.vec[:] = 0\ngfu.vec[mesh.nv-3] = 1\ngfu.vec[fes.ndof-1] = 1\nDraw (gfu, order=2);\n```\n\n----------------------------------------\n\nTITLE: Listing boundary/interface regions\nDESCRIPTION: This snippet demonstrates how to retrieve a list of all boundary/interface regions in the mesh using `mesh.GetBoundaries()`. This can be helpful for debugging or iterating through all boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nmesh.GetBoundaries()   # list boundary/interface regions\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve Modules\nDESCRIPTION: This snippet imports necessary modules from the NGSolve library, including the core NGSolve functionalities, the web GUI for visualization, and ipywidgets for interactive elements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/navierstokes.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nimport ipywidgets as widgets\n```\n\n----------------------------------------\n\nTITLE: Defining the Lagrangian functional\nDESCRIPTION: This code defines the Lagrangian functional which includes the cost functional and the PDE constraint using the state (gfu) and adjoint (gfp) variables. It utilizes automatic differentiation capabilities (TnT).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nVEC = H1(mesh, order=2, dim=2)\nPHI, X = VEC.TnT()\n\ndef EquationFA(u,v):\n    return ( grad(u)*grad(v)-f*v)*dx\n\nq=4\ndef CostAutoFA(u): \n    return (u-ud)**q*dx\n\ndef CostAuto2(u): \n    return CostAutoFA(u)\n\nLagrangianFA = CostAutoFA(gfu) + EquationFA(gfu,gfp)\n```\n\n----------------------------------------\n\nTITLE: Initializing variables for Convergence study with isoparametric mapping - Python\nDESCRIPTION: This snippet initializes variables for a convergence study using isoparametric mapping. It sets the integration order, generates a mesh, defines the level set function, creates a LevelSetMeshAdaptation object, and initializes dictionaries to store errors and experimental orders of convergence (EOC) for curved and uncurved meshes and for different domain types (NEG, POS, IF).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\norder = 2\nmesh = Mesh (square.GenerateMesh(maxh=0.7, quad_dominated=False))\n\nlevelset = sqrt(x*x+y*y)-1\nreferencevals = { POS : 9-pi, NEG : pi, IF : 2*pi }\n\nlsetmeshadap = LevelSetMeshAdaptation(mesh, order=order, threshold=0.2, discontinuous_qn=True)\nlsetp1 = lsetmeshadap.lset_p1\nerrors_uncurved = dict()\nerrors_curved = dict()\neoc_uncurved = dict()\neoc_curved = dict()\n\nfor key in [NEG,POS,IF]:\n    errors_curved[key] = []\n    errors_uncurved[key] = []\n    eoc_curved[key] = []\n    eoc_uncurved[key] = []\n```\n\n----------------------------------------\n\nTITLE: Time-Stepping Loop with Device Vectors\nDESCRIPTION: This snippet implements the time-stepping loop using device vectors for GPU acceleration. It creates device vectors for the velocity and pressure fields and then performs the time integration on the GPU.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngfp.Interpolate( exp(-100*(x**2+y**2+z**2)))\ngfu.vec[:] = 0\n\nscene = Draw (gftr, draw_vol=False, order=3);\n\nt = 0\ndt = 0.5 * h / (order+1)**2 / 2\ntend = 0.1\n\nop1 = (dt * invmassu @ B).CreateDeviceMatrix()\nop2 = (dt * invmassp @ B.T).CreateDeviceMatrix()\n\ndevu = gfu.vec.CreateDeviceVector(copy=True)\ndevp = gfp.vec.CreateDeviceVector(copy=True)\n\ncnt = 0\nwith TaskManager(): \n    while t < tend:\n        t = t+dt\n        devu += op1 * devp\n        devp -= op2 * devu\n        cnt = cnt+1\n        if cnt%10 == 0:\n            gfp.vec.data = devp\n            gftr.vec.data = traceop * gfp.vec\n            scene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Distributing Mesh in Parallel (Python)\nDESCRIPTION: This code snippet demonstrates how to distribute a mesh in parallel using NGSolve and `mpi4py`. The master process (rank 0) generates the mesh and distributes it to other processes using the `Distribute` method. Other processes receive their portion of the mesh using `Receive`. It depends on NGSolve and netgen. The number of elements in each process's local mesh part is printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n%%px\nfrom ngsolve import *\nfrom netgen.occ import unit_square\n\nif comm.rank == 0:\n    mesh = Mesh(unit_square.GenerateMesh(maxh=0.1).Distribute(comm))\nelse:\n    mesh = Mesh(netgen.meshing.Mesh.Receive(comm))\nprint (mesh.GetNE(VOL))\n```\n\n----------------------------------------\n\nTITLE: Defining 2D Geometry for Static Contact - Python\nDESCRIPTION: This code snippet defines the geometry for a 2D contact problem using the netgen.occ module. It creates a rectangle and a ball, defines boundary names for contact and symmetry conditions, and generates a compound geometry. The mesh is then created and curved.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom ngsolve import *\nfrom ngsolve.solvers import *\nfrom ngsolve.webgui import Draw\nfrom netgen.webgui import Draw as DrawGeo\n\nrect = MoveTo(0,-0.02).Rectangle(0.04, 0.02).Face()\nball = MoveTo(0,0).Arc(0.005, 90).Rotate(90).Line(0.005).Close().Face()\n\nrect.edges.Min(X).name=\"sym\"\nrect.edges.Max(X).name=\"free\"\nrect.edges.Min(Y).name=\"fix\"\nrect.edges.Max(Y).name=\"contact1\"\nball.edges.Min(X).name=\"sym\"\nball.edges.Max(Y).name=\"disp\"\nball.edges.Max(X-Y).name=\"contact2\"\nball.faces.name=\"ball\"\nrect.faces.name=\"rect\"\nrect = Glue ([rect, Vertex((0.001,0,0))])\nrect.vertices.Max(Y-X).maxh=0.0002\nrect.edges.Max(Y-0.1*X).maxh=0.00002\ngeo = Compound([rect,ball])\nDrawGeo (geo)\nmesh = Mesh(OCCGeometry(geo, dim=2).GenerateMesh(maxh=0.002))\nmesh.Curve(4)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining the shape derivative linear form\nDESCRIPTION: This code defines the linear form 'dJOmegaAuto' for the shape derivative using the DiffShape command. This command automatically accounts for the transformations required to compute the shape derivative.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndJOmegaAuto = LinearForm(VEC)\ndJOmegaAuto += LagrangianFA.DiffShape(X)\n```\n\n----------------------------------------\n\nTITLE: Preconditioned Inverse Iteration (PINVIT)\nDESCRIPTION: This snippet implements the preconditioned inverse iteration (PINVIT) algorithm to solve the generalized eigenvalue problem. It calculates the Rayleigh quotient, computes the residual, applies the preconditioner, and solves a small 2x2 eigenvalue problem to find the optimal step size. The result is then used to update the solution vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.2-eigenvalues/pinvit.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nr, w, Mu, Au, Mw, Aw = u.vec.CreateVectors(6)\n\n# r.FV().NumPy()[:] = random.rand(fes.ndof)\nr.SetRandom()\nu.vec.data = Projector(fes.FreeDofs(), True) * r\n\nfor i in range(20):\n    Au.data = a.mat * u.vec\n    Mu.data = m.mat * u.vec\n    auu = InnerProduct(Au, u.vec)\n    muu = InnerProduct(Mu, u.vec)\n    # Rayleigh quotient\n    lam = auu/muu\n    print (lam / (pi**2))\n    # residual\n    r.data = Au - lam * Mu\n    w.data = pre.mat * r.data\n    # w.data = 1/Norm(w) * w\n    w *= 1/Norm(w)\n    Aw.data = a.mat * w\n    Mw.data = m.mat * w\n\n    # setup and solve 2x2 small eigenvalue problem\n    asmall = Matrix(2,2)\n    asmall[0,0] = auu\n    asmall[0,1] = asmall[1,0] = InnerProduct(Au, w)\n    asmall[1,1] = InnerProduct(Aw, w)\n    msmall = Matrix(2,2)\n    msmall[0,0] = muu\n    msmall[0,1] = msmall[1,0] = InnerProduct(Mu, w)\n    msmall[1,1] = InnerProduct(Mw, w)\n    # print (\"asmall =\", asmall, \", msmall = \", msmall)\n    \n    \n    eval,evec = scipy.linalg.eigh(a=asmall, b=msmall)\n    # print (eval, evec)\n    u.vec.data = float(evec[0,0]) * u.vec + float(evec[1,0]) * w\n    \nDraw (u);\n```\n\n----------------------------------------\n\nTITLE: Create NodeId Object\nDESCRIPTION: This snippet creates a `NodeId` object representing a vertex with number 0. It then prints the type and number of the `NodeId`. It introduces the `NodeId` class and demonstrates how to instantiate it for a specific mesh entity type (VERTEX) and number.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nv = NodeId(VERTEX,0)   # a standalone NodeId object\ntype(v)\nprint (\"type = \", v.type, \"v.nr =\", v.nr)\n```\n\n----------------------------------------\n\nTITLE: Define shape function and its gradient - Python\nDESCRIPTION: These functions `J` and `gradJ` wrap the shape function and its gradient for use with SciPy's optimization routines. The `J` function computes the cost functional by deforming the mesh and integrating the function `f`. The `gradJ` function computes the gradient of the cost functional.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef J(x_):\n        \n    gfset.Set((0,0))\n    # x_ NumPy vector \n    gfset.vec.FV().NumPy()[:] += x_\n\n    mesh.SetDeformation(gfset)\n\n    cost_c = Integrate (f, mesh)\n\n    mesh.UnsetDeformation()\n\n    Redraw(blocking=True)\n\n    return cost_c\n\ndef gradJ(x_, euclid = False):\n\n    gfset.Set((0,0))\n    # x_ NumPy vector \n    gfset.vec.FV().NumPy()[:] += x_\n\n    mesh.SetDeformation(gfset)\n\n    fX.Assemble()\n\n    mesh.UnsetDeformation()\n\n    if euclid == True:\n        gfX.vec.data = fX.vec\n    else: \n        gfX.vec.data = invaX * fX.vec\n\n    return gfX.vec.FV().NumPy().copy()\n```\n\n----------------------------------------\n\nTITLE: Symplectic Euler Time Stepping Scheme\nDESCRIPTION: This snippet implements a symplectic Euler time-stepping scheme for solving the acoustic wave equation. It takes bilinear forms B and BT, initial and final times, time step size, and scene objects as input. The function updates the grid function `gfu` based on the symplectic Euler method. The `backward` flag determines the order of updates.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef Run(B, BT, t0 = 0, tend = 0.25, tau = 1e-3, \n        backward = False, scenes = []):\n    t = 0\n    with TaskManager():\n        while t < (tend-t0) - tau/2:\n            t += tau\n            if not backward:\n                gfu.vec.data += -tau * invp @ BT * gfu.vec\n                gfu.vec.data += tau * invu @ B * gfu.vec\n                print(\"\\r t = {:}\".format(t0 + t),end=\"\")\n            else:\n                gfu.vec.data += -tau * invu @ B * gfu.vec\n                gfu.vec.data += tau * invp @ BT * gfu.vec\n                print(\"\\r t = {:}\".format(tend - t),end=\"\")\n            for sc in scenes: sc.Redraw() # blocking=False)\n        print(\"\")\n```\n\n----------------------------------------\n\nTITLE: Adding THREE.js object to Scene - Python\nDESCRIPTION: This code creates a THREE.js object (a cube) and adds it to the scene. It uses the `modules.THREE` namespace and `render_object` to integrate the cube into the NGsolve webgui.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\njs_code = \"\"\"  \n    const geometry = new modules.THREE.BoxGeometry( 1, 1, 1 );\n    const material = new modules.THREE.MeshBasicMaterial( { color: 0x0000ff } );\n    const cube = new modules.THREE.Mesh( geometry, material );\n    const render_object = new modules.render_object.RenderObject()\n    cube.matrixWorldAutoUpdate = false;\n    render_object.name = \"My Render Object\"\n    render_object.three_object = cube\n    scene.addRenderObject(render_object)\n\"\"\"\nDraw(m, js_code=js_code);\n```\n\n----------------------------------------\n\nTITLE: Javascript code for combined communication\nDESCRIPTION: This Javascript code handles combined communication. It sends a message to Python upon selection, and upon receiving face data from Python, updates the tooltip text.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nscene.on(\"select\", ({dim, index}) => {\n  console.log(\"selected\", dim, index);\n  scene.widget.send({type: 'select', dim, index})\n})\n\nscene.widget.model.on('msg:custom', (faces)=> {\n  console.log(\"received faces\", faces)\n  scene.tooltip.textContent += \", Faces: \";\n\n  for ( let i =0; i < faces.length; i++)\n      scene.tooltip.textContent += faces[i][0] + \" \" + faces[i][1] + \", \"\n\n  // extend tooltip width\n  scene.tooltip.style.width = \"300px\"\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Differential Symbols for Integration - Python\nDESCRIPTION: This snippet defines `DifferentialSymbol`s used in the variational formulation. `dxt` represents integration over the space-time domain, while `dxold` and `dxnew` represent spatial integrations at the old and new time levels, respectively.  These symbols are essential for defining the integrals in the weak form of the heat equation. `dxtref` and `dmesh` are assumed to be defined elsewhere (likely in xfem).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndxt = delta_t * dxtref(mesh, time_order=2)\ndxold = dmesh(mesh, tref=0)\ndxnew = dmesh(mesh, tref=1)\n```\n\n----------------------------------------\n\nTITLE: Setting C++ Standard and Visibility\nDESCRIPTION: Sets the C++ standard to C++17. If compiling with Emscripten, it sets the C++ visibility preset to hidden, which reduces the size of the generated JavaScript code.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_CXX_STANDARD 17)\nif(EMSCRIPTEN)\n    set(CMAKE_CXX_VISIBILITY_PRESET hidden)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This snippet imports the necessary modules from netgen.occ for geometry creation, ngsolve for finite element analysis, and ngsolve.webgui for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Regions in Netgen CSG (Python)\nDESCRIPTION: This code defines two regions: a cube with a hole cut out and the hole itself.  It adds both regions to the CSGeometry object. This demonstrates how to define multiple regions within a single geometry, important for multi-material simulations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_3d_geometries.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\ngeo.Add (cube-hole)\ngeo.Add (cube*hole)\n```\n\n----------------------------------------\n\nTITLE: Accessing Documentation in Python\nDESCRIPTION: This Python code snippet uses the `help()` function to access and display the documentation for the `MyFESpace` class defined in the compiled module `m`. This allows users to view the DocInfo structure that documents parameters and their use.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nhelp (m.MyFESpace)\n```\n\n----------------------------------------\n\nTITLE: Executing Python File in Netgen from Command Line\nDESCRIPTION: This command executes a Python file within Netgen from the command line.  Replace `poisson.py` with the path to your desired Python script. This assumes Netgen is in your system's PATH.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/gettingstarted.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnetgen poisson.py\n```\n\n----------------------------------------\n\nTITLE: Creating and Installing netgen_python Interface Library\nDESCRIPTION: Creates an interface library named `netgen_python` and handles Python integration based on the build environment (CONDA or system). It appends `NGS_PYTHON` to the compile definitions, finds Python libraries/includes and sets necessary linker flags. It links with appropriate libraries and include directories depending on the environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_38\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(netgen_python INTERFACE )\ninstall( TARGETS netgen_python ${ngs_install_dir} )\nif (NETGEN_USE_PYTHON)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS NGS_PYTHON)\n    if(BUILD_FOR_CONDA AND NOT WIN32)\n        find_package(PythonInterp 3 REQUIRED)\n        if(NOT BUILD_FOR_CONDA)\n          find_package(PythonLibs 3 REQUIRED)\n        endif()\n        target_include_directories(netgen_python INTERFACE ${PYTHON_INCLUDE_DIR})\n        if(APPLE)\n          set(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup\")\n        endif()\n    else()\n        target_link_libraries(netgen_python INTERFACE ${NETGEN_PYTHON_LIBRARIES})\n        target_include_directories(netgen_python INTERFACE ${NETGEN_PYBIND_INCLUDE_DIR} ${NETGEN_PYTHON_INCLUDE_DIRS})\n    endif()\nendif (NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: Block Inverse Operations for Velocity Space\nDESCRIPTION: Analogous to the previous snippet, this code defines the block inverse operator for the velocity finite element space (fes_u) by combining the embedding operator with the inverse mass matrix operation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nudofs = fes.Range(1)\nemb_u = Embedding(fes.ndof, udofs)\ninvmassu = fes_u.Mass(Id(mesh.dim)).Inverse()\ninvu = emb_u @ invmassu @ emb_u.T\n```\n\n----------------------------------------\n\nTITLE: Define Square Geometry - Python\nDESCRIPTION: This snippet initializes a `SplineGeometry` object, appends four points to define a square, and then connects these points with lines to form the square's boundaries. The `AppendPoint` method adds control points to the geometry, and the `Append` method creates line segments between them.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngeo = geom2d.SplineGeometry()\np1 = geo.AppendPoint (0,0)\np2 = geo.AppendPoint (1,0)\np3 = geo.AppendPoint (1,1)\np4 = geo.AppendPoint (0,1)\n\ngeo.Append ([\"line\", p1, p2])\ngeo.Append ([\"line\", p2, p3])\ngeo.Append ([\"line\", p3, p4])\ngeo.Append ([\"line\", p4, p1])\n```\n\n----------------------------------------\n\nTITLE: Setting NETGENDIR Environment Variable (Bash)\nDESCRIPTION: This command sets the `NETGENDIR` environment variable, pointing to the location of the Netgen executable. This allows the system to find the executable from any directory. The variable needs to be adjusted to your actual installation path.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport NETGENDIR=\"${BASEDIR}/ngsolve-install/bin\"\n```\n\n----------------------------------------\n\nTITLE: Displaying help for the VTKOutput class in Python\nDESCRIPTION: This code snippet demonstrates how to use the help() function in Python to display the documentation for the VTKOutput class. This allows users to explore the available options and parameters for the class.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-vtk/vtk.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nhelp(VTKOutput)\n```\n\n----------------------------------------\n\nTITLE: Defining Neo-Hookean Material Model for Static Contact - Python\nDESCRIPTION: This code defines the material properties (Young's modulus E, Poisson's ratio nu, density rho) and sets up a Neo-Hookean material model for the static contact problem. It also defines the bilinear form, contact boundary, and the coefficient function for the contact condition. The grid function is initialized with a displacement on the ball.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nE = 2.1e11\nnu = 0.2\n\nrho = 7e3\nmu  = E / 2 / (1+nu)\nlam = E * nu / ((1+nu)*(1-2*nu))\n\nI = Id(mesh.dim)\ndef Pow(a, b):\n    return a**b  # exp (log(a)*b)\n\ndef C(u):\n    # F = Id(2) + Grad(u)\n    G = Grad(u)\n    F = Id(3) + CoefficientFunction( (G[0,0], G[1,0], 0,   G[1,0], G[1,1], 0,    0, 0, u[0]/(x+1e-16) ) )\n    return F.trans*F\n\ndef NeoHooke (C):\n    return 0.5 * mu * (Trace(C-Id(C.dims[0])) + 2*mu/lam * Det(C)**(-lam/2/mu) - 1)\n\nfes = VectorH1(mesh, order=4, dirichletx=\"sym\", dirichlety=\"fix|disp\")\nu,v = fes.TnT()\n\na = BilinearForm(fes)\na += Variation((x*NeoHooke(C(u))).Compile()*dx)\n\ncontact = ContactBoundary(mesh.Boundaries(\"contact1\"), mesh.Boundaries(\"contact2\"))\n\nX = CoefficientFunction((x,y))\ncf = (X + u - (X.Other() + u.Other())) * contact.normal\n\n# energy formulation\n# contact.AddEnergy(IfPos(cf, 1e14*cf*cf, 0))\n# or integrator\ncontact.AddIntegrator(IfPos(cf, 1e14*cf*(v-v.Other())*contact.normal, 0))\n\ngfu = GridFunction(fes)\n\ndisp = -10e-6\ngfu.Set((0, disp), definedon=mesh.Materials(\"ball\"))\n\nsceneu = Draw(gfu, deformation=gfu)\n\nC_ = C(gfu).MakeVariable()\nsigma = NeoHooke(C_).Diff(C_)\nscenesigma = Draw(sigma[1,1], mesh, \"sigmazz\", min=-2e9, max=2e9)\n\n\nwith TaskManager():\n    contact.Update(gfu, a, 200, 1e-4)\n\n    NewtonMinimization(a=a, u=gfu, printing=False, inverse=\"sparsecholesky\")\n    sceneu.Redraw()\n    scenesigma.Redraw()\n\nDraw(sigma[1,1], mesh, \"sigmazz\", min=-5e9, max=0, deformation=gfu);\n```\n\n----------------------------------------\n\nTITLE: Visualizing a Vector-Valued CoefficientFunction\nDESCRIPTION: This snippet visualizes the vector-valued CoefficientFunction `vecfun` on the mesh using arrows. The `vectors=True` argument in the `Draw` function enables the vector field visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nDraw(vecfun, mesh, vectors=True);\n```\n\n----------------------------------------\n\nTITLE: Running Time Loop with Skeleton Formulation - Python\nDESCRIPTION: This code executes the `SolveAndVisualize` function with the skeleton formulation of the convection operator `c.mat` and measures the execution time using the `%%time` magic command.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n%%time\ngfu_t = SolveAndVisualize(c.mat)\n#Draw(gfu_t,mesh,interpolate_multidim=True,animate=True,\n#     min=0, max=0.2, autoscale=False, deformation=True)\n```\n\n----------------------------------------\n\nTITLE: Importing PML Setup\nDESCRIPTION: This snippet imports the PML setup from the `ring_resonator_import` module. It assumes this module contains the necessary finite element spaces, grid functions, and linear operators for the PML simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom ring_resonator_import import *\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Defining problem parameters in NGSolve\nDESCRIPTION: This code defines the source term, boundary conditions, and a material parameter (lambda) for the problem. These parameters are used in the subsequent form assembly.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.7-hybrid/hybrid.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsource = sin(pi*x)\nud = CF(5)\ng = mesh.BoundaryCF( {\"left\" : y*(1-y)}, default=0)\nlam = 10\n```\n\n----------------------------------------\n\nTITLE: Communication Javascript -> Python - Python\nDESCRIPTION: This example demonstrates communication from Javascript to Python using `scene.widget.send(message)` and `scene.widget.on_msg(callback)`. It prints adjacent faces of a selected edge in Python when an edge is selected in the webgui.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\njs_code = \"\"\"  \nscene.on(\"select\", ({dim, index}) => {\n    console.log(\"selected\", dim, index);\n    scene.widget.send({type: 'select', dim, index})\n})\n\"\"\"\ns = Draw(m, js_code=js_code);\ndef onMessage(widget, content, buffers):\n    dim = content['dim']\n    index = content['index']\n    if dim == 1:\n        # find adjacent faces to selected edge\n        r = m.Region(BBND)\n        r.Mask().Clear()\n        r.Mask().Set(index)\n        nb = r.Neighbours(BND)\n        boundaries = m.GetBoundaries()\n        faces = [ (i, boundaries[i]) for i, val in enumerate(nb.Mask()) if val ]\n        print(\"faces\", faces)\ns.widget.on_msg(onMessage)\n```\n\n----------------------------------------\n\nTITLE: Adding Netgen Subdirectory Conditionally (CMake)\nDESCRIPTION: This CMake code snippet conditionally adds the `netgen` directory as a subdirectory to the current project. The condition `BUILD_NETGEN` must be defined and evaluate to true for the subdirectory to be added. This enables the integration of Netgen's functionality during the build process if the option is enabled.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/external_dependencies/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\n# if(BUILD_NETGEN)\n#   add_subdirectory(netgen)\n# endif()\n```\n\n----------------------------------------\n\nTITLE: Define Parameters for Convection-Diffusion Problem in NGSolve\nDESCRIPTION: This snippet defines parameters used in the convection-diffusion problem, including the penalty parameter `alpha` and the mesh size `h`. These parameters are used to define the stabilization terms in the DG formulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nalpha = 4\nh = specialcf.mesh_size\n```\n\n----------------------------------------\n\nTITLE: Projecting and Visualizing Level Set and Exact Solution (Python)\nDESCRIPTION: This snippet projects both the level set and exact solution onto a multidimensional GridFunction for simultaneous visualization.  It employs a helper function ProjectPairOnMultiDimGF and the Draw function, utilizing an eval_function to conditionally display either the level set or the exact solution based on the value's sign.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nu_exact_one_timestep = cos(pi * r_one_timestep / R) * sin(pi * tref * tend)\n\nfrom helper import ProjectPairOnMultiDimGF\nlset_cf_to_show = ProjectPairOnMultiDimGF(levelset_one_timestep, u_exact_one_timestep,mesh,order=3,sampling=8)\n\nDraw(lset_cf_to_show,mesh,\"u_exact\",eval_function=\"value.x>0.0?value.z:value.y\",autoscale=False,\n     min=-0.5,max=1, interpolate_multidim=True, animate=True)\n```\n\n----------------------------------------\n\nTITLE: Setting MKL Usage Flag (CMake)\nDESCRIPTION: Sets the `NGSOLVE_USE_MKL` variable based on the boolean value of `USE_MKL`.  This determines whether NGSolve uses the Intel Math Kernel Library (MKL) for optimized numerical computations.  The `$<BOOL:${USE_MKL}>` expression converts `USE_MKL` to a boolean value.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/python/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nset(NGSOLVE_USE_MKL $<BOOL:${USE_MKL}>)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Smoothed Indicator of Corners\nDESCRIPTION: This snippet demonstrates visualization of the smoothed indicator for the corners of the geometry, offering a way to visually inspect these higher co-dimension features.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(corners.IndicatorSmoothed(level_sets_p1, 0.06/interactive), -3.5, 2.5, mesh, \"boundary_indicator\")\n```\n\n----------------------------------------\n\nTITLE: Add NGSolve Library\nDESCRIPTION: This snippet creates the `ngsolve` library, specifying its type (static or shared via `${NGSOLVE_LIB_TYPE}`), source files, and links necessary include directories and libraries. It uses `target_include_directories` to specify private include directories and `target_link_libraries` to link against Netgen, solve, ngcomp, ngfem, ngbla, ngla, ngstd, and the Netgen Python interface. An alias library 'solve' is also created.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/solve/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library( ngsolve ${NGSOLVE_LIB_TYPE} ${ngsolve_object_libs} ngsolve.cpp python_solve.cpp)\ntarget_include_directories(ngsolve PRIVATE ${NETGEN_PYTHON_INCLUDE_DIRS})\ntarget_link_libraries(ngsolve PUBLIC netgen_libs solve ngcomp ngfem ngbla ngla ngstd PRIVATE \"$<BUILD_INTERFACE:netgen_python>\" )\ninstall( TARGETS ngsolve ${ngs_install_dir} )\nadd_library(solve ALIAS ngsolve)\n```\n\n----------------------------------------\n\nTITLE: Adding Area Elements in Python\nDESCRIPTION: This code snippet adds area elements (triangles or quadrilaterals) to the mesh. It iterates through the grid and creates either a quadrilateral or two triangles based on the `quads` flag, adding them to the mesh using `mesh.Add(Element2D(...))`. The material is also set using `mesh.SetMaterial(1, \"mat\")`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmesh.SetMaterial(1, \"mat\")\nfor j in range(N):\n    for i in range(N):\n        if quads:\n            mesh.Add(Element2D(1, [pnums[i + j * (N + 1)], pnums[i + (j + 1) * (N + 1)], pnums[i + 1 + (j + 1) * (N + 1)], pnums[i + 1 + j * (N + 1)]]))\n        else:\n            mesh.Add(Element2D(1, [pnums[i + j * (N + 1)], pnums[i + (j + 1) * (N + 1)], pnums[i + 1 + j * (N + 1)]]))\n            mesh.Add(Element2D(1, [pnums[i + (j + 1) * (N + 1)], pnums[i + 1 + (j + 1) * (N + 1)], pnums[i + 1 + j * (N + 1)]]))\n```\n\n----------------------------------------\n\nTITLE: Analyzing Degree of Freedom Types (Python)\nDESCRIPTION: This code snippet analyzes the different types of degrees of freedom (dofs) in the finite element space.  It iterates through all dofs, counts the occurrences of each `CouplingType`, and stores the counts in a dictionary `dof_types`.  This provides a summary of the distribution of dof types, highlighting the number of `LOCAL_DOF`s.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndof_types = {}\nfor i in range(fes.ndof):\n    ctype = fes.CouplingType(i)\n    if ctype in dof_types.keys():\n        dof_types[ctype] += 1\n    else:\n        dof_types[ctype] = 1\ndof_types\n```\n\n----------------------------------------\n\nTITLE: Calculating condition number\nDESCRIPTION: Calculates the estimated condition number by dividing the largest eigenvalue by the smallest eigenvalue. Depends on `lams` being calculated.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmax(lams)/min(lams)\n```\n\n----------------------------------------\n\nTITLE: Defining CMake Options\nDESCRIPTION: Defines various options for the build process, such as whether to use a superbuild, enable LAPACK, CUDA, MKL, HYPRE, MUMPS, PARDISO, UMFPACK, Intel MIC, VTUNE, CCACHE, install dependencies, enable unit tests, build stub files, or use fast compilation. These options can be set by the user during configuration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\noption( USE_SUPERBUILD   \"Whether or not a superbuild should be invoked\" ON)\noption( USE_LAPACK       \"build ngsolve with LAPACK\" ON)\noption( USE_CUDA         \"enable CUDA GPU support\")\noption( USE_MKL          \"enable MKL\")\noption( USE_HYPRE        \"enable HYPRE support\")\noption( USE_MUMPS        \"enable sparse direct solver MUMPS\")\noption( USE_PARDISO      \"enable pardiso sparse direct solver\")\noption( USE_UMFPACK      \"enable umfpack sparse direct solver\" ON)\noption( INTEL_MIC        \"cross compile for intel xeon phi\")\noption( USE_VTUNE        \"include vtune pause/resume numproc\")\noption( USE_CCACHE       \"use ccache\")\noption( INSTALL_DEPENDENCIES \"install dependencies like netgen or solver libs, useful for packaging\" OFF )\noption( ENABLE_UNIT_TESTS \"Enable Catch unit tests\")\noption( BUILD_STUB_FILES \"Build stub files for better autocompletion\" ON)\noption( FAST_COMPILE \"Skip optimized function code for faster compilation times and reduced code size\" OFF )\n```\n\n----------------------------------------\n\nTITLE: MultiVector Initialization\nDESCRIPTION: This snippet initializes MultiVector objects and sets up the initial data for the MultiVector-based simultaneous iteration. A MultiVector is created based on `u.vec`, random values are assigned to the first num vectors and the preconditioner is applied. Initial eigenvalues are set to 1.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.2-eigenvalues/pinvit.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nuvecs = MultiVector(u.vec, num)\nvecs = MultiVector(u.vec, 2*num)\n\nfor v in vecs[0:num]:\n    v.SetRandom()\nuvecs[:] = pre * vecs[0:num]\nlams = Vector(num * [1])\n```\n\n----------------------------------------\n\nTITLE: Higher Order L2 Aggregation\nDESCRIPTION: This code repeats the basis aggregation and visualization process for a higher-order L2 finite element space (order=2), showing how the extended basis functions behave with increased polynomial degree.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfes = L2(mesh, order=2)\nShowPattern(AggEmbedding(EA, fes))\ngfshow = ExtendedBasisFunctionsAsMultiDim(EA,fes)\nDraw (gfshow, mesh, interpolate_multidim=False, animate=False, autoscale=True);\n```\n\n----------------------------------------\n\nTITLE: Combining Operators (NGSolve)\nDESCRIPTION: This code combines the operators `c1` and `c2` using the embedding operator `embV`. It computes `c` by adding `c1.mat` to the product of `c2.mat` and `embV`. This combines the contributions from different parts of the problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nc = c1.mat + c2.mat @ embV\n```\n\n----------------------------------------\n\nTITLE: Defining Time Derivative and Time Variable - Python\nDESCRIPTION: This snippet defines a function `dt` to rescale the time derivative operator `dtref` and creates a time variable `t` based on the reference time variable `tref`.  The rescaling is necessary because the space-time objects in `ngsxfem` are designed for the reference time interval [0,1], and this transformation maps the reference time to the actual time interval. A `Parameter` is used to store the old time value for time-stepping schemes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef dt(u):\n    return 1.0 / delta_t * dtref(u)\n\ntnew = 0\ntold = Parameter(0)\nt = told + delta_t * tref    \nt.MakeVariable()\n```\n\n----------------------------------------\n\nTITLE: Solving Stokes as Block-System with MinRes\nDESCRIPTION: This snippet solves the Stokes equation as a block system using the MinRes iterative solver. It constructs the BlockMatrix and BlockVector objects, sets up the preconditioner, and calls the MinRes solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nK = BlockMatrix( [ [a.mat, b.mat.T], [b.mat, None] ] )\nC = BlockMatrix( [ [a.mat.Inverse(V.FreeDofs()), None], [None, mp.mat.Inverse()] ] )\n\nrhs = BlockVector ( [f.vec, g.vec] )\nsol = BlockVector( [gfu.vec, gfp.vec] )\n\nsolvers.MinRes (mat=K, pre=C, rhs=rhs, sol=sol, printrates=True, initialize=False);\n```\n\n----------------------------------------\n\nTITLE: Define Finite Element Spaces for HDG in NGSolve\nDESCRIPTION: This snippet defines the finite element spaces for the Hybrid Discontinuous Galerkin (HDG) method. It uses an L2 space for the element-wise variable (`V`) and a FacetFESpace for the hybrid variable on the element boundaries (`F`). The `dirichlet` flag sets Dirichlet boundary conditions. Trial and test functions are then defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\norder=4\nV = L2(mesh, order=order)\nF = FacetFESpace(mesh, order=order, dirichlet=\"bottom|left|right|top\")\nfes = V*F\nu,uhat = fes.TrialFunction()\nv,vhat = fes.TestFunction()\n```\n\n----------------------------------------\n\nTITLE: Importing necessary libraries\nDESCRIPTION: This snippet imports the necessary libraries for using NGSolve and Netgen. It imports the core NGSolve functionalities, the web GUI, and the OpenCascade library for geometry modeling.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *   # Opencascade for geometry modeling\n```\n\n----------------------------------------\n\nTITLE: Define bilinear form for shape gradient - Python\nDESCRIPTION: This snippet defines the bilinear form `aX` for computing the shape gradient. The bilinear form integrates `InnerProduct(grad(PHI) + grad(PHI).trans, grad(PSI))` and `InnerProduct(PHI, PSI)` over the domain.  This form is used to solve for the gradient X using the equation  `b_Omega(X, psi) = DJ(Omega)(psi)`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# bilinear form for H1 shape gradient; aX represents b_Omega\naX = BilinearForm(VEC)\naX += InnerProduct(grad(PHI) + grad(PHI).trans, grad(PSI)) * dx\naX += InnerProduct(PHI, PSI) * dx\n```\n\n----------------------------------------\n\nTITLE: Creating Face Descriptors for Mesh Merging\nDESCRIPTION: This snippet creates an empty mesh (`ngmesh`) and adds two `FaceDescriptor` objects to it.  `FaceDescriptor` objects define properties associated with surface elements, such as boundary condition markers (`bc`), domain numbers in front and back of surface elements (`domin`, `domout`), and surface numbers (`surfnr`).  These descriptors are used to distinguish between the surfaces of the two meshes being merged.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# create an empty mesh\nngmesh = Mesh()\n\n# a face-descriptor stores properties associated with a set of surface elements\n# bc .. boundary condition marker,\n# domin/domout .. domain-number in front/back of surface elements (0 = void),\n# surfnr .. number of the surface described by the face-descriptor\n\nfd_outside = ngmesh.Add (FaceDescriptor(bc=1,domin=1,surfnr=1))\nfd_inside = ngmesh.Add (FaceDescriptor(bc=2,domin=2,domout=1,surfnr=2))\n```\n\n----------------------------------------\n\nTITLE: Assembling Linear Forms for Stokes\nDESCRIPTION: This snippet assembles the linear forms for the velocity (f) and pressure (g) spaces, which represent the right-hand side of the Stokes equations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(V).Assemble()\ng = LinearForm(Q).Assemble();\n```\n\n----------------------------------------\n\nTITLE: Setting up (P1-iso-P2)-P1 Formulation\nDESCRIPTION: This snippet sets up the (P1-iso-P2)-P1 formulation for the Stokes equation. The mesh is refined, and a prolongation operator is used to represent the pressure in the range of the coarse-to-fine prolongation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh( geo.GenerateMesh(maxh=0.02))\n\nV = VectorH1(mesh, order=1, dirichlet=\"wall|inlet|cyl\")\nQ = H1(mesh, order=1)\n\nu,v = V.TnT()\np,q = Q.TnT()\n\nmp = BilinearForm(p*q*dx).Assemble()\ninvmp = mp.mat.Inverse(inverse=\"sparsecholesky\")\n\nmesh.ngmesh.Refine()\nV.Update()\nQ.Update()\n```\n\n----------------------------------------\n\nTITLE: Renaming points after mesh creation\nDESCRIPTION: This snippet demonstrates how to rename a point (BBBoundary) after mesh creation using the `SetCD3Name` method. The points are referenced by a 1-based index.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmesh.ngmesh.SetCD3Name(1, \"other_bbbnd_name\")\nprint(\"BBBnd = \", mesh.GetBBBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Adding Linearization Term to BilinearForm in ngsolve (Python)\nDESCRIPTION: This snippet adds the calculated linearization term to the `BilinearForm`, completing the algorithmic linearization process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\na += linearization_term.Compile(realcompile=realcompile) * irs_dx\n```\n\n----------------------------------------\n\nTITLE: Visualizing Results of Koiter Shell Model (Python)\nDESCRIPTION: This snippet visualizes the displacement component of the `solution` GridFunction on the mesh, using the displacement itself as the deformation. This allows for a visual representation of the shell's deformation under the applied load.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nDraw(solution.components[0], mesh, \"disp\", deformation=solution.components[0]);\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Target for Generated Kernels\nDESCRIPTION: This snippet defines a custom target named `kernel_generated` that depends on the generated matrix kernel header files. This ensures that the header files are generated before any target that depends on `kernel_generated` is built.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(kernel_generated DEPENDS matkernel_1.hpp matkernel_2.hpp matkernel_4.hpp matkernel_8.hpp)\n```\n\n----------------------------------------\n\nTITLE: Defining a custom target for timings\nDESCRIPTION: This CMake code defines a custom target named `timings` that executes the timings.py script using the NETGEN_PYTHON_EXECUTABLE. It runs the script twice with different arguments (-s and -ap). If numactl is available, the script will be run with CPU binding to CPU 0. The working directory is set to the CMake binary directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/timings/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(timings\n  COMMAND ${SET_CPU_BINDING} ${NETGEN_PYTHON_EXECUTABLE} timings.py -s\n  COMMAND ${NETGEN_PYTHON_EXECUTABLE} timings.py -ap\n  WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum System Dimension\nDESCRIPTION: Defines the maximum compile-time size of SparseMatrix entries using the `MAX_SYS_DIM` variable. It sets a default value and appends a compile option to pass this value to the compiler.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_33\n\nLANGUAGE: cmake\nCODE:\n```\nset(MAX_SYS_DIM \"3\" CACHE STRING \"Maximum compile-time size of SparseMatrix entries.\")\nif (NOT MAX_SYS_DIM)\n   set(MAX_SYS_DIM \"3\")\nendif (NOT MAX_SYS_DIM)\nmessage(STATUS \"MAX_SYS_DIM = ${MAX_SYS_DIM}\")\nlist (APPEND NGSOLVE_COMPILE_OPTIONS -DMAX_SYS_DIM=${MAX_SYS_DIM})\n```\n\n----------------------------------------\n\nTITLE: Generating Corners of DomainTypeArray\nDESCRIPTION: This snippet demonstrates the creation of corners by taking the boundary of the boundary of the `DomainTypeArray`\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ncorners = boundary.Boundary()\ncorners.as_list\n```\n\n----------------------------------------\n\nTITLE: Evaluating a CoefficientFunction at Multiple Points\nDESCRIPTION: This snippet evaluates the `myfunc` CoefficientFunction at a set of points and prints the results.  It iterates through a list of points, creates a `MappedIntegrationPoint` for each, and then evaluates the function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npts = [(0.1*i, 0.2) for i in range(11)]\nvals = [myfunc(mesh(*p)) for p in pts] \nfor p,v in zip(pts, vals):\n    print(\"point=(%3.2f,%3.2f), value=%6.5f\"\n         %(p[0], p[1], v))\n```\n\n----------------------------------------\n\nTITLE: DomainTypeArray Intersection\nDESCRIPTION: This snippet showcases the usage of the `&` operator to compute the intersection between a `DomainTypeArray` and another one. Note that intersections can increase the codimension.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndta2 = outside_triangle & DomainTypeArray([(POS, NEG, POS), (POS, POS, POS)])\ndta2.as_list\n```\n\n----------------------------------------\n\nTITLE: Running Poisson Example with Python\nDESCRIPTION: This bash command demonstrates how to run the Poisson equation example directly using the Python 3 interpreter. It assumes the `poisson.py` file is located in the current directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/whetting_the_appetite/poisson.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 poisson.py\n```\n\n----------------------------------------\n\nTITLE: Running Jupyter Notebook\nDESCRIPTION: This command starts the Jupyter notebook server and opens the specified notebook file (poisson.ipynb) in the browser.  The notebook must be present in the current directory or a specified path.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/usejupyter.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\njupyter notebook poisson.ipynb\n```\n\n----------------------------------------\n\nTITLE: Merging Meshes with NGSolve\nDESCRIPTION: This Python script creates two geometries (a cube and a sphere), meshes them individually, merges the surface meshes, and generates a unified volume mesh. The resulting mesh has two sub-domains representing the sphere and its complement within the cube. It requires the NGSolve library and Netgen for mesh generation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/working_with_meshes.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport netgen.gui\nfrom netgen.geom2d import SplineGeometry\nfrom netgen.csg import * \n\n\ngeo = SplineGeometry()\ngeo.AddRectangle( (-1, -1), (1, 1), bc=\"wall\")\ngeo.AddCircle ( (0, 0), 0.5, bc=\"inner\")\n\nmesh = geo.GenerateMesh(maxh=0.1)\n\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nngmesh = Mesh(mesh)\nngmesh.Curve(3)\n\nDraw (ngmesh)\n```\n\n----------------------------------------\n\nTITLE: Enabling WebGUI Jupyter Notebook Extension\nDESCRIPTION: These commands install and enable the webgui_jupyter_widgets notebook extension, making it available for use in Jupyter notebooks (for Jupyter versions older than 7.0.0). This enables the visualization components.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/usejupyter.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\njupyter nbextension install --user --py webgui_jupyter_widgets\njupyter nbextension enable --user --py webgui_jupyter_widgets\n```\n\n----------------------------------------\n\nTITLE: Creating Mesh Regions (NGSolve, Python)\nDESCRIPTION: This snippet showcases the creation of mesh regions in NGSolve, associating domain labels and boundary parts with specific regions. The `Materials` function creates a volume region, while the `Boundaries` function creates a boundary region.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_definedon.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh.Materials(\"inner\")\nmesh.Boundaries(\"b|r|t\")\n```\n\n----------------------------------------\n\nTITLE: Matrix-Vector Multiplication with Distributed Vectors in Python\nDESCRIPTION: This snippet performs a matrix-vector multiplication using a locally assembled matrix and a cumulated vector (gfu.vec). The resulting vector is a distributed vector, and values on shared dofs are added up from each local process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.2-pardofs/pardofs.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n%%px\nr = M.CreateColVector()\nr.data = M*gfu.vec\nprint (r)\n```\n\n----------------------------------------\n\nTITLE: Assembling and solving the adjoint equation\nDESCRIPTION: This code assembles and solves the adjoint equation using the functions defined previously, and redraws the visualization scene.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfadjoint.Assemble()\nSolveAdjointEquation()\nscene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Select Faces by Max/Min Z Coordinate - Python\nDESCRIPTION: This snippet demonstrates how to select faces of a box based on the maximum or minimum Z coordinate of their center of gravity. The selected faces are then colored differently.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nbox = Box((0,0,0), (1,1,1))\nbox.faces.Max(Z).col = (1,0,0)\nbox.faces.Min(Y).col = (0,0,1)\nDrawGeo (box);\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve Modules\nDESCRIPTION: This snippet imports the necessary modules from the NGSolve library and the webgui for visualization.  It requires the NGSolve library to be installed. It provides access to core functionality for finite element simulations and mesh handling.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Creating geometry and mesh\nDESCRIPTION: This snippet creates the geometry of the rotating domain using the OCC (Open Cascade) module within Netgen. It defines shapes like squares, circles, and holes, combines them into a compound shape, and then generates a finite element mesh from the geometry. The boundary names are also defined here to apply boundary conditions later.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsquare = MoveTo(0,0).Rectangle(1,1).Face()\ncirco = Circle((0.5,0.5), 0.30001).Face()\ncirc = Circle((0.5,0.5), 0.3).Face()\nholes = Circle((0.65,0.5), 0.05).Face() + Circle((0.35,0.5), 0.05).Face()\n\nsquare.edges.name=\"outer\"\ncirc.edges.name=\"gammai\"\nholes.edges.name=\"hole\"\ncirco.edges.name=\"gammao\"\nsquare.edges.name=\"wall\"\nsquare.edges.Min(X).name=\"inlet\"\nsquare.edges.Max(X).name=\"outlet\"\nouter = square-circo\nouter.faces.name = \"outer\"\n\ncirc.faces.name = \"inner\"\n\nboth = Compound([outer, circ-holes])\nmesh = Mesh(OCCGeometry(both, dim=2).GenerateMesh(maxh=0.05)).Curve(3)\nprint (mesh.GetMaterials(), mesh.GetBoundaries())\nDraw (mesh);\n```\n\n----------------------------------------\n\nTITLE: Javascript code creating a THREE.js object\nDESCRIPTION: This javascript code creates a THREE.js object (box) and adds it to the scene.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nconst geometry = new modules.THREE.BoxGeometry( 1, 1, 1 );\nconst material = new modules.THREE.MeshBasicMaterial( { color: 0x0000ff } );\nconst cube = new modules.THREE.Mesh( geometry, material );\nconst render_object = new modules.render_object.RenderObject()\ncube.matrixWorldAutoUpdate = false;\nrender_object.name = \"My Render Object\"\nrender_object.three_object = cube\nscene.addRenderObject(render_object)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Egg Info\nDESCRIPTION: Installs the Python egg info file, a metadata file that helps Python and pip understand that Netgen is installed. It is only executed if NETGEN_USE_PYTHON is true and SKBUILD is false.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_43\n\nLANGUAGE: cmake\nCODE:\n```\nif(NETGEN_USE_PYTHON AND NOT SKBUILD)\n  # install egg file to let python/pip know that Netgen ist installed\n  file( WRITE \"ngsolve-py3.egg-info\"\n\"Metadata-Version: 2.1\nName: ngsolve\nVersion: ${NGSOLVE_VERSION_MAJOR}.${NGSOLVE_VERSION_MINOR}.${NGSOLVE_VERSION_PATCH}.post${NGSOLVE_VERSION_TWEAK}\n\")\n  install(FILES ngsolve-py3.egg-info DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON} COMPONENT ngsolve)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining LinearForm\nDESCRIPTION: This code defines the linear form 'f' using the given coefficients and integrates over the negative and positive domains.  It represents the source term in the problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ncoef_f = [1,0]    \n\nf = LinearForm(VhG)\nf += coef_f[0] * v[0] * dx_neg\nf += coef_f[1] * v[1] * dx_pos\n```\n\n----------------------------------------\n\nTITLE: Creating DomainTypeArray (Python)\nDESCRIPTION: This snippet demonstrates the creation of a DomainTypeArray for the Zalesak disk using logical operations on level sets.  It defines the z_disc as the intersection of a half-plane and the complement of another region.  DomainTypeArray provides a compact and efficient way to describe complex regions using a combination of level set comparisons.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nz_disc =    DomainTypeArray((NEG,ANY,ANY,ANY)) \\\n         & ~DomainTypeArray((NEG,NEG,NEG,NEG))\nz_disc.as_list\n```\n\n----------------------------------------\n\nTITLE: Plotting Convergence Rate of FESpace in NGSolve\nDESCRIPTION: This snippet uses Matplotlib to plot the convergence rate obtained from the previous snippet.  It plots the error as a function of the polynomial order on a logarithmic scale.  This helps visualize the convergence behavior of the finite element method.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.3-highorder/highorder.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nimport matplotlib.pyplot as plt\nn,err = zip(*errlist)\nplt.yscale('log')\nplt.plot(n,err);\n```\n\n----------------------------------------\n\nTITLE: L-BFGS Shape Optimization with SciPy - Python\nDESCRIPTION: This Python code performs shape optimization using the L-BFGS-B method from the SciPy library. It initializes the shape function `gfset`, defines optimization options such as maximum iterations and gradient tolerance, and then calls the `minimize` function from `scipy.optimize` to perform the optimization. The shape function `J` and its gradient `gradJ` are passed as arguments. It depends on the scipy.optimize module and the function J, gradJ must be defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.optimize import minimize\n\nx0 = gfset.vec.FV().NumPy()\n\n# options for optimiser\n\noptions = {\"maxiter\":1000,\n              \"disp\":True, \n              \"gtol\":1e-10}\n\n# we use quasi-Newton method L-BFGS\nminimize(J, x0, method='L-BFGS-B', jac=gradJ, options=options)\n\n```\n\n----------------------------------------\n\nTITLE: Running Time Simulation with geom_free=True\nDESCRIPTION: This snippet runs the time simulation using the assembled matrix B (with `geom_free=True`) and its transpose. It measures the execution time using the `%time` magic command and runs the simulation both forward and backward in time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n%time Run(B, B.T, backward=False)\n%time Run(B, B.T, backward=True)\n```\n\n----------------------------------------\n\nTITLE: Serializing an ngsolve Object to Binary Archive\nDESCRIPTION: This code serializes an ngsolve object `x` (likely a coordinate variable) to a binary archive using `comp.ToArchive`. The second argument `True` indicates that the archive should be binary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/emscripten/example.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport ngsolve.comp as comp\ncomp.ToArchive(x, True)\n```\n\n----------------------------------------\n\nTITLE: Adding Contact Integrator\nDESCRIPTION: This snippet adds a contact integrator to handle the transport of the concentration field across the contact boundary between the rotating and stationary parts of the domain.  It utilizes the trace operator and upwinding to ensure stability and conservation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/rotating.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncontact = ContactBoundary(mesh.Boundaries(\"gammao\"), mesh.Boundaries(\"gammai\"), volume=False)\nnc = contact.normal\n\nterm = gfutgrad*nc * IfPos (gfutgrad*nc, uhat.Trace()*(-vhat.Trace().Other()), \\\n                               uhat.Trace().Other()*(vhat.Trace()))\n\ncontact.AddIntegrator (term)\n```\n\n----------------------------------------\n\nTITLE: Setting Discretization Parameters - Python\nDESCRIPTION: This snippet sets the discretization order and the ghost penalty stabilization parameter. The order determines the polynomial degree of the finite element spaces, while the ghost penalty stabilization parameter controls the strength of the stabilization term added to the variational formulation (set to 0 for no stabilization).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\norder = 2\ngamma_stab = 0 # 0 if no ghost penalty is to be used\n```\n\n----------------------------------------\n\nTITLE: Creating Python Bindings (Conditional) - CMake\nDESCRIPTION: This block handles creating Python bindings if `NETGEN_USE_PYTHON` is enabled. It finds the Python3 library, adds a library `ngscuda` built from `python_ngscuda.cpp`, and links it with the C++ CUDA library`${lib_name}`. Finally it sets the RPATH and install the Python module.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif(NETGEN_USE_PYTHON)\n    find_package(Python3 COMPONENTS Interpreter Development)\n    Python3_add_library(ngscuda python_ngscuda.cpp)\n    target_link_libraries(ngscuda PUBLIC ${lib_name})\n    set_target_properties(ngscuda PROPERTIES INSTALL_RPATH \"${NETGEN_RPATH_TOKEN}/../${NETGEN_PYTHON_RPATH}\")\n    install(TARGETS ngscuda DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve COMPONENT ngsolve)\nendif(NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: Javascript code receiving message from Python\nDESCRIPTION: This Javascript code receives a custom message from the Python side and updates the colormap max setting in the GUI.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_14\n\nLANGUAGE: javascript\nCODE:\n```\nscene.widget.model.on('msg:custom', (message)=> {\n  console.log(\"received message\", message)\n  scene.gui.settings.Colormap.max = message.colormap_max\n  scene.animate()\n})\n```\n\n----------------------------------------\n\nTITLE: Building the Project (Bash)\nDESCRIPTION: This command initiates the compilation process using the `make` utility. The `-jx` option allows parallel compilation using `x` threads, speeding up the build. If no `-jx` option is given, `make` uses the default number of threads.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Installing nvcc and nvlink Scripts - CMake\nDESCRIPTION: This snippet installs the generated `ngs_nvcc` and `ngs_nvlink` scripts to the `${NGSOLVE_INSTALL_DIR_BIN}` directory.  The COMPONENT is set to `ngsolve_devel`, indicating these scripts are for development purposes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_12\n\nLANGUAGE: CMake\nCODE:\n```\ninstall (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/ngs_nvcc DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve_devel )\ninstall (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/ngs_nvlink DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve_devel )\n```\n\n----------------------------------------\n\nTITLE: Time Loop for Operator Splitting\nDESCRIPTION: This snippet implements the main time loop for the operator splitting scheme. It initializes a `PropagateConvection` object and then iterates through time steps, applying the convection operator explicitly and the Stokes operator implicitly. The solution is updated and visualized at each time step.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfor s in scenes : s.Draw()\n```\n\nLANGUAGE: python\nCODE:\n```\ntend += 1\nres = gfu.vec.CreateVector()\nconvpropagator = PropagateConvection(tau,substeps)\nwhile t < tend:\n    gfu.vec.data += inv @ (convpropagator - mstar) * gfu.vec\n    t += tau\n    print (\"\\r  t =\", t, end=\"\")\n    for s in scenes : s.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Cloning NGSolve repository using Git\nDESCRIPTION: This command clones the NGSolve repository, including submodules, from GitHub into the 'src' directory within the base directory. It uses the '--recurse-submodules' flag to ensure that all necessary submodules, such as Netgen, are also downloaded.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installwindows.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone --recurse-submodules https://github.com/NGSolve/ngsolve.git src\n```\n\n----------------------------------------\n\nTITLE: Visualizing H(div) Gradient\nDESCRIPTION: This snippet demonstrates how to access and visualize the element-wise gradient of an H(div) finite element function. It uses the Operator() method with the `grad` argument to access gradient operator and then draws the 0,1 component of the gradient.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nDraw (grad(ud)[0,1], mesh, \"gradud\");\n```\n\n----------------------------------------\n\nTITLE: Marking Elements by DOMAIN_TYPE - Python\nDESCRIPTION: This snippet defines a function `DrawMarkedElements` that iterates through different domain types (`IF`, `NEG`, `POS`) and draws the corresponding elements using `BitArrayCF` and `Draw`.  This demonstrates how to mark elements based on whether they are cut by the interface or lie entirely within the positive or negative domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndts = [IF,NEG,POS]\ndef DrawMarkedElements():\n    for dt in dts: \n        print(\"Drawing\", dt); \n        Draw(BitArrayCF(ci.GetElementsOfType(dt)),mesh,\"elements_\"+str(dt))\n        yield\ndme = DrawMarkedElements()\n```\n\n----------------------------------------\n\nTITLE: Importing Netgen Meshing Module\nDESCRIPTION: This snippet imports the necessary modules from the `netgen.meshing` library, enabling the creation and manipulation of meshes. It is a fundamental first step in any mesh generation process using Netgen. This also includes the import of netgen.gui, which is commented out.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# import netgen.gui\nfrom netgen.meshing import *\n```\n\n----------------------------------------\n\nTITLE: Artificial Diffusion Implementation - Python\nDESCRIPTION: This snippet adds artificial diffusion to the DG formulation to stabilize the solution and prevent oscillations near shocks. It uses a parameter `artvisc` to control the amount of diffusion.  `AddArtificialDiffusion` function (presumably from a separate file) modifies the bilinear form `a` to include the diffusion term.  The `compile=True` argument is likely related to optimizing the diffusion calculation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom DGdiffusion import AddArtificialDiffusion\n\nartvisc = Parameter(1.0)\nif order > 0:\n    AddArtificialDiffusion(a,Ubnd,artvisc,compile=True)\n```\n\n----------------------------------------\n\nTITLE: Changing the Value of a Parameter\nDESCRIPTION: This snippet demonstrates how to change the value of a `Parameter` using the `Set` method. It modifies the value of `k` to 10 and then redraws the CoefficientFunction `f` to reflect the change.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nk.Set(10)\nDraw(f, mesh, order=3);\n```\n\n----------------------------------------\n\nTITLE: Setting DG Jumps Flag in FESpace (Python)\nDESCRIPTION: This snippet shows how to set the `dgjumps` flag to `True` when defining the `FESpace` in NGSolve.  This tells NGSolve to reserve more entries in the matrix, which is necessary when working with assembled matrices in DG methods due to the larger matrix stencil.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/dg.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nFESpace( ... , flags = { \"dgjumps\" : True })\n```\n\n----------------------------------------\n\nTITLE: Setting the mesh deformation\nDESCRIPTION: This code sets the deformation of the mesh using the GridFunction 'gfset'. It initializes 'gfset' to zero, sets it as the mesh deformation, and visualizes it.  The SetVisualization(deformation=True) is key for displaying deformed meshes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# gfset denotes the deformation of the original domain and will be updated during the shape optimization\ngfset = GridFunction(VEC)\ngfset.Set((0,0))\nmesh.SetDeformation(gfset)\nsceneSet = Draw(gfset,mesh,\"gfset\")\nSetVisualization (deformation=True)\n```\n\n----------------------------------------\n\nTITLE: Auxiliary Space Preconditioning (Python)\nDESCRIPTION: This snippet implements auxiliary space preconditioning for the DG discretization using the H1 discretization. It creates a transformation operator from the DG space to the H1 space and combines it with the H1 preconditioner and a smoother for the DG matrix.  Finally, it solves the linear system using a CG solver with the combined preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ntransform = fesH1.ConvertL2Operator(fesDG)\npre = transform @ preH1.mat @ transform.T + aDG.mat.CreateSmoother()\n\nsolvers.CG(mat=aDG.mat, rhs=fDG.vec, sol=gfuDG.vec, pre=pre, \\\n           maxsteps=200)\n\nDraw (gfuDG)\n```\n\n----------------------------------------\n\nTITLE: Creating Distributed Mesh with NGSolve and Netgen in Python\nDESCRIPTION: This snippet creates a distributed mesh using NGSolve and Netgen. The root process generates a mesh and distributes it to other processes using MPI. Other processes receive the mesh. This is essential for setting up a parallel finite element simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.2-pardofs/pardofs.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n%%px\nfrom ngsolve import *\nfrom netgen.geom2d import unit_square\ncomm = MPI.COMM_WORLD\nif comm.rank == 0:\n    mesh = Mesh(unit_square.GenerateMesh(maxh=0.1).Distribute(comm))\nelse:\n    mesh = Mesh(netgen.meshing.Mesh.Receive(comm))\n```\n\n----------------------------------------\n\nTITLE: Setting NETGEN_DIR\nDESCRIPTION: Sets the NETGEN_DIR variable, which specifies the path to the Netgen installation. If left empty, Netgen will be built automatically. The CACHE PATH indicates that this is a cached variable of type PATH, allowing the user to set it through the CMake GUI or command line.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nset(NETGEN_DIR \"\" CACHE PATH \"Path to Netgen, leave empty to build Netgen automatically\")\n```\n\n----------------------------------------\n\nTITLE: Print Detailed Timers for Slowest Process - NGSolve/Python\nDESCRIPTION: Identifies the process with the maximum time spent in the 'SparseCholesky<d,d,d>::MultAdd' timer and prints detailed timer information for that process, including timers with values greater than the minimum of 0.3 times the maximum 'SparseCholesky<d,d,d>::MultAdd' time or 0.5 seconds. This pinpoints the most time-consuming operations on the rank with the highest Cholesky factorization time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nt_chol = filter(lambda t: t['name'] == 'SparseCholesky<d,d,d>::MultAdd', Timers()).__next__()\nmaxt = comm.Max(t_chol['time']) \nif t_chol['time'] == maxt:\n    print('timers from rank ', comm.rank, ':')\n    for t in sorted(filter(lambda t:t['time']>min(0.3*maxt, 0.5), Timers()), key=lambda t:t['time'], reverse=True):\n        print(t['name'], ':  ', t['time'])\n```\n\n----------------------------------------\n\nTITLE: Drawing the WebGL Scene\nDESCRIPTION: This snippet creates an instance of the `NewWebGLScene` class with the mesh, a coefficient function `CF((x,y,z,u))`, binary data transfer, and order 2. It then calls the `Draw` method to render the scene in the web browser.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/emscripten/example.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncf = CF((x,y,z,u))\nscene = NewWebGLScene(mesh, cf, True, order=2)\ndata = scene.GetData()\n\nscene.Draw()\n```\n\n----------------------------------------\n\nTITLE: Setting CUDA Compile Options - CMake\nDESCRIPTION: This snippet sets compile options specific to CUDA. `--expt-relaxed-constexpr` allows for relaxed constexpr evaluation, and `--extended-lambda` enables extended lambda features. These options are passed to the CUDA compiler during compilation of the library.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_compile_options(${lib_name} PUBLIC $<$<COMPILE_LANGUAGE:CUDA>:--expt-relaxed-constexpr --extended-lambda >)\n```\n\n----------------------------------------\n\nTITLE: Solve Poisson Problem and Store Results (Local)\nDESCRIPTION: This code solves the Poisson problem with the 'local' preconditioner for 9 refinement levels and stores the results in `res_local`. The `res_local` variable will contain a list of tuples: (number of DoFs, number of iterations).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nres_local = SolveProblem(levels=9, precond=\"local\")\nres_local\n```\n\n----------------------------------------\n\nTITLE: Printing Degrees of Freedom\nDESCRIPTION: This code prints the total number of degrees of freedom (ndof) for the combined finite element space `fes`, the FEM space `fesfem`, and the wave space `feswaves`. This is useful for understanding the size of the problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfes.ndof, fesfem.ndof, feswaves.ndof\n```\n\n----------------------------------------\n\nTITLE: Adding Face Descriptor in Python\nDESCRIPTION: This code snippet adds a FaceDescriptor to the mesh, which defines the surface number, domain, and boundary condition. Here, it sets the surface number to 1, the domain to 1, and the boundary condition to 1.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmesh.Add (FaceDescriptor(surfnr=1,domin=1,bc=1))\n```\n\n----------------------------------------\n\nTITLE: Get Help on FESpaceElement\nDESCRIPTION: This snippet imports the `FESpaceElement` class from `ngsolve.comp` and calls the `help` function to print its documentation. This is a debugging tool to help to understand more about the object type.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.comp import FESpaceElement\nhelp(FESpaceElement)\n```\n\n----------------------------------------\n\nTITLE: Adjusting Faces and Edges\nDESCRIPTION: This snippet adjusts the faces and edges by removing any vertices that are already considered subdomain vertices, and likewise it removes vertices for faces. It filters the faces and edges to remove empty sets.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nall_e = set.union(*[set(f) for f in faces]) if len(faces) else {}\nfaces2 = [[v for v in f if not v in all_e] for f in faces]\nfaces = [f for f in faces2 if len(f)]\n\n\nedges2 = [[v for v in e if not v in vertices] for e in edges]\nedges = [e for e in edges2 if len(e)]\n```\n\n----------------------------------------\n\nTITLE: Configuring Emscripten Executable in CMake\nDESCRIPTION: This CMake code block configures an executable named 'em_ngs' specifically for the Emscripten environment when Python is not in use. It sets the include directories, links necessary libraries (ngcomp, ngfem, etc.) including ZLIB, and defines linker options for memory growth, embind, and ES6 module export with modularization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/emscripten/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(EMSCRIPTEN AND NOT NETGEN_USE_PYTHON)\n  add_executable(em_ngs em_ngs.cpp)\n  target_include_directories(em_ngs PRIVATE ${ZLIB_INCLUDE_DIRS})\n  target_link_libraries(em_ngs PUBLIC ngcomp ngfem ngla ngbla ngstd nglib ${NETGEN_ZLIB_LIBRARIES})\n  target_link_options(em_ngs PUBLIC -sALLOW_MEMORY_GROWTH)\n  target_link_options(em_ngs PUBLIC -lembind)\n  target_link_options(em_ngs PUBLIC -sEXPORT_ES6=1 -sMODULARIZE) # -sLINKABLE)\nendif(EMSCRIPTEN AND NOT NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: Installing Header Files - CMake\nDESCRIPTION: This snippet installs a list of header files to the `${NGSOLVE_INSTALL_DIR_INCLUDE}` directory. The COMPONENT is set to `ngsolve_devel`, indicating these headers are part of the development package.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_13\n\nLANGUAGE: CMake\nCODE:\n```\ninstall( FILES\n        cuda_linalg.hpp\n        cuda_profiler.hpp\n        unifiedvector.hpp\n        cuda_ngstd.hpp\n        cuda_ngbla.hpp\n        linalg_kernels.hpp\n        DESTINATION ${NGSOLVE_INSTALL_DIR_INCLUDE}\n        COMPONENT ngsolve_devel\n)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Coupling Types of Degrees of Freedom (Python)\nDESCRIPTION: This code iterates through all degrees of freedom (dofs) in the finite element space and prints the coupling type of each dof using `fes.CouplingType(i)`.  This helps understand how NGSolve classifies dofs for static condensation (e.g., LOCAL_DOF vs. other types).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(fes.ndof):\n    print(fes.CouplingType(i))\n```\n\n----------------------------------------\n\nTITLE: Estimating condition number\nDESCRIPTION: This code snippet estimates the condition number of the preconditioned matrix by computing the eigenvalues using the `EigenValues_Preconditioner` function with the assembled matrix `a.mat` and the point Jacobi preconditioner `preJpoint`. It then calculates the ratio of the maximum to the minimum eigenvalue to estimate the condition number.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlams = EigenValues_Preconditioner(mat=a.mat, pre=preJpoint)\nlams\n```\n\n----------------------------------------\n\nTITLE: Generating triangular structured surface meshes\nDESCRIPTION: This snippet generates a structured triangular surface mesh using the MakeStructuredSurfaceMesh function. The flip_triangles argument allows changing the triangle orientation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nmesh = MakeStructuredSurfaceMesh(quads=False, nx=12, ny=2, mapping=mapping, flip_triangles=True)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Performing Transient Analysis in PySpice\nDESCRIPTION: This snippet performs a transient analysis of the defined circuit using PySpice.  It sets up the simulation and plots the input and output voltages. A try-except block handles potential errors during simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.1-ngspice/NGSpiceNGSolve.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    simulator = circuit.simulator()\n    analysis = simulator.transient(step_time=source.period/50, end_time=source.period*4)\n    # analysis = simulator.transient(step_time=1e-4, end_time=1e-2)\n    \n    import matplotlib.pyplot as plt\n    plt.plot (analysis.input)\n    plt.plot (analysis.output)\nexcept:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Installing the ngbla Library\nDESCRIPTION: This snippet installs the `ngbla` library to the specified installation directory. The variable `${ngs_install_dir}` controls the installation location.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( TARGETS ngbla ${ngs_install_dir} )\n```\n\n----------------------------------------\n\nTITLE: Creating a Structured Mesh and Level Set\nDESCRIPTION: This code creates a structured 2D mesh and defines a level set function to represent a boundary. It then interpolates the level set onto the mesh to create a GridFunction for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.meshes import MakeStructured2DMesh\nmesh = MakeStructured2DMesh(quads=False, nx=3, ny=2)\nlevelset = x - 0.8\ngflset = GridFunction(H1(mesh))\nInterpolateToP1(levelset, gflset)\nDrawDC(gflset, -1.0, 2.0, mesh, \"x\")\n```\n\n----------------------------------------\n\nTITLE: Creating Union DomainTypeArray Manually (Python)\nDESCRIPTION: This snippet creates a DomainTypeArray representing the union of two regions by explicitly listing the domain tuples. This achieves the same result as using TensorUnion.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ndta3 = DomainTypeArray([(POS, POS, POS, ANY, ANY, ANY),\n                        (ANY, ANY, ANY, NEG, NEG, NEG)])\nDrawDC(dta3.Indicator(level_sets1 + level_sets2), -3.5, 2.5, mesh, \"union\")\n```\n\n----------------------------------------\n\nTITLE: Installing Header Files with CMake\nDESCRIPTION: This CMake command installs the specified header files (ngs_stdcpp_include.hpp, ngs_defines.hpp, compatibility.hpp) to the include directory defined by the NGSOLVE_INSTALL_DIR_INCLUDE variable. The installed files are part of the 'ngsolve_devel' component. This allows developers to include these headers in their projects when using ngsolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/include/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ninstall( FILES\n        ngs_stdcpp_include.hpp ngs_defines.hpp compatibility.hpp \n        DESTINATION ${NGSOLVE_INSTALL_DIR_INCLUDE}\n        COMPONENT ngsolve_devel\n       )\n```\n\n----------------------------------------\n\nTITLE: Convergence Study for TDNNS in NGSolve\nDESCRIPTION: This snippet performs a convergence study for the TDNNS method. It iteratively solves the BVP, computes the relative error between the numerical solution and the exact solution, stores the error and number of degrees of freedom, and refines the mesh. The process is repeated for a specified number of iterations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nl = []\nfor i in range(5):\n    print(\"i = \", i)\n    SolveBVP()\n    if clamped:\n        norm_w = sqrt(Integrate(w_c_ex*w_c_ex, mesh))\n        err = sqrt(Integrate((gfu-w_c_ex)*(gfu-w_c_ex), mesh))/norm_w\n    else:\n        norm_w = sqrt(Integrate(w_s_ex*w_s_ex, mesh))\n        err = sqrt(Integrate((gfu-w_s_ex)*(gfu-w_s_ex), mesh))/norm_w\n    print(\"err = \", err)\n    l.append ( (fes.ndof, err ))\n    mesh.Refine()\n```\n\n----------------------------------------\n\nTITLE: Creating Union DomainTypeArray (Python)\nDESCRIPTION: This snippet creates a DomainTypeArray representing the union of two other DomainTypeArrays using the TensorUnion function. The combined DomainTypeArray is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\ndta_union = TensorUnion(dta1, dta2)\nDrawDC(dta_union.Indicator(level_sets1 + level_sets2), -3.5, 2.5, mesh, \"union\")\n```\n\n----------------------------------------\n\nTITLE: Setting Linker Flags (CMake)\nDESCRIPTION: This snippet defines linker flags based on the configuration options, specifically for MKL and MPI. It iterates through MPI libraries and appends them to the linker flags. It also handles special cases for macOS (APPLE) and Windows (WIN32).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_46\n\nLANGUAGE: CMake\nCODE:\n```\n# linker flags\nif(USE_MKL AND NOT INSTALL_DEPENDENCIES AND NOT MKL_STATIC AND WIN32)\n    set( ngsld_flags \"${ngsld_flags} ${MKL_LINK_FLAGS}\" )\nendif()\n\nif(USE_MPI)\n  set( ngsld_flags \"${ngsld_flags} ${MPI_LINK_FLAGS}\" )\n  foreach( lib ${MPI_CXX_LIBRARIES} )\n    set(ngsld_flags \"${ngsld_flags} ${lib}\")\n  endforeach()\nendif(USE_MPI)\n\nif(APPLE)\n    install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/pictures/logo.icns DESTINATION ${NGSOLVE_INSTALL_DIR_RES}/../ RENAME Netgen.icns)\n    if(CMAKE_OSX_SYSROOT)\n        set( ngscxx_includes \"-isysroot ${CMAKE_OSX_SYSROOT} ${ngscxx_includes}\" )\n        set( ngsld_flags \"-isysroot ${CMAKE_OSX_SYSROOT} ${ngsld_flags}\" )\n    endif()\n    #   set(ngscxx_flags \"${ngscxx_flags} -Qunused-arguments\")\n    set(ngscxx_includes \"${ngscxx_includes} -I$Netgen_BUNDLE/Contents/Resources/include\" )  \n    set(ngsld_flags \"${ngsld_flags} -L$Netgen_BUNDLE/Contents/MacOS  -undefined dynamic_lookup\" )\n    set(ngscxx_header \"\\\n#!${BASH}\n${ngscxx_set_script_dir}\nNetgen_BUNDLE=\\\"`echo \\\"$0\\\" | sed -e 's/\\\\/Contents\\\\/MacOS\\\\/ngscxx//'`\\\"\"\nNetgen_MACOS=\"$Netgen_BUNDLE/Contents/MacOS\"\n\")\n    set(ngsld_header \"\\\n#!${BASH}\n${ngscxx_set_script_dir}\nNetgen_BUNDLE=\\\"`echo \\\"$0\\\" | sed -e 's/\\\\/Contents\\\\/MacOS\\\\/ngsld//'`\\\"\"\nNetgen_MACOS=\"$Netgen_BUNDLE/Contents/MacOS\"\n\")\nfile(RELATIVE_PATH BIN_TO_LIB_RELPATH ${NETGEN_BINARY_DIR} ${NETGEN_LIBRARY_DIR})\nelif(WIN32)\n    set(ngsld_flags \"${ngsld_flags} /LIBPATH:\\\"%NGSCXX_DIR%/${BIN_TO_LIB_RELPATH}\\\" nglib.lib ngcore.lib libngsolve.lib\" )\n    set(ngsld_header\n\"set PYTHON_LIBRARY=${NETGEN_PYTHON_LIBRARIES}\n\")\n    if(NETGEN_USE_PYTHON)\n      set(ngsld_header\n\"for /f  %%a in ('python -c \\\"import sys,os; print(os.path.join(sys.base_prefix, 'libs'))\\\"') do set PYTHON_LIBDIR=\\\"%%a\\\"\\n\")\n      set(ngsld_flags \"${ngsld_flags} /LIBPATH:\\\"%PYTHON_LIBDIR%\\\"\")\n    endif()\nelse()\n    set(ngsld_flags \"${ngsld_flags} -L\\$NGSCXX_DIR/${BIN_TO_LIB_RELPATH} -Wl,--rpath=\\$NGSCXX_DIR/${BIN_TO_LIB_RELPATH}\" )\n    set(ngscxx_header\n\"#!${BASH}\n${ngscxx_set_script_dir}\n\")\n    set(ngsld_header\n\"#!${BASH}\n${ngscxx_set_script_dir}\n\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Solving Eigenvalue Problem\nDESCRIPTION: This snippet uses an Arnoldi eigensolver to compute the resonances. It initializes a GridFunction with multiple vectors, provides the assembled bilinear forms, and specifies a shift for the eigenvalues.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nu = GridFunction(fes, multidim=50, name='resonances')\n\nwith TaskManager():\n    lam = ArnoldiSolver(a.mat, m.mat, fes.FreeDofs(), \n                        list(u.vecs), shift=400)\nDraw(u);\n```\n\n----------------------------------------\n\nTITLE: Getting Outer Normals\nDESCRIPTION: This snippet retrieves the outer normal vectors for each boundary segment using the GetOuterNormals method of the DomainTypeArray. The level set functions are used to compute the normals.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnormals = square.GetOuterNormals(level_sets_p1)\n```\n\n----------------------------------------\n\nTITLE: Print Timers\nDESCRIPTION: This snippet prints timers information for tasks that took more than 0.5 seconds, sorting them by time in descending order.  It focuses on identifying performance bottlenecks.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n%%px --target 1\nfor t in sorted(filter(lambda t:t['time']>0.5, Timers()), key=lambda t:t['time'], reverse=True):\n    print(t['name'], ':  ', t['time'])\n```\n\n----------------------------------------\n\nTITLE: Setting and Visualizing Grid Function\nDESCRIPTION: This Python code creates a GridFunction `gfu` on the finite element space `fes`. It initializes the GridFunction with the function x*y and then visualizes the GridFunction and the x-component of its gradient using the `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ngfu = GridFunction(fes)\ngfu.Set(x*y)\n\nDraw (gfu)\nDraw (grad(gfu)[0], mesh);\n```\n\n----------------------------------------\n\nTITLE: Installing Header Files with CMake\nDESCRIPTION: Installs specified header files to the directory defined by `NGSOLVE_INSTALL_DIR_INCLUDE`.  The installed files are marked as part of the `ngsolve_devel` component, which can be used to manage the installation of development-related files separately from runtime libraries.  This makes the header files available to other projects that depend on ngsolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/parallel/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( FILES\n        parallelngs.hpp parallelvector.hpp parallel_matrices.hpp dump.hpp\n        DESTINATION ${NGSOLVE_INSTALL_DIR_INCLUDE}\n        COMPONENT ngsolve_devel\n       )\n```\n\n----------------------------------------\n\nTITLE: Getting help for Solid2d in Python\nDESCRIPTION: This snippet demonstrates how to get help information about the `Solid2d` class using the `help()` function in Python.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.2-csg2d/csg2d.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nhelp(Solid2d)\n```\n\n----------------------------------------\n\nTITLE: Building pybind11 Stub Files (CMake)\nDESCRIPTION: Conditionally builds stub files for improved autocompletion support when `BUILD_STUB_FILES` is enabled. It first checks for the `pybind11-stubgen` package and its version using Python.  If present and up-to-date, it uses `pybind11-stubgen` to generate stub files for the `ngsolve` package and installs them. Requires Python and the `pybind11-stubgen` package.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/python/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(BUILD_STUB_FILES)\nexecute_process(COMMAND ${NETGEN_PYTHON_EXECUTABLE} -c \"from importlib.metadata import version; print(version('pybind11-stubgen'))\" OUTPUT_VARIABLE stubgen_version RESULT_VARIABLE pybind11_stubgen)\nif(pybind11_stubgen AND NOT ${pybind11_stubgen} EQUAL 0)\n  message(WARNING \"pybind11-stubgen not found, if you want to create stub files\nfor better autocompletion support install it with pip.\")\nelse()\n  if(stubgen_version LESS \"1.0\")\n    message(WARNING \"pybind11-stubgen version is too old, if you want to create stub files for better autocompletion support upgrade it with pip.\")\n  else()\n  message(\"-- Found pybind11-stubgen version: ${stubgen_version}\")\n  install(CODE \"\\\n  set(ENV{PYTHONPATH} ${CMAKE_INSTALL_PREFIX}/${NGSOLVE_INSTALL_DIR_PYTHON})\\n \\\n  execute_process(COMMAND ${Python3_EXECUTABLE} -m pybind11_stubgen --ignore-all-errors ngsolve)\\n \\\n  \")\n  install(CODE \"execute_process(COMMAND ${NETGEN_PYTHON_EXECUTABLE} -m pybind11_stubgen --ignore-all-errors ngsolve)\")\n  install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/../stubs/ngsolve/ DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/ COMPONENT ngsolve)\n  endif()\nendif()\nendif(BUILD_STUB_FILES)\n```\n\n----------------------------------------\n\nTITLE: Importing custom utilities in Python\nDESCRIPTION: Imports a custom module 'usrmeeting_jupyterstuff'. It is assumed this module contains utility functions for managing the parallel environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom usrmeeting_jupyterstuff import *\n```\n\n----------------------------------------\n\nTITLE: Solving Quadratic Eigenvalue Problem - Python\nDESCRIPTION: This snippet sets up the quadratic eigenvalue problem by computing matrices M1 and M2 from the assembled bilinear forms a, b, and c. It then uses the SOAR (Second Order Arnoldi) solver to compute the eigenvalues and eigenvectors of the QEP. `SOAR` is initialized with matrices `M1`, `M2`, and the number of desired eigenvalues.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ninv = a.mat.Inverse(freedofs=fes.FreeDofs(), inverse=\"sparsecholesky\")\nM1 = -inv@b.mat\nM2 = -inv@c.mat\nQ = SOAR(M1,M2, nr_eigs)\n```\n\n----------------------------------------\n\nTITLE: Start and Connect to MPI Cluster\nDESCRIPTION: This snippet starts an MPI cluster, connects to it, and sets the number of processors. It depends on the `usrmeeting_jupyterstuff` module for cluster management.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom usrmeeting_jupyterstuff import *\nnum_procs = '100'\nstop_cluster()\nstart_cluster(num_procs)\nconnect_cluster()\n```\n\n----------------------------------------\n\nTITLE: Defining Trial and Test Functions for Mixed Formulation\nDESCRIPTION: This code retrieves the trial and test functions from the mixed finite element space `fesm`. `sigma` and `u` are the trial functions, while `tau` and `v` are the test functions. These functions are used to define the bilinear and linear forms.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsigma, u = fesm.TrialFunction()\ntau, v = fesm.TestFunction()\n```\n\n----------------------------------------\n\nTITLE: DG Method with Skeleton Flag (Python)\nDESCRIPTION: This code demonstrates an alternative implementation of a DG method using the `skeleton` flag. This approach separates the boundary integral computation into internal (VOL) and boundary (BND) facets, potentially leading to more efficient computation as each edge is processed only once.  The `Other()` method is used to access values on the neighboring element, and the `SymbolicBFI` is used with `VOL` and `BND` specifiers.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/dg.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na += SymbolicBFI ( bn*IfPos(bn, u, u.Other()) * (v-v.Other()), VOL, skeleton=True)\n                a += SymbolicBFI ( bn*IfPos(bn, u, ubnd) * v, BND, skeleton=True)\n```\n\n----------------------------------------\n\nTITLE: Importing 2D Geometry Module\nDESCRIPTION: This code imports the `unit_square` function from the `netgen.geom2d` module. This function can be used to easily create a unit square geometry for meshing. It is a convenience function to avoid manually defining the square's boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import unit_square\n```\n\n----------------------------------------\n\nTITLE: Initializing 2-Stage SDIRK Method in Python\nDESCRIPTION: This snippet initializes a 2-stage, third-order SDIRK method using a Python class. It defines the Butcher tableau coefficients 'a', 'b', and 'c', including the parameter 'p', and the diagonal element `astar`. The 'a' matrix defines the stage coefficients, 'b' the weights, and 'c' the nodes.  The number of stages is set to 2.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.1-parabolic/parabolic.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass sdirk2: #order 3\n    p = (3 - sqrt(3))/6\n    stages = 2\n    a = [[p, 0], \n         [1 - 2*p, p]]\n    b = [1/2, 1/2]\n    c = [p, 1 - p]\n    astar = p\n    \n```\n\n----------------------------------------\n\nTITLE: Derivatives of Stress w.r.t. Internal States in ngsolve (Python)\nDESCRIPTION: This snippet calculates the partial derivatives of the stress with respect to the internal state variables (p, alpha, Lambda). These derivatives are reshaped and used in the algorithmic linearization of the bilinear form for consistent tangent stiffness computation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# Partial derivates w.r.t. internal states; need to be reshaped in order to put them together \n#  in a single expression below.\n\ndim_sigma = sigma.dim\ndp_sigma = sigma.Diff(gfp).Reshape((dim_sigma, gfp.dim))\ndalpha_sigma = sigma.Diff(gfalpha).Reshape((dim_sigma, 1))\ndLambda_sigma = sigma.Diff(gfLambda).Reshape((dim_sigma, 1))\n```\n\n----------------------------------------\n\nTITLE: Defining Load and Load Factor\nDESCRIPTION: This snippet defines the applied force and a load factor, which allows for applying the load in increments. The `loadfactor` is a Parameter object, which can be adjusted to control the load during the simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nforce = 450\n# For loadsteps\nloadfactor = Parameter(1)\n```\n\n----------------------------------------\n\nTITLE: Creating a Jacobi Preconditioner - Python\nDESCRIPTION: This creates a Jacobi preconditioner for the given bilinear form 'a'. It inverts only the unconstrained diagonal elements and fills the remaining values with zeros, effectively handling boundary constraints during preconditioning.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_dirichlet.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nc = Preconditioner(a, \"local\")\n```\n\n----------------------------------------\n\nTITLE: Generating non-closed surfaces using AddSurface\nDESCRIPTION: This snippet demonstrates how to create non-closed surface meshes by using the `AddSurface` method of the CSGeometry class.  A finite volume geometry acts as the base, and the surface geometry is automatically cut with it.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ngeo       = CSGeometry()\ncyl       = Cylinder(Pnt(0,0,0), Pnt(1,0,0), 1)\nbot       = Plane(Pnt(0,0,0), Vec(0,0,-1))\nright     = Plane( Pnt(3,0,0), Vec(1,0,0))\nleft      = Plane(Pnt(0,0,0), Vec(-1,0,0))\nfinitecyl = cyl * bot * left * right\n\ngeo.AddSurface(cyl, finitecyl)\nmesh = Mesh(geo.GenerateMesh(maxh=0.5))\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Printing Combined Domain Types - Python\nDESCRIPTION: This snippet iterates through combined domain types (`cdts`) such as NO, CDOM_NEG, CDOM_POS, etc. and prints their integer values, binary representation, and string representation. This helps understand how these combined flags are defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncdts = [NO,CDOM_NEG,CDOM_POS,UNCUT,CDOM_IF,HASNEG,HASPOS,ANY]\nfor dt in cdts: print(int(dt),\": {0:03b} ,\".format(int(dt)),str(dt) )\n```\n\n----------------------------------------\n\nTITLE: Solving Koiter Shell Model in Load Steps (Python)\nDESCRIPTION: This snippet demonstrates solving the Koiter shell model in multiple load steps.  The load parameter `par` is incremented gradually, and the solution is obtained for each step. The averaged normal vector `averednv` is updated at each step before solving. This incremental loading helps to converge to a stable solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nnumsteps=10\nwith TaskManager():\n    for steps in range(1,numsteps):\n        par.Set((steps+1)/numsteps)\n        print(\"Loadstep =\", steps+1, \", F/Fmax =\", (steps+1)/numsteps*100, \"%\")\n        \n        averednv.Set((1 - gfclamped) * cfnphys + gfclamped * nsurf,\n            definedon=mesh.Boundaries(\".*\"),\n            dual=True,\n        )\n        \n        (res,numit) = solvers.Newton(bfA, solution, inverse=\"sparsecholesky\", printing=False, maxerr=2e-10)\n```\n\n----------------------------------------\n\nTITLE: Solving the state equation\nDESCRIPTION: This code defines a function 'SolveStateEquation' that solves the state equation using a direct solver (LU decomposition). It assembles the right-hand side vector, applies the inverse of the stiffness matrix to it, and updates the grid function 'gfu' with the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef SolveStateEquation():\n    rhs = gfu.vec.CreateVector()\n    rhs.data = fstate.vec - a.mat * gfu.vec\n    update = gfu.vec.CreateVector()\n    update.data = a.mat.Inverse(fes.FreeDofs()) * rhs\n    gfu.vec.data += update\n```\n\n----------------------------------------\n\nTITLE: GLSL Shader Code - C\nDESCRIPTION: This is the part of the GLSL shader code where the `eval_function` is injected as `USER_FUNCTION`.  It shows how the user-defined function is integrated into the shader for altering the output function values based on position and normal vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#ifdef USER_FUNCTION\nvec3 userFunction( vec3 value, vec3 p, vec3 normal )\n{\n  return vec3(USER_FUNCTION);\n}\n#endif // USER_FUNCTION\n```\n\n----------------------------------------\n\nTITLE: Checking for Header Files\nDESCRIPTION: Includes the CheckIncludeFiles module and uses it to check for the existence of the dlfcn.h header file, defining HAVE_DLFCN_H if found.  It then includes the CheckCXXSymbolExists module and uses it to check for the existence of the abi::__cxa_demangle symbol in cxxabi.h, defining HAVE_CXA_DEMANGLE if found.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_14\n\nLANGUAGE: cmake\nCODE:\n```\ninclude (CheckIncludeFiles)\ncheck_include_files (dlfcn.h HAVE_DLFCN_H)\ninclude (CheckCXXSymbolExists)\ncheck_cxx_symbol_exists ( abi::__cxa_demangle \"cxxabi.h\" HAVE_CXA_DEMANGLE )\n```\n\n----------------------------------------\n\nTITLE: Create Symbolic Link for mylittlengs\nDESCRIPTION: Creates a symbolic link to the `mylittlengs` source directory. This is done using `add_custom_target` and the `CMAKE_COMMAND` to execute a create_symlink command. This target depends on the `mylittlengs` external project. This snippet is conditionally executed based on `NETGEN_USE_PYTHON` and the absence of `WIN32`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(link_mylittlengs\n        COMMAND ${CMAKE_COMMAND} -E create_symlink \"${source_dir}\" \"${CMAKE_CURRENT_SOURCE_DIR}/mylittlengs\"\n        )\n      add_dependencies(link_mylittlengs mylittlengs)\n```\n\n----------------------------------------\n\nTITLE: Setting Mesh Parameters in Python\nDESCRIPTION: This code snippet defines the parameters for the mesh generation process. The `quads` variable determines whether to use quadrilaterals or triangles, and the `N` variable specifies the number of subdivisions along each axis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nquads = True\nN=5\n```\n\n----------------------------------------\n\nTITLE: Setting up Reissner-Mindlin Plate Parameters in NGSolve\nDESCRIPTION: This snippet defines the parameters for the Reissner-Mindlin plate problem. It sets up material properties like Young's modulus (E), Poisson's ratio (nu), and shear correction factor (k), along with geometric parameters such as thickness (t) and radius (R).  It also defines the force (fz) and the polynomial order for the finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nE, nu, k = 10.92, 0.3, 5/6\nmu  = E/(2*(1+nu))\nlam = E*nu/(1-nu**2)\n#shearing modulus\nG = E/(2*(1+nu))\n#thickness, shear locking with t=0.1\nt = 0.1\nR = 5\n#force\nfz = 1\n\norder = 1\n```\n\n----------------------------------------\n\nTITLE: Initializing FETI-DP Problem in NGSolve Python\nDESCRIPTION: Initializes the mesh, finite element space, and assembles the required matrices for the FETI-DP solver. Uses the previously defined `load_mesh`, `setup_space` and `setup_FETIDP` functions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n%%px\ncomm = MPI_Init()\nmesh = load_mesh(nref=1)\nfes, a, f = setup_space(mesh, order=2)\nA_dp, A_dp_inv, F, Fhat, nFhat, B, scaledA, scaledBT = setup_FETIDP(fes, a)\n```\n\n----------------------------------------\n\nTITLE: Setting Test Timeout\nDESCRIPTION: Sets the test timeout value based on the build type.  Debug builds have a longer timeout.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_42\n\nLANGUAGE: cmake\nCODE:\n```\nif(${CMAKE_BUILD_TYPE} STREQUAL \"Debug\" OR ${CMAKE_BUILD_TYPE} STREQUAL \"DEBUG\")\n  set(NGS_TEST_TIMEOUT 300)\nelse()\n  set(NGS_TEST_TIMEOUT 60)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Launching Netgen GUI on Ubuntu/Windows\nDESCRIPTION: This code snippet shows how to launch the Netgen GUI from the command prompt on Ubuntu and Windows. No dependencies are needed. It simply invokes the `netgen` command.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/gettingstarted.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnetgen\n```\n\n----------------------------------------\n\nTITLE: Configuring the Build with CMake (Bash)\nDESCRIPTION: This script changes the directory to the build directory and calls CMake to configure the build process. It sets the installation prefix and points to the source directory. The `CMAKE_INSTALL_PREFIX` variable specifies where the installed files will be placed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncd $BASEDIR/ngsolve-build\ncmake -DCMAKE_INSTALL_PREFIX=${BASEDIR}/ngsolve-install ${BASEDIR}/ngsolve-src\n```\n\n----------------------------------------\n\nTITLE: Drawing a Sub-part of the Solution (Python)\nDESCRIPTION: This code snippet demonstrates how to draw only a part of the solution which is stored on process `n`.  Requires the ngsolve.webgui and a `GridFunction gfu` distributed among the MPI processes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nDraw (gfu[3]);\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Definitions & Flags (CMake)\nDESCRIPTION: This snippet retrieves compiler definitions and options from the `ngcore` target, then iterates through the definitions and constructs compiler flags for different operating systems. It also handles CMAKE_CXX_FLAGS and adds compile options.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_44\n\nLANGUAGE: CMake\nCODE:\n```\nget_target_property(ngcore_compile_definitions ngcore INTERFACE_COMPILE_DEFINITIONS)\nget_property(have_options TARGET ngcore PROPERTY INTERFACE_COMPILE_OPTIONS SET)\nif(have_options)\n    get_target_property(ngcore_compile_options ngcore INTERFACE_COMPILE_OPTIONS)\nendif(have_options)\nset(ngscxx_compile_definitions ${NGSOLVE_COMPILE_DEFINITIONS} ${ngcore_compile_definitions})\n\nforeach( d ${ngscxx_compile_definitions} )\n    if(WIN32)\n      if(NOT ${d} STREQUAL \"NGS_EXPORTS\")\n        set( ngscxx_define_flags \"${ngscxx_define_flags} /D${d}\" )\n      endif()\n    else()\n      set( ngscxx_define_flags \"${ngscxx_define_flags} -D${d}\" )\n    endif()\nendforeach()\n\nstring(TOUPPER \"CMAKE_CXX_FLAGS_${CMAKE_BUILD_TYPE}\" build_type_name)\nset(ngscxx_flags \"${${build_type_name}} ${CMAKE_CXX_FLAGS} ${ngscxx_define_flags}\")\n\nif(WIN32)\n  string(REPLACE \"/Zi \" \" \" ngscxx_flags ${ngscxx_flags})\nendif(WIN32)\n\n\nforeach( opt ${NGSOLVE_COMPILE_OPTIONS} ${ngcore_compile_options} )\n    set(ngscxx_flags \"${ngscxx_flags} ${opt}\")\nendforeach()\nif(NOT WIN32)\n  set(ngscxx_flags \"${ngscxx_flags} -fPIC\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting PYTHONPATH for Python Scripts (Bash)\nDESCRIPTION: This command sets the `PYTHONPATH` environment variable so that Python can find the Netgen/NGSolve modules. It calculates the relative path to the platform-specific library directory and adds it to the `PYTHONPATH`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nexport PYTHONPATH=$NETGENDIR/../`python3 -c \"import os.path, sysconfig;print(os.path.relpath(sysconfig.get_path('platlib'), sysconfig.get_path('data')))\"`\n```\n\n----------------------------------------\n\nTITLE: Setting up Block-Matrices for FETI-DP Python\nDESCRIPTION: Sets up the block matrices for the FETI-DP system and its preconditioner. Includes creating the system matrix (M), two versions of the preconditioner (Mhat and Mhat2), and defining a custom matrix class (Mhat_v2) for efficient preconditioning.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n%%px\nM = BlockMatrix([[A_dp, B.T], \\\n                 [B, None]])\nMhat = BlockMatrix([[A_dp_inv, None], \\\n                    [Fhat @ B @ A_dp_inv, nFhat]])\nclass Mhat_v2(BaseMatrix):\n    def __init__(self, Ahat, B, Fhat):\n        super(Mhat_v2, self).__init__()\n        self.Ahat = Ahat\n        self.B = B\n        self.Fhat = Fhat\n        self.hv = Fhat.CreateColVector()\n    def Mult(self, x, y):\n        y[0].data = self.Ahat * x[0]\n        self.hv.data = x[1] - self.B * y[0]\n        y[1].data = self.Fhat * self.hv\n    def CreateRowVector(self):\n        return BlockVector([self.Ahat.CreateRowVector(), self.Fhat.CreateRowVector()])\n    def CreateColVector(self):\n        return BlockVector([self.Ahat.CreateRowVector(), self.Fhat.CreateRowVector()])\nMhat2 = Mhat_v2(A_dp_inv, B, Fhat)\n```\n\n----------------------------------------\n\nTITLE: Adding Boundary Elements in 2D\nDESCRIPTION: This code adds boundary elements (`Element1D`) to the mesh, representing the edges of the square domain. It iterates through the top, bottom, left, and right edges, creating `Element1D` objects using the `PointId` objects in the `pnums` array.  Boundary conditions are assigned using an index.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# horizontal boundaries\nfor i in range(N):\n   ngmesh.Add(Element1D([pnums[N + i * (N + 1)],\n                       pnums[N + (i + 1) * (N + 1)]], index=1))\n   ngmesh.Add(Element1D([pnums[0 + i * (N + 1)], pnums[0 + (i + 1) * (N + 1)]], index=1))\n\n# vertical boundaries\nfor i in range(N):\n   ngmesh.Add(Element1D([pnums[i], pnums[i + 1]], index=2))\n   ngmesh.Add(Element1D([pnums[i + N * (N + 1)], pnums[i + 1 + N * (N + 1)]], index=2))\n```\n\n----------------------------------------\n\nTITLE: Generating Geometry and Mesh for Naghdi Shell Model (Python)\nDESCRIPTION: This snippet uses the Netgen CSG (Constructive Solid Geometry) module to create a cylindrical geometry and generate a mesh. It defines boundary conditions, curves the mesh for higher-order elements, and visualizes it using the Draw function. The `maxh` parameter controls the maximum mesh element size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\nfrom ngsolve import *\nfrom ngsolve.internal import visoptions\nfrom ngsolve.webgui import Draw\n\norder = 3\n\ngeo = CSGeometry()\ncyl   = Cylinder(Pnt(0,0,0),Pnt(1,0,0),0.4).bc(\"cyl\")\nleft  = Plane(Pnt(0,0,0), Vec(-1,0,0))\nright = Plane(Pnt(1,0,0), Vec(1,0,0))\nfinitecyl = cyl * left * right\ngeo.AddSurface(cyl, finitecyl)\ngeo.NameEdge(cyl,left, \"left\")\ngeo.NameEdge(cyl,right, \"right\")\n\nmesh = Mesh(geo.GenerateMesh(maxh=0.2))\nmesh.Curve(order)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Geometry using OCC\nDESCRIPTION: This snippet defines a 2D geometry using the OCC (Open Cascade) module within Netgen. It creates a rectangle and subtracts two smaller rectangles to represent electrodes.  The edges of the smaller rectangles are named 'el1' and 'el2'. The final geometry is then created using OCCGeometry with dim=2.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.1-ngspice/NGSpiceNGSolve.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nouter = MoveTo(0,0).RectangleC(0.1,0.1).Face()\nel1 = MoveTo(0,0.002).RectangleC(0.03,0.001).Face()\nel2 = MoveTo(0,-0.002).RectangleC(0.03,0.001).Face()\nel1.edges.name=\"el1\"\nel2.edges.name=\"el2\"\n\ndom = outer-el1-el2\ngeom = OCCGeometry(dom, dim=2)\n```\n\n----------------------------------------\n\nTITLE: Get Edge Information - Python\nDESCRIPTION: This snippet retrieves the first edge of a solid and prints its type, start point, and end point. It demonstrates how to access edges and retrieve geometric information associated with edges.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\ne = solid.edges[0]\nprint (\"I am a\", e.type)\nprint (\"with startpoint\", e.start, \"and endpoint\", e.end)   \n```\n\n----------------------------------------\n\nTITLE: Adding Boundary Term to Bilinear Form (Legacy)\nDESCRIPTION: This code snippet adds a boundary term to the bilinear form `c2`, considering an `IfPos` condition based on the dot product of `b` and `n`. It utilizes trial functions `uT` and `uF`, and test function `vT` from respective spaces. The integration is performed over the element boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nc2 += b*n * IfPos(b*n, uT, uF-uT) * vT * dx(element_boundary=True)\n```\n\n----------------------------------------\n\nTITLE: Defining Vertex Dofs\nDESCRIPTION: This function identifies all free degrees of freedom associated with vertices in the mesh. It iterates through each vertex, retrieves the corresponding degrees of freedom using `fes.GetDofNrs(v)`, and sets the corresponding bit in the `vertexdofs` bit array to `True`. The bit array is then intersected with the `fes.FreeDofs()` bit array to ensure that only free degrees of freedom are selected.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef VertexDofs(mesh, fes):\n    vertexdofs = BitArray(fes.ndof)\n    vertexdofs[:] = False\n    for v in mesh.vertices:\n        for d in fes.GetDofNrs(v):\n            vertexdofs[d] = True\n    vertexdofs &= fes.FreeDofs()\n    return vertexdofs\n\nvertexdofs = VertexDofs(mesh, fes)\nprint(vertexdofs)   # bit array, printed 50 chars/line\n```\n\n----------------------------------------\n\nTITLE: Handling Superbuild Logic\nDESCRIPTION: This section handles the superbuild logic. If USE_SUPERBUILD is enabled, it defines the NGSuite project, sets the CMAKE_INSTALL_PREFIX to the default install directory, includes the SuperBuild.cmake and package.cmake scripts, includes CPack, and then returns to prevent further processing. Otherwise, it defines the NGSolve project and sets the CMAKE_INSTALL_PREFIX similarly.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nif (USE_SUPERBUILD)\n  project (NGSuite)\n  if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n    set(CMAKE_INSTALL_PREFIX \"${INSTALL_DIR_DEFAULT}\" CACHE PATH \"Install directory\" FORCE)\n  endif()\n  # execute the superbuild (this script will be invoked again without the\n  # USE_SUPERBUILD option this time)\n  option( BUILD_UMFPACK \"Download and build UMFPACK automatically\" ON )\n  include (cmake/SuperBuild.cmake)\n  include (cmake/package.cmake)\n  include(CPack)\n  return()                      # stop processing this file further\nelse()\n  project(NGSolve)\n  if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n    set(CMAKE_INSTALL_PREFIX \"${INSTALL_DIR_DEFAULT}\" CACHE PATH \"Install directory\" FORCE)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Running the Adaptive Loop\nDESCRIPTION: This code implements an adaptive loop that iteratively solves the boundary value problem, calculates the error, refines the mesh, and visualizes the solution. The loop continues until the number of degrees of freedom exceeds a specified threshold.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nlevel = 0 \nwhile fes.ndof < 50000:  \n    SolveBVP()\n    level = level + 1\n    if level%5 == 0:\n        print('adaptive step #', level)\n        Draw(gfu)\n    CalcError()\n    mesh.Refine()\n```\n\n----------------------------------------\n\nTITLE: Target Link Libraries Configuration\nDESCRIPTION: Configures the libraries that `ngstd` links against. It links against `netgen_libs`, MPI libraries (`${MPI_CXX_LIBRARIES}`), `netgen_python` (for build interface), and LAPACK libraries (`${LAPACK_CMAKE_LINK_INTERFACE}`, `ngs_lapack`).  The `$<>` expressions are generator expressions that allow for conditional linking based on build configuration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(ngstd PUBLIC netgen_libs)\ntarget_link_libraries(ngstd PUBLIC ${MPI_CXX_LIBRARIES} PRIVATE \"$<BUILD_INTERFACE:netgen_python>\")\ntarget_link_libraries(ngstd ${LAPACK_CMAKE_LINK_INTERFACE} \"$<BUILD_INTERFACE:ngs_lapack>\")\n```\n\n----------------------------------------\n\nTITLE: Configuring NGSolve with CMake\nDESCRIPTION: This command creates a 'build' directory, navigates into it, and uses CMake to configure the NGSolve project from the source files in the '../src' directory.  It sets the installation prefix to 'BASEDIR/install', which determines where the compiled files will be installed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installwindows.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir build\ncd build\ncmake \"../src\" -DCMAKE_INSTALL_PREFIX=\"BASEDIR/install\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Periodic Cake Geometry\nDESCRIPTION: This code creates a 3D cake geometry with periodic boundary conditions in the azimuthal direction. It uses the WorkPlane and Revolve operations from Netgen OCC to generate the shape and then identifies the faces corresponding to the periodic boundaries using the Identify function with a rotation transformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/periodicity.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nf = WorkPlane(Axes((0,0,0), Y,X)).MoveTo(0.3,0).Rectangle(3,1).Face()\nax = Axis ((0,0,0), Z)\ncake = f.Revolve(ax, 30)\ncake.faces.Min(Y).name=\"f1\"\ncake.faces.Max(Y-0.5*X).name=\"f2\"\ncake.faces.Min(Z).name=\"bot\"\n\ncake.faces[\"f1\"][0].Identify(cake.faces[\"f2\"][0], \"id\",\n                            trafo=Rotation(ax, 30))\nDraw (cake);\n```\n\n----------------------------------------\n\nTITLE: Defining and Meshing a Cube using Planes in Netgen CSG (Python)\nDESCRIPTION: This code defines a cube using six planes, then creates a CSGeometry object, adds the cube to it, generates a mesh, and saves the mesh to a file. It demonstrates the use of the Plane primitive and boolean multiplication for intersection.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_3d_geometries.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import *\n\nleft  = Plane (Pnt(0,0,0), Vec(-1,0,0) )\nright = Plane (Pnt(1,1,1), Vec( 1,0,0) )\nfront = Plane (Pnt(0,0,0), Vec(0,-1,0) )\nback  = Plane (Pnt(1,1,1), Vec(0, 1,0) )\nbot   = Plane (Pnt(0,0,0), Vec(0,0,-1) )\ntop   = Plane (Pnt(1,1,1), Vec(0,0, 1) )\n   \ncube = left * right * front * back * bot * top\ngeo = CSGeometry()\ngeo.Add (cube)\n   \nmesh = geo.GenerateMesh(maxh=0.1)\nmesh.Save(\"cube.vol\")\n```\n\n----------------------------------------\n\nTITLE: Including Catch Unit Tests\nDESCRIPTION: If unit tests are enabled, this snippet includes the catch.cmake script located in the external_projects directory. This script likely defines the necessary functions and macros to integrate the Catch2 testing framework into the project.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_20\n\nLANGUAGE: cmake\nCODE:\n```\nif(ENABLE_UNIT_TESTS)\n  include(${CMAKE_CURRENT_LIST_DIR}/cmake/external_projects/catch.cmake)\nendif(ENABLE_UNIT_TESTS)\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Variables - Bash\nDESCRIPTION: This snippet demonstrates how to set the CC and CXX environment variables to specify the path to the clang compiler. This is necessary if the compiler is not in the default location/path.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nexport CC=<MyPathtoClang>\nexport CXX=<MyPathtoClang++>\n```\n\n----------------------------------------\n\nTITLE: Target Compile Definitions Configuration\nDESCRIPTION: Sets public and private compile definitions for the `ngstd` library.  Public definitions are visible to other libraries that link against `ngstd`, while private definitions are only visible within `ngstd` itself.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_definitions(ngstd PUBLIC ${NGSOLVE_COMPILE_DEFINITIONS})\ntarget_compile_definitions(ngstd PRIVATE ${NGSOLVE_COMPILE_DEFINITIONS_PRIVATE})\n```\n\n----------------------------------------\n\nTITLE: Solving Navier-Stokes with Very Low Viscosity\nDESCRIPTION: This code attempts to solve the Navier-Stokes equations with a very low viscosity value, further increasing the Reynolds number and likely causing the Newton solver to diverge. Multidimensional output is requested.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nnu.Set(0.001)\nSolveAndVisualize()\n```\n\n----------------------------------------\n\nTITLE: HDiv Aggregation\nDESCRIPTION: This snippet demonstrates the basis aggregation and visualization for an HDiv finite element space (order=1).  It demonstrates the application of the aggregation technique to vector-valued spaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfes = HDiv(mesh, order=1)\nShowPattern(AggEmbedding(EA, fes))\ngfshow = ExtendedBasisFunctionsAsMultiDim(EA,fes)\nDraw (gfshow, mesh, interpolate_multidim=False, animate=False, autoscale=True);\n```\n\n----------------------------------------\n\nTITLE: Install Header File\nDESCRIPTION: This snippet installs the `solve.hpp` header file into the include directory for NGSolve development. The header file is placed in `${NGSOLVE_INSTALL_DIR_INCLUDE}` and marked as a component for development.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/solve/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( FILES solve.hpp DESTINATION ${NGSOLVE_INSTALL_DIR_INCLUDE} COMPONENT ngsolve_devel )\n```\n\n----------------------------------------\n\nTITLE: Printing Vector Dimensions\nDESCRIPTION: This snippet prints the dimensions of the grid function vector and its local component. It accesses the vector using `gfu.vec` and `gfu.vec.local_vec`, and prints their lengths. It also prints the local and global number of DOFs of the finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\nprint('length of vector:    ', len(gfu.vec))\nprint('length of local vec: ', len(gfu.vec.local_vec))\nprint('dim local fes:       ', fes.ndof)\nprint('dim global fes:      ', fes.ndofglobal)\n```\n\n----------------------------------------\n\nTITLE: Creating Build and Install Directories (Bash)\nDESCRIPTION: This script creates two directories: one for the build process and one for the final installation. The `BASEDIR` variable defines the parent directory for both.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir $BASEDIR/ngsolve-build\nmkdir $BASEDIR/ngsolve-install\n```\n\n----------------------------------------\n\nTITLE: Include Directories Configuration\nDESCRIPTION: Adds the current source directory to the include directories list before other directories. This ensures that local headers are found first during compilation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Setting up Finite Element Spaces for TDNNS in NGSolve\nDESCRIPTION: This snippet defines the finite element spaces for the TDNNS method. It uses HCurl for the rotation (beta), HDivDiv for the stress tensor (sigma), and H1 for the vertical deflection (u). The dirichlet boundary conditions are set depending on whether the plate is clamped or simply supported. A mixed FESpace is then created.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\norder=1\nif clamped:\n    fesB = HCurl(mesh, order=order-1, dirichlet=\"circ\", autoupdate=True)\n    fesS = HDivDiv(mesh, order=order-1, dirichlet=\"\", autoupdate=True)  \nelse:\n    fesB = HCurl(mesh, order=order-1)\n    fesS = HDivDiv(mesh, order=order-1, dirichlet=\"circ\", autoupdate=True)\nfesW = H1(mesh, order=order, dirichlet=\"circ\", autoupdate=True)\n\nfes = FESpace( [fesW, fesB, fesS], autoupdate=True ) \n(u,beta,sigma), (du,dbeta,dsigma) = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Installing the Built Project (Bash)\nDESCRIPTION: This command installs the compiled binaries and related files to the location specified by `CMAKE_INSTALL_PREFIX` during the CMake configuration step.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Importing ngsxfem Functionality - Python\nDESCRIPTION: This snippet imports the basic functionality of the `ngsxfem` package, providing essential tools for working with unfitted finite element methods.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# basic xfem functionality\nfrom xfem import *\n```\n\n----------------------------------------\n\nTITLE: Integrating Error for Element-wise Error Estimation\nDESCRIPTION: This snippet integrates the error over each element in the mesh to compute the element-wise error estimator. The `element_wise=True` option in the `Integrate` function ensures that the integration is performed for each element individually, and the results are stored in the `eta2` variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\neta2 = Integrate(err, mesh, VOL, element_wise=True)\nprint(eta2)\n```\n\n----------------------------------------\n\nTITLE: Vector Creation and Linear Form Definition in NGSolve\nDESCRIPTION: This snippet creates vectors for storing data and defines linear forms for post-processing internal states using NGSolve. The vectors `w` and `rhs` are created using `gfu.vec.CreateVector()`. Linear forms `fd` and `fda` are defined using `LinearForm` and `InnerProduct` for specific functions and integration rules.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# A set of functions/vectors for keeping data\nw = gfu.vec.CreateVector()\nrhs = gfu.vec.CreateVector()\n\n# Postprocess internal states\nfd = LinearForm(InnerProduct(gfp, qd)*irs_dx)\nfda = LinearForm(InnerProduct(gfalpha_k, qda)*irs_dx)\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation with Block Smoother on CUDA\nDESCRIPTION: This snippet extends the previous example by performing the computation on the CUDA device using device matrices for the bilinear form and the preconditioner. It measures the time taken for the solution process on the device.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nadev = a.mat.CreateDeviceMatrix()\npredev = pre.CreateDeviceMatrix()\nfdev = f.vec.CreateDeviceVector()\n\nwith TaskManager(): \n    inv = CGSolver(adev, predev, maxsteps=2000, printrates=False)\n    ts = time()\n    gfu.vec.data = (inv * fdev).Evaluate() \n    te = time()\n    print (\"iterations =\", inv.GetSteps(), \"time =\", te-ts) \n```\n\n----------------------------------------\n\nTITLE: Selecting Facets to Draw - Python\nDESCRIPTION: This snippet defines a function `SelectFacetsToDraw` that retrieves facets with specified neighbor types and then draws the elements surrounding those facets. This allows visualizing the elements near specific types of interfaces (e.g., facets between CDOM_IF and CDOM_NEG).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef SelectFacetsToDraw(dt1,dt2): \n    ba_facets = GetFacetsWithNeighborTypes(mesh,a=ci.GetElementsOfType(dt1), b=ci.GetElementsOfType(dt2))\n    ba_surround_facets = GetElementsWithNeighborFacets(mesh,ba_facets)\n    Draw(BitArrayCF(ba_surround_facets), mesh, \"surrounding_facets\")    \n```\n\n----------------------------------------\n\nTITLE: Defining a finite element space with Dirichlet boundary conditions\nDESCRIPTION: This snippet defines a finite element space and sets Dirichlet boundary conditions on the 'b', 'l', and 'r' boundaries. This is achieved through the `dirichlet` parameter when defining the space. It sets up trial and test functions and a `GridFunction` for the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=3, dirichlet=\"b|l|r\")\nu, v = fes.TnT()\ngfu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve modules\nDESCRIPTION: This snippet imports the necessary modules from the NGSolve library, including core functionality and visualization tools.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.7-hybrid/hybrid.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\n```\n\n----------------------------------------\n\nTITLE: Solving the BVP for TDNNS in NGSolve\nDESCRIPTION: This snippet defines a function, SolveBVP, to solve the boundary value problem (BVP) for the TDNNS method. It updates the finite element space and grid function, assembles the bilinear and linear forms, and uses a direct inverse to solve the linear system. The solution is then stored in the grid function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef SolveBVP():\n    fes.Update()\n    gfsol.Update()\n    with TaskManager():\n        a.Assemble()\n        f.Assemble()\n        inv = a.mat.Inverse(fes.FreeDofs())\n        gfsol.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Visualizing Results of 3D Contact Simulation - Python\nDESCRIPTION: This code visualizes the solution of the 3D contact problem. It displays the deformed shape and the first component of the symmetric gradient of the displacement field.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfu, mesh, deformation=True);\nDraw (Sym(Grad(gfu))[0,0], mesh, draw_surf=False);\n```\n\n----------------------------------------\n\nTITLE: Starting and Connecting to Cluster\nDESCRIPTION: This snippet starts a cluster with the specified number of processes (`num_procs`) and then connects to it. It relies on functions (`start_cluster`, `connect_cluster`) from the `usrmeeting_jupyterstuff` module.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstart_cluster(num_procs)\nconnect_cluster()\n```\n\n----------------------------------------\n\nTITLE: Handling Netgen GUI Configuration\nDESCRIPTION: Configures settings for the Netgen GUI, if it is enabled (`NETGEN_USE_GUI`). It configures and installs the `ngsolve.tcl` file and sets the destination directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_27\n\nLANGUAGE: cmake\nCODE:\n```\nfile(RELATIVE_PATH BIN_TO_LIB_RELPATH ${NETGEN_BINARY_DIR} ${NETGEN_LIBRARY_DIR})\nif(NETGEN_USE_GUI)\n  if(NOT NGSOLVE_INSTALL_DIR_TCL)\n      set(NGSOLVE_INSTALL_DIR_TCL ${NGSOLVE_INSTALL_DIR_BIN})\n  endif()\n  configure_file(${CMAKE_CURRENT_SOURCE_DIR}/ngsolve.tcl\n    ${CMAKE_CURRENT_BINARY_DIR}/ngsolve.tcl @ONLY)\n\n  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/ngsolve.tcl DESTINATION ${NGSOLVE_INSTALL_DIR_TCL} COMPONENT ngsolve)\nendif(NETGEN_USE_GUI)\n```\n\n----------------------------------------\n\nTITLE: Installation Configuration\nDESCRIPTION: Configures the installation of the `ngstd` library to the specified installation directory (`${ngs_install_dir}`).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( TARGETS ngstd ${ngs_install_dir} )\n```\n\n----------------------------------------\n\nTITLE: Installing Python Demos\nDESCRIPTION: This CMake snippet installs various Python demo files into specific directories within the NGSolve Python installation. It utilizes the `install` command with the `FILES` argument to specify the files to be installed and the `DESTINATION` argument to define the target directory.  The `COMPONENT` argument specifies the component to which the files belong.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(FILES __init__.py DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/demos COMPONENT ngsolve_devel)\ninstall(FILES\n        __init__.py\n        poisson.py adaptive.py cmagnet.py navierstokes.py\n        elasticity.py poisson.ipynb\n        DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/demos/intro\n        COMPONENT ngsolve_devel\n       )\n\ninstall(FILES\n        __init__.py\n        mixed.py hybrid_dg.py nonlin.py taskmanager.py\n        pickling.py pml.py DG/timeDG-skeleton.py DG/timeDGwave.py\n        DG/timeDG.py DG/timeDGlap.py hdivdiv/hhj.py hdivdiv/tdnns.py\n        DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/demos/howto\n        COMPONENT ngsolve_devel\n       )\n\ninstall(FILES\n        __init__.py\n        TensorProduct/tp_dg_1d_1d.py\n        TensorProduct/tp_dg_2d_1d.py TensorProduct/tp_dg_1d_2d.py\n        TensorProduct/tp_dg_2d_2d.py\n        DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/demos/TensorProduct\n        COMPONENT ngsolve_devel\n       )\n```\n\n----------------------------------------\n\nTITLE: Sourcing Bashrc - Bash\nDESCRIPTION: This snippet shows how to apply changes made to the `.bashrc` file by sourcing it. This reloads the shell environment so that new or modified environment variables take effect.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsource .bashrc\n```\n\n----------------------------------------\n\nTITLE: Installing OpenCascade Library on Ubuntu (bash)\nDESCRIPTION: This snippet demonstrates how to install the OpenCascade library on Ubuntu using the apt package manager. It adds the 'universe' repository, updates the package list, and installs the required libocct-data-exchange-dev, libocct-draw-dev, and occt-misc packages. This is necessary for enabling OpenCascade support in Netgen/NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/cmakeoptions.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-add-repository universe\nsudo apt-get update\nsudo apt-get install libocct-data-exchange-dev\n                       libocct-draw-dev occt-misc\n```\n\n----------------------------------------\n\nTITLE: Setting Default Installation Directory\nDESCRIPTION: Sets the default installation directory based on the operating system.  On macOS, it defaults to /Applications/Netgen.app.  On Windows, it defaults to C:/netgen.  On other systems, it defaults to /opt/netgen.  The INSTALL_DIR_DEFAULT variable is then set to this platform-specific default path.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif(APPLE)\n  set(INSTALL_DIR_DEFAULT /Applications/Netgen.app)\nelse(APPLE)\n  if(WIN32)\n    set(INSTALL_DIR_DEFAULT \"C:/netgen\")\n  else(WIN32)\n    set(INSTALL_DIR_DEFAULT /opt/netgen)\n  endif(WIN32)\nendif(APPLE)\n```\n\n----------------------------------------\n\nTITLE: Starting and Connecting to MPI Cluster\nDESCRIPTION: This snippet starts an MPI cluster with a specified number of processes and connects to it. It calls the `start_cluster()` function with the `num_procs` variable as an argument.  It also calls the `connect_cluster()` function to establish the connection.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nstart_cluster(num_procs)\nconnect_cluster()\n```\n\n----------------------------------------\n\nTITLE: Python Integration\nDESCRIPTION: This snippet handles Python integration for NGSolve. It creates a shared library `ngslib` from `ngspy.cpp`, sets its suffix to `.so`, links against Netgen's Python interface and LAPACK. On Windows, the suffix is changed to `.pyd`. It links against `ngsolve` and other necessary libraries. An install RPATH is set and then the library is installed to the python packages directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/solve/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(NETGEN_USE_PYTHON)\n    add_library( ngslib SHARED ngspy.cpp )\n\n    set_target_properties(ngslib PROPERTIES SUFFIX \".so\")\n    set_target_properties(ngslib PROPERTIES PREFIX \"\")\n    target_link_libraries(ngslib PRIVATE \"$<BUILD_INTERFACE:netgen_python>\")\n    target_link_libraries(ngslib ${LAPACK_CMAKE_LINK_INTERFACE} \"$<BUILD_INTERFACE:ngs_lapack>\")\n\n    target_link_libraries(ngslib PUBLIC ngsolve)\n\n    if(WIN32)\n        set_target_properties( ngslib PROPERTIES SUFFIX \".pyd\" )\n    else(WIN32)\n        target_link_libraries(ngslib PRIVATE ngstd ngbla ngla ngfem ngcomp)\n    endif(WIN32)\n\n    set_target_properties(ngslib PROPERTIES INSTALL_RPATH \"${NETGEN_RPATH_TOKEN}/../${NETGEN_PYTHON_RPATH}\")\n    install(TARGETS ngslib DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve COMPONENT ngsolve)\nendif(NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: Installing/Upgrading Jupyter on Windows\nDESCRIPTION: This command installs or upgrades Jupyter and ipykernel using the pip package manager on Windows systems. The upgrade is necessary to address a known bug in ipykernel. Requires pip to be installed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/usejupyter.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade jupyter\npip install --upgrade ipykernel\n```\n\n----------------------------------------\n\nTITLE: Set Include Directories\nDESCRIPTION: This snippet adds the current source directory to the include directories, making header files in the current directory available for compilation. The `BEFORE` keyword ensures it's added at the beginning of the list.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/solve/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules - Python\nDESCRIPTION: This snippet imports the necessary modules from netgen, ngsolve, and xfem for defining geometries, performing finite element calculations, and visualizing results. It also imports the constant pi from the math module.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# basic geometry features (for the background mesh)\nfrom netgen.geom2d import SplineGeometry\n# ngsolve\nfrom ngsolve import *\n# basic xfem functionality\nfrom xfem import *\n# for isoparametric mapping\nfrom xfem.lsetcurv import *\n# visualisation\nfrom ngsolve.webgui import *\n# the contant pi\nfrom math import pi\n```\n\n----------------------------------------\n\nTITLE: Assembling forms and creating setup\nDESCRIPTION: This code snippet initializes the finite element setup by calling the `Setup` function and then assembles the bilinear form `a` and linear form `f`. These assembled forms are essential for solving the finite element problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh, fes, a, f, gfu = Setup(h=0.1, p=3)\na.Assemble()\nf.Assemble();\n```\n\n----------------------------------------\n\nTITLE: Overwriting the Mult Method\nDESCRIPTION: This code modifies the `Mult` method of the `PropagateConvection` class to use the `ConvertL2Operator` for the projection between HDG and L2 spaces. This simplifies the code and potentially improves performance.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef NewMult(self, x, y):\n    self.vecL2.data = HDG_to_L2 * x # <- project from Hdiv to L2\n    for i in range(self.steps):\n        self.vecL2.data -= tau/self.steps*self.invmL2@convL2.mat*self.vecL2\n    y.data = HDG_to_L2.T @ self.mL2 * self.vecL2    \n    \nPropagateConvection.Mult = NewMult\n```\n\n----------------------------------------\n\nTITLE: Setting Compile Definitions for Debug Builds\nDESCRIPTION: If the build type is set to 'Debug', this snippet appends the 'DEBUG' and 'Wall' compile definitions to the `NGSOLVE_COMPILE_DEFINITIONS` list.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_28\n\nLANGUAGE: cmake\nCODE:\n```\nstring(TOLOWER \"${CMAKE_BUILD_TYPE}\" CMAKE_BUILD_TYPE_LOWER)\nif(CMAKE_BUILD_TYPE_LOWER STREQUAL \"debug\")\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS DEBUG Wall)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Getting help for EI in Python\nDESCRIPTION: This snippet demonstrates how to get help information about the `EI` (EdgeInfo) class using the `help()` function in Python.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.2-csg2d/csg2d.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nhelp(EI)\n```\n\n----------------------------------------\n\nTITLE: Calculating Error Measures in NGSolve (Python)\nDESCRIPTION: This code calculates four different error measures: L2 error of p on the physical domain, L2 error of p on uncut elements, L2 error of u on the physical domain, and L2 error of u on the whole active mesh. It uses the `Integrate` function to compute the integrals and then prints the results.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\np_l2error = sqrt(Integrate((gfpT - p_exact)**2*dX.order(2*order+3), mesh))\np_inner_l2error = sqrt(Integrate((gfpT - p_exact)**2*dxinner, mesh))\nu_l2error = sqrt(Integrate((gfu - u_exact)**2*dX.order(2*order+3), mesh))\nu_l2error_bar = sqrt(Integrate((gfu - u_exact)**2*dxbar, mesh))\nprint(\"p_l2error = \", p_l2error)\nprint(\"p_inner_l2error = \", p_inner_l2error)\nprint(\"u_l2error = \", u_l2error)\nprint(\"u_l2error_bar = \", u_l2error_bar)\n```\n\n----------------------------------------\n\nTITLE: Refining Mesh for Visualization\nDESCRIPTION: This snippet refines the mesh to accurately render the indicator functions.  The number of refinement steps depends on the `interactive` parameter. For `interactive > 1`, more refinement steps are taken. This snippet also updates the level set GridFunctions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nif interactive > 1:\n    nref = 4\nelse:\n    nref = 2\nfor i in range(nref):\n    mesh.ngmesh.Refine()\nmesh=Mesh(mesh.ngmesh)    \n\nfor i, lset_p1 in enumerate(level_sets_p1):\n    lset_p1.Update()\n    InterpolateToP1(level_sets[i], lset_p1)\n```\n\n----------------------------------------\n\nTITLE: Adding ngstd Library\nDESCRIPTION: Defines the `ngstd` library, specifying its type (`${NGS_LIB_TYPE}`) and listing the source files that make up the library. These source files include core components like block allocation, evaluation functions, templates, string operations, status handling, Python bindings, and B-spline functionality.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library( ngstd ${NGS_LIB_TYPE}\n        blockalloc.cpp evalfunc.cpp templates.cpp\n        stringops.cpp statushandler.cpp\n        python_ngstd.cpp\n        bspline.cpp\n        )\n```\n\n----------------------------------------\n\nTITLE: Creating CutInfo Object - Python\nDESCRIPTION: This snippet creates a `CutInfo` object, which gathers information about elements cut by the interface {phi = 0}. The `CutInfo` class requires the mesh and the P1 approximation of the level set function as input. The `help(CutInfo)` provides documentation for the class.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nci = CutInfo(mesh, lsetp1)\nhelp(CutInfo)\n```\n\n----------------------------------------\n\nTITLE: Setting up parameters - Python\nDESCRIPTION: This snippet sets up the parameters for the eigenvalue problem, including the number of eigenvalues to compute and the frequency (omega) as a parameter.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnr_eigs = 200\nomega=Parameter(5)\n```\n\n----------------------------------------\n\nTITLE: Initializing DomainTypeArray\nDESCRIPTION: This snippet demonstrates how to initialize a `DomainTypeArray` with a tuple of domain types. The `ANY` domain type is used and will be expanded internally to a list of tuples containing only `{IF, POS, NEG}`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndomain = DomainTypeArray((ANY, NEG, POS))\n```\n\n----------------------------------------\n\nTITLE: Combining multigrid and block Gauss-Seidel\nDESCRIPTION: This code snippet combines the multigrid preconditioner (`mg.mat`) with the symmetric block Gauss-Seidel smoother (`blockgs`) to create a new preconditioner `mgblock`. This combines the benefits of both methods.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nmgblock = mg.mat + blockgs\n```\n\n----------------------------------------\n\nTITLE: Analyzing SparseCholesky Timer in NGSolve Python\nDESCRIPTION: Analyzes the 'SparseCholesky' timer and prints timers from the rank with the maximum 'SparseCholesky' time. It helps identify which process is taking the longest in the Cholesky factorization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n%%px\nt_chol = filter(lambda t: t['name'] == 'SparseCholesky<d,d,d>::MultAdd', Timers()).__next__()\nmaxt = comm.Max(t_chol['time'])\nif t_chol['time'] == maxt:\n    print('timers from rank ', comm.rank, ':')\n    for t in sorted(filter(lambda t:t['time']>min(0.3*maxt, 0.5), Timers()), key=lambda t:t['time'], reverse=True):\n        print(t['name'], ':  ', t['time'])\n```\n\n----------------------------------------\n\nTITLE: Displaying CMake help\nDESCRIPTION: This command displays the available options for CMake, allowing the user to customize the build process according to their needs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installwindows.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncmake --help\n```\n\n----------------------------------------\n\nTITLE: Applying the Trace Operator - Python\nDESCRIPTION: This code demonstrates how to apply the trace operator to a `GridFunction` `gfu` defined on the `FESpace` `VT`. The result is stored in a `GridFunction` `gfuF` on the `FacetFESpace` `VF`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ngfuF = GridFunction(VF)\ngfuF.vec.data = trace * gfu.vec\n```\n\n----------------------------------------\n\nTITLE: Add Specific Unit Tests (CMake)\nDESCRIPTION: These snippets invoke the `add_unit_test` macro to create specific unit tests for `finiteelement`, `ngblas`, `coefficientfunction`, and `meshaccess`. Each unit test is associated with a corresponding source file. The `coefficientfunction` test is conditionally added based on the `$ENV{RUN_SLOW_TESTS}` environment variable. `file(COPY)` copies volume files to the binary directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/catch/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_unit_test(finiteelement finiteelement.cpp)\nadd_unit_test(ngblas ngblas.cpp)\nif($ENV{RUN_SLOW_TESTS})\n  add_unit_test(coefficientfunction coefficientfunction.cpp)\nendif()\nfile(COPY line.vol square.vol cube.vol 2_doms.vol DESTINATION ${CMAKE_CURRENT_BINARY_DIR})\nadd_unit_test(meshaccess meshaccess.cpp)\n```\n\n----------------------------------------\n\nTITLE: Assembling Linear Form and Creating Grid Function\nDESCRIPTION: This snippet assembles a linear form and creates a grid function. It creates a `LinearForm(fes)`, adds a symbolic form representing a function using `SymbolicLFI(x*y*v)`, and assembles the linear form using `f.Assemble()`. It also creates a `GridFunction(fes)` to store the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\nf = LinearForm(fes)\nf += SymbolicLFI(x*y*v)\nf.Assemble()\ngfu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Configuring Python Configuration File (CMake)\nDESCRIPTION: Configures the `config/config.py` file using CMake's `configure_file` command. The `@ONLY` option specifies that only variables defined within the CMake configuration should be replaced.  The configured file is placed in the `${CMAKE_CURRENT_BINARY_DIR}/config.py` directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/python/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(config/config.py ${CMAKE_CURRENT_BINARY_DIR}/config.py @ONLY)\n```\n\n----------------------------------------\n\nTITLE: Importing PySpice Modules\nDESCRIPTION: This snippet attempts to import the necessary modules from PySpice. It includes a try-except block to handle cases where PySpice is not installed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.1-ngspice/NGSpiceNGSolve.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from PySpice.Spice.Netlist import Circuit\n    from PySpice.Unit import *\nexcept:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Time Loop and Visualization - Python\nDESCRIPTION: This code defines a function `SolveAndVisualize` that performs the explicit time integration and visualization. It initializes the grid function, performs time stepping with the explicit Euler scheme, and adds the results to a multidimensional grid function for animation.  It supports optional right-hand side vectors for non-homogeneous problems.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef SolveAndVisualize(conv_op, t=0, tend=0.6, dt=dt, dt_sample=0.06, rhs_vec = None):\n    gfu.vec[:] = 0; cnt = 0;\n    sample_rate = int(floor(dt_sample*tend/dt))\n    gfu_t = GridFunction(gfu.space,multidim=0)\n    gfu_t.AddMultiDimComponent(gfu.vec)\n    if rhs_vec:\n        inv_rhs = invm * rhs_vec\n    while t < tend-0.5*dt:\n        if rhs_vec:\n            res = invm @ conv_op * gfu.vec + inv_rhs\n        else:\n            res = invm @ conv_op * gfu.vec\n        gfu.vec.data -= dt * res\n        t += dt; cnt += 1; print(\"\\r t=\",t,end=\"\")\n        if (cnt+1) % sample_rate == 0:\n            gfu_t.AddMultiDimComponent(gfu.vec)\n    return gfu_t\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories (CMake)\nDESCRIPTION: This section adds various subdirectories to the build process, including core NGSolve modules and components. It conditionally adds the `py_tutorials` subdirectory if NETGEN_USE_PYTHON is enabled, and the `ngscuda` subdirectory if USE_CUDA is enabled.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_49\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(cmake/resources)\nadd_subdirectory(include)\nadd_subdirectory(ngstd)\nadd_subdirectory(basiclinalg)\nadd_subdirectory(parallel)\nadd_subdirectory(linalg)\nadd_subdirectory(fem)\nadd_subdirectory(multigrid)\nadd_subdirectory(comp)\nadd_subdirectory(solve)\nadd_subdirectory(python)\nadd_subdirectory(pde_tutorial)\nif(NETGEN_USE_PYTHON)\n  add_subdirectory(py_tutorials)\nendif(NETGEN_USE_PYTHON)\nadd_subdirectory(tests)\nadd_subdirectory(docs)\nif(USE_CUDA)\n    add_subdirectory(ngscuda)\nendif(USE_CUDA)\nadd_subdirectory(emscripten)\n```\n\n----------------------------------------\n\nTITLE: Generate Unstructured Mesh in NGSolve using Python\nDESCRIPTION: This snippet generates an unstructured mesh on the unit square using NGSolve. `unit_square.GenerateMesh(maxh=0.2)` creates the mesh with a maximum element size of 0.2. The number of vertices and elements are printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\nmesh.nv, mesh.ne   # number of vertices & elements \n```\n\n----------------------------------------\n\nTITLE: Convert Netgen Mesh to NGSolve Mesh\nDESCRIPTION: This snippet converts a Netgen mesh to an NGSolve mesh, enabling the use of NGSolve functionalities such as curved elements. It also prints the type of the converted mesh and redraws it.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.comp import Mesh\nmesh = Mesh(ngmesh)\nprint(type(mesh))\nRedraw()\n```\n\n----------------------------------------\n\nTITLE: Iterate Faces and Edges, Print Start and End Points - Python\nDESCRIPTION: This snippet iterates through the faces of a solid and then iterates through the edges of each face, printing the start and end points of each edge. This demonstrates iterating through nested levels of the shape hierarchy.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nfor f in solid.faces:\n    print (\"face\")\n    for e in f.edges:\n        print (\"edge:\", e.start, \"-\", e.end)\n```\n\n----------------------------------------\n\nTITLE: Solving Periodic Problem in 3D\nDESCRIPTION: This Python code snippet demonstrates how to solve a periodic problem in 3D using NGSolve, building upon a previously defined mesh. It sets up a periodic finite element space and solves a simple Poisson equation. It requires the ngsolve library and a pre-existing mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/periodic.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(geo.GenerateMesh(maxh=0.3))\nfes = Periodic(H1(mesh, order=3, dirichlet=1))\nu,v = fes.TnT()\n\na = BilinearForm(grad(u)*grad(v)*dx).Assemble()\nf = LinearForm(sin(y)*cos(z)*v*dx).Assemble()\ng = GridFunction(fes)\ng.vec.data = a.mat.Inverse(freedofs=fes.FreeDofs()) * f.vec\n\nDraw (g)\n\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson Equation on Periodic Space\nDESCRIPTION: This code defines a periodic H1 finite element space and solves the Poisson equation with a source term.  It sets up the bilinear and linear forms, assembles them, and then solves the resulting linear system using a direct solver. The solution is then visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/periodicity.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = Periodic(H1(mesh,order=3))\nu,v = fes.TnT()\na = BilinearForm(grad(u)*grad(v)*dx+u*v*dx).Assemble()\nf = LinearForm(exp(-100*( (x-0.8)**2+(y-0.8)**2))*v*dx).Assemble()\n                 \ngfu = GridFunction(fes,\"u\")\ngfu.vec.data = a.mat.Inverse(fes.FreeDofs()) * f.vec\n\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh in 1D\nDESCRIPTION: This code initializes a new Mesh object and sets the spatial dimension to 1, indicating that it will be a one-dimensional mesh. This is a necessary setup step before adding any points or elements to the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nm = Mesh(dim=1)\n```\n\n----------------------------------------\n\nTITLE: Level Set Function Approximation - Python\nDESCRIPTION: This snippet interpolates the level set function into a piecewise linear function space (H1) using `InterpolateToP1`.  The resulting approximation is then visualized using `DrawDC`. This process simplifies numerical integration and avoids complex cut topologies.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nlsetp1 = GridFunction(H1(mesh,order=1))\nInterpolateToP1(levelset,lsetp1)\nDrawDC(lsetp1,-1,1,mesh,\"lsetp1\")\n```\n\n----------------------------------------\n\nTITLE: Visualizing Subdomains (Python)\nDESCRIPTION: This snippet creates an L2 space and sets the value of a GridFunction on each process to its MPI rank. This allows visualization of the domain decomposition.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n%%px\nfesL2 = L2(mesh, order=0)\ngfL2 = GridFunction(fesL2)\ngfL2.vec.local_vec[:] = comm.rank\n```\n\n----------------------------------------\n\nTITLE: Setting a piecewise constant CoefficientFunction\nDESCRIPTION: This snippet demonstrates creating a piecewise constant `CoefficientFunction` that takes different values on different subdomains. A dictionary maps subdomain names to their corresponding values. The `MaterialCF` function then creates the coefficient function, which is visualized using `Draw`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndomain_values = {'inner': 3.7,  'outer': 1}\ncf = mesh.MaterialCF(domain_values)\nDraw(cf, mesh);\n```\n\n----------------------------------------\n\nTITLE: Perform Boolean Fusion Operation - Python\nDESCRIPTION: This snippet performs a boolean fusion operation between a box and a cylinder using the `+` operator, which corresponds to the `fuse` operation in OCCT.  The resulting fused object is then visualized using `DrawGeo`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfused = box+cyl\nDrawGeo (fused);\n```\n\n----------------------------------------\n\nTITLE: Configuring timings.py script in CMake\nDESCRIPTION: This CMake command copies the timings.py script from the source directory to the binary directory, making it available for execution during the build process. It ensures that the timing script used is up-to-date with the source code.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/timings/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/timings.py ${CMAKE_CURRENT_BINARY_DIR}/timings.py)\n```\n\n----------------------------------------\n\nTITLE: Installing scipy, matplotlib - Bash\nDESCRIPTION: This code snippet installs the scipy and matplotlib packages using pip. These packages are required by some of the tutorials for scientific computing and plotting. It uses pip3 to install the necessary packages.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/index.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip3 install scipy matplotlib matplotlib\n```\n\n----------------------------------------\n\nTITLE: Stop MPI Cluster\nDESCRIPTION: This snippet stops the MPI cluster, which is a cleanup operation after the computations are complete.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nstop_cluster()\n```\n\n----------------------------------------\n\nTITLE: Detailed Timer Breakdown\nDESCRIPTION: This snippet filters timers, specifically for 'SparseCholesky<d,d,d>::MultAdd', and prints the timers from the rank that took the longest. It aims to find the processes where the sparse Cholesky decomposition is taking the most time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n%%px\nt_chol = filter(lambda t: t['name'] == 'SparseCholesky<d,d,d>::MultAdd', Timers()).__next__()\nmaxt = comm.Max(t_chol['time']) \nif t_chol['time'] == maxt:\n    print('timers from rank ', comm.rank, ':')\n    for t in sorted(filter(lambda t:t['time']>min(0.3*maxt, 0.5), Timers()), key=lambda t:t['time'], reverse=True):\n        print(t['name'], ':  ', t['time'])\n```\n\n----------------------------------------\n\nTITLE: Adding Horizontal Boundary Elements in Python\nDESCRIPTION: This code snippet adds horizontal boundary elements (1D elements) to the mesh. It iterates through the top and bottom edges of the grid and adds the corresponding elements to the mesh with a boundary condition index of 1.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(N):\n   mesh.Add(Element1D([pnums[N + i * (N + 1)], pnums[N + (i + 1) * (N + 1)]], index=1))\n   mesh.Add(Element1D([pnums[0 + i * (N + 1)], pnums[0 + (i + 1) * (N + 1)]], index=1))\n```\n\n----------------------------------------\n\nTITLE: Target Compile Options Configuration\nDESCRIPTION: Sets compile options for the `ngstd` library. These options control various aspects of the compilation process, such as optimization levels and warning treatments.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_compile_options(ngstd PUBLIC ${NGSOLVE_COMPILE_OPTIONS})\n```\n\n----------------------------------------\n\nTITLE: Setting NETGENDIR Environment Variable (csh/tcsh)\nDESCRIPTION: This command sets the `NETGENDIR` environment variable, pointing to the location of the Netgen executable. This allows the system to find the executable from any directory. This command is used for csh/tcsh shells.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsetenv NETGENDIR \"${BASEDIR}/ngsolve-install/bin\"\n```\n\n----------------------------------------\n\nTITLE: Installing NGSolve Tutorial Files with CMake\nDESCRIPTION: This CMake command installs a collection of files related to NGSolve tutorials. The files consist of geometry files (.geo), volume mesh files (.vol), PDE definition files (.pde), and input files (.in2d).  They are copied to the ${NGSOLVE_INSTALL_DIR_RES}/ngsolve directory as part of the ngsolve_tutorial component.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/pde_tutorial/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( FILES\n        beam.geo chip.vol coilshield.vol cube.vol d3_helmholtz.pde d6_shaft.pde piezo2d40round4.vol.gz square.in2d beam.vol coil.geo coil.vol d1_square.pde d4_cube.pde d7_coil.pde shaft.geo square.vol chip.in2d coilshield.geo cube.geo d2_chip.pde d5_beam.pde d8_coilshield.pde shaft.vol doubleglazing.in2d doubleglazing.vol d10_DGdoubleglazing.pde d9_hybridDG.pde d11_chip_nitsche.pde\n        DESTINATION ${NGSOLVE_INSTALL_DIR_RES}/ngsolve\n        COMPONENT ngsolve_tutorial\n       )\n```\n\n----------------------------------------\n\nTITLE: Accessing and Drawing Subdomains (Python)\nDESCRIPTION: This snippet retrieves the GridFunction 'gfL2' from all processes, and then draws the subdomain on the main process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ngfL2 = c[:][\"gfL2\"]\nDraw (gfL2[0]);\n```\n\n----------------------------------------\n\nTITLE: Non-closed surface meshing with boundary conditions and points\nDESCRIPTION: This snippet demonstrates creating a non-closed surface with boundary conditions, edges (BBoundaries), and points (BBBoundaries). It uses `AddSurface` to define the surface and `NameEdge` to label the edges formed by the intersection of the surface with other geometric entities.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ngeo       = CSGeometry()\ncyl       = Cylinder(Pnt(0,0,0), Pnt(1,0,0), 1)\nbot       = Plane(Pnt(0,0,0), Vec(0,0,-1))\nright     = Plane( Pnt(3,0,0), Vec(1,0,0))\nleft      = Plane(Pnt(0,0,0), Vec(-1,0,0))\nfinitecyl = cyl * bot * left * right\n\ngeo.AddSurface(cyl, finitecyl.bc(\"surface\"))\ngeo.AddPoint(Pnt(0,0,1), \"pntload\")\n\ngeo.NameEdge(cyl,bot, \"sym\")\ngeo.NameEdge(cyl,left, \"left\")\ngeo.NameEdge(cyl,right, \"right\")\n\nmesh = Mesh(geo.GenerateMesh(maxh=0.5))\nmesh.Curve(2)\nDraw(mesh)\nprint(\"Bnd   = \", mesh.GetBoundaries())\nprint(\"BBnd  = \", mesh.GetBBoundaries())\nprint(\"BBBnd = \", mesh.GetBBBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Setting Clipping Planes\nDESCRIPTION: This snippet demonstrates how to set clipping planes for the visualization. The `clipping` parameter is a dictionary specifying the plane's position (`pnt`) and normal vector (`vec`), as well as a boolean for enabling clipping. This allows visualizing internal sections of the model.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclipping = { \"function\" : True,  \"pnt\" : (2.5,1.5,1), \"vec\" : (0,1,-1) } \nDraw (func, mesh, clipping=clipping);\n```\n\n----------------------------------------\n\nTITLE: Starting Jupyter Notebook - Bash\nDESCRIPTION: This command starts the Jupyter notebook server in the current directory. It assumes that the `index.ipynb` file is located in the current working directory. This allows the user to access and run the i-tutorials through the web browser.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/index.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\njupyter-notebook index.ipynb\n```\n\n----------------------------------------\n\nTITLE: Setting up ParallelDofs for Edge Averages\nDESCRIPTION: This snippet establishes the ParallelDofs for the edge average space (w). It determines the processes that share each edge and then uses this information to construct the ParallelDofs. The edge constraints are computed and statistics about them are printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nedist_procs = [sorted(set.intersection(*[set(pardofs.Dof2Proc(v)) for v in edge])) for edge in edges]\neavg_pardofs = ParallelDofs(edist_procs, comm)\n\nneavg = comm.Sum(sum([1 for ps in edist_procs if comm.rank<ps[0]]))\nneavg_min = comm.Min(len(edges) if comm.rank else neavg)\nneavg_avg = comm.Sum(len(edges)) / comm.size\nneavg_max = comm.Max(len(edges))\nif comm.rank==0:\n    print('# edge constraints global: ', neavg)\n    print('min, avg, max: ', neavg_min, ' ', neavg_avg, ' ', neavg_max)\n```\n\n----------------------------------------\n\nTITLE: Printing Shared DOFs Information\nDESCRIPTION: This snippet identifies and prints the ranks with which specific DOFs are shared, as well as the DOFs shared with other ranks. It iterates through a limited number of local DOFs and prints the ranks they are shared with, using `pd.Dof2Proc(k)`.  It then iterates through other ranks and prints the DOFs shared with those ranks using `pd.Proc2Dof(p)`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\nprint('I am rank ', comm.rank)\nprint('---')\n\nfor k in range(min(10,fes.ndof)):\n    print('I share DOF', k, 'with ranks:', [p for p in pd.Dof2Proc(k)])\n    \nprint('... and so forth ...')\nprint('\\n')\n\nfor p in range(0, comm.size-1):\n    if len(pd.Proc2Dof(p)):\n        print('DOFs I share with rank', p, ': ', [p for p in pd.Proc2Dof(p)])\n```\n\n----------------------------------------\n\nTITLE: Defining Element Patches - Python\nDESCRIPTION: This snippet defines element patches using `ElementAggregation`. All elements cut by the interface are included in the patches, thus marking these elements as \"bad\", meaning they need support for stabilization or postprocessing. A patch number field is constructed and visualized to illustrate the patches.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nEA = ElementAggregation(mesh)\nEA.Update(ci.GetElementsOfType(NEG), hasif)\npatch_number_field = GridFunction(L2(mesh))\npatch_number_field.vec.FV()[:] = EA.element_to_patch\nDraw(patch_number_field, mesh, \"patch_number_field\") #, deformation=CF((0,0,0.02*patch_number_field)))\n```\n\n----------------------------------------\n\nTITLE: Solving with Mass Matrix (Python)\nDESCRIPTION: This snippet illustrates how to solve a system using the block-diagonal (or diagonal) mass matrix of an L2 finite element space in NGSolve. It uses the `SolveM` method of the `FESpace` object. The `rho` argument allows specifying a density coefficient function for the mass matrix, and the operation is performed in-place for the given vector `u`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/dg.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndensity = CoefficientFunction(1)\n                fes.SolveM (rho=density, vec=u)\n```\n\n----------------------------------------\n\nTITLE: Defining and Assembling Linear Form for Force\nDESCRIPTION: Defines a constant field representing the force vector (1e-3, 0, 0) and creates a linear form by integrating the force over the \"force\" boundary. The linear form is then assembled.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nforce = CF( (1e-3,0,0) )\nf = LinearForm(force*v*ds(\"force\")).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Import Netgen Geometry Module - Python\nDESCRIPTION: This snippet imports the `netgen.geom2d` module, which is necessary for defining 2D geometries in Netgen-Python. It's the first step in creating any geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport netgen.geom2d as geom2d\n```\n\n----------------------------------------\n\nTITLE: Defining and Training TensorFlow Model\nDESCRIPTION: This snippet defines a TensorFlow neural network model with dense layers, compiles it with the Adam optimizer and mean squared error loss function, and trains it on the generated data (`data_in`, `data_out`).  The model learns to approximate the NGSolve solution based on the input parameters.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport tensorflow as tf\n\n# func = 'relu' #activation function\nfunc = 'swish' #activation function\nmodel = tf.keras.models.Sequential([\n    tf.keras.layers.Dense(10,input_shape=(input_dim,),activation=func),\n    tf.keras.layers.Dense(20,activation=func),\n    tf.keras.layers.Dense(50,activation=func),\n    tf.keras.layers.Dense(output_dim)\n    ])\n\n# Standard Adam optimizer\noptimizer = tf.keras.optimizers.Adam(learning_rate=0.001)\n\n# Loss function (error functional) mean squared error (least squares)\n@tf.function\ndef loss_fn(y_true, y_pred):\n   return tf.math.reduce_mean(tf.math.square(y_true-y_pred))\n\nloss_fn = tf.keras.losses.MeanSquaredError()\n\n# Training\nepochs = 1000 # number of times the data is used for training\nbatch_size = 1024  # each gradient descent step uses 1024 datapoints\nmodel.compile(optimizer=optimizer,loss=loss_fn)\nmodel.fit(data_in,data_out,epochs=epochs,batch_size=batch_size,verbose=0)\nprint(loss_fn(data_out,model(data_in)).numpy())\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear Forms with Trace Operator\nDESCRIPTION: This snippet assembles the bilinear forms Bel and Btr using volume contributions and couplings between the trace (obtained through the trace operator) and the volume. It then combines these forms using embedding operators to create the final bilinear form B.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nBel = BilinearForm(trialspace=fes_p, testspace=fes_u)\nBel += grad(p)*v * dx -p*(v*n) * dx(element_boundary=True)\n%time Bel.Assemble()\n\nBtr = BilinearForm(trialspace=fes_tr, testspace=fes_u)\nBtr += 0.5 * phat * (v*n) * dx(element_boundary=True) \n%time Btr.Assemble()\n\nB = emb_u @ (Bel.mat + Btr.mat @ traceop) @ emb_p.T\n```\n\n----------------------------------------\n\nTITLE: Get Edges Connected to Mesh Vertex\nDESCRIPTION: This snippet retrieves the edges connected to a `MeshNode` representing a vertex. It demonstrates querying topological information from a MeshNode object.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmeshv.edges\n```\n\n----------------------------------------\n\nTITLE: Installing Jupyter with pip (Mac/Linux)\nDESCRIPTION: This command installs Jupyter using the pip3 package manager on macOS or Linux systems. It ensures that Jupyter is available for creating and running interactive notebooks.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/usejupyter.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip3 install jupyter\n```\n\n----------------------------------------\n\nTITLE: Drawing Plane Wave Shape\nDESCRIPTION: This code visualizes the third plane wave shape on the mesh. `animate_complex=True` allows visualizing the complex values of the function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nDraw (shapes[2], mesh, animate_complex=True );  \n```\n\n----------------------------------------\n\nTITLE: Generating ngsolve.rc Configuration File with CMake\nDESCRIPTION: This CMake command generates the `ngsolve.rc` file by processing the `ngsolve.rc.template` file.  It uses the IMMEDIATE and @ONLY options, indicating that variable substitution occurs during the configuration stage and only CMake variables marked for substitution are processed. The generated file is placed in the source directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/cmake/resources/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(ngsolve.rc.template ${CMAKE_CURRENT_SOURCE_DIR}/ngsolve.rc IMMEDIATE @ONLY)\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Netgen on Mac OS X\nDESCRIPTION: This code snippet shows how to set environment variables to execute netgen from the command prompt on Mac OS X. The `setenviron_mac.sh` file contains the specific environment variable settings needed for the installation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/gettingstarted.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nsetenviron_mac.sh\n```\n\n----------------------------------------\n\nTITLE: Installing with Make - Bash\nDESCRIPTION: This snippet shows how to install the built Netgen/NGsolve project using Make. The `make install` command is executed in the build directory. This step typically requires appropriate permissions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Querying H(div) Operators\nDESCRIPTION: This snippet queries and prints the available operators associated with the H(div) finite element space. This provides insight into the operations that can be performed on functions within that space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint (\"H(div) operators: \", ud.Operators())\n```\n\n----------------------------------------\n\nTITLE: Add Pytest Test with CMake\nDESCRIPTION: This CMake snippet adds a pytest test using the `add_test` command. It specifies the test name, the command to execute (using the Netgen Python executable), pytest arguments like `--durations` and `--ignore`, and the working directory. This test is conditional on `NETGEN_USE_PYTHON` being true.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/pytest/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(NETGEN_USE_PYTHON)\n  add_test(NAME pytest COMMAND ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n  if(NETGEN_USE_MPI)\n    add_test(NAME mpi_pytest COMMAND mpirun -np 5 --allow-run-as-root ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/mpi_only )\n    set_tests_properties ( mpi_pytest PROPERTIES TIMEOUT 60 )\n  endif()\n  set_tests_properties ( pytest PROPERTIES TIMEOUT 1500 )\n  add_custom_target(pytest ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\nendif(NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: External Project Setup for mylittlengs\nDESCRIPTION: Sets up an external project, `mylittlengs`, using `ExternalProject_Add`. It clones a git repository, and configures update, build, and install commands (empty in this case). This snippet also sets target properties to exclude the project from the default 'all' target. It is conditionally executed based on `NETGEN_USE_PYTHON` and the absence of `WIN32`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nExternalProject_Add(\n        mylittlengs\n        GIT_REPOSITORY https://github.com/NGSolve/mylittlengsolve.git\n        TIMEOUT 10\n        UPDATE_COMMAND ${GIT_EXECUTABLE} pull\n        CONFIGURE_COMMAND \"\"\n        BUILD_COMMAND \"\"\n        INSTALL_COMMAND \"\"\n        )\n      set_target_properties(mylittlengs PROPERTIES EXCLUDE_FROM_ALL TRUE)\n      ExternalProject_Get_Property(mylittlengs source_dir)\n```\n\n----------------------------------------\n\nTITLE: Header Files Installation\nDESCRIPTION: Configures the installation of header files to the specified include directory (`${NGSOLVE_INSTALL_DIR_INCLUDE}`).  These headers are essential for developers who want to use the `ngstd` library in their own projects. The component `ngsolve_devel` is also specified.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( FILES\n        bessel.hpp blockalloc.hpp evalfunc.hpp\n        memusage.hpp ngstd.hpp\n        stringops.hpp\n        statushandler.hpp ngsstream.hpp \n        mycomplex.hpp python_ngstd.hpp ngs_utils.hpp\n        bspline.hpp sample_sort.hpp\n        DESTINATION ${NGSOLVE_INSTALL_DIR_INCLUDE}\n        COMPONENT ngsolve_devel\n       )\n```\n\n----------------------------------------\n\nTITLE: Updating Source Code (Bash)\nDESCRIPTION: This script updates the Netgen/NGSolve source code by fetching the latest changes from the remote repository and updating the submodules. This requires that you are in the source directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\ngit submodule update --recursive --init\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear and Linear Forms with Condensation (Python)\nDESCRIPTION: This snippet demonstrates assembling a bilinear form with the `condense=True` option, which enables static condensation. It also assembles a linear form.  The bilinear form represents grad(u) * grad(v) * dx, and the linear form represents 1 * v * dx. A GridFunction 'u' is initialized using the finite element space 'fes'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\na = BilinearForm(grad(u) * grad(v) * dx, condense=True).Assemble()\nf = LinearForm(1 * v * dx).Assemble()\nu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies to ngbla\nDESCRIPTION: This snippet adds a dependency from the `ngbla` library to the `kernel_generated` target, which forces the kernel headers to be generated before compiling ngbla. It also sets include directories and compile definitions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nadd_dependencies(ngbla kernel_generated)\n\ntarget_include_directories(ngbla PRIVATE ${CMAKE_CURRENT_BINARY_DIR})\ntarget_compile_definitions(ngbla PRIVATE ${NGSOLVE_COMPILE_DEFINITIONS_PRIVATE})\n```\n\n----------------------------------------\n\nTITLE: Calculating and drawing CutRatioGF\nDESCRIPTION: This snippet calculates the cut ratio field kappaminus using the CutInfo class and draws it on the mesh, labeling it as \"kappa\". This field represents the ratio of the area of each element that lies in the negative domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nkappaminus = CutRatioGF(ci)\nkappa = (kappaminus, 1-kappaminus)\nDraw(kappaminus, mesh, \"kappa\")\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific Library Type and Compiler Options\nDESCRIPTION: Sets the library type and compiler options based on the target platform (EMSCRIPTEN, Windows, or other). It defines the NGS_LIB_TYPE and NGSOLVE_LIB_TYPE variables and appends compiler options accordingly.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_29\n\nLANGUAGE: cmake\nCODE:\n```\nif(EMSCRIPTEN)\n    set(NGS_LIB_TYPE OBJECT)\n    set(NGSOLVE_LIB_TYPE OBJECT)\nelif(WIN32)\n    add_definitions(-DNGS_EXPORTS)\n\n    # build convenience (aka object) libraries in windows)\n    set(NGS_LIB_TYPE OBJECT)\n    set(NGSOLVE_LIB_TYPE SHARED)\n\n    if(CMAKE_CXX_COMPILER_ID STREQUAL \"Intel\")\n        # Intel Compiler\n        list(APPEND NGSOLVE_COMPILE_OPTIONS /Od /MP $<$<COMPILE_LANGUAGE:CXX>:/Qstd=c++17> /Qopt-report-file:report.log)\n    else()\n        # MS Visual Compiler\n        list(APPEND NGSOLVE_COMPILE_OPTIONS /std:c++17 /bigobj /wd4068)\n    endif()\n\nelse(WIN32)\n    set(NGS_LIB_TYPE SHARED)\n    set(NGSOLVE_LIB_TYPE SHARED)\n    list(APPEND NGSOLVE_COMPILE_OPTIONS $<$<COMPILE_LANGUAGE:CXX>:-std=c++17>)\nendif(EMSCRIPTEN)\nif(APPLE)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS MSG_NOSIGNAL=0)\nendif(APPLE)\n```\n\n----------------------------------------\n\nTITLE: Set Material Property on Sphere in Netgen\nDESCRIPTION: This snippet demonstrates setting the material property of a sphere using the mat() method. This allows assigning different physical properties to different parts of the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsphere.mat(\"iron\")\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces in NGSolve\nDESCRIPTION: This snippet defines the finite element spaces used for the mixed formulation. It includes a discontinuous H(div) space (V), an L2 space (Q), and a facet space (F). Boundary conditions are applied to the facet space. The code then prints the number of degrees of freedom for each space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.7-hybrid/hybrid.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\norder = 3\nV = Discontinuous (HDiv(mesh, order=order))\nQ = L2(mesh, order=order-1)\nF = FacetFESpace(mesh, order=order, dirichlet=\"bottom\")\nX = V*Q*F\nprint (\"sigmadofs:\", X.Range(0))\nprint (\"udofs:    \", X.Range(1))\nprint (\"uhatdofs: \", X.Range(2))\n```\n\n----------------------------------------\n\nTITLE: Setting Elasticity Parameters\nDESCRIPTION: This code snippet defines the material parameters for the elasticity model, including Young's modulus (Emod), Poisson's ratio (nu), shear modulus (mu), and Lam's first parameter (lmbda).  The hardening parameter H, yield stress sigma_Y, and a perturbation parameter for tensor norms (norm_pert) are also defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Elasticity parameters correspond to those in Ref. 4, ie. mu = 80193.8 and kappa = 164206\n\n# Young's modulus\nEmod = 206900\n\n# Poisson's ratio\nnu = 0.29\n\nprint(\"E =\", Emod, \"\\n\\nnu =\", nu)\n\nmu = Parameter(Emod / (2 * (1 + nu)))\nlmbda = Parameter(Emod * nu / ((1 + nu) * (1 - 2 * nu)))\n\nprint()\nprint(\"mu =\", mu.Get())\nprint(\"lambda =\", lmbda.Get())\n\n# just for reference:\nkappa = Emod / (3 * (1 - 2 * nu))\n\nprint(\"kappa =\", kappa)\n\n\n# Hardening parameter\nH = Parameter(1.0)\n\n# Yield stress\nsigma_Y = Parameter(450)\n\n# Perturbation parameter for tensor norms: this value is decisive for the accuracy of the result!\n#  for higher values of H it must be sufficently small\nnorm_pert = 1e-16\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for NGSolve\nDESCRIPTION: This snippet imports the required modules from the NGSolve library, including modules for finite element analysis, visualization, geometry creation, and solvers.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import SplineGeometry\nfrom ngsolve.solvers import *\n```\n\n----------------------------------------\n\nTITLE: Assembling BilinearForm and LinearForm\nDESCRIPTION: This snippet assembles the bilinear form a and the linear form f, preparing them for solving the linear system.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()\nf.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Importing Custom Modules\nDESCRIPTION: This snippet imports a custom module named `usrmeeting_jupyterstuff`. This module likely contains functions for managing cluster setup and connection.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom usrmeeting_jupyterstuff import *\n```\n\n----------------------------------------\n\nTITLE: Solving with NGSolve CGSolver\nDESCRIPTION: This code uses the NGSolve CGSolver to solve the linear system with the previously assembled matrix and preconditioner. It initializes the CGSolver with the matrix, preconditioner, and a printrates flag. The solution is computed by applying the inverse operator to the right-hand side vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n%%px\nfrom ngsolve.krylovspace import CGSolver\ninv = CGSolver(a.mat, pre, printrates=comm.rank==0)\ngfu.vec.data = inv * f.vec\n```\n\n----------------------------------------\n\nTITLE: Define function and gradient for shape optimization - Python\nDESCRIPTION: This snippet defines the function `f` and its gradient `grad_f` as CoefficientFunctions using NGSolve. These functions are crucial for calculating the shape derivative and the cost functional to be minimized.  The function `f` is defined based on the provided mathematical formula.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# define the function f and its gradient\na =4.0/5.0\nb = 2\nf = CoefficientFunction((sqrt((x - a)**2 + b * y**2) - 1) \\\n                * (sqrt((x + a)**2 + b * y**2) - 1) \\\n                * (sqrt(b * x**2 + (y - a)**2) - 1) \\\n                * (sqrt(b * x**2 + (y + a)**2) - 1) - 0.001)\n\n# gradient of f defined as vector valued coefficient function\ngrad_f = CoefficientFunction((f.Diff(x),f.Diff(y)))\n```\n\n----------------------------------------\n\nTITLE: Setting up Stiffness and Mass Matrices\nDESCRIPTION: This snippet sets up the finite element space, bilinear forms for stiffness (a) and mass (m) matrices, and a preconditioner for the stiffness matrix. It initializes the grid function u within the finite element space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.2-eigenvalues/pinvit.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=4, dirichlet=\".*\")\nu,v = fes.TnT()\n\na = BilinearForm(grad(u)*grad(v)*dx)\npre = Preconditioner(a, \"multigrid\")\na.Assemble()\n\nm = BilinearForm(u*v*dx).Assemble()\n\nu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces for DG Method\nDESCRIPTION: This code defines the finite element spaces required for the hybridized C0-continuous interior penalty (DG) method. It creates an H1 space (V1) for the displacement and a NormalFacetFESpace (V2) for the normal derivative trace on the element boundaries. These spaces are combined into a product space V.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.9-fourthorder/fourthorder.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\norder = 3\n\nV1 = H1(mesh, order=order, dirichlet=\"left|bottom|right|top\")\nV2 = NormalFacetFESpace(mesh, order=order-1, dirichlet=\"left|bottom|right|top\")\nV = V1*V2\n\nw,what = V.TrialFunction()\nv,vhat = V.TestFunction()\n```\n\n----------------------------------------\n\nTITLE: Solving magnetostatic problem\nDESCRIPTION: This code solves the magnetostatic problem to determine the magnetic vector potential. It defines an HCurl finite element space, assembles a bilinear form based on the curl-curl operator, and assembles a linear form representing the current source. The resulting system is solved to obtain the magnetic vector potential.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/coil.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfes = HCurl(mesh, order=2, nograds=True)\nprint (\"HCurl dofs:\", fes.ndof)\nu,v = fes.TnT()\nmu = 4*math.pi*1e-7\na = BilinearForm(1/mu*curl(u)*curl(v)*dx+1e-6/mu*u*v*dx)\npre = Preconditioner(a, \"bddc\")\nf = LinearForm(sigma*grad(gfphi)*v*dx(\"coil\"))\nwith TaskManager():\n    a.Assemble()\n    f.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Constructing the Schur Complement in NGSolve\nDESCRIPTION: This code constructs the Schur complement, which discretizes the Laplace operator, using previously defined operators such as the bilinear form `b`, and the mass matrix inverse `ainv`. It also sets up the linear form `f` and applies a projector.  These components are then used for solving the system.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/examples/matrixfree.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nLaplace = b.mat @ ainv @ b.mat.T\n\nf = LinearForm (V)\nf += 1*vt * dx\nf.Assemble()\n\nproj = Projector(V.FreeDofs(), True)\n\ngfu = GridFunction (V)\n```\n\n----------------------------------------\n\nTITLE: Displaying Install Directory in CMake\nDESCRIPTION: This snippet uses the `message` command to display the installation directory for the NGSolve project, which is specified by the `CMAKE_INSTALL_PREFIX` variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_55\n\nLANGUAGE: cmake\nCODE:\n```\nmessage(\"\n  Install directory:\n\n    ${CMAKE_INSTALL_PREFIX}\")\n```\n\n----------------------------------------\n\nTITLE: Printing the Original Expression Tree\nDESCRIPTION: This snippet prints the original, uncompiled expression tree for the `final` CoefficientFunction. Useful for comparison with the compiled version.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nprint(final)\n```\n\n----------------------------------------\n\nTITLE: Building and Installing NGSolve using CMake\nDESCRIPTION: This command builds the NGSolve project in 'Release' configuration and installs it to the directory specified by CMAKE_INSTALL_PREFIX during configuration.  It uses the CMake build tool to compile the source code and install the necessary files.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installwindows.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncmake --build . --config Release --target install\n```\n\n----------------------------------------\n\nTITLE: Set User ID and Number of Processors - Python\nDESCRIPTION: Defines the user ID and the number of processors to be used in the distributed computation. These variables are used for managing and configuring the computational cluster.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nuser_id = 'lukas'\nnum_procs = '40'\n```\n\n----------------------------------------\n\nTITLE: Setting NGROOT Environment Variable - Bash\nDESCRIPTION: This snippet shows how to set the NGROOT environment variable, which specifies the root directory for Netgen/NGsolve sources and builds. This makes it easier to refer to the source and build directories in subsequent commands.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport NGROOT=<PathToTheFolderYouJustMade>\n```\n\n----------------------------------------\n\nTITLE: Loading Geometry in Netgen from Command Line\nDESCRIPTION: This command allows loading a geometry file directly when starting Netgen from the command line. Replace `sculpture.geo` with the actual path to your geometry file. This assumes Netgen is in your system's PATH.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/gettingstarted.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnetgen sculpture.geo\n```\n\n----------------------------------------\n\nTITLE: Adding Test Subdirectories (CMake)\nDESCRIPTION: This snippet adds subdirectories named 'pytest', 'catch', and 'timings' to the build. These subdirectories presumably contain further test configurations or test suites managed by their own CMakeLists.txt files.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(pytest)\nadd_subdirectory(catch)\nadd_subdirectory(timings)\n```\n\n----------------------------------------\n\nTITLE: Appending Compile Definitions\nDESCRIPTION: Appends the `USE_TIMEOFDAY` definition to the `NGSOLVE_COMPILE_DEFINITIONS` list. This variable is used later to pass compile-time definitions to the compiler.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_24\n\nLANGUAGE: cmake\nCODE:\n```\nlist(APPEND NGSOLVE_COMPILE_DEFINITIONS USE_TIMEOFDAY)\n```\n\n----------------------------------------\n\nTITLE: Add MPI Pytest Test with CMake\nDESCRIPTION: This CMake snippet adds an MPI-enabled pytest test using `add_test`. It utilizes `mpirun` to execute the pytest command in parallel. The test is located in a subdirectory (`mpi_only`) and a timeout is set using `set_tests_properties`. This test runs when both `NETGEN_USE_PYTHON` and `NETGEN_USE_MPI` are true.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/pytest/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(NETGEN_USE_PYTHON)\n  add_test(NAME pytest COMMAND ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n  if(NETGEN_USE_MPI)\n    add_test(NAME mpi_pytest COMMAND mpirun -np 5 --allow-run-as-root ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/mpi_only )\n    set_tests_properties ( mpi_pytest PROPERTIES TIMEOUT 60 )\n  endif()\n  set_tests_properties ( pytest PROPERTIES TIMEOUT 1500 )\n  add_custom_target(pytest ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\nendif(NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: Setting include directories\nDESCRIPTION: This cmake command adds the current source directory to the include directories. This ensures that the compiler can find the header files located within the current source directory during the build process. The `BEFORE` keyword ensures that the current source directory is prepended to the include paths.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/multigrid/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Install Code for Stub Generation (CMake)\nDESCRIPTION: This uses CMake `install(CODE ...)` to execute commands during the install step. It sets the `PYTHONPATH` environment variable to include the ngsolve python installation directory and then executes the pybind11_stubgen module to generate stub files, ignoring any errors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/python/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(CODE \"\\\n  set(ENV{PYTHONPATH} ${CMAKE_INSTALL_PREFIX}/${NGSOLVE_INSTALL_DIR_PYTHON})\\n \\\n  execute_process(COMMAND ${Python3_EXECUTABLE} -m pybind11_stubgen --ignore-all-errors ngsolve)\\n \\\n  \")\n```\n\nLANGUAGE: cmake\nCODE:\n```\ninstall(CODE \"execute_process(COMMAND ${NETGEN_PYTHON_EXECUTABLE} -m pybind11_stubgen --ignore-all-errors ngsolve)\")\n```\n\n----------------------------------------\n\nTITLE: Revolving a face\nDESCRIPTION: This code demonstrates how to revolve a face around an axis using the Revolve method. It defines a complex face using lines and arcs, then revolves it around the Y-axis by 180 degrees. The Axis specifies the center and direction of the axis of revolution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/workplane.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nface = WorkPlane().MoveTo(10,0).Line(18).Arc(2,90).Line(6).Arc(2,90) \\\n    .Line(18).Rotate(90).Line(2).Rotate(90).Line(10) \\\n    .Arc(3,-180).Line(10).Close().Face()\np = face.Revolve(Axis((0,0,0),Y),180)\nDrawGeo(p);\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Normal Vector for Koiter Shell Model (Python)\nDESCRIPTION: This snippet initializes the normal vectors used in the Koiter shell formulation. The `averednv` and `averednv_start` grid functions, defined on facet surfaces, are set to the surface normal `nsurf` on all boundaries using dual evaluation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\naverednv.Set(nsurf, dual=True, definedon=mesh.Boundaries(\".*\"))\naverednv_start.Set(nsurf, dual=True, definedon=mesh.Boundaries(\".*\"))\n```\n\n----------------------------------------\n\nTITLE: Expressing XFEM Shape Functions in CutFEM\nDESCRIPTION: This code snippet demonstrates how to express XFEM shape functions as CutFEM shape functions using `ngsolve`. It involves obtaining standard and enrichment shape functions, and then combining them for positive and negative parts.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\n(u_std,u_x), (v_std, v_x) = VhG.TnT()\n\nu = [u_std + op(u_x) for op in [neg,pos]]\nv = [v_std + op(v_x) for op in [neg,pos]]\n```\n\n----------------------------------------\n\nTITLE: Including Version File Generation\nDESCRIPTION: Includes a CMake script (generate_version_file.cmake) to generate a version file for the project. This script is responsible for creating a file containing the project's version number and other relevant information.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ninclude (${CMAKE_CURRENT_LIST_DIR}/cmake/generate_version_file.cmake)\n```\n\n----------------------------------------\n\nTITLE: Solving Linear System Using CG\nDESCRIPTION: This snippet solves a linear system using the Conjugate Gradient (CG) method with a preconditioner. It updates the grid function vector `gfu.vec` with the solution obtained by solving `a.mat * gfu.vec = f.vec` using the CG solver, the preconditioner `c.mat`, a tolerance of `1e-6`, a maximum of `30` steps, and prints the rates from rank 0.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\ngfu.vec.data = solvers.CG(mat=a.mat, pre=c.mat, rhs=f.vec, tol=1e-6, maxsteps=30, printrates=comm.rank==0)\n```\n\n----------------------------------------\n\nTITLE: Displaying Configuration Information in CMake\nDESCRIPTION: This snippet uses the `message` command to display various configuration settings for the NGSolve project, including the project name, version, build type, compiler, flags, and enabled features. The message is formatted for readability.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_53\n\nLANGUAGE: cmake\nCODE:\n```\nmessage(\"\n------------------------------------------------------------------------\n  ${PROJECT_NAME} ${NGSOLVE_VERSION}:  Automatic configuration OK.\n\n  Build type: ${CMAKE_BUILD_TYPE}\n  Compiler: ${CMAKE_CXX_COMPILER}\n  Flags: ${flags}\n\n  Enabled functionality:\n\n    GUI: ............... ${NETGEN_USE_GUI}\n    LAPACK: ............ ${USE_LAPACK}\n    MKL: ............... ${USE_MKL}\n    PYTHON: ............ ${NETGEN_USE_PYTHON}\n    MPI: ............... ${NETGEN_USE_MPI}\n    CUDA: .............. ${USE_CUDA}\n    MUMPS: ............. ${USE_MUMPS}\n    PARDISO: ........... ${USE_PARDISO}\n    INTEL_MIC: ......... ${INTEL_MIC}\n    VTUNE: ............. ${USE_VTUNE}\n\n\n  Building:\n  \")\n```\n\n----------------------------------------\n\nTITLE: Copyright Disclaimer Example\nDESCRIPTION: This snippet shows a sample copyright disclaimer that an employer or school can sign to relinquish copyright interest in a library. It helps clarify the ownership of the software and ensures that the library can be freely distributed under the LGPL. The example includes the name of the organization, the library's name, and the signature of an authorized representative.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/cmake/resources/LICENSE.txt#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nYoyodyne, Inc., hereby disclaims all copyright interest in the\nlibrary `Frob' (a library for tweaking knobs) written by James Random Hacker.\n\n<signature of Ty Coon>, 1 April 1990\nTy Coon, President of Vice\n```\n\n----------------------------------------\n\nTITLE: Constructing Edge-Constraint Matrix\nDESCRIPTION: This snippet creates the edge-constraint matrix (B_p) using the COO (Coordinate list) format. It calculates the average value for each edge degree of freedom. It takes the list of edges and constructs the rows, cols, and vals for sparse matrix creation using `SparseMatrixd.CreateFromCOO()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nar = [(num_e[0],d,1.0) for num_e in enumerate(edges) for d in num_e[1] ]\nrows, cols, vals = [list(x) for x in zip(*ar)] if len(ar) else [[],[],[]]\nB_p = SparseMatrixd.CreateFromCOO(rows, cols, vals, len(edges), fes.ndof)\n```\n\n----------------------------------------\n\nTITLE: Compiling a CoefficientFunction with Real Compilation\nDESCRIPTION: This snippet compiles the `final` CoefficientFunction with 'realcompile=True' and 'wait=True', leveraging a compiler script for further optimization. Requires NGSolve to be built from source with a compiler/toolchain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfinalcc = final.Compile(realcompile=True, wait=True)\n```\n\n----------------------------------------\n\nTITLE: Setting up geometry and mesh for Hybrid Mixed Method in NGSolve\nDESCRIPTION: This code snippet sets up the geometry and mesh for solving a partial differential equation using the hybrid mixed method in NGSolve. It defines a complex 3D geometry using constructive solid geometry (CSG) operations and generates a mesh from it.  The mesh is then used in subsequent finite element analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/examples/matrixfree.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import unit_square\nfrom ngsolve.fem import MixedFE\nfrom netgen.csg import *\n\ngeom = CSGeometry()\ngeom.Add (Sphere(Pnt(50,50,50),80) \\\n          -Cylinder(Pnt(-100,0,0),Pnt(200,0,0), 40) \\\n          -Cylinder(Pnt(100,-100,100),Pnt(100,200,100),40)\n          -Cylinder(Pnt(0,100,-100), Pnt(0,100,200),40)\n          -Sphere(Pnt(50,50,50),50))\n# geom.Draw()\n\nmesh = Mesh(geom.GenerateMesh(maxh=25))\n\n#for i in range(1):\n#    mesh.Refine()\n#mesh.Curve(5)\n# Draw (mesh)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build with CMake - Bash\nDESCRIPTION: This snippet demonstrates how to configure the build using CMake. It navigates to the build directory and then calls CMake, providing the path to the source directory as an argument.  Requires cmake to be installed and in the PATH.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd $NGROOT/ngsolve-build\ncmake $NGROOT/ngsolve-src\n```\n\n----------------------------------------\n\nTITLE: Initializing NGSolve and Mesh\nDESCRIPTION: This snippet initializes NGSolve, generates a mesh, refines it, and defines a finite element space (H1) for solving the Poisson equation. It imports necessary modules and sets up the problem space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/poisson_cuda.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom time import time\n```\n\n----------------------------------------\n\nTITLE: Copying ngsolve Objects Using Archive Serialization\nDESCRIPTION: This snippet defines a function `Copy` that serializes an ngsolve object to an archive (binary by default) and then deserializes it using `comp.FromArchiveCF`, effectively creating a copy of the object. It then demonstrates copying `x` and `u`, printing the original and copied objects, as well as the vectors of the GridFunctions `u` and `u1`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/emscripten/example.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef Copy(obj, binary=True):\n    return comp.FromArchiveCF(comp.ToArchive(obj, binary), binary)\n\nx1 = Copy(x)\nprint(x,x1)\nu1 = Copy(u)\nprint(u,u1)\nprint(u.vec)\nprint(u1.vec)\n```\n\n----------------------------------------\n\nTITLE: Add MPI Tests using CTest - CMake\nDESCRIPTION: This CMake code block defines tests for the Python MPI examples using `add_test`. It iterates through a list of Python scripts (`mpi_poisson.py`, `mpi_cmagnet.py`, `mpi_timeDG.py`, `mpi_navierstokes.py`) and creates a test for each. The test command uses `mpirun` with 5 processes (`-np 5`) to execute the Python script using `ngspy`. The working directory is set to `${CMAKE_CURRENT_SOURCE_DIR}`, and a timeout is configured using `set_tests_properties` and the `${NGS_TEST_TIMEOUT}` variable. It requires `NETGEN_USE_MPI` to be enabled.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/mpi/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif(NETGEN_USE_MPI)\n     include(CTest)\n     foreach(py_test mpi_poisson.py mpi_cmagnet.py mpi_timeDG.py mpi_navierstokes.py)\n       add_test(NAME ${py_test} COMMAND mpirun -np 5 --allow-run-as-root ngspy ${py_test} WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n       set_tests_properties ( ${py_test} PROPERTIES TIMEOUT ${NGS_TEST_TIMEOUT} )\n     endforeach()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Results of Koiter Shell Model After Load Steps (Python)\nDESCRIPTION: This snippet, similar to the previous visualization snippet, draws the displacement component of the `solution` GridFunction on the deformed mesh. This is used to visualize the final deformed state of the shell after applying multiple load steps.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nDraw(solution.components[0], mesh, \"disp\", deformation=solution.components[0]);\n```\n\n----------------------------------------\n\nTITLE: Add Dependencies for Documentation Targets\nDESCRIPTION: Adds dependencies to the `docs` and `docs_latex` targets. These targets now depend on the `link_mylittlengs` target, ensuring that the symbolic link is created before building the documentation. This is conditional upon `NETGEN_USE_PYTHON`, `SPHINX_FOUND`, and the absence of `WIN32`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT WIN32)\n        add_dependencies(docs link_mylittlengs)\n        add_dependencies(docs_latex link_mylittlengs)\n      endif(NOT WIN32)\n```\n\n----------------------------------------\n\nTITLE: Add Custom Pytest Target with CMake\nDESCRIPTION: This CMake snippet creates a custom target named `pytest` using `add_custom_target`. This allows running pytest as a specific build target.  The target runs the pytest command using the specified Python executable and arguments.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/pytest/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(NETGEN_USE_PYTHON)\n  add_test(NAME pytest COMMAND ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n  if(NETGEN_USE_MPI)\n    add_test(NAME mpi_pytest COMMAND mpirun -np 5 --allow-run-as-root ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/mpi_only )\n    set_tests_properties ( mpi_pytest PROPERTIES TIMEOUT 60 )\n  endif()\n  set_tests_properties ( pytest PROPERTIES TIMEOUT 1500 )\n  add_custom_target(pytest ${NETGEN_PYTHON_EXECUTABLE} -m pytest --durations=20 --ignore=mpi_only WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\nendif(NETGEN_USE_PYTHON)\n```\n\n----------------------------------------\n\nTITLE: Setting Library Name Conditionally - CMake\nDESCRIPTION: This snippet defines the library name based on whether the current project is 'NGSolve' or 'ngscuda'. If it's not 'NGSolve', it also searches for NGSolve and sets the CMAKE_INSTALL_PREFIX if it hasn't been explicitly set. This allows building the library as part of NGSolve or as a standalone project.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_PROJECT_NAME STREQUAL \"NGSolve\")\n  cmake_minimum_required(VERSION 3.18)\n  project(ngscuda)\n  find_package(NGSolve)\n  if (CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)\n    set(CMAKE_INSTALL_PREFIX \"${NGSOLVE_INSTALL_DIR}\" CACHE PATH \"Install directory\" FORCE)\n  endif()\n  set(lib_name ngscudalib_local)\nelse()\n  set(lib_name ngscudalib)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Setting Installation Directories\nDESCRIPTION: Defines installation directories for various components of NGSolve, including binaries, libraries, and CMake configuration files. It uses the `install` command with the `EXPORT` option to specify the installation locations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_23\n\nLANGUAGE: cmake\nCODE:\n```\nset(ngs_install_dir EXPORT ngsolve-targets RUNTIME DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve LIBRARY DESTINATION ${NGSOLVE_INSTALL_DIR_LIB} COMPONENT ngsolve_devel ARCHIVE DESTINATION ${NGSOLVE_INSTALL_DIR_LIB} COMPONENT ngsolve_devel )\ninstall(EXPORT ngsolve-targets DESTINATION ${NGSOLVE_INSTALL_DIR_CMAKE} COMPONENT ngsolve_devel)\n```\n\n----------------------------------------\n\nTITLE: Differentiating a CoefficientFunction with Respect to a Parameter\nDESCRIPTION: This snippet demonstrates how to differentiate a CoefficientFunction with respect to a `Parameter`.  It calculates the partial derivative of `f` with respect to `k`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint (f.Diff(k))\n```\n\n----------------------------------------\n\nTITLE: Define Custom Target for Unit Tests (CMake)\nDESCRIPTION: This snippet defines a custom target named `unit_tests`. It serves as a placeholder to group all unit test executables and ensure they are built when the `unit_tests` target is specified. The `add_custom_target` command creates a target that does not correspond to a specific file but can be used to trigger other actions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/catch/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(unit_tests)\n```\n\n----------------------------------------\n\nTITLE: Initializing the Initial Condition - Python\nDESCRIPTION: This snippet initializes the `u_last` `GridFunction` with the initial condition by restricting the exact solution `u_exact` to the initial time (`tref=0`). The `fix_tref` function is used to set the reference time in the space-time function.  The time variable `told` is also set to zero.  It is important that `u_last` is a function of space only, while `u_exact` depends on space and time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nu_last.Set(fix_tref(u_exact, 0))\ntold.Set(0.)\n```\n\n----------------------------------------\n\nTITLE: Setting CMAKE_MODULE_PATH\nDESCRIPTION: Sets the CMAKE_MODULE_PATH variable to include custom CMake modules located in the \"cmake/cmake_modules\" directory within the source directory. This allows CMake to find custom functions and macros defined in those modules.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_MODULE_PATH \"${CMAKE_MODULE_PATH}\" \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_modules\")\n```\n\n----------------------------------------\n\nTITLE: Printing a Compiled CoefficientFunction\nDESCRIPTION: This snippet prints the compiled `CoefficientFunction` (`myfunc_compiled`), showing the linear sequence of steps resulting from the compilation process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nprint(myfunc_compiled)\n```\n\n----------------------------------------\n\nTITLE: Adding Python Tests\nDESCRIPTION: This CMake snippet defines tests for various Python scripts. It iterates through a list of Python files and creates a test for each one using the `add_test` command. The `COMMAND` argument specifies the command to execute (using the configured Python executable) and the `WORKING_DIRECTORY` argument sets the working directory for the test. It also sets a timeout property for each test.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(CTest)\nforeach(py_test assemble.py bla.py poisson.py adaptive.py cmagnet.py mixed.py hybrid_dg.py taskmanager.py compound.py pickling.py)\n  add_test(NAME ${py_test} COMMAND ${NETGEN_PYTHON_EXECUTABLE} ${py_test} WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n  set_tests_properties ( ${py_test} PROPERTIES TIMEOUT ${NGS_TEST_TIMEOUT} )\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Defining Mixed Finite Element Spaces\nDESCRIPTION: This snippet defines the finite element spaces for the mixed formulation. It uses `HDiv` for the flux (sigma) and `L2` for the scalar variable (u). The product space `fesm` is created by multiplying these individual spaces. Essential boundary conditions are set for the H(Div) component.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\norder_flux=1\nV = HDiv(mesh, order=order_flux, dirichlet=\"right|top|left\")\nQ = L2(mesh, order=order_flux-1)\nfesm = V*Q\n```\n\n----------------------------------------\n\nTITLE: Conditional Kernel Generator Command (EMSCRIPTEN)\nDESCRIPTION: This snippet conditionally defines the command for generating kernel files based on whether the target environment is EMSCRIPTEN. If EMSCRIPTEN is defined, it uses g++ to compile the generator. Otherwise, it adds an executable target.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(EMSCRIPTEN)\n  add_custom_command(OUTPUT kernel_generator\n    COMMAND g++ -std=c++17 ${CMAKE_CURRENT_SOURCE_DIR}/generate_mat_kernels.cpp -o ${CMAKE_CURRENT_BINARY_DIR}/kernel_generator\n    )\n  set(kernel_command ${CMAKE_CURRENT_BINARY_DIR}/kernel_generator)\nelse(EMSCRIPTEN)\n  add_executable(kernel_generator generate_mat_kernels.cpp)\n  set(kernel_command kernel_generator)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Integrator on Selected Elements - Python\nDESCRIPTION: This snippet defines an integrator on a subset of elements using the `definedonelements` keyword argument. This allows setting up the finite element formulation only on a selection of elements. The BitArray passed to `definedonelements` is taken by reference, so changes to the `CutInfo` will automatically update the elements the integrator acts on.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nintegrator = VhR.TrialFunction()*VhR.TestFunction() * dx(definedonelements=ci.GetElementsOfType(HASNEG))\nprint(ci.GetElementsOfType(HASNEG))\n```\n\n----------------------------------------\n\nTITLE: Defining Spaces, Forms, and Solving (Python)\nDESCRIPTION: This code snippet demonstrates the definition of finite element spaces, bilinear and linear forms, and the solution of the linear system in parallel using NGSolve. It creates an H1 space, defines a bilinear form for the Laplacian, and a linear form for the source term. A CG solver is used to solve the resulting linear system. The preconditioner helps to speed up the solver. This code relies on NGSolve's parallel capabilities to distribute the computation across the cluster.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n%%px\nfes = H1(mesh, order=3, dirichlet=\".*\")\nu,v = fes.TnT()\n\na = BilinearForm(grad(u)*grad(v)*dx)\npre = Preconditioner(a, \"local\")\na.Assemble()\n\nf = LinearForm(1*v*dx).Assemble()\ngfu = GridFunction(fes)\n\nfrom ngsolve.krylovspace import CGSolver\ninv = CGSolver(a.mat, pre.mat, printrates=comm.rank==0, maxiter=200, tol=1e-8)\ngfu.vec.data = inv*f.vec\n```\n\n----------------------------------------\n\nTITLE: Visualizing Eigenfunction - Python\nDESCRIPTION: This snippet selects an eigenfunction based on its eigenvalue (closest to 6j) and visualizes it using NGSolve's Draw function. A GridFunction is initialized on the finite element space, and the data from the selected eigenvector is assigned to it. The complex eigenfunction is visualized, and deformation and scaling are applied.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\nind = np.absolute(np.asarray(lams)-6j).argmin()\ngfu.vec.data = Z[ind]\nDraw (gfu, animate_complex=True, deformation=True, scale=2);\n```\n\n----------------------------------------\n\nTITLE: Set Mesh Size on Surface of Solid in Netgen\nDESCRIPTION: This snippet demonstrates refining the mesh on the surface of a specific solid using the maxh() method as a property of the solid. This allows focusing mesh refinement on particular boundaries or surfaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\n\nbrick = OrthoBrick(Pnt(-2,-2,-2),Pnt(2,2,2))\nsphere = Sphere(Pnt(0,0,0),1)\n\ngeo.Add(brick-sphere)\ngeo.Add(sphere.maxh(0.1))\nngmesh = geo.GenerateMesh()\n```\n\n----------------------------------------\n\nTITLE: Custom Block Inverse Operator for Fast Conversion (Python)\nDESCRIPTION: This snippet implements a custom linear operator for fast conversion between finite element spaces using Gauss-Seidel smoothing.  It defines a `MyBlockInverse` class that inherits from `BaseMatrix` and performs block Gauss-Seidel iterations. The class implements Mult and MultTrans, for applying the inverse and its transpose.  It relies on precomputed block smoothers for edges and faces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass MyBlockInverse(BaseMatrix):\n    def __init__ (self, mat, eblocks, fblocks):\n        super(MyBlockInverse, self).__init__()\n        self.mat = mat\n        self.einv = mat.CreateBlockSmoother(eblocks)\n        self.finv = mat.CreateBlockSmoother(fblocks)\n        self.res = self.mat.CreateColVector()\n\n    def CreateRowVector(self):\n        return self.mat.CreateColVector()\n    def CreateColVector(self):\n        return self.mat.CreateRowVector()\n        \n    def Mult(self, x, y):\n        # y[:] = 0\n        # self.einv.Smooth(y,x)    #   y = y +  A_E^-1  (x - A y)\n        # self.finv.Smooth(y,x)    #   y = y +  A_E^-1  (x - A y)\n        \n        # the same, but we see how to transpose that\n        y.data = self.einv * x\n        self.res.data = x - self.mat * y\n        y.data += finv * self.res\n\n    def MultTrans(self, x, y):\n        y.data = self.finv.T * x\n        self.res.data = x - self.mat.T * y\n        y.data += einv.T * self.res\n\n\neblocks = [feshdiv.GetDofNrs(edge) for edge in mesh.edges]\nfblocks = [feshdiv.GetDofNrs(face) for face in mesh.faces]\n\ntransform = MyBlockInverse(ahdiv.mat, eblocks, fblocks) @ amixed.mat\ngfuhdiv.vec.data = transform * gfuh1.vec\n```\n\n----------------------------------------\n\nTITLE: Find Primal DOFs (Vertices) - NGSolve/Python\nDESCRIPTION: Identifies the primal degrees of freedom (DOFs), specifically vertices, in a finite element mesh using parallel processing. It determines subdomain faces, edges (intersections of faces), and vertices (intersections of edges).  It then uses MPI communication to ensure that a DOF is flagged as a vertex if any rank identifies it as such. The `pythonic` variable controls whether to use list comprehensions or for loops.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npythonic = True\nif pythonic:\n    faces = [set(d for d in pardofs.Proc2Dof(p) if d<mesh.nv and fes.FreeDofs()[d] ) for p in pardofs.ExchangeProcs()]\n    edges = sorted([tuple(sorted(e)) for e in set(tuple(f1.intersection(f2)) for f1 in faces for f2 in faces if f1 is not f2) if len(e)>1])\n    vertices = sorted(set([ v for e1 in edges for e2 in edges if e1 is not e2 for v in set(e1).intersection(set(e2)) ]))\nelse:\n    faces = []\n    for p in pardofs.ExchangeProcs():\n        faces.append(set(d for d in pardofs.Proc2Dof(p) if d<mesh.nv and fes.FreeDofs()[d]))\n    edges = []\n    for f1 in faces:\n        for f2 in faces:\n            if f1 is not f2:\n                edge = sorted(tuple(f1.intersection(f2)))\n                if len(edge) > 1:\n                    if not edge in edges:\n                        edges.append(sorted(tuple(edge)))\n    vertices = set()\n    for e1 in edges:\n        for e2 in edges:\n            if e1 is not e2:\n                vs = set(e1).intersection(set(e2))\n                vertices = vertices.union(vs)\n    vertices = sorted(vertices)\n```\n\n----------------------------------------\n\nTITLE: Defining the geometry and mesh in NGSolve\nDESCRIPTION: This code creates a circular geometry using SplineGeometry and generates a mesh with a specified maximum element size.  The Draw function is used to visualize the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\ngeo.AddCircle(c=(0.5,0.5), r=0.5, bc = 'circle')\nmesh = Mesh(geo.GenerateMesh(maxh = 0.08))\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Setting Additional Paths for Libraries\nDESCRIPTION: This snippet allows users to specify additional paths to libraries in non-standard locations using the ADDITIONAL_PATHS cache variable. If ADDITIONAL_PATHS is set, the CMAKE_PREFIX_PATH is updated to include these paths.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_21\n\nLANGUAGE: cmake\nCODE:\n```\nset(ADDITIONAL_PATHS \"\" CACHE PATH \"List of paths to additional libraries in non-standard locations, separated by ';'\")\nif (ADDITIONAL_PATHS)\n  set(CMAKE_PREFIX_PATH ${ADDITIONAL_PATHS})\nendif (ADDITIONAL_PATHS)\n```\n\n----------------------------------------\n\nTITLE: Additive Multilevel Preconditioner Class - Python\nDESCRIPTION: This code defines a class `MLPreconditioner` that implements an additive multilevel preconditioner. It uses a recursive approach to construct the preconditioner, combining a local smoother with a coarse-grid correction. The `Mult` method applies the preconditioner to a vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass MLPreconditioner(BaseMatrix):\n    def __init__ (self, fes, level, mat, coarsepre):\n        super().__init__()\n        self.fes = fes\n        self.level = level\n        self.mat = mat\n        self.coarsepre = coarsepre\n        if level > 0:\n            self.localpre = mat.CreateSmoother(fes.FreeDofs())\n        else:\n            self.localpre = mat.Inverse(fes.FreeDofs())\n        \n    def Mult (self, x, y):\n        \"\"\"Return y = C[l] * x = (inv(D) + P * C[l-1] * P.T) * x \n           when l>0 and inv(A[0]) * x when l=0. \"\"\"\n        if self.level == 0:\n            y.data = self.localpre * x\n            return\n        hx = x.CreateVector(copy=True)        \n        self.fes.Prolongation().Restrict(self.level, hx)  # hx <- P.T * x\n        cdofs = self.fes.Prolongation().LevelDofs(self.level-1)\n        y[cdofs] = self.coarsepre * hx[cdofs]             # y = C[l-1] * hx  \n        self.fes.Prolongation().Prolongate(self.level, y) # y <- P * C[l-1] * P.T * x\n        y += self.localpre * x                            # y += inv(D) * x\n\n    def Shape (self):\n        return self.localpre.shape\n    def CreateVector (self, col):\n        return self.localpre.CreateVector(col)\n```\n\n----------------------------------------\n\nTITLE: Integrating a CoefficientFunction Numerically\nDESCRIPTION: This snippet numerically integrates the `myfunc` CoefficientFunction over the mesh using the `Integrate` function.  The `order` parameter specifies the precision of the quadrature rule used for the integration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nIntegrate(myfunc, mesh, order=5)\n```\n\n----------------------------------------\n\nTITLE: Defining Cut Differential Symbols\nDESCRIPTION: This snippet defines cut integration measures dx and ds for volume and boundary integrals respectively, utilizing the `dCut` functionality. Additionally, `dFacetPatch` is used to define integration over ghost penalty facets. The integration measures are restricted to specific element sets.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.7-mlset_pde/mlset_pde.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndx = dCut(level_sets_p1, square, definedonelements=els_hasneg)\nds = {dtt: dCut(level_sets_p1, dtt, definedonelements=els_if_single[dtt])\n      for dtt in boundary}\ndw = dFacetPatch(definedonelements=facets_gp)\n```\n\n----------------------------------------\n\nTITLE: Applying LGPL v2.1 to a New Library\nDESCRIPTION: This snippet provides the necessary notices to attach to a new library when applying the GNU Lesser General Public License v2.1. It includes copyright information, license terms, warranty disclaimer, and contact information for the Free Software Foundation. This ensures that the library is properly licensed and that users are aware of the terms of use.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/cmake/resources/LICENSE.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n<one line to give the library's name and a brief idea of what it does.>\nCopyright (C) <year>  <name of author>\n\nThis library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense as published by the Free Software Foundation; either\nversion 2.1 of the License, or (at your option) any later version.\n\nThis library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public\nLicense along with this library; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n```\n\n----------------------------------------\n\nTITLE: Estimating eigenvalues with coarse grid preconditioner\nDESCRIPTION: This snippet attempts to estimate eigenvalues using the `EigenValues_Preconditioner` function with only a coarse grid preconditioner.  It is noted that this alone does not provide meaningful preconditioning.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nEigenValues_Preconditioner(mat=a.mat, pre=coarsepre)\n```\n\n----------------------------------------\n\nTITLE: Solving and Post-processing FETI-DP\nDESCRIPTION: This snippet demonstrates solving the FETI-DP system and post-processing the solution. It initializes the MPI communicator, loads the mesh, sets up the finite element space, constructs the FETI-DP matrices, prepares the right-hand side, solves the system using a conjugate gradient (CG) solver, and performs post-processing to evaluate the jump in the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n%%px\ncomm = MPI_Init()\nmesh = load_mesh(nref=1)\nfes, a, f = setup_space(mesh, order=2)\nA_dp, A_dp_inv, F, Fhat, B, scaledA, scaledBT = setup_FETIDP(fes, a)\nrhs = B.CreateColVector()\nlam = B.CreateColVector()\nprep(B, A_dp_inv, f)\nif comm.rank==0:\n    print('')\nt = solve(F,  Fhat,  rhs, lam)\nif comm.rank==0:\n    print('\\ntime solve: ', t)\n    print('dofs per core and second: ', fes.ndofglobal / (t * comm.size))    \ngfu = GridFunction(fes)\npost(B, A_dp_inv, gfu, lam)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for NGSolve and XFEM - Python\nDESCRIPTION: This snippet imports necessary libraries from NGSolve, XFEM, and standard Python modules. These libraries provide functionality for finite element analysis, mesh generation, and numerical computations.  Specifically, it imports netgen.geom2d for mesh generation, ngsolve for FEM functionality, xfem for space-time FEM, time for timing information and pi from math.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import unit_square\nfrom ngsolve import *\nfrom xfem import *\nimport time\nfrom math import pi\nngsglobals.msg_level = 1\n```\n\n----------------------------------------\n\nTITLE: Cloning NGSolve Repository - Bash\nDESCRIPTION: This snippet demonstrates how to clone the NGSolve repository from GitHub using git. The `--recurse-submodules` option ensures that all submodules are also cloned. The current directory must be the value specified by the NGROOT variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd $NGROOT\ngit clone --recurse-submodules https://github.com/NGSolve/ngsolve.git ngsolve-src\n```\n\n----------------------------------------\n\nTITLE: Help Function in Python\nDESCRIPTION: Shows the documentation of fes\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nhelp(fes)\n```\n\n----------------------------------------\n\nTITLE: Visualize Nonlinear Elasticity Solution\nDESCRIPTION: Visualizes the solution of the nonlinear elasticity problem, interpolating between the stored load steps and animating the deformation. It uses the `Draw` function with appropriate parameters for multi-dimensional data and deformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu_l,mesh, interpolate_multidim=True, animate=True, \n     deformation=True, min=0, max=1, autoscale=False)\n```\n\n----------------------------------------\n\nTITLE: Accessing boundary regions by name\nDESCRIPTION: This snippet demonstrates accessing boundary regions within the mesh using `mesh.Boundaries(name)`. This function returns a `Region` object that corresponds to the specified boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmesh.Boundaries(\"b\")\n```\n\n----------------------------------------\n\nTITLE: Alternative way to declare Test and Trial Functions\nDESCRIPTION: This snippet declares both trial and test function simultaneously using `fes.TnT()`\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nu, v = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Plotting Eigenvalues\nDESCRIPTION: This snippet plots the real and imaginary parts of the computed eigenvalues in the complex plane using Matplotlib.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nlamr = [sqrt(l).real for l in lam]\nlami = [sqrt(l).imag for l in lam]\nplt.plot(lamr, lami, \".\")\nplt.grid(True)\nplt.title('Computed $\\omega$ values')\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Drawing with eval_function - Python\nDESCRIPTION: This snippet demonstrates using the `eval_function` argument to modify the function values in the WebGL fragment shader. It defines a GLSL expression that depends on position, and visualizes a CoefficientFunction (CF) with specified min, max, and camera settings.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\neval_function = \"p.x*p.x+p.y*p.y+p.z*p.z < 0.5 ? 1. : sin(100.0*p.x)\"\nDraw(CF(1), m, \"func\", eval_function=eval_function, min=-1, max=1, settings={\"camera\": {\"transformations\": [{\"type\": \"rotateY\", \"angle\": 45}]}})\n```\n\n----------------------------------------\n\nTITLE: Printing Local Matrix and ParallelDofs Information\nDESCRIPTION: This snippet prints information about the local matrix contribution of an MPI rank and its associated `ParallelDofs` objects. It accesses the local matrix using `a.mat.local_mat` and prints its type and dimensions.  It also prints the `row_pardofs`, `col_pardofs` and the FESpace's pardofs\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nprint('a.mat.local_mat on rank', comm.rank, 'is a', type(a.mat.local_mat), 'of dimensions', a.mat.local_mat.height, a.mat.local_mat.width)\nprint('lcoal fes ndof: ', fes.ndof)\nprint('a.mat.row_pardofs: ', a.mat.row_pardofs)\nprint('a.mat.col_pardofs: ', a.mat.col_pardofs)\nprint('fes pardofs:       ', fes.ParallelDofs())\n```\n\n----------------------------------------\n\nTITLE: Installing WebGUI Jupyter Widgets\nDESCRIPTION: This command installs the webgui_jupyter_widgets package using pip3, which provides extensions for visualizing NGSolve objects within Jupyter notebooks. This is necessary for the interactive visualization component.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/usejupyter.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip3 install webgui_jupyter_widgets\n```\n\n----------------------------------------\n\nTITLE: Drawing Geometry\nDESCRIPTION: This line visualizes the defined geometry. It requires the `shape` object to be defined beforehand, representing the geometric domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nDraw (shape);\n```\n\n----------------------------------------\n\nTITLE: Generating Background Mesh - Python\nDESCRIPTION: This snippet generates a background mesh for the domain using `SplineGeometry`. It creates a square domain and generates a mesh with a specified maximum element size and quad-dominated setting.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsquare = SplineGeometry()\nsquare.AddRectangle([-1.5,-1.5],[1.5,1.5],bc=1)\nmesh = Mesh (square.GenerateMesh(maxh=0.5, quad_dominated=False))\n```\n\n----------------------------------------\n\nTITLE: Solving Patchwise System in NGSolve (Python)\nDESCRIPTION: This code snippet demonstrates the usage of the `PatchwiseSolve` function in NGSolve to solve a system of equations patch-by-patch. It takes the element array (EA), finite element space (Zh), and the assembled left-hand side and right-hand side integrals as input.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ngfz.vec.data = PatchwiseSolve(EA,Zh,sum(lhs_integrals),sum(rhs_integrals))\n```\n\n----------------------------------------\n\nTITLE: Defining Couplings on Facets - Python\nDESCRIPTION: This code defines the couplings on the facets. It creates a bilinear form `c2` on the mixed space `V` with trial functions `uT`, `uF` and test functions in `VT`. The comment highlights that `uf-u` represents the neighbor value.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nuT,uF = V.TrialFunction() \nc2 = BilinearForm(trialspace=V, testspace=VT, nonassemble=True)   # part 2\n# here uf-u = u_me + u_other - u_me is the neighbor value\n```\n\n----------------------------------------\n\nTITLE: Determine Vertex Type\nDESCRIPTION: This snippet determines the type of the vertex object when iterating over `mesh.vertices`. It prints the type of `v` to the console, showing it is a `MeshNode` object. It reveals the class representing a vertex within the NGSolve framework.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor v in mesh.vertices:    \n    print(type(v))\n```\n\n----------------------------------------\n\nTITLE: Adding NETGENDIR to PATH (csh/tcsh)\nDESCRIPTION: This command adds the directory containing the Netgen executable to the `PATH` environment variable.  This allows you to run the `netgen` command from any location in the terminal without specifying the full path. This command is used for csh/tcsh shells.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nsetenv PATH \"$NETGENDIR:$PATH\"\n```\n\n----------------------------------------\n\nTITLE: Stopping the cluster in Python\nDESCRIPTION: Stops the parallel cluster. This is the cleanup step after the computation is complete, terminating all parallel processes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nstop_cluster()\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve Modules - Python\nDESCRIPTION: This snippet imports the necessary modules from the NGSolve library for finite element analysis. It includes modules for defining finite element spaces, bilinear forms, and linear algebra operations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.3-multigrid/multigrid.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.la import EigenValues_Preconditioner\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Space and GridFunctions for state and adjoint\nDESCRIPTION: This code defines the finite element space (fes) using H1 elements of order 2. It creates GridFunctions (gfu, gfp) to represent the state variable (u) and the adjoint variable (p), respectively. The Draw function visualizes these variables.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=2, dirichlet=\".*\")\ngfu = GridFunction(fes)\nscene_u = Draw (gfu, mesh, \"state\")\n\ngfp = GridFunction(fes)\nscene_p = Draw (gfp, mesh, \"adjoint\")\n```\n\n----------------------------------------\n\nTITLE: Javascript code example rotating the camera\nDESCRIPTION: This is the javascript code injected to rotate the camera around the y axis for the first 3 seconds.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n// Example: Rotate the view around the y axis for the first 3 seconds\n// print message in javascript console of the browser (open with F12 for Chrome and Firefox)\nconsole.log(\"hello from Javascript!\", \"Scene\", scene, \"render_data\", render_data)\n\n// hide geometry edges (see the 'Objects' menu in the GUI for entry names)\nscene.gui.settings.Objects['Edges'] = false\n\n// Track time since first draw\nlet t = 0;\nconst speed = 90*Math.PI/180;\n\n// Register a callback function to the scene, which is called after a frame is rendered\nscene.on(\"afterrender\", (scene, dt) => {\n  t += dt;\n  if(t<3) {\n    console.log(`time since last frame: ${dt} seconds`, \"total time: \", t, \"seconds\")\n\n    // rotate around y axis\n    scene.controls.rotateObject(new modules.THREE.Vector3(0,1,0), dt*speed)\n\n    // recalculate transformation matrices, also triggers rerendering of scene\n    scene.controls.update();\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: CUDA Kernel for Applying IP Function (C++)\nDESCRIPTION: This C++ code represents a CUDA kernel generated from an NGSolve bilinear form. It performs a series of operations on input data to compute the output, utilizing shared memory and thread parallelism. The code includes steps like coefficient function evaluation, scalar-vector multiplication, matrix operations, and reshapes, all optimized for GPU execution. This code requires a CUDA compiler (nvcc) and the CUDA runtime environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstddef>\n__global__ void ApplyIPFunctionKernel (size_t nip, double * input, size_t dist_input,\n                                       double * output, size_t dist_output) {\n  {\n    auto values_0 = [dist_input,input](size_t i, int comp)\n      { return input[i + (comp+0)*dist_input]; };\n    bool constexpr has_values_0 = true;\n\n    int tid = blockIdx.x*blockDim.x+threadIdx.x;\n    for (int i = tid; i < nip; i += blockDim.x*gridDim.x) {\n      // step 0: trial-function diffop = Id\n      double var_0_0(0x0p+0 /* (0.0000000000000000e+00) */);\n      var_0_0 = 0.0;\n      double var_0_1(0x0p+0 /* (0.0000000000000000e+00) */);\n      var_0_1 = 0.0;\n      double var_0_2(0x0p+0 /* (0.0000000000000000e+00) */);\n      var_0_2 = 0.0;\n      double var_0_3(0x0p+0 /* (0.0000000000000000e+00) */);\n      var_0_3 = 0.0;\n\n      if (has_values_0) {\n        var_0_0 = values_0(i,0);\n        var_0_1 = values_0(i,1);\n        var_0_2 = values_0(i,2);\n        var_0_3 = values_0(i,3);\n      }\n      // step 1: ComponentCoefficientFunction 0\n      double var_1;\n      var_1 = var_0_0;\n      // step 2: 1\n      double var_2;\n      var_2 = 0x1p+0 /* (1.0000000000000000e+00) */;\n      // step 3: binary operation '/'\n      double var_3;\n      var_3 = var_2 / var_1;\n      // step 4: subtensor [ first: 1, num: ( 2,), dist: ( 1,) ]\n      double var_4_0;\n      double var_4_1;\n      var_4_0 = var_0_1;\n      var_4_1 = var_0_2;\n      // step 5: scalar-vector multiply\n      double var_5_0;\n      double var_5_1;\n      var_5_0 = (var_3 * var_4_0);\n      var_5_1 = (var_3 * var_4_1);\n      // step 6: scalar-vector multiply\n      double var_6_0;\n      double var_6_1;\n      var_6_0 = (var_1 * var_5_0);\n      var_6_1 = (var_1 * var_5_1);\n      // step 7: reshape\n      double var_7_0_0;\n      double var_7_1_0;\n      var_7_0_0 =  (var_5_0);\n      var_7_1_0 =  (var_5_1);\n      // step 8: reshape\n      double var_8_0_0;\n      double var_8_0_1;\n      var_8_0_0 =  (var_5_0);\n      var_8_0_1 =  (var_5_1);\n      // step 9: matrix-matrix multiply\n      double var_9_0_0;\n      double var_9_0_1;\n      double var_9_1_0;\n      double var_9_1_1;\n      var_9_0_0 = ((var_7_0_0 * var_8_0_0));\n      var_9_0_1 = ((var_7_0_0 * var_8_0_1));\n      var_9_1_0 = ((var_7_1_0 * var_8_0_0));\n      var_9_1_1 = ((var_7_1_0 * var_8_0_1));\n      // step 10: scalar-matrix multiply\n      double var_10_0_0;\n      double var_10_0_1;\n      double var_10_1_0;\n      double var_10_1_1;\n      var_10_0_0 = (var_1 * var_9_0_0);\n      var_10_0_1 = (var_1 * var_9_0_1);\n      var_10_1_0 = (var_1 * var_9_1_0);\n      var_10_1_1 = (var_1 * var_9_1_1);\n      // step 11: ComponentCoefficientFunction 3\n      double var_11;\n      var_11 = var_0_3;\n      // step 12: 2\n      double var_12;\n      var_12 = 0x1p+1 /* (2.0000000000000000e+00) */;\n      // step 13: binary operation '/'\n      double var_13;\n      var_13 = var_1 / var_12;\n      // step 14: innerproduct, fix size = 2\n      double var_14;\n      var_14 = (((var_5_0 * var_5_0)) + (var_5_1 * var_5_1));\n      // step 15: binary operation '*'\n      double var_15;\n      var_15 = var_13 * var_14;\n      // step 16: binary operation '-'\n      double var_16;\n      var_16 = var_11 - var_15;\n      // step 17: scale 0.4\n      double var_17;\n      var_17 = (0x1.9999999999998p-2 /* (3.9999999999999991e-01) */ * var_16);\n      // step 18: Identity matrix\n      double var_18_0_0;\n      double var_18_0_1;\n      double var_18_1_0;\n      double var_18_1_1;\n      var_18_0_0 = 1.0;\n      var_18_0_1 = 0.0;\n      var_18_1_0 = 0.0;\n      var_18_1_1 = 1.0;\n      // step 19: scalar-matrix multiply\n      double var_19_0_0;\n      double var_19_0_1;\n      double var_19_1_0;\n      double var_19_1_1;\n      var_19_0_0 = (var_17 * var_18_0_0);\n      var_19_0_1 = (var_17 * var_18_0_1);\n      var_19_1_0 = (var_17 * var_18_1_0);\n      var_19_1_1 = (var_17 * var_18_1_1);\n      // step 20: binary operation '+'\n      double var_20_0_0;\n      double var_20_0_1;\n      double var_20_1_0;\n      double var_20_1_1;\n      var_20_0_0 = var_10_0_0 + var_19_0_0;\n      var_20_0_1 = var_10_0_1 + var_19_0_1;\n      var_20_1_0 = var_10_1_0 + var_19_1_0;\n      var_20_1_1 = var_10_1_1 + var_19_1_1;\n      // step 21: binary operation '+'\n      double var_21;\n      var_21 = var_11 + var_17;\n      // step 22: scalar-vector multiply\n      double var_22_0;\n      double var_22_1;\n      var_22_0 = (var_21 * var_5_0);\n      var_22_1 = (var_21 * var_5_1);\n      // step 23: VectorialCoefficientFunction\n      double var_23_0;\n      double var_23_1;\n      double var_23_2;\n      double var_23_3;\n      double var_23_4;\n      double var_23_5;\n      double var_23_6;\n      double var_23_7;\n      var_23_0 = var_6_0;\n      var_23_1 = var_6_1;\n      var_23_2 = var_20_0_0;\n      var_23_3 = var_20_0_1;\n      var_23_4 = var_20_1_0;\n      var_23_5 = var_20_1_1;\n      var_23_6 = var_22_0;\n      var_23_7 = var_22_1;\n      // step 24: unary operation ' '\n      double var_24_0;\n      double var_24_1;\n      double var_24_2;\n      double var_24_3;\n      double var_24_4;\n      double var_24_5;\n      double var_24_6;\n      double var_24_7;\n      var_24_0 =  (var_23_0);\n      var_24_1 =  (var_23_1);\n      var_24_2 =  (var_23_2);\n      var_24_3 =  (var_23_3);\n      var_24_4 =  (var_23_4);\n      var_24_5 =  (var_23_5);\n      var_24_6 =  (var_23_6);\n      var_24_7 =  (var_23_7);\n      // step 25: reshape\n      double var_25_0_0;\n      double var_25_0_1;\n      double var_25_1_0;\n      double var_25_1_1;\n      double var_25_2_0;\n      double var_25_2_1;\n      double var_25_3_0;\n      double var_25_3_1;\n      var_25_0_0 =  (var_24_0);\n      var_25_0_1 =  (var_24_1);\n      var_25_1_0 =  (var_24_2);\n      var_25_1_1 =  (var_24_3);\n      var_25_2_0 =  (var_24_4);\n      var_25_2_1 =  (var_24_5);\n      var_25_3_0 =  (var_24_6);\n      var_25_3_1 =  (var_24_7);\n      // step 26: scale -1\n      double var_26_0_0;\n      double var_26_0_1;\n      double var_26_1_0;\n      double var_26_1_1;\n      double var_26_2_0;\n      double var_26_2_1;\n      double var_26_3_0;\n      double var_26_3_1;\n      var_26_0_0 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_0_0);\n      var_26_0_1 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_0_1);\n      var_26_1_0 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_1_0);\n      var_26_1_1 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_1_1);\n      var_26_2_0 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_2_0);\n      var_26_2_1 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_2_1);\n      var_26_3_0 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_3_0);\n      var_26_3_1 = (-0x1p+0 /* (-1.0000000000000000e+00) */ * var_25_3_1);\n\n      output[i+0*dist_output] = var_26_0_0;\n      output[i+1*dist_output] = var_26_0_1;\n      output[i+2*dist_output] = var_26_1_0;\n      output[i+3*dist_output] = var_26_1_1;\n      output[i+4*dist_output] = var_26_2_0;\n      output[i+5*dist_output] = var_26_2_1;\n      output[i+6*dist_output] = var_26_3_0;\n      output[i+7*dist_output] = var_26_3_1;\n    }\n  }}\nextern \"C\" void ApplyIPFunction (size_t nip, double * input, size_t dist_input,\n                                 double * output, size_t dist_output) {\n  ApplyIPFunctionKernel<<<256,256>>> (nip, input, dist_input, output, dist_output); }\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Distributed GridFunction (Python)\nDESCRIPTION: This code snippet demonstrates how to access the distributed `GridFunction` from the `ipyparallel` client. It retrieves the `gfu` variable from all engines in the cluster and stores it in a list. `gfu` now is a list of `GridFunction` objects, where `gfu[i]` represents the grid function on the process with rank `i`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ngfu = c[:][\"gfu\"]\n```\n\n----------------------------------------\n\nTITLE: Solving Koiter Shell Model with Newton's Method (Python)\nDESCRIPTION: This snippet solves the nonlinear Koiter shell model using Newton's method. It sets the load parameter `par`, updates the averaged normal vector `averednv`, and iteratively solves the system using `solvers.Newton`. The `inverse=\"sparsecholesky\"` argument specifies the linear solver to use.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\npar.Set(0.1)\naverednv.Set((1 - gfclamped) * cfnphys + gfclamped * nsurf,\n            definedon=mesh.Boundaries(\".*\"),\n            dual=True,\n        )\n\nwith TaskManager():\n    solvers.Newton(bfA, solution, inverse=\"sparsecholesky\", maxerr=1e-10, maxit=20)\n```\n\n----------------------------------------\n\nTITLE: Getting Dual-Primal Inverse\nDESCRIPTION: This snippet retrieves the dual-primal inverse using the `DPSpace_Inverse` class. It sets up the point-constraints, the constraint matrix, ParallelDofs for `w`, and the inverse types for local and global problems. Requires `dd_toolbox`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom dd_toolbox import DPSpace_Inverse\nA_dp_inv = DPSpace_Inverse(mat=a.mat, freedofs=fes.FreeDofs(), \\\n                           c_points=primal_dofs, \\\n                           c_mat=B_p, c_pardofs=eavg_pardofs, \\\n                           invtype_loc='sparsecholesky', \\\n                           invtype_glob='masterinverse')\n```\n\n----------------------------------------\n\nTITLE: Defining Symmetric Gauss-Seidel Preconditioner\nDESCRIPTION: Defines a class `SymmetricGS` that implements a symmetric Gauss-Seidel preconditioner. It inherits from `BaseMatrix` and takes a smoother object as input. The `Mult` method performs a forward and backward Gauss-Seidel sweep.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass SymmetricGS(BaseMatrix):\n    def __init__ (self, smoother):\n        super(SymmetricGS, self).__init__()\n        self.smoother = smoother\n    def Mult (self, x, y):\n        y[:] = 0.0\n        self.smoother.Smooth(y, x)\n        self.smoother.SmoothBack(y,x)\n    def Height (self):\n        return self.smoother.height\n    def Width (self):\n        return self.smoother.height\n```\n\n----------------------------------------\n\nTITLE: Stopping the cluster in Python\nDESCRIPTION: Stops the existing parallel cluster. This is likely a utility function provided by the 'usrmeeting_jupyterstuff' module to terminate all parallel processes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstop_cluster()\n```\n\n----------------------------------------\n\nTITLE: Solving Evolution Equations with NewtonCF in ngsolve (Python)\nDESCRIPTION: This snippet demonstrates how to solve the nonlinear evolution equations at each quadrature point using `NewtonCF` in ngsolve. It compiles the evolution equations and defines parameters for the Newton-Raphson solver, including tolerance and maximum iterations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Parameters for evolution\ntol = Parameter(1e-10)\nmaxiter = 20\nevol_tol = tol\n\neqs = evolution_eqs(strain(gfu), p, alpha, Lambda, evol_tol).Compile(realcompile=realcompile)\nevolution = NewtonCF(eqs, gfint, tol=tol.Get(), maxiter=maxiter)\n```\n\n----------------------------------------\n\nTITLE: Explicit Yield Surface Implementation with ngsolve (Python)\nDESCRIPTION: This snippet sets up the finite element spaces and grid functions necessary for an elastoplastic model using an explicit yield surface in ngsolve. It defines spaces for stress, internal variables, and displacement, along with corresponding trial and test functions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfes_p = MatrixValued(fes_ir, symmetric=True, deviatoric=False, dim=3)\n\nfes_int = fes_p * fes_ir * fes_ir # p x alpha x Lambda\n\n# Trial and test functions\nu, u_test = fes_u.TnT()\nint_trial, int_test = fes_int.TnT()\np, alpha, Lambda = int_trial\n\n# GridFunction for \"external\" state\ngfu = GridFunction(fes_u)\n\n# GridFunction for internal states\ngfint = GridFunction(fes_int)\ngfp, gfalpha, gfLambda = gfint.components\n\n# For history states\ngfhist = GridFunction(fes_int)\ngfp_k, gfalpha_k, gfLambda_k = gfhist.components\n\n# \"Trial\" states for plastic evolution (these are not trial functions in FE parlance but elastic predictors)\ngftrial = GridFunction(fes_int)\ngfsigma_trial, gfbeta_trial, _ = gftrial.components\n\n# Time increment\nDelta_t = 1.0\n# Not really needed for a rate-independent model. Value could be used for scaling the equations though.\n\n# Short-hand for storing history variables. Note that the history value of Lambda is not relevant and thus omitted.\ndef store_internal():\n    gfp_k.Interpolate(gfp)\n    gfalpha_k.Interpolate(gfalpha)\n    gfLambda_k.Interpolate(gfLambda)\n```\n\n----------------------------------------\n\nTITLE: Defining Embedding Operators (NGSolve)\nDESCRIPTION: This snippet defines embedding operators between different finite element spaces (`VT`, `VF`, and `V`). `embT` and `embF` are embeddings from `VT` and `VF` into `V` respectively. The combined embedding `embV` is constructed using `embT`, `embF`, and a trace operator.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nembT = Embedding(V.ndof, V.Range(0))\nembF = Embedding(V.ndof, V.Range(1))\nembV = embT + embF @ trace\n```\n\n----------------------------------------\n\nTITLE: Targeted parallel execution with Jupyter magic %%px\nDESCRIPTION: This snippet illustrates targeted parallel execution using the `%%px` Jupyter magic command with the `--targets` option. It specifies that only workers with ranks 3 to 5 (inclusive) should execute the code. This enables selective execution on specific workers within the cluster.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.0-mpi_basics/MPI-Parallelization_in_NGSolve.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n%%px --targets 3:5\nprint('hello from some in the cluster')\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve modules\nDESCRIPTION: This snippet imports necessary modules from the NGSolve library, including functionalities for finite element analysis, web visualization, and CAD geometry from Netgen.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwellevp.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\n```\n\n----------------------------------------\n\nTITLE: Adding Boundary Elements in 1D\nDESCRIPTION: This code adds boundary elements (`Element0D`) to the mesh, representing the left and right boundaries of the one-dimensional domain.  It also defines regions for the left and right boundaries with assigned indices. The `Element0D` objects use the appropriate `PointId` objects.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nidx_left = m.AddRegion(\"left\", dim=0)\nidx_right = m.AddRegion(\"right\", dim=0)\n\nm.Add (Element0D (pnums[0], index=idx_left))\nm.Add (Element0D (pnums[N], index=idx_right))\n```\n\n----------------------------------------\n\nTITLE: Defining bilinear form using Equation\nDESCRIPTION: This code demonstrates an alternative way of defining the bilinear form using the 'Equation' function. This approach ensures consistency between the definition of the PDE and the bilinear form.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\naAuto = BilinearForm(fes, symmetric=True)\naAuto += Equation(u,v)\n```\n\n----------------------------------------\n\nTITLE: Printing Max Timer per Rank in NGSolve Python\nDESCRIPTION: Prints the maximum timer and corresponding rank if the timer's time exceeds a threshold. Targets ranks 0 to 20. Useful for identifying expensive operations performed by specific ranks.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n%%px --targets 0:20\nmaxt = max(Timers(), key=lambda t:t['time'])\nif maxt['time']>min(0.3*maxt['time'], 0.5):\n    print('max timer rank', comm.rank, ': ', maxt['name'], ' ', maxt['time'])\n```\n\n----------------------------------------\n\nTITLE: Setting up a Preconditioner\nDESCRIPTION: This snippet sets up a preconditioner for the assembled bilinear form. It creates a preconditioner object using `Preconditioner(a, 'hypre')`, which specifies the 'hypre' preconditioner. Alternatively, it includes a commented-out line to use the 'bddc' preconditioner with a 'mumps' inverse.  It then assembles the `a` BilinearForm.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\nc = Preconditioner(a, 'hypre')\n#c = Preconditioner(a, 'bddc', inverse='mumps')\na.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Print Top Timers - NGSolve/Python\nDESCRIPTION: Prints the names and times of the timers that exceeded 0.5 seconds, sorted by time in descending order, but only from target rank 1. This helps identify the most time-consuming operations in the code execution on that specific rank.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfor t in sorted(filter(lambda t:t['time']>0.5, Timers()), key=lambda t:t['time'], reverse=True):\n    print(t['name'], ':  ', t['time'])\n```\n\n----------------------------------------\n\nTITLE: Starting a cluster with Jupyter magic\nDESCRIPTION: This snippet starts a cluster of Python processes using the `usrmeeting_jupyterstuff` library, allocating a specified number of cores for the cluster. It requires the `usrmeeting_jupyterstuff` module to be available and configured for the Jupyter environment. The `start_cluster` function initiates the cluster, and `connect_cluster` establishes the connection to it.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.0-mpi_basics/MPI-Parallelization_in_NGSolve.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nnum_procs = '5'\nfrom usrmeeting_jupyterstuff import start_cluster, connect_cluster\nstart_cluster(num_procs)\nconnect_cluster()\n```\n\n----------------------------------------\n\nTITLE: Summing Local DOFs and Comparing to Global DOFs\nDESCRIPTION: This snippet calculates the sum of local degrees of freedom (DOFs) across all ranks and compares it to the global number of DOFs. It sums the local DOFs using `comm.Sum(fes.ndof)` and then prints a message from rank 0 indicating whether the sum of local DOFs is equal to the global number of DOFs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nnd2 = comm.Sum(fes.ndof)\nif comm.rank==0:\n    print('Strangely, the sum of all local DOFs is ', nd2, '!=', fes.ndofglobal)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Aggregation Embedding Matrix\nDESCRIPTION: This snippet demonstrates how to create and visualize the aggregation embedding matrix for a piecewise constant (L2) finite element space. It utilizes the AggEmbedding class and a helper function ShowPattern to display the matrix structure.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfes = L2(mesh, order=0)\nE = AggEmbedding(EA, fes)\nfrom helper import ShowPattern\nShowPattern(E)\nprint(E)\n```\n\n----------------------------------------\n\nTITLE: Refining the mesh for finer computations\nDESCRIPTION: This code snippet refines the mesh multiple times to increase the problem size.  It updates the finite element space and reassembles the matrix 'a' after each refinement. The number of degrees of freedom (NDOF) is printed after the refinement loop to show the increased problem size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(6):   # finer mesh updates & assembly\n    mesh.Refine()\n    fes.Update()\n    a.Assemble()\nprint('NDOF = ', fes.ndof)\n```\n\n----------------------------------------\n\nTITLE: Accessing Derivative Names\nDESCRIPTION: This snippet retrieves and prints the derivative names associated with the `GridFunction` objects for the H1, HDiv, and HCurl spaces. It demonstrates that function spaces know their canonical derivatives.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ngfu.derivname, ud.derivname, uc.derivname\n```\n\n----------------------------------------\n\nTITLE: Defining Inverse Mass Matrices\nDESCRIPTION: This snippet defines the inverse mass matrices for the pressure and velocity spaces. These are used in the explicit time-stepping scheme.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ninvmassp = fes_p.Mass(1).Inverse()\ninvmassu = fes_u.Mass(1).Inverse()\n```\n\n----------------------------------------\n\nTITLE: Defining Trial Function for Symbolic Energy minimization problem in ngsolve using python\nDESCRIPTION: This code snippet defines the trial function for the symbolic energy minimization problem. The `TrialFunction` is used to define the unknown variable in the variational formulation of the problem. This is the first step in setting up the minimization problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/symbolic_integrators.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nu = V.TrialFunction()\n```\n\n----------------------------------------\n\nTITLE: Stopping the cluster with Jupyter magic\nDESCRIPTION: This snippet stops the previously started cluster using the `usrmeeting_jupyterstuff` library.  Calling `stop_cluster()` releases the resources allocated for the cluster.  It is important to stop the cluster after use to free up cores.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.0-mpi_basics/MPI-Parallelization_in_NGSolve.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom usrmeeting_jupyterstuff import stop_cluster\nstop_cluster()\n```\n\n----------------------------------------\n\nTITLE: NumberSpace and Bilinear Form for Trivial Problem\nDESCRIPTION: Defines a simple 1D space `NumberSpace` and defines the bilinearform corresponding to the equation 5u^2 = 1. It applies the Newton method to find the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nV = NumberSpace(mesh)\nu,v = V.TnT()\na = BilinearForm(V)\na += ( 5*u*u*v - 1 * v)*dx\ngfu = GridFunction(V)\ngfu.vec[:] = 1\nSimpleNewtonSolve(gfu,a, callback = lambda gfu : print(f\"u^k = {gfu.vec[0]}, u^k**2 = {gfu.vec[0]**2}\"))\nprint(f\"\\nscalar solution, {gfu.vec[0]}, exact: {sqrt(0.2)}, error: {abs(sqrt(0.2)-gfu.vec[0])}\")\n```\n\n----------------------------------------\n\nTITLE: Extending Dimension for Internal State Derivatives in ngsolve (Python)\nDESCRIPTION: This snippet extends the dimensions of the partial derivatives of stress with respect to the internal states, creating a single object `dint_sigma` that combines the contributions from p, alpha, and Lambda.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndim_int = gfp.dim + gfalpha.dim + gfLambda.dim\n\ndint_sigma = dp_sigma.ExtendDimension((dim_sigma, dim_int), pos=(0,0)) \\\n + dalpha_sigma.ExtendDimension((dim_sigma, dim_int), pos=(0, gfp.dim)) \\\n + dLambda_sigma.ExtendDimension((dim_sigma, dim_int), pos=(0, gfp.dim + gfalpha.dim))\n```\n\n----------------------------------------\n\nTITLE: Get Material and Boundary Information\nDESCRIPTION: This snippet retrieves material and boundary information from the generated mesh. This information is used later to apply material properties and boundary conditions in the finite element formulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwell.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh.GetMaterials(), mesh.GetBoundaries()\n```\n\n----------------------------------------\n\nTITLE: Drawing Mesh using NGSolve WebGUI\nDESCRIPTION: This code imports the `Draw` function from `ngsolve.webgui` and displays the mesh in the web browser. It first converts the Netgen mesh (`ngmesh`) to an NGSolve mesh and then calls the `Draw` function. This allows for interactive visualization of the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.webgui import Draw\nmesh = ngsolve.Mesh(ngmesh)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Generating a complex closed surface mesh using CSG\nDESCRIPTION: This snippet creates a complex closed surface mesh by combining multiple spheres using the CSG (Constructive Solid Geometry) approach. The resulting surface mesh is then visualized. The `perfstepsend` argument ensures only the surface is meshed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\nsphere_bot = Sphere(Pnt(0,0,0),1)\nsphere_middle = Sphere(Pnt(0,1,0),0.7)\nsphere_top = Sphere(Pnt(0,1.9,0),0.4)\ngeo.Add(sphere_bot+sphere_middle+sphere_top)\n\nmesh = Mesh(geo.GenerateMesh(maxh=0.5, perfstepsend=MeshingStep.MESHSURFACE))\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Creating a point Jacobi preconditioner\nDESCRIPTION: This code creates a point Jacobi preconditioner using the `CreateSmoother` method of the assembled matrix `a.mat`. It takes the free degrees of freedom `fes.FreeDofs()` as input to construct the smoother.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npreJpoint = a.mat.CreateSmoother(fes.FreeDofs())\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Forms for Full Space Application\nDESCRIPTION: This snippet defines the bilinear forms B and BT for the acoustic wave equation. It uses the `TnT` (Trial and Test) function to create trial and test functions on the product space `fes`.  The forms include volume and boundary terms with a centered flux approximation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn = specialcf.normal(mesh.dim) \n(p,u),(q,v) = fes.TnT()\nB = BilinearForm(fes, nonassemble=True)\nB += grad(p)*v * dx + 0.5*(p.Other()-p)*(v*n) * dx(element_boundary=True)\nBT = BilinearForm(fes, nonassemble=True)\nBT += grad(q)*u * dx + 0.5*(q.Other()-q)*(u*n) * dx(element_boundary=True)\n```\n\n----------------------------------------\n\nTITLE: Setting up Finite Element Spaces for MITC in NGSolve\nDESCRIPTION: This snippet defines the finite element spaces for the Mixed Interpolation of Tensorial Components (MITC) method. It uses VectorH1 for the rotations (beta) and H1 for the vertical deflection (u).  The dirichlet boundary conditions are set depending on whether the plate is clamped or simply supported. A mixed FESpace is then created.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nif clamped:\n    fesB = VectorH1(mesh, order=order, orderinner=order+1, dirichletx=\"circ|left\", dirichlety=\"circ|bottom\", autoupdate=True)\nelse:\n    fesB = VectorH1(mesh, order=order, orderinner=order+1, dirichletx=\"left\", dirichlety=\"bottom\", autoupdate=True)\nfesW = H1(mesh, order=order, orderinner=order+1, dirichlet=\"circ\", autoupdate=True)\nfes = FESpace( [fesB, fesW], autoupdate=True ) \n(beta,u), (dbeta,du) = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Solving with Inhomogeneous Dirichlet Boundary Conditions (Python)\nDESCRIPTION: This code solves a Poisson equation with inhomogeneous Dirichlet boundary conditions using static condensation. It defines a manufactured solution `U`, calculates the corresponding source term `DeltaU`, sets the boundary values of the GridFunction `u` using `u.Set(U, BND)`, extends the Dirichlet data, and solves the system. Finally, it calculates the error between the computed solution and the manufactured solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.4-staticcond/staticcond.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nU = x*x*(1-y)*(1-y)          # U = manufactured solution\nDeltaU = 2*((1-y)*(1-y)+x*x) # Source: DeltaU = U\n\nf = LinearForm(fes)\nf += -DeltaU * v * dx\nf.Assemble()\n\nu = GridFunction(fes)\nu.Set(U, BND)               \nu.vec.data += a.harmonic_extension * u.vec \nu.vec.data += invA * (f.vec - a.mat * u.vec)\n\nsqrt(Integrate((U-u)*(U-u),mesh))  # Compute error\n```\n\n----------------------------------------\n\nTITLE: Defining Facet and Mixed FESpaces - Python\nDESCRIPTION: This code defines a `FacetFESpace` `VF` and a mixed `FESpace` `V` combining the original space `VT` and the facet space `VF`. The `FacetFESpace` is used for representing traces on the element boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nVF = FacetFESpace(mesh, order=order)\nV = VT*VF\n```\n\n----------------------------------------\n\nTITLE: Printing Parallel Status of Vectors\nDESCRIPTION: This snippet prints the parallel status of the vectors associated with the linear form and grid function.  It uses the `GetParallelStatus()` method to determine and print whether the vectors are 'Cumulated' or 'Distributed'. It prints the status for the global vector as well as the local vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\nprint('status f vec:         ', f.vec.GetParallelStatus())\nprint('status vec.local_vec: ', f.vec.local_vec.GetParallelStatus())\nprint('')\nprint('status gfu vec:       ', gfu.vec.GetParallelStatus())\nprint('status vec.local_vec: ', gfu.vec.local_vec.GetParallelStatus())\n```\n\n----------------------------------------\n\nTITLE: Loading Distributed Mesh and Printing Information\nDESCRIPTION: This snippet loads a mesh in parallel and prints information about the part of the mesh that belongs to the current rank. It loads the mesh from the file 'square.vol' using `Mesh()`, and then prints the number of elements, faces, edges, and vertices that are local to the current MPI rank.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nmesh = Mesh('square.vol')\nprint('rank', str(comm.rank)+\"'s part of the mesh has \", mesh.ne, 'elements, ', \\\n      mesh.nface, 'faces, ', mesh.nedge, 'edges and ', mesh.nv, ' vertices')\n```\n\n----------------------------------------\n\nTITLE: Drawing Pressure on Physical Domain in NGSolve (Python)\nDESCRIPTION: This code draws the second component of the `gfw` GridFunction (pressure) on the physical domain using the `DrawDC` function in NGSolve, with deformation applied.  It also sets a minimum and maximum for the color scale to -1 and 1 respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(lsetp1,gfw.components[1],-1,mesh,\"p\",deformation=deformation, min=-1, max=1)\n```\n\n----------------------------------------\n\nTITLE: Executing Python Command to Get pybind11-stubgen Version\nDESCRIPTION: This CMake snippet uses `execute_process` to run a Python command that retrieves the version of the `pybind11-stubgen` package. The output is stored in the `stubgen_version` variable, and the result of the execution is stored in `pybind11_stubgen`.  This allows CMake to determine if the package is installed and its version number.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/python/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\nexecute_process(COMMAND ${NETGEN_PYTHON_EXECUTABLE} -c \"from importlib.metadata import version; print(version('pybind11-stubgen'))\" OUTPUT_VARIABLE stubgen_version RESULT_VARIABLE pybind11_stubgen)\n```\n\n----------------------------------------\n\nTITLE: Set up vector space and deformation field - Python\nDESCRIPTION: This snippet sets up the vector space `VEC` and the grid functions `gfset` and `gfX` for the deformation field. `VEC` is defined as an H1 space, crucial for representing the displacement field. `gfset` and `gfX` are GridFunctions that store the current deformation and the gradient, respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# vector space for shape gradient\nVEC = H1(mesh, order=1, dim=2)\n\n# grid function for deformation field\ngfset = GridFunction(VEC)\ngfX = GridFunction(VEC)\n\nDraw(gfset)\n```\n\n----------------------------------------\n\nTITLE: Creating LinMat wrapper for BlockMatrix Python\nDESCRIPTION: Creates `LinMat` wrappers around the `BlockMatrix` instances. The `LinMat` class is a simple workaround to allow `BlockMatrix` objects to be used with the C++-side GMRES solver, which expects standard NGSolve (Parallel-)Vectors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n%%px\nM_lin = LinMat(M, [A_dp.col_pardofs, B.col_pardofs])\nMhat_lin = LinMat(Mhat, [A_dp.col_pardofs, B.col_pardofs])\nMhat2_lin = LinMat(Mhat2, [A_dp.col_pardofs, B.col_pardofs])\n```\n\n----------------------------------------\n\nTITLE: Assembling Bilinear Form\nDESCRIPTION: This snippet defines and assembles a bilinear form for Poisson's equation on the distributed finite element space. It defines trial and test functions using `fes.TnT()`, creates a `BilinearForm(fes)`, adds the symbolic form representing the Laplacian using `SymbolicBFI(grad(u)*grad(v))`, and assembles the bilinear form using `a.Assemble()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nu,v = fes.TnT()\na = BilinearForm(fes)\na += SymbolicBFI(grad(u)*grad(v))\na.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Calculating Condition Number with Default Settings\nDESCRIPTION: This snippet calculates the condition number (ratio of maximum to minimum eigenvalue) of the preconditioned matrix using the default BDDC preconditioner settings.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nlams = TestPreconditioner (10, condense=True)\nmax(lams)/min(lams)\n```\n\n----------------------------------------\n\nTITLE: Extending Domain by Neighbors - Python\nDESCRIPTION: This snippet extends a domain by repeatedly adding its direct neighbors. It uses `GetFacetsWithNeighborTypes` to find facets between the current domain and itself and then uses `GetElementsWithNeighborFacets` to find the elements surrounding those facets. This is repeated multiple times to expand the selected domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nba_facets = GetFacetsWithNeighborTypes(mesh,a=ba_surround_facets,b=ba_surround_facets,\n                                           bnd_val_a=False,bnd_val_b=False,use_and=False)\nba_surround_facets = GetElementsWithNeighborFacets(mesh,ba_facets)\nDraw(BitArrayCF(ba_surround_facets), mesh, \"ba_surround\")\n```\n\n----------------------------------------\n\nTITLE: Defining Distributed Finite Element Space and Printing Information\nDESCRIPTION: This snippet defines a finite element space on a distributed mesh and prints information about its dimension. It creates an H1 finite element space using `H1(mesh, order=3, dirichlet='bottom|left')` and then prints the local and global number of degrees of freedom (DOFs).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfes = H1(mesh, order=3, dirichlet='bottom|left')\nprint('fes on rank', comm.rank, 'has', fes.ndof, 'DOFs, globally we have ', fes.ndofglobal)\n```\n\n----------------------------------------\n\nTITLE: MPI Time Measurement and Summation\nDESCRIPTION: This snippet measures the execution time and calculates the sum of a value across all MPI processes. It measures the time using `comm.WTime()`, sums a value (1 in this case) across all processes using `comm.Sum()`, calculates the maximum time across all processes using `comm.Max()`, and prints the result from rank 0.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nt = comm.WTime()\ns2 = comm.Sum(1)\nt = comm.Max(comm.WTime()-t)\nif comm.rank==0:\n    print('There are ', s2, ' of us, which took us ', round(t,6), 'seconds to figure out')\n```\n\n----------------------------------------\n\nTITLE: Solving Poisson equation using NGSolve in Python\nDESCRIPTION: This code snippet demonstrates how to solve the Poisson equation using NGSolve. It defines a mesh, finite element space, bilinear form, linear form, and solves the system to obtain the grid function 'gfu'. This example sets up a basic simulation environment that creates and solves a Poisson equation on a unit square mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-vtk/vtk.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.geom2d import unit_square\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\nfes = H1(mesh, order=2, dirichlet=\"bottom|right\")\ngfu = GridFunction(fes) \na = BilinearForm(fes, symmetric=True)\na += grad(fes.TrialFunction())*grad(fes.TestFunction())*dx\na.Assemble()\nf = LinearForm(fes)\nf += x*fes.TestFunction()*dx\nf.Assemble()\ngfu.vec.data = a.mat.Inverse(freedofs=fes.FreeDofs()) * f.vec\n```\n\n----------------------------------------\n\nTITLE: Generate Mesh with Global Mesh Size in Netgen\nDESCRIPTION: This snippet demonstrates setting a global mesh size using the maxh argument in the GenerateMesh function. Two equivalent methods are shown: directly passing maxh or using a MeshingParameters object.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nunit_cube.GenerateMesh(maxh=0.4)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.meshing import MeshingParameters\nmp = MeshingParameters(maxh=0.4)\nunit_cube.GenerateMesh(mp = mp)\n```\n\n----------------------------------------\n\nTITLE: Integrating the Derivative with Respect to a Parameter\nDESCRIPTION: This snippet integrates the square of the difference between the derivative of `f` with respect to `k` and the analytical derivative (y*cos(k*y)). This verifies the correctness of the differentiation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nIntegrate((f.Diff(k) - y*cos(k*y))**2, mesh)\n```\n\n----------------------------------------\n\nTITLE: Creating CSG2d Geometry with Basic Primitives in Python\nDESCRIPTION: This snippet demonstrates the creation of a 2D geometry using the CSG2d interface in Netgen. It defines a circle and a rectangle, then uses boolean operators (union, difference, and intersection) to create three domains. These domains are added to the geometry, meshed, and visualized using NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.2-csg2d/csg2d.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import CSG2d, Circle, Rectangle\n\ngeo = CSG2d()\n\n# define some primitives\ncircle = Circle( center=(0,0), radius=1.0, mat=\"mat1\", bc=\"bc_circle\" )\nrect = Rectangle( pmin=(0,0), pmax=(1.5,1.5), mat=\"mat2\", bc=\"bc_rect\" )\n\n# use operators +, - and * for union, difference and intersection operations\ndomain1 = circle - rect\ndomain2 = circle * rect\ndomain2.Mat(\"mat3\").Maxh(0.1) # change domain name and maxh\ndomain3 = rect-circle\n\n# add top level objects to geometry\ngeo.Add(domain1)\ngeo.Add(domain2)\ngeo.Add(domain3)\n\n# generate mesh\nm = geo.GenerateMesh(maxh=0.3)\n\n# use NGSolve just for visualization\nfrom ngsolve.webgui import Draw\nfrom ngsolve import Mesh, VOL\nmesh = Mesh(m)\nmesh.Curve(3)\ncf = mesh.RegionCF(VOL, dict(mat1=0, mat2=4, mat3=7)) \nDraw(cf, mesh)\n```\n\n----------------------------------------\n\nTITLE: Defining Geometry using Netgen CSG - Python\nDESCRIPTION: This function `MakeGeometry` constructs the geometry of the simulation domain using Netgen's constructive solid geometry (CSG) module. It defines a box, a core, and a coil using `OrthoBrick` and `Cylinder` primitives, and then combines them using boolean operations. The function returns the constructed geometry object.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/maxwell.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef MakeGeometry():\n    geometry = CSGeometry()\n    box = OrthoBrick(Pnt(-1,-1,-1),Pnt(2,1,2)).bc(\"outer\")\n\n    core = OrthoBrick(Pnt(0,-0.05,0),Pnt(0.8,0.05,1))- \\\n           OrthoBrick(Pnt(0.1,-1,0.1),Pnt(0.7,1,0.9))- \\\n           OrthoBrick(Pnt(0.5,-1,0.4),Pnt(1,1,0.6)).maxh(0.2).mat(\"core\")\n    \n    coil = (Cylinder(Pnt(0.05,0,0), Pnt(0.05,0,1), 0.3) - \\\n            Cylinder(Pnt(0.05,0,0), Pnt(0.05,0,1), 0.15)) * \\\n            OrthoBrick (Pnt(-1,-1,0.3),Pnt(1,1,0.7)).maxh(0.2).mat(\"coil\")\n    \n    geometry.Add ((box-core-coil).mat(\"air\"), transparent=True)\n    geometry.Add (core, col=(0.5,0.5,0))\n    geometry.Add (coil, col=(0,1,0))\n    return geometry\n\ngeo = MakeGeometry()\n# Draw (geo)\n```\n\n----------------------------------------\n\nTITLE: Creating faces with different orientations\nDESCRIPTION: This code creates three faces with different orientations using WorkPlane and Axes.  Each face is a rectangle, and the orientation is determined by the normal vector specified in the Axes constructor. The faces are then combined and visualized using DrawGeo.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/workplane.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nf1 = WorkPlane(Axes((0,0,0), n=Z, h=X)).Rectangle(2,1).Face()\nf2 = WorkPlane(Axes((0,1,0), n=-Y, h=X)).Rectangle(2,1).Face()\nf3 = WorkPlane(Axes((0,0,0), n=X, h=Y)).Rectangle(1,1).Face()\nDrawGeo (f1+f2+f3);\n```\n\n----------------------------------------\n\nTITLE: Specifying boundary conditions during mesh generation\nDESCRIPTION: This snippet shows how to assign boundary condition names to different parts of the geometry using the `bc` method. These names can then be used to apply different boundary conditions in the finite element simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\nsphere_bot = Sphere(Pnt(0,0,0),1).bc(\"bottom\")\nsphere_middle = Sphere(Pnt(0,1,0),0.7).bc(\"middle\")\nsphere_top = Sphere(Pnt(0,1.9,0),0.4).bc(\"top\")\ngeo.Add(sphere_bot+sphere_middle+sphere_top)\nmesh = Mesh(geo.GenerateMesh(maxh=0.5, perfstepsend=MeshingStep.MESHSURFACE))\nprint(\"Bnd = \", mesh.GetBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Starting MPI Cluster with ipyparallel (Python)\nDESCRIPTION: This code snippet demonstrates how to start an MPI cluster using the `ipyparallel` module. It initializes a cluster with a specified number of engines (processes) and connects to it, activating the cluster for use.  The `n` parameter specifies the number of MPI processes to use.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom ipyparallel import Cluster\nc = await Cluster(engines=\"mpi\").start_and_connect(n=4, activate=True)\n```\n\n----------------------------------------\n\nTITLE: Creating PETSc Vectors\nDESCRIPTION: This code creates PETSc vectors compatible with the previously created PETSc matrix. It uses the `createVecs()` method of the PETSc matrix to generate vectors suitable for use in solving linear systems with that matrix. These vectors are then used to store the right-hand side and solution during the solving process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n%%px\npsc_f, psc_u = psc_mat.createVecs()\n```\n\n----------------------------------------\n\nTITLE: Solving Stokes with Discontinuous Pressure Elements\nDESCRIPTION: This snippet demonstrates solving the Stokes equation with discontinuous pressure elements (P2-P1). It highlights the instability of this combination and prints the number of degrees of freedom for the velocity and pressure spaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nV = VectorH1(mesh, order=2, dirichlet=\"wall|inlet|cyl\")\nQ = L2(mesh, order=1)\nprint (\"V.ndof =\", V.ndof, \", Q.ndof =\", Q.ndof)\nX = V*Q\n\ngfu = SolveStokes(X)\n```\n\n----------------------------------------\n\nTITLE: Computing Element Matrix for Bilinear Form A (Python)\nDESCRIPTION: This code iterates through the mesh elements and computes the element matrix for the bilinear form 'a'. It retrieves the finite element space associated with the element, obtains the transformation from the reference element to the physical element, and then calculates the element matrix using the CalcElementMatrix method.  The integrators[0] accesses the first integrator defined in the bilinear form (in this case, the sigma*tau * dx term).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfor el in mesh.Elements():\n    felS = Sigma.GetFE(el)\n    trafo = mesh.GetTrafo(el)\n    elmat = a.integrators[0].CalcElementMatrix(felS, trafo)   \n    print (elmat)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Results of Naghdi Shell Model (Python)\nDESCRIPTION: This snippet visualizes the results of the Naghdi shell model. It draws the rotations and displacement components of the `gfu` GridFunction on the mesh, using the displacement as a deformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu.components[1], mesh, \"rotations\", deformation=gfu.components[0])\nDraw(gfu.components[0], mesh, \"disp\");\n```\n\n----------------------------------------\n\nTITLE: Accessing and Printing ParallelDofs Information\nDESCRIPTION: This snippet accesses the `ParallelDofs` object of a finite element space and prints information about the local and global number of DOFs. It retrieves the `ParallelDofs` object using `fes.ParallelDofs()` and then prints the number of local and global DOFs associated with the parallel distribution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\npd = fes.ParallelDofs()\nprint('rank', comm.rank, 'has', pd.ndoflocal, 'local DOFs, globally we have', pd.ndofglobal)\n```\n\n----------------------------------------\n\nTITLE: Performing Vector-Space Operations in NGSolve\nDESCRIPTION: This snippet shows how to perform basic vector-space operations such as scaling, addition, and matrix multiplication in NGSolve. It also demonstrates how to compute the inner product of two vectors using the `InnerProduct` function. Key point is the `.data` access.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_linalg.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nhelp.data = 3 * vu\nhelp.data += mat * vu\nprint (\"(u,h) = \", InnerProduct(help, vu))\n```\n\n----------------------------------------\n\nTITLE: Updating the mesh deformation\nDESCRIPTION: This code updates the mesh deformation based on the calculated deformation field 'gfX'. It scales the deformation field and subtracts it from the current deformation to move towards the optimal shape. It also prints the cost at the initial design.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ngfset.Set((0,0))\nmesh.SetDeformation(gfset)\nprint('Cost at initial design', Integrate (CostAuto(gfu), mesh))\n\nscale = 0.5 / Norm(gfX.vec)\ngfset.vec.data -= scale * gfX.vec\nmesh.SetDeformation(gfset)\nsceneSet.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Adaptive Mesh Refinement for Heat Equation - Python\nDESCRIPTION: This Python script demonstrates adaptive mesh refinement for solving a stationary heat equation with highly varying coefficients using NGSolve. It utilizes a Zienkiewicz-Zhu type error estimator and loops through several refinement levels to improve the solution. The script models a 2D geometry using line segments.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/whetting_the_appetite/adaptive.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nadaptive.py </../py_tutorials/adaptive.py>\n```\n\n----------------------------------------\n\nTITLE: Vectorial Approximation Space Definition - Python\nDESCRIPTION: This snippet defines a finite element space (fes) for the shallow water equations, which are a system of three equations. It uses an L2 space with a specified order (order=2). The `**3` indicates a vectorial space with dimension 3, representing the height (h) and momentum components (hu, hv).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.8-simplehyp/shallow2D.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\norder = 2\nfes = L2(mesh,order=order)**3\n#fes = L2(mesh,order=order,dim=3)\n```\n\n----------------------------------------\n\nTITLE: Deprecation Warning in CMake\nDESCRIPTION: This snippet checks if the `ADDITIONAL_PATHS` variable is set and, if so, issues a warning message indicating that it is deprecated and suggesting the use of `CMAKE_PREFIX_PATH` instead.  It uses a conditional statement and the `message` command with the `WARNING` flag.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_56\n\nLANGUAGE: cmake\nCODE:\n```\nif (ADDITIONAL_PATHS)\n  message(WARNING \"The use of ADDITIONAL_PATHS is deprecated, use CMAKE_PREFIX_PATH instead.\")\nendif (ADDITIONAL_PATHS)\n```\n\n----------------------------------------\n\nTITLE: Set Boundary Condition and Max Mesh Size on Sphere in Netgen\nDESCRIPTION: This snippet shows how to set boundary conditions and maximum mesh size on the surface of a sphere using the bc() and maxh() methods.  These properties are defined directly on the solid object before adding it to the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsphere = Sphere(Pnt(0,0,0),1)\n\n```\n\nLANGUAGE: python\nCODE:\n```\nsphere.bc(\"sphere\").maxh(0.25)\n```\n\n----------------------------------------\n\nTITLE: Embedding Finite Element Spaces from H1 to HDiv (Python)\nDESCRIPTION: This snippet shows how to transform functions from a vector-valued H1 space to an HDiv space using dual basis functions in NGSolve.  It defines `VectorH1` and `HDiv` finite element spaces, sets up bilinear forms, and uses a direct solver to perform the transformation. `dx(element_boundary=True)` indicates that the integral is computed on the element boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import unit_square\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2))\n\nfesh1 = VectorH1(mesh, order=2)\nfeshdiv = HDiv(mesh, order=2)\n\ngfuh1 = GridFunction(fesh1)\ngfuh1.Set ( (x*x,y*y) )\n\ngfuhdiv = GridFunction(feshdiv, name=\"uhdiv\")\n```\n\nLANGUAGE: python\nCODE:\n```\namixed = BilinearForm(trialspace=fesh1, testspace=feshdiv)\nahdiv = BilinearForm(feshdiv)\n\nu,v = feshdiv.TnT()\nvdual = v.Operator(\"dual\")\nuh1 = fesh1.TrialFunction()\n\ndS = dx(element_boundary=True)\nahdiv += u*vdual * dx + u*vdual * dS\nahdiv.Assemble()\n\namixed += uh1*vdual*dx + uh1*vdual*dS\namixed.Assemble()\n\n# build transformation operator:\ntransform = ahdiv.mat.Inverse() @ amixed.mat\ngfuhdiv.vec.data = transform * gfuh1.vec\n\nDraw (gfuh1)\nDraw (gfuhdiv)\n```\n\n----------------------------------------\n\nTITLE: Curving a mesh for higher-order elements\nDESCRIPTION: This snippet demonstrates how to curve a mesh, which is often necessary when using higher-order finite elements. The `Curve` method increases the polynomial order of the mesh geometry representation, improving accuracy for curved domains.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmesh.Curve(2)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Listing subdomains\nDESCRIPTION: This snippet demonstrates how to retrieve a list of all subdomains in the mesh using `mesh.GetMaterials()`. This is useful for iterating or debugging which subdomains exist.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nmesh.GetMaterials()    # list all subdomains\n```\n\n----------------------------------------\n\nTITLE: Parallel execution with Jupyter magic %%px\nDESCRIPTION: This snippet shows how to execute Python code in parallel across all workers in the cluster using the `%%px` Jupyter magic command. All processes in the cluster will execute the print statement concurrently. This allows distributing computational tasks across multiple cores.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.0-mpi_basics/MPI-Parallelization_in_NGSolve.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n%%px\nprint('hello from everyone in the cluster!')\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh\nDESCRIPTION: This snippet initializes a mesh from a unit square using NGSolve's `unit_square` geometry. The `GenerateMesh` method is used with `maxh=0.3` to control the maximum mesh size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.3))\n```\n\n----------------------------------------\n\nTITLE: Abbreviated Definition of a Vector-Valued CoefficientFunction\nDESCRIPTION: This snippet demonstrates the use of the abbreviation `CF` for `CoefficientFunction` to define the same vector-valued function as in the previous snippet.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nvecfun = CF((-y, sin(x)))   # CF = CoefficientFunction\n```\n\n----------------------------------------\n\nTITLE: Creating CutInfo Object (Python)\nDESCRIPTION: This snippet creates an instance of the CutInfo class, which is used to store information about the intersection of the level set with the mesh elements.  The time_order=0 argument specifies that the CutInfo object should look for space-time cut information.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nci = CutInfo(mesh, time_order=0)\n```\n\n----------------------------------------\n\nTITLE: Drawing Pressure Field\nDESCRIPTION: This snippet visualizes the computed pressure field using the `Draw` function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfp);\n```\n\n----------------------------------------\n\nTITLE: Forming the Schur Complement (Python)\nDESCRIPTION: This code forms the Schur complement by combining the bilinear form's matrix and the inverse mass matrix. The Schur complement is a discretization of the Laplace operator and can be used to solve elliptic problems.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nLaplace = b.mat @ ainv @ b.mat.T\n```\n\n----------------------------------------\n\nTITLE: Creating Background Geometry and Mesh (Python)\nDESCRIPTION: This snippet creates the background geometry and mesh for the simulation. It uses a rectangle as the outer domain, generates a mesh with a specified maximum element size, and refines the mesh to improve accuracy.  The mesh is a crucial component for the finite element analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Outer domain:\nrect = SplineGeometry()\nrect.AddRectangle([-0.6, -1], [0.6, 1])\nngmesh = rect.GenerateMesh(maxh=maxh, quad_dominated=False)\nfor j in range(space_refs):\n    ngmesh.Refine()\nmesh = Mesh(ngmesh)\n```\n\n----------------------------------------\n\nTITLE: Generating Visualization of Auxiliary Space\nDESCRIPTION: This snippet generates the visualization of the auxiliary space function used in the document. It sets up mixed finite element spaces, variational formulation, solves it using Newton's method, and visualizes the resulting function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import unit_square\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.1))\nfes_ho = Discontinuous(H1(mesh, order=10))\nfes_lo = H1(mesh, order=1, dirichlet=\".*\")\nfes_lam = Discontinuous(H1(mesh, order=1))\nfes = fes_ho*fes_lo*fes_lam\nuho, ulo, lam = fes.TrialFunction()\n\na = BilinearForm(fes)\na += Variation(0.5 * grad(uho)*grad(uho)*dx \n               - 1*uho*dx \n               + (uho-ulo)*lam*dx(element_vb=BBND))\ngfu = GridFunction(fes)\nsolvers.Newton(a=a, u=gfu)\nDraw(gfu.components[0],deformation=True, settings={\"camera\": {\"transformations\": [{\"type\": \"rotateX\", \"angle\": -45}]}})\n```\n\n----------------------------------------\n\nTITLE: Extruding a face\nDESCRIPTION: This snippet shows how to extrude a face created using a workplane. A rectangle with a smaller rectangle removed to form a frame shape is created and then extruded. The `Extrude()` method is used to create a 3D solid from the face by extruding it along the Z-axis for a given distance.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/workplane.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nface = WorkPlane().RectangleC(2,1).RectangleC(1.8,0.8).Reverse().Face()\nframe = face.Extrude(1)\nDrawGeo(frame);\n```\n\n----------------------------------------\n\nTITLE: Setting Domain Numbers and Materials (Python)\nDESCRIPTION: This snippet demonstrates setting domain numbers and materials for different regions within the geometry. This is crucial for defining different physical properties or boundary conditions within the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngeo = SplineGeometry()\ngeo.AddRectangle(p1=(-1,-1),\n                 p2=(1,1),\n                 bc=\"rectangle\",\n                 leftdomain=1,\n                 rightdomain=0)\ngeo.AddCircle(c=(0,0),\n              r=0.5,\n              bc=\"circle\",\n              leftdomain=2,\n              rightdomain=1)\ngeo.SetMaterial (1, \"outer\")\ngeo.SetMaterial (2, \"inner\")\n```\n\n----------------------------------------\n\nTITLE: Generating Structured Surface Mesh (Python)\nDESCRIPTION: This snippet creates a structured surface mesh using `MakeStructuredSurfaceMesh`. A mapping function is defined to map the parameter space to the physical space.  The mesh is then visualized. The `quads=False` argument specifies that the mesh should be made of triangles rather than quadrilaterals.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.meshes import MakeStructuredSurfaceMesh\nthickness = 0.1\nL = 12\nW = 1\nE, nu = 1.2e6, 0\nmoment = IfPos(x-L+1e-6, 1, 0)*50*pi/3\n\nmapping = lambda x,y,z : (L*x, W*y,0)\nmesh = MakeStructuredSurfaceMesh(quads=False, nx=10, ny=1, mapping=mapping)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Material Norm Functions (Python)\nDESCRIPTION: These functions, `MaterialNorm` and `MaterialNormInv`, compute the material norm and its inverse, respectively, based on the material properties `E` (Young's modulus) and `nu` (Poisson's ratio). These are used in the variational form to calculate the energy contributions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngradn = specialcf.Weingarten(3) #grad(nsurf)\n\ndef MaterialNorm(mat, E, nu):\n    return E/(1-nu**2)*((1-nu)*InnerProduct(mat,mat)+nu*Trace(mat)**2)\ndef MaterialNormInv(mat, E, nu):\n    return (1+nu)/E*(InnerProduct(mat,mat)-nu/(nu+1)*Trace(mat)**2)\n```\n\n----------------------------------------\n\nTITLE: Initializing MPI Cluster with ipyparallel in Python\nDESCRIPTION: This snippet initializes an MPI cluster using ipyparallel. It starts a specified number of engines (processes) and connects to them, activating the cluster for parallel execution. This setup is a prerequisite for distributed computing with NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.2-pardofs/pardofs.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ipyparallel import Cluster\nc = await Cluster(engines=\"mpi\").start_and_connect(n=4, activate=True)\n```\n\n----------------------------------------\n\nTITLE: Converting to NGSolve Mesh\nDESCRIPTION: This snippet imports the `ngsolve` module and converts the Netgen mesh (`m`) to an NGSolve mesh.  This allows for further processing and visualization using NGSolve's capabilities. It creates a mesh that can be used for finite element analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport ngsolve\nmesh = ngsolve.Mesh(m)\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve Modules\nDESCRIPTION: This snippet imports necessary modules from the NGSolve library, including modules for defining finite element spaces, web-based visualization, and linear algebra operations. It initializes the heap size for memory management.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.4-bddc/bddc.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom ngsolve.la import EigenValues_Preconditioner\nSetHeapSize(100*1000*1000)\n```\n\n----------------------------------------\n\nTITLE: Accessing Solution Components\nDESCRIPTION: This snippet extracts the components of the mixed solution, `gfsigma` and `gfu`, from the `gfm` GridFunction. These components represent the flux and the scalar variable, respectively. These components refer to ranges of the same coefficient vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.5-mixed/mixed.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngfsigma, gfu = gfm.components\n```\n\n----------------------------------------\n\nTITLE: Matrix-Vector Multiplication\nDESCRIPTION: This snippet demonstrates matrix-vector multiplication with parallel vectors. It creates two vectors using `gfu.vec.CreateVector()`, initializes `v` with ones, and then performs the matrix-vector multiplication `w.data = a.mat * v`, storing the result in `w`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_18\n\nLANGUAGE: Python\nCODE:\n```\nv = gfu.vec.CreateVector()\nw = gfu.vec.CreateVector()\nv[:] = 1.0\nw.data = a.mat * v\n```\n\n----------------------------------------\n\nTITLE: Setting Number of Threads in NGS-Py\nDESCRIPTION: This code snippet shows how to set the number of threads for parallel execution in NGS-Py using the SetNumThreads function. The number of threads can also be set using the environment variable NGS_NUM_THREADS. This function allows overriding the default number of threads.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_parallel.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nSetNumThreads ( num_threads )\n```\n\n----------------------------------------\n\nTITLE: Solving the deformation equation\nDESCRIPTION: This code defines a function 'SolveDeformationEquationAuto' that solves the deformation equation using a direct solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef SolveDeformationEquationAuto():\n    rhs = gfX.vec.CreateVector()\n    rhs.data = dJOmegaAuto.vec - b.mat * gfX.vec\n    update = gfX.vec.CreateVector()\n    update.data = b.mat.Inverse(VEC.FreeDofs()) * rhs\n    gfX.vec.data += update\n```\n\n----------------------------------------\n\nTITLE: Running Time Simulation with Bilinear Forms\nDESCRIPTION: This snippet runs the time simulation using the previously defined bilinear forms B and BT. It visualizes the pressure field and uses the `%time` magic command to measure the execution time of the `Run` function. The simulation is run both forward and backward in time.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nscenep=Draw(gfu.components[0], mesh, \"p\", min=-0.02, max=0.08, \n            autoscale=False, order=3, deformation=True) \n%time Run(B.mat, BT.mat, backward=False, scenes=[scenep])\n%time Run(B.mat, BT.mat, backward=True, scenes=[scenep])\n```\n\n----------------------------------------\n\nTITLE: Generating Geometries and Meshes\nDESCRIPTION: This code generates two geometries: a brick and a sphere, using the CSG (Constructive Solid Geometry) module. It then meshes each geometry separately using `GenerateMesh`. The maximum element size (`maxh`) is specified for each mesh, and `Refine` is called on the sphere's mesh to improve its quality.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# generate brick and mesh it\ngeo1 = CSGeometry()\ngeo1.Add (OrthoBrick( Pnt(0,0,0), Pnt(1,1,1) ))\nm1 = geo1.GenerateMesh (maxh=0.1)\n# m1.Refine()\n\n# generate sphere and mesh it\ngeo2 = CSGeometry()\ngeo2.Add (Sphere (Pnt(0.5,0.5,0.5), 0.1))\nm2 = geo2.GenerateMesh (maxh=0.05)\nm2.Refine()\n# m2.Refine()\n```\n\n----------------------------------------\n\nTITLE: Modifying Right-hand Side (NGSolve, Python)\nDESCRIPTION: This snippet modifies the right-hand side vector by adding the contribution from the harmonic extension transpose multiplied by the original right-hand side vector. This step is necessary to account for the eliminated internal unknowns during static condensation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_staticcondensation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nf.vec.data += a.harmonic_extension_trans * f.vec\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve, NumPy and WebGUI\nDESCRIPTION: This snippet imports the necessary libraries: NGSolve for finite element analysis, NumPy for numerical operations, and NGSolve's webgui for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nimport numpy as np\n```\n\n----------------------------------------\n\nTITLE: Deform mesh, assemble forms, unset deformation - Python\nDESCRIPTION: This snippet deforms the mesh using the current deformation field `gfset`, assembles the bilinear form `aX` and the linear form `dJOmega` on the deformed domain.  After assembly, the deformation is unset. This allows to compute the derivatives on the deformed domain.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# deform current domain with gfset\nmesh.SetDeformation(gfset)\n\n# assemble on deformed domain\naX.Assemble()\ndJOmega.Assemble()\n\nmesh.UnsetDeformation()\n# unset deformation\n```\n\n----------------------------------------\n\nTITLE: Compressing a finite element space\nDESCRIPTION: This snippet demonstrates compressing a finite element space defined on a subdomain using the `Compress` function. This removes the unused degrees of freedom, resulting in a smaller space. The `ndof` of the compressed space is then printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfescomp = Compress(fes1)\nprint(fescomp.ndof)\n```\n\n----------------------------------------\n\nTITLE: Printing MPI Rank and Size (Python)\nDESCRIPTION: This code snippet uses `mpi4py` to retrieve and print the rank (ID) and size (total number) of the MPI communicator. It uses the `%%px` IPython magic to execute the code in parallel across all MPI processes. It depends on the `mpi4py` package.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.1-mpi/poisson_mpi.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n%%px \nfrom mpi4py.MPI import COMM_WORLD as comm\nprint (comm.rank, comm.size)\n```\n\n----------------------------------------\n\nTITLE: Print Operator Information\nDESCRIPTION: This snippet prints information about the assembled operator matrix bfamat. This could include details about sparsity, structure, and other relevant properties of the matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint (bfamat.GetOperatorInfo())\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces\nDESCRIPTION: This snippet defines the finite element spaces used in the simulation. VectorH1 is used for the displacement field (u), with Dirichlet boundary conditions applied on the \"right\" and \"bottom\" boundaries. IntegrationRuleSpace is used for internal variables and multipliers, defined with an order one less than the displacement field. The measure 'dx' is also defined, linked to the integration rules of the IR space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfes_u = VectorH1(mesh, order=order, dirichletx=\"right\", dirichlety=\"bottom\")\nfes_ir = IntegrationRuleSpace(mesh, order=order-1)\n\n```\n\nLANGUAGE: python\nCODE:\n```\n# extract integration rules from IntegrationRuleSpace\nirs_dx = dx(intrules=fes_ir.GetIntegrationRules())\n```\n\n----------------------------------------\n\nTITLE: Applying Deformation\nDESCRIPTION: This snippet demonstrates how to apply a deformation to a mesh before drawing it.  A `CF` (CoefficientFunction) representing the deformation is created and passed to the `Draw` function via the `deformation` parameter. The second draw is for controlling the deformation value.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndeform = CF( (-0.05*z*x,0,0.05*x*x) )\nDraw (mesh, deformation=deform);\n\nprint (\"use deformation slider:\")\nDraw (deform, mesh);  \n```\n\n----------------------------------------\n\nTITLE: Assembling and solving the state equation\nDESCRIPTION: This code assembles the bilinear and linear forms for the state equation, solves it using the SolveStateEquation function, and redraws the visualization scene.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\na.Assemble()\nfstate.Assemble()\nSolveStateEquation()\n\nscene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Computing Trial State in ngsolve (Python)\nDESCRIPTION: This snippet computes the trial state for the plastic evolution by interpolating the derivatives of the energy density with respect to the history variables (p and alpha). These trial values determine whether plastic deformation will occur.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nPsi_trial = Psi(strain(gfu), *gfhist.components[:2])\ndef compute_trial_state():\n    gftrial.components[0].Interpolate(-Psi_trial.Diff(gfhist.components[0]))\n    gftrial.components[1].Interpolate(-Psi_trial.Diff(gfhist.components[1]))\n    # no need to interpolate Lambda\n```\n\n----------------------------------------\n\nTITLE: Setting NGSolve Compile Definitions\nDESCRIPTION: Initializes variables to store compile include directories, compile definitions, private compile definitions, and compile options for NGSolve.  It appends HAVE_NETGEN_SOURCES to the list of compile definitions, indicating that the Netgen sources are available.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_13\n\nLANGUAGE: cmake\nCODE:\n```\nset(NGSOLVE_COMPILE_INCLUDE_DIRS \"\")\nset(NGSOLVE_COMPILE_DEFINITIONS \"\")\nset(NGSOLVE_COMPILE_DEFINITIONS_PRIVATE \"\")\nset(NGSOLVE_COMPILE_OPTIONS \"\")\nlist(APPEND NGSOLVE_COMPILE_DEFINITIONS HAVE_NETGEN_SOURCES)\n```\n\n----------------------------------------\n\nTITLE: Extracting Flux by Differentiating with Grad(v) (Python)\nDESCRIPTION: This Python code shows how to extract the flux from a bilinear form term by differentiating with respect to the gradient of the test function 'v'. This is a crucial step in preparing the form for low-level code generation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint (term2[0].coef.Diff(Grad(v)))\n```\n\n----------------------------------------\n\nTITLE: Printing Mesh Material and Boundary Information\nDESCRIPTION: This snippet prints the materials and boundaries present in the mesh for a subset of the MPI ranks. It accesses the mesh's materials and boundaries via `mesh.GetMaterials()` and `mesh.GetBoundaries()` respectively, and prints this information for ranks 0 to 5.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nprint('rank', comm.rank, 'Materials:', mesh.GetMaterials())\nprint('rank', comm.rank, 'Boundaries: ', mesh.GetBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Timing Mass Matrix Inverse Application (Python)\nDESCRIPTION: This snippet times the application of the inverse mass matrix to a vector. The %timeit command is used to measure the execution time of the matrix-vector product.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.11-matrixfree/matrixfree.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nvx = ainv.CreateRowVector()\nvy = ainv.CreateColVector()\nvx[:] = 1\n\n%timeit vy.data = ainv * vx\n```\n\n----------------------------------------\n\nTITLE: Initializing MPI and Printing Rank/Size\nDESCRIPTION: This snippet initializes MPI within NGSolve and prints the rank and size of the MPI communicator.  It imports the `ngsolve` module, initializes the MPI communicator using `MPI_Init()`, and prints a message indicating the rank and size of the current process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom ngsolve import *\ncomm = MPI_Init()\nprint(\"Hello from rank \", comm.rank, ' of ', comm.size)\n```\n\n----------------------------------------\n\nTITLE: Compare Sparsity of DG and L2 Matrices in NGSolve\nDESCRIPTION: This snippet compares the number of non-zero elements in the DG matrix with that of a standard L2 matrix. It defines an L2 finite element space without discontinuous jumps and assembles a bilinear form using it. It then prints the number of non-zero elements for both matrices, highlighting the increased sparsity of the DG matrix due to the additional coupling terms.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfes2 = L2(mesh, order=order)\nul2,vl2 = fes2.TnT()\na2 = BilinearForm(ul2*vl2*dx).Assemble()\nprint (\"DG-matrix nze:\", a.mat.nze)\nprint (\"L2-matrix nze:\", a2.mat.nze)\n```\n\n----------------------------------------\n\nTITLE: Assembling DG Bilinear Forms\nDESCRIPTION: This snippet assembles the bilinear forms for the DG discretization.  It includes the volume term and the boundary terms. The trace operator is used to handle the boundary terms involving the average of the pressure.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nBel = BilinearForm(trialspace=fes_p, testspace=fes_u, geom_free = True)\nBel += grad(p)*v * dx -p*(v*n) * dx(element_boundary=True)\nBel.Assemble()\n\nBtr = BilinearForm(trialspace=fes_tr, testspace=fes_u, geom_free = True)\nBtr += phat * (v*n) *dx(element_boundary=True)\nBtr.Assemble();\n\nB = Bel.mat + Btr.mat @ traceop\n```\n\n----------------------------------------\n\nTITLE: Integrating over the intersection of level sets\nDESCRIPTION: This snippet calculates the area of the triangle by integrating the constant function 1 over the region where all three level set functions are negative. It uses the `Integrate` function with `dCut` to define the integration domain. The result is compared to the exact area to calculate the error.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\narea = Integrate(CoefficientFunction(1) * dCut(level_sets_p1, (NEG, NEG, NEG), order=0), mesh=mesh)\nerror = abs(area - 0.5)\nprint(\"Result of the integration: {}\".format(area))\nprint(\"Error of the integration: {:5.3e}\".format(error))\n```\n\n----------------------------------------\n\nTITLE: Creating 2D Periodic Geometry\nDESCRIPTION: This Python code snippet shows how to create a 2D periodic geometry using SplineGeometry in Netgen. The copy parameter of the Append method is used to define the appended spline as the slave of the one given in copy. It emphasizes that slave boundaries must be defined in the same direction as the master boundaries. It requires the netgen library.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/periodic.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import SplineGeometry\nfrom ngsolve import *\n\ngeo = SplineGeometry()\ngeo.AppendSpline ((-1, -1), (1, -1), bc=1)\ngeo.AppendSpline ((1, -1), (1, 1), bc=2)\ngeo.AppendSpline ((1, 1), (-1, 1), bc=3)\ngeo.AppendSpline ((-1, 1), (-1, -1), bc=4, copy=[0])\n\nmesh = geo.GenerateMesh(maxh=0.3)\n\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules - Python\nDESCRIPTION: This snippet imports the required modules from NGSolve, scipy, numpy, and ngsolve.eigenvalues. These modules are necessary for finite element analysis, linear algebra, and visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nimport math\nimport scipy.linalg\nimport numpy as np\nfrom ngsolve.eigenvalues import SOAR\n```\n\n----------------------------------------\n\nTITLE: Defining Geometry using Netgen OCC\nDESCRIPTION: This code defines the geometry of the problem using Netgen's OCC module. It creates rectangles and circles, assigns names to edges and faces for boundary conditions and material properties, and glues the shapes together to form the final geometry.  Regions 'fem' and 'waves' are defined for different discretization methods.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nr1 = Rectangle(1,1).Face()\nr1.edges.Min(Y).name = \"dir\"\nr1.edges.Max(Y).name = \"dir\"\nr1.edges.Min(X).name = \"dir\"\nr1.edges.Max(X).name = \"coupling\"\nr1.faces.name = \"fem\"\ncirc = Circle((0.4,0.7),0.02).Face()\ncirc.faces.name = \"femsource\"\n\ncirc2 = Circle((0.4,0.3),0.05).Face()\ncirc2.faces.name = \"femobstacle\"\n\n\nr2 = MoveTo(1,0).Rectangle(3,1).Face()\nr2.edges.Min(Y).name = \"dir\"\nr2.edges.Max(Y).name = \"dir\"\nr2.faces.name = \"waves\"\nshape = Glue([r1-circ-circ2, circ,circ2,r2])\n```\n\n----------------------------------------\n\nTITLE: Solving the adjoint equation\nDESCRIPTION: This code defines a function 'SolveAdjointEquation' that solves the adjoint equation, using the transpose of the stiffness matrix.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef SolveAdjointEquation():\n    rhs = gfp.vec.CreateVector()\n    rhs.data = fadjoint.vec - a.mat.T * gfp.vec\n    update = gfp.vec.CreateVector()\n    update.data = a.mat.Inverse(fes.FreeDofs()).T * rhs\n    gfp.vec.data += update\n```\n\n----------------------------------------\n\nTITLE: Setting up Pressure Preconditioner\nDESCRIPTION: This snippet sets up the bilinear form for the pressure mass matrix, which is used as a preconditioner for the pressure block in the block system solver.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nmp = BilinearForm(p*q*dx).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Printing Type of Assembled Matrix\nDESCRIPTION: This snippet prints the type of the assembled matrix from the bilinear form. It accesses the matrix using `a.mat` and prints its type using `type(a.mat)`. This is done to inspect the data structure used to store the matrix in a parallel context.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nprint('a.mat is a', type(a.mat))\n```\n\n----------------------------------------\n\nTITLE: Defining problem data\nDESCRIPTION: This code defines the problem data, including the right-hand side function 'f' and the desired state 'ud', using CoefficientFunction. It also calculates the gradients of 'f' and 'ud'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#given data of our problem (chosen such that \\Omega^* = [0,1]^2 is the optimal shape)\nf = CoefficientFunction(2*y*(1-y)+2*x*(1-x))\nud = x*(1-x)*y*(1-y)\n\ngrad_f = CoefficientFunction( (f.Diff(x), f.Diff(y) ) )\ngrad_ud = CoefficientFunction( (ud.Diff(x), ud.Diff(y) ) )\n```\n\n----------------------------------------\n\nTITLE: Assemble System with Task Manager\nDESCRIPTION: This code assembles the bilinear and linear forms using the NGSolve TaskManager. The TaskManager enables task-parallel execution, potentially speeding up the assembly process on multi-core systems.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwell.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n    a.Assemble()\n    f.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Setting Min-Max Values\nDESCRIPTION: This snippet demonstrates setting the minimum and maximum values for the color scale when drawing a scalar function. The `min` and `max` parameters control the range of values that are mapped to the color map.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nDraw (x*y*z, mesh, min=5, max=10);\n```\n\n----------------------------------------\n\nTITLE: Linear Form and Solver Setup for H(curl) in Python\nDESCRIPTION: This snippet sets up a linear form and solves the system using a CGSolver. It defines a linear form based on the curl of the test function and assembles it. A GridFunction is initialized, and the CGSolver is used to solve the system.  The code provides an example of setting up a solver for an H(curl) problem.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.5-amg/amg.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(curl(v)[2]*dx).Assemble()\ngfu = GridFunction(fes)\nfrom ngsolve.krylovspace import CGSolver\n\n# inv = CGSolver(a.mat, pre.mat, plotrates=False, maxiter=200)\n# gfu.vec[:] = inv*f.vec\n```\n\n----------------------------------------\n\nTITLE: Importing Necessary Libraries\nDESCRIPTION: This snippet imports the required libraries for the simulation, including NGSolve, the NGSolve web GUI, the Netgen OCC geometry module, and Matplotlib for plotting.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\nimport matplotlib.pyplot as plt\n```\n\n----------------------------------------\n\nTITLE: Import Custom Module - Python\nDESCRIPTION: Imports a custom module named `usrmeeting_jupyterstuff`. This module likely contains utility functions or configurations specific to the user's environment or project setup. The module is assumed to be available in the current environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom usrmeeting_jupyterstuff import *\n```\n\n----------------------------------------\n\nTITLE: Importing Custom Modules\nDESCRIPTION: This snippet imports a custom module named `usrmeeting_jupyterstuff`. This module likely contains functions or classes specific to the user's meeting setup in a Jupyter environment, facilitating tasks like cluster management.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom usrmeeting_jupyterstuff import *\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Symmetric System\nDESCRIPTION: This snippet defines the finite element space, trial and test functions, and the bilinear forms for the eigenvalue problem. Dirichlet boundary conditions are applied to the region named \"dir\".\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=4, complex=True, dirichlet=\"dir\")\n\nu = fes.TrialFunction()\nv = fes.TestFunction()\n\na = BilinearForm(grad(u)*grad(v)*dx).Assemble()\nm = BilinearForm(u*v*dx).Assemble();\n```\n\n----------------------------------------\n\nTITLE: Solving Stokes with Higher Order Taylor-Hood Elements\nDESCRIPTION: This snippet demonstrates solving the Stokes equation with higher-order Taylor-Hood elements (P4-P3). The `SolveStokes` function is called with the appropriate finite element spaces defined.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.6-stokes/stokes.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nV = VectorH1(mesh, order=4, dirichlet=\"wall|inlet|cyl\")\nQ = H1(mesh, order=3)\nX = V*Q\n\ngfu = SolveStokes(X)\n```\n\n----------------------------------------\n\nTITLE: Executing code in Jupyter cell\nDESCRIPTION: This snippet demonstrates executing Python code in a standard Jupyter cell. The code will run within the primary Jupyter process. This is the default execution behavior for cells without special directives.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.0-mpi_basics/MPI-Parallelization_in_NGSolve.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nprint('this is executed right here')\n```\n\n----------------------------------------\n\nTITLE: Setting CMake Minimum Required Version\nDESCRIPTION: Specifies the minimum required CMake version for the project.  This ensures that the project uses a version of CMake that supports the features used in the CMakeLists.txt file. Setting the minimum version avoids compatibility issues with older CMake versions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.16)\n```\n\n----------------------------------------\n\nTITLE: Differentiating a CoefficientFunction\nDESCRIPTION: This snippet demonstrates how to differentiate a CoefficientFunction using the `Diff` method. It calculates the partial derivative of `myfunc` with respect to `x` and visualizes the resulting derivative on the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndiff_myfunc = myfunc.Diff(x)\nDraw(diff_myfunc, mesh, \"derivative\");\n```\n\n----------------------------------------\n\nTITLE: Adding Vertical Boundary Elements in Python\nDESCRIPTION: This code snippet adds vertical boundary elements (1D elements) to the mesh. It iterates through the left and right edges of the grid and adds the corresponding elements to the mesh with a boundary condition index of 1.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(N):\n   mesh.Add(Element1D([pnums[i], pnums[i + 1]], index=1))\n   mesh.Add(Element1D([pnums[i + N * (N + 1)], pnums[i + 1 + N * (N + 1)]], index=1))\n```\n\n----------------------------------------\n\nTITLE: Visualizing active dofs\nDESCRIPTION: This snippet visualizes the active degrees of freedom of the cut finite element space. It sets the degrees of freedom corresponding to the first space to -1 and the second space to 1, and sets inactive degrees of freedom to 0.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ngfu.components[0].Set(CoefficientFunction(-1))\ngfu.components[1].Set(CoefficientFunction(1))\nfor i, val in enumerate(freedofs):\n    if not val:\n        gfu.vec[i] = 0.0\n```\n\n----------------------------------------\n\nTITLE: Drawing a Flux Variable on Active Mesh in NGSolve (Python)\nDESCRIPTION: This snippet utilizes the `Draw` function in NGSolve to visualize the first component of the `gfw` GridFunction (flux variable) on the active mesh, with deformation applied. It also sets a minimum and maximum for the color scale to 0 and 1.2 respectively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.9-unfmixed/unfmixed.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nDraw(BitArrayCF(hasneg)*gfw.components[0],mesh,\"u\",deformation=deformation, min=0, max=1.2)\n```\n\n----------------------------------------\n\nTITLE: Get Dofs Associated to Edges\nDESCRIPTION: This snippet creates a finite element space and iterates over the edges of the mesh, printing the degrees of freedom (Dofs) associated with each edge. It requires the `H1` finite element space and showcases obtaining Dof numbers related to specific mesh entities like edges.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=4)\nfor edge in mesh.edges:\n    print (\"type = \", type(edge)) \n    print (\"dofs = \", fes.GetDofNrs(edge))   \n```\n\n----------------------------------------\n\nTITLE: Computing Boundary with Compressed DomainTypeArray (Python)\nDESCRIPTION: This snippet calculates and visualizes the boundary of a compressed DomainTypeArray. The smoothing parameter in `IndicatorSmoothed` is controlled by the `interactive` variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nbnd2 = z_disc2.Boundary()\nDrawDC(bnd2.IndicatorSmoothed(level_sets_p1,0.08/interactive), -3.5, 2.5, mesh, \"bnd2\")\nbnd2.as_list\n```\n\n----------------------------------------\n\nTITLE: Visualizing HCurl Face Basis Function\nDESCRIPTION: This snippet visualizes a face basis function in the HCurl space. It retrieves DOFs for face 10, sets the corresponding `GridFunction` entry to 1, and visualizes the function and its curl.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nface_dofs = fes.GetDofNrs(NodeId(FACE,10))\nprint (\"facedofs: \", face_dofs)\nuc.vec[:] = 0\nuc.vec[face_dofs[0]] = 1\nDraw (uc, min=0, max=1, vectors = { \"grid_size\":30})\nDraw (curl(uc), mesh, \"curl\", min=-1, max=1, order=3); # it's a gradient\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve Modules\nDESCRIPTION: This code imports necessary modules from the NGSolve library. ngsolve provides the core functionality for finite element analysis. ngsolve.webgui enables visualization in a web browser. netgen.occ provides tools for Constructive Solid Geometry (CSG) modeling.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.4-Maxwell/Maxwell.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.occ import *\n```\n\n----------------------------------------\n\nTITLE: Setting GUI Parameters\nDESCRIPTION: This snippet shows how to set GUI parameters directly through the `settings` argument. The parameters are specified by their displayed names in the GUI. This allows for fine-grained control over the visualization appearance, such as the number of subdivisions and the number of colors in the colormap.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nDraw (func, mesh, settings = { \"subdivision\" : 1, \"Colormap\" : { \"ncolors\" : 3 } });\n```\n\n----------------------------------------\n\nTITLE: Drawing OCC Shape\nDESCRIPTION: This snippet demonstrates how to draw an OCC shape using Webgui. It creates a box geometry, names a face, and then uses the `Draw` function to render it in the Webgui interface. The shape object from netgen.occ is the input.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nshape = Box( (0,0,0), (5,3,2) )\nshape.faces.Max(X).name=\"right\"\nDraw (shape);\n```\n\n----------------------------------------\n\nTITLE: Plotting Convergence for MITC in NGSolve\nDESCRIPTION: This snippet uses matplotlib to plot the convergence of the MITC method. It plots the relative error against the number of degrees of freedom on a log-log scale.  The plot includes labels for the axes and is displayed using plt.show().\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\nplt.yscale('log')\nplt.xscale('log')\nplt.xlabel(\"ndof\")\nplt.ylabel(\"relative error\")\nndof,err = zip(*l)\nplt.plot(ndof,err, \"-*\")\nplt.ion()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Declaring a Complex-Valued Finite Element Space\nDESCRIPTION: This code defines a complex-valued finite element space using `H1`.  The `complex=True` argument is crucial for handling complex-valued solutions. `fes.TnT()` creates trial and test functions `u` and `v` within this space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/helmholtz.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=5, complex=True)\nu, v = fes.TnT()\n```\n\n----------------------------------------\n\nTITLE: Creating Geometry for Eigenvalue Problem\nDESCRIPTION: This snippet defines the geometry for the eigenvalue problem, creating a cavity opening into free space. A radial PML region is defined around a circular area. The code constructs the geometry and generates the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nshroom = MoveTo(-2, 0).Line(1.8).Rotate(-90).Line(0.8).Rotate(90).Line(0.4). \\\n    Rotate(90).Line(0.8).Rotate(-90).Line(1.8).Rotate(90).Arc(2, 180).Face()\ncirc = Circle((0, 0), 1).Face()\npmlregion = shroom - circ\npmlregion.faces.name = 'pml'\nair = shroom * circ\nair.faces.name = 'air'\nshape = Glue([air, pmlregion])\ngeo = OCCGeometry(shape, dim=2)\nmesh = Mesh(geo.GenerateMesh(maxh=0.1))\nmesh.Curve(5)\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining Circuit in PySpice\nDESCRIPTION: This snippet defines an electrical circuit using PySpice. It includes a sinusoidal voltage source, a resistor, and a capacitor. The capacitance value is obtained from the NGSolve calculation.  A try-except block handles potential errors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.1-ngspice/NGSpiceNGSolve.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    circuit = Circuit('test1')\n\n    source = circuit.SinusoidalVoltageSource(1, 'input', circuit.gnd, amplitude=1@u_V, frequency=1@u_kHz)\n    # source = circuit.PulseVoltageSource(1, 'input', circuit.gnd, 1, 2, 0, 0, 0, 0.001, 0.01)\n    \n    circuit.R(1, 'input', 'output', 100@u_kOhm)\n    # circuit.C(1, 'output', 0, 1@u_nF)\n    circuit.C(1, 'output', circuit.gnd, capacity)\n\n    print (circuit)\nexcept:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Installing the Library - CMake\nDESCRIPTION: This snippet installs the target `${lib_name}` to the `${ngs_install_dir}`. This installation step only occurs if the project name is NGSolve, meaning this is the main build.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_PROJECT_NAME STREQUAL \"NGSolve\")\n  install( TARGETS ${lib_name} ${ngs_install_dir} )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Set Color Property on Sphere in Netgen\nDESCRIPTION: This snippet shows how to set the color of a sphere using the col() method, enabling visualization with specific colors (RGB values).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsphere.col([1,0,0])#.transp()\n```\n\n----------------------------------------\n\nTITLE: Compiling a CoefficientFunction\nDESCRIPTION: This snippet compiles the `myfunc` CoefficientFunction using the `Compile` method.  Compiling optimizes the function for faster evaluation by translating the expression tree into a linear sequence of steps.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nmyfunc_compiled = myfunc.Compile()\n```\n\n----------------------------------------\n\nTITLE: Drawing Scalar Function on Mesh\nDESCRIPTION: This snippet demonstrates how to draw a scalar function defined by x*y*z on a mesh using Webgui. It takes a scalar function and an NGSolve mesh as input and visualizes the function values on the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfunc = x*y*z\nDraw (func, mesh);\n```\n\n----------------------------------------\n\nTITLE: Creating and Installing netgen_libs Interface Library\nDESCRIPTION: Creates an interface library named `netgen_libs` and links it to `nglib` and `ngcore`. It is then installed using the provided installation directory settings.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_26\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(netgen_libs INTERFACE)\ninstall(TARGETS netgen_libs ${ngs_install_dir})\ntarget_link_libraries(netgen_libs INTERFACE nglib ngcore)\n```\n\n----------------------------------------\n\nTITLE: Adding FASTCOMPILE Definition\nDESCRIPTION: Conditionally appends the FASTCOMPILE definition to the NGSOLVE_COMPILE_DEFINITIONS list if the FAST_COMPILE option is enabled. This allows skipping optimized function code for faster compilation times.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_17\n\nLANGUAGE: cmake\nCODE:\n```\nif(FAST_COMPILE)\n  list(APPEND NGSOLVE_COMPILE_DEFINITIONS FASTCOMPILE)\nendif(FAST_COMPILE)\n```\n\n----------------------------------------\n\nTITLE: Javascript code sending message to Python\nDESCRIPTION: This Javascript code sends a message to Python containing information about the selected dimension and index when a selection event occurs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_15\n\nLANGUAGE: javascript\nCODE:\n```\nscene.on(\"select\", ({dim, index}) => {\n  console.log(\"selected\", dim, index);\n  scene.widget.send({type: 'select', dim, index})\n})\n```\n\n----------------------------------------\n\nTITLE: Drawing Extended Basis Functions\nDESCRIPTION: This snippet calls the ExtendedBasisFunctionsAsMultiDim function to generate extended basis functions and then visualizes them on the mesh.  The user can interact with the webgui to change the active basis function to observe its extension.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngfshow = ExtendedBasisFunctionsAsMultiDim(EA,fes)\nDraw (gfshow, mesh, interpolate_multidim=False, animate=False, autoscale=True);\n```\n\n----------------------------------------\n\nTITLE: Setting edge names after mesh generation\nDESCRIPTION: This snippet demonstrates how to change the name of an edge (BBoundary) after the mesh has been generated, using the `SetCD2Name` method. The edges are referenced by a 1-based index.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmesh.ngmesh.SetCD2Name(1, \"other_bbnd_name\")\nprint(\"BBnd = \", mesh.GetBBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Removing Temporary Files - Python\nDESCRIPTION: This snippet removes the temporary files created during the pickling and unpickling process. It uses the `os.remove` function to delete the files. The `os` module provides operating system-related functionality.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.remove(\"mesh.pkl\")\nos.remove(\"gridfunction.pkl\")\nos.remove(\"func.pkl\")\n```\n\n----------------------------------------\n\nTITLE: Stop Cluster - Python\nDESCRIPTION: Stops the computational cluster associated with the specified user ID. This function likely terminates any running processes or resources allocated to the cluster.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstop_cluster(user_id)\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh and Libraries in NGSolve (Python)\nDESCRIPTION: This snippet initializes the necessary libraries (ngsolve, ngsolve.webgui, matplotlib.pylab) and creates a mesh using the unit square geometry with a specified maximum element size.  The `Mesh` object is essential for defining the computational domain for finite element analysis. The maxh parameter controls the mesh refinement.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nimport matplotlib.pylab as plt\nmesh = Mesh(unit_square.GenerateMesh(maxh=2))\n```\n\n----------------------------------------\n\nTITLE: Solve Poisson Problem with Local Preconditioner\nDESCRIPTION: This code snippet solves the defined Poisson problem using the 'local' preconditioner, which is a simple Jacobi preconditioner. The results are then printed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.1-preconditioners/preconditioner.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nSolveProblem(precond=\"local\")\n```\n\n----------------------------------------\n\nTITLE: Getting Boundaries for Dynamic Contact Problem - Python\nDESCRIPTION: Retrieves the boundary names of the generated mesh, which are then used to set up the contact condition.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmesh.GetBoundaries()\n```\n\n----------------------------------------\n\nTITLE: Import Visualization Modules in NGSolve\nDESCRIPTION: This snippet imports necessary modules from the ngsolve library for visualizing geometries and meshes. The Draw and Redraw functions are used to display the constructed geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# import netgen.gui\nfrom ngsolve import Draw, Redraw # just for visualization\n```\n\n----------------------------------------\n\nTITLE: Select Faces by X Coordinate Less than 0.8 - Python\nDESCRIPTION: This snippet selects faces of a box where the x-coordinate of the center of gravity is less than 0.8. The selected faces are displayed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\nDrawGeo (Compound(box.faces[X<0.8]));\n```\n\n----------------------------------------\n\nTITLE: Accessing and Printing Degrees of Freedom\nDESCRIPTION: This Python code accesses the number of degrees of freedom (ndof) of the finite element space `fes` and prints it to the console. This is a basic check to verify that the finite element space is correctly initialized and contains the expected number of degrees of freedom.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nprint (\"ndof = \", fes.ndof)\n```\n\n----------------------------------------\n\nTITLE: Parametric Solver Definition\nDESCRIPTION: This function `Solve` takes two parameters (Ax, Ay), deforms the mesh based on these parameters, assembles the bilinear and linear forms, and solves the resulting linear system to obtain the solution `gfu`. It sets up a parametric problem where the mesh deformation depends on the parameters.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef Solve(Ax, Ay):\n    mesh.UnsetDeformation()\n    deform.Interpolate ( (x*y*Ax, x*y*Ay) )\n    mesh.SetDeformation(deform)\n    a.Assemble()\n    f.Assemble()\n    gfu.vec.data = a.mat.Inverse(fes.FreeDofs()) * f.vec\n```\n\n----------------------------------------\n\nTITLE: Changing BBoundary names of structured surface meshes\nDESCRIPTION: This snippet demonstrates how to change the boundary names (BBoundaries) of a structured surface mesh after generation using `SetCD2Name`. The boundaries are initially named \"left\", \"right\", \"top\", and \"bottom\" based on the unit square.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(mesh.GetBBoundaries())\nmesh.ngmesh.SetCD2Name(1, \"other_name\")\nprint(mesh.GetBBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Convergence Study for MITC in NGSolve\nDESCRIPTION: This snippet performs a convergence study for the MITC method. It iteratively solves the BVP, computes the relative error between the numerical solution and the exact solution, stores the error and number of degrees of freedom, and refines the mesh. The process is repeated for a specified number of iterations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nl = []\nfor i in range(5):\n    print(\"i = \", i)\n    SolveBVP()\n    if clamped:\n        norm_w = sqrt(Integrate(w_c_ex*w_c_ex, mesh))\n        err = sqrt(Integrate((gfu-w_c_ex)*(gfu-w_c_ex), mesh))/norm_w\n    else:\n        norm_w = sqrt(Integrate(w_s_ex*w_s_ex, mesh))\n        err = sqrt(Integrate((gfu-w_s_ex)*(gfu-w_s_ex), mesh))/norm_w\n    print(\"err = \", err)\n    l.append ( (fes.ndof, err ))\n    mesh.Refine()\n```\n\n----------------------------------------\n\nTITLE: Derivatives of Evolution Equations in ngsolve (Python)\nDESCRIPTION: This snippet computes the partial derivatives of the evolution equations with respect to both the external (strain) and internal (p, alpha, Lambda) state variables.  These derivatives are essential for calculating the sensitivity of the internal states to changes in strain during the linearization process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# instance of evolution equations based only on grid functions for direct evaluation\neqs_gf = evolution_eqs(strain_gf, gfp, gfalpha, gfLambda, evol_tol)\n\ndim_eqs = eqs_gf.dim\n\n# Partial derivate w.r.t. external (strain) state\ndext_eqs_gf = eqs_gf.Diff(strain_gf).Reshape((dim_eqs, strain_gf.dim))\n\n# Partial derivates w.r.t. internal states; need to be reshaped in order to put them together \n#  in a single expression below.\ndp_eqs_gf = eqs_gf.Diff(gfp).Reshape((dim_eqs, gfp.dim))\ndalpha_eqs_gf = eqs_gf.Diff(gfalpha).Reshape((dim_eqs, 1))\ndLambda_eqs_gf = eqs_gf.Diff(gfLambda).Reshape((dim_eqs, 1))\n\ndint_eqs_gf = \\\n   dp_eqs_gf.ExtendDimension((dim_eqs, dim_int), pos=(0,0)) \\\n + dalpha_eqs_gf.ExtendDimension((dim_eqs, dim_int), pos=(0, gfp.dim)) \\\n + dLambda_eqs_gf.ExtendDimension((dim_eqs, dim_int), pos=(0, gfp.dim + gfalpha.dim))\n```\n\n----------------------------------------\n\nTITLE: Define Finite Element Space\nDESCRIPTION: Defines a finite element space using H1 elements of order 4 on the mesh. Dirichlet boundary conditions are applied on all boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nV = H1(mesh, order=4, dirichlet=\".*\")\nu = V.TrialFunction()\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries to ngbla\nDESCRIPTION: This snippet links the `ngbla` library with `ngstd`, MPI libraries, and netgen/lapack. The usage requirements specify the interfaces to other dependent libraries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_link_libraries(ngbla PUBLIC ngstd ${MPI_CXX_LIBRARIES} PRIVATE \"$<BUILD_INTERFACE:netgen_python>\")\ntarget_link_libraries(ngbla ${LAPACK_CMAKE_LINK_INTERFACE} \"$<BUILD_INTERFACE:ngs_lapack>\")\n```\n\n----------------------------------------\n\nTITLE: Solving the System in NGSolve\nDESCRIPTION: This snippet solves the assembled system of equations. It applies Dirichlet boundary conditions to the facet component of the GridFunction, and then either solves the condensed system using a CG solver with a preconditioner or solves the full system using a direct solver with an inverse.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.7-hybrid/hybrid.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nf.Assemble()\ngfu.components[2].Set(ud, BND)\n\nif a.condense:\n\n    fmod = (f.vec + a.harmonic_extension_trans * f.vec).Evaluate()\n    solvers.CG(mat=a.mat, pre=c.mat, rhs=fmod, sol=gfu.vec, initialize=False)\n    \n    gfu.vec.data += a.harmonic_extension * gfu.vec\n    gfu.vec.data += a.inner_solve * f.vec\n\nelse:\n    \n    r = f.vec - a.mat * gfu.vec\n    inv = a.mat.Inverse(freedofs=X.FreeDofs())\n    gfu.vec.data += inv * r\n```\n\n----------------------------------------\n\nTITLE: Setting up the deformation equation\nDESCRIPTION: This code sets up a bilinear form for the deformation equation and defines a grid function to store the deformation field.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nb = BilinearForm(VEC)\nb += InnerProduct(grad(X),grad(PHI))*dx + InnerProduct(X,PHI)*dx\n\ngfX = GridFunction(VEC)\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for Geometry and NGSolve\nDESCRIPTION: Imports necessary libraries for geometry creation using Netgen OCC, visualization, and finite element analysis with NGSolve.  These imports provide the core functionality for defining the problem domain and performing the numerical simulation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom netgen.webgui import Draw as DrawGeo\nimport ngsolve\n```\n\n----------------------------------------\n\nTITLE: Defining Complex CoefficientFunctions\nDESCRIPTION: This snippet defines a series of complex CoefficientFunctions (f0, f1, f2, f3, final) built from simpler ones. These functions are used to demonstrate the performance benefits of compiling.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nf0 = myfunc\nf1 = f0*y \nf2 = f1*f1 + f1*f0 + f0*f0 \nf3 = f2*f2*f2*f0**2 + f0*f2**2 + f0**2 + f1**2 + f2**2\nfinal = f3 + f3 + f3 \nfinalc = final.Compile()\n```\n\n----------------------------------------\n\nTITLE: Defining a Vector-Valued CoefficientFunction\nDESCRIPTION: This snippet defines a vector-valued CoefficientFunction using the `CoefficientFunction` constructor. It creates a function that maps a point (x, y) to the vector (-y, sin(x)).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nvecfun = CoefficientFunction((-y, sin(x)))\n```\n\n----------------------------------------\n\nTITLE: Drawing NGSolve Grid Function\nDESCRIPTION: This code retrieves the `gfu` GridFunction from all engines of the ipyparallel cluster, then draws the first component using the ngsolve.webgui.Draw function.  This allows visualization of the solution computed on the parallel cluster.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngfu = c[:][\"gfu\"]\nfrom ngsolve.webgui import Draw\n```\n\nLANGUAGE: python\nCODE:\n```\nDraw (gfu[0]);\n```\n\n----------------------------------------\n\nTITLE: Modify Boundary Condition Between Solids in Netgen\nDESCRIPTION: This snippet demonstrates how to modify the boundary condition on the interface between two solids using the bcmod argument when adding a solid to the CSGeometry. This allows for specific boundary conditions at interfaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nhalfsphere = sphere * Plane(Pnt(0,0,0),Vec(1,0,0)).bc('plane')\nbox = brick-sphere\ngeo = CSGeometry()\ngeo.Add(box.col([1,0,0]).transp())\ngeo.Add(halfsphere.col([0,0,1]),bcmod=[(box,\"halfsphere\")])\ngeo.Draw()\n```\n\n----------------------------------------\n\nTITLE: Get Faces of a Cell\nDESCRIPTION: This snippet retrieves the faces of a cell using NodeId and MeshNode. It demonstrates accessing topological information of higher dimensional mesh entities, such as cells and their faces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nc = NodeId(CELL, 1)\nmeshc = mesh[c]\nmeshc.faces          # faces of a cell\n```\n\n----------------------------------------\n\nTITLE: Setting Number of Processes\nDESCRIPTION: This snippet sets the number of processes to be used for parallel execution. It is a simple assignment of a string value to a variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnum_procs = '40'\n```\n\n----------------------------------------\n\nTITLE: Printing the Output Dimension\nDESCRIPTION: Prints the degrees of freedom of the finite element space to standard output.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.2-tensorflow/TensorFlowNGSolve.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint (output_dim)\n```\n\n----------------------------------------\n\nTITLE: Accessing Triangle Basis Functions\nDESCRIPTION: This snippet shows how to access and visualize basis functions associated with a triangle (face) in the H1 space. It retrieves the DOFs associated with face 0, sets all `GridFunction` values to zero, sets the first DOF of the face to 10, and visualizes the resulting basis function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntrig_dofs = fes.GetDofNrs(NodeId(FACE,0))\nprint(\"trig_dofs = \", trig_dofs)\ngfu.vec[:] = 0\ngfu.vec[trig_dofs[0]] = 10\nDraw(gfu, order=3, min=0, max=0.3, deformation=True);\n```\n\n----------------------------------------\n\nTITLE: Defining Skeleton Integrals - Python\nDESCRIPTION: This code defines differential symbols for facet integrals on inner and boundary facets using `dx(skeleton=True)` and `ds(skeleton=True)`.  It also demonstrates how to restrict the boundary integrals to specific named boundaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndskel_inner  = dx(skeleton=True)\ndskel_bound  = ds(skeleton=True)\n# or:\ndskel_inflow = ds(skeleton=True, definedon=mesh.Boundaries(\"left|bottom\"))\ndskel_outflow = ds(skeleton=True, definedon=mesh.Boundaries(\"right|top\"))\n```\n\n----------------------------------------\n\nTITLE: Block Inverse Operations with Embedding and Mass Matrix\nDESCRIPTION: This snippet demonstrates how to create block inverse operators by combining the `Embedding` operator with the inverse mass matrix operation. It defines the embedding operator and mass matrix for the pressure finite element space, then calculates the inverse operator.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npdofs = fes.Range(0);\nemb_p = Embedding(fes.ndof, pdofs)\ninvmassp = fes_p.Mass(1).Inverse()\ninvp = emb_p @ invmassp @ emb_p.T\n```\n\n----------------------------------------\n\nTITLE: Sensitivity of Internal States in ngsolve (Python)\nDESCRIPTION: This snippet calculates the sensitivity of the internal states with respect to the external (strain) state. It uses the previously computed derivatives of the evolution equations and the VS embedding to obtain the sensitivity matrix `dext_int`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nA_red = VS_cf.trans * dint_eqs_gf * VS_cf\nA_red_inv = Inv(A_red)\nA_inv = VS_cf * A_red_inv * VS_cf.trans\n\n# sensitivity of internal states wrt to external states, i.e. strain\ndext_int = -A_inv * dext_eqs_gf\n```\n\n----------------------------------------\n\nTITLE: Printing the Expression Tree of a CoefficientFunction\nDESCRIPTION: This snippet prints the expression tree representation of the `myfunc` CoefficientFunction.  This shows the internal structure of how the function is represented in NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(myfunc) \n```\n\n----------------------------------------\n\nTITLE: Drawing component 0 of GridFunction\nDESCRIPTION: This snippet draws the first component of the GridFunction gfu on the mesh, labeling it as \"background_uneg\".\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nDraw(gfu.components[0], mesh, \"background_uneg\")\n```\n\n----------------------------------------\n\nTITLE: Setting number of processes Python\nDESCRIPTION: Sets the number of processes to be used in the parallel computation. This value is used later when starting the cluster.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnum_procs = '100'\n```\n\n----------------------------------------\n\nTITLE: Add Rectangle Shape - Python\nDESCRIPTION: This snippet adds a rectangle to the geometry using the `AddRectangle` method. It defines the lower-left and upper-right corners of the rectangle. It provides a convenient way to create rectangular shapes within the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/define_2d_geometries.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ngeo.AddRectangle((0,0), (3,2))\n```\n\n----------------------------------------\n\nTITLE: Setting up the mesh deformation\nDESCRIPTION: This code sets up the mesh deformation by defining a grid function 'gfset' to store the deformation and applying it to the mesh. It also enables visualization of the deformed mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# gfset denotes the deformation of the original domain and will be updated during the shape optimization\ngfset = GridFunction(VEC)\ngfset.Set((0,0))\nmesh.SetDeformation(gfset)\nsceneSet = Draw(gfset,mesh,\"gfset\")\nSetVisualization (deformation=True)\n```\n\n----------------------------------------\n\nTITLE: Integrating over regions of co-dimension 1 (sides of the triangle)\nDESCRIPTION: These snippets compute the lengths of the sides of the triangle by integrating the constant function 1 over the regions where one level set function is zero (IF) and the other two are negative.  The `dCut` function is used with appropriate domain types (IF, NEG, NEG), (NEG, IF, NEG), and (NEG, NEG, IF). The results are compared with the exact lengths to calculate the error.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nlen_top = Integrate(CoefficientFunction(1) * dCut(level_sets_p1, (IF, NEG, NEG), order=0), mesh)\nprint(\"Top side-length of the triangle\");\nprint(\"Result of the integration: {}\".format(len_top))\nprint(\"Error of the integration: {:5.3e}\".format(abs(len_top - 1)))\n\nlen_right = Integrate(CoefficientFunction(1) * dCut(level_sets_p1, (NEG, IF, NEG), order=0), mesh)\nprint(\"\\nRight side-length of the triangle\")\nprint(\"Result of the integration: {}\".format(len_right))\nprint(\"Error of the integration: {:5.3e}\".format(abs(len_right - sqrt(5)/2)))\n\nlen_left = Integrate(CoefficientFunction(1) * dCut(level_sets_p1, (NEG, NEG, IF), order=0), mesh)\nprint(\"\\nLeft side-length of the triangle\")\nprint(\"Result of the integration: {}\".format(len_left))\nprint(\"Error of the integration: {:5.3e}\".format(abs(len_left - sqrt(5)/2)))\n```\n\n----------------------------------------\n\nTITLE: Examining FreeDofs of a space on a subdomain\nDESCRIPTION: This snippet prints the `FreeDofs` array of the finite element space defined on the subdomain.  This shows which degrees of freedom are actively used in the subdomain space, as opposed to being unused.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(fes1.FreeDofs())\n```\n\n----------------------------------------\n\nTITLE: Setting environment variables\nDESCRIPTION: This command builds the 'set_environment_variables' target, which configures the necessary environment variables (PATH, NETGENDIR, PYTHONPATH) for NGSolve to run correctly after installation.  This step is crucial for ensuring that NGSolve can be found and used by other applications.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installwindows.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncmake --build . --config Release --target set_environment_variables\n```\n\n----------------------------------------\n\nTITLE: Shape derivative linear form for SciPy - Python\nDESCRIPTION: This snippet defines the linear form `fX` for the shape derivative, which is used in the SciPy optimization. The shape derivative is calculated as an integral over the domain, involving the function `f`, its gradient, and the test function `PSI`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfX = LinearForm(VEC)\n\n# analytic shape derivative\nfX += f*div(PSI)*dx + (f.Diff(x,PSI[0])) *dx + (f.Diff(y,PSI[1])) *dx\n```\n\n----------------------------------------\n\nTITLE: Stokes Discretization with HDG\nDESCRIPTION: This snippet defines the bilinear form for the Stokes discretization using the HDG method. It includes terms for diffusion, interface terms involving tangential jumps, and pressure terms. The bilinear form is then assembled.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.7-opsplit/opsplit.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nalpha = 4  # SIP parameter\ndS = dx(element_boundary=True)\na = BilinearForm ( V, symmetric=True)\na += nu * InnerProduct ( Grad(u), Grad(v) ) * dx\na += nu * InnerProduct ( Grad(u)*n, tang(vhat-v) ) * dS \na += nu * InnerProduct ( Grad(v)*n, tang(uhat-u) ) * dS\na += nu * alpha*order*order/h * InnerProduct(tang(vhat-v), tang(uhat-u)) * dS\na += (-div(u)*q - div(v)*p) * dx\na.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Finite Element Space Instance\nDESCRIPTION: This Python code creates an instance of a custom finite element space, `MyFESpace`, defined in the compiled module `m`. It passes the generated mesh, sets the `secondorder` flag to True, and specifies Dirichlet boundary conditions on the left, bottom, and top boundaries of the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfes = m.MyFESpace(mesh, secondorder=True, dirichlet=\"left|bottom|top\")\n```\n\n----------------------------------------\n\nTITLE: Plotting Convergence for TDNNS in NGSolve\nDESCRIPTION: This snippet uses matplotlib to plot the convergence of the TDNNS method. It plots the relative error against the number of degrees of freedom on a log-log scale. The plot includes labels for the axes and is displayed using plt.show().\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nplt.yscale('log')\nplt.xscale('log')\nplt.xlabel(\"ndof\")\nplt.ylabel(\"relative error\")\nndof,err = zip(*l)\nplt.plot(ndof,err, \"-*\")\n\nplt.ion()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Get Vertices, Edges, and Facets of Volume Element\nDESCRIPTION: This snippet gets the vertices, edges, and facets of a volume element accessed via ElementId.  It showcases querying the different topological entities that make up a volume element.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nelt0.vertices, elt0.edges, elt0.facets\n```\n\n----------------------------------------\n\nTITLE: Restrict Mesh Size at Specific Points in Netgen\nDESCRIPTION: This snippet shows how to restrict the mesh size at specific points using the RestrictH method within a MeshingParameters object.  This provides fine-grained control over mesh refinement at arbitrary points in space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\n\nbrick = OrthoBrick(Pnt(-2,-2,-2),Pnt(2,2,2))\nsphere = Sphere(Pnt(0,0,0),1)\n\nmp = MeshingParameters(maxh=0.4)\nmp.RestrictH (x=0, y=0, z=1, h=0.025)\n        \ngeo.Add(brick-sphere)\ngeo.Add(sphere)\nngmesh = geo.GenerateMesh(mp = mp)\n```\n\n----------------------------------------\n\nTITLE: Creating Block Gauss-Seidel Preconditioner\nDESCRIPTION: Creates a symmetric block Gauss-Seidel preconditioner using the `SymmetricGS` class and the block Jacobi smoother `blockjac`.  The `EigenValues_Preconditioner` is then used to determine the condition number of `a.mat` preconditioned with the newly created `blockgs` preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nblockgs = SymmetricGS(blockjac)\nlams = EigenValues_Preconditioner(mat=a.mat, pre=blockgs)\nmax(lams)/min(lams)\n```\n\n----------------------------------------\n\nTITLE: VS Embedding for Internal States in ngsolve (Python)\nDESCRIPTION: Since the internal state `p` is deviatoric, its embedding into a vector space is non-trivial. This snippet retrieves a non-trivial embedding for `p` and creates a common embedding for all internal states (p, alpha, and Lambda) for the linearization process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# VS embedding\n\n# Retreive non-trivial embedding for p\nVS_p = gfp.space.VSEmbedding().NumPy()\n\n# Create a common embedding for all internal states\nVS_all = np.zeros((dim_eqs, VS_p.shape[1] + 2))\nVS_all[:VS_p.shape[0], :VS_p.shape[1]] = VS_p\nVS_all[VS_p.shape[0], VS_p.shape[1]] = 1\nVS_all[VS_p.shape[0] + 1, VS_p.shape[1] + 1] = 1\n\n# Create a CoefficienFunction from the array\nVS_cf = CF(tuple(VS_all.flatten().tolist()), dims=VS_all.shape)\n```\n\n----------------------------------------\n\nTITLE: Setting Number of Processes\nDESCRIPTION: This snippet defines the number of processes to be used in the MPI cluster. It initializes a string variable `num_procs` to '20'.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nnum_procs = '20'\n```\n\n----------------------------------------\n\nTITLE: Windows Build Instructions in CMake\nDESCRIPTION: This snippet uses the `message` command within an `if(WIN32)` block to provide build instructions specific to Windows systems.  It directs the user to open the NGSolve.sln file and build the solution, followed by building the \"INSTALL\" target to install the project.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_54\n\nLANGUAGE: cmake\nCODE:\n```\nif(WIN32)\nmessage(\"\n    Open ${CMAKE_BINARY_DIR}/NGSolve.sln and build solution to compile ${PROJECT_NAME}.\n\n    Build \\\"INSTALL\\\" to install ${PROJECT_NAME}.\n\")\nelse(WIN32)\nmessage(\"\n    Type 'make' to compile ${PROJECT_NAME}.\n\n    Type 'make install' to install ${PROJECT_NAME}.\n\n\")\nendif(WIN32)\n```\n\n----------------------------------------\n\nTITLE: Stopping MPI Cluster\nDESCRIPTION: This snippet stops the MPI cluster. It calls the `stop_cluster()` function to shut down the MPI environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_22\n\nLANGUAGE: Python\nCODE:\n```\nstop_cluster()\n```\n\n----------------------------------------\n\nTITLE: Drawing a Mesh - Python\nDESCRIPTION: This snippet uses the `Draw` function from `ngsolve.webgui` to visualize the unpickled mesh.  This assumes a web GUI is available for display.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nDraw (mesh2);\n```\n\n----------------------------------------\n\nTITLE: Defining a surface via a mapping function\nDESCRIPTION: This snippet defines a mapping function that transforms a 2D domain to a 3D surface.  The mapping function takes x, y, and z coordinates as input and returns the corresponding 3D coordinates.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom math import pi\nL  = 12\nW  = 1.1\nmapping = lambda x,y,z : (x*L, -W*(y-0.5)*sin(pi/2*x), W*(y-0.5)*cos(pi/2*x) )\n```\n\n----------------------------------------\n\nTITLE: Timing Integration of a CoefficientFunction\nDESCRIPTION: This snippet uses the `%timeit` magic command to measure the time taken to integrate the `final` CoefficientFunction over the mesh.  This provides a baseline for comparing the performance of the compiled function.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n%timeit Integrate(final, mesh, order=10)\n```\n\n----------------------------------------\n\nTITLE: Computing Capacitance with NGSolve\nDESCRIPTION: This snippet defines a finite element space, sets boundary conditions, and computes the capacitance. It uses H1 elements of order 3. Boundary conditions are set on edges 'el1' (1V) and 'el2' (0V). The capacitance is then calculated using the InnerProduct.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-10.1-ngspice/NGSpiceNGSolve.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=3, dirichlet=\"el1|el2\")\nu,v = fes.TnT()\ngfu = GridFunction(fes)\ngfu.Set (mesh.BoundaryCF({\"el1\":1, \"el2\":0}), BND)\n\nmata = BilinearForm(10*8.854e-12*grad(u)*grad(v)*dx).Assemble().mat\ninv = mata.Inverse(inverse=\"sparsecholesky\", freedofs=fes.FreeDofs())\ngfu.vec.data -= inv@mata * gfu.vec\n\ncapacity = InnerProduct(mata*gfu.vec, gfu.vec)\nprint (\"capacity=\", capacity)\nDraw (gfu);\n```\n\n----------------------------------------\n\nTITLE: Refining Mesh with Periodic Conditions\nDESCRIPTION: This snippet refines the mesh generated from the cake geometry to improve the accuracy of the solution.  It generates the mesh using OCCGeometry, refines it using `mesh.ngmesh.Refine()`, and visualizes identified nodes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/periodicity.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(OCCGeometry(cake).GenerateMesh(maxh=0.5)) # .Curve(3)\nmesh.ngmesh.Refine()\n\nplist = []\nfor pair in mesh.ngmesh.GetIdentifications():\n    plist += list(mesh.ngmesh[pair[0]].p)\n    plist += list(mesh.ngmesh[pair[1]].p)\nDraw(mesh, objects=[{\"type\" : \"lines\", \"position\" : plist, \"name\": \"identification\", \"color\": \"purple\"}]);\n```\n\n----------------------------------------\n\nTITLE: Adding and labeling single points (BBBoundaries)\nDESCRIPTION: This snippet shows how to add and label single points (BBBoundaries) to the geometry. These points can be used for various purposes, such as defining point loads. The `AddPoint` method adds a point to the geometry and associates a name with it.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\ngeo.Add(Sphere(Pnt(0,0,0),1))\ngeo.AddPoint(Pnt(0,0,1), \"pntload\")\nmesh = Mesh(geo.GenerateMesh(maxh=0.5, perfstepsend=MeshingStep.MESHSURFACE))\nDraw(mesh)\nprint(\"BBBnd = \", mesh.GetBBBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Printing Operator Information for PML Combined Operator\nDESCRIPTION: This snippet prints information about the `op1` operator, which is used in the PML implementation and combines several operators.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint (op1.GetOperatorInfo())\n```\n\n----------------------------------------\n\nTITLE: Listing files in the current directory using shell command\nDESCRIPTION: This code snippet shows how to use the `ls` command within a Python environment to list files in the current directory. The `!` prefix indicates that the command should be executed in the shell. This is used to verify the creation of the VTK output file.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-vtk/vtk.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n!ls -lh vtk_example1*\n```\n\n----------------------------------------\n\nTITLE: Visualizing Sparsity Pattern with Matplotlib\nDESCRIPTION: This snippet visualizes the sparsity pattern of a SciPy sparse matrix using Matplotlib. It uses the `plt.spy()` function to create a plot showing the non-zero elements of the matrix. Requires Matplotlib to be installed.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_numpy.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pylab as plt\nplt.spy(A)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Importing Netgen/NGSolve Modules - Python\nDESCRIPTION: This snippet imports necessary modules from Netgen/NGSolve, including core NGSolve functionalities, the web GUI, geometry features, and internal functionalities for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#import netgen.gui\n# ngsolve stuff\nfrom ngsolve import *\nfrom ngsolve.webgui import *\n# basic geometry features (for the background mesh)\nfrom netgen.geom2d import SplineGeometry\n# visualization stuff\nfrom ngsolve.internal import *\n```\n\n----------------------------------------\n\nTITLE: Creating PETSc Matrix and Vector Mapping\nDESCRIPTION: This code creates a PETSc matrix from an NGSolve matrix and sets up a vector mapping between NGSolve and PETSc vectors. It utilizes the `CreatePETScMatrix` function to convert the NGSolve matrix `a.mat` to a PETSc matrix, considering the free degrees of freedom of the finite element space.  A `VectorMapping` object is created to facilitate the transfer of vector data between the two systems.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%px\npsc_mat = n2p.CreatePETScMatrix(a.mat, fes.FreeDofs())\nvecmap = n2p.VectorMapping (a.mat.row_pardofs, fes.FreeDofs())\n```\n\n----------------------------------------\n\nTITLE: Sparse Matrix Visualization using SciPy and Matplotlib (Python)\nDESCRIPTION: This snippet converts the assembled bilinear form matrix into a SciPy sparse matrix and visualizes its sparsity pattern using Matplotlib. It requires the `scipy` and `matplotlib` libraries. The `plt.spy()` function displays the non-zero elements in the matrix, providing insight into its structure.  This can be useful for understanding the connectivity and dependencies within the finite element system.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport scipy.sparse as sp\nA = sp.csr_matrix(a.mat.CSR())\nplt.rcParams['figure.figsize'] = (4,4)\nplt.spy(A)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Drawing with unit_cube - Python\nDESCRIPTION: This snippet imports the necessary modules (`netgen.csg`, `ngsolve`, `ngsolve.webgui`) and creates a mesh from a unit cube. It then initializes the webgui Draw function for the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.csg import unit_cube\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nm = Mesh(unit_cube.GenerateMesh(maxh=0.2))\n\nhelp(Draw)\n```\n\n----------------------------------------\n\nTITLE: Mapping Reference Time to Physical Time (Python)\nDESCRIPTION: This snippet defines parameters to map the reference time variable (tref) to the physical time.  It introduces 'told' (previous time step) and 'delta_t' (time step size) as Parameters, enabling dynamic control of the time interval during the simulation. 'tref' represents the time within the reference interval [0,1).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.5-spacetime_unfitted/spacetime_unfitted.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Map from reference time to physical time\ntold = Parameter(tstart)\nt = told + delta_t * tref\nt.MakeVariable()\n```\n\n----------------------------------------\n\nTITLE: Creating Periodic Geometries (Python)\nDESCRIPTION: This snippet shows how to construct a geometry for a periodic $L_2$ finite element space. It uses the `copy` argument of `geo.Append` to identify opposite segments, ensuring the meshing algorithm copies the boundary mesh to the opposite segment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom math import pi, cos, sin\ngeo = SplineGeometry()\npnums = [ geo.AddPoint(cos(phi),sin(phi)) for phi in [x*pi/3 for x in range(6)] ]\nl1 = geo.Append([\"line\", 0, 1], leftdomain=1, rightdomain=0, bc=\"upperRight\")\nl2 = geo.Append([\"line\", 1, 2], leftdomain=1, rightdomain=0, bc=\"upperCenter\")\nl3 = geo.Append([\"line\", 2, 3], leftdomain=1, rightdomain=0, bc=\"upperLeft\")\ngeo.Append([\"line\", 0, 5], leftdomain=0, rightdomain=1, bc=\"lowerRight\", copy = l3)\ngeo.Append([\"line\", 5, 4], leftdomain=0, rightdomain=1, bc=\"lowerCenter\", copy = l2)\ngeo.Append([\"line\", 4, 3], leftdomain=0, rightdomain=1, bc=\"lowerLeft\", copy = l1)\nngmesh = geo.GenerateMesh(maxh=0.1)\n```\n\n----------------------------------------\n\nTITLE: Adding CUDA Library - CMake\nDESCRIPTION: This snippet creates a shared library named `${lib_name}` (defined in the previous snippet) from a list of `.cpp` and `.cu` files. These files contain the CUDA and C++ code for the library.  It includes CUDA kernels, C++ implementations and header files.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(${lib_name} SHARED\n    cuda_linalg.cpp unifiedvector.cpp cuda_tasks.cpp\n    cuda_ngstd.cpp cuda_ngbla.hpp cuda_applyIR.cpp\n    linalg_kernels.cu dev_sparsecholesky.cpp dev_blockjacobi.cpp cuda_profiler.cu\n)\n```\n\n----------------------------------------\n\nTITLE: Solving for External Unknowns (NGSolve, Python)\nDESCRIPTION: This code snippet solves for the external unknowns using the Schur complement matrix (`a.mat.Inverse`) and the modified right-hand side vector. `fes.FreeDofs(True)` provides the indices of the free degrees of freedom, representing the external unknowns.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_staticcondensation.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nu.vec.data = a.mat.Inverse(fes.FreeDofs(True)) * f.vec\n```\n\n----------------------------------------\n\nTITLE: Pickling GridFunctions with Shared Spaces - Python\nDESCRIPTION: This snippet shows how to pickle `GridFunction` objects that share the same finite element space. It creates two `GridFunction` objects on the same `H1` space and sets their values using `x` and `y` coordinates. Then, it pickles both grid functions into a file.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfes = H1(mesh, order=2)\ngfu1 = GridFunction(fes)\ngfu2 = GridFunction(fes)\ngfu1.Set(x)\ngfu2.Set(y)\n\noutfile = open(\"gridfunction.pkl\", \"wb\")\npickle.dump([gfu1,gfu2], outfile)\n```\n\n----------------------------------------\n\nTITLE: Adding Mesh Points in 1D\nDESCRIPTION: This snippet creates a loop to add MeshPoint objects to the mesh.  The `m.Add` function returns `PointId` objects, which are stored in an array `pnums` for later use in constructing segments. The example adds 11 points evenly spaced between 0 and 1.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nN = 10\npnums = []\nfor i in range(0, N+1):\n    pnums.append (m.Add (MeshPoint (Pnt(i/N, 0, 0))))\n\ntype(pnums[0])\n```\n\n----------------------------------------\n\nTITLE: Creating the mesh and level set function\nDESCRIPTION: This snippet creates a square mesh using SplineGeometry and defines a level set function representing a circle. It then interpolates the level set function onto a GridFunction for visualization and further processing.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsquare = SplineGeometry()\nsquare.AddRectangle([-1.5,-1.5],[1.5,1.5],bc=1)\nmesh = Mesh (square.GenerateMesh(maxh=0.4, quad_dominated=False))\n\nlevelset = (sqrt(x*x+y*y) - 1.0)\nDrawDC(levelset, -3.5, 2.5, mesh,\"levelset\")\n\nlsetp1 = GridFunction(H1(mesh,order=1))\nInterpolateToP1(levelset,lsetp1)\nDrawDC(lsetp1, -3.5, 2.5, mesh, \"lsetp1\")\n```\n\n----------------------------------------\n\nTITLE: Printing Operator Information\nDESCRIPTION: This snippet prints information about the linear operator op1. This is useful for debugging and performance analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint (op1.GetOperatorInfo())\n```\n\n----------------------------------------\n\nTITLE: Transform Shapes (Move and Rotate) - Python\nDESCRIPTION: This snippet demonstrates how to translate and rotate shapes using the `Move` and `Rotate` methods. The transformation preserves the original shape, returning a transformed copy. The translation `Move` takes a vector as argument, the rotation `Rotation` needs an axis given by a point and a direction, and an angle.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nsolid = Box((0,0,0), (5,3,1)) + Sphere((0,0,0), 0.3)\nsolid2 = solid.Move((5,0,2))\nsolid3 = solid.Move((0,0,4)).Rotate( Axis((0,0,4), X), 45)\nDrawGeo (solid + solid2 + solid3);\n```\n\n----------------------------------------\n\nTITLE: Checking for CUDA Device\nDESCRIPTION: This snippet attempts to import the NGSolve CUDA module and prints an error message if it fails. This allows to check if a CUDA-enabled GPU is available.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import ngsolve.ngscuda\nexcept:\n    print (\"Sorry, no cuda device\")\n```\n\n----------------------------------------\n\nTITLE: Generate and Print Mesh Type in Netgen\nDESCRIPTION: This snippet generates a Netgen mesh from the CSGeometry object and prints the type of the generated mesh.  It also calls Redraw() to visualize the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nngmesh = geo.GenerateMesh()\nprint(type(ngmesh))\nRedraw()\n```\n\n----------------------------------------\n\nTITLE: Assembling Linear Form for RHS (NGSolve)\nDESCRIPTION: This code snippet assembles the right-hand side (RHS) of the linear system. It defines a `LinearForm` on the space `VT` and adds a term involving `b`, `n`, `IfPos`, and `ubnd`, integrated over the skeleton boundary (`dskel_bound`). The assembled vector is then stored in `rhs.Assemble()`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nrhs = LinearForm(VT)                                              # part 3\nrhs += b*n * IfPos(b*n, 0, ubnd) * vT * dskel_bound # dskel_inflow\nrhs.Assemble()\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Space and Printing DOF Information in Python\nDESCRIPTION: This snippet defines a finite element space (H1) on the distributed mesh. It then prints the global number of degrees of freedom, the local number of degrees of freedom, and the sum of local degrees of freedom across all processes. This gives insights into the distribution of degrees of freedom in the parallel computation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.2-pardofs/pardofs.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n%%px\nfes = H1(mesh, order=1)\n# fes = L2(mesh, order=0)\nprint (\"global dofs =\", fes.ndofglobal, \", local dofs =\", fes.ndof, \\\n       \", sum of local dofs =\", comm.allreduce(fes.ndof))\n```\n\n----------------------------------------\n\nTITLE: Running Poisson Example with Netgen\nDESCRIPTION: This bash command demonstrates how to run the Poisson equation example using Netgen, which provides a graphical user interface. It assumes `poisson.py` file is in the current directory and that Netgen is properly installed and configured.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/whetting_the_appetite/poisson.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnetgen poisson.py\n```\n\n----------------------------------------\n\nTITLE: Building with Make - Bash\nDESCRIPTION: This snippet demonstrates how to build the Netgen/NGsolve project using Make. The `make` command is executed in the build directory. The `-jx` option can be added to use multiple threads for compilation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Visualize enrichment function\nDESCRIPTION: Creates a grid function on the enrichment space and sets it to a sine function of y.  This allows visualization of the enrichment function, demonstrating its localization to the interface edge.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngfext = GridFunction(fesext)\ngfext.Set(sin(10*y))\nDraw (gfext);\n```\n\n----------------------------------------\n\nTITLE: Defining the problem data (f, ud) as CoefficientFunctions\nDESCRIPTION: This snippet defines the data for the PDE problem, specifically the source term 'f' and the desired state 'ud', as CoefficientFunction objects. It also computes their gradients.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#given data of our problem (chosen such that \\Omega^* = [0,1]^2 is the optimal shape)\nf = CoefficientFunction(2*y*(1-y)+2*x*(1-x))\nud = x*(1-x)*y*(1-y)\n\ngrad_f = CoefficientFunction( (f.Diff(x), f.Diff(y) ) )\ngrad_ud = CoefficientFunction( (ud.Diff(x), ud.Diff(y) ) )\n```\n\n----------------------------------------\n\nTITLE: Solving Navier-Stokes with Reduced Viscosity\nDESCRIPTION: This code demonstrates solving the Navier-Stokes equations with a reduced viscosity value, increasing the Reynolds number and potentially leading to convergence issues. The solve is repeated with and without multidim output.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.3-nonlinear/nonlinear.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nnu.Set(0.01)\nSolveAndVisualize(multidim=False)\n```\n\nLANGUAGE: python\nCODE:\n```\nnu.Set(0.01)\nSolveAndVisualize()\n```\n\n----------------------------------------\n\nTITLE: Defining Bilinear Form for 3D Linear Elasticity - Python\nDESCRIPTION: This code defines the finite element space, bilinear form, and load for the 3D linear elasticity problem. Regularization is added to stabilize the solution. A surface force is also added to the 'force' boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfes = VectorH1(mesh, order=3, dirichlet=\"fix\")\nu = fes.TrialFunction()\ngfu = GridFunction(fes)\n\na = BilinearForm(fes)\na += Variation(InnerProduct(Sym(Grad(u)), Sym(Grad(u)))*dx)\na += Variation(1e-8*u*u*dx)   # regularization\na += Variation(-0.01*u[0]*ds(\"force\"))\n```\n\n----------------------------------------\n\nTITLE: Setting Maximum Mesh Size and Drawing (Python)\nDESCRIPTION: This snippet sets the maximum mesh size for a specific domain and then generates and draws the mesh using `Draw` from the `ngsolve.webgui` module. The `Mesh` object converts the netgen mesh to an ngsolve mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ngeo.SetDomainMaxH(2, 0.02)\nngmesh = geo.GenerateMesh(maxh=0.1)\nDraw (Mesh(ngmesh))\n```\n\n----------------------------------------\n\nTITLE: Generate geometry for shape optimization - Python\nDESCRIPTION: This snippet generates the initial geometry for the shape optimization problem using NGSolve and Netgen. It creates a circular geometry and sets up the mesh for finite element analysis.  It utilizes `SplineGeometry` to define the geometry and `Mesh` to create the finite element mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Generate the geometry\nfrom ngsolve import *\n\n# load Netgen/NGSolve and start the gui\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import SplineGeometry\n\ngeo = SplineGeometry()\ngeo.AddCircle((0,0), r = 2.5)\n\nngmesh = geo.GenerateMesh(maxh = 0.08)\nmesh = Mesh(ngmesh)\nmesh.Curve(2)\n```\n\n----------------------------------------\n\nTITLE: Print Linear System Matrix in Python\nDESCRIPTION: Prints the linear system matrix\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nprint(a.mat)\n```\n\n----------------------------------------\n\nTITLE: Importing Netgen Modules in Python\nDESCRIPTION: This code snippet imports the necessary modules from the Netgen library for creating and manipulating meshes. It includes modules for geometry, meshing elements (0D, 1D, and 2D), mesh points, face descriptors, and CSG points.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.geom2d import unit_square, MakeCircle, SplineGeometry\nfrom netgen.meshing import Element0D, Element1D, Element2D, MeshPoint, FaceDescriptor, Mesh\nfrom netgen.csg import Pnt\n```\n\n----------------------------------------\n\nTITLE: Communication Python -> Javascript - Python\nDESCRIPTION: This example demonstrates communication from Python to Javascript using `scene.widget.send` and `scene.widget.model.on('msg:custom', callback)`. It changes the colormap max setting from Python in a loop by sending custom messages to the Javascript side.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\njs_code = \"\"\"  \nscene.widget.model.on('msg:custom', (message)=> {\n    console.log(\"received message\", message)\n    scene.gui.settings.Colormap.max = message.colormap_max\n    scene.animate()\n})\n\"\"\"\ns = Draw(x, m, \"x\", js_code=js_code);\n\nimport time\nfor i in range(10):\n    time.sleep(1)\n    s.widget.send({\"colormap_max\": .9-.1*i})\n```\n\n----------------------------------------\n\nTITLE: Generating nvcc and nvlink Scripts - CMake\nDESCRIPTION: This snippet generates shell scripts `ngs_nvcc` and `ngs_nvlink` using the `file(GENERATE)` command. These scripts wrap the CUDA compiler (nvcc) and the C++ compiler. The `ngs_nvcc` script compiles CUDA code, while `ngs_nvlink` links CUDA code. The scripts include the NVCC path, flags, defines, and include paths. They are generated conditionally based on the compile language.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_11\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/ngs_nvcc\n              CONTENT \"${ngs_nvcc_header}\\n$NVCC ${ngscxx_define_flags} -arch=native ${nvcc_flags} ${ngscxx_includes} $*\\n\"\n              CONDITION $<$<COMPILE_LANGUAGE:CXX>>\n              )\nfile(GENERATE OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/ngs_nvlink CONTENT \"${ngs_nvcc_header}\\n$NGSCXX ${ngsld_flags} $*\\n\")\n```\n\n----------------------------------------\n\nTITLE: Configuring MUMPS Integration\nDESCRIPTION: Configures the integration with MUMPS. If `USE_MUMPS` is enabled, it enables Fortran language, finds the MUMPS and MPI packages, adds the `USE_MUMPS` compile definition, and includes the MUMPS include directories and link directories.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_37\n\nLANGUAGE: cmake\nCODE:\n```\nif (USE_MUMPS)\n    enable_language(Fortran)\n    find_package(MUMPS REQUIRED)\n    find_package(MPI REQUIRED)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS USE_MUMPS)\n    include_directories(${MUMPS_INCLUDE_DIR})\n    link_directories(${MUMPS_DIR}/lib)\nendif (USE_MUMPS)\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve-PETSc Interface\nDESCRIPTION: This snippet imports the necessary modules for interfacing NGSolve with PETSc. It imports `ngsolve.ngs2petsc` for data transfer and `petsc4py.PETSc` for PETSc functionalities. This allows for the creation and manipulation of PETSc matrices and vectors within NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n%%px\nimport ngsolve.ngs2petsc as n2p\nimport petsc4py.PETSc as psc\n```\n\n----------------------------------------\n\nTITLE: Demonstrate DOF Numbering in NGSolve\nDESCRIPTION: This snippet demonstrates the effect of `all_dofs_together` flag on DOF numbering.  The first DOFs are the lowest order DOFs if `all_dofs_together` is False.  Sparsity patterns are shown for FESpaces with order 0, order 1, and order 1 with the `all_dofs_together` flag set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nplt.rcParams['figure.figsize'] = (15, 15)\nfig = plt.figure()\nax = [fig.add_subplot(131), fig.add_subplot(132), fig.add_subplot(133)]\n\nfor i, (order, all_dofs_together, label) in enumerate([(0,False, \"non-zeros (p=0)\"),\n                                                    (1,False,\"non-zeros (p=1, low order + high order)\"),\n                                                    (1,True,\"non-zeros (p=1, all_dofs_together)\")]):\n    a = BilinearForm(L2(mesh,order=order,dgjumps=True,all_dofs_together=all_dofs_together))\n    a.Assemble()\n    ax[i].spy(sp.csr_matrix(a.mat.CSR()),markersize=3,precision=-1)\n    ax[i].set_xlabel(label)\n```\n\n----------------------------------------\n\nTITLE: Applying LevelSetMeshAdaptation and drawing - Python\nDESCRIPTION: This snippet applies a mesh deformation technique using LevelSetMeshAdaptation. It calculates the deformation based on the level set function and visualizes the deformation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(square.GenerateMesh(maxh=0.4, quad_dominated=False))\nlsetmeshadap = LevelSetMeshAdaptation(mesh, order=2, threshold=1000, discontinuous_qn=True)\ndeformation = lsetmeshadap.CalcDeformation(levelset)\nDraw(deformation,mesh,\"deformation\")\n```\n\n----------------------------------------\n\nTITLE: Setting Initial Conditions\nDESCRIPTION: This snippet sets the initial conditions for the pressure and velocity fields. The pressure field is initialized with a Gaussian function, and the velocity field is set to zero. The pressure field is then visualized using the `Draw` function.  'x' and 'y' are assumed to be spatial coordinate variables in NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.2-wavedg/wavedg.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ngfu.components[0].Set (exp(-50*(x**2+y**2))-exp(-100*(x**2+y**2)))\ngfu.components[1].vec[:] = 0\nDraw(gfu.components[0], mesh, \"p\", min=-0.02, max=0.08, autoscale=False, order=3)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This code snippet imports necessary modules from the netgen.occ library. Specifically, it imports all elements from netgen.occ and the Draw function from netgen.webgui, which is used for visualizing the geometry.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/workplane.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.occ import *\nfrom netgen.webgui import Draw as DrawGeo\n```\n\n----------------------------------------\n\nTITLE: Install Python MPI Examples - CMake\nDESCRIPTION: This CMake command installs several Python scripts related to MPI examples (mpi_poisson.py, mpi_cmagnet.py, mpi_navierstokes.py, mpi_timeDG.py). It specifies the destination directory as `${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/demos/mpi` and assigns the component `ngsolve_devel`. The `FILES` argument lists the files to install and the `DESTINATION` argument specifies the installation directory. The `COMPONENT` argument is used for packaging.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/py_tutorials/mpi/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(FILES\n        mpi_poisson.py mpi_cmagnet.py mpi_navierstokes.py\n        mpi_timeDG.py ../__init__.py\n        DESTINATION ${NGSOLVE_INSTALL_DIR_PYTHON}/ngsolve/demos/mpi\n        COMPONENT ngsolve_devel\n       )\n```\n\n----------------------------------------\n\nTITLE: Appending Results and Post Processing - Python\nDESCRIPTION: This function calculates and prints the error of the integration, appends it to a list of errors, and calculates the experimental order of convergence (EOC) based on successive error values after mesh refinement.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nerrors = []\n\ndef AppendResultAndPostProcess(integral):\n    error = abs(integral - pi)\n    print(\"Result of the integration: \", integral)\n    print(\"Error of the integration: \", error)\n\n    errors.append(error)\n    eoc = [log(errors[i+1]/errors[i])/log(0.5) for i in range(len(errors)-1)]\n\n    print(\"Collected errors:\", errors)\n    print(\"experimental order of convergence (L2):\", eoc)    \n\nAppendResultAndPostProcess(integral)\n```\n\n----------------------------------------\n\nTITLE: Configure Sphinx Documentation Build\nDESCRIPTION: Configures the Sphinx documentation build process. It sets up directories for binary builds, Sphinx cache, and HTML output. It configures the `conf.py` file and creates a custom target `docs` to build HTML documentation using Sphinx. The documentation is built only if `NETGEN_USE_PYTHON` and `SPHINX_FOUND` are true. Includes setting environment variables for netgen documentation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nset(BINARY_BUILD_DIR \"${CMAKE_CURRENT_BINARY_DIR}/_build\")\n\n    # Sphinx cache with pickled ReST documents\n    set(SPHINX_CACHE_DIR \"${CMAKE_CURRENT_BINARY_DIR}/_doctrees\")\n\n    # HTML output directory\n    set(SPHINX_OUTPUT_DIR \"${CMAKE_CURRENT_BINARY_DIR}\")\n\n    configure_file(\n      \"${CMAKE_CURRENT_SOURCE_DIR}/conf.py\"\n      \"${BINARY_BUILD_DIR}/conf.py\"\n      @ONLY)\n\n    add_custom_target(docs\n      COMMAND\n      ${CMAKE_COMMAND} -E env NETGEN_DOCUMENTATION_RST_FORMAT=1\n      ${CMAKE_COMMAND} -E env NETGEN_DOCUMENTATION_OUT_DIR=\"${SPHINX_OUTPUT_DIR}/html\"\n      ${CMAKE_COMMAND} -E env NETGEN_DOCUMENTATION_SRC_DIR=\"${CMAKE_CURRENT_SOURCE_DIR}\"\n      ${SPHINX_EXECUTABLE}\n      -a -q -b html\n      -c \"${BINARY_BUILD_DIR}\"\n      -d \"${SPHINX_CACHE_DIR}\"\n      \"${CMAKE_CURRENT_SOURCE_DIR}\"\n      \"${SPHINX_OUTPUT_DIR}/html\"\n      COMMAND\n      # copy webgui.js to html/_static/\n      ${NETGEN_PYTHON_EXECUTABLE} -m webgui_jupyter_widgets.js \"${CMAKE_CURRENT_BINARY_DIR}/html/_static\"\n      COMMENT \"Building HTML documentation with Sphinx\"\n      )\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh Object in Python\nDESCRIPTION: This code snippet creates an empty mesh object and sets its geometry and dimension. The `Mesh` object is initialized, the geometry is set to `unit_square` (presumably a predefined geometry), and the dimension of the mesh is set to 2.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh()\nmesh.SetGeometry(unit_square)\nmesh.dim = 2\n```\n\n----------------------------------------\n\nTITLE: Printing Operator Information for PML\nDESCRIPTION: This snippet prints information about the `fullB` and `dampingp` operators, which are used in the PML implementation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint (fullB.GetOperatorInfo())\nprint (dampingp.GetOperatorInfo())\n```\n\n----------------------------------------\n\nTITLE: Visualizing DomainTypeArray Indicator (Python)\nDESCRIPTION: This snippet visualizes the DomainTypeArray representing the Zalesak disk by plotting its indicator function. The indicator function is constructed based on the level sets and then drawn using DrawDC on the provided mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nDrawDC(z_disc.Indicator(level_sets_p1), -3.5, 2.5, mesh, \"zdisc\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Inspecting Trace Operator - Python\nDESCRIPTION: This code creates a `TraceOperator` mapping from the `FESpace` `VT` to the `FacetFESpace` `VF`. It then prints information about the dimensions of the spaces and the operator itself.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ntrace = VT.TraceOperator(VF, False)\n#info output about the trace operator\nprint(\"The space VT has {} dofs.\".format(VT.ndof))\nprint(\"The trace space VF has {} dofs.\".format(VF.ndof))\nprint(\"trace represents an {} x {} operator\".format(trace.height, trace.width))\n```\n\n----------------------------------------\n\nTITLE: Configure LaTeX Documentation Build\nDESCRIPTION: Configures the LaTeX documentation build using Sphinx. It creates a custom target `docs_latex` that executes Sphinx to generate LaTeX output. This target depends on the presence of Sphinx and is executed conditionally based on `NETGEN_USE_PYTHON` and `SPHINX_FOUND`. Includes setting environment variables for netgen documentation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(docs_latex\n      ${CMAKE_COMMAND} -E env NETGEN_DOCUMENTATION_RST_FORMAT=1\n    \t${SPHINX_EXECUTABLE}\n    \t-q -b latex\n    \t-c \"${BINARY_BUILD_DIR}\"\n    \t-d \"${SPHINX_CACHE_DIR}\"\n    \t\"${CMAKE_CURRENT_SOURCE_DIR}\"\n    \t\"${SPHINX_OUTPUT_DIR}/latex\"\n    \tCOMMENT \"Building Latex documentation with Sphinx\")\n```\n\n----------------------------------------\n\nTITLE: Postprocessing Data Structures in ngsolve (Python)\nDESCRIPTION: This snippet defines data structures for postprocessing results in ngsolve using `MatrixValued` finite element spaces. It creates grid functions and bilinear forms required for drawing and analyzing stress fields, including their inverses.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# for postprocessing\ndrawfes = MatrixValued(L2(mesh, order=order-1), dim=3, symmetric=True, deviatoric=False)\npd, qd = drawfes.TnT()\npdraw = GridFunction(drawfes)\nad = BilinearForm(InnerProduct(pd, qd)*irs_dx, symmetric=True).Assemble()\ninvad = ad.mat.Inverse()\n\ndrawafes = L2(mesh, order=order-1)\npda, qda = drawafes.TnT()\nadraw = GridFunction(drawafes)\nada = BilinearForm(InnerProduct(pda, qda)*irs_dx, symmetric=True).Assemble()\ninvada = ada.mat.Inverse()\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This code imports the necessary modules from the NGSolve library, the NGSolve web GUI, and the Netgen geometry module. These modules provide the functionality for finite element analysis, visualization, and geometry creation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03_Shape_Derivative_Laplace_SemiAuto.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom netgen.geom2d import SplineGeometry\n```\n\n----------------------------------------\n\nTITLE: Create Compound of Shapes - Python\nDESCRIPTION: This snippet creates a compound of the box and cylinder geometries using `Compound`. Component shapes are meshed independently. The resulting geometry is then meshed and visualized.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ngeo = Compound( [box, cyl])\nDrawGeo (geo)\n\nmesh = Mesh(OCCGeometry(geo).GenerateMesh(maxh=0.2)).Curve(3)\nDraw (mesh, clipping=True);\n```\n\n----------------------------------------\n\nTITLE: Starting the cluster in Python\nDESCRIPTION: Starts a new parallel cluster with a specified number of processes and connects to it. The `num_procs` variable determines the number of processes to start.  It relies on the utilities in the 'usrmeeting_jupyterstuff' module.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstart_cluster(num_procs)\nconnect_cluster()\n```\n\n----------------------------------------\n\nTITLE: Linking CUDA Libraries and NGSolve - CMake\nDESCRIPTION: This snippet links the `${lib_name}` library with required CUDA libraries (cusparse, cublas, cudart) and the ngsolve library. It also links with netgen_python. It configures the library to depend on these CUDA and NGSolve components.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_link_libraries(${lib_name} PUBLIC CUDA::cusparse CUDA::cublas CUDA::cudart ngsolve netgen_python)\n```\n\n----------------------------------------\n\nTITLE: Adding point names to structured surface meshes\nDESCRIPTION: This snippet adds point names (BBBoundaries) to a structured surface mesh. The `bbbpts` argument specifies the coordinates of the points, and the `bbbnames` argument provides the corresponding names. The points must be Gridpoints in the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nmesh = MakeStructuredSurfaceMesh(nx=12, ny=2, mapping=mapping, bbbpts=[[L,0,0]], bbbnames=[\"force\"])\nprint(mesh.GetBBBoundaries())\n```\n\n----------------------------------------\n\nTITLE: Finding Subdomain Vertices\nDESCRIPTION: This snippet determines the subdomain vertices by identifying the intersection of faces. It calculates the set of dofs that are free and belong to each processor's subdomain. It involves an if-else block to determine the vertex based on `pythonic` variable, which controls between readability and performance. `DISTRIBUTED` and `Cumulate` are used to collect the vertices on all processors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npythonic = True\nif pythonic:\n    faces = [set(d for d in pardofs.Proc2Dof(p) if d<mesh.nv and fes.FreeDofs()[d] ) for p in pardofs.ExchangeProcs()]\n    edges = sorted([tuple(sorted(e)) for e in set(tuple(f1.intersection(f2)) for f1 in faces for f2 in faces if f1 is not f2) if len(e)>1])\n    vertices = sorted(set([ v for e1 in edges for e2 in edges if e1 is not e2 for v in set(e1).intersection(set(e2)) ]))\nelse:\n    faces = []\n    for p in pardofs.ExchangeProcs():\n        faces.append(set(d for d in pardofs.Proc2Dof(p) if d<mesh.nv and fes.FreeDofs()[d]))\n    edges = []\n    for f1 in faces:\n        for f2 in faces:\n            if f1 is not f2:\n                edge = sorted(tuple(f1.intersection(f2)))\n                if len(edge) > 1:\n                    if not edge in edges:\n                        edges.append(sorted(tuple(edge)))\n    vertices = set()\n    for e1 in edges:\n        for e2 in edges:\n            if e1 is not e2:\n                vs = set(e1).intersection(set(e2))\n                vertices = vertices.union(vs)\n    vertices = sorted(vertices)\n\nvec = f.vec.CreateVector()\nvec.local_vec[:] = 0.0\nfor v in vertices:\n    vec.local_vec[v] = 1\nvec.SetParallelStatus(DISTRIBUTED)\nvec.Cumulate()\nvertices = [ v for v in range(mesh.nv) if vec.local_vec[v]!=0 ]\n\nprimal_dofs = BitArray([v in vertices for v in range(fes.ndof)]) & fes.FreeDofs()\n```\n\n----------------------------------------\n\nTITLE: Printing Bilinear Form Term in NGSolve (Python)\nDESCRIPTION: This snippet demonstrates how to print a bilinear form term within the NGSolve environment using Python. This allows for inspection and debugging of the symbolic representation of the form before code generation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint (term2)\n```\n\n----------------------------------------\n\nTITLE: Defining Finite Element Spaces for Naghdi Shell Model (Python)\nDESCRIPTION: This snippet defines finite element spaces for the displacement `u` and rotation `beta` in the Naghdi shell model. It utilizes `VectorH1` elements for both, specifying the order and Dirichlet boundary conditions on the 'left' boundary.  A special coefficient function `nsurf` is defined representing the normal vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.4-shells/shell.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfes1 = VectorH1(mesh, order=order, dirichlet_bbnd=\"left\")\nfes = fes1*fes1\nu,beta = fes.TrialFunction()\n\nnsurf = specialcf.normal(3)\n\nthickness = 0.1\n```\n\n----------------------------------------\n\nTITLE: Non-Zero Entries Comparison - Python\nDESCRIPTION: This snippet compares the number of non-zero entries in the matrices generated by the RestrictedBilinearForm and the full BilinearForm, showing that the restriction reduces the number of non-zero entries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nprint(len(a_full.mat.AsVector()))\nprint(len(a.mat.AsVector()))\n```\n\n----------------------------------------\n\nTITLE: Check Object Type - Python\nDESCRIPTION: This snippet checks the type of the created object, which is a Py-wrapped OCCT object derived from `TopoDS_Shape`. It prints both the Python type and the type query.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.4-occ/occ.ipynb#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nprint (\"object type is:\", type(box))\nprint (\"type query tells:\", box.type)\n```\n\n----------------------------------------\n\nTITLE: Installing webgui_jupyter_widgets - Bash\nDESCRIPTION: This code snippet installs the `webgui_jupyter_widgets` package using pip and configures the Jupyter notebook extensions to enable the webgui visualization within Jupyter. It uses pip3 to install the package and then uses jupyter nbextension commands to install and enable the necessary extensions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/index.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip3 install webgui_jupyter_widgets\njupyter nbextension install --user --py widgetsnbextension\njupyter nbextension enable --user --py widgetsnbextension\njupyter nbextension install --user --py webgui_jupyter_widgets\njupyter nbextension enable --user --py webgui_jupyter_widgets\n```\n\n----------------------------------------\n\nTITLE: Drawing Geometry - Python\nDESCRIPTION: This snippet uses Netgen's webgui to visualize the created geometry, allowing for inspection of the unit cell's shape.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nDrawGeo(shape);\n```\n\n----------------------------------------\n\nTITLE: Configuring LAPACK Integration\nDESCRIPTION: Configures the integration with LAPACK. It defines an interface library `ngs_lapack`, finds the LAPACK package if `USE_LAPACK` is enabled, links the library, and adds the `LAPACK` compile definition.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_32\n\nLANGUAGE: cmake\nCODE:\n```\nadd_library(ngs_lapack INTERFACE )\ninstall( TARGETS ngs_lapack ${ngs_install_dir} )\nif (USE_LAPACK)\n    if(NOT LAPACK_LIBRARIES)\n      find_package(LAPACK REQUIRED)\n    endif()\n    target_link_libraries(ngs_lapack INTERFACE \"${LAPACK_LIBRARIES}\")\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS LAPACK)\nendif (USE_LAPACK)\n```\n\n----------------------------------------\n\nTITLE: Creating Build Directory - Bash\nDESCRIPTION: This snippet shows how to create a dedicated build directory for Netgen/NGsolve. This helps to keep the source directory clean and organized. The build directory is created under the directory specified by the NGROOT variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installmacnative.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmkdir $NGROOT/ngsolve-build\n```\n\n----------------------------------------\n\nTITLE: Drawing with Objects - Python\nDESCRIPTION: This code shows how to pass additional visualization data as objects (lines, points, and text) to the `Draw` function. It defines dictionaries specifying the type, position, color, size, and name for each object. The `settings` parameter is used to turn off default edges and surface.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nlines = { \"type\": \"lines\", \"position\": [0,0,0, 1,1,1, 1,0,0, 0,0,1], \"name\": \"my lines\", \"color\": \"red\"}\npoints = { \"type\": \"points\", \"position\": [0.5, 0.5, 0.5, 1.1,1,1], \"size\":20, \"color\": \"blue\", \"name\": \"my points\"}\ntext = { \"type\": \"text\", \"name\": \"my text\", \"text\": \"hello!\", \"position\": [1.3,0,0]}\nDraw(m, objects=[lines,points, text], settings={\"Objects\": {\"Edges\": False, \"Surface\": False}})\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules for NGSolve and Netgen\nDESCRIPTION: This snippet imports the required modules from the ngsolve and netgen libraries, including classes for creating geometric objects, meshes, and visualization. It also imports MeshingStep for controlling the meshing process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.csg import *\nfrom netgen.meshing import MeshingStep\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Running the Time Loop - Python\nDESCRIPTION: This code executes the `SolveAndVisualize` function with the convection operator `c.mat` and measures the execution time using the `%%time` magic command.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n%%time \ngfu_t = SolveAndVisualize(c.mat)\n```\n\n----------------------------------------\n\nTITLE: Setting up FETI-DP Solver in NGSolve Python\nDESCRIPTION: Sets up and solves a FETI-DP problem using NGSolve. It includes defining the problem, setting up finite element spaces, defining bilinear and linear forms, assembling matrices, and implementing the FETI-DP preconditioner.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.5-fetidp_inexact/feti-dp-iv.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%px\nfrom ngsolve import *\nimport netgen.meshing as ngmeshing\nfrom ngsolve.la import ParallelMatrix, FETI_Jump, SparseMatrixd, ParallelDofs, BlockMatrix\nfrom dd_toolbox import FindFEV, DPSpace_Inverse, ScaledMat, LinMat\n\ndef load_mesh(nref=0):\n    ngmesh = ngmeshing.Mesh(dim=3)\n    ngmesh.Load('cube.vol')\n    for l in range(nref):\n        ngmesh.Refine()\n    return Mesh(ngmesh)\n\ndef setup_space(mesh, order=1):\n    comm = MPI_Init()\n    fes = H1(mesh, order=order, dirichlet='right|top')\n    a = BilinearForm(fes)\n    u,v = fes.TnT()\n    a += SymbolicBFI(grad(u)*grad(v))\n    a.Assemble()\n    f = LinearForm(fes)\n    f += SymbolicLFI(x*y*v)\n    f.Assemble()\n    avg_dof = comm.Sum(fes.ndof) / comm.size\n    if comm.rank==0:\n        print('global,  ndof =', fes.ndofglobal, ', lodofs =', fes.lospace.ndofglobal)\n        print('avg DOFs per core: ', avg_dof)\n    return [fes, a, f]\n\ndef setup_FETIDP(fes, a):\n    faces, edges, vertices = FindFEV(mesh.dim, mesh.nv, \\\n                                     fes.ParallelDofs(), fes.FreeDofs())\n    primal_dofs = BitArray([ v in set(vertices) for v in range(fes.ndof) ]) & fes.FreeDofs() \n    dp_pardofs = fes.ParallelDofs().SubSet(primal_dofs)\n    ar = [(num_e[0],d,1.0) for num_e in enumerate(edges) for d in num_e[1] ]\n    rows, cols, vals = [list(x) for x in zip(*ar)] if len(ar) else [[],[],[]]\n    B_p = SparseMatrixd.CreateFromCOO(rows, cols, vals, len(edges), fes.ndof)\n    edist_procs = [sorted(set.intersection(*[set(fes.ParallelDofs().Dof2Proc(v)) for v in edge])) for edge in edges]\n    eavg_pardofs = ParallelDofs(edist_procs, comm)\n    nprim = comm.Sum(sum([1 for k in range(fes.ndof) if primal_dofs[k] and comm.rank<fes.ParallelDofs().Dof2Proc(k)[0] ]))\n    if comm.rank==0:\n        print('# of global primal dofs: ', nprim)  \n    A_dp = ParallelMatrix(a.mat.local_mat, dp_pardofs)\n    dual_pardofs = fes.ParallelDofs().SubSet(BitArray(~primal_dofs & fes.FreeDofs()))\n    B = FETI_Jump(dual_pardofs, u_pardofs=dp_pardofs)\n    if comm.rank==0:\n        print('# of global multipliers = :', B.col_pardofs.ndofglobal)\n    A_dp_inv = DPSpace_Inverse(mat=a.mat, freedofs=fes.FreeDofs(), \\\n                               c_points=primal_dofs, \\\n                               c_mat=B_p, c_pardofs=eavg_pardofs, \\\n                               invtype_loc='sparsecholesky', \\\n                               invtype_glob='masterinverse')\n    F = B @ A_dp_inv @ B.T\n    innerdofs = BitArray([len(fes.ParallelDofs().Dof2Proc(k))==0 for k in range(fes.ndof)]) & fes.FreeDofs()\n    A = a.mat.local_mat\n    Aiinv = A.Inverse(innerdofs, inverse='sparsecholesky')\n    scaledA = ScaledMat(A, [0 if primal_dofs[k] else 1.0/(1+len(fes.ParallelDofs().Dof2Proc(k))) for k in range(fes.ndof)])\n    scaledBT = ScaledMat(B.T, [0 if primal_dofs[k] else 1.0/(1+len(fes.ParallelDofs().Dof2Proc(k))) for k in range(fes.ndof)])\n    Fhat = B @ scaledA @ (IdentityMatrix() - Aiinv @ A) @ scaledBT\n    nFhat = B @ scaledA @ (Aiinv @ A - IdentityMatrix()) @ scaledBT\n    return [A_dp, A_dp_inv, F, Fhat, nFhat, B, scaledA, scaledBT]  \n```\n\n----------------------------------------\n\nTITLE: Introducing Parameters in CoefficientFunctions\nDESCRIPTION: This snippet introduces the concept of `Parameter`s in CoefficientFunctions.  It defines a parameter `k` with an initial value of 1.0 and then creates a CoefficientFunction `f` that depends on `k` and `y`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nk = Parameter(1.0)\nf = sin(k*y)\nDraw(f, mesh);\n```\n\n----------------------------------------\n\nTITLE: Defining a CoefficientFunction on boundary regions\nDESCRIPTION: This snippet creates a `CoefficientFunction` defined on the boundary regions. The dictionary `bdry_values` assigns the value x to the 'b' boundary and (2-y) to the 'r' boundary. The default value is set to 0. Note: Drawing the raw `BoundaryCF` is not useful.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# Make a linear function equaling 2 at the bottom right vertex\n# of (0,2) x (0,2) and equals zero at the remaining vertices:\nbdry_values = {'b': x, 'r': 2-y}\ncf = mesh.BoundaryCF(bdry_values, default=0)\n```\n\n----------------------------------------\n\nTITLE: Add Test to Ensure Unit Tests are Built (CMake)\nDESCRIPTION: This snippet adds a test named `unit_tests_built` that executes a CMake command to build the `unit_tests` target. It ensures that all unit test executables are built before any individual test is run. The working directory is set to allow correct execution of the build command. It depends on the `CMAKE_BUILD_TYPE` variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/catch/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nadd_test(NAME unit_tests_built COMMAND ${CMAKE_COMMAND} --build . --target unit_tests --config ${CMAKE_BUILD_TYPE} WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/../.. )\n```\n\n----------------------------------------\n\nTITLE: 3D Plot - Python\nDESCRIPTION: This snippet creates a 3D plot showing the relationship between ksi, k and frequency.  Requires the Axes3D import from `mpl_toolkits.mplot3d`. Z axis limits are explicitly set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure(figsize=(10,10))\nax = fig.add_subplot(111, projection='3d')\nax.set_zlim(0,0.7)\nplt.plot(ks, ksi, fs, \"*\", ms=1)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: DomainTypeArray Intersection Example 2\nDESCRIPTION: This snippet demonstrates another example of `DomainTypeArray` intersection.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndta3 = DomainTypeArray((NEG, IF, POS)) & DomainTypeArray((NEG, POS, IF))\ndta3.as_list\n```\n\n----------------------------------------\n\nTITLE: Conditional UMFPACK Test Addition (CMake)\nDESCRIPTION: This snippet conditionally adds a Python test 'umfpack.py' if `NETGEN_USE_PYTHON` is true or the system is not Windows, and if `USE_UMFPACK` is enabled. It specifies the Python executable, working directory, and timeout properties for the test.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NETGEN_USE_PYTHON OR NOT WIN32)\n\ninclude(CTest)\n\nif(USE_UMFPACK)\n  add_test(NAME umfpack.py COMMAND ${NETGEN_PYTHON_EXECUTABLE} umfpack.py WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n  set_tests_properties ( ${py_test} PROPERTIES TIMEOUT ${NGS_TEST_TIMEOUT} )\nendif(USE_UMFPACK)\n\nendif(NETGEN_USE_PYTHON OR NOT WIN32)\n```\n\n----------------------------------------\n\nTITLE: Define Upwind Flux for Convection Term in NGSolve\nDESCRIPTION: This snippet defines the upwind flux for the convection term in the DG formulation. It uses the `IfPos` function to determine the upwind value based on the sign of the dot product between the convection velocity `b` and the normal vector `n`. The `uup` variable represents the upwind value of the solution.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.8-DG/DG.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nb = CF( (20,5) )\nuup = IfPos(b*n, u, u.Other())\n\nconvection = -b * u * grad(v)*dx + b*n*uup*jump_v * dx(skeleton=True)\n\nacd = BilinearForm(diffusion + convection).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Add Sphere to CSGeometry and Draw in Netgen\nDESCRIPTION: This snippet adds the sphere, with defined properties like color and boundary conditions, to the CSGeometry object and then draws the geometry for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngeo = CSGeometry()\ngeo.Add(sphere)\ngeo.Draw()\n```\n\n----------------------------------------\n\nTITLE: Plotting Convergence History\nDESCRIPTION: This snippet plots the history of the adaptive convergence, showing the relationship between the number of degrees of freedom and the H1 error estimate. It uses Matplotlib to generate a log-log plot and displays it interactively.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.6-adaptivity/adaptivity.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nplt.yscale('log')\nplt.xscale('log')\nplt.xlabel(\"ndof\")\nplt.ylabel(\"H1 error-estimate\")\nndof,err = zip(*l)\nplt.plot(ndof,err, \"-*\")\n\nplt.ion()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Generating a mesh from the OCC geometry\nDESCRIPTION: This snippet generates a mesh from the OpenCascade geometry defined in the previous step.  The `maxh` parameter controls the maximum mesh size. The mesh is then drawn using the `Draw` function for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(OCCGeometry(geo, dim=2).GenerateMesh(maxh=0.2))\nDraw(mesh);\n```\n\n----------------------------------------\n\nTITLE: Set Boundary Condition on Solid Surface in Netgen\nDESCRIPTION: This snippet shows how to set a boundary condition for the entire surface of a solid.  The .bc() method is chained after creating the solid, assigning a name to the boundary.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nbrick = OrthoBrick(Pnt(-2,-2,-2),Pnt(2,2,2)).bc('outer')\nsphere = Sphere(Pnt(0,0,0),1).bc('sphere')\n```\n\n----------------------------------------\n\nTITLE: Setting Target Properties - CMake\nDESCRIPTION: This snippet sets properties for the target `${lib_name}`. `POSITION_INDEPENDENT_CODE` is set to ON, enabling the creation of a position-independent library. `CUDA_SEPARABLE_COMPILATION` is also enabled, which allows for separable compilation of CUDA code, potentially improving compilation times.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nset_target_properties(${lib_name} PROPERTIES POSITION_INDEPENDENT_CODE ON CUDA_SEPARABLE_COMPILATION ON)\n```\n\n----------------------------------------\n\nTITLE: Setting up ParallelDofs for Dual-Primal Space\nDESCRIPTION: This snippet configures the parallel degrees of freedom (ParallelDofs) for the dual-primal space, which is essential for the FETI-DP method.  It computes and prints the number of primal dofs on different MPI ranks.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprimal_dofs = BitArray([ v in set(vertices) for v in range(fes.ndof) ]) & fes.FreeDofs()\ndp_pardofs = pardofs.SubSet(primal_dofs)\n\nnprim = comm.Sum(sum([1 for k in range(fes.ndof) if primal_dofs[k] and comm.rank<pardofs.Dof2Proc(k)[0] ]))\nnpmin = comm.Min(primal_dofs.NumSet() if comm.rank else nprim)\nnpavg = comm.Sum(primal_dofs.NumSet())/comm.size\nnpmax = comm.Max(primal_dofs.NumSet())\nif comm.rank==0:\n    print('# primal dofs global: ', nprim)\n    print('min, avg, max per rank: ', npmin, ' ', npavg, ' ', npmax)\n```\n\n----------------------------------------\n\nTITLE: Print Linear System Vector in Python\nDESCRIPTION: Prints the linear system vector.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(f.vec)\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories (CMake)\nDESCRIPTION: This snippet defines include directories for the project, including paths for Netgen, MKL, MUMPS, Python, UMFPACK, and VTune. It then constructs the include flags for different operating systems (Windows vs. others). It also handles relative paths between Netgen binary and include directories.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_45\n\nLANGUAGE: CMake\nCODE:\n```\n# include directories\nset(ngscxx_include_dirs ${NETGEN_MPI_CXX_INCLUDE_PATH} ${MKL_INCLUDE_DIRS} ${MUMPS_INCLUDE_DIR} ${NETGEN_PYTHON_INCLUDE_DIRS} ${UMFPACK_INCLUDE_DIR} ${VTUNE_INCLUDE_DIR})\n\n\nforeach( d ${ngscxx_include_dirs} )\n  if(WIN32)\n    set( ngscxx_includes \"${ngscxx_includes} /I\\\"${d}\\\"\" )\n  else()\n    set( ngscxx_includes \"${ngscxx_includes} -I${d}\" )\n  endif()\nendforeach()\n\nfile(RELATIVE_PATH BIN_TO_INC_RELPATH ${NETGEN_BINARY_DIR} ${NETGEN_INCLUDE_DIR})\nif(WIN32)\n  get_filename_component(VC_BIN_DIR ${CMAKE_CXX_COMPILER} PATH)\n  find_file(VCVARSALL vcvarsall.bat PATHS ${VC_BIN_DIR}/../../ ${VC_BIN_DIR}/../../../../../../Auxiliary/Build/)\n  set( ngscxx_set_script_dir \"\\\nset NGSCXX_DIR=%~dp0\ncall \\\"${VCVARSALL}\\\" amd64\n\" )\n  set( ngscxx_includes \"${ngscxx_includes} /I\\\"%NGSCXX_DIR%/${BIN_TO_INC_RELPATH}\\\"\" )\n  set( ngscxx_includes \"${ngscxx_includes} /I\\\"%NGSCXX_DIR%/${BIN_TO_INC_RELPATH}/include\\\"\" )\nelse()\n  set( ngscxx_set_script_dir \"\\\nNGSCXX_DIR=$( cd $(dirname $0); pwd )\nPY_INCLUDE_FLAGS=-I$(python3 -c\\\"import sysconfig;print(sysconfig.get_path('include'))\\\")\nif [ -f ${CMAKE_CXX_COMPILER} ]\n  then NGSCXX=${CMAKE_CXX_COMPILER}\n  else NGSCXX=c++\nfi\nexport CCACHE_NOHASHDIR=1\n\")\n  set( ngscxx_includes \"${ngscxx_includes} -I\\$NGSCXX_DIR/${BIN_TO_INC_RELPATH}\" )\n  set( ngscxx_includes \"${ngscxx_includes} -I\\$NGSCXX_DIR/${BIN_TO_INC_RELPATH}/include\" )\n  set( ngscxx_includes \"${ngscxx_includes} \\$PY_INCLUDE_FLAGS\" )\n  find_program(BASH bash REQUIRED)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Curve Mesh in NGSolve\nDESCRIPTION: This snippet demonstrates curving the mesh using a specified order (3 in this case) within NGSolve, improving the approximation of curved geometries. The mesh is then drawn for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nmesh.Curve(3)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Print Solution Vector in Python\nDESCRIPTION: Prints the solution vector\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.1-poisson/poisson.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(gfu.vec)\n```\n\n----------------------------------------\n\nTITLE: Interpolating Stress and Creating Grid Function\nDESCRIPTION: Defines a matrix-valued finite element space for the stress tensor and interpolates the stress field based on the computed displacement. A grid function `gfstress` stores the interpolated stress values.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/wta/elasticity3D.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nwith TaskManager():\n    fesstress = MatrixValued(H1(mesh,order=3), symmetric=True)\n    gfstress = GridFunction(fesstress)\n    gfstress.Interpolate (Stress(Sym(Grad(gfu))))\n```\n\n----------------------------------------\n\nTITLE: Creating block smoothers on finest grid\nDESCRIPTION: This snippet defines block smoothers based on vertex patches on the finest grid. It utilizes the `VertexPatchBlocks` class to define the blocks and then creates a block smoother using `CreateBlockSmoother` from the matrix 'a'. Finally, it constructs a symmetric Gauss-Seidel smoother using the block Jacobian.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.1.2-blockjacobi/blockjacobi.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nblocks = VertexPatchBlocks(mesh, fes)\nblockjac = a.mat.CreateBlockSmoother(blocks)\nblockgs = SymmetricGS(blockjac)\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh with Custom Geometry (Python)\nDESCRIPTION: This snippet generates a mesh from the custom geometry defined using lines and splines, setting a maximum mesh size.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.1-geom2d/geom2d.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nngmesh = geo.GenerateMesh(maxh=0.2)\n```\n\n----------------------------------------\n\nTITLE: Getting Boundaries for 3D Contact Problem - Python\nDESCRIPTION: This code retrieves and prints the boundary names of the 3D mesh.  These names are used later for defining boundary conditions and contact surfaces.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmesh.GetBoundaries()\n```\n\n----------------------------------------\n\nTITLE: Setting NVCC Flags - CMake\nDESCRIPTION: This snippet iterates through compile options specified in `NGSOLVE_COMPILE_OPTIONS` and `ngcore_compile_options`, as well as adding `-fPIC`, and constructs a string `nvcc_flags` containing these options prefixed with `-Xcompiler`. This allows passing C++ compiler flags to the CUDA compiler.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngscuda/CMakeLists.txt#_snippet_10\n\nLANGUAGE: CMake\nCODE:\n```\nset(nvcc_flags \"\")\nforeach( opt ${NGSOLVE_COMPILE_OPTIONS} ${ngcore_compile_options} \"-fPIC\")\n    set(nvcc_flags \"${nvcc_flags} -Xcompiler ${opt}\")\n    message(\"add opt \", ${opt})\nendforeach()\n```\n\n----------------------------------------\n\nTITLE: Updating CutInformation and Redrawing - Python\nDESCRIPTION: This snippet updates the level set function and the corresponding `CutInfo` object. The level set function is redefined, interpolated to the P1 space, and then the `CutInfo` is updated with the new level set data. The scene is then redrawn to reflect the changes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nlevelset = sqrt((x-0.5)**2+y**2)-1\nscene = Draw(levelset,mesh,\"levelset\") # overwrite visualization\nInterpolateToP1(levelset,lsetp1)\nci.Update(lsetp1);scene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Generating Mesh for Finite Element Analysis\nDESCRIPTION: This Python code generates a mesh using the Netgen OCC module and initializes the NGSolve environment.  It creates a unit square mesh with a maximum element size of 0.2, disabling quad-dominated meshing. This mesh will be used for the finite element analysis.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-9.1-C++FE/CppExtension.ipynb#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom netgen.occ import unit_square\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.2, quad_dominated=False))\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags in CMake\nDESCRIPTION: This snippet sets the compiler flags for the NGSolve project using the `set` command. The flags are stored in the `flags` variable, which is then used in a message displaying the project's configuration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_52\n\nLANGUAGE: cmake\nCODE:\n```\nset(flags \"${ngscxx_flags}\")\n```\n\n----------------------------------------\n\nTITLE: Adding Compile Definition for TCL\nDESCRIPTION: If Netgen GUI is enabled (`NETGEN_USE_GUI`), the snippet appends `TCL` to the list of compile definitions.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_31\n\nLANGUAGE: cmake\nCODE:\n```\nif (NETGEN_USE_GUI)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS TCL)\nendif (NETGEN_USE_GUI)\n```\n\n----------------------------------------\n\nTITLE: Drawing Level Set Function and Cut Ratio in NGSolve (Python)\nDESCRIPTION: This code snippet visualizes the level set function (psi) and the cut ratio (cutRatio) using the Draw function in NGSolve. It creates two visualization scenes: one for the level set itself and another for the cut ratio, which represents the fraction of an element intersected by the level set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/05_Topological_Derivative_Transmission.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nscene = Draw(psi)\nscene_cr = Draw(cutRatio, mesh, \"cutRatio\")\n```\n\n----------------------------------------\n\nTITLE: Get Dofs Associated to Volume Elements\nDESCRIPTION: This snippet iterates over the volume elements of a finite element space and prints the dofs associated with each element. It requires a previously defined finite element space (fes) and showcases how Dofs are associated to FESpaceElements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfor el in fes.Elements(VOL):\n    print(type(el))\n    print (el.dofs)\n```\n\n----------------------------------------\n\nTITLE: Initializing Mesh in 2D\nDESCRIPTION: This code initializes an empty Netgen Mesh object for two dimensions. This object will be populated with mesh points and elements in subsequent steps. The `dim=2` argument specifies the spatial dimension of the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nngmesh = Mesh(dim=2)\n```\n\n----------------------------------------\n\nTITLE: Time-Stepping with PML\nDESCRIPTION: This snippet implements the time-stepping loop for the wave equation with PML. It includes the PML damping terms in the update equations.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/wave_cuda.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ngfu = GridFunction(fes)\nscene = Draw (gfu.components[0], order=3, min=-0.05, max=0.05, autoscale=False)\n\nt = 0\ntend = 15\ntau = 2e-4\ni = 0\nsigma = 10   # pml damping parameter\n\nop1 = invp@(-fullB.T-sigma*dampingp) \nop2 = invu@(fullB-sigma*dampingu)\nwith TaskManager(): \n    while t < tend:\n\n        gfu.vec.data += tau*Envelope(t)*srcvec\n        gfu.vec.data += tau*op1*gfu.vec\n        gfu.vec.data += tau*op2*gfu.vec        \n\n        t += tau\n        i += 1\n        if i%20 == 0:\n            scene.Redraw()\n```\n\n----------------------------------------\n\nTITLE: Finding numactl executable in CMake\nDESCRIPTION: This CMake code searches for the numactl executable on the system. If found, it sets the `SET_CPU_BINDING` variable to the appropriate numactl command for binding the process to CPU 0.  This is used later when running the timings script.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/tests/timings/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfind_program(NUMACTL_EXECUTABLE numactl)\nif(NUMACTL_EXECUTABLE)\n  set(SET_CPU_BINDING numactl -C 0)\nendif(NUMACTL_EXECUTABLE)\n```\n\n----------------------------------------\n\nTITLE: Finding Netgen Package\nDESCRIPTION: Uses the find_package command to locate the Netgen library, requiring it to be found and providing hints about its location. The CONFIG keyword indicates that it should use a configuration file provided by Netgen.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(Netgen REQUIRED CONFIG HINTS ${CMAKE_INSTALL_PREFIX}/Contents/Resources)\n```\n\n----------------------------------------\n\nTITLE: Installing Prerequisites on Ubuntu (Bash)\nDESCRIPTION: This command updates the package list and installs the necessary prerequisites for building Netgen/NGSolve on Ubuntu, including Python 3, Tk, XMU, OpenGL, LAPACKE, and other development libraries.  It requires root privileges to execute. The `-y` flag automatically answers 'yes' to any prompts during the installation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update && sudo apt-get -y install python3 python3-distutils python3-tk libpython3-dev libxmu-dev tk-dev tcl-dev cmake git g++ libglu1-mesa-dev liblapacke-dev libocct-data-exchange-dev libocct-draw-dev occt-misc libtbb-dev libxi-dev\n```\n\n----------------------------------------\n\nTITLE: Defining and Visualizing Exact Solution - Python\nDESCRIPTION: This snippet defines the exact solution and visualizes it.  `u_exact` represents the analytical solution. The `ProjectOnMultiDimGF` function projects the analytical solution onto a grid function that can be visualized over time.  The multidim GridFunction allows sampling within the time interval. The Draw function displays the approximate solution along with the analytical solution. It utilizes the `helper` module which is not defined here.  The min, max, and autoscale parameters control the color scaling of the visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.4-spacetime_fitted/spacetime_fitted.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nu_exact = sin(pi * t) * sin(pi * x)**2 * sin(pi * y)**2\nfrom helper import ProjectOnMultiDimGF\nu_exact_to_show = ProjectOnMultiDimGF(sin(pi * tref) * sin(pi * x)**2 * sin(pi * y)**2,mesh,order=3,sampling=8)\nDraw(u_exact_to_show,mesh,\"u_exact\",autoscale=False,min=0,max=1, interpolate_multidim=True, animate=True, deformation=True)\n# The multidim-option now samples within the time interval [0,1].\n```\n\n----------------------------------------\n\nTITLE: Finding Element-Internal Solution (NGSolve, Python)\nDESCRIPTION: This code snippet calculates the element-internal solution by adding the contributions from the harmonic extension and the inner solve. These operations recover the solution values at the internal degrees of freedom that were eliminated during static condensation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/how_to/howto_staticcondensation.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nu.vec.data += a.harmonic_extension * u.vec\nu.vec.data += a.inner_solve * f.vec\n\nDraw (u)\n```\n\n----------------------------------------\n\nTITLE: Listing files in current directory (time series)\nDESCRIPTION: This code uses the shell command `ls` to list files matching the pattern \"vtk_example2*\". This is done to check the generation of a time-series of VTK files.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-vtk/vtk.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nls -lh vtk_example2*\n```\n\n----------------------------------------\n\nTITLE: Inspecting Element Aggregation Data\nDESCRIPTION: This snippet prints information about trivial and non-trivial patches, as well as patch interior facets and the facet-to-patch mapping, providing insights into the aggregation structure.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.8-aggregation/aggregation.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(\"trivial root elements:\", EA.els_in_trivial_patch)\nprint(\"nontrivial elements:\", EA.els_in_nontrivial_patch)\nprint(\"EA.patch_interior_facets: \", EA.patch_interior_facets)\nprint(\"EA.facet_to_patch: \", EA.facet_to_patch)\n```\n\n----------------------------------------\n\nTITLE: Adding 1D Elements to Mesh\nDESCRIPTION: This code adds one-dimensional elements (`Element1D`) to the mesh, connecting consecutive points defined in the `pnums` array. It also sets the material for the domain using `m.AddRegion` and assigns an index to it. The `Element1D` objects are created using the `PointId` objects.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nidx = m.AddRegion(\"material\", dim=1)\nfor i in range(0,N):\n    m.Add (Element1D ([pnums[i],pnums[i+1]], index=idx))\n```\n\n----------------------------------------\n\nTITLE: Initializing IPython Parallel Cluster\nDESCRIPTION: This code initializes an IPython parallel cluster with MPI engines.  It uses the `ipyparallel` library to start and connect to a cluster with a specified number of engines, configured to use MPI for communication. The `activate=True` argument ensures that the cluster is ready for immediate use.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5a.3-petsc/PETSc_interface.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ipyparallel import Cluster\nc = await Cluster(engines=\"mpi\").start_and_connect(n=4, activate=True)\n```\n\n----------------------------------------\n\nTITLE: Block Gauss-Seidel Smoothing in NGSolve (Python)\nDESCRIPTION: This snippet demonstrates block Gauss-Seidel smoothing for solving a linear system with a block-triangular matrix in NGSolve. It defines blocks corresponding to vertices, edges, and faces of the mesh and creates block smoothers for each. The smoothers are then applied sequentially. It uses `fes.GetDofNrs` to get the degrees of freedom numbers corresponding to the topological entities.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.10-dualbasis/dualbasis.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nvblocks = [fes.GetDofNrs(vertex) for vertex in mesh.vertices]\neblocks = [fes.GetDofNrs(edge) for edge in mesh.edges]\nfblocks = [fes.GetDofNrs(face) for face in mesh.faces]\n\nprint (vblocks)\nprint (eblocks)\nprint (fblocks)\n\nvinv = a.mat.CreateBlockSmoother(vblocks)\neinv = a.mat.CreateBlockSmoother(eblocks)\nfinv = a.mat.CreateBlockSmoother(fblocks)\n\nvinv.Smooth(gfu.vec, f.vec)\neinv.Smooth(gfu.vec, f.vec)\nfinv.Smooth(gfu.vec, f.vec)\nprint (gfu.vec)\n```\n\n----------------------------------------\n\nTITLE: Printing the Expression Tree with a Parameter\nDESCRIPTION: This snippet prints the expression tree of the CoefficientFunction `f`, showcasing how the `Parameter` `k` is represented as a node in the tree.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nprint(f)\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies\nDESCRIPTION: Specifies that the `ngstd` library depends on the `generate_version_file` target. This ensures that the version file is generated before `ngstd` is built.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nadd_dependencies( ngstd generate_version_file )\n```\n\n----------------------------------------\n\nTITLE: Demonstrate NodeId and MeshNode Types\nDESCRIPTION: This snippet shows the different types for a NodeId and MeshNode. It highlights that `v` is a `NodeId` and `meshv` is a `MeshNode`. It clarifies that when a NodeId is associated with a Mesh it becomes a MeshNode.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntype(v), type(meshv)   # note the different types\n```\n\n----------------------------------------\n\nTITLE: Installing NGSolve Header Files\nDESCRIPTION: This cmake command installs specified header files (`mgpre.hpp`, `multigrid.hpp`, `prolongation.hpp`, `smoother.hpp`) to the include directory of the NGSolve installation. The destination is defined by the `${NGSOLVE_INSTALL_DIR_INCLUDE}` variable.  The `COMPONENT ngsolve_devel` specifies that these files are part of the development component of NGSolve.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/multigrid/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( FILES\n        mgpre.hpp  multigrid.hpp  prolongation.hpp  smoother.hpp\n        DESTINATION ${NGSOLVE_INSTALL_DIR_INCLUDE}\n        COMPONENT ngsolve_devel\n       )\n```\n\n----------------------------------------\n\nTITLE: Create ElementId Object\nDESCRIPTION: This snippet creates an `ElementId` object representing a boundary element with number 0 and prints its type. It introduces the `ElementId` class and demonstrates how to instantiate it with the `BND` object representing boundary elements.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nei = ElementId(BND,0)\ntype(ei)\n```\n\n----------------------------------------\n\nTITLE: Initializing NGSolve and SciPy\nDESCRIPTION: This snippet imports necessary modules from NGSolve, the web GUI, and SciPy's linear algebra library. It initializes a mesh object from the unit square with a specified maximum element size. This is the preliminary setup needed for the rest of the eigenvalue solver implementation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.2-eigenvalues/pinvit.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n\nimport scipy.linalg\n\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.1))\n```\n\n----------------------------------------\n\nTITLE: Checking CouplingType of degrees of freedom\nDESCRIPTION: This snippet iterates through each degree of freedom in the finite element space defined on a subdomain and prints its `CouplingType`. This demonstrates that many dofs are of type `COUPLING_TYPE.UNUSED_DOF`\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfor i in range(fes1.ndof):\n    print(fes1.CouplingType(i))\n```\n\n----------------------------------------\n\nTITLE: Installing Webgui\nDESCRIPTION: This command installs the webgui_jupyter_widgets package using pip. It is a necessary first step to using Webgui in a Jupyter notebook environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npip install webgui_jupyter_widgets\n```\n\n----------------------------------------\n\nTITLE: Exporting single solution to VTK format with NGSolve\nDESCRIPTION: This code snippet demonstrates how to export a single solution to a VTK file using the VTKOutput class in NGSolve. It initializes a VTKOutput object with the mesh, coefficient functions, names, filename, and subdivision level, and then calls the Do() method to write the output to a file. The output file can then be visualized using ParaView.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-vtk/vtk.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nvtk = VTKOutput(mesh,coefs=[gfu],names=[\"sol\"],filename=\"vtk_example1\",subdivision=2)\nvtk.Do()\n```\n\n----------------------------------------\n\nTITLE: Visualizing the state\nDESCRIPTION: This code redraws the state variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/03b_Shape_Derivative_Laplace_FullyAuto.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nscene_u = Draw(gfu)\n```\n\n----------------------------------------\n\nTITLE: Access Volume Element via NodeId\nDESCRIPTION: This snippet demonstrates accessing a volume element using `NodeId`. It highlights that both `NodeId` with `ELEMENT` and `ElementId` with `VOL` can be used to access the same volume element.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nel0 = mesh[NodeId(ELEMENT, 0)]\ntype(el0)\n```\n\n----------------------------------------\n\nTITLE: Setting Real Compilation Flag\nDESCRIPTION: This snippet sets the realcompile flag to False. This flag controls whether the expressions are compiled (JIT) or interpreted.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# expression (jit) compilation flag\nrealcompile = False\n```\n\n----------------------------------------\n\nTITLE: Integrating over a list of domains\nDESCRIPTION: This snippet computes the perimeter of the triangle by integrating over a list of tuples describing each side. The `domain_list` contains the domain types corresponding to each side of the triangle, which are then passed to `dCut` and `Integrate`. The result is compared to the exact perimeter to calculate the error.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.6-mlset_basic/mlset_basic.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndomain_list = [(IF, NEG, NEG), (NEG, IF, NEG), (NEG, NEG, IF)]\nlen_together =  Integrate(CoefficientFunction(1) * dCut(level_sets_p1, domain_list, order=0), mesh)\n\n\nprint(\"Perimeter of the triangle\")\nprint(\"Result of the integration: {}\".format(len_together))\nprint(\"Error of the integration: {:5.3e}\".format(abs(len_together - 1 - sqrt(5))))\n```\n\n----------------------------------------\n\nTITLE: Configuring VTune Integration\nDESCRIPTION: Configures integration with Intel VTune Profiler. If `USE_VTUNE` is enabled, it adds the `VTUNE` compile definition, finds the VTune include and library directories, and includes them.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_41\n\nLANGUAGE: cmake\nCODE:\n```\nif(USE_VTUNE)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS VTUNE)\n    find_path(VTUNE_INCLUDE_DIR libittnotify.h)\n    include_directories(${VTUNE_INCLUDE_DIR})\n    get_filename_component(VTUNE_DIR ${VTUNE_INCLUDE_DIR} PATH)\n    if(INTEL_MIC)\n        find_library(VTUNE_LIB libittnotify.a PATH ${VTUNE_DIR}/bin64/k1om)\n    else(INTEL_MIC)\n        find_library(VTUNE_LIB libittnotify.a PATH ${VTUNE_DIR}/lib64)\n    endif(INTEL_MIC)\nendif(USE_VTUNE)\n```\n\n----------------------------------------\n\nTITLE: Target Include Directories Configuration\nDESCRIPTION: Sets the include directories for the `ngstd` library. These directories contain the header files needed to compile the library and any other libraries that depend on it.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/ngstd/CMakeLists.txt#_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_include_directories(ngstd PUBLIC ${NGSOLVE_INCLUDE_DIRS} )\n```\n\n----------------------------------------\n\nTITLE: Configuring UMFPACK Integration\nDESCRIPTION: Configures integration with UMFPACK. If `USE_UMFPACK` is enabled, it sets `SuiteSparse_USE_LAPACK_BLAS` to `ON`, finds the SuiteSparse package or individual UMFPACK libraries, and adds the `USE_UMFPACK` compile definition.  It also locates the umfpack include directory.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_40\n\nLANGUAGE: cmake\nCODE:\n```\nif(USE_UMFPACK)\n  set(SuiteSparse_USE_LAPACK_BLAS ON)\n  find_package(suitesparse QUIET NO_MODULE HINTS ${UMFPACK_DIR})\n  if(suitesparse_FOUND)\n    set(UMFPACK_LIBRARIES SuiteSparse::umfpack)\n  else()\n    # UMFPACK was not built with Superbuild, look for it manually\n    find_library(UMFPACK_LIB REQUIRED NAMES umfpack HINTS ${UMFPACK_DIR}/lib ${UMFPACK_DIR}/lib64)\n    find_library(CHOLMOD_LIB REQUIRED NAMES cholmod HINTS ${UMFPACK_DIR}/lib ${UMFPACK_DIR}/lib64)\n    find_library(AMD_LIB REQUIRED NAMES amd HINTS ${UMFPACK_DIR}/lib ${UMFPACK_DIR}/lib64)\n    find_library(CCOLAMD_LIB REQUIRED NAMES ccolamd HINTS ${UMFPACK_DIR}/lib ${UMFPACK_DIR}/lib64)\n    find_library(SUITESPARSECONFIG_LIB REQUIRED NAMES suitesparseconfig HINTS ${UMFPACK_DIR}/lib ${UMFPACK_DIR}/lib64)\n    set(UMFPACK_LIBRARIES ${UMFPACK_LIB} ${CHOLMOD_LIB} ${AMD_LIB} ${CCOLAMD_LIB} ${SUITESPARSECONFIG_LIB})\n    find_path(UMFPACK_INCLUDE_DIR REQUIRED NAMES umfpack.h PATH_SUFFIXES suitesparse HINTS ${UMFPACK_DIR}/include ${UMFPACK_DIR}/include/suitesparse)\n  endif()\n  list(APPEND NGSOLVE_COMPILE_DEFINITIONS USE_UMFPACK)\nendif(USE_UMFPACK)\n```\n\n----------------------------------------\n\nTITLE: Initializing Git submodules\nDESCRIPTION: This command navigates to the 'src' directory and initializes and updates the Git submodules, downloading the source files for Netgen and Pybind11. It ensures that all external dependencies are properly included in the build process.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installwindows.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd src\ngit submodule update --init --recursive\ncd ..\n```\n\n----------------------------------------\n\nTITLE: Printing Eigenvalues\nDESCRIPTION: This snippet prints the computed eigenvalues.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.7-helmholtz/pml.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint (\"lam: \", lam)\n```\n\n----------------------------------------\n\nTITLE: Generating Higher Order H1 Space\nDESCRIPTION: This snippet creates a higher-order H1 finite element space on the previously generated mesh. It initializes the order of the space and creates a `GridFunction` to represent solutions in this space.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.3-hcurlhdiv/hcurlhdiv.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\norder=3\nfes = H1(mesh, order=order)\ngfu = GridFunction(fes)\n```\n\n----------------------------------------\n\nTITLE: Rebuilding and Reinstalling (Bash)\nDESCRIPTION: These commands rebuild and reinstall the project after updating the source code. This ensures that the latest changes are incorporated into the installed binaries.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/install/installlinux.rst#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nmake\nmake install\n```\n\n----------------------------------------\n\nTITLE: Cauchy-Riemann Regularization - Python\nDESCRIPTION: This Python code demonstrates adding Cauchy-Riemann regularization to the bilinear form `aX` used in shape optimization. It adds terms to enforce conformality and improve mesh quality. PHI and PSI represent test and trial functions, respectively. alpha is the regularization parameter that controls the strength of the regularization. It depends on the definitions of PHI, PSI, dx, aX and the value of alpha.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-7-optimization/01_Shape_Derivative_Levelset.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nalpha = 100\n\naX += alpha * (PHI.Deriv()[0,0] - PHI.Deriv()[1,1])*(PSI.Deriv()[0,0] - PSI.Deriv()[1,1]) *dx\naX += alpha * (PHI.Deriv()[1,0] + PHI.Deriv()[0,1])*(PSI.Deriv()[1,0] + PSI.Deriv()[0,1]) *dx\n```\n\n----------------------------------------\n\nTITLE: Get Boundaries of Mesh in NGSolve\nDESCRIPTION: This snippet shows how to retrieve the boundary information from an NGSolve mesh using the GetBoundaries() method. This provides information about the different boundary regions in the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.2-csg/csg.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nngmesh = geo.GenerateMesh()\nmesh = Mesh(ngmesh)\nmesh.GetBoundaries()\n```\n\n----------------------------------------\n\nTITLE: Configuring HYPRE Integration\nDESCRIPTION: Configures the integration with HYPRE. If `USE_HYPRE` is enabled, it checks for MPI, finds the HYPRE package, adds the `HYPRE` compile definition, and includes the HYPRE include directories.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_36\n\nLANGUAGE: cmake\nCODE:\n```\nif (USE_HYPRE)\n  if (NOT NETGEN_USE_MPI)\n      message(FATAL_ERROR \"Hypre needs MPI to be enabled, but Netgen was configured without MPI!\")\n  endif (NOT NETGEN_USE_MPI)\n  find_package(HYPRE REQUIRED)\n  list(APPEND NGSOLVE_COMPILE_DEFINITIONS HYPRE)\n  include_directories(${HYPRE_INCLUDES})\nendif(USE_HYPRE)\n```\n\n----------------------------------------\n\nTITLE: Adding Mesh Points in Python\nDESCRIPTION: This code snippet adds mesh points to the mesh. It iterates through a grid of points defined by the `N` parameter and adds each point to the mesh using `mesh.Add(MeshPoint(Pnt(i / N, j / N, 0)))`. The point indices are stored in the `pnums` list.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/netgen_tutorials/manual_mesh_generation.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npnums = []\nfor i in range(N + 1):\n    for j in range(N + 1):\n        pnums.append(mesh.Add(MeshPoint(Pnt(i / N, j / N, 0))))\n```\n\n----------------------------------------\n\nTITLE: Adding Definitions based on Header Checks\nDESCRIPTION: Conditionally appends HAVE_DLFCN_H and HAVE_CXA_DEMANGLE to the NGSOLVE_COMPILE_DEFINITIONS list if the corresponding header files were found during the check_include_files and check_cxx_symbol_exists steps.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_15\n\nLANGUAGE: cmake\nCODE:\n```\nif(HAVE_DLFCN_H)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS HAVE_DLFCN_H)\nendif()\nif(HAVE_CXA_DEMANGLE)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS HAVE_CXA_DEMANGLE)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Uninstall Target Configuration (CMake)\nDESCRIPTION: This snippet configures an uninstall target, which generates a script to remove installed files. It also generates a configuration file for NGSolve that includes installation directories.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_51\n\nLANGUAGE: CMake\nCODE:\n```\nconfigure_file(\n    \"${CMAKE_CURRENT_SOURCE_DIR}/cmake/cmake_uninstall.cmake.in\"\n    \"${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake\"\n    IMMEDIATE @ONLY)\n# add_custom_target(uninstall\n#     COMMAND ${CMAKE_COMMAND} -P ${CMAKE_CURRENT_BINARY_DIR}/cmake_uninstall.cmake)\n\nget_filename_component(NGS_CMAKE_DIR_ABS ${NGSOLVE_INSTALL_DIR_CMAKE} ABSOLUTE BASE_DIR ${CMAKE_INSTALL_PREFIX})\nfile(RELATIVE_PATH CMAKE_TO_PREFIX_RELPATH ${NGS_CMAKE_DIR_ABS} ${CMAKE_INSTALL_PREFIX})\nconfigure_file(${CMAKE_CURRENT_SOURCE_DIR}/cmake/NGSolveConfig.cmake.in\n  ${CMAKE_CURRENT_BINARY_DIR}/NGSolveConfig.cmake @ONLY ESCAPE_QUOTES)\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/NGSolveConfig.cmake DESTINATION ${NGSOLVE_INSTALL_DIR_CMAKE} COMPONENT ngsolve_devel)\n```\n\n----------------------------------------\n\nTITLE: Animating the deformation - Python\nDESCRIPTION: This snippet animates the deformation field by gradually increasing its magnitude and redrawing the scene. This allows visualizing the effect of the deformation on the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.2-intlset/intlset.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nN=100\n\ndeformation.vec.data = 1.0/N*deformation.vec\nfor i in range (1, N+1):\n    deformation.vec.data = (i+1)/i * deformation.vec\n    scene1.Redraw()\n    scene2.Redraw()\n```\n\n----------------------------------------\n\nTITLE: CTest Configuration (CMake)\nDESCRIPTION: This snippet enables testing using CTest and defines a custom target for performance tests. This allows running tests that are marked with the \"performance\" label and executing them using the \"Experimental\" dashboard configuration.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_50\n\nLANGUAGE: CMake\nCODE:\n```\nenable_testing()\ninclude(CTest)\nadd_custom_target(performance_tests ctest -L performance -D Experimental)\n```\n\n----------------------------------------\n\nTITLE: Stopping Cluster\nDESCRIPTION: This snippet calls the `stop_cluster()` function, which is assumed to be defined in the imported `usrmeeting_jupyterstuff` module. Its purpose is likely to terminate any existing cluster.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.4-fetidp_edge/feti-dp-iii.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nstop_cluster()\n```\n\n----------------------------------------\n\nTITLE: Generating structured surface meshes with a mapping\nDESCRIPTION: This snippet uses the `MakeStructuredSurfaceMesh` function to generate a structured surface mesh based on the mapping function defined previously. The `quads` argument specifies whether to use quadrilaterals or triangles.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.1-surfacemeshes/surface_meshes.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve.meshes import MakeStructuredSurfaceMesh\nmesh = MakeStructuredSurfaceMesh(quads=True, nx=12, ny=2, mapping=mapping)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary modules\nDESCRIPTION: This snippet imports the required modules from ngsolve, xfem, netgen, and math. It sets up the environment for solving the problem using unfitted finite element methods.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.3-cutfem/cutfem.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# the constant pi\nfrom math import pi\n# ngsolve stuff\nfrom ngsolve import *\n# basic xfem functionality\nfrom xfem import *\n# basic geometry features (for the background mesh)\nfrom netgen.geom2d import SplineGeometry\n# visualization stuff\nfrom ngsolve.webgui import * \n```\n\n----------------------------------------\n\nTITLE: Import NGSolve and Netgen modules\nDESCRIPTION: Imports necessary modules from the NGSolve and Netgen libraries for finite element analysis and geometry creation.  The ngsolve.webgui module is used for visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.13-interfaces/interfaceresistivity.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.occ import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Setting NGSolve Installation Directories\nDESCRIPTION: Sets the installation directories for NGSolve based on the corresponding Netgen installation directories. This ensures that the NGSolve files are installed in the same locations as the Netgen files. It also replaces \"netgen\" with \"ngsolve\" in NETGEN_INSTALL_DIR_CMAKE to create NGSOLVE_INSTALL_DIR_CMAKE.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nset(NGSOLVE_INSTALL_DIR_PYTHON  ${NETGEN_INSTALL_DIR_PYTHON})\nset(NGSOLVE_INSTALL_DIR_BIN     ${NETGEN_INSTALL_DIR_BIN})\nset(NGSOLVE_INSTALL_DIR_LIB     ${NETGEN_INSTALL_DIR_LIB})\nset(NGSOLVE_INSTALL_DIR_INCLUDE ${NETGEN_INSTALL_DIR_INCLUDE})\nset(NGSOLVE_INSTALL_DIR_RES     ${NETGEN_INSTALL_DIR_RES})\nstring(REPLACE \"netgen\" \"ngsolve\" NGSOLVE_INSTALL_DIR_CMAKE ${NETGEN_INSTALL_DIR_CMAKE})\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories in CMake\nDESCRIPTION: Adds the current source directory to the include directories used during compilation. The `BEFORE` keyword ensures that this directory is searched before other system directories. This allows the project's header files to be found before system headers with the same name.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/parallel/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ninclude_directories(BEFORE ${CMAKE_CURRENT_SOURCE_DIR})\n```\n\n----------------------------------------\n\nTITLE: Creating a time-dependent coefficient function and exporting as VTK series\nDESCRIPTION: This code snippet demonstrates how to create a time-dependent coefficient function and export it as a series of VTK files. It initializes a Parameter object, defines a time-dependent coefficient function, creates a VTKOutput object, and then calls the Do() method repeatedly with different time values in a loop. This generates a sequence of VTK files that can be used to create a video or animation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-vtk/vtk.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nt = Parameter(0)\ncoef = sin(4*(x+y+t))\nvtkout = VTKOutput(mesh,coefs=[coef],names=[\"sol\"],filename=\"vtk_example2\",subdivision=2)\nvtkout.Do(time = 0.0)\nfor i in range(20):\n    t.Set((i+1)/20)\n    vtkout.Do(time = (i+1)/20.0)\n```\n\n----------------------------------------\n\nTITLE: Importing Necessary Modules for NGSolve\nDESCRIPTION: This code snippet imports the necessary modules from NGSolve and Netgen. `ngsolve` provides the core functionality for finite element analysis, `netgen.occ` is used for creating the geometry, and `ngsolve.webgui` enables visualization of the results.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.14-globalspaces/planewavecoupling.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom netgen.occ import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Resetting Mesh for TDNNS Method in NGSolve\nDESCRIPTION: This snippet resets the mesh for the TDNNS simulation, generating a new mesh with specified maximum element size (maxh) and curving it to a specified order. It then visualizes the mesh using Draw.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(sg.GenerateMesh(maxh=R/3))\nmesh.Curve(order)\nDraw(mesh)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Target for Version File Generation\nDESCRIPTION: Adds a custom target named generate_version_file that executes the cmake command to run the cmake/generate_version_file.cmake script. It passes the CMAKE_CURRENT_BINARY_DIR and CMAKE_CURRENT_LIST_DIR as arguments to the script.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_16\n\nLANGUAGE: cmake\nCODE:\n```\nadd_custom_target(generate_version_file\n  ${CMAKE_COMMAND}\n    -DBDIR=${CMAKE_CURRENT_BINARY_DIR}\n    -P ${CMAKE_CURRENT_LIST_DIR}/cmake/generate_version_file.cmake\n    )\n```\n\n----------------------------------------\n\nTITLE: Generating a Mesh - Python\nDESCRIPTION: This snippet creates a mesh of the unit square using the `unit_square.GenerateMesh` function from NGSolve. The `maxh` parameter controls the maximum element size in the mesh. The created mesh object can then be used for defining finite element spaces and solving PDEs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh = Mesh(unit_square.GenerateMesh(maxh=0.3))\n```\n\n----------------------------------------\n\nTITLE: Start and Connect to Cluster - Python\nDESCRIPTION: Starts a computational cluster with the specified number of processors and associates it with the given user ID. Then, it connects to the started cluster. This function initializes the distributed computing environment, allowing parallel execution of tasks.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.3-fetidp_point3d/feti-dp-ii.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstart_cluster(num_procs,user_id)\nconnect_cluster(user_id)\n```\n\n----------------------------------------\n\nTITLE: Access Ngs_Element from ElementId\nDESCRIPTION: This snippet shows how to access an `Ngs_Element` object from an `ElementId` using the mesh. It then retrieves the vertices of that element. It showcases how to access Ngs_Element object associated with an ElementId by indexing the mesh object with the ElementId.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.8-meshtopology/meshtopology.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nmeshel = mesh[ei]\ntype(meshel)\nprint (\"type of meshel = \\n \", meshel)\nprint (\"vertices =\", meshel.vertices)\n```\n\n----------------------------------------\n\nTITLE: Installing Header Files\nDESCRIPTION: This snippet installs the header files associated with the `ngbla` library to the `${NGSOLVE_INSTALL_DIR_INCLUDE}` directory. It installs headers related to matrices, vectors, linear algebra operations, and other related data structures.  It marks the install component as `ngsolve_devel`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/basiclinalg/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\ninstall( FILES\n        bandmatrix.hpp cholesky.hpp matrix.hpp ng_lapack.hpp \n        vector.hpp bla.hpp expr.hpp symmetricmatrix.hpp clapack.h     \n        tensor.hpp triangular.hpp householder.hpp eigensystem.hpp calcinverse.hpp\n        ngblas.hpp simd_complex.hpp complex_wrapper.hpp\n        DESTINATION ${NGSOLVE_INSTALL_DIR_INCLUDE}\n        COMPONENT ngsolve_devel\n       )\n```\n\n----------------------------------------\n\nTITLE: Checking webgui_jupyter_widgets Version - Python\nDESCRIPTION: This code snippet verifies that the installed version of `webgui_jupyter_widgets` is greater than or equal to 0.2.18. If the version is outdated, it prints a message instructing the user to upgrade the package using pip.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-webgui/webgui-internal.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    import webgui_jupyter_widgets\n    from packaging.version import parse\n    assert parse(webgui_jupyter_widgets.__version__) >= parse(\"0.2.18\")\n    print('Everything good!')\nexcept:\n    print(\"\\x1b[31mYou need to update webgui_jupyter_widgets by running: \\x1b[0m\\npython3 -m pip install --upgrade webgui_jupyter_widgets\")\n```\n\n----------------------------------------\n\nTITLE: Defining Inverse Material Law for TDNNS\nDESCRIPTION: This snippet defines a function CMatInv to compute the inverse of the material law of Hooke, necessary for the TDNNS method. It takes the material matrix, Young's modulus (E), and Poisson's ratio (nu) as inputs.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.1.3-rmplate/Reissner_Mindlin_plate.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef CMatInv(mat, E, nu):\n    return (1+nu)/E*(mat-nu/(nu+1)*Trace(mat)*Id(2))\n```\n\n----------------------------------------\n\nTITLE: Printing the Compiled Expression Tree\nDESCRIPTION: This snippet prints the compiled expression tree for the `finalc` CoefficientFunction.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.2-coefficient/coefficientfunction.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nprint(finalc)\n```\n\n----------------------------------------\n\nTITLE: Using string shorthands for regions in integration\nDESCRIPTION: This snippet demonstrates an alternative syntax for specifying the integration region within `dx` and `ds`.  Instead of passing a `Region` object, a string representing the region name can be passed directly.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-1.5-subdomains/subdomains.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nf = LinearForm(u1*v*dx('inner') + 0.1*v*ds('t')).Assemble()\n```\n\n----------------------------------------\n\nTITLE: Import NGSolve modules\nDESCRIPTION: Imports necessary modules from the NGSolve library for finite element analysis and visualization.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.4-nonlmin/nonlmin.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# imports\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\n```\n\n----------------------------------------\n\nTITLE: Configuring MKL Integration\nDESCRIPTION: Configures integration with Intel MKL. If `USE_MKL` is enabled, it finds the MKL package, sets compile definitions, and handles interface layer and static linking considerations.  It also installs the MKL runtime libraries on Windows if MKL is statically linked.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_34\n\nLANGUAGE: cmake\nCODE:\n```\nif (USE_MKL)\n    set(NG_USE_MPI ${USE_MPI})\n    unset(USE_MPI CACHE)\n    find_package(MKL REQUIRED)\n    set(USE_MPI ${NG_USE_MPI} CACHE STRING \"enable mpi parallelization\")\n    target_include_directories(ngs_lapack INTERFACE \"${MKL_INCLUDE_DIRS}\")\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS USE_PARDISO)\n    list(APPEND NGSOLVE_COMPILE_DEFINITIONS_PRIVATE USE_MKL)\n\n    if(\"${MKL_INTERFACE_LAYER}\" STREQUAL \"_ilp64\" OR ${MKL_INTERFACE} STREQUAL \"ilp64\")\n      list(APPEND NGSOLVE_COMPILE_DEFINITIONS MKL_ILP64)\n    endif()\n    if(MKL_STATIC AND WIN32)\n      install(FILES ${MKL_RTL_LIBRARY_BIN} DESTINATION ${NGSOLVE_INSTALL_DIR_BIN} COMPONENT ngsolve )\n    endif()\nendif (USE_MKL)\n```\n\n----------------------------------------\n\nTITLE: Drawing the Advection Velocity - Python\nDESCRIPTION: This snippet visualizes the advection velocity field `b` on the mesh using the `Draw` function. The visualization helps to understand the direction and magnitude of the advection.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-3.5.1-dgapply/dgapply-scalar.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nDraw(b,mesh,vectors = {\"grid_size\" : 32}, min = 2, max = 3, autoscale=False,\n     height = \"30vh\")\n```\n\n----------------------------------------\n\nTITLE: Enabling Compile Commands Export\nDESCRIPTION: Enables the export of compile commands, which can be used by tools like clangd for code completion and analysis. The generated compile_commands.json file contains the exact compiler commands used to build each source file.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n```\n\n----------------------------------------\n\nTITLE: Configuring Pardiso Integration\nDESCRIPTION: Configures integration with the Pardiso solver. If `USE_PARDISO` is enabled, it adds the `USE_PARDISO` and `USE_PARDISO400` compile definitions, finds the Pardiso library, and links it with the OpenMP library.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_39\n\nLANGUAGE: cmake\nCODE:\n```\nif(USE_PARDISO)\n  list(APPEND NGSOLVE_COMPILE_DEFINITIONS USE_PARDISO)\n  list(APPEND NGSOLVE_COMPILE_DEFINITIONS USE_PARDISO400)\n  if(NOT PARDISO_LIB)\n      find_library(PARDISO_LIB NAMES libpardiso500-GNU481-X86-64.so)\n  endif(NOT PARDISO_LIB)\n  if(NOT PARDISO_LIB)\n      message(FATAL_ERROR \"Could NOT find Pardiso\")\n  endif(NOT PARDISO_LIB)\n  find_package(OpenMP)\n  set(PARDISO_LIBS ${PARDISO_LIB} ${OpenMP_gomp_LIBRARY} ${OpenMP_pthread_LIBRARY})\nendif(USE_PARDISO)\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Domain Types - Python\nDESCRIPTION: These snippets iterate through the `DrawMarkedElements` generator to draw elements of different domain types. Each call to `next(dme)` draws the elements corresponding to the next domain type (IF, NEG, POS).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-8.1-basics/basics.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnext(dme)\n```\n\nLANGUAGE: python\nCODE:\n```\nnext(dme)\n```\n\nLANGUAGE: python\nCODE:\n```\nnext(dme)\n```\n\n----------------------------------------\n\nTITLE: Using Ccache for Compilation\nDESCRIPTION: This snippet attempts to find the ccache executable. If found, it sets the RULE_LAUNCH_COMPILE global property to the ccache executable, effectively using ccache to speed up compilation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_18\n\nLANGUAGE: cmake\nCODE:\n```\nif(USE_CCACHE)\n  find_program(CCACHE_FOUND NAMES ccache ccache.bat)\n  if(CCACHE_FOUND)\n    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ${CCACHE_FOUND})\n  endif(CCACHE_FOUND)\nendif(USE_CCACHE)\n```\n\n----------------------------------------\n\nTITLE: Plotting Eigenvalues - Python\nDESCRIPTION: This snippet uses matplotlib to plot the calculated eigenvalues. It plots the real and imaginary parts of the eigenvalues as points on a scatter plot.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots()\nax.set_xlim(-20,20)\nax.set_ylim(-20,20)\nplt.plot([l.real for l in lams],[l.imag for l in lams],'x')\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Handling Deprecated INSTALL_DIR variable\nDESCRIPTION: Checks if the INSTALL_DIR variable is set. If it is, a warning message is displayed indicating that it's deprecated and that CMAKE_INSTALL_PREFIX should be used instead. The INSTALL_DIR_DEFAULT is then set to the value of INSTALL_DIR for backward compatibility.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nif(INSTALL_DIR)\n  message(WARNING \"INSTALL_DIR is deprecated, use CMAKE_INSTALL_PREFIX instead\")\n  set(INSTALL_DIR_DEFAULT ${INSTALL_DIR})\nendif(INSTALL_DIR)\n```\n\n----------------------------------------\n\nTITLE: Creating a CoefficientFunction - Python\nDESCRIPTION: This snippet creates a `CoefficientFunction` expression using existing `GridFunction` objects (`gfu1`) and coordinate variables (`x`, `y`). The expression represents a mathematical function that can be evaluated on the mesh.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/appendix-pickling/pickling.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfunc = x*gfu1 + y\nprint (func)\n```\n\n----------------------------------------\n\nTITLE: Getting Boundary and Material Information - Python\nDESCRIPTION: This snippet retrieves the boundary names and material names from the generated mesh. It is used to identify the contact surfaces and material regions for subsequent steps in the contact problem setup.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.2-contact/contact.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmesh.GetBoundaries(), mesh.GetMaterials()\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Options for Clang\nDESCRIPTION: Adds specific compiler options when using the Clang compiler, suppressing warnings related to undefined variable templates and variable-length arrays.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_30\n\nLANGUAGE: cmake\nCODE:\n```\nif (CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n    list(APPEND NGSOLVE_COMPILE_OPTIONS $<$<COMPILE_LANGUAGE:CXX>:-Wno-undefined-var-template -Wno-vla-extension>)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Evolving Internal Variables with LinearForm and Mass Matrix in ngsolve (Python)\nDESCRIPTION: This snippet defines a `LinearForm` that triggers the solution of the evolution equations when evaluated. It also sets up a mass matrix for the internal variable space, used as an interpolation tool to project the solution of the evolution equations onto the grid function `gfint`.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-6.3-plasticity/plasticity.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# A Linearform for which the evaluation triggers the solution of the evolution equations \ntestfunc = CoefficientFunction(tuple(fes_int.TestFunction()))\nL_evol = LinearForm(fes_int)\nL_evol += InnerProduct(CacheCF(evolution), testfunc) * irs_dx\n# NOTE: CacheCF(evolution) ensures that the evolution equations are solved only once per evaluation\n\n# Mass-Matrix for the internal variable space as generic interpolation tool\nM_evol = BilinearForm(fes_int, symmetric=True, diagonal=True)\nfor _trial, _test in zip(*fes_int.TnT()):\n    M_evol += InnerProduct(_trial,  _test).Compile() * irs_dx\n    \nM_evol.Assemble()\nM_evol_inv = M_evol.mat.Inverse()\n\n\ndef evolve_internal():\n    compute_trial_state()\n    L_evol.Assemble()\n    gfint.vec.data = M_evol_inv * L_evol.vec\n```\n\n----------------------------------------\n\nTITLE: Getting help for PI in Python\nDESCRIPTION: This snippet demonstrates how to get help information about the `PI` (PointInfo) class using the `help()` function in Python.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.1.2-csg2d/csg2d.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nhelp(PI)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Availability Messages\nDESCRIPTION: Displays messages based on whether Sphinx is found. If Sphinx is found, it informs the user they can build the documentation with `make docu`. If Sphinx is not found, it prompts the user to install Sphinx if they wish to build the documentation.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/CMakeLists.txt#_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nmessage(\"Sphinx found, you can build the documentation with make docu\")\n  else(SPHINX_FOUND)\n    message(\"Sphinx not found, if you want to build the documentation you have to install Sphinx\")\n```\n\n----------------------------------------\n\nTITLE: Importing NGSolve Modules\nDESCRIPTION: This snippet imports necessary modules from the NGSolve library, including core functionalities and visualization tools. It also attempts to import the ngscuda module for GPU acceleration and gracefully handles potential import failures.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-5.5-cuda/EulerEquations.ipynb#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom ngsolve import *\nfrom ngsolve.webgui import Draw\nfrom time import sleep\n\ntry:\n    import ngsolve.ngscuda as ngscuda\nexcept:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Plotting k vs fs - Python\nDESCRIPTION: This snippet generates a plot showing the relationship between the imaginary part of the wave number (k) and frequency (fs). It uses matplotlib to create the plot and display it. The x and y axis limits are explicitly set.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-2.12-periodicity/dispersion.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nax.set_xlim(0,6.28)\nax.set_ylim(0,0.7)\nplt.plot(ks, fs, \"*\", ms=2)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Setting MKL Architecture for Intel MIC\nDESCRIPTION: If Intel MIC support is enabled, this snippet sets the MKL_ARCH variable to \"mic\" and includes the cmake/mic.cmake script, which likely contains specific configurations for Intel Xeon Phi processors.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_19\n\nLANGUAGE: cmake\nCODE:\n```\nif(INTEL_MIC)\n    set(MKL_ARCH \"mic\")\n    include(cmake/mic.cmake)\nendif(INTEL_MIC)\n```\n\n----------------------------------------\n\nTITLE: Importing Modules for 3D Mesh Merging\nDESCRIPTION: This code imports the necessary modules for creating and merging 3D meshes: `netgen.meshing`, `netgen.csg`, and the `ngsglobals` from ngsolve.  The `ngsglobals` module is used to set the message level for debugging purposes.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/unit-4.3-manualmesh/manualmeshing.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom netgen.meshing import *\nfrom netgen.csg import *\n\nfrom ngsolve import ngsglobals\nngsglobals.msg_level = 2\n```\n\n----------------------------------------\n\nTITLE: Setting RPATH for macOS\nDESCRIPTION: Configures the RPATH (runtime search path) for macOS. It sets CMAKE_MACOSX_RPATH to TRUE to enable RPATH and defines CMAKE_INSTALL_RPATH to specify the runtime search path, using the NETGEN_RPATH_TOKEN variable.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_22\n\nLANGUAGE: cmake\nCODE:\n```\nset(CMAKE_MACOSX_RPATH TRUE)\nif(NOT BUILD_FOR_CONDA)\n    set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)\nendif()\nset(CMAKE_INSTALL_RPATH \"${NETGEN_RPATH_TOKEN};${NETGEN_RPATH_TOKEN}/${NETGEN_RPATH}\")\n```\n\n----------------------------------------\n\nTITLE: Setting LAPACK Link Interface\nDESCRIPTION: Sets the link interface property for LAPACK depending on whether MKL is statically linked or not.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/CMakeLists.txt#_snippet_35\n\nLANGUAGE: cmake\nCODE:\n```\nif(MKL_STATIC)\n  set(LAPACK_CMAKE_LINK_INTERFACE PRIVATE)\nelse()\n  set(LAPACK_CMAKE_LINK_INTERFACE PUBLIC)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Stopping MPI Cluster\nDESCRIPTION: This code snippet stops the MPI cluster. It calls the `stop_cluster()` function, which is assumed to be defined in a previously imported module. This function is used to shut down the MPI environment.\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nstop_cluster()\n```\n\n----------------------------------------\n\nTITLE: Printing Parallel Status After Multiplication\nDESCRIPTION: This snippet prints the parallel status of the vectors after the matrix-vector multiplication. It accesses the vectors `v` and `w`, and uses their `GetParallelStatus()` methods to determine and print their parallel status (Cumulated or Distributed).\nSOURCE: https://github.com/ngsolve/ngsolve/blob/master/docs/i-tutorials/historic/unit-5.1-mpi_ngsolve/mpi_basics.ipynb#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nprint('status v: ', v.GetParallelStatus())\nprint('status w: ', w.GetParallelStatus())\n```"
  }
]