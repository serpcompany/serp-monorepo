[
  {
    "owner": "mystenlabs",
    "repo": "move-book",
    "content": "TITLE: Defining Basic Module Structure in Move\nDESCRIPTION: Demonstrates the basic syntax for defining a module in Move, including the module declaration, struct definition, use statement, constant declaration, and a public function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/modules.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::test;\n\npublic struct Example has copy, drop { i: u64 }\n\nuse std::debug;\n\nconst ONE: u64 = 1;\n\npublic fun print(x: u64) {\n    let sum = x + ONE;\n    let example = Example { i: sum };\n    debug::print(&sum)\n}\n```\n\n----------------------------------------\n\nTITLE: Variable Declaration and Assignment in Move\nDESCRIPTION: Demonstrates basic variable declaration and assignment in Move, including mutable and immutable variables. Shows type inference and explicit type annotation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/primitive-types.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun main() {\n    let x = 42;\n    let mut y = 42;\n    let z: u8 = 42;\n}\n```\n\n----------------------------------------\n\nTITLE: Annotating Data Types with Abilities in Move\nDESCRIPTION: Examples of how to declare structs and enums with different abilities in Move. Shows declaration patterns for drop, copy, and store abilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\npublic struct Ignorable has drop { x: u64 }\npublic struct Pair has copy, drop { x: u64, y: u64 }\npublic struct MyVec has copy, drop, store { x: Pair }\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Generic Container in Move\nDESCRIPTION: Demonstrates how to define a generic Container struct with a single type parameter T and a creation function that returns a new Container instance. This showcases the basic syntax for defining generic types and functions in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n/// A simple container for a single value\nstruct Container<T> has copy, drop {\n    value: T\n}\n\n/// Function to create a new container of type T with a value\npublic fun new<T: copy + drop>(value: T): Container<T> {\n    Container<T> { value }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic Ownership in Move\nDESCRIPTION: This snippet shows how variables are owned by their function scopes. Variables 'a' and 'b' are owned by different functions and are dropped when each function ends. The test function shows that these variables are not accessible outside their defining scopes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/ownership-and-scope.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::ownership;\n\npublic fun owner() {\n    let a = 1; // a is owned by the `owner` function\n} // a is dropped here\n\npublic fun other() {\n    let b = 2; // b is owned by the `other` function\n} // b is dropped here\n\n#[test]\nfun test_owner() {\n    owner();\n    other();\n    // a & b are not valid here\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Struct Methods in Move\nDESCRIPTION: This example demonstrates how to define and use methods on a Hero struct. It shows the basic receiver syntax where methods can be called directly on struct instances using the dot notation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct-methods.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule hero::hero {\n    use std::string::String;\n\n    /// Represents a hero with name and health\n    public struct Hero has store, drop {\n        name: String,\n        health: u64,\n    }\n\n    /// Create a new hero with the given name and default health\n    public fun new(name: String): Hero {\n        Hero { name, health: 100 }\n    }\n\n    /// Attack the hero, decreasing their health\n    public fun attack(hero: &mut Hero, damage: u64) {\n        if (hero.health > damage) {\n            hero.health = hero.health - damage;\n        } else {\n            hero.health = 0;\n        }\n    }\n\n    /// Get hero's current health\n    public fun health(hero: &Hero): u64 {\n        hero.health\n    }\n\n    /// Method call example\n    public fun example() {\n        let hero = new(std::string::utf8(b\"Sui\"));\n        health(&hero); // normal call\n        hero.health(); // method call - same as above\n\n        attack(&mut hero, 10); // normal call\n        hero.attack(10); // method call - same as above\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Struct in Move\nDESCRIPTION: Demonstrates how to define a custom struct type with various field types, including another struct and an optional field.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nstruct Artist {\n    name: String,\n}\n\nstruct Record {\n    title: String,\n    artist: Artist,\n    year: u16,\n    is_debut: bool,\n    edition: Option<u16>,\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Reflection in Move\nDESCRIPTION: This code snippet illustrates the usage of type reflection in Move using the std::type_name module. It shows how to get type names for various data types, including primitives and custom structs, and how to extract module and address information from type names.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/type-reflection.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nuse std::type_name;\nuse std::string;\n\nstruct MyType {}\n\n#[test]\nfun test_type_reflection() {\n    // Get type names\n    let bool_type = type_name::get<bool>();\n    let u64_type = type_name::get<u64>();\n    let vec_type = type_name::get<vector<u8>>();\n    let my_type = type_name::get<MyType>();\n\n    // Convert to string\n    let bool_str = type_name::into_string(bool_type);\n    assert!(bool_str == string::utf8(b\"bool\"), 0);\n\n    // Get module name and address\n    let (address, module_name) = type_name::get_address_and_module(my_type);\n    assert!(module_name == string::utf8(b\"type-reflection\"), 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Exhaustive Pattern Matching Examples in Move\nDESCRIPTION: Demonstrates how to make pattern matching exhaustive in Move by adding wildcard patterns or fully matching on remaining values. The examples show corrections to the previously non-exhaustive matches.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_12\n\nLANGUAGE: move\nCODE:\n```\nfun f(x: MyEnum): u8 {\n    match (x) {\n        MyEnum::Variant(1, true) => 1,\n        MyEnum::Variant(_, _) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        // Now exhaustive since this will match all values of MyEnum::OtherVariant\n        MyEnum::OtherVariant(..) => 2,\n\n    }\n}\n\nfun match_pair_bool(x: Pair<bool>): u8 {\n    match (x) {\n        Pair(true, true) => 1,\n        Pair(true, false) => 1,\n        Pair(false, false) => 1,\n        // Now exhaustive since this will match all values of Pair<bool>\n        Pair(false, true) => 1,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Structs with Abilities in Move\nDESCRIPTION: Shows how to declare structs with abilities, which allow values to be copied, dropped, or stored. Abilities can be declared before or after the struct's fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m {\n    public struct Foo has copy, drop { x: u64, y: bool }\n}\n\nmodule a::m;\n\npublic struct PreNamedAbilities has copy, drop { x: u64, y: bool }\npublic struct PostNamedAbilities { x: u64, y: bool } has copy, drop;\npublic struct PrePositionalAbilities has copy, drop (u64, bool)\npublic struct PostPositionalAbilities (u64, bool) has copy, drop;\n```\n\n----------------------------------------\n\nTITLE: Creating a Generic User Type with Metadata in Move\nDESCRIPTION: Defines a User struct with generic metadata of type T. This example demonstrates how generics enable a type to have shared behavior while allowing flexible data storage in specific fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\n/// A user with metadata of any type\nstruct User<T: copy + drop + store> has key, copy, drop, store {\n    name: vector<u8>,\n    age: u8,\n    metadata: T\n}\n\n/// Create a new user\npublic fun new_user<T: copy + drop + store>(name: vector<u8>, age: u8, metadata: T): User<T> {\n    User {\n        name,\n        age,\n        metadata\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rule 1: Handling All Possible Scenarios\nDESCRIPTION: Improved implementation that adds custom checks before operations that might fail. This gives more control over error handling to the calling module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/better-error-handling.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule book::module_a {\n    use book::module_b;\n\n    const ENoField: u64 = 0;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoField);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoField);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoField);\n        let field_3 = module_b::get_field(3);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicit Integer Type Annotation in Move\nDESCRIPTION: Demonstrates different ways to explicitly specify integer types in Move, including type suffixes and annotations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/primitive-types.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nlet x = 42u8;\nlet y: u8 = 42;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Generic Pair Type with Multiple Type Parameters in Move\nDESCRIPTION: Defines a generic Pair struct with two type parameters T and U, along with a function to create a new Pair. This example shows how to work with multiple type parameters in Move generics.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n/// A pair containing two different types\nstruct Pair<T, U> has copy, drop {\n    first: T,\n    second: U\n}\n\n/// Function to create a new pair\npublic fun new_pair<T: copy + drop, U: copy + drop>(first: T, second: U): Pair<T, U> {\n    Pair { first, second }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Witness Pattern in Move\nDESCRIPTION: Demonstrates a basic implementation of the witness pattern in Move, showing how a struct can be created only by the module defining it, thus proving ownership of the type.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/witness-pattern.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::witness;\n\n/// A struct that requires a witness to be created.\npublic struct Instance<T> { t: T }\n\n/// Create a new instance of `Instance<T>` with the provided T.\npublic fun new<T>(witness: T): Instance<T> {\n    Instance { t: witness }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Math Functions in Move\nDESCRIPTION: This snippet defines two functions: 'add' for adding two u64 numbers and 'test_add' that tests the add function using the assert! macro. It demonstrates basic function declaration and internal module function calls.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/function.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::math {\n    fun add(a: u64, b: u64): u64 {\n        a + b\n    }\n\n    #[test]\n    fun test_add() {\n        let result = add(1, 2);\n        assert!(result == 3, 0);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Local Variables in Move\nDESCRIPTION: This snippet demonstrates basic declaration and usage of local variables in Move, including let bindings and mutability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nlet x = 1;\nlet y = x + x:\n\nlet x;\nif (cond) {\n  x = 1\n} else {\n  x = 0\n}\n\nlet mut x = 0;\nif (cond) x = x + 1;\nfoo(&mut x);\n```\n\n----------------------------------------\n\nTITLE: Function Parameters and Return Types in Move\nDESCRIPTION: Examples of Move functions with various parameter and return type configurations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nfun add(x: u64, y: u64): u64 { x + y }\n\nfun useless() { }\n\nfun zero(): u64 { 0 }\n\nfun one_two_three(): (u64, u64, u64) { (0, 1, 2) }\n\nfun just_unit(): () { () }\nfun just_unit() { () }\nfun just_unit() { }\n```\n\n----------------------------------------\n\nTITLE: Calling Functions in Move\nDESCRIPTION: Demonstrates different ways of calling functions in Move, including using aliases and fully qualified names.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nmodule a::example {\n    public fun zero(): u64 { 0 }\n}\n\nmodule b::other {\n    use a::example::{Self, zero};\n    fun call_zero() {\n        // With the `use` above all of these calls are equivalent\n        a::example::zero();\n        example::zero();\n        zero();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Copy Ability Example in Move\nDESCRIPTION: Demonstrates how the copy ability is conditionally inherited by generic types based on their type parameters. Shows valid and invalid cases of copying generic structures.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\npublic struct NoAbilities {}\npublic struct S has copy, drop { f: bool }\npublic struct Cup<T> has copy, drop, store { item: T }\n\nfun example(c_x: Cup<u64>, c_s: Cup<S>) {\n    // Valid, 'Cup<u64>' has 'copy' because 'u64' has 'copy'\n    let c_x2 = copy c_x;\n    // Valid, 'Cup<S>' has 'copy' because 'S' has 'copy'\n    let c_s2 = copy c_s;\n}\n\nfun invalid(c_account: Cup<signer>, c_n: Cup<NoAbilities>) {\n    // Invalid, 'Cup<signer>' does not have 'copy'.\n    // Even though 'Cup' was declared with copy, the instance does not have 'copy'\n    // because 'signer' does not have 'copy'\n    let c_account2 = copy c_account;\n    // Invalid, 'Cup<NoAbilities>' does not have 'copy'\n    // because 'NoAbilities' does not have 'copy'\n    let c_n2 = copy c_n;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutable References\nDESCRIPTION: Demonstrates how to use immutable references to read Card data without transferring ownership using the inspect_card function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/references.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nfun inspect_card(card: &Card) {\n    assert!(card.rides > 0, EMPTY_CARD)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hello World Module\nDESCRIPTION: Demonstrates the implementation of a simple 'hello_world' module with a function that returns 'Hello, World!' as a String.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\n/// The module `hello_world` under named address `hello_world`.\n/// The named address is set in the `Move.toml`.\nmodule hello_world::hello_world;\n\n// Imports the `String` type from the Standard Library\nuse std::string::String;\n\n/// Returns the \"Hello, World!\" as a `String`.\npublic fun hello_world(): String {\n    b\"Hello, World!\".to_string()\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Package Structure in Move\nDESCRIPTION: This snippet demonstrates the basic structure of a Move package, showing how it consists of modules containing structs and functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/packages.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\npackage 0x...\n    module a\n        struct A1\n        fun hello_world()\n    module b\n        struct B1\n        fun hello_package()\n```\n\n----------------------------------------\n\nTITLE: Defining Structs in Move\nDESCRIPTION: Demonstrates how to define structs with named and positional fields inside a module. Structs can have abilities and must follow specific naming conventions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct Foo { x: u64, y: bool }\npublic struct Bar {}\npublic struct Baz { foo: Foo, }\n//                          ^ note: it is fine to have a trailing comma\n\npublic struct PosFoo(u64, bool)\npublic struct PosBar()\npublic struct PosBaz(Foo)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Structs in Move\nDESCRIPTION: Demonstrates how to create struct instances, including named and positional structs. Also shows field name punning for struct creation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct Foo has drop { x: u64, y: bool }\npublic struct Baz has drop { foo: Foo }\npublic struct Positional(u64, bool) has drop;\n\nfun example() {\n    let foo = Foo { x: 0, y: false };\n    let baz = Baz { foo: foo };\n    // Note: positional struct values are created using parentheses and\n    // based on position instead of name.\n    let pos = Positional(0, false);\n    let pos_invalid = Positional(false, 0);\n    //                           ^ ERROR! Fields are out of order and the types don't match.\n}\n\nlet baz = Baz { foo: foo };\n// is equivalent to\nlet baz = Baz { foo };\n```\n\n----------------------------------------\n\nTITLE: Defining a Generic Identity Function in Move\nDESCRIPTION: This snippet demonstrates how to define a generic identity function that takes a value of any type and returns it unchanged. It showcases the syntax for declaring type parameters in functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun id<T>(x: T): T {\n    // this type annotation is unnecessary but valid\n    (x: T)\n}\n```\n\n----------------------------------------\n\nTITLE: Unpacking a Struct with Ignored Fields in Move\nDESCRIPTION: Demonstrates how to unpack a struct while ignoring unused fields to suppress compiler warnings.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nlet Artist { name: _ } = artist;\n```\n\n----------------------------------------\n\nTITLE: Illustrating Automatic Borrowing in Move Method Calls\nDESCRIPTION: This example demonstrates how the Move compiler automatically borrows the receiver if a function expects a reference. It shows borrowing for both immutable and mutable references.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct X() has copy, drop;\npublic fun by_val(_: X) {}\npublic fun by_ref(_: &X) {}\npublic fun by_mut(_: &mut X) {}\n\nfun example(mut x: X) {\n    x.by_ref(); // resolves to a::m::by_ref(&x)\n    x.by_mut(); // resolves to a::m::by_mut(&mut x)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Object Struct with Key Ability in Move\nDESCRIPTION: This snippet demonstrates how to define a struct with the 'key' ability, which is considered an object in Move. It includes the required 'id' field of type UID and a constructor function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/key-ability.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\npublic struct Object has key {\n    id: UID, // required\n    name: String,\n}\n\n/// Creates a new Object with a Unique ID\npublic fun new(name: String, ctx: &mut TxContext): Object {\n    Object {\n        id: object::new(ctx), // creates a new UID\n        name,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Return Values with Tuples in Move\nDESCRIPTION: This snippet demonstrates how to return multiple values from a function using tuple return types. The function returns both the sum and product of two input values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/function.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun sum_and_product(a: u64, b: u64): (u64, u64) {\n    (a + b, a * b)\n}\n```\n\n----------------------------------------\n\nTITLE: Using if-else Expression for Variable Assignment in Move\nDESCRIPTION: This example demonstrates how to use an if-else expression to assign a value to a variable based on a condition.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nlet x = 5;\nlet y = if (x > 0) 1 else 0;\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Generics in Move\nDESCRIPTION: This example shows how Move's type inference can automatically determine type arguments for generic functions and structs, reducing the need for explicit type annotations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun foo() {\n    let x = id(true);\n    //        ^ <bool> is inferred\n\n    let foo = Foo { x: true };\n    //           ^ <bool> is inferred\n\n    let Foo { x } = foo;\n    //     ^ <bool> is inferred\n}\n```\n\n----------------------------------------\n\nTITLE: Event Emission Sample Implementation - Move\nDESCRIPTION: Example showing how to emit events using the sui::event module. The code demonstrates the practical implementation of event emission in a Move module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/events.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/events.move:emit}}\n```\n\n----------------------------------------\n\nTITLE: Using VecMap for Key-Value Pair Storage in Move\nDESCRIPTION: Illustrates the implementation of VecMap for storing key-value pairs. The example shows how to create a VecMap, insert key-value pairs, and retrieve values using keys.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/collections.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/collections-3.move:vec_map}}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Generic Container Instances in Move\nDESCRIPTION: Shows three equivalent ways to create a new Container with a u8 value. This example demonstrates how type inference works with generics in Move, and how the compiler can infer types when given partial type information.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n#[test]\nfun test_generic() {\n    // Explicitly specify the type of the container\n    let c1: Container<u8> = new(10);\n    // Explicitly specify the type for the function call\n    let c2 = new<u8>(10);\n    // Explicitly specify the type of the value\n    let c3 = new(10u8);\n\n    // These are all equivalent\n    assert!(c1.value == 10, 0);\n    assert!(c2.value == 10, 0);\n    assert!(c3.value == 10, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Unpacking a Struct in Move\nDESCRIPTION: Shows how to unpack a struct into its individual fields, creating new variables.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nlet Artist { name } = artist;\n```\n\n----------------------------------------\n\nTITLE: Handling Vectors of Non-Droppable Types in Move\nDESCRIPTION: Illustrates how to properly handle vectors containing non-droppable types. Empty vectors must be explicitly destroyed using destroy_empty, while non-empty vectors require manual element handling.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/vector.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nstruct Coin has store { value: u64 }\n\npublic fun example() {\n    let v = vector::empty<Coin>();\n    \n    // Explicitly destroy empty vector of non-drop type\n    vector::destroy_empty(v);\n    \n    // ERROR!\n    // let v2 = vector::empty<Coin>();\n    // v2 is implicitly destroyed here\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Search with Early Return in Move\nDESCRIPTION: This function searches for a target value in a vector and returns its index using an Option type. It demonstrates using a return statement within a loop to exit early when the target is found.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_12\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\nuse std::option::{Self, Option};\n\nfun index_of<T>(v: &vector<T>, target: &T): Option<u64> {\n    let i = 0;\n    let n = vector::length(v);\n    while (i < n) {\n        if (vector::borrow(v, i) == target) return option::some(i);\n        i = i + 1\n    };\n\n    option::none()\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Public Functions from Another Module\nDESCRIPTION: Demonstrates how to import and call a public function from another module. This code will compile successfully because public functions are accessible outside their defining module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/visibility.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule book::try_calling_public {\n\nuse book::public_visibility;\n\n// Different module -> can call public()\nfun try_calling_public() {\n    public_visibility::public();\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Transferring Ownership by Returning Values in Move\nDESCRIPTION: This example demonstrates how returning a variable from a function transfers its ownership to the caller. Variable 'a' is defined in the 'owner' function but returned, making it accessible in the test_owner function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/ownership-and-scope.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule book::ownership;\n\npublic fun owner(): u8 {\n    let a = 1; // a defined here\n    a // scope ends, a is returned\n}\n\n#[test]\nfun test_owner() {\n    let a = owner();\n    // a is valid here\n} // a is dropped here\n```\n\n----------------------------------------\n\nTITLE: Implementing Versioned State for Move Objects\nDESCRIPTION: This snippet demonstrates how to implement versioning for Move objects. It includes a shared state object with a version field and a function that checks the version before performing operations, allowing for forced migration to new versions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/upgradeability-practices.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule book::versioned_state {\n\n    const EVersionMismatch: u64 = 0;\n\n    const VERSION: u8 = 1;\n\n    /// The shared state (can be owned too)\n    public struct SharedState has key {\n        id: UID,\n        version: u8,\n        /* ... */\n    }\n\n    public fun mutate(state: &mut SharedState) {\n        assert!(state.version == VERSION, EVersionMismatch);\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Option Values in Move\nDESCRIPTION: Demonstrates how to create and manipulate Option values using various methods from the option module, including creating Some and None values, testing variants, and extracting values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/option.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/option.move:usage}}\n```\n\n----------------------------------------\n\nTITLE: Initializing Integer Variables with Explicit and Inferred Types in Move\nDESCRIPTION: This code snippet demonstrates various ways to initialize integer variables in Move, including explicit type annotations, type inference, and hexadecimal representations for different integer sizes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/integers.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// literals with explicit annotations;\nlet explicit_u8 = 1u8;\nlet explicit_u16 = 1u16;\nlet explicit_u32 = 1u32;\nlet explicit_u64 = 2u64;\nlet explicit_u128 = 3u128;\nlet explicit_u256 = 1u256;\nlet explicit_u64_underscored = 154_322_973u64;\n\n// literals with simple inference\nlet simple_u8: u8 = 1;\nlet simple_u16: u16 = 1;\nlet simple_u32: u32 = 1;\nlet simple_u64: u64 = 2;\nlet simple_u128: u128 = 3;\nlet simple_u256: u256 = 1;\n\n// literals with more complex inference\nlet complex_u8 = 1; // inferred: u8\n// right hand argument to shift must be u8\nlet _unused = 10 << complex_u8;\n\nlet x: u8 = 38;\nlet complex_u8 = 2; // inferred: u8\n// arguments to `+` must have the same type\nlet _unused = x + complex_u8;\n\nlet complex_u128 = 133_876; // inferred: u128\n// inferred from function argument type\nfunction_that_takes_u128(complex_u128);\n\n// literals can be written in hex\nlet hex_u8: u8 = 0x1;\nlet hex_u16: u16 = 0x1BAE;\nlet hex_u32: u32 = 0xDEAD80;\nlet hex_u64: u64 = 0xCAFE;\nlet hex_u128: u128 = 0xDEADBEEF;\nlet hex_u256: u256 = 0x1123_456A_BCDE_F;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scopes and Expression Blocks in Move\nDESCRIPTION: This code illustrates the behavior of scopes and expression blocks in Move, including variable accessibility and the resulting values of blocks.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\n{\n    let x = 0;\n    {\n        let y = x + 1; // valid\n    }\n}\n\n{ let x = 1; let y = 1; x + y }\n\n{ let v = vector[]; vector::push_back(&mut v, 1); v }\n```\n\n----------------------------------------\n\nTITLE: Destroying Structs via Pattern Matching in Move\nDESCRIPTION: Shows how to destroy struct values by binding or assigning them in patterns. Includes examples for named structs, positional structs, and nested patterns.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct Foo { x: u64, y: bool }\npublic struct Bar(Foo)\npublic struct Baz {}\npublic struct Qux()\n\nfun example_destroy_foo() {\n    let foo = Foo { x: 3, y: false };\n    let Foo { x, y: foo_y } = foo;\n    //        ^ shorthand for `x: x`\n\n    // two new bindings\n    //   x: u64 = 3\n    //   foo_y: bool = false\n}\n\nfun example_destroy_foo_wildcard() {\n    let foo = Foo { x: 3, y: false };\n    let Foo { x, y: _ } = foo;\n\n    // only one new binding since y was bound to a wildcard\n    //   x: u64 = 3\n}\n\nfun example_destroy_foo_assignment() {\n    let x: u64;\n    let y: bool;\n    Foo { x, y } = Foo { x: 3, y: false };\n\n    // mutating existing variables x and y\n    //   x = 3, y = false\n}\n\nfun example_foo_ref() {\n    let foo = Foo { x: 3, y: false };\n    let Foo { x, y } = &foo;\n\n    // two new bindings\n    //   x: &u64\n    //   y: &bool\n}\n\nfun example_foo_ref_mut() {\n    let foo = Foo { x: 3, y: false };\n    let Foo { x, y } = &mut foo;\n\n    // two new bindings\n    //   x: &mut u64\n    //   y: &mut bool\n}\n\nfun example_destroy_bar() {\n    let bar = Bar(Foo { x: 3, y: false });\n    let Bar(Foo { x, y }) = bar;\n    //            ^ nested pattern\n\n    // two new bindings\n    //   x: u64 = 3\n    //   y: bool = false\n}\n\nfun example_destroy_baz() {\n    let baz = Baz {};\n    let Baz {} = baz;\n}\n\nfun example_destroy_qux() {\n    let qux = Qux();\n    let Qux() = qux;\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Type Inference in Move\nDESCRIPTION: This snippet demonstrates how Move infers integer types based on usage and default behavior, as well as how to handle large integer values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nlet x8: u8 = 0;\nlet x16: u16 = 0;\nlet x32: u32 = 0;\nlet x64: u64 = 0;\nlet x128: u128 = 0;\nlet x256: u256 = 0;\n\nlet x = 0;\n//      ^ u64 is used by default\n\nlet i: u8 = 256; // ERROR!\n//          ^^^ too large for u8\nlet x = 340282366920938463463374607431768211454;\n//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ too large for u64\n\nlet x = 340282366920938463463374607431768211454u128;\n//                                             ^^^^ valid!\n```\n\n----------------------------------------\n\nTITLE: Creating Test-Only Utilities with #[test_only] in Move\nDESCRIPTION: Demonstrates how to create helper functions for testing using the #[test_only] attribute. These functions are only available in the test environment and can be used to access internal functionality.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/testing.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule book::testing;\n\n// Public function which uses the `secret` function.\npublic fun multiply_by_secret(x: u64): u64 {\n    x * secret()\n}\n\n/// Private function which is not available to the public.\nfun secret(): u64 { 100 }\n\n#[test_only]\n/// This function is only available for testing purposes in tests and other\n/// test-only functions. Mind the visibility - for `#[test_only]` it is\n/// common to use `public` visibility.\npublic fun secret_for_testing(): u64 {\n    secret()\n}\n\n#[test]\n// In the test environment we have access to the `secret_for_testing` function.\nfun test_multiply_by_secret() {\n    let expected = secret_for_testing() * 2;\n    assert!(multiply_by_secret(2) == expected);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generic Functions and Structs in Move\nDESCRIPTION: This snippet demonstrates how to call generic functions and use generic structs with explicit type arguments. It shows both construction and destruction of generic struct values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nfun foo() {\n    let x = id<bool>(true);\n\n    // type arguments on construction\n    let foo = Foo<bool> { x: true };\n    let bar = Bar<u64, u8> { x: 0, y: vector<u8>[] };\n\n    // type arguments on destruction\n    let Foo<bool> { x } = foo;\n    let Bar<u64, u8> { x, y } = bar;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic If Expression in Move\nDESCRIPTION: Simple if condition that modifies a value based on a boolean comparison.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/conditionals.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nif (x > 5) x = x - 5\n```\n\n----------------------------------------\n\nTITLE: Defining Enums with Different Field Types in Move\nDESCRIPTION: This example shows how to define enums with no fields, positional fields, and named fields. It also demonstrates how to specify abilities for enums.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum Foo has drop {\n    VariantWithNoFields,\n    //                 ^ note: it is fine to have a trailing comma after variant declarations\n}\npublic enum Bar has copy, drop {\n    VariantWithPositionalFields(u64, bool),\n}\npublic enum Baz has drop {\n    VariantWithNamedFields { x: u64, y: bool, z: Bar },\n}\n```\n\n----------------------------------------\n\nTITLE: Using Supply for Minting Balance in Sui Framework\nDESCRIPTION: Shows how the instantiated Supply<T> can be used to mint new Balance<T> instances, where T is the type of the supply. This demonstrates the practical application of the witness pattern in token management.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/witness-pattern.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n// File: sui-framework/sources/balance.move\n/// Storable balance.\npublic struct Balance<phantom T> has store {\n    value: u64,\n}\n\n/// Increase supply by `value` and create a new `Balance<T>` with this value.\npublic fun increase_supply<T>(self: &mut Supply<T>, value: u64): Balance<T> {\n    assert!(value < (18446744073709551615u64 - self.value), EOverflow);\n    self.value = self.value + value;\n    Balance { value }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching in Move\nDESCRIPTION: Demonstrates a simple pattern matching function that returns different values based on the input.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun run(x: u64): u64 {\n    match (x) {\n        1 => 2,\n        2 => 3,\n        x => x,\n    }\n}\n\nrun(1); // returns 2\nrun(2); // returns 3\nrun(3); // returns 3\nrun(0); // returns 0\n```\n\n----------------------------------------\n\nTITLE: Complete Metro Pass Test Implementation\nDESCRIPTION: Full example demonstrating the usage of all reference types and ownership transfer in a test scenario.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/references.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n#[test]\nfun test_card_flow() {\n    // Buy a new card\n    let card = new();\n    \n    // Show card to inspector - immutable borrow\n    inspect_card(card);\n    \n    // Use card at turnstile - mutable borrow\n    use_at_turnstile(card);\n    \n    // Show card to inspector again - immutable borrow\n    inspect_card(card);\n    \n    // Recycle the card - move\n    recycle(card);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Let Binding Grammar in Move\nDESCRIPTION: This snippet illustrates the grammar of let bindings in Move, showing how patterns, type annotations, and initializers can be combined.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nlet (x, y): (u64, u64) = (0, 1);\nlet Foo { f, g: x } = Foo { f: 0, g: 1 };\n```\n\n----------------------------------------\n\nTITLE: Defining a Copyable Type in Move\nDESCRIPTION: Demonstrates how to define a custom type with the Copy ability, allowing instances to be duplicated.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/copy-ability.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nstruct Copyable has copy {\n    value: u64\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Ability Constraints to Type Parameters in Move\nDESCRIPTION: Defines a function that requires its type parameter to have the copy and drop abilities. This demonstrates how to constrain type parameters to ensure they support specific operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\n/// A function that requires T to be copyable and droppable\npublic fun copy_value<T: copy + drop>(value: T): (T, T) {\n    (value, value)\n}\n```\n\n----------------------------------------\n\nTITLE: Privileged Struct Operations in Move\nDESCRIPTION: Illustrates the visibility rules for struct operations in Move. Struct types can only be created, destroyed, and have their fields accessed inside the module that defines them.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m {\n    public struct Foo has drop { x: u64 }\n\n    public fun new_foo(): Foo {\n        Foo { x: 42 }\n    }\n}\n\nmodule a::n {\n    use a::m::Foo;\n\n    public struct Wrapper has drop {\n        foo: Foo\n        //   ^ valid the type is public\n\n    }\n\n    fun f1(foo: Foo) {\n        let x = foo.x;\n        //      ^ ERROR! cannot access fields of `Foo` outside of `a::m`\n    }\n\n    fun f2() {\n        let foo_wrapper = Wrapper { foo: m::new_foo() };\n        //                               ^ valid the function is public\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining UID and ID Structs in Sui Move\nDESCRIPTION: Defines the UID struct as a wrapper around ID, and ID as a wrapper around an address. These are fundamental types for object identification in Sui.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/uid-and-id.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// File: sui-framework/sources/object.move\n/// UID is a unique identifier of an object\npublic struct UID has store {\n    id: ID\n}\n\n/// ID is a wrapper around an address\npublic struct ID has store, drop {\n    bytes: address\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rule 2: Using Different Abort Codes\nDESCRIPTION: Enhanced implementation that uses distinct error codes for each potential failure point, allowing callers to provide specific error messages.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/better-error-handling.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::module_a {\n    use book::module_b;\n\n    const ENoFieldA: u64 = 0;\n    const ENoFieldB: u64 = 1;\n    const ENoFieldC: u64 = 2;\n\n    public fun do_something() {\n        assert!(module_b::has_field(1), ENoFieldA);\n        let field_1 = module_b::get_field(1);\n        /* ... */\n        assert!(module_b::has_field(2), ENoFieldB);\n        let field_2 = module_b::get_field(2);\n        /* ... */\n        assert!(module_b::has_field(3), ENoFieldC);\n        let field_3 = module_b::get_field(3);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Versioning Configuration with Dynamic Fields in Move\nDESCRIPTION: This snippet shows a pattern for versioning object configurations using dynamic fields in Move. It uses a simple base object with a version and stores the actual configuration as a dynamic field, allowing for changes in configuration structure across upgrades.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/upgradeability-practices.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::versioned_config {\n    use sui::vec_map::VecMap;\n    use std::string::String;\n\n    /// The base object\n    public struct Config has key {\n        id: UID,\n        version: u16\n    }\n\n    /// The actual configuration\n    public struct ConfigV1 has store {\n        data: Bag,\n        metadata: VecMap<String, String>\n    }\n\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Functions from Other Modules in Move\nDESCRIPTION: This example shows how to import and use a function from another module. It demonstrates the use of the 'use' statement and function path notation to access the 'add' function from the math module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/function.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::math_user {\n    use book::math;\n\n    fun use_add(): u64 {\n        math::add(1, 2)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Gift Minting and Transfer Example\nDESCRIPTION: Shows how to implement authorized minting and transfer of Gift objects using AdminCap capability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n/// Some `Gift` object that the admin can `mint_and_transfer`.\npublic struct Gift has key { id: UID }\n\n/// Creates a new `Gift` object and transfers it to the `recipient`.\npublic fun mint_and_transfer(\n    _: &AdminCap, recipient: address, ctx: &mut TxContext\n) {\n    let gift = Gift { id: object::new(ctx) };\n    transfer::transfer(gift, recipient);\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Variable Declarations with Tuples in Move\nDESCRIPTION: This snippet demonstrates how to declare multiple variables at once using tuples in Move, including handling different arities and mixed mutability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet () = ();\nlet (x0, x1) = (0, 1);\nlet (y0, y1, y2) = (0, 1, 2);\nlet (z0, z1, z2, z3) = (0, 1, 2, 3);\n\nlet (mut x, y) = (0, 1);\nx = 1;\n```\n\n----------------------------------------\n\nTITLE: Defining Sui Objects with Different Transfer Capabilities\nDESCRIPTION: Demonstrates how to define two different types of Sui objects - one with restricted transfer capabilities (A) and another with public transfer capabilities (B). Shows proper struct definition with required UID field and appropriate abilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities/object.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule a::my_module;\n\npublic struct A has key {\n    id: sui::object::UID,\n}\n\npublic struct B has key, store {\n    id: sui::object::UID,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Enum Variants in Move\nDESCRIPTION: This snippet demonstrates how to create values of enum types by specifying variants and their fields. It shows examples for variants with no fields, named fields, and positional fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum Action has drop {\n    Stop,\n    Pause { duration: u32 },\n    MoveTo { x: u64, y: u64 },\n    Jump(u64),\n}\npublic enum Other has drop {\n    Stop(u64),\n}\n\nfun example() {\n    // Note: The `Stop` variant of `Action` doesn't have fields so no parentheses or curlies are needed.\n    let stop = Action::Stop;\n    let pause = Action::Pause { duration: 10 };\n    let move_to = Action::MoveTo { x: 10, y: 20 };\n    let jump = Action::Jump(10);\n    // Note: The `Stop` variant of `Other` does have positional fields so we need to supply them.\n    let other_stop = Other::Stop(10);\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Operations Using Move Standard Library\nDESCRIPTION: Demonstrates common vector operations including push_back, pop_back, length, is_empty, and remove. These operations require importing the std::vector module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/vector.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\n\nfun main() {\n    let v = vector::empty<u64>();\n    \n    vector::push_back(&mut v, 5);\n    vector::push_back(&mut v, 6);\n    \n    assert!(vector::length(&v) == 2, 0);\n    \n    let has_five = false;\n    let i = 0;\n    while (i < vector::length(&v)) {\n        if (*vector::borrow(&v, i) == 5) {\n            has_five = true;\n            break\n        };\n        i = i + 1;\n    };\n    \n    assert!(has_five, 1);\n    \n    // removes the last element\n    vector::pop_back(&mut v);\n    \n    assert!(vector::length(&v) == 1, 2);\n    \n    // check if the vector is empty\n    assert!(!vector::is_empty(&v), 3);\n    \n    // remove the element at index 0\n    vector::remove(&mut v, 0);\n    \n    assert!(vector::is_empty(&v), 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Borrowing Pattern with Hot Potato in Move\nDESCRIPTION: An example that uses the Promise hot potato to ensure that a borrowed value is returned to its container, demonstrating a practical application of the pattern.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/hot-potato-pattern.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule container {\n    use sui::object::{Self, ID, UID};\n    use sui::tx_context::TxContext;\n\n    struct Container has key {\n        id: UID,\n        value: Option<Thing>\n    }\n\n    struct Thing has store {\n        // fields\n    }\n\n    struct Promise {\n        container_id: ID,\n        thing_id: ID\n    }\n\n    /// Create a new Container with the Thing inside\n    public fun new(thing: Thing, ctx: &mut TxContext): Container {\n        Container {\n            id: object::new(ctx),\n            value: option::some(thing)\n        }\n    }\n\n    /// Borrow the Thing from the Container\n    public fun borrow(self: &mut Container): (Thing, Promise) {\n        let thing = option::extract(&mut self.value);\n        let promise = Promise {\n            container_id: object::id(self),\n            thing_id: object::id(&thing)\n        };\n\n        (thing, promise)\n    }\n\n    /// Return the Thing to the Container\n    public fun return(self: &mut Container, thing: Thing, promise: Promise) {\n        let Promise { container_id, thing_id } = promise;\n\n        assert!(object::id(self) == container_id, EWrongContainer);\n        assert!(object::id(&thing) == thing_id, EWrongThing);\n\n        option::fill(&mut self.value, thing);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Type Declaration in Move\nDESCRIPTION: Shows declaration of different integer types available in Move, from u8 to u256.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/primitive-types.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nlet a: u8 = 1;\nlet b: u16 = 2;\nlet c: u32 = 3;\nlet d: u64 = 4;\nlet e: u128 = 5;\nlet f: u256 = 6;\n```\n\n----------------------------------------\n\nTITLE: Match Expression Syntax in Move\nDESCRIPTION: Shows the general syntax of a match expression, including patterns, guards, and arm expressions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmatch (expression) {\n    pattern1 if (guard_expression) => expression1,\n    pattern2 => expression2,\n    pattern3 => { expression3, expression4, ... },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Types as Field Names in Move\nDESCRIPTION: Example showing how to define custom types to use as dynamic field names, providing a more structured approach for dynamic field management with different key types.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n/// One of the keys to use with dynamic fields\npublic struct AccessoryKey has store, copy, drop {\n    name: String\n}\n\n/// Another key, this one is empty\npublic struct MetadataKey has store, copy, drop {}\n```\n\n----------------------------------------\n\nTITLE: Basic Vector Operations in Move\nDESCRIPTION: Example showing common vector operations like creating an empty vector, pushing elements, accessing elements, and popping elements.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/vector.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\n\nlet mut v = vector::empty<u64>();\nvector::push_back(&mut v, 5);\nvector::push_back(&mut v, 6);\n\nassert!(*vector::borrow(&v, 0) == 5, 42);\nassert!(*vector::borrow(&v, 1) == 6, 42);\nassert!(vector::pop_back(&mut v) == 6, 42);\nassert!(vector::pop_back(&mut v) == 5, 42);\n```\n\n----------------------------------------\n\nTITLE: Control Flow Expressions in Move\nDESCRIPTION: Shows how control flow constructs in Move (if-else and while loops) are expressions that return values, with examples of assigning the results to variables.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/expression.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nfun control_flow() {\n    // If-else expression\n    let x = if (true) 1 else 2;\n    assert!(x == 1, 0);\n\n    // While loop\n    let i = 0;\n    let sum = 0;\n    while (i < 10) {\n        sum = sum + i;\n        i = i + 1;\n    };\n    assert!(sum == 45, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Abilities with Generic Types\nDESCRIPTION: Example showing how to declare conditional abilities on generic types, demonstrating ability inheritance based on type parameters.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\npublic struct Cup<T> has copy, drop, store, key { item: T }\n```\n\n----------------------------------------\n\nTITLE: Defining Public Functions in Move\nDESCRIPTION: Shows how to define public functions in Move using the 'public' keyword. Public functions can be called from any module that imports them.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/visibility.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::public_visibility;\n\n// This function can be called from other modules\npublic fun public() { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Declaring a Module with Label Syntax in Move\nDESCRIPTION: Example of declaring a module using the newer label syntax, which is the recommended approach. The module name follows snake_case convention and is preceded by its package address.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/module.md#2025-04-22_snippet_0\n\nLANGUAGE: Move\nCODE:\n```\nmodule book::module_label;\n\n// Module members go here\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String as Bytes in Move\nDESCRIPTION: Shows how strings in Move are fundamentally byte vectors by creating a custom string implementation with a wrapper struct around vector<u8>.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/string.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule package::custom_strings {\n    struct CustomString has copy, drop, store {\n        bytes: vector<u8>\n    }\n\n    fun new(bytes: vector<u8>): CustomString {\n        CustomString { bytes }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Expected Failure Tests in Move\nDESCRIPTION: Shows how to write tests for failure cases using the #[expected_failure] attribute. This attribute can specify the expected abort code that should be returned when the test fails.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/testing.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::testing_failure;\n\nconst EInvalidArgument: u64 = 1;\n\n#[test]\n#[expected_failure(abort_code = 0)]\nfun test_fail() {\n    abort 0 // aborts with 0\n}\n\n// attributes can be grouped together\n#[test, expected_failure(abort_code = EInvalidArgument)]\nfun test_fail_1() {\n    abort 1 // aborts with 1\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Vectors with Different Types in Move\nDESCRIPTION: Shows how to create vectors in Move using vector literal syntax with different types, including empty vectors, integers, booleans, and nested vectors.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/vector.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nlet empty_vector: vector<u8> = vector[];\nlet singleton_vector = vector[100u8];\nlet multiple_elements = vector[1u8, 2u8, 3u8];\n\nlet nested_vector = vector[vector[1u8, 2u8], vector[3u8, 4u8]];\n\nlet boolean_vector = vector[true, false];\n```\n\n----------------------------------------\n\nTITLE: Importing Specific Members in Move\nDESCRIPTION: This example demonstrates how to import specific members from a module using the 'use' keyword.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule package::example {\n    use sui::object::UID;\n    use sui::tx_context::TxContext;\n\n    struct Example has key {\n        id: UID\n    }\n\n    public fun new(ctx: &mut TxContext): Example {\n        Example { id: sui::object::new(ctx) }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Phantom Type Parameters in Move\nDESCRIPTION: Defines a Coin struct with a phantom type parameter T that isn't used in any fields. This demonstrates how phantom type parameters can provide type-level distinctions without runtime overhead.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\n/// Unit structs for different currencies\nstruct USD has drop {}\nstruct EUR has drop {}\n\n/// A coin with a phantom type parameter for the currency\nstruct Coin<phantom T: drop> has key, store {\n    value: u64,\n}\n\n/// Create a new coin\npublic fun new_coin<T: drop>(value: u64): Coin<T> {\n    Coin { value }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Type Constraints in Move Generics\nDESCRIPTION: Shows how to use a function with constrained type parameters. This example demonstrates that the function works with types that satisfy the constraints.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\n#[test]\nfun test_constraints() {\n    let (v1, v2) = copy_value(10u8);\n    assert!(v1 == 10u8, 0);\n    assert!(v2 == 10u8, 0);\n    \n    let (v1, v2) = copy_value(true);\n    assert!(v1 == true, 0);\n    assert!(v2 == true, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Option Type in a User Registry Example\nDESCRIPTION: Practical example of using Option for optional fields in a user registry, where the middle_name field is defined as Option<String> to clearly indicate its optional nature.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/option.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/option.move:registry}}\n```\n\n----------------------------------------\n\nTITLE: Creating a Store with Module Initializer in Move\nDESCRIPTION: Example of a Store module that uses the `init` function to create a StoreOwnerCap object when the module is published. The capability is then transferred to the module publisher.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/module-initializer.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/module-initializer.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Guard Expressions in Pattern Matching in Move\nDESCRIPTION: Explains the use of guard expressions in pattern matching for Move. The example demonstrates how guards are evaluated after pattern matching but before the arm expression, and how they affect match arm selection.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_13\n\nLANGUAGE: move\nCODE:\n```\nfun match_with_guard(x: u64): u64 {\n    match (x) {\n        1 if (false) => 1,\n        1 => 2,\n        _ => 3,\n    }\n}\n\nmatch_with_guard(1); // returns 2\nmatch_with_guard(0); // returns 3\n```\n\n----------------------------------------\n\nTITLE: Type Inference for Vectors in Move\nDESCRIPTION: This snippet demonstrates type inference for vectors in Move, showing cases where manual annotation is required and where the compiler can infer the type based on usage.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\nfun foo() {\n    let v = vector[]; // ERROR!\n    //            ^ The compiler cannot figure out the element type, since it is never used\n\n    let v = vector<u64>[];\n    //            ^~~~~ Must annotate manually in this case.\n}\n\nfun foo() {\n    let v = vector[];\n    //            ^ <u64> is inferred\n    vector::push_back(&mut v, 42);\n    //               ^ <u64> is inferred\n}\n```\n\n----------------------------------------\n\nTITLE: Function Return Values in Move\nDESCRIPTION: Examples showing how return values are determined in Move functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\nfun add(x: u64, y: u64): u64 {\n    x + y\n}\n\nfun double_and_add(x: u64, y: u64): u64 {\n    let double_x = x * 2;\n    let double_y = y * 2;\n    double_x + double_y\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Type with Witness in Sui Framework\nDESCRIPTION: Demonstrates how the Sui Framework uses the witness pattern to create a Supply type that can only be instantiated with a witness of type T. This allows for controlled minting and burning of a specific token type.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/witness-pattern.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n// File: sui-framework/sources/balance.move\n/// A Supply of T. Used for minting and burning.\npublic struct Supply<phantom T> has store {\n    value: u64,\n}\n\n/// Create a new supply for type T with the provided witness.\npublic fun create_supply<T: drop>(_w: T): Supply<T> {\n    Supply { value: 0 }\n}\n\n/// Get the `Supply` value.\npublic fun supply_value<T>(supply: &Supply<T>): u64 {\n    supply.value\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Generic Structs in Move\nDESCRIPTION: This example shows how to define generic structs with type parameters. It includes two struct definitions: Foo with one type parameter and Bar with two type parameters.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\npublic struct Foo<T> has copy, drop { x: T }\n\npublic struct Bar<T1, T2> has copy, drop {\n    x: T1,\n    y: vector<T2>,\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring a Basic Move Function\nDESCRIPTION: Example of a simple Move function declaration with type parameters and a return value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }\n```\n\n----------------------------------------\n\nTITLE: Destructuring Against References in Move\nDESCRIPTION: This snippet demonstrates how to destructure structs against references, allowing for borrowing of fields without moving the entire struct.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example {\n\npublic struct X(u64)\npublic struct Y { x1: X, x2: X }\n\nfun new_x(): X {\n    X(1)\n}\n\nfun example() {\n    let mut y = Y { x1: new_x(), x2: new_x() };\n\n    let Y { x1: X(f), x2 } = &y;\n    assert!(*f + x2.f == 2, 42);\n\n    let Y { x1: X(f1), x2: X(f2) } = &mut y;\n    *f1 = *f1 + 1;\n    *f2 = *f2 + 1;\n    assert!(*f1 + *f2 == 4, 42);\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Table Structure Definition in Move\nDESCRIPTION: Definition of the generic Table structure that provides a typed key-value collection with store ability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-collections.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\npublic struct Table<phantom K: copy + drop + store, phantom V: store> has key, store {\n    /// the ID of this table\n    id: UID,\n    /// the number of key-value pairs in the table\n    size: u64,\n}\n```\n\n----------------------------------------\n\nTITLE: Capability-Based Access Control Implementation\nDESCRIPTION: Shows the implementation of user creation using capability-based access control, demonstrating improved security and code organization.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/capability.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/capability-4.move:with_capability}}\n```\n\n----------------------------------------\n\nTITLE: Using assert! Macro for Condition Checking in Move\nDESCRIPTION: This code shows how to use the assert! macro to check a condition and abort the transaction if the condition is not met.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/assert-and-abort.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nfun aborts_if_not_42(value: u64) {\n    assert!(value == 42, 1);\n}\n\nfun aborts_if_not_42_with_custom_error(value: u64) {\n    assert!(value == 42, ENOT_42);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Sum Function Using While Loop in Move\nDESCRIPTION: This snippet demonstrates how to use a while loop to compute the sum of numbers from 1 to n in Move. It uses mutable variables to keep track of the sum and the current number.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/loops.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun sum(n: u64): u64 {\n    let mut sum = 0;\n    let mut i = 1;\n    while (i <= n) {\n        sum = sum + i;\n        i = i + 1\n    };\n\n    sum\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Wrapper Type in Move\nDESCRIPTION: Demonstrates the basic implementation of a wrapper type pattern, showing how to create a new type that wraps an existing one. This is typically implemented as a positional struct with a single field.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/wrapper-type-pattern.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/wrapper-type-pattern.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Config Pattern for Constants in Move\nDESCRIPTION: Shows how to implement the config pattern to make constants accessible across multiple modules while maintaining centralized control.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/constants.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/constants-config.move:config}}\n```\n\n----------------------------------------\n\nTITLE: Using a Generic Pair Type with Multiple Parameters in Move\nDESCRIPTION: Demonstrates how to create and use a Pair instance with two different types. This example shows how the order of type parameters is important in generic types and functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n#[test]\nfun test_pair() {\n    let pair = new_pair(10u8, true);\n    \n    assert!(pair.first == 10u8, 0);\n    assert!(pair.second == true, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Function Calls in Move\nDESCRIPTION: Illustrates function calls in Move as expressions that return values. Demonstrates both passing arguments to functions and assigning the return value to variables.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/expression.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun helper1(x: u64): u64 {\n    x + 1\n}\n\nfun helper2(x: u64, y: u64): u64 {\n    x + y\n}\n\nfun fun_call() {\n    let x = helper1(1);\n    assert!(x == 2, 0);\n\n    let y = helper2(1, 2);\n    assert!(y == 3, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Transfer Implementation Example\nDESCRIPTION: Demonstrates how to implement object transfer functionality using AdminCap, including initialization and transfer operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::transfer_to_sender {\n\n    /// A struct with `key` is an object. The first field is `id: UID`!\n    public struct AdminCap has key { id: UID }\n\n    /// `init` function is a special function that is called when the module\n    /// is published. It is a good place to create application objects.\n    fun init(ctx: &mut TxContext) {\n        // Create a new `AdminCap` object, in this scope.\n        let admin_cap = AdminCap { id: object::new(ctx) };\n\n        // Transfer the object to the transaction sender.\n        transfer::transfer(admin_cap, ctx.sender());\n\n        // admin_cap is gone! Can't be accessed anymore.\n    }\n\n    /// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient\n    /// becomes the owner of the object, and only they can access it.\n    public fun transfer_admin_cap(cap: AdminCap, recipient: address) {\n        transfer::transfer(cap, recipient);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Ownership and Abilities in Move\nDESCRIPTION: Demonstrates the default linear and ephemeral nature of structs in Move, and how to use the 'copy' and 'drop' abilities to change these properties. It also shows how to manually unpack a struct to destroy it.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct Foo { x: u64 }\n\npublic fun copying() {\n    let foo = Foo { x: 100 };\n    let foo_copy = copy foo; // ERROR! 'copy'-ing requires the 'copy' ability\n    let foo_ref = &foo;\n    let another_copy = *foo_ref // ERROR! dereference requires the 'copy' ability\n}\n\npublic fun destroying_1() {\n    let foo = Foo { x: 100 };\n\n    // error! when the function returns, foo still contains a value.\n    // This destruction requires the 'drop' ability\n}\n\npublic fun destroying_2(f: &mut Foo) {\n    *f = Foo { x: 100 } // error!\n                        // destroying the old value via a write requires the 'drop' ability\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct Foo { x: u64 }\n\npublic fun destroying_1_fixed() {\n    let foo = Foo { x: 100 };\n    let Foo { x: _ } = foo;\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct Foo has copy, drop { x: u64 }\n\npublic fun run() {\n    let foo = Foo { x: 100 };\n    let foo_copy = foo;\n    //             ^ this code copies foo,\n    //             whereas `let x = move foo` would move foo\n\n    let x = foo.x;            // x = 100\n    let x_copy = foo_copy.x;  // x = 100\n\n    // both foo and foo_copy are implicitly discarded when the function returns\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Index Syntax for Matrix Type in Move\nDESCRIPTION: Demonstrates how to create a Matrix type with custom index syntax for borrowing elements. Includes methods for both mutable and immutable access.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule matrix;\n\npublic struct Matrix<T> { v: vector<vector<T>> }\n\n#[syntax(index)]\npublic fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {\n    vector::borrow(vector::borrow(&s.v, i), j)\n}\n\n#[syntax(index)]\npublic fun borrow_mut<T>(s: &mut Matrix<T>, i: u64, j: u64): &mut T {\n    vector::borrow_mut(vector::borrow_mut(&mut s.v, i), j)\n}\n\npublic fun make_matrix<T>(v: vector<vector<T>>):  Matrix<T> {\n    Matrix { v }\n}\n```\n\n----------------------------------------\n\nTITLE: Claiming Publisher object in Move\nDESCRIPTION: Example of claiming a Publisher object in a module using the package::claim function and a One Time Witness.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/publisher.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule example::publisher {\n    use sui::package;\n    use sui::tx_context::TxContext;\n\n    struct PUBLISHER has drop {}\n\n    fun init(witness: PUBLISHER, ctx: &mut TxContext) {\n        package::claim(witness, ctx);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mutating Struct Fields in Move\nDESCRIPTION: Shows how to mutably borrow struct fields to assign new values. It also demonstrates using the dot operator for direct field modification, which requires the 'drop' ability for the field type.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nlet mut foo = Foo { x: 3, y: true };\n*&mut foo.x = 42;     // foo = Foo { x: 42, y: true }\n*&mut foo.y = !foo.y; // foo = Foo { x: 42, y: false }\nlet mut bar = Bar(foo);               // bar = Bar(Foo { x: 42, y: false })\n*&mut bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })\n*&mut bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })\n```\n\nLANGUAGE: move\nCODE:\n```\nlet mut foo = Foo { x: 3, y: true };\nfoo.x = 42;     // foo = Foo { x: 42, y: true }\nfoo.y = !foo.y; // foo = Foo { x: 42, y: false }\nlet mut bar = Bar(foo);         // bar = Bar(Foo { x: 42, y: false })\nbar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })\nbar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })\n```\n\nLANGUAGE: move\nCODE:\n```\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &mut foo;\nfoo_ref.x = foo_ref.x + 1;\n```\n\n----------------------------------------\n\nTITLE: Basic Move Reference Patterns\nDESCRIPTION: Demonstrates the three basic patterns for handling values in Move: moving by value, borrowing immutably, and borrowing mutably.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n/// Moved by value\npublic fun take<T>(value: T) { /* value is moved here! */ abort 0 }\n\n/// For immutable reference\npublic fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort 0 }\n\n/// For mutable reference\npublic fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort 0 }\n```\n\n----------------------------------------\n\nTITLE: Transfer Function Implementations with Different Access Patterns\nDESCRIPTION: Implementation of various transfer functions demonstrating the restrictions and requirements for transferring objects with different abilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/transfer-restrictions.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n/// Imports the `ObjectK` and `ObjectKS` types from `transfer_a` and attempts\n/// to implement different `transfer` functions for them\nmodule book::transfer_b;\n    \n// types are not internal to this module\nuse book::transfer_a::{ObjectK, ObjectKS};\n\n// Fails! ObjectK is not `store`, and ObjectK is not internal to this module\npublic fun transfer_k(k: ObjectK, to: address) {\n    sui::transfer::transfer(k, to);\n}\n\n// Fails! ObjectKS has `store` but the function is not public\npublic fun transfer_ks(ks: ObjectKS, to: address) {\n    sui::transfer::transfer(ks, to);\n}\n\n// Fails! ObjectK is not `store`, `public_transfer` requires `store`\npublic fun public_transfer_k(k: ObjectK) {\n    sui::transfer::public_transfer(k);\n}\n\n// Works! ObjectKS has `store` and the function is public\npublic fun public_transfer_ks(y: ObjectKS, to: address) {\n    sui::transfer::public_transfer(y, to);\n}\n```\n\n----------------------------------------\n\nTITLE: Native Functions in Move Standard Library\nDESCRIPTION: Example of a native function declaration in the Move standard library, where the implementation is provided by the VM.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule std::vector {\n    native public fun length<Element>(v: &vector<Element>): u64;\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Method Call Syntax in Move\nDESCRIPTION: Demonstrates the basic syntax pattern for method calls in Move, showing the expression, identifier, optional type arguments, and function arguments structure.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n<expression> . <identifier> <[type_arguments],*> ( <arguments> )\n```\n\n----------------------------------------\n\nTITLE: Declaring Phantom Type Parameters in Move\nDESCRIPTION: Demonstrates how to declare a struct with a phantom type parameter using the phantom keyword. The example shows a Coin struct where Currency is marked as phantom.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\npublic struct Coin<phantom Currency> has store {\n    value: u64\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[error] Attribute for Error Messages in Move\nDESCRIPTION: This code demonstrates the use of the #[error] attribute to define error constants with custom error messages.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/assert-and-abort.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n#[error(\"The value must be 42\")]\nconst ENOT_42: vector<u8> = b\"ENOT_42\";\n\n#[error(\"The flag must be set to true\")]\nconst EINVALID_FLAG: vector<u8> = b\"EINVALID_FLAG\";\n\nfun validate_data(value: u64, flag: bool) {\n    assert!(value == 42, ENOT_42);\n    assert!(flag == true, EINVALID_FLAG);\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Constants and Or-Patterns in Move\nDESCRIPTION: Shows pattern matching with constants and or-patterns in Move. The function test_constant matches against a constant value, while test_or_pattern demonstrates the use of or-patterns for multiple value matches.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nconst MyConstant: u64 = 10;\nfun test_constant(x: u64): u64 {\n    match (x) {\n        MyConstant => 1,\n        _ => 2,\n    }\n}\ntest_constant(MyConstant); // returns 1\ntest_constant(10); // returns 1\ntest_constant(20); // returns 2\n\nfun test_or_pattern(x: u64): u64 {\n    match (x) {\n        1 | 2 | 3 => 1,\n        4 | 5 | 6 => 2,\n        _ => 3,\n    }\n}\ntest_or_pattern(3); // returns 1\ntest_or_pattern(5); // returns 2\ntest_or_pattern(70); // returns 3\n```\n\n----------------------------------------\n\nTITLE: Basic Abort Usage in Move\nDESCRIPTION: Demonstrates the basic syntax of abort expressions, which can take no arguments or a u64 abort code.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nabort\nabort 42\n```\n\n----------------------------------------\n\nTITLE: Using Foreign Types as Dynamic Fields in Move\nDESCRIPTION: Example showing how different types can be used for both the name and value of dynamic fields, demonstrating the flexibility of attaching various data types to a Character object.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet josh = create_character(string::utf8(b\"Josh\"), ctx);\n\n// String attached via bytestring\ndf::add(&mut josh.id, b\"info\", string::utf8(b\"The greatest warrior\"));\n\n// u64 attached via u32\ndf::add<u32, u64>(&mut josh.id, 10, 10000);\n\n// bool attached via bool\ndf::add<bool, bool>(&mut josh.id, true, false);\n```\n\n----------------------------------------\n\nTITLE: Implementing Mutable References\nDESCRIPTION: Shows how to use mutable references to modify Card data using the use_at_turnstile function that deducts rides.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/references.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nfun use_at_turnstile(card: &mut Card) {\n    assert!(card.rides > 0, EMPTY_CARD);\n    card.rides = card.rides - 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Dynamic Fields in Move\nDESCRIPTION: Example demonstrating how to add, access, and remove dynamic fields from a Character object, attaching two different types of accessories that couldn't normally be stored together in a collection.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\npublic struct Character has key {\n    id: UID,\n    name: String,\n}\n\npublic struct Hat has store {\n    kind: String, \n    color: String,\n}\n\npublic struct Mustache has store {\n    thickness: u8,\n    color: vector<u8>,\n}\n\npublic fun create_character(\n    name: String, ctx: &mut TxContext\n): Character {\n    Character {\n        id: object::new(ctx),\n        name\n    }\n}\n\n// Create Character and attach accessories to it\nlet josh = create_character(string::utf8(b\"Josh\"), ctx);\n\nlet hat = Hat { kind: string::utf8(b\"Baseball\"), color: string::utf8(b\"Black\") };\nlet mustache = Mustache { thickness: 1, color: b\"Black\" };\n\n// Add dynamic fields with bytestring keys\ndf::add(&mut josh.id, b\"hat\", hat);\ndf::add(&mut josh.id, b\"mustache\", mustache);\n\n// Dynamic fields can be accessed and modified\nlet hat_ref = df::borrow_mut<vector<u8>, Hat>(&mut josh.id, b\"hat\");\nhat_ref.kind = string::utf8(b\"Cowboy\");\n\n// Dynamic fields can be removed and moved elsewhere\nlet _hat = df::remove<vector<u8>, Hat>(&mut josh.id, b\"hat\");\n\n// Dynamic fields can be removed when the parent is being destroyed\nobject::delete(josh.id);\n```\n\n----------------------------------------\n\nTITLE: Using continue to Skip Loop Iterations in Move\nDESCRIPTION: This snippet shows how to use the continue statement to skip the rest of the current iteration and start the next one in a loop.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = 0;\nloop {\n    x = x + 1;\n    if (x % 2 != 0) continue;\n    // Do something with even numbers\n    if (x > 10) break;\n};\n```\n\n----------------------------------------\n\nTITLE: Passing Variables by Value in Move (Move Semantics)\nDESCRIPTION: This snippet illustrates how passing a variable to another function transfers ownership to that function. When 'a' is passed to take_ownership, it's no longer valid in the test_owner function afterward, demonstrating move semantics.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/ownership-and-scope.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::ownership;\n\npublic fun owner(): u8 {\n    let a = 10;\n    a\n} // a is returned\n\npublic fun take_ownership(v: u8) {\n    // v is owned by `take_ownership`\n} // v is dropped here\n\n#[test]\nfun test_owner() {\n    let a = owner();\n    take_ownership(a);\n    // a is not valid here\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing and Borrowing Struct Fields in Move\nDESCRIPTION: Demonstrates how to access struct fields using the dot operator, and how to borrow structs and their fields using reference operators. Includes examples for both named and positional structs.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\npublic struct Foo { x: u64, y: bool }\nlet foo = Foo { x: 3, y: true };\nlet x = foo.x;  // x == 3\nlet y = foo.y;  // y == true\n\npublic struct PosFoo(u64, bool)\nlet pos_foo = PosFoo(3, true);\nlet x = pos_foo.0;  // x == 3\nlet y = pos_foo.1;  // y == true\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref: &Foo = &foo;\nlet y: bool = foo_ref.y;         // reading a field via a reference to the struct\nlet x_ref: &u64 = &foo.x;        // borrowing a field by extending a reference to the struct\n\nlet x_ref_mut: &mut u64 = &mut foo.x;\n*x_ref_mut = 42;            // modifying a field via a mutable reference\n\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar(foo);\n\nlet x_ref = &bar.0.x;\n\nlet foo = Foo { x: 3, y: true };\nlet foo_ref = &foo;\nlet x_ref = &foo_ref.x;\n// this has the same effect as let x_ref = &foo.x\n```\n\n----------------------------------------\n\nTITLE: Expected Failure Test Examples in Move\nDESCRIPTION: Demonstrates various ways to use the #[expected_failure] annotation with test functions, including simple aborts and error conditions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n#[test]\n#[expected_failure]\npublic fun this_test_will_abort_and_pass() { abort 1 }\n\n#[test]\n#[expected_failure]\npublic fun test_will_error_and_pass() { 1/0; }\n\n#[test] // Will pass since test fails with the expected abort code constant.\n#[expected_failure(abort_code = ENotFound)] // ENotFound is a constant defined in the module\npublic fun test_will_error_and_pass_abort_code() { abort ENotFound }\n\n#[test] // Will fail since test fails with a different error than expected.\n#[expected_failure(abort_code = my_module::ENotFound)]\npublic fun test_will_error_and_fail() { 1/0; }\n\n#[test, expected_failure] // Can have multiple in one attribute. This test will pass.\npublic fun this_other_test_will_abort_and_pass() { abort 1 }\n```\n\n----------------------------------------\n\nTITLE: Conditional Key Ability Example in Move\nDESCRIPTION: Demonstrates how the key ability works with generic types and shows valid and invalid cases of using types in global storage operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\npublic struct NoAbilities {}\npublic struct MyData<T> has key { f: T }\n\nfun valid(addr: address) acquires MyData {\n    // Valid, 'MyData<u64>' has 'key'\n    transfer(addr, MyData<u64> { f: 0 });\n}\n\nfun invalid(addr: address) {\n   // Invalid, 'MyData<NoAbilities>' does not have 'key'\n   transfer(addr, MyData<NoAbilities> { f: NoAbilities {} })\n   // Invalid, 'MyData<NoAbilities>' does not have 'key'\n   borrow<NoAbilities>(addr);\n   // Invalid, 'MyData<NoAbilities>' does not have 'key'\n   borrow_mut<NoAbilities>(addr);\n}\n\n// Mock storage operation\nnative public fun transfer<T: key>(addr: address, value: T);\n```\n\n----------------------------------------\n\nTITLE: Basic Move Package Configuration\nDESCRIPTION: Basic Move.toml configuration showing package metadata, dependencies and address configurations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/manifest.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"my_project\"\nversion = \"0.0.0\"\nedition = \"2024\"\n\n[dependencies]\nExample = { git = \"https://github.com/example/example.git\", subdir = \"path/to/package\", rev = \"framework/testnet\" }\n\n[addresses]\nstd =  \"0x1\"\nalice = \"0xA11CE\"\n\n[dev-addresses]\nalice = \"0xB0B\"\n```\n\n----------------------------------------\n\nTITLE: Explaining Move and Copy Behavior in Non-Borrowed Method Calls\nDESCRIPTION: This example illustrates how values might be moved or copied if not borrowed in method calls. It shows the difference in behavior for types with and without the copy ability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct X() has copy, drop;\npublic fun by_val(_: X) {}\npublic fun by_ref(_: &X) {}\npublic fun by_mut(_: &mut X) {}\n\npublic struct Y has drop { x: X }\npublic fun drop_y(y: Y) { y }\n\nfun example(y: Y) {\n    y.x.by_val(); // copies `y.x` since `by_val` is by-value and `X` has `copy`\n    y.drop_y(); // moves `y` since `drop_y` is by-value and `Y` does _not_ have `copy`\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Capability Implementation in Move\nDESCRIPTION: Demonstrates implementing a basic capability pattern for managing user creation with an admin capability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/capability.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/capability.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Conditional Drop Ability Example in Move\nDESCRIPTION: Shows how the drop ability is conditionally applied to generic types and demonstrates valid and invalid cases of dropping values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\npublic struct NoAbilities {}\npublic struct S has copy, drop { f: bool }\npublic struct Cup<T> has copy, drop, store { item: T }\n\nfun unused() {\n    Cup<bool> { item: true }; // Valid, 'Cup<bool>' has 'drop'\n    Cup<S> { item: S { f: false }}; // Valid, 'Cup<S>' has 'drop'\n}\n\nfun left_in_local(c_account: Cup<signer>): u64 {\n    let c_b = Cup<bool> { item: true };\n    let c_s = Cup<S> { item: S { f: false }};\n    // Valid return: 'c_account', 'c_b', and 'c_s' have values\n    // but 'Cup<signer>', 'Cup<bool>', and 'Cup<S>' have 'drop'\n    0\n}\n\nfun invalid_unused() {\n    // Invalid, Cannot ignore 'Cup<NoAbilities>' because it does not have 'drop'.\n    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'\n    // because 'NoAbilities' does not have 'drop'\n    Cup<NoAbilities> { item: NoAbilities {} };\n}\n\nfun invalid_left_in_local(): u64 {\n    let n = Cup<NoAbilities> { item: NoAbilities {} };\n    // Invalid return: 'c_n' has a value\n    // and 'Cup<NoAbilities>' does not have 'drop'\n    0\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Struct Fields in Move\nDESCRIPTION: Demonstrates how to access fields of a struct using the dot notation within the module that defines the struct.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet name = artist.name;\n```\n\n----------------------------------------\n\nTITLE: Creating References to Struct Fields in Move\nDESCRIPTION: Demonstrates creating both direct and extended references to struct fields in Move. Shows how references can be created to access struct fields through existing references.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/references.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nlet s = S { f: 10 };\nlet f_ref1: &u64 = &s.f; // works\nlet s_ref: &S = &s;\nlet f_ref2: &u64 = &s_ref.f // also works\n```\n\n----------------------------------------\n\nTITLE: Defining a Standard Move Package Manifest\nDESCRIPTION: Shows a more comprehensive Move.toml file with dependencies, named addresses, and dev settings.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"AName\"\nlicense = \"Apache 2.0\"\n\n[addresses]\naddress_to_be_filled_in = \"_\"\nspecified_address = \"0xB0B\"\n\n[dependencies]\n# Local dependency\nLocalDep = { local = \"projects/move-awesomeness\", addr_subst = { \"std\" = \"0x1\" } }\n# Git dependency\nMoveStdlib = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/move-stdlib\", rev = \"framework/mainnet\" }\n\n[dev-addresses] # For use when developing this module\naddress_to_be_filled_in = \"0x101010101\"\n```\n\n----------------------------------------\n\nTITLE: Using '..' Wildcard in Move Pattern Matching\nDESCRIPTION: This snippet demonstrates the usage of the '..' wildcard in constructor patterns for pattern matching. It shows examples of using '..' with positional and named arguments, and explains the restrictions on its placement within the pattern.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_16\n\nLANGUAGE: move\nCODE:\n```\npublic struct MyStruct(u64, u64, u64, u64) has drop;\n\npublic struct MyStruct2 {\n    x: u64,\n    y: u64,\n    z: u64,\n    w: u64,\n}\n\nfun wild_match(x: MyStruct) {\n    match (x) {\n        MyStruct(.., 1) => 1,\n        // OK! The `..` pattern can be used at the beginning of the constructor pattern\n        MyStruct(1, ..) => 2,\n        // OK! The `..` pattern can be used at the end of the constructor pattern\n        MyStruct(1, .., 1) => 3,\n        // OK! The `..` pattern can be used at the middle of the constructor pattern\n        MyStruct(1, .., 1, 1) => 4,\n        MyStruct(..) => 5,\n    }\n}\n\nfun wild_match2(x: MyStruct2) {\n    match (x) {\n        MyStruct2 { x: 1, .. } => 1,\n        MyStruct2 { x: 1, w: 2 .. } => 2,\n        MyStruct2 { .. } => 3,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Enum in Move\nDESCRIPTION: This snippet demonstrates how to define a simple enum 'Action' with different variant types including no fields, named fields, and positional fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\npublic enum Action {\n    Stop,\n    Pause { duration: u32 },\n    MoveTo { x: u64, y: u64 },\n    Jump(u64),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Method Aliases in Move 2024\nDESCRIPTION: Shows how to define method aliases for types in Move 2024, both locally for foreign types and publicly for types defined in the same module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\n// my_module.move\n// Local: type is foreign to the module\nuse fun my_custom_function as vector.do_magic;\n\n// sui-framework/kiosk/kiosk.move\n// Exported: type is defined in the same module\npublic use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;\n```\n\n----------------------------------------\n\nTITLE: Implementing Common Wrapper Type Accessors in Move\nDESCRIPTION: Shows how to implement common accessor methods for a wrapper type, including inner(), inner_mut(), and into_inner() methods. These methods provide access to the underlying wrapped type when needed.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/wrapper-type-pattern.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/wrapper-type-pattern.move:common}}\n```\n\n----------------------------------------\n\nTITLE: Package Manifest Named Address\nDESCRIPTION: Shows the default named address configuration in the Move.toml manifest file for the 'hello_world' package.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[addresses]\nhello_world = \"0x0\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Module in Move\nDESCRIPTION: This snippet demonstrates how to define a module in Move, including a public struct and a public function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// File: sources/module_one.move\nmodule package::module_one {\n    use std::string::String;\n\n    struct Character has store, drop {\n        name: String,\n        level: u64,\n    }\n\n    public fun new(name: String, level: u64): Character {\n        Character { name, level }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling UTF-8 Validation Safely in Move\nDESCRIPTION: Shows how to safely create UTF-8 strings with validation using the try_utf8 method, which returns an Option<String> rather than aborting on invalid input.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/string.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nuse std::string;\nuse std::option::{Self, Option};\n\n// This might not be valid UTF-8, so we use try_utf8\nlet maybe_valid_bytes = get_bytes_from_somewhere();\nlet maybe_string: Option<String> = string::try_utf8(maybe_valid_bytes);\n\nif (option::is_some(&maybe_string)) {\n    // do something with the string\n    let valid_string = option::extract(&mut maybe_string);\n    // ...\n} else {\n    // handle the error case\n}\n```\n\n----------------------------------------\n\nTITLE: Updating a Generic User Type in Move\nDESCRIPTION: Shows how to update the metadata of a User instance. This demonstrates that operations on generic types can be defined independently of the concrete type parameter.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n/// Update user metadata\npublic fun update_metadata<T: copy + drop + store, U: copy + drop + store>(\n    user: &mut User<T>,\n    metadata_converter: fun(T): U\n): User<U> {\n    let User { name, age, metadata } = *user;\n    \n    User {\n        name,\n        age,\n        metadata: metadata_converter(metadata)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Examples in Move\nDESCRIPTION: Illustrates various pattern types including literals, constants, variables, wildcards, constructors, at-patterns, or-patterns, and multi-arity wildcards.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n// literal pattern\n1\n\n// constant pattern\nMyConstant\n\n// variable pattern\nx\n\n// wildcard pattern\n_\n\n// constructor pattern that matches `MyEnum::Variant` with the fields `1` and `true`\nMyEnum::Variant(1, true)\n\n// constructor pattern that matches `MyEnum::Variant` with the fields `1` and binds the second field's value to `x`\nMyEnum::Variant(1, x)\n\n// multi-arity wildcard pattern that matches multiple fields within the `MyEnum::Variant` variant\nMyEnum::Variant(..)\n\n// constructor pattern that matches the `x` field of `MyStruct` and binds the `y` field to `other_variable`\nMyStruct { x, y: other_variable }\n\n// at-pattern that matches `MyEnum::Variant` and binds the entire value to `x`\nx @ MyEnum::Variant(..)\n\n// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant`\nMyEnum::Variant(..) | MyEnum::OtherVariant(..)\n\n// same as the above or-pattern, but with explicit wildcards\nMyEnum::Variant(_, _) | MyEnum::OtherVariant(_, _)\n\n// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant` and binds the u64 field to `x`\nMyEnum::Variant(x, _) | MyEnum::OtherVariant(_, x)\n\n// constructor pattern that matches `OtherEnum::V` and if the inner `MyEnum` is `MyEnum::Variant`\nOtherEnum::V(MyEnum::Variant(..))\n```\n\n----------------------------------------\n\nTITLE: Defining a Move Module with Unit Tests\nDESCRIPTION: Defines a Move module named 'my_module' with a struct, constants, functions, and unit tests including expected failures.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\n// filename: sources/my_module.move\nmodule test_example::my_module;\n\npublic struct Wrapper(u64)\n\nconst ECoinIsZero: u64 = 0;\n\npublic fun make_sure_non_zero_coin(coin: Wrapper): Wrapper {\n    assert!(coin.0 > 0, ECoinIsZero);\n    coin\n}\n\n#[test]\nfun make_sure_non_zero_coin_passes() {\n    let coin = Wrapper(1);\n    let Wrapper(_) = make_sure_non_zero_coin(coin);\n}\n\n#[test]\n// Or #[expected_failure] if we don't care about the abort code\n#[expected_failure(abort_code = ECoinIsZero)]\nfun make_sure_zero_coin_fails() {\n    let coin = Wrapper(0);\n    let Wrapper(_) = make_sure_non_zero_coin(coin);\n}\n\n#[test_only] // test only helper function\nfun make_coin_zero(coin: &mut Wrapper) {\n    coin.0 = 0;\n}\n\n#[test]\n#[expected_failure(abort_code = ECoinIsZero)]\nfun make_sure_zero_coin_fails2() {\n    let mut coin = Wrapper(10);\n    coin.make_coin_zero();\n    let Wrapper(_) = make_sure_non_zero_coin(coin);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the Option Type in Move's Standard Library\nDESCRIPTION: The core implementation of Option in Move's standard library, showing how it's defined as a struct containing a vector that can have a length of 0 or 1, representing the absence or presence of a value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/option.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// File: move-stdlib/source/option.move\n/// Abstraction of a value that may or may not be present.\nstruct Option<Element> has copy, drop, store {\n    vec: vector<Element>\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Address Literals in Move\nDESCRIPTION: Demonstrates how to define address literals in Move using the @ prefix followed by a hexadecimal number or an identifier that refers to a named address in the Move.toml file.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/address.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nlet addr1 = @0x1;               // shorthand for 0x00000000000000000000000000000001\nlet addr2 = @0x42;              // shorthand for 0x00000000000000000000000000000042\nlet addr3 = @0x123456789;        // shorthand for 0x00000000000000000000000000123456789\nlet named_addr = @std;          // named address, resolves as per Move.toml\nlet named_addr2 = @sui;         // named address, resolves as per Move.toml\n```\n\n----------------------------------------\n\nTITLE: Dynamic Object Field Addition Method Signature in Move\nDESCRIPTION: Shows the method signature for adding dynamic object fields, demonstrating the key+store constraint on Value type. This method adds a field to an object at a specified name.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-object-fields.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\npublic fun add<Name: copy + drop + store, Value: key + store>(\n    object: &mut UID,\n    name: Name,\n    value: Value,\n) { /* implementation omitted */ }\n```\n\n----------------------------------------\n\nTITLE: Example Transaction Structure in Move\nDESCRIPTION: Demonstrates a basic transaction structure with multiple commands including coin splitting, market purchase, and object transfer. Shows how commands can be chained together and use results from previous operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/what-is-a-transaction.md#2025-04-22_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nInputs:\n- sender = 0xa11ce\n\nCommands:\n- payment = SplitCoins(Gas, [ 1000 ])\n- item = MoveCall(0xAAA::market::purchase, [ payment ])\n- TransferObjects(item, sender)\n```\n\n----------------------------------------\n\nTITLE: Module Using One Time Witness in Move\nDESCRIPTION: Example implementation showing how to use One Time Witness in a module initialization context to ensure single instantiation of a TreasuryCap.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/one-time-witness.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::coin_otw {\n\n    /// The OTW for the `book::coin_otw` module.\n    struct COIN_OTW has drop {}\n\n    /// Receive the instance of `COIN_OTW` as the first argument.\n    fun init(otw: COIN_OTW, ctx: &mut TxContext) {\n        let treasury_cap = book::simple_coin::new(COIN_OTW {}, ctx);\n        transfer::public_transfer(treasury_cap, ctx.sender())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Address Variables in Move\nDESCRIPTION: This snippet demonstrates various ways to initialize address variables in Move, including numerical and named addresses. It shows different address formats and the use of the '@' prefix in expression contexts.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/address.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// shorthand for\n// 0x0000000000000000000000000000000000000000000000000000000000000001\nlet a1: address = @0x1;\n// shorthand for\n// 0x0000000000000000000000000000000000000000000000000000000000000042\nlet a2: address = @0x42;\n// shorthand for\n// 0x00000000000000000000000000000000000000000000000000000000DEADBEEF\nlet a3: address = @0xDEADBEEF;\n// shorthand for\n// 0x000000000000000000000000000000000000000000000000000000000000000A\nlet a4: address = @0x0000000000000000000000000000000A;\n// Assigns `a5` the value of the named address `std`\nlet a5: address = @std;\n// Any valid numerical value can be used as an address\nlet a6: address = @66;\nlet a7: address = @42_000;\n```\n\n----------------------------------------\n\nTITLE: Nested Import Example\nDESCRIPTION: Example of using nested imports to bring multiple names into scope.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nuse std::{\n    vector::{Self as vec, push_back},\n    string::{String, Self as str}\n};\n\nfun example(s: &mut String) {\n    let mut v = vec::empty();\n    push_back(&mut v, 0);\n    push_back(&mut v, 10);\n    str::append_utf8(s, v);\n}\n```\n\n----------------------------------------\n\nTITLE: Incrementing Specific Enum Variants using Pattern Matching in Move\nDESCRIPTION: This snippet shows how to create functions that increment values within specific enum variants using pattern matching. It demonstrates working with mutable references to enum fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum SimpleEnum {\n    Variant1(u64),\n    Variant2(u64),\n}\n\npublic fun incr_enum_variant1(simple_enum: &mut SimpleEnum) {\n    match (simple_enum) {\n        SimpleEnum::Variant1(mut value) => *value += 1,\n        _ => (),\n    }\n}\n\npublic fun incr_enum_variant2(simple_enum: &mut SimpleEnum) {\n    match (simple_enum) {\n        SimpleEnum::Variant2(mut value) => *value += 1,\n        _ => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cup Module Implementation\nDESCRIPTION: Defines a generic Cup type with associated functions that can be called as methods.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule a::cup;\n\npublic struct Cup<T>(T) has copy, drop, store;\n\npublic fun cup_borrow<T>(c: &Cup<T>): &T {\n    &c.0\n}\n\npublic fun cup_value<T>(c: Cup<T>): T {\n    let Cup(t) = c;\n    t\n}\n\npublic fun cup_swap<T: drop>(c: &mut Cup<T>, t: T) {\n    c.0 = t;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Vector Literals in Move\nDESCRIPTION: Examples of different ways to declare vector literals in Move, including type-inferred and explicitly typed vectors.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/vector.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n(vector[]: vector<bool>);\n(vector[0u8, 1u8, 2u8]: vector<u8>);\n(vector<u128>[]: vector<u128>);\n(vector<address>[@0x42, @0x100]: vector<address>);\n```\n\n----------------------------------------\n\nTITLE: Using Break with Values in Loop Expression\nDESCRIPTION: This function demonstrates how to use break with values in a loop expression to find the position of a target value in a vector. It returns an Option<u64> immediately upon finding the value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/loops.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nfun find_position(values: &vector<u64>, target_value: u64): Option<u64> {\n    let size = vector::length(values);\n    let mut i = 0;\n\n    loop {\n        if (vector::borrow(values, i) == &target_value) {\n            break option::some(i)\n        } else if (i >= size) {\n            break option::none()\n        };\n        i = i + 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Sharing Config Object\nDESCRIPTION: Function that creates a new Config object and shares it using transfer::share_object, making it publicly available as a mutable reference.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\npublic fun create_and_share(message: String, ctx: &mut TxContext) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Share the object so it becomes shared.\n    transfer::share_object(config);\n}\n```\n\n----------------------------------------\n\nTITLE: Type Parameter Constraints Syntax\nDESCRIPTION: Demonstrates the syntax for declaring ability constraints on type parameters.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_13\n\nLANGUAGE: move\nCODE:\n```\nT: copy\nT: copy + drop\nT: copy + drop + store + key\n```\n\n----------------------------------------\n\nTITLE: Package-Scoped Public Functions in Move\nDESCRIPTION: Shows the usage of public(package) visibility modifier for package-scoped function access.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m {\n    public(package) fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule a::n {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // valid, also in `a`\n    }\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        b::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' can only be called from a module in `a`\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring Values in Move Variable Declarations\nDESCRIPTION: This snippet shows how to ignore certain values when declaring multiple variables, using underscores to avoid unused variable warnings.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nfun three(): (u64, u64, u64) {\n    (0, 1, 2)\n}\n\nlet (x1, _, z1) = three();\nlet (x2, _y, z2) = three();\nassert!(x1 + z1 == x2 + z2, 42);\n```\n\n----------------------------------------\n\nTITLE: Defining Metro Pass Header and Constants\nDESCRIPTION: Initial layout of the metro pass module defining the Card type and constants including number of uses and error codes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/references.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::metro_pass;\nconst USES: u64 = 10;\nconst EMPTY_CARD: u64 = 1;\n\nstruct Card has drop {\n    rides: u64\n}\n\nfun new(): Card {\n    Card { rides: USES }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Enums with Abilities in Move\nDESCRIPTION: This example shows how to define enums with abilities, demonstrating both pre-named and post-named ability declarations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum Foo has copy, drop {\n    VariantWithNoFields,\n}\n\npublic enum PreNamedAbilities has copy, drop { Variant }\npublic enum PostNamedAbilities { Variant } has copy, drop;\npublic enum PostNamedAbilitiesInvalid { Variant } has copy, drop\n//                                                              ^ ERROR! missing semicolon\n\npublic enum NamedInvalidAbilities has copy { Variant } has drop;\n//                                                     ^ ERROR! duplicate ability declaration\n```\n\n----------------------------------------\n\nTITLE: Nested Or-Patterns in Constructor Matching in Move\nDESCRIPTION: Shows how to use nested or-patterns within constructor patterns in Move. The function f demonstrates matching on specific enum variants with multiple possible values for a field.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\nfun f(x: MyEnum) {\n    match (x) {\n        MyEnum::Variant(1 | 2 | 10, true) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        MyEnum::Variant(..) => 3,\n        MyEnum::OtherVariant(..) => 4,\n}\nf(MyEnum::Variant(1, true)); // returns 1\nf(MyEnum::Variant(2, true)); // returns 1\nf(MyEnum::Variant(10, true)); // returns 1\nf(MyEnum::Variant(10, false)); // returns 3\n```\n\n----------------------------------------\n\nTITLE: Using Method Syntax for Struct Functions in Move 2024\nDESCRIPTION: Illustrates the new method syntax in Move 2024, where functions with a struct as the first argument can be called using dot notation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\npublic fun count(c: &Counter): u64 { /* ... */ }\n\nfun use_counter() {\n    // move 2020\n    let count = counter::count(&c);\n\n    // move 2024\n    let count = c.count();\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Variables through References in Move\nDESCRIPTION: This snippet shows how to modify variables through mutable references in Move, including conditional modifications and vector operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = 0;\nlet r = &mut x;\n*r = 1;\nassert!(x == 1, 42);\n\nlet mut v = vector[];\nvector::push_back(&mut v, 100);\nassert!(*vector::borrow(&v, 0) == 100, 42);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Drop Ability Usage in Move\nDESCRIPTION: This code snippet demonstrates how the 'drop' ability works in Move. It shows the definition of structs with and without the drop ability, and how they can be used in functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/drop-ability.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/drop-ability.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Immutable Constants Example in Move\nDESCRIPTION: Demonstrates the immutable nature of constants in Move, showing that they cannot be reassigned after definition.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/constants.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule book::immutable_constants;\n\nconst ITEM_PRICE: u64 = 100;\n\n// emits an error\nfun change_price() {\n    ITEM_PRICE = 200;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating UTF-8 Strings in Move\nDESCRIPTION: Demonstrates different methods for creating UTF-8 String instances using the string::utf8 method and the to_string() convenience function on byte vectors.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/string.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nuse std::string;\n\n// using the string module directly\nlet hello_std = string::utf8(b\"Hello, World!\");\n\n// using to_string() defined on vector<u8>\nlet hello_ext = b\"Hello, World!\".to_string();\n```\n\n----------------------------------------\n\nTITLE: Aliasing External Module Functions as Struct Methods in Move\nDESCRIPTION: This example shows how to associate a function from an external module with a struct in the current module. It demonstrates using the bcs::to_bytes function as a method on the Hero struct for serialization.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct-methods.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule hero::hero {\n    use std::string::String;\n    use std::vector;\n\n    /// Represents a hero with name and health\n    public struct Hero has store, drop {\n        name: String,\n        health: u64,\n    }\n\n    /// Create a new hero with the given name and default health\n    public fun new(name: String): Hero {\n        Hero { name, health: 100 }\n    }\n\n    // Associate external function bcs::to_bytes with our Hero struct\n    use fun bcs::to_bytes as Hero.to_bytes;\n\n    #[test]\n    public fun test_hero_serialization() {\n        let hero = new(std::string::utf8(b\"Sui\"));\n        \n        // Using the aliased external method\n        let bytes = hero.to_bytes();\n        assert!(vector::length(&bytes) > 0, 0);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Destruction in Move\nDESCRIPTION: Examples showing how to properly destroy vectors with and without the drop ability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/vector.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun destroy_any_vector<T>(vec: vector<T>) {\n    vector::destroy_empty(vec) // deleting this line will cause a compiler error\n}\n\nfun destroy_droppable_vector<T: drop>(vec: vector<T>) {\n    // valid!\n    // nothing needs to be done explicitly to destroy the vector\n}\n```\n\n----------------------------------------\n\nTITLE: Option BCS Decoding\nDESCRIPTION: Shows how to decode Option types using BCS, treating them as vectors of 0 or 1 element.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/bcs.move:decode_option}}\n```\n\n----------------------------------------\n\nTITLE: Block-Level Scoping in Move\nDESCRIPTION: This example shows how blocks create sub-scopes within a function. Variables defined within blocks are owned by those blocks and are dropped when the block ends, making them inaccessible to outer scopes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/ownership-and-scope.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule book::ownership;\n\npublic fun owner() {\n    let a = 1; // a is owned by the `owner` function's scope\n    {\n        let b = 2; // the block that declares b owns it\n        {\n            let c = 3; // the block that declares c owns it\n        }; // c is dropped here\n    }; // b is dropped here\n    // a = b; // error: b is not valid here\n    // a = c; // error: c is not valid here\n} // a is dropped here\n```\n\n----------------------------------------\n\nTITLE: Implementing a while Loop in Move\nDESCRIPTION: This snippet shows how to use a while loop in Move to repeatedly execute a block of code while a condition is true.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = 0;\nwhile (x < 10) {\n    x = x + 1;\n};\n```\n\n----------------------------------------\n\nTITLE: Vector Iteration Macro Usage Examples in Move\nDESCRIPTION: Demonstrates practical uses of the vector iteration macros. Examples include printing elements, finding maximums, computing sums, and transforming vector contents using both immutable and mutable approaches.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_15\n\nLANGUAGE: move\nCODE:\n```\nfun imm_examples(v: &vector<u64>) {\n    // print all elements\n    for_imm!(v, |x| std::debug::print(x));\n\n    // sum all elements\n    let mut sum = 0;\n    for_imm!(v, |x| sum = sum + x);\n\n    // find the max element\n    let mut max = 0;\n    for_imm!(v, |x| if (x > max) max = x);\n}\n\nfun mut_examples(v: &mut vector<u64>) {\n    // increment each element\n    for_mut!(v, |x| *x = *x + 1);\n\n    // set each element to the previous value, and the first to last value\n    let mut prev = v[v.length() - 1];\n    for_mut!(v, |x| {\n        let tmp = *x;\n        *x = prev;\n        prev = tmp;\n    });\n\n    // set the max element to 0\n    let mut max = &mut 0;\n    for_mut!(v, |x| if (*x > *max) max = x);\n    *max = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Flexible Index Syntax with Default Values in Move\nDESCRIPTION: Demonstrates how to implement index syntax that takes additional arguments, such as providing a default value for out-of-bounds access in a table-like structure.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n#[syntax(index)]\npublic fun borrow_or_set<Key: copy, Value: drop>(\n    input: &mut MTable<Key, Value>,\n    key: Key,\n    default: Value\n): &mut Value {\n    if (contains(input, key)) {\n        borrow(input, key)\n    } else {\n        insert(input, key, default);\n        borrow(input, key)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Index Syntax for Matrix in Move\nDESCRIPTION: Shows how to use the custom index syntax defined for the Matrix type. Demonstrates accessing and modifying matrix elements using index notation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nlet mut m = matrix::make_matrix(vector[\n    vector[1, 0, 0],\n    vector[0, 1, 0],\n    vector[0, 0, 1],\n]);\n\nlet mut i = 0;\nwhile (i < 3) {\n    let mut j = 0;\n    while (j < 3) {\n        if (i == j) {\n            assert!(m[i, j] == 1, 1);\n        } else {\n            assert!(m[i, j] == 0, 0);\n        };\n        *(&mut m[i,j]) = 2;\n        j = j + 1;\n    };\n    i = i + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Vector Iteration Macros in Move\nDESCRIPTION: Two macros for iterating over vector elements. 'for_imm' allows immutable iteration with a lambda function applied to each element, while 'for_mut' allows mutable iteration with a function that can modify each element.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_14\n\nLANGUAGE: move\nCODE:\n```\nmacro fun for_imm<$T>($v: &vector<$T>, $f: |&$T|) {\n    let v = $v;\n    let n = v.length();\n    let mut i = 0;\n    while (i < n) {\n        $f(&v[i]);\n        i = i + 1;\n    }\n}\n\nmacro fun for_mut<$T>($v: &mut vector<$T>, $f: |&mut $T|) {\n    let v = $v;\n    let n = v.length();\n    let mut i = 0;\n    while (i < n) {\n        $f(&mut v[i]);\n        i = i + 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Expression Constants\nDESCRIPTION: Examples of constants using complex expressions that are evaluated at compile time.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/constants.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nconst RULE: bool = true && false;\nconst CAP: u64 = 10 * 100 + 1;\nconst SHIFTY: u8 = {\n    (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)\n};\nconst HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;\nconst REM: u256 =\n    57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;\nconst EQUAL: bool = 1 == 1;\n```\n\n----------------------------------------\n\nTITLE: Control Flow in Move Macros\nDESCRIPTION: Illustrates how control flow constructs like 'return' are scoped within macros and lambda functions. The example shows a macro 'maybe_div' that uses a return statement.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\nmacro fun maybe_div($x: u64, $y: u64): u64 {\n    let x = $x;\n    let y = $y;\n    if (y == 0) return 0;\n    x / y\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nlet result: vector<u64> = vector[maybe_div!(10, 0)];\n```\n\nLANGUAGE: move\nCODE:\n```\nlet result: vector<u64> = vector['a: {\n    let x = { 10 };\n    let y = { 0 };\n    if (y == 0) return 'a 0;\n    x / y\n}];\n```\n\n----------------------------------------\n\nTITLE: Move Boolean Logical Operations\nDESCRIPTION: Examples of logical operations available for bool type in Move, including AND (&&), OR (||), and NOT (!). These operations include short-circuiting behavior for && and ||.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/bool.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\np && q     // equivalent to: if (p) q else false\n```\n\nLANGUAGE: move\nCODE:\n```\np || q     // equivalent to: if (p) true else q\n```\n\nLANGUAGE: move\nCODE:\n```\n!p         // equivalent to: if (p) false else true\n```\n\n----------------------------------------\n\nTITLE: Vector Mapping Macro Implementation\nDESCRIPTION: Example of a macro function that maps a vector to another vector using a lambda function. Demonstrates type parameters and lambda usage.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmacro fun map<$T, $U>($v: vector<$T>, $f: |$T| -> $U): vector<$U> {\n    let mut v = $v;\n    v.reverse();\n    let mut i = 0;\n    let mut result = vector[];\n    while (!v.is_empty()) {\n        result.push_back($f(v.pop_back()));\n        i = i + 1;\n    };\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Copy Ability Constraint Examples\nDESCRIPTION: Examples showing constraint checking with the copy ability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_16\n\nLANGUAGE: move\nCODE:\n```\nfun unsafe_double<T>(x: T) {\n    (copy x, x)\n    // ERROR! T does not have 'copy'\n}\n\nfun double<T: copy>(x: T) {\n    (copy x, x) // valid, T has 'copy'\n}\n\npublic struct NoAbilities {}\n\nfun foo(): (NoAbilities, NoAbilities) {\n    let r = NoAbilities {};\n    double<NoAbilities>(r)\n    //     ^ ERROR! NoAbilities does not have 'copy'\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Early Return in a Move Function\nDESCRIPTION: This example demonstrates how to use the return statement to exit a function early when a certain condition is met.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nfun example(x: u64): u64 {\n    if (x == 0) {\n        return 42\n    };\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Copy and Drop Abilities\nDESCRIPTION: Demonstrates implementing both Copy and Drop abilities together on a custom type, which is a common pattern for better resource management.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/copy-ability.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nstruct CopyDrop has copy, drop {\n    value: u64\n}\n```\n\n----------------------------------------\n\nTITLE: Public Transfer Functions Implementation in Move\nDESCRIPTION: Definition of public transfer functions in the sui-framework that enable transfer, sharing, and freezing of objects with 'key + store' abilities across modules.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/transfer-restrictions.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// File: sui-framework/sources/transfer.move\n/// Public version of the `transfer` function.\npublic fun public_transfer<T: key + store>(object: T, to: address) {}\n\n/// Public version of the `share_object` function.\npublic fun public_share_object<T: key + store>(object: T) {}\n\n/// Public version of the `freeze_object` function.\npublic fun public_freeze_object<T: key + store>(object: T) {}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Move Equality Comparisons\nDESCRIPTION: This example demonstrates how to optimize equality comparisons in Move by using references instead of copying large data structures.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nlet v1: vector<u8> = function_that_returns_vector();\nlet v2: vector<u8> = function_that_returns_vector();\nassert!(&v1 == &v2, 42);\n//      ^      ^\nuse_two_vectors(v1, v2);\n\nlet s1: Foo = function_that_returns_large_struct();\nlet s2: Foo = function_that_returns_large_struct();\nassert!(&s1 == &s2, 42);\n//      ^      ^\nuse_two_foos(s1, s2);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Automatic Borrowing Through Field Access in Move\nDESCRIPTION: This snippet shows how automatic borrowing works through field access in Move. It illustrates borrowing of both immutable and mutable references for struct fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct X() has copy, drop;\npublic fun by_val(_: X) {}\npublic fun by_ref(_: &X) {}\npublic fun by_mut(_: &mut X) {}\n\npublic struct Y has drop { x: X }\n\nfun example(mut y: Y) {\n    y.x.by_ref(); // resolves to a::m::by_ref(&y.x)\n    y.x.by_mut(); // resolves to a::m::by_mut(&mut y.x)\n}\n```\n\n----------------------------------------\n\nTITLE: Move Boolean Control Flow Usage\nDESCRIPTION: Examples of how boolean values are used in Move's control flow constructs including if statements, while loops, and assertions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/bool.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nif (bool) { ... }\nwhile (bool) { .. }\nassert!(bool, u64)\n```\n\n----------------------------------------\n\nTITLE: Nested Struct Field References in Move\nDESCRIPTION: Shows how to create references to nested struct fields within the same module using the dot operator for field access.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/references.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\npublic struct A { b: B }\npublic struct B { c : u64 }\nfun f(a: &A): &u64 {\n    &a.b.c\n}\n```\n\n----------------------------------------\n\nTITLE: Table Usage Example\nDESCRIPTION: Example showing how to use a Table collection as a struct field in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-collections.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/dynamic-collections.move:table_struct}}\n```\n\n----------------------------------------\n\nTITLE: Using Continue in While Loop to Sum Even Numbers\nDESCRIPTION: This function demonstrates the use of continue in a while loop to sum only even numbers from a vector. It skips odd numbers using the continue statement.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/loops.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun sum_even(values: &vector<u64>): u64 {\n    let size = vector::length(values);\n    let mut i = 0;\n    let mut even_sum = 0;\n\n    while (i < size) {\n        let number = *vector::borrow(values, i);\n        i = i + 1;\n        if (number % 2 == 1) continue;\n        even_sum = even_sum + number;\n    };\n    even_sum\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Method Naming Convention in Move\nDESCRIPTION: Shows struct method naming conventions using snake_case and demonstrates method aliasing for shared method names across different structs.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/coding-conventions.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\npublic fun value(h: &Hero): u64 { h.value }\n\npublic use fun hero_health as Hero.health;\npublic fun hero_health(h: &Hero): u64 { h.another_value }\n\npublic use fun boar_health as Boar.health;\npublic fun boar_health(b: &Boar): u64 { b.another_value }\n```\n\n----------------------------------------\n\nTITLE: Using Shorthand Syntax for Enum Variants with Named Fields in Move\nDESCRIPTION: This example shows how to use the shorthand syntax for creating enum variants with named fields, similar to struct initialization in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet duration = 10;\n\nlet pause = Action::Pause { duration: duration };\n// is equivalent to\nlet pause = Action::Pause { duration };\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Method Call Chaining in Move\nDESCRIPTION: This snippet shows how method calls can be chained in Move. It illustrates that any expression can be the receiver of a method, allowing for more readable and concise code.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\nmodule a::shapes {\n    public struct Point has copy, drop, store { x: u64, y: u64 }\n    public struct Line has copy, drop, store { start: Point, end: Point }\n\n    public fun x(p: &Point): u64 { p.x }\n    public fun y(p: &Point): u64 { p.y }\n\n    public fun start(l: &Line): &Point { &l.start }\n    public fun end(l: &Line): &Point { &l.end }\n\n}\n\nmodule b::example {\n    use a::shapes::Line;\n\n    public fun x_values(l: Line): (u64, u64) {\n        (l.start().x(), l.end().x())\n    }\n\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Test Function Declaration in Move\nDESCRIPTION: Examples of correct and incorrect test function declarations using the #[test] annotation. Shows that test functions must have no parameters.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n#[test] // OK\nfun this_is_a_test() { ... }\n\n#[test] // Will fail to compile since the test takes an argument\nfun this_is_not_correct(arg: u64) { ... }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Address Substitution in Move\nDESCRIPTION: Illustrates how named addresses are substituted with their numerical values during compilation. This example shows the equivalence of using named and numerical addresses.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/modules.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nfun example() {\n    my_addr::m::foo(@my_addr);\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nfun example() {\n    0xC0FFEE::m::foo(@0xC0FFEE);\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Variable Shadowing in Move\nDESCRIPTION: This snippet demonstrates variable shadowing in Move, showing how variables can be redeclared with different types and how shadowing affects scopes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\nlet x = 0;\nassert!(x == 0, 42);\n\nlet x = 1; // x is shadowed\nassert!(x == 1, 42);\n\nlet x = b\"hello\"; // x is shadowed\nassert!(x == b\"hello\", 42);\n\nlet x = 0;\n{\n    let x = b\"hello\";\n    assert!(x = b\"hello\", 42);\n};\nassert!(x == 0, 42);\n```\n\n----------------------------------------\n\nTITLE: Basic Pattern Matching in Move\nDESCRIPTION: Demonstrates basic pattern matching with literals, variables, and wildcards in Move. The function test_lit matches against specific u64 values and a wildcard, while test_var shows matching with a variable pattern.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nfun test_lit(x: u64): u8 {\n    match (x) {\n        1 => 2,\n        2 => 3,\n        _ => 4,\n    }\n}\ntest_lit(1); // returns 2\ntest_lit(2); // returns 3\ntest_lit(3); // returns 4\ntest_lit(10); // returns 4\n\nfun test_var(x: u64): u64 {\n    match (x) {\n        y => y,\n    }\n}\ntest_var(1); // returns 1\ntest_var(2); // returns 2\ntest_var(3); // returns 3\n```\n\n----------------------------------------\n\nTITLE: Performing Actions on Game State using Enum Pattern Matching in Move\nDESCRIPTION: This snippet demonstrates pattern matching on an Action enum to update a GameState struct. It shows how to handle different variants, use guards, and destructure enum fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum Action has drop {\n    Stop,\n    Pause { duration: u32 },\n    MoveTo { x: u64, y: u64 },\n    Jump(u64),\n}\n\npublic struct GameState {\n    // Fields containing a game state\n    character_x: u64,\n    character_y: u64,\n    character_height: u64,\n    // ...\n}\n\nfun perform_action(stat: &mut GameState, action: Action) {\n    match (action) {\n        // Handle the `Stop` variant\n        Action::Stop => state.stop(),\n        // Handle the `Pause` variant\n        // If the duration is 0, do nothing\n        Action::Pause { duration: 0 } => (),\n        Action::Pause { duration } => state.pause(duration),\n        // Handle the `MoveTo` variant\n        Action::MoveTo { x, y } => state.move_to(x, y),\n        // Handle the `Jump` variant\n        // if the game disallows jumps then do nothing\n        Action::Jump(_) if (state.jumps_not_allowed()) => (),\n        // otherwise, jump to the specified height\n        Action::Jump(height) => state.jump(height),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Safety with Generic Pairs in Move\nDESCRIPTION: Shows that Pair<T, U> and Pair<U, T> are different types that cannot be compared. This example illustrates how generics enforce type safety in Move by treating different type parameter arrangements as distinct types.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n#[test]\n#[expected_failure]\nfun test_pair_swap() {\n    let pair1 = new_pair(10u8, true);\n    let pair2 = new_pair(true, 10u8);\n    \n    // This will not compile because the types are different\n    // pair1 is Pair<u8, bool> and pair2 is Pair<bool, u8>\n    assert!(pair1 == pair2, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Witness Pattern in Move Module\nDESCRIPTION: Shows how a module can use the witness pattern to create an instance of a generic type, proving ownership of the witness type.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/witness-pattern.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule book::witness_source;\n\nuse book::witness::{Self, Instance};\n\n/// A struct used as a witness.\npublic struct W {}\n\n/// Create a new instance of `Instance<W>`.\npublic fun new_instance(): Instance<W> {\n    witness::new(W {})\n}\n```\n\n----------------------------------------\n\nTITLE: Finding First Even Number Using Labeled Block in Move\nDESCRIPTION: Function using labeled blocks with a for_ref macro to find the first even number in a vector.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/labeled-control-flow.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nfun find_first_even(vs: vector<u64>): Option<u64> {\n    'result: {\n        for_ref!(&vs, |n| if (*n % 2 == 0) { return 'result option::some(*n)});\n        option::none()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Shared Config Object\nDESCRIPTION: Special case function that demonstrates how to delete a shared object by taking it by value. This is the only case where a shared object can be taken by value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Copying in Move\nDESCRIPTION: Examples demonstrating vector copying behavior and move semantics.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/vector.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nlet x = vector[10];\nlet y = x; // implicit copy\nlet z = x;\n(y, z)\n```\n\n----------------------------------------\n\nTITLE: Using 'let mut' for Mutable Variables in Move 2024\nDESCRIPTION: Illustrates the new 'let mut' syntax for declaring mutable variables in Move 2024. This syntax is now required for variables that will be reassigned after declaration.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n// Move 2020\nlet x: u64 = 10;\nx = 20;\n\n// Move 2024\nlet mut x: u64 = 10;\nx = 20;\n```\n\n----------------------------------------\n\nTITLE: Declaring a Struct with Abilities in Move\nDESCRIPTION: Example of a struct definition in Move that has the 'copy' and 'drop' abilities. The syntax uses the 'has' keyword followed by a comma-separated list of abilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/abilities-introduction.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n/// This struct has the `copy` and `drop` abilities.\nstruct VeryAble has copy, drop {\n    // field: Type1,\n    // field2: Type2,\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Module Alias Usage Example\nDESCRIPTION: Example showing how to create and use module aliases with vector and option types.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\nuse std::option as o;\n\nfun new_vec(): vector<o::Option<u8>> {\n    let mut v = vector[];\n    vector::push_back(&mut v, o::some(0));\n    vector::push_back(&mut v, o::none());\n    v\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Operations with Error Codes\nDESCRIPTION: Example module showing the use of constant error codes with multiple vector operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example;\n\nuse std::vector;\n\nconst EEmptyVector: u64 = 0;\nconst EIndexOutOfBounds: u64 = 1;\n\npublic fun rotate_three<T>(v: &mut vector<T>, i: u64, j: u64, k: u64) {\n    let n = v.length();\n    assert!(n > 0, EEmptyVector);\n    assert!(i < n, EIndexOutOfBounds);\n    assert!(j < n, EIndexOutOfBounds);\n    assert!(k < n, EIndexOutOfBounds);\n\n    v.swap(i, k);\n    v.swap(j, k);\n}\n\npublic fun remove_twice<T>(v: &mut vector<T>, i: u64, j: u64): (T, T) {\n    let n = v.length();\n    assert!(n > 0, EEmptyVector);\n    assert!(i < n, EIndexOutOfBounds);\n    assert!(j < n, EIndexOutOfBounds);\n    assert!(i > j, EIndexOutOfBounds);\n\n    (v.remove(i), v.remove(j))\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Method Call Examples\nDESCRIPTION: Shows practical examples of method calls in Move, including value access and mutable borrowing operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\ncoin.value();\n*nums.borrow_mut(i) = 5;\n```\n\n----------------------------------------\n\nTITLE: Defining Functions with Various Return Types in Move\nDESCRIPTION: Examples of functions returning unit and tuples with different arities. Demonstrates implicit and explicit unit returns, as well as multi-value returns using tuples.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/tuples.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example;\n\n// all 3 of these functions are equivalent\n\n// when no return type is provided, it is assumed to be `()`\nfun returns_unit_1() { }\n\n// there is an implicit () value in empty expression blocks\nfun returns_unit_2(): () { }\n\n// explicit version of `returns_unit_1` and `returns_unit_2`\nfun returns_unit_3(): () { () }\n\n\nfun returns_3_values(): (u64, bool, address) {\n    (0, false, @0x42)\n}\nfun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {\n    (x, 0, 1, b\"foobar\")\n}\n```\n\n----------------------------------------\n\nTITLE: Using Vector Collections in Move Objects\nDESCRIPTION: Demonstrates how to create and use a vector collection within a Move object. The example shows initialization, adding elements, and accessing elements in a vector.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/collections.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/collections.move:vector}}\n```\n\n----------------------------------------\n\nTITLE: Nested Loop Control Flow Example in Move\nDESCRIPTION: Example showing how to use labeled loops for complex control flow in nested loops with multiple conditions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/labeled-control-flow.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nlet x = 'outer: loop {\n    ...\n    'inner: while (cond) {\n        ...\n        if (cond0) { break 'outer value };\n        ...\n        if (cond1) { continue 'inner }\n        else if (cond2) { continue 'outer }\n        ...\n    }\n        ...\n};\n```\n\n----------------------------------------\n\nTITLE: Freeze Inference Examples in Move\nDESCRIPTION: Shows various cases where Move automatically infers freeze operations when converting mutable references to immutable ones.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/references.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nfun takes_immut_returns_immut(x: &u64): &u64 { x }\n\n// freeze inference on return value\nfun takes_mut_returns_immut(x: &mut u64): &u64 { x }\n\nfun expression_examples() {\n    let mut x = 0;\n    let mut y = 0;\n    takes_immut_returns_immut(&x); // no inference\n    takes_immut_returns_immut(&mut x); // inferred freeze(&mut x)\n    takes_mut_returns_immut(&mut x); // no inference\n\n    assert!(&x == &mut y, 42); // inferred freeze(&mut y)\n}\n\nfun assignment_examples() {\n    let x = 0;\n    let y = 0;\n    let imm_ref: &u64 = &x;\n\n    imm_ref = &x; // no inference\n    imm_ref = &mut y; // inferred freeze(&mut y)\n}\n```\n\n----------------------------------------\n\nTITLE: Constant Naming Conventions in Move\nDESCRIPTION: Demonstrates the naming conventions for constants in Move, including uppercase for values and ECamelCase for error constants.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/constants.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/constants-naming.move:naming}}\n```\n\n----------------------------------------\n\nTITLE: Using Phantom Type Parameters for Type Safety in Move\nDESCRIPTION: Demonstrates how phantom type parameters can be used to create type-safe distinctions between otherwise identical structures. This example shows how USD and EUR coins are treated as different types.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/generics.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\n#[test]\nfun test_phantom() {\n    let usd_coin = new_coin<USD>(100);\n    let eur_coin = new_coin<EUR>(100);\n    \n    // The coins have the same value\n    assert!(usd_coin.value == eur_coin.value, 0);\n    \n    // But they are different types\n    // This would not compile:\n    // let _invalid: Coin<USD> = eur_coin;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Package Visibility Functions in Move\nDESCRIPTION: Shows how to define package-visible functions using the 'public(package)' modifier. Package-visible functions can be called from any module within the same package but not from other packages.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/visibility.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule book::package_visibility;\n\npublic(package) fun package_only() { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Defining Move Package Manifest Structure\nDESCRIPTION: Outlines the structure and syntax of the Move.toml manifest file, including package metadata, dependencies, and address declarations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = <string>\nedition* = <string>      # e.g., \"2024.alpha\" to use the Move 2024 edition,\n                         # currently in alpha. Will default to the latest stable edition if not specified.\nlicense* = <string>              # e.g., \"MIT\", \"GPL\", \"Apache 2.0\"\nauthors* = [<string>,+]  # e.g., [\"Joe Smith (joesmith@noemail.com)\", \"John Snow (johnsnow@noemail.com)\"]\n\n# Additional fields may be added to this section by external tools. E.g., on Sui the following sections are added:\npublished-at* = \"<hex-address>\" # The address that the package is published at. Should be set after the first publication.\n\n[dependencies] # (Optional section) Paths to dependencies\n# One or more lines declaring dependencies in the following format\n\n# ##### Local Dependencies #####\n# For local dependencies use `local = path`. Path is relative to the package root\n# Local = { local = \"../path/to\" }\n# To resolve a version conflict and force a specific version for dependency\n# override you can use `override = true`\n# Override = { local = \"../conflicting/version\", override = true }\n# To instantiate address values in a dependency, use `addr_subst`\n<string> = {\n    local = <string>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n\n# ##### Git Dependencies #####\n# For remote import, use the `{ git = \"...\", subdir = \"...\", rev = \"...\" }`.\n# Revision must be supplied, it can be a branch, a tag, or a commit hash.\n# If no `subdir` is specified, the root of the repository is used.\n# MyRemotePackage = { git = \"https://some.remote/host.git\", subdir = \"remote/path\", rev = \"main\" }\n<string> = {\n    git = <URL ending in .git>,\n    subdir=<path to dir containing Move.toml inside git repo>,\n    rev=<git commit hash>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n\n[addresses]  # (Optional section) Declares named addresses in this package\n# One or more lines declaring named addresses in the following format\n# Addresses that match the name of the package must be set to `\"0x0\"` or they will be unable to be published.\n<addr_name> = \"_\" | \"<hex_address>\" # e.g., std = \"_\" or my_addr = \"0xC0FFEECAFE\"\n\n# Named addresses will be accessible in Move as `@name`. They're also exported:\n# for example, `std = \"0x1\"` is exported by the Standard Library.\n# alice = \"0xA11CE\"\n\n[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in \"dev\" and \"test\" modes\n# The dev-dependencies section allows overriding dependencies for `--test` and\n# `--dev` modes. You can e.g., introduce test-only dependencies here.\n# Local = { local = \"../path/to/dev-build\" }\n<string> = {\n    local = <string>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n<string> = {\n    git = <URL ending in .git>,\n    subdir=<path to dir containing Move.toml inside git repo>,\n    rev=<git commit hash>,\n    override* = <bool>,\n    addr_subst* = { (<string> = (<string> | \"<hex_address>\"))+ }\n}\n\n[dev-addresses] # (Optional section) Same as [addresses] section, but only included in \"dev\" and \"test\" modes\n# The dev-addresses section allows overwriting named addresses for the `--test`\n# and `--dev` modes.\n<addr_name> = \"<hex_address>\" # e.g., alice = \"0xB0B\"\n```\n\n----------------------------------------\n\nTITLE: Safer Approaches to Exposing UIDs for Dynamic Fields in Move\nDESCRIPTION: Example showing more secure ways to expose access to dynamic fields, using package-limited visibility or specific accessor methods rather than exposing the full UID.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\n/// Access Character's UID (package-limited to prevent abuse)\npublic(package) fun uid(character: &mut Character): &mut UID {\n    &mut character.id\n}\n\n/// A safer approach - exposing specific fields only\npublic fun hat_ref(self: &Character): Option<&Hat> {\n    if (df::exists_<vector<u8>, Hat>(&self.id, b\"hat\")) {\n        option::some(df::borrow<vector<u8>, Hat>(&self.id, b\"hat\"))\n    } else {\n        option::none()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Representing Published Package Structure\nDESCRIPTION: This snippet illustrates how a published Move package is represented on the blockchain, showing its unique address and the bytecode of its modules.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/packages.md#2025-04-22_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n0x...\n    my_module: <bytecode>\n    another_module: <bytecode>\n```\n\n----------------------------------------\n\nTITLE: Integer Square Root Macro in Move\nDESCRIPTION: Implements a macro for calculating the integer square root for any integer type (except u256). It demonstrates the use of type parameters and type annotations within the macro.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_13\n\nLANGUAGE: move\nCODE:\n```\nmacro fun num_sqrt<$T, $U>($x: $T, $bitsize: u8): $T {\n    let x = $x;\n    let mut bit = (1: $U) << $bitsize;\n    let mut res = (0: $U);\n    let mut x = x as $U;\n\n    while (bit != 0) {\n        if (x >= res + bit) {\n            x = x - (res + bit);\n            res = (res >> 1) + bit;\n        } else {\n            res = res >> 1;\n        };\n        bit = bit >> 2;\n    };\n\n    res as $T\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Copy and Move Inference in Move\nDESCRIPTION: Shows how Move automatically infers whether to copy or move values based on their types and abilities. Values with copy ability or references are copied, while others are moved.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_13\n\nLANGUAGE: move\nCODE:\n```\nlet s = b\"hello\";\nlet foo = Foo { f: 0 };\nlet coin = Coin { value: 0 };\nlet coins = vector[Coin { value: 0 }, Coin { value: 0 }];\n\nlet s2 = s; // copy\nlet foo2 = foo; // copy\nlet coin2 = coin; // move\nlet coins2 = coin; // move\n\nlet x = 0;\nlet b = false;\nlet addr = @0x42;\nlet x_ref = &x;\nlet coin_ref = &mut coin2;\n\nlet x2 = x; // copy\nlet b2 = b; // copy\nlet addr2 = @0x42; // copy\nlet x_ref2 = x_ref; // copy\nlet coin_ref2 = coin_ref; // copy\n```\n\n----------------------------------------\n\nTITLE: Using Self Keyword in Grouped Imports in Move\nDESCRIPTION: This example demonstrates how to use the 'Self' keyword to import both the module and its members in a grouped import.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule package::example {\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n\n    struct Example has key {\n        id: UID\n    }\n\n    public fun new(ctx: &mut TxContext): Example {\n        Example { id: object::new(ctx) }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scoping Rules for use fun Aliases in Move\nDESCRIPTION: This snippet shows how use fun aliases are scoped locally, similar to normal use statements. It demonstrates how different aliases can be used in nested scopes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m {\n    public struct X() has copy, drop, store;\n    public fun foo(_: &X) {}\n    public fun bar(_: &X) {}\n}\n\nmodule b::other {\n    use a::m::X;\n\n    use fun a::m::foo as X.f;\n\n    fun example(x: &X) {\n        x.f(); // resolves to a::m::foo\n        {\n            use a::m::bar as f;\n            x.f(); // resolves to a::m::bar\n        };\n        x.f(); // still resolves to a::m::foo\n        {\n            use fun a::m::bar as X.f;\n            x.f(); // resolves to a::m::bar\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Public Functions in Move\nDESCRIPTION: Demonstrates how public functions can be accessed from other modules.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m {\n    public fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // valid\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Module Aliasing in Move\nDESCRIPTION: Basic syntax for creating aliases to modules using the 'use' keyword.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nuse <address>::<module name>;\nuse <address>::<module name> as <module alias name>;\n```\n\n----------------------------------------\n\nTITLE: Bag Implementation Example\nDESCRIPTION: Demonstration of Bag collection usage with specific implementation details.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-collections.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/dynamic-collections.move:bag_usage}}\n```\n\n----------------------------------------\n\nTITLE: Basic BCS Encoding Example\nDESCRIPTION: Demonstrates basic BCS encoding using the to_bytes function for simple values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/bcs.move:encode}}\n```\n\n----------------------------------------\n\nTITLE: Unpacking Mutable Tuple Return Values in Move\nDESCRIPTION: This snippet demonstrates how to unpack multiple return values from a function with some variables declared as mutable using the 'mut' keyword.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/function.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nfun test_sum_and_product_mut() {\n    let (sum, mut product) = sum_and_product(2, 3);\n    assert!(sum == 5, 0);\n    product = product + 1;\n    assert!(product == 7, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Named Addresses in Move Code\nDESCRIPTION: Demonstrates how to use a named address in a Move module, which is declared in the package manifest.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule named_addr::a {\n    public fun x(): address { @named_addr }\n}\n```\n\n----------------------------------------\n\nTITLE: Transferring Ownership from Blocks in Move\nDESCRIPTION: This snippet demonstrates how returning a value from a block transfers ownership to the outer scope. Variable 'c' is defined in a block, but its value is transferred to 'b' through the block's return, making it available for the final calculation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/ownership-and-scope.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule book::ownership;\n\npublic fun owner(): u8 {\n    let a = 1; // a is owned by the `owner` function's scope\n    let b = {\n        let c = 2; // the block that declares c owns it\n        c // c is returned from the block and transferred to b\n    };\n    a + b // both a and b are valid here\n}\n```\n\n----------------------------------------\n\nTITLE: Bag Structure Definition in Move\nDESCRIPTION: Definition of the Bag structure in Sui Framework, which implements a heterogeneous collection with key and store abilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-collections.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\npublic struct Bag has key, store {\n    /// the ID of this bag\n    id: UID,\n    /// the number of key-value pairs in the bag\n    size: u64,\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Hero Object with Display in Move\nDESCRIPTION: This snippet shows how to create a Hero object and associate it with a Display object for metadata, demonstrating the new approach to object display in Sui.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/display.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nstruct Hero has key {\n    id: UID,\n    power: u64,\n}\n\nfun mint_hero(ctx: &mut TxContext) {\n    let hero = Hero {\n        id: object::new(ctx),\n        power: 100,\n    };\n    let hero_display = display::new<Hero>();\n    display::add(&mut hero_display, \"name\", \"Mighty Hero\");\n    display::add(&mut hero_display, \"image_url\", \"ipfs://hero.png\");\n    display::add(&mut hero_display, \"description\", \"A true Hero with the power of {power}\");\n    transfer::public_transfer(hero, tx_context::sender(ctx));\n    display::update_version(&mut hero_display);\n}\n```\n\n----------------------------------------\n\nTITLE: Constructor Pattern Matching in Move\nDESCRIPTION: Illustrates constructor pattern matching for enums in Move. The function f demonstrates matching on specific enum variants and their fields, including the use of wildcards and or-patterns within constructors.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nfun f(x: MyEnum) {\n    match (x) {\n        MyEnum::Variant(1, true) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        MyEnum::Variant(..) => 3,\n        MyEnum::OtherVariant(..) => 4,\n}\nf(MyEnum::Variant(1, true)); // returns 1\nf(MyEnum::Variant(2, true)); // returns 3\nf(MyEnum::OtherVariant(false, 3)); // returns 2\nf(MyEnum::OtherVariant(true, 3)); // returns 2\nf(MyEnum::OtherVariant(true, 2)); // returns 4\n```\n\n----------------------------------------\n\nTITLE: Using Method Aliases to Avoid Name Conflicts in Move\nDESCRIPTION: This snippet demonstrates how to use method aliases to avoid name conflicts when a module defines multiple structs with similar methods. It shows how to create both local and public aliases for method names.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct-methods.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule hero::hero {\n    use std::string::String;\n\n    /// Represents a hero with name and health\n    public struct Hero has store, drop {\n        name: String,\n        health: u64,\n    }\n\n    /// Represents a villain with name and health\n    public struct Villain has store, drop {\n        name: String,\n        health: u64,\n    }\n\n    /// Create a new hero with the given name and default health\n    public fun new_hero(name: String): Hero {\n        Hero { name, health: 100 }\n    }\n\n    /// Create a new villain with the given name and default health\n    public fun new_villain(name: String): Villain {\n        Villain { name, health: 150 }\n    }\n\n    /// Get hero's current health\n    public fun hero_health(hero: &Hero): u64 {\n        hero.health\n    }\n\n    /// Get villain's current health\n    public fun villain_health(villain: &Villain): u64 {\n        villain.health\n    }\n\n    // Now define aliases for methods to create clean API\n    public use fun hero_health as Hero.health;\n    public use fun villain_health as Villain.health;\n\n    #[test]\n    public fun test_hero_and_villain() {\n        let hero = new_hero(std::string::utf8(b\"Sui\"));\n        let villain = new_villain(std::string::utf8(b\"Anti-Sui\"));\n\n        // Can call methods directly on the instances\n        assert!(hero.health() == 100, 0);\n        assert!(villain.health() == 150, 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Move Tests with Sui CLI\nDESCRIPTION: Shows the command to run Move tests using the Sui CLI. The 'sui move test' command builds the package in test mode and executes all tests found in the package.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/testing.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move test\n> UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\n> INCLUDING DEPENDENCY Bridge\n> INCLUDING DEPENDENCY DeepBook\n> INCLUDING DEPENDENCY SuiSystem\n> INCLUDING DEPENDENCY Sui\n> INCLUDING DEPENDENCY MoveStdlib\n> BUILDING book\n> Running Move unit tests\n> ...\n```\n\n----------------------------------------\n\nTITLE: Boolean Type Usage in Move\nDESCRIPTION: Demonstrates declaration and usage of boolean values in Move, showing type inference for boolean literals.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/primitive-types.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet t = true;\nlet f = false;\nlet b: bool = true;\n```\n\n----------------------------------------\n\nTITLE: Implementing Wrapper Type for Dynamic Object Fields in Move\nDESCRIPTION: Defines the internal Wrapper struct used for storing field names in dynamic object fields. This type prevents key collisions with direct dynamic field usage.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-object-fields.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\npublic struct Wrapper<Name> has copy, drop, store {\n    name: Name,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Named Addresses in Move Modules\nDESCRIPTION: Shows how to use named addresses in module declarations and within module code. Named addresses are used for better code readability and maintainability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/modules.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule test_addr::test;\n\npublic struct Example has copy, drop { a: address }\n\nfriend test_addr::another_test;\n\npublic fun print() {\n    let example = Example { a: @test_addr };\n    debug::print(&example)\n}\n```\n\n----------------------------------------\n\nTITLE: Using 'mut' in Function Arguments and Destructuring in Move 2024\nDESCRIPTION: Shows how to use the 'mut' keyword in function arguments, tuple destructuring, and struct unpacking to declare mutable variables in Move 2024.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n// takes by value and mutates\nfun takes_by_value_and_mutates(mut v: Value): Value {\n    v.field = 10;\n    v\n}\n\n// `mut` should be placed before the variable name\nfun destruct() {\n    let (x, y) = point::get_point();\n    let (mut x, y) = point::get_point();\n    let (mut x, mut y) = point::get_point();\n}\n\n// in struct unpack\nfun unpack() {\n    let Point { x, mut y } = point::get_point();\n    let Point { mut x, mut y } = point::get_point();\n}\n```\n\n----------------------------------------\n\nTITLE: Constant References Example\nDESCRIPTION: Example showing how constants can reference other constants within the same module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/constants.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nconst BASE: u8 = 4;\nconst SQUARE: u8 = BASE * BASE;\n```\n\n----------------------------------------\n\nTITLE: Defining Immutable Index Syntax for Vector in Move\nDESCRIPTION: Shows the declaration of an immutable index syntax method for the standard vector type in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n#[syntax(index)]\npublic native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;\n```\n\n----------------------------------------\n\nTITLE: Importing a Module in Move\nDESCRIPTION: This snippet shows how to import a module and use its public members in another module within the same package.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n// File: sources/module_two.move\nmodule package::module_two {\n    use package::module_one::{Self, Character};\n    use std::string;\n\n    public fun create_character(name: vector<u8>, level: u64): Character {\n        module_one::new(string::utf8(name), level)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equality for User-Defined Types in Move\nDESCRIPTION: This example demonstrates how equality and inequality operators work with user-defined types in Move, using a custom struct 'S'.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example;\n\npublic struct S has copy, drop { f: u64, s: vector<u8> }\n\nfun always_true(): bool {\n    let s = S { f: 0, s: b\"\" };\n    s == s\n}\n\nfun always_false(): bool {\n    let s = S { f: 0, s: b\"\" };\n    s != s\n}\n```\n\n----------------------------------------\n\nTITLE: Function Naming Convention in Move\nDESCRIPTION: Illustrates function naming using snake_case with descriptive names.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/coding-conventions.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\npublic fun add(a: u64, b: u64): u64 { a + b }\npublic fun create_if_not_exists() { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Defining Internal (Private) Functions in Move\nDESCRIPTION: Demonstrates how to define and call internal (private) functions within the same module. Internal functions are the default visibility in Move and can only be accessed within the module they are defined in.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/visibility.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::internal_visibility;\n\n// This function can be called from other functions in the same module\nfun internal() { /* ... */ }\n\n// Same module -> can call internal()\nfun call_internal() {\n    internal();\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating if Condition in Move\nDESCRIPTION: This snippet shows how to use an if statement in Move to make a decision based on a boolean condition.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nlet x = 5;\nif (x > 0) {\n    // x is positive\n};\n```\n\n----------------------------------------\n\nTITLE: Type Compatible If Expressions in Move\nDESCRIPTION: Examples of type compatibility in if expressions, showing both valid and invalid cases.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/conditionals.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n// x and y must be u64 integers\nlet maximum: u64 = if (x > y) x else y;\n\n// ERROR! branches different types\nlet z = if (maximum < 10) 10u8 else 100u64;\n\n// ERROR! branches different types, as default false-branch is () not u64\nif (maximum >= 10) maximum;\n```\n\n----------------------------------------\n\nTITLE: Conditional Store Ability Example in Move\nDESCRIPTION: Illustrates how the store ability affects struct field requirements and shows valid and invalid cases of storing values in structs.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\npublic struct Cup<T> has copy, drop, store { item: T }\n\n// 'MyInnerData is declared with 'store' so all fields need 'store'\nstruct MyInnerData has store {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n\n// 'MyData' is declared with 'key' so all fields need 'store'\nstruct MyData has key {\n    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'\n    inner: Cup<MyInnerData>, // Valid, 'Cup<MyInnerData>' has 'store'\n    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Bound Checking with Abort\nDESCRIPTION: Function that checks if all numbers in a vector are below a specified bound, aborting if the condition is not met.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = v.length();\n    while (i < n) {\n        let cur = v[i];\n        if (cur > bound) abort 42;\n        i = i + 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct BCS Decoding\nDESCRIPTION: Demonstrates how to decode custom structs field by field using BCS.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/bcs.move:decode_struct}}\n```\n\n----------------------------------------\n\nTITLE: Defining the Field Structure in Move for Dynamic Fields\nDESCRIPTION: The internal Field struct used for storing dynamic fields in the Sui Framework, which contains a deterministically generated UID, the field name, and the value bound to the field.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n/// Internal object used for storing the field and value\npublic struct Field<Name: copy + drop + store, Value: store> has key {\n    /// Determined by the hash of the object ID, the field name\n    /// value and it's type, i.e. hash(parent.id || name || Name)\n    id: UID,\n    /// The value for the name of this field\n    name: Name,\n    /// The value bound to this field\n    value: Value,\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid Reference to Reference Example in Move\nDESCRIPTION: Demonstrates that Move does not allow references to references, showing an example that will not compile.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/references.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet x = 7;\nlet y: &u64 = &x;\nlet z: &&u64 = &y; // ERROR! will not compile\n```\n\n----------------------------------------\n\nTITLE: Using Publisher as admin capability in Move\nDESCRIPTION: Example of using the Publisher object as an admin capability to perform privileged actions in a module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/publisher.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\npublic fun admin_action(publisher: &Publisher) {\n    assert!(package::from_module<PUBLISHER>(publisher), 0);\n    // perform admin action\n}\n```\n\n----------------------------------------\n\nTITLE: Using Early Return for Conditional Logic in Move\nDESCRIPTION: This function demonstrates an early return statement used for handling a specific condition before the main computation. It subtracts two u64 values but returns 0 if the second value is larger than the first.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_11\n\nLANGUAGE: move\nCODE:\n```\nfun safe_sub(x: u64, y: u64): u64 {\n    if (y > x) return 0;\n    x - y\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Definition Convention in Move\nDESCRIPTION: Demonstrates struct naming using PascalCase for struct names, snake_case for fields, and Cap suffix for capabilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/coding-conventions.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\npublic struct Hero has key {\n    id: UID\n    value: u64,\n    another_value: u64,\n}\n\npublic struct AdminCap has key { id: UID }\n```\n\n----------------------------------------\n\nTITLE: Implementing assert_eq Macro in Move\nDESCRIPTION: Shows an implementation of an assert_eq macro that lazily evaluates its arguments. This macro compares two values and aborts with a custom error code if they are not equal.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_12\n\nLANGUAGE: move\nCODE:\n```\nmacro fun assert_eq<$T>($left: $T, $right: $T, $code: u64) {\n    let left = $left;\n    let right = $right;\n    if (left != right) {\n        std::debug::print(&b\"assertion failed.\\n left: \");\n        std::debug::print(&left);\n        std::debug::print(&b\"\\n does not equal right: \");\n        std::debug::print(&right);\n        abort $code;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Constant Usage Example\nDESCRIPTION: Example showing how to declare and use a constant in a Move module with a permission check.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/constants.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule a::example;\n\nconst MY_ADDRESS: address = @a;\n\npublic fun permissioned(addr: address) {\n    assert!(addr == MY_ADDRESS, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Expanding a Simple Macro in Move\nDESCRIPTION: Demonstrates the basic syntax for defining a macro and how it expands at the call site. The macro 'apply' takes a function and an argument, and applies the function to the argument.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmacro fun apply($f: |u64| -> u64, $x: u64): u64 {\n    $f($x)\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nlet incremented = apply!(|x| x + 1, 5);\n```\n\nLANGUAGE: move\nCODE:\n```\nlet incremented = {\n    let x = { 5 };\n    { x + 1 }\n};\n```\n\n----------------------------------------\n\nTITLE: Struct Definitions with Copy Ability\nDESCRIPTION: Example showing struct definitions with copy ability and phantom type parameters to demonstrate ability inheritance.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_11\n\nLANGUAGE: move\nCODE:\n```\npublic struct S<T1, phantom T2> has copy { f: T1 }\npublic struct NoCopy {}\npublic struct HasCopy has copy {}\n```\n\n----------------------------------------\n\nTITLE: Destructuring Structs in Move\nDESCRIPTION: This snippet shows how to destructure structs to declare multiple variables, including nested structs and punning syntax.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example {\n\npublic struct X(u64)\npublic struct Y { x1: X, x2: X }\n\nfun new_x(): X {\n    X(1)\n}\n\nfun example() {\n    let Y { x1: X(f), x2 } = Y { x1: new_x(), x2: new_x() };\n    assert!(f + x2.f == 2, 42);\n\n    let Y { x1: X(f1), x2: X(f2) } = Y { x1: new_x(), x2: new_x() };\n    assert!(f1 + f2 == 2, 42);\n}\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Modules with Addresses in Move\nDESCRIPTION: This snippet shows how to declare modules using both numerical and named addresses in Move. It also demonstrates the use of addresses in module imports and the syntax difference between expression and non-expression contexts.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/address.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule 66::some_module {   // Not in expression context, so no @ needed\n    use 0x1::other_module; // Not in expression context so no @ needed\n    use std::vector;       // Can use a named address as a namespace item\n    ...\n}\n\nmodule std::other_module {  // Can use a named address when declaring a module\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: More Invalid Ability Declarations\nDESCRIPTION: Additional examples showing invalid ability declarations for key and store abilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\npublic struct NoAbilities {}\n\npublic struct MyData has key {\n    f: NoAbilities, // Error 'NoAbilities' does not have 'store'\n}\n\npublic struct MyDataEnum has store {\n    Variant1,\n    Variant2(NoAbilities), // Error 'NoAbilities' does not have 'store'\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Functions Without Return Values in Move\nDESCRIPTION: This snippet demonstrates a function that performs actions but doesn't return a value. In Move, such functions are defined with empty parentheses as the return type.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/function.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nfun do_nothing(): () {\n    // no return value\n}\n```\n\n----------------------------------------\n\nTITLE: Gift Object Freezing\nDESCRIPTION: Shows how to implement freezing functionality for Gift objects, converting them from owned to immutable state.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n/// Freezes the `Gift` object so it becomes immutable.\npublic fun freeze_gift(gift: Gift) {\n    transfer::freeze_object(gift);\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Move Semantics Example\nDESCRIPTION: Example showing how move semantics work with vectors to prevent accidental copies.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/vector.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet x = vector[10];\nlet y = move x;\nlet z = x; // ERROR! x has been moved\n(y, z)\n```\n\n----------------------------------------\n\nTITLE: Using Break in While Loop to Find Position in Vector\nDESCRIPTION: This function uses a while loop with a break statement to find the position of a target value in a vector. It returns an Option<u64> containing the index if found, or None if not found.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/loops.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nfun find_position(values: &vector<u64>, target_value: u64): Option<u64> {\n    let size = vector::length(values);\n    let mut i = 0;\n    let mut found = false;\n\n    while (i < size) {\n        if (vector::borrow(values, i) == &target_value) {\n            found = true;\n            break\n        };\n        i = i + 1\n    };\n\n    if (found) {\n        option::some(i)\n    } else {\n        option::none<u64>()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic Equality Operations in Move\nDESCRIPTION: This snippet shows basic usage of equality and inequality operators with different data types in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n0 == 0; // `true`\n1u128 == 2u128; // `false`\nb\"hello\" != x\"00\"; // `true`\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching with Variables in Move\nDESCRIPTION: Demonstrates how variables in patterns can be used in guard expressions and on the right-hand side of match arms.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\npublic struct Wrapper(u64)\n\nfun add_under_wrapper_unless_equal(wrapper: Wrapper, x: u64): u64 {\n    match (wrapper) {\n        Wrapper(y) if (y == x) => Wrapper(y),\n        Wrapper(y) => y + x,\n    }\n}\nadd_under_wrapper_unless_equal(Wrapper(1), 2); // returns Wrapper(3)\nadd_under_wrapper_unless_equal(Wrapper(2), 3); // returns Wrapper(5)\nadd_under_wrapper_unless_equal(Wrapper(3), 3); // returns Wrapper(3)\n```\n\n----------------------------------------\n\nTITLE: Chained BCS Decoding\nDESCRIPTION: Shows how to decode multiple values in a chain using a single let statement.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/bcs.move:chain_decode}}\n```\n\n----------------------------------------\n\nTITLE: Valid Phantom Type Parameter Usage\nDESCRIPTION: Examples of valid phantom type parameter usage where the phantom type either doesn't appear in the struct or appears only in phantom positions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\npublic struct S1<phantom T1, T2> { f: u64 }\n//               ^^^^^^^ valid, T1 does not appear inside the struct definition\n\npublic struct S2<phantom T1, T2> { f: S1<T1, T2> }\n//               ^^^^^^^ valid, T1 appears in phantom position\n```\n\n----------------------------------------\n\nTITLE: Event Emission Native Function Definition - Move\nDESCRIPTION: Native function definition for emitting events in the Sui Framework. The function accepts a generic type T with copy and drop abilities and emits it as an event that can be tracked off-chain.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/events.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// File: sui-framework/sources/event.move\nmodule sui::event;\n\n/// Emit a custom Move event, sending the data off-chain.\n///\n/// Used for creating custom indexes and tracking on-chain\n/// activity in a way that suits a specific application the most.\n///\n/// The type `T` is the main way to index the event, and can contain\n/// phantom parameters, eg `emit(MyEvent<phantom T>)`.\npublic native fun emit<T: copy + drop>(event: T);\n```\n\n----------------------------------------\n\nTITLE: Type Casting in Move\nDESCRIPTION: Shows how to perform type casting between different integer types using the 'as' operator.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/primitive-types.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet x = 42u8;\nlet y = (x as u64);\n```\n\n----------------------------------------\n\nTITLE: Invalid Ability Declaration Examples\nDESCRIPTION: Examples demonstrating invalid ability declarations where struct fields don't satisfy ability requirements.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abilities.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\npublic struct NoAbilities {}\n\npublic struct WantsCopy has copy {\n    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'\n}\n\npublic enum WantsCopyEnum has copy {\n    Variant1\n    Variant2(NoAbilities), // ERROR 'NoAbilities' does not have 'copy'\n}\n```\n\n----------------------------------------\n\nTITLE: Duplicate Friend Declarations in Move\nDESCRIPTION: This snippet shows an error when attempting to declare the same module as a friend multiple times, which is not allowed in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::a {}\n\nmodule 0x42::m {\n    use 0x42::a as aliased_a;\n    friend 0x42::A;\n    friend aliased_a; // ERROR!\n//         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Pop Implementation with Assert\nDESCRIPTION: Revised version of pop_twice using assert instead of explicit abort condition.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    assert!(v.length() >= 2, 42); // Now uses 'assert'\n    (v.pop_back(), v.pop_back())\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Functions in Move\nDESCRIPTION: Example of a macro function in Move, which is inlined at compile-time and can accept lambda-style arguments.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmacro fun n_times($n: u64, $body: |u64| -> ()) {\n    let n = $n;\n    let mut i = 0;\n    while (i < n) {\n        $body(i);\n        i = i + 1;\n    }\n}\n\nfun example() {\n    let mut sum = 0;\n    n_times!(10, |x| sum = sum + x );\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Values by Reference in Move\nDESCRIPTION: This snippet shows how to compare values by reference in Move to avoid destroying assets that don't have the 'drop' ability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example;\n\npublic struct Coin has store { value: u64 }\nfun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {\n    let are_equal = &c1 == c2; // valid, note `c2` is automatically borrowed\n    if (are_equal) (c2, c1) else (c1, c2)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New UID in Sui Move\nDESCRIPTION: Demonstrates how to create a new UID using the object::new function, which requires a mutable reference to TxContext.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/uid-and-id.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nlet ctx = &mut tx_context::dummy();\nlet uid = object::new(ctx);\n```\n\n----------------------------------------\n\nTITLE: Using Literals in Move\nDESCRIPTION: Demonstrates the use of various literals in Move including boolean values, integer values, hexadecimal values, byte vector values, and byte values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/expression.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun literals() {\n    // Boolean literals\n    let _ = true;\n    let _ = false;\n\n    // Integer literals\n    let _ = 0;\n    let _ = 1;\n    let _ = 123123;\n\n    // Hex literals\n    let _ = 0x0;\n    let _ = 0x1;\n    let _ = 0x123;\n\n    // Byte string literals\n    let _ = b\"hello world\";\n\n    // Byte literals with hex values\n    let _ = x\"DEADBEEF\";\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Pop Implementation with Abort\nDESCRIPTION: Example function that pops two items from a vector, using abort to handle insufficient vector length.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\n\nfun pop_twice<T>(v: &mut vector<T>): (T, T) {\n    if (v.length() < 2) abort 42;\n    (v.pop_back(), v.pop_back())\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Patterns with Or-Patterns in Move\nDESCRIPTION: Shows how to use or-patterns to match multiple conditions in a single match arm.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\npublic enum MyEnum has drop {\n    Variant(u64, bool),\n    OtherVariant(bool, u64),\n}\n\nfun test_or_pattern(x: u64): u64 {\n    match (x) {\n        MyEnum::Variant(1 | 2 | 3, true) | MyEnum::OtherVariant(true, 1 | 2 | 3) => 1,\n        MyEnum::Variant(8, true) | MyEnum::OtherVariant(_, 6 | 7) => 2,\n        _ => 3,\n    }\n}\n\ntest_or_pattern(MyEnum::Variant(3, true)); // returns 1\ntest_or_pattern(MyEnum::OtherVariant(true, 2)); // returns 1\ntest_or_pattern(MyEnum::Variant(8, true)); // returns 2\ntest_or_pattern(MyEnum::OtherVariant(false, 7)); // returns 2\ntest_or_pattern(MyEnum::OtherVariant(false, 80)); // returns 3\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Mutability Usage in Move Pattern Matching\nDESCRIPTION: This snippet showcases different ways of using the 'mut' modifier in pattern matching. It includes examples of using 'mut' with value, immutable reference, and mutable reference matches, as well as demonstrating an invalid usage.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_15\n\nLANGUAGE: move\nCODE:\n```\npublic struct MyStruct(u64)\n\nfun top_level_mut(x: MyStruct) {\n    match (x) {\n        mut MyStruct(y) => 1,\n        // ERROR: cannot use mut on a non-variable pattern\n    }\n}\n\nfun mut_on_immut(x: &MyStruct): u64 {\n    match (x) {\n        MyStruct(mut y) => {\n            y = &(*y + 1);\n            *y\n        }\n    }\n}\n\nfun mut_on_value(x: MyStruct): u64 {\n    match (x) {\n        MyStruct(mut y) =>  {\n            *y = *y + 1;\n            *y\n        },\n    }\n}\n\nfun mut_on_mut(x: &mut MyStruct): u64 {\n    match (x) {\n        MyStruct(mut y) =>  {\n            *y = *y + 1;\n            *y\n        },\n    }\n}\n\nlet mut x = MyStruct(1);\n\nmut_on_mut(&mut x); // returns 2\nx.0; // returns 2\n\nmut_on_immut(&x); // returns 3\nx.0; // returns 2\n\nmut_on_value(x); // returns 3\n```\n\n----------------------------------------\n\nTITLE: Defining Error Constants in Move\nDESCRIPTION: This snippet illustrates how to define error constants for improved code readability and easier understanding of abort scenarios.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/assert-and-abort.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nconst ENOT_42: u64 = 0;\nconst EINVALID_FLAG: u64 = 1;\n\nfun validate_data(value: u64, flag: bool) {\n    assert!(value == 42, ENOT_42);\n    assert!(flag == true, EINVALID_FLAG);\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing References in Move Equality Operations\nDESCRIPTION: This example shows how to compare references in Move, demonstrating that the mutability of references doesn't affect equality comparisons.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nlet i = &0;\nlet m = &mut 1;\n\ni == m; // `false`\nm == i; // `false`\nm == m; // `true`\ni == i; // `true`\n```\n\n----------------------------------------\n\nTITLE: Empty Return Statements in Move Functions\nDESCRIPTION: This snippet shows two equivalent functions demonstrating that using 'return' without an argument is shorthand for returning an empty tuple '()'.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_13\n\nLANGUAGE: move\nCODE:\n```\nfun foo() { return }\nfun foo() { return () }\n```\n\n----------------------------------------\n\nTITLE: Non-Exhaustive Pattern Matching Examples in Move\nDESCRIPTION: Illustrates non-exhaustive pattern matching in Move, showing cases where the compiler will raise an error due to incomplete matching. Examples include matching on enums and structs.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_11\n\nLANGUAGE: move\nCODE:\n```\npublic enum MyEnum {\n    Variant(u64, bool),\n    OtherVariant(bool, u64),\n}\n\npublic struct Pair<T>(T, T)\n\nfun f(x: MyEnum): u8 {\n    match (x) {\n        MyEnum::Variant(1, true) => 1,\n        MyEnum::Variant(_, _) => 1,\n        MyEnum::OtherVariant(_, 3) => 2,\n        // ERROR: not exhaustive as the value `MyEnum::OtherVariant(_, 4)` is not matched.\n    }\n}\n\nfun match_pair_bool(x: Pair<bool>): u8 {\n    match (x) {\n        Pair(true, true) => 1,\n        Pair(true, false) => 1,\n        Pair(false, false) => 1,\n        // ERROR: not exhaustive as the value `Pair(false, true)` is not matched.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Move Package Directory Structure\nDESCRIPTION: Shows the typical directory structure of a Move package, including required and optional files and directories.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\na_move_package\n├── Move.toml      (required)\n├── Move.lock      (generated)\n├── sources        (required)\n├── doc_templates  (optional)\n├── examples       (optional, test & dev mode)\n└── tests          (optional, test mode)\n```\n\n----------------------------------------\n\nTITLE: Option Handling Macro Usage Examples in Move\nDESCRIPTION: Demonstrates practical uses of the Option handling macros. Examples include conditionally printing Option values, checking for specific values, and transforming the type of the contained value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_17\n\nLANGUAGE: move\nCODE:\n```\nfun examples(opt: Option<u64>) {\n    // print the value if it exists\n    inspect!(&opt, |x| std::debug::print(x));\n\n    // check if the value is 0\n    let is_zero = is_some_and!(&opt, |x| *x == 0);\n\n    // upcast the u64 to a u256\n    let str_opt = map!(opt, |x| x as u256);\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Unix Timestamp of Epoch Start in Sui Move\nDESCRIPTION: This code shows how to retrieve the Unix timestamp of the current epoch's start time in Sui Move. This can be useful for calculations based on the epoch's beginning.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/epoch-and-time.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nlet epoch_start = epoch::epoch_start_timestamp_ms(ctx);\n```\n\n----------------------------------------\n\nTITLE: Method Syntax with Move Macros\nDESCRIPTION: Demonstrates how macros can be called using method syntax and explains the difference in argument evaluation order. The example uses a 'maybe_s' macro to show this behavior.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_11\n\nLANGUAGE: move\nCODE:\n```\npublic struct S() has copy, drop;\npublic fun foo(): S { abort 0 }\npublic macro fun maybe_s($s: S, $cond: bool): S {\n    if ($cond) $s\n    else S()\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nmaybe_s!(foo(), false) // does not abort\n```\n\nLANGUAGE: move\nCODE:\n```\nfoo().maybe_s!(false) // aborts\n```\n\n----------------------------------------\n\nTITLE: Variable Shadowing in Move\nDESCRIPTION: Shows how variables can be shadowed by redeclaring them with the same name in a new scope.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/primitive-types.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nlet x = 42;\nlet x = true;\n```\n\n----------------------------------------\n\nTITLE: Using Move and Copy Operations in Move Language\nDESCRIPTION: This code shows the usage of move and copy operations in Move, demonstrating how they affect variable accessibility and value ownership.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_11\n\nLANGUAGE: move\nCODE:\n```\nlet x = 0;\nlet y = copy x + 1;\nlet z = copy x + 2;\n\nlet x = 1;\nlet y = move x + 1;\n//      ------ Local was moved here\nlet z = move x + 2; // Error!\n//      ^^^^^^ Invalid usage of local 'x'\ny + z\n```\n\n----------------------------------------\n\nTITLE: Enforcing One Time Witness Check in Move\nDESCRIPTION: Example demonstrating how to check if a type is a valid One Time Witness using the sui::types module's is_one_time_witness function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/one-time-witness.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/one-time-witness.move:usage}}\n```\n\n----------------------------------------\n\nTITLE: Out of Gas Error Testing in Move\nDESCRIPTION: Shows how to test for out of gas errors using the expected_failure annotation with out_of_gas option.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule pkg_addr::other_module {\n    public fun will_oog() { loop {} }\n}\n\nmodule pkg_addr::my_module {\n    use pkg_addr::other_module;\n    #[test]\n    #[expected_failure(out_of_gas, location = Self)]\n    fun test_will_oog_and_pass1() { loop {} }\n\n    #[test]\n    #[expected_failure(arithmetic_error, location = pkg_addr::other_module)]\n    fun test_will_oog_and_pass2() { other_module::will_oog() }\n\n    // FAIL: Will fail since the location we expect it the fail at is different from where\n    // the test actually failed.\n    #[test]\n    #[expected_failure(out_of_gas, location = Self)]\n    fun test_will_oog_and_fail() { other_module::will_oog() }\n}\n```\n\n----------------------------------------\n\nTITLE: Full Transaction Output for Sui Object Transfer\nDESCRIPTION: Complete transaction output from the Sui CLI showing the transaction digest, data, and effects. This demonstrates a successful object creation and transfer to the sender's address.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nTransaction Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8\n╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Data                                                                                             │\n├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │\n│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │\n│ Gas Budget: 100000000 MIST                                                                                  │\n│ Gas Price: 1000 MIST                                                                                         │\n│ Gas Payment:                                                                                                 │\n│  ┌──                                                                                                         │\n│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                                    │\n│  │ Version: 22                                                                                               │\n│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                                      │\n│  └──                                                                                                         │\n│                                                                                                              │\n│ Transaction Kind: Programmable                                                                               │\n│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │\n│ │ Input Objects                                                                                            │ │\n│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │\n│ │ 0   Pure Arg: Type: address, Value: \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\" │ │\n│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │\n│ ╭──────────────────────────────────────────────────────────────────────────────────╮                         │\n│ │ Commands                                                                         │                         │\n│ ├──────────────────────────────────────────────────────────────────────────────────┤                         │\n│ │ 0  MoveCall:                                                                     │                         │\n│ │  ┌                                                                               │                         │\n│ │  │ Function:  new                                                                │                         │\n│ │  │ Module:    todo_list                                                          │                         │\n│ │  │ Package:   0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe │                         │\n│ │  └                                                                               │                         │\n│ │                                                                                  │                         │\n│ │ 1  TransferObjects:                                                              │                         │\n│ │  ┌                                                                               │                         │\n│ │  │ Arguments:                                                                    │                         │\n│ │  │   Result 0                                                                    │                         │\n│ │  │ Address: Input  0                                                             │                         │\n│ │  └                                                                               │                         │\n│ ╰──────────────────────────────────────────────────────────────────────────────────╯                         │\n│                                                                                                              │\n│ Signatures:                                                                                                  │\n│    C5Lie4dtP5d3OkKzFBa+xM0BiNoB/A4ItthDCRTRBUrEE+jXeNs7mP4AuGwi3nzfTskh29+R1j1Kba4Wdy3QDA==                  │\n│                                                                                                              │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Effects                                                                               │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8                                              │\n│ Status: Success                                                                                   │\n│ Executed Epoch: 1213                                                                              │\n│                                                                                                   │\n│ Created Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 23                                                                                    │\n│  │ Digest: DuHTozDHMsuA7cFnWRQ1Gb8FQghAEBaj3inasJxqYq1c                                           │\n│  └──                                                                                              │\n│ Mutated Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 23                                                                                    │\n│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │\n│  └──                                                                                              │\n│ Gas Object:                                                                                       │\n│  ┌──                                                                                              │\n│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 23                                                                                    │\n│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │\n│  └──                                                                                              │\n│ Gas Cost Summary:                                                                                 │\n│    Storage Cost: 2318000 MIST                                                                     │\n│    Computation Cost: 1000000 MIST                                                                 │\n│    Storage Rebate: 978120 MIST                                                                    │\n│    Non-refundable Storage Fee: 9880 MIST                                                          │\n│                                                                                                   │\n│ Transaction Dependencies:                                                                         │\n│    FSz2fYXmKqTf77mFXNq5JK7cKY8agWja7V5yDKEgL8c3                                                   │\n│    GgMZKTt482DYApbAZkPDtdssGHZLbxgjm2uMXhzJax8Q                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n╭─────────────────────────────╮\n│ No transaction block events │\n╰─────────────────────────────╯\n\n╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                        │\n├───────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                      │\n│  ┌──                                                                                                  │\n│  │ ObjectID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                       │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │\n```\n\n----------------------------------------\n\nTITLE: Defining an Immutable Index Method for Matrix in Move\nDESCRIPTION: A valid implementation of an immutable index syntax method for a Matrix type that allows accessing elements using matrix[i, j] syntax.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\n#[syntax(index)]\npublic fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {\n    vector::borrow(vector::borrow(&s.v, i), j)\n}\n```\n\n----------------------------------------\n\nTITLE: Assignment with If Expression in Move\nDESCRIPTION: Using an if expression to assign a value to a variable based on a condition.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/conditionals.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet z = if (x < 100) x else 100;\n```\n\n----------------------------------------\n\nTITLE: Implementing Value Transfer\nDESCRIPTION: Demonstrates passing by value to transfer ownership of the Card using the recycle function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/references.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun recycle(card: Card) {\n    let Card { rides: _ } = card;\n}\n```\n\n----------------------------------------\n\nTITLE: Option Handling Macros with Lambda Functions in Move\nDESCRIPTION: Utility macros for working with Option types. 'inspect' conditionally applies a function to an Option's value, 'is_some_and' combines checking and predicate testing, and 'map' transforms an Option's inner value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_16\n\nLANGUAGE: move\nCODE:\n```\nmacro fun inspect<$T>($opt: &Option<$T>, $f: |&$T|) {\n    let opt = $opt;\n    if (opt.is_some()) $f(opt.borrow())\n}\n\nmacro fun is_some_and<$T>($opt: &Option<$T>, $f: |&$T| -> bool): bool {\n    let opt = $opt;\n    if (opt.is_some()) $f(opt.borrow())\n    else false\n}\n\nmacro fun map<$T, $U>($opt: Option<$T>, $f: |$T| -> $U): Option<$U> {\n    let opt = $opt;\n    if (opt.is_some()) {\n        option::some($f(opt.destroy_some()))\n    } else {\n        opt.destroy_none();\n        option::none()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Or-At Pattern Matching in Move\nDESCRIPTION: Demonstrates the use of or-at patterns in Move, which combine or-patterns with variable binding. The function test_or_at_pattern shows how to match and bind values in a single pattern.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nfun test_or_at_pattern(x: u64): u64 {\n    match (x) {\n        x @ (1 | 2 | 3) => x + 1,\n        y @ (4 | 5 | 6) => y + 2,\n        z => z + 3,\n    }\n}\ntest_or_pattern(2); // returns 3\ntest_or_pattern(5); // returns 7\ntest_or_pattern(70); // returns 73\n```\n\n----------------------------------------\n\nTITLE: Sharing Objects Using transfer::share_object\nDESCRIPTION: Function signature for sharing objects in Sui. Only accepts types with the 'key' ability, making the object publicly accessible as a mutable reference.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\npublic fun share_object<T: key>(obj: T);\n```\n\n----------------------------------------\n\nTITLE: Reading Transaction Context in Move\nDESCRIPTION: This snippet demonstrates how to read various fields from the TxContext using getter functions. It shows accessing sender address, transaction digest, epoch, and epoch timestamp.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/transaction-context.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/transaction-context.move:reading}}\n```\n\n----------------------------------------\n\nTITLE: Combining Index Expressions with Field Access in Move\nDESCRIPTION: Shows how index expressions can be combined with field accesses in more complex data structures.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\npublic struct V { v: vector<u64> }\n\npublic struct Vs { vs: vector<V> }\n\nfun borrow_first(input: &Vs): &u64 {\n    &input.vs[0].v[0]\n    // translates to `vector::borrow(&vector::borrow(&input.vs, 0).v, 0)`\n}\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Type Methods in Move 2024\nDESCRIPTION: Demonstrates the use of new methods associated with built-in types in Move 2024, such as 'to_string' for vectors and 'to_bytes' for addresses.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nfun aliases() {\n    // vector to string and ascii string\n    let str: String = b\"Hello, World!\".to_string();\n    let ascii: ascii::String = b\"Hello, World!\".to_ascii_string();\n\n    // address to bytes\n    let bytes = @0xa11ce.to_bytes();\n}\n```\n\n----------------------------------------\n\nTITLE: Object Type Definitions with Different Abilities\nDESCRIPTION: Definition of two object types: ObjectK with 'key' ability and ObjectKS with both 'key' and 'store' abilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/transfer-restrictions.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n/// Defines `ObjectK` and `ObjectKS` with `key` and `key + store`\n/// abilities respectively\nmodule book::transfer_a;\n\npublic struct ObjectK has key { id: UID }\npublic struct ObjectKS has key, store { id: UID }\n```\n\n----------------------------------------\n\nTITLE: Complex If Expression Blocks in Move\nDESCRIPTION: Using if expressions with multiple statements in expression blocks and chained conditions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/conditionals.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet maximum = if (x > y) x else y;\nif (maximum < 10) {\n    x = x + 10;\n    y = y + 10;\n} else if (x >= 10 && y >= 10) {\n    x = x - 10;\n    y = y - 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Restrictions on Move Equality Operations\nDESCRIPTION: This example demonstrates the restrictions on using equality operators with types that don't have the 'drop' ability in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example;\n\npublic struct Coin has store { value: u64 }\nfun invalid(c1: Coin, c2: Coin) {\n    c1 == c2 // ERROR!\n//  ^^    ^^ These assets would be destroyed!\n}\n```\n\n----------------------------------------\n\nTITLE: Cyclic Friend Declarations Causing Dependency Error in Move\nDESCRIPTION: This complex example illustrates how cyclic friend declarations can create invalid module dependencies, which are not allowed in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x2::a {\n    use 0x2::c;\n    friend 0x2::b;\n\n    public fun a() {\n        c::c()\n    }\n}\n\nmodule 0x2::b {\n    friend 0x2::c; // ERROR!\n//         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'\n}\n\nmodule 0x2::c {\n    public fun c() {}\n}\n```\n\n----------------------------------------\n\nTITLE: Phantom Type Parameters with Ability Constraints\nDESCRIPTION: Shows how to declare phantom type parameters with ability constraints.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_12\n\nLANGUAGE: move\nCODE:\n```\npublic struct S<phantom T: copy> {}\n```\n\n----------------------------------------\n\nTITLE: Configuring Sui Framework Addresses in TOML\nDESCRIPTION: Address configuration in the package manifest that exports two named addresses: 'sui' (0x2) and 'std' (0x1) from the standard dependency.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/sui-framework.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[addresses]\nsui = \"0x2\"\n\n# Exported from the MoveStdlib dependency\nstd = \"0x1\"\n```\n\n----------------------------------------\n\nTITLE: Implementing VecSet in Move for Unique Item Collections\nDESCRIPTION: Shows how to use the VecSet collection type to store unique items. The example demonstrates creating a VecSet, inserting elements, and checking if an element exists in the set.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/collections.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/collections-2.move:vec_set}}\n```\n\n----------------------------------------\n\nTITLE: Using Enum Increment Functions in Move\nDESCRIPTION: This snippet demonstrates how to use the previously defined enum increment functions to modify enum values. It shows the effect of calling these functions on different variants.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = SimpleEnum::Variant1(10);\nincr_enum_variant1(&mut x);\nassert!(x == SimpleEnum::Variant1(11));\n// Doesn't increment since it increments a different variant\nincr_enum_variant2(&mut x);\nassert!(x == SimpleEnum::Variant1(11));\n```\n\n----------------------------------------\n\nTITLE: Handling Orphaned Dynamic Fields in Move\nDESCRIPTION: Code demonstrating how dynamic fields can become orphaned when the parent object is deleted without properly removing its fields, resulting in inaccessible objects and unclaimed storage fees.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\npublic fun delete_character(character: Character) {\n    let Character { id, name } = character;\n    \n    // ⚠️ WARNING: This will orphan all dynamic fields attached to the `id`\n    object::delete(id);\n    string::remove(name);\n}\n```\n\n----------------------------------------\n\nTITLE: Function Constraint Examples\nDESCRIPTION: Examples demonstrating constraint checking in function definitions and calls.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_15\n\nLANGUAGE: move\nCODE:\n```\nfun unsafe_consume<T>(x: T) {\n    // ERROR! x does not have 'drop'\n}\n\nfun consume<T: drop>(x: T) {\n    // valid, x will be dropped automatically\n}\n\npublic struct NoAbilities {}\n\nfun foo() {\n    let r = NoAbilities {};\n    consume<NoAbilities>(NoAbilities);\n    //      ^^^^^^^^^^^ ERROR! NoAbilities does not have 'drop'\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Address to u256 in Move\nDESCRIPTION: Shows how to convert an address to a u256 type and back using the Sui Framework's address module. This conversion is possible because addresses are 32-byte values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/address.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nuse sui::address;\n\nlet addr = @0x1;\nlet addr_as_u256 = address::to_u256(addr);\nlet addr_again = address::from_u256(addr_as_u256);\n\nassert!(addr == addr_again, 0);\n```\n\n----------------------------------------\n\nTITLE: Converting Address to String in Move\nDESCRIPTION: Shows how to convert an address to a string representation using the Sui Framework's address module to_string function, useful for display purposes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/address.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nuse sui::address;\n\nlet addr = @0x1;\nlet addr_as_string = address::to_string(addr);\n\n// The string representation of @0x1 is \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n```\n\n----------------------------------------\n\nTITLE: Vector Bound Checking with Assert\nDESCRIPTION: Revised version of check_vec using assert instead of explicit abort condition.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector;\nfun check_vec(v: &vector<u64>, bound: u64) {\n    let i = 0;\n    let n = v.length();\n    while (i < n) {\n        let cur = v[i];\n        assert!(cur <= bound, 42); // Now uses 'assert'\n        i = i + 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Clock Object Structure in Sui Move\nDESCRIPTION: This snippet defines the Clock object structure in Sui Move. The Clock is a singleton shared object that exposes time to Move calls and is found at address 0x6. It can only be read via an immutable reference.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/epoch-and-time.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n// File: sui-framework/clock.move\n/// Singleton shared object that exposes time to Move calls.  This\n/// object is found at address 0x6, and can only be read (accessed\n/// via an immutable reference) by entry functions.\n///\n/// Entry Functions that attempt to accept `Clock` by mutable\n/// reference or value will fail to verify, and honest validators\n/// will not sign or execute transactions that use `Clock` as an\n/// input parameter, unless it is passed by immutable reference.\nstruct Clock has key {\n    id: UID,\n    /// The clock's timestamp, which is set automatically by a\n    /// system transaction every time consensus commits a\n    /// schedule, or by `sui::clock::increment_for_testing` during\n    /// testing.\n    timestamp_ms: u64,\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Automatic Borrowing in Move Equality Operations\nDESCRIPTION: This snippet showcases the automatic borrowing feature introduced in Move 2024 edition, where operands are automatically borrowed when comparing references with non-references.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nlet r = &0;\n\n// In all cases, `0` is automatically borrowed as `&0`\nr == 0; // `true`\n0 == r; // `true`\nr != 0; // `false`\n0 != r; // `false`\n```\n\n----------------------------------------\n\nTITLE: Reference Subtyping Examples in Move\nDESCRIPTION: Demonstrates reference subtyping rules in Move, showing valid and invalid assignments between mutable and immutable references.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/references.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmodule a::example {\n    fun read_and_assign(store: &mut u64, new_value: &u64) {\n        *store = *new_value\n    }\n\n    fun subtype_examples() {\n        let mut x: &u64 = &0;\n        let mut y: &mut u64 = &mut 1;\n\n        x = &mut 1; // valid\n        y = &2; // ERROR! invalid!\n\n        read_and_assign(y, x); // valid\n        read_and_assign(x, y); // ERROR! invalid!\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining One Time Witness in Move\nDESCRIPTION: Example showing how to define a One Time Witness type in Move. The type must have only 'drop' ability, no fields, not be generic, and be named after the module in uppercase.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/one-time-witness.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/one-time-witness.move:definition}}\n```\n\n----------------------------------------\n\nTITLE: Module Declaration with Address Literal in Move\nDESCRIPTION: Example showing a module declaration using a literal address rather than a named address. This approach directly specifies the blockchain address where the module will be published.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/module.md#2025-04-22_snippet_1\n\nLANGUAGE: Move\nCODE:\n```\nmodule 0x0::module;\n\n// Module members go here\n\n```\n\n----------------------------------------\n\nTITLE: Bag Usage Example\nDESCRIPTION: Example showing how to use a Bag collection as a struct field in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-collections.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/dynamic-collections.move:bag_struct}}\n```\n\n----------------------------------------\n\nTITLE: Admin Capability Initialization Pattern\nDESCRIPTION: Shows how to create a single AdminCap object during package initialization for application setup and admin control.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/capability.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/capability-2.move:admin_cap}}\n```\n\n----------------------------------------\n\nTITLE: Creating a Struct Instance in Move\nDESCRIPTION: Shows how to initialize a struct instance by setting values for its fields.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/struct.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nlet artist = Artist {\n    name: \"The Beatles\".to_string(),\n};\n```\n\n----------------------------------------\n\nTITLE: Aborting Execution with Abort Code in Move\nDESCRIPTION: This snippet demonstrates how to use the 'abort' keyword to abort a transaction with a specific abort code.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/assert-and-abort.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun main() {\n    abort 1\n}\n```\n\n----------------------------------------\n\nTITLE: Blocks as Expressions in Move\nDESCRIPTION: Demonstrates how blocks in Move are expressions that return the value of the last expression. Shows both standalone blocks and blocks assigned to variables.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/expression.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nfun block() {\n    // Block with a value\n    let x = {\n        let y = 1;\n        y + 2\n    };\n    assert!(x == 3, 0);\n\n    // Block with a single statement\n    let _ = {\n        1\n    };\n\n    // Block with multiple statements\n    let x = {\n        let a = 1;\n        let b = a + 1;\n        b * 2\n    };\n    assert!(x == 4, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining derive_id Function for Unique IDs in Move\nDESCRIPTION: This snippet shows the native function definition for derive_id, which is used internally to generate unique object IDs based on the transaction hash and the number of IDs created.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/transaction-context.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nnative fun derive_id(tx_hash: vector<u8>, ids_created: u64): address;\n```\n\n----------------------------------------\n\nTITLE: Importing External Modules in Move\nDESCRIPTION: This example shows how to import modules from external packages using aliases defined in the Move.toml file.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule example::using_std {\n    use std::vector;\n    use sui::object::{Self, UID};\n    use sui::tx_context::TxContext;\n\n    struct Example has key {\n        id: UID,\n        values: vector<u64>\n    }\n\n    public fun new(ctx: &mut TxContext): Example {\n        Example {\n            id: object::new(ctx),\n            values: vector::empty()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Table Implementation Example\nDESCRIPTION: Demonstration of Table collection usage with specific implementation details.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-collections.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/dynamic-collections.move:table_usage}}\n```\n\n----------------------------------------\n\nTITLE: Resolving Name Conflicts in Move Imports\nDESCRIPTION: This snippet shows how to use the 'as' keyword to rename imported members and resolve name conflicts.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmodule example::resolving_conflicts {\n    use std::vector;\n    use sui::vec_map;\n\n    use std::vector::length as vec_len;\n    use sui::vec_map::size as map_size;\n\n    public fun compare_sizes(v: &vector<u64>, m: &vec_map::VecMap<u64, u64>): bool {\n        vec_len(v) == map_size(m)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Default Else Clause in Move\nDESCRIPTION: Demonstration of implicit and explicit unit value () in else clauses.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/conditionals.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nif (condition) true_branch // implied default: else ()\nif (condition) true_branch else ()\n```\n\n----------------------------------------\n\nTITLE: Defining Module Members in Move\nDESCRIPTION: Example demonstrating declaration of various module members including a struct, function, and constant. These components form the building blocks of a module's functionality.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/module.md#2025-04-22_snippet_3\n\nLANGUAGE: Move\nCODE:\n```\nmodule book::module_members;\n\n// This is a struct declaration\nstruct Donut has drop {\n    weight: u64\n}\n\n// This is a function declaration\npublic fun create(weight: u64): Donut {\n    Donut { weight }\n}\n\n// This is a constant declaration\nconst MAX_WEIGHT: u64 = 100;\n\n```\n\n----------------------------------------\n\nTITLE: Defining TxContext Struct in Move\nDESCRIPTION: This snippet shows the definition of the TxContext struct in the sui::tx_context module. It contains fields for sender address, transaction hash, epoch number, epoch timestamp, and a counter for created IDs.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/transaction-context.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nstruct TxContext has drop {\n    sender: address,\n    tx_hash: vector<u8>,\n    epoch: u64,\n    epoch_timestamp_ms: u64,\n    ids_created: u64\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Assignments in Move\nDESCRIPTION: This code demonstrates how to perform assignments in Move, including pattern-based assignments and modifications through references.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example;\n\npublic struct X { f: u64 }\n\nfun new_x(): X {\n    X { f: 1 }\n}\n\nfun example() {\n    let (mut x, mut y, mut f, mut g) = (0, 0, 0, 0);\n\n    (X { f }, X { f: x }) = (new_x(), new_x());\n    assert!(f + x == 2, 42);\n\n    (x, y, f, _, g) = (0, 0, 0, 0, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Borrowing Operator for Custom Types in Move 2024\nDESCRIPTION: Demonstrates how to implement the borrowing operator for custom types in Move 2024 using the '#[syntax(index)]' attribute.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\n#[syntax(index)]\npublic fun borrow(c: &List<T>, key: String): &T { /* ... */ }\n\n#[syntax(index)]\npublic fun borrow_mut(c: &mut List<T>, key: String): &mut T { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Defining Mutable Index Syntax for Vector in Move\nDESCRIPTION: Shows the declaration of a mutable index syntax method for the standard vector type in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\n#[syntax(index)]\npublic native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;\n```\n\n----------------------------------------\n\nTITLE: Generic Add One Macro\nDESCRIPTION: Example of a simple macro function that adds one to a generic type T.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmacro fun add_one<$T>($x: $T): $T {\n    $x + 1\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a UID in Sui Move\nDESCRIPTION: Shows the lifecycle of a UID, including creation within a Character struct and subsequent deletion after unpacking the struct.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/uid-and-id.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet ctx = &mut tx_context::dummy();\n\nlet char = Character {\n    id: object::new(ctx)\n};\n\nlet Character { id } = char;\nid.delete();\n```\n\n----------------------------------------\n\nTITLE: Invalid Recursive Struct Examples\nDESCRIPTION: Examples of invalid recursive struct definitions that are not allowed in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_17\n\nLANGUAGE: move\nCODE:\n```\npublic struct Foo<T> {\n    x: Foo<u64> // ERROR! 'Foo' containing 'Foo'\n}\n\npublic struct Bar<T> {\n    x: Bar<T> // ERROR! 'Bar' containing 'Bar'\n}\n\n// ERROR! 'A' and 'B' forming a cycle, which is not allowed either.\npublic struct A<T> {\n    x: B<T, u64>\n}\n\npublic struct B<T1, T2> {\n    x: A<T1>\n    y: A<T2>\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Copy Ability Implementation\nDESCRIPTION: Shows how to use Copy ability both implicitly and explicitly with a Copyable type instance.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/copy-ability.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n#[test]\nfun test_copy() {\n    let a = Copyable { value: 10 };\n    let b = a;\n    let c = *&a;\n    let Copyable {} = a;\n    let Copyable {} = b;\n    let Copyable {} = c;\n}\n```\n\n----------------------------------------\n\nTITLE: Hygiene in Move Macros\nDESCRIPTION: Demonstrates how Move macros maintain hygiene by preventing accidental variable capture from different scopes. The example shows how variables are renamed during expansion to avoid conflicts.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\nmacro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {\n    let x = $x;\n    $f(x, x)\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nlet sum = {\n    let x#1 = { foo() };\n    {\n        let x#2 = { x#1 };\n        let y#2 = { x#1 };\n        { x#2 + y#2 }\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Block Comments in Move\nDESCRIPTION: Shows how to use block comments in Move using /* */ syntax. Demonstrates multi-line commenting and partial line commenting capabilities.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/comments.md#2025-04-22_snippet_1\n\nLANGUAGE: Move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/comments-block.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Member Alias Usage Example\nDESCRIPTION: Example demonstrating how to use member aliases for functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector::push_back;\nuse std::option::some as s;\n\nfun new_vec(): vector<std::option::Option<u8>> {\n    let mut v = vector[];\n    vector::push_back(&mut v, s(0));\n    vector::push_back(&mut v, std::option::none());\n    v\n}\n```\n\n----------------------------------------\n\nTITLE: Basic BCS Decoding Example\nDESCRIPTION: Demonstrates basic BCS decoding using the wrapper API for primitive types.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/bcs.move:decode}}\n```\n\n----------------------------------------\n\nTITLE: Line Comments in Move\nDESCRIPTION: Demonstrates the usage of single-line comments in Move using double slashes (//). Shows how to add explanatory notes that get ignored by the compiler.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/comments.md#2025-04-22_snippet_0\n\nLANGUAGE: Move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/comments-line.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Running Move Tests\nDESCRIPTION: Demonstrates how to run Move tests using the Sui Move CLI, including options for running specific tests or all tests in a package.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nsui move test\n```\n\n----------------------------------------\n\nTITLE: Entry Functions in Move\nDESCRIPTION: Demonstrates the use of entry modifier for functions that can serve as execution entry points.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m {\n    entry fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid!\n}\n\nmodule a::n {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Shop Price Constant in Move\nDESCRIPTION: Example showing how to define a constant price value in a Move module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/constants.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/constants-shop-price.move:shop_price}}\n```\n\n----------------------------------------\n\nTITLE: Using Publisher object for type authority in Move\nDESCRIPTION: Demonstration of using the Publisher object to prove authority over a type using package::from_package and package::from_module functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/publisher.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\npublic fun prove_type<T>(publisher: &Publisher) {\n    assert!(package::from_package<T>(publisher), 0);\n}\n\npublic fun prove_same_module<T>(publisher: &Publisher) {\n    assert!(package::from_module<T>(publisher), 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Limitations of Guard Expressions in Move\nDESCRIPTION: Illustrates limitations of guard expressions in Move pattern matching, particularly regarding mutability. The examples show that variables are only available as immutable references in guards, regardless of the original pattern.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_14\n\nLANGUAGE: move\nCODE:\n```\nfun incr(x: &mut u64) {\n    *x = *x + 1;\n}\n\nfun match_with_guard_incr(x: u64): u64 {\n    match (x) {\n        x if ({ incr(&mut x); x == 1 }) => 1,\n        // ERROR:    ^^^ invalid borrow of immutable value\n        _ => 2,\n    }\n}\n\nfun match_with_guard_incr2(x: &mut u64): u64 {\n    match (x) {\n        x if ({ incr(&mut x); x == 1 }) => 1,\n        // ERROR:    ^^^ invalid borrow of immutable value\n        _ => 2,\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: For Reference Macro Implementation in Move\nDESCRIPTION: Macro implementation for iterating over vector elements, used to demonstrate labeled control flow with macros.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/labeled-control-flow.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmacro fun for_ref<$T>($vs: &vector<$T>, $f: |&$T|) {\n    let vs = $vs;\n    let mut i = 0;\n    let end = vs.length();\n    while (i < end) {\n        $f(vs.borrow(i));\n        i = i + 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Move Unit Tests\nDESCRIPTION: Executes the Move unit tests in the current package using the 'sui move test' command.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move test\n```\n\n----------------------------------------\n\nTITLE: Module Abort Example\nDESCRIPTION: Demonstrates how abort codes are handled at the module level and propagated through function calls.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x2::example {\n    public fun aborts() {\n        abort 42\n    }\n}\n\nmodule 0x3::invoker {\n    public fun always_aborts() {\n        0x2::example::aborts()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Assigned Named Addresses in Move.toml\nDESCRIPTION: Demonstrates how to declare a named address with a specific value in Move.toml, which cannot be changed by importing packages.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"example_pkg\"\n...\n[addresses]\nnamed_addr = \"0xCAFE\"\n```\n\n----------------------------------------\n\nTITLE: Reading Current Time from Clock Object in Sui Move\nDESCRIPTION: This code demonstrates how to read the current time in milliseconds since the Unix Epoch using the Clock object in Sui Move. It uses the timestamp_ms function from the sui::clock module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/epoch-and-time.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nlet clock = clock::clock();\nlet time = clock::timestamp_ms(clock);\n```\n\n----------------------------------------\n\nTITLE: If-Else Expression in Move\nDESCRIPTION: Conditional expression with both true and false branches that modifies a value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/conditionals.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nif (y <= 10) y = y + 1 else y = 10\n```\n\n----------------------------------------\n\nTITLE: Vector Error Testing in Move\nDESCRIPTION: Demonstrates testing vector operations that are expected to fail, including specifying minor status codes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmodule pkg_addr::other_module {\n    public fun vector_borrow_empty() {\n        &vector<u64>[][1];\n    }\n}\n\nmodule pkg_addr::my_module {\n    #[test]\n    #[expected_failure(vector_error, location = Self)]\n    fun vector_abort_same_module() {\n        vector::borrow(&vector<u64>[], 1);\n    }\n\n    #[test]\n    #[expected_failure(vector_error, location = pkg_addr::other_module)]\n    fun vector_abort_same_module() {\n        other_module::vector_borrow_empty();\n    }\n\n    // Can specify minor statues (i.e., vector-specific error codes) to expect.\n    #[test]\n    #[expected_failure(vector_error, minor_status = 1, location = Self)]\n    fun native_abort_good_right_code() {\n        vector::borrow(&vector<u64>[], 1);\n    }\n\n    // FAIL: correct error, but wrong location.\n    #[test]\n    #[expected_failure(vector_error, location = pkg_addr::other_module)]\n    fun vector_abort_same_module() {\n        other_module::vector_borrow_empty();\n    }\n\n    // FAIL: correct error and location but the minor status differs so this test will fail.\n    #[test]\n    #[expected_failure(vector_error, minor_status = 0, location = Self)]\n    fun vector_abort_wrong_minor_code() {\n        vector::borrow(&vector<u64>[], 1);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Labeled Block with Named Return in Move\nDESCRIPTION: Example demonstrating labeled blocks for non-local control flow, using named returns to exit blocks with specific values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/labeled-control-flow.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nfun named_return(n: u64): vector<u8> {\n    let x = 'a: {\n        if (n % 2 == 0) {\n            return 'a b\"even\"\n        };\n        b\"odd\"\n    };\n    x\n}\n```\n\n----------------------------------------\n\nTITLE: Dependency Override Configuration\nDESCRIPTION: Example showing how to override conflicting dependency versions using the override field.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/manifest.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nExample = { override = true, git = \"https://github.com/example/example.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\n```\n\n----------------------------------------\n\nTITLE: Unused Type Parameters in Move Structs\nDESCRIPTION: This example demonstrates the use of unused type parameters in Move struct definitions, which can be useful for modeling certain concepts.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\npublic struct Foo<T> {\n    foo: u64\n}\n\nmodule a::m;\n\n// Currency Specifiers\npublic struct A {}\npublic struct B {}\n\n// A generic coin type that can be instantiated using a currency\n// specifier type.\n//   e.g. Coin<A>, Coin<B> etc.\npublic struct Coin<Currency> has store {\n    value: u64\n}\n\n// Write code generically about all currencies\npublic fun mint_generic<Currency>(value: u64): Coin<Currency> {\n    Coin { value }\n}\n\n// Write code concretely about one currency\npublic fun mint_a(value: u64): Coin<A> {\n    mint_generic(value)\n}\npublic fun mint_b(value: u64): Coin<B> {\n    mint_generic(value)\n}\n```\n\n----------------------------------------\n\nTITLE: TodoList Object JSON Representation\nDESCRIPTION: Shows the JSON output of the TodoList object query, which includes all metadata and the list items. This format clearly shows the structure of the Move object with its fields and values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_26\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"objectId\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\",\n  \"version\": \"24\",\n  \"digest\": \"FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ\",\n  \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n  \"owner\": {\n    \"AddressOwner\": \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\"\n  },\n  \"previousTransaction\": \"EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1\",\n  \"storageRebate\": \"1558000\",\n  \"content\": {\n    \"dataType\": \"moveObject\",\n    \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n    \"hasPublicTransfer\": true,\n    \"fields\": {\n      \"id\": {\n        \"id\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\"\n      },\n      \"items\": [\"Finish the Hello, Sui chapter\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Structs with Different Abilities in Move\nDESCRIPTION: Defines two structs with different abilities: Foo with copy, drop, and store abilities, and Coin with only store ability. These structs are used to demonstrate different move semantics.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_12\n\nLANGUAGE: move\nCODE:\n```\npublic struct Foo has copy, drop, store { f: u64 }\npublic struct Coin has store { value: u64 }\n```\n\n----------------------------------------\n\nTITLE: Unpacking Immutable Tuple Return Values in Move\nDESCRIPTION: This code shows how to unpack multiple return values from a function into immutable variables using tuple destructuring syntax.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/function.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nfun test_sum_and_product() {\n    let (sum, product) = sum_and_product(2, 3);\n    assert!(sum == 5, 0);\n    assert!(product == 6, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Unique Object Addresses in Move\nDESCRIPTION: This snippet defines the fresh_object_address function, which wraps the derive_id function to generate unique object addresses. It increments the ids_created counter in the TxContext.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/transaction-context.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\npublic fun fresh_object_address(ctx: &mut TxContext): address {\n    let ids_created = ctx.ids_created;\n    let id = derive_id(*&ctx.tx_hash, ids_created);\n    ctx.ids_created = ids_created + 1;\n    id\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Address to Bytes in Move\nDESCRIPTION: Demonstrates conversion between an address and a vector<u8> (byte array) using the Sui Framework's address module functions to_bytes and from_bytes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/address.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nuse sui::address;\n\nlet addr = @0x1;\nlet addr_as_bytes = address::to_bytes(addr);\nlet addr_again = address::from_bytes(addr_as_bytes);\n\nassert!(addr == addr_again, 0);\n```\n\n----------------------------------------\n\nTITLE: Type Annotations for Local Variables in Move\nDESCRIPTION: This snippet shows how to use explicit type annotations for local variables in Move, which can improve readability and clarity.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/variables.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule 0::example {\n\n    public struct S { f: u64, g: u64 }\n\n    fun annotated() {\n        let u: u8 = 0;\n        let b: vector<u8> = b\"hello\";\n        let a: address = @0x0;\n        let (x, y): (&u64, &mut u64) = (&0, &mut 1);\n        let S { f, g: f2 }: S = S { f: 0, g: 1 };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Macro Expansion with Multiple Argument Usage in Move\nDESCRIPTION: Shows how a macro that uses an argument multiple times expands, potentially causing multiple evaluations of the same expression. The 'dup' macro demonstrates this behavior.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nmacro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {\n    $f($x, $x)\n}\n```\n\nLANGUAGE: move\nCODE:\n```\nlet sum = dup!(|x, y| x + y, foo());\n```\n\nLANGUAGE: move\nCODE:\n```\nlet sum = {\n    let x = { foo() };\n    let y = { foo() };\n    { x + y }\n};\n```\n\n----------------------------------------\n\nTITLE: Running Move Migration Tool in Bash\nDESCRIPTION: Demonstrates how to use the Move CLI migration tool to update code to the new edition. The command updates syntax for 'let mut', 'public' struct modifier, and 'public(package)' function visibility.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move migrate\n```\n\n----------------------------------------\n\nTITLE: Variable-Path Execution with Hot Potato in Move\nDESCRIPTION: Example of a phone shop implementation that uses the Hot Potato pattern to decouple purchase from payment, creating a modular and maintainable approach to transactions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/hot-potato-pattern.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule phone_shop {\n    // Basic phone struct\n    struct Phone has key, store { id: UID /* ... */ }\n\n    // The \"hot potato\" - neither stored nor dropped\n    struct Ticket { phone_id: ID }\n\n    /// Take a phone from the shop (creates a responsibility to pay)\n    public fun take_phone(shop: &mut Shop, ctx: &mut TxContext): (Phone, Ticket) {\n        // ... phone creation logic ...\n        let phone = Phone { id: object::new(ctx) /* ... */ };\n        // Return both the phone and the ticket\n        (phone, Ticket { phone_id: object::id(&phone) })\n    }\n\n    /// Pay with bonus points\n    public fun pay_with_points(shop: &mut Shop, points: &mut Points, ticket: Ticket) {\n        let Ticket { phone_id } = ticket; // consume the ticket\n        points_system::spend(points, PHONE_COST_IN_POINTS);\n        // Register purchase in the shop's system\n        record_purchase(shop, phone_id, PAYMENT_TYPE_POINTS)\n    }\n\n    /// Pay with USD\n    public fun pay_with_usd(shop: &mut Shop, coin: Coin<SUI>, ticket: Ticket, ctx: &mut TxContext) {\n        let Ticket { phone_id } = ticket; // consume the ticket\n        assert!(coin::value(&coin) >= PHONE_COST_IN_SUI, EInsufficientFunds);\n        // Handle payment\n        shop_balance::add(&mut shop.balance, coin);\n        // Register purchase\n        record_purchase(shop, phone_id, PAYMENT_TYPE_USD)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Valid Module Names in Move\nDESCRIPTION: Shows examples of valid module names in Move. Module names can start with a lowercase or uppercase letter and can contain underscores and numbers after the first character.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/modules.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule a::my_module {}\nmodule a::foo_bar_42 {}\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables\nDESCRIPTION: Commands to set package ID and user address as environment variables\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nexport PACKAGE_ID=0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe\nexport MY_ADDRESS=$(sui client active-address)\n```\n\n----------------------------------------\n\nTITLE: Displaying Sui Transaction Effects Output\nDESCRIPTION: Demonstrates the effects and results of a transaction execution including created objects, mutated objects, gas usage details, and transaction dependencies. Shows the complete state changes caused by the transaction on the Sui network.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Effects                                                                               │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW                                              │\n│ Status: Success                                                                                   │\n│ Executed Epoch: 411                                                                               │\n│                                                                                                   │\n│ Created Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                           │\n│  └──                                                                                              │\n│  ┌──                                                                                              │\n│  │ ID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                         │\n│  │ Owner: Immutable                                                                               │\n│  │ Version: 1                                                                                     │\n│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                           │\n│  └──                                                                                              │\n│ Mutated Objects:                                                                                  │\n│  ┌──                                                                                              │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │\n│  └──                                                                                              │\n│ Gas Object:                                                                                       │\n│  ┌──                                                                                              │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ Version: 8                                                                                     │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │\n│  └──                                                                                              │\n│ Gas Cost Summary:                                                                                 │\n│    Storage Cost: 10404400 MIST                                                                    │\n│    Computation Cost: 1000000 MIST                                                                 │\n│    Storage Rebate: 978120 MIST                                                                    │\n│    Non-refundable Storage Fee: 9880 MIST                                                          │\n│                                                                                                   │\n│ Transaction Dependencies:                                                                         │\n│    7Ukrc5GqdFqTA41wvWgreCdHn2vRLfgQ3YMFkdks72Vk                                                   │\n│    7d4amuHGhjtYKujEs9YkJARzNEn4mRbWWv3fn4cdKdyh                                                   │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Macro Usage Examples with Map\nDESCRIPTION: Examples showing how to use the map macro with different lambda expressions and type annotations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nlet v = vector[1, 2, 3];\nlet doubled: vector<u64> = map!(v, |x| 2 * x);\nlet bytes: vector<vector<u8>> = map!(v, |x| std::bcs::to_bytes(&x));\n```\n\n----------------------------------------\n\nTITLE: Declaring Friends Using Fully Qualified Module Name in Move\nDESCRIPTION: This snippet demonstrates how to declare a friend module using a fully qualified module name. Module 'b' is declared as a friend of module 'a'.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::a {\n    friend 0x42::b;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fast Path in Sui Move\nDESCRIPTION: This code snippet demonstrates a practical implementation of Sui's fast path mechanism. It shows how transactions that only interact with owned objects can take the fast path and avoid consensus, while those interacting with shared objects require consensus for execution.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/fast-path.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/fast-path.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Documentation Comments in Move\nDESCRIPTION: Illustrates the usage of documentation comments starting with /// for generating code documentation. These comments are placed before the definition of items they document.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/comments.md#2025-04-22_snippet_2\n\nLANGUAGE: Move\nCODE:\n```\n{{#include ../../../packages/samples/sources/move-basics/comments-doc.move:main}}\n```\n\n----------------------------------------\n\nTITLE: Overflow Prevention in Move\nDESCRIPTION: Demonstrates how to prevent overflow when working with integer types by casting to larger types before operations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/primitive-types.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nlet x: u64 = 255;\nlet y: u64 = (x as u128 + 1u128 as u64);\n```\n\n----------------------------------------\n\nTITLE: Tuple Destructuring in Move\nDESCRIPTION: Examples of tuple destructuring in let bindings and assignments. Demonstrates destructuring of tuples with different sizes and from function returns.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/tuples.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::example;\n\n// all 3 of these functions are equivalent\nfun returns_unit() {}\nfun returns_2_values(): (bool, bool) { (true, false) }\nfun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) { (x, 0, 1, b\"foobar\") }\n\nfun examples(cond: bool) {\n    let () = ();\n    let (mut x, mut y): (u8, u64) = (0, 1);\n    let (mut a, mut b, mut c, mut d) = (@0x0, 0, false, b\"\");\n\n    () = ();\n    (x, y) = if (cond) (1, 2) else (3, 4);\n    (a, b, c, d) = (@0x1, 1, true, b\"1\");\n}\n\nfun examples_with_function_calls() {\n    let () = returns_unit();\n    let (mut x, mut y): (bool, bool) = returns_2_values();\n    let (mut a, mut b, mut c, mut d) = returns_4_values(&0);\n\n    () = returns_unit();\n    (x, y) = returns_2_values();\n    (a, b, c, d) = returns_4_values(&1);\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Move 2024 Edition in Configuration File\nDESCRIPTION: Shows how to specify the Move 2024 edition in the move configuration file. The 'edition' keyword is used with either '2024' or '2024.beta' for new features.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nedition = \"2024\"\n# alternatively, for new features:\nedition = \"2024.beta\"\n```\n\n----------------------------------------\n\nTITLE: Adding 'public' Visibility to Structs in Move 2024\nDESCRIPTION: Shows how to add the 'public' visibility modifier to structs in Move 2024, which is now required for struct declarations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\n// Move 2020\nstruct Book {}\n\n// Move 2024\npublic struct Book {}\n```\n\n----------------------------------------\n\nTITLE: Multiple Member Aliasing\nDESCRIPTION: Example showing how to create multiple aliases in a single use statement.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nuse std::vector::push_back;\nuse std::option::{some as s, none as n};\n\nfun new_vec(): vector<std::option::Option<u8>> {\n    let mut v = vector[];\n    push_back(&mut v, s(0));\n    push_back(&mut v, n());\n    v\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Subtyping with References in Move\nDESCRIPTION: Demonstrates subtyping behavior of tuples with references in Move. Shows valid and invalid subtype relationships based on reference mutability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/tuples.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet x: &u64 = &0;\nlet y: &mut u64 = &mut 1;\n\n// (&u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (a, b): (&u64, &u64) = (x, y);\n\n// (&mut u64, &mut u64) is a subtype of (&u64, &u64)\n// since &mut u64 is a subtype of &u64\nlet (c, d): (&u64, &u64) = (y, y);\n\n// ERROR! (&u64, &mut u64) is NOT a subtype of (&mut u64, &mut u64)\n// since &u64 is NOT a subtype of &mut u64\nlet (e, f): (&mut u64, &mut u64) = (x, y);\n```\n\n----------------------------------------\n\nTITLE: Executing Sui Client Objects Command\nDESCRIPTION: This command is used to list objects associated with the current Sui client account. It's useful for verifying the creation of new objects like TodoList.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client objects\n```\n\n----------------------------------------\n\nTITLE: Module Naming Convention in Move\nDESCRIPTION: Demonstrates proper module naming using snake_case with descriptive but concise names.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/coding-conventions.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::conventions { /* ... */ }\nmodule book::common_practices { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Declaring Friends Using Module Name Alias in Move\nDESCRIPTION: This example shows how to declare a friend module using a module name alias. The 'b' module is imported with a 'use' statement and then declared as a friend.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::a {\n    use 0x42::b;\n    friend b;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Hot Potato Struct in Move\nDESCRIPTION: Definition of a basic Hot Potato struct called Request without any abilities, making it impossible to store, copy, or drop.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/hot-potato-pattern.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nstruct Request {\n    amount: u64,\n    creator: address\n}\n```\n\n----------------------------------------\n\nTITLE: Module Declaration with Block Syntax in Move\nDESCRIPTION: Example of the older module block syntax using curly braces, required for defining multiple modules in a single file. This syntax is a legacy approach from pre-2024 editions of Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/module.md#2025-04-22_snippet_4\n\nLANGUAGE: Move\nCODE:\n```\nmodule 0x0::module {\n\n    // This is a struct declaration\n    struct Donut has drop {\n        weight: u64\n    }\n\n    // This is a function declaration\n    public fun create(weight: u64): Donut {\n        Donut { weight }\n    }\n\n    // This is a constant declaration\n    const MAX_WEIGHT: u64 = 100;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Enum Overwrite Function in Move\nDESCRIPTION: This snippet shows how to use the previously defined enum overwrite function. It demonstrates the effect of calling this function on an enum value.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_11\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = X::B(20);\noverwrite_enum(&mut x);\nassert!(x == X::A(10));\n```\n\n----------------------------------------\n\nTITLE: Implementing Sum Function Using Loop Expression in Move\nDESCRIPTION: This snippet shows how to use a loop expression with break to compute the sum of numbers from 1 to n in Move. It demonstrates the use of break to exit the loop when the condition is met.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/loops.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nfun sum(n: u64): u64 {\n    let mut sum = 0;\n    let mut i = 1;\n\n    loop {\n       i = i + 1;\n       if (i >= n) break;\n       sum = sum + i;\n    };\n\n    sum\n}\n```\n\n----------------------------------------\n\nTITLE: Decoding Clever Abort Codes\nDESCRIPTION: Pseudocode implementation showing how to decode clever abort codes into human-readable error messages.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert/clever-errors.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// Information available in the MoveAbort\nlet clever_abort_code: u64 = ...;\nlet (package_id, module_name): (PackageStorageId, ModuleName) = ...;\n\nlet is_clever_abort = (clever_abort_code & 0x8000_0000_0000_0000) != 0;\n\nif is_clever_abort {\n    // Get line number, identifier index, and constant index\n    // Identifier and constant index are sentinel values if set to '0xffff'\n    let line_number = ((clever_abort_code & 0x0000_ffff_0000_0000) >> 32) as u16;\n    let identifier_index = ((clever_abort_code & 0x0000_0000_ffff_0000) >> 16) as u16;\n    let constant_index = ((clever_abort_code & 0x0000_0000_0000_ffff)) as u16;\n\n    // Print the line error message\n    print!(\"Error from '{}::{}' (line {})\", package_id, module_name, line_number);\n\n    // No need to print anything or load the module if both are sentinel values\n    if identifier_index == 0xffff && constant_index == 0xffff {\n        return;\n    }\n\n    // Only needed if constant name and value are not 0xffff\n    let module: CompiledModule = fetch_module(package_id, module_name);\n\n    // Print the constant name (if any)\n    if identifier_index != 0xffff {\n        let constant_name = module.get_identifier_at_table_index(identifier_index);\n        print!(\", '{}'\", constant_name);\n    }\n\n    // Print the constant value (if any)\n    if constant_index != 0xffff {\n        let constant_value = module.get_constant_at_table_index(constant_index).deserialize_on_constant_type().to_string();\n        print!(\": {}\", constant_value);\n    }\n\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Dependency Configuration Examples\nDESCRIPTION: Examples showing how to specify dependencies using git repository URLs or local directory paths.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/manifest.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n# git repository\nExample = { git = \"https://github.com/example/example.git\", subdir = \"path/to/package\", rev = \"framework/testnet\" }\n\n# local directory\nMyPackage = { local = \"../my-package\" }\n```\n\n----------------------------------------\n\nTITLE: Constant Naming Examples\nDESCRIPTION: Examples of valid constant names following Move naming conventions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/constants.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nconst FLAG: bool = false;\nconst EMyErrorCode: u64 = 0;\nconst ADDRESS_42: address = @0x42;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating VecSet Comparison Limitations in Move\nDESCRIPTION: Shows the limitations of comparing VecSet instances. The example demonstrates how comparing two VecSets with the same elements can fail due to insertion order differences.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/collections.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/collections-4.move:vec_set_comparison}}\n```\n\n----------------------------------------\n\nTITLE: Displaying TodoList Object Information\nDESCRIPTION: This snippet shows the output of the 'sui client objects' command, specifically displaying information about a newly created TodoList object including its ID, version, digest, and type.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_20\n\nLANGUAGE: plaintext\nCODE:\n```\n╭  ...                                                                                  ╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │\n│ │ version    │  22                                                                  │ │\n│ │ digest     │  /DUEiCLkaNSgzpZSq2vSV0auQQEQhyH9occq9grMBZM=                        │ │\n│ │ objectType │  0x468d..29fe::todo_list::TodoList                                   │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n|  ...                                                                                  |\n```\n\n----------------------------------------\n\nTITLE: Implementing an Infinite Loop in Move\nDESCRIPTION: This snippet shows how to create an infinite loop using the loop keyword in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = 0;\nloop {\n    x = x + 1;\n};\n```\n\n----------------------------------------\n\nTITLE: Ability Constraints in Pattern Matching in Move\nDESCRIPTION: Demonstrates ability constraints in pattern matching for Move, particularly focusing on the 'drop' ability. The examples show how the compiler enforces restrictions on matching non-droppable values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/pattern-matching.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\npublic struct NonDrop(u64)\n\nfun drop_nondrop(x: NonDrop) {\n    match (x) {\n        NonDrop(1) => 1,\n        _ => 2\n        // ERROR: cannot wildcard match on a non-droppable value\n    }\n}\n\nfun destructure_nondrop(x: NonDrop) {\n    match (x) {\n        NonDrop(1) => 1,\n        NonDrop(_) => 2\n        // OK!\n    }\n}\n\nfun use_nondrop(x: NonDrop): NonDrop {\n    match (x) {\n        NonDrop(1) => NonDrop(8),\n        x => x\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Consuming a Hot Potato in Move\nDESCRIPTION: Implementation of functions to create and consume a Hot Potato, demonstrating how such structures must be explicitly unpacked by their module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/hot-potato-pattern.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\npublic fun new_request(amount: u64, creator: address): Request {\n    Request { amount, creator }\n}\n\npublic fun fulfill_request(req: Request): (u64, address) {\n    let Request { amount, creator } = req;\n    (amount, creator)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Infinite while Loop in Move\nDESCRIPTION: This example demonstrates how to create an infinite while loop in Move, which is equivalent to a loop statement.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = 0;\nwhile (true) {\n    x = x + 1;\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Macro Function Syntax in Move\nDESCRIPTION: Shows the general syntax pattern for declaring macro functions in Move. Parameters and type parameters must start with $.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n<visibility>? macro fun <identifier><[$type_parameters: constraint],*>([$identifier: type],*): <return_type> <function_body>\n```\n\n----------------------------------------\n\nTITLE: Move Lock File Core Section\nDESCRIPTION: Structure of the core [move] section in Move.lock file containing version, manifest digest, and dependency information.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_11\n\nLANGUAGE: ini\nCODE:\n```\n[move]\nversion = <string> # Lock file version, used for backwards compatibility checking.\nmanifest_digest = <hash> # Sha3-256 hash of the Move.toml file that was used to generate this lock file.\ndeps_digest = <hash> # Sha3-256 hash of the Move.lock file of all dependencies. If no dependencies are present, this will be an empty string.\ndependencies = { (name = <string>)* } # List of dependencies. Not present if there are no dependencies.\n```\n\n----------------------------------------\n\nTITLE: Assertions Without Abort Codes in Move\nDESCRIPTION: Shows how assertions and abort statements without explicit codes automatically derive abort codes from source line numbers.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert/clever-errors.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::a_module;\n\n#[test]\nfun assert_false(x: bool) {\n    assert!(false);\n}\n\n#[test]\nfun abort_no_code() {\n    abort\n}\n```\n\n----------------------------------------\n\nTITLE: Method Alias Usage Example\nDESCRIPTION: Shows how to create and use method aliases with the use fun syntax.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmodule b::example;\n\nuse fun a::cup::cup_borrow as Cup.borrow;\nuse fun a::cup::cup_value as Cup.value;\nuse fun a::cup::cup_swap as Cup.set;\n\nfun example(c: &mut Cup<u64>) {\n    let _ = c.borrow(); // resolves to a::cup::cup_borrow\n    let v = c.value(); // resolves to a::cup::cup_value\n    c.set(v * 2); // resolves to a::cup::cup_swap\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Constant Value Examples\nDESCRIPTION: Examples of constants with simple value assignments for different primitive types.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/constants.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nconst MY_BOOL: bool = false;\nconst MY_ADDRESS: address = @0x70DD;\nconst BYTES: vector<u8> = b\"hello world\";\nconst HEX_BYTES: vector<u8> = x\"DEADBEEF\"\n```\n\n----------------------------------------\n\nTITLE: Function Definition with Method Support\nDESCRIPTION: Example showing how functions in a type's defining module can be called as methods when the type is the first argument.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic struct X() has copy, drop, store;\npublic fun foo(x: &X) { ... }\npublic fun bar(flag: bool, x: &X) { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining Display Struct in Move\nDESCRIPTION: This snippet shows the structure of the Display object in the Sui Framework, which is used to store metadata for object display.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/display.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nstruct Display<phantom T: key> has key, store {\n    id: UID,\n    /// Contains fields for display. Currently supported\n    /// fields are: name, link, image and description.\n    fields: VecMap<String, String>,\n    /// Version that can only be updated manually by the Publisher.\n    version: u16\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Sui Move Package\nDESCRIPTION: Command to publish the Sui Move package to the network, including building and verification steps.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client publish --gas-budget 100000000\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Bridge\nINCLUDING DEPENDENCY DeepBook\nINCLUDING DEPENDENCY SuiSystem\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING todo_list\nSuccessfully verified dependencies on-chain against source.\nTransaction Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW\n```\n\n----------------------------------------\n\nTITLE: Handling Non-Droppable Enums in Pattern Matching in Move\nDESCRIPTION: This snippet shows the correct way to handle enums without the 'drop' ability in pattern matching. It demonstrates the need to destructure or consume the enum in each match arm.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum X { Variant { x: u64 } }\n\npublic fun good(x: X) {\n    match (x) {\n        // OK! Compiles since the value is destructured\n        X::Variant { x: _ } => (),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Types as Dynamic Field Names in Move\nDESCRIPTION: Implementation showing how custom type keys can be used to attach dynamic fields to a Character object, demonstrating the pattern of using structured keys for field naming.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet acc_key = AccessoryKey { name: string::utf8(b\"hat\") };\nlet meta_key = MetadataKey {};\n\n// attach hat to our character\ndf::add(&mut josh.id, acc_key, Hat { ... });\n\n// attach some metadata\ndf::add<MetadataKey, String>(&mut josh.id, meta_key, string::utf8(b\"Strong and brave\"));\n```\n\n----------------------------------------\n\nTITLE: Declaring Unassigned Named Addresses in Move.toml\nDESCRIPTION: Shows how to declare a named address in Move.toml that can be assigned any value by an importing package.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"example_pkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n```\n\n----------------------------------------\n\nTITLE: Documenting Randomness System Structure - Markdown\nDESCRIPTION: Technical notes documenting the structure and behavior of the randomness system, including consensus commits, epoch initialization, and transaction-specific random value generation. Includes security considerations and implementation details.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/randomness.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- Every consensus commit a new random value is generated.\n- Beginning of an epoch, validators create a global random value.\n- One value is used to derive unique random value per transaction.\n- Pseudo-random generator from a seed that is created once per epoch.\n\n- RandomInner is updated.\n- Every consensus commit the value inside is updated\n\n- Developers call `new_generator` and pass in the global random object.\n- ...which creates the RandomGenerator from the global seed with a fresh object ID.\n- The RandomGenerator uses unknown unpredictable random bytes + fresh object UID from a transaction.\n\n- then they use `generate_bytes` or `generate_u64` or any other integer. Or a value in a range.\n- random shuffle of a vector.\n```\n\n----------------------------------------\n\nTITLE: Move Lock Package Section Example\nDESCRIPTION: Example of package sections in Move.lock file showing how dependencies are recorded with their sources.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_12\n\nLANGUAGE: ini\nCODE:\n```\n[[move.package]]\nname = \"A\"\nsource = { git = \"https://github.com/b/c.git\", subdir = \"e/f\", rev = \"a1b2c3\" }\n\n[[move.package]]\nname = \"B\"\nsource = { local = \"../local-dep\" }\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Using Public Assert Functions\nDESCRIPTION: Example of a problematic pattern where public functions assert conditions directly, limiting the caller's ability to handle errors gracefully.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/better-error-handling.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule book::some_app_assert {\n\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert_is_authorized();\n        // ...\n    }\n\n    public fun do_b() {\n        assert_is_authorized();\n        // ...\n    }\n\n    /// Don't do this\n    public fun assert_is_authorized() {\n        assert!(/* some condition */ true, ENotAuthorized);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Placeholder Type '_' in Move\nDESCRIPTION: This example shows how to use the '_' placeholder type in Move to let the compiler infer some type arguments while explicitly specifying others.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet bar = Bar<u64, _> { x: 0, y: vector[b\"hello\"] };\n//                 ^ vector<u8> is inferred\n```\n\n----------------------------------------\n\nTITLE: Expression Block Use Declaration\nDESCRIPTION: Example demonstrating use declarations within expression blocks.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule a::example;\n\nfun new_vec(): vector<Option<u8>> {\n    use std::vector::push_back;\n    use std::option::{Option, some, none};\n\n    let mut v = vector[];\n    push_back(&mut v, some(0));\n    push_back(&mut v, none());\n    v\n}\n```\n\n----------------------------------------\n\nTITLE: Using Continue in Loop Expression to Sum Even Numbers\nDESCRIPTION: This function uses a loop expression with continue to sum only even numbers from a vector. It demonstrates the use of break to exit the loop and continue to skip odd numbers.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/loops.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nfun sum_even(values: &vector<u64>): u64 {\n    let size = vector::length(values);\n    let mut i = 0;\n    let mut even_sum = 0;\n\n    loop {\n        if (i >= size) break;\n        let number = *vector::borrow(values, i);\n        i = i + 1;\n        if (number % 2 == 1) continue;\n        even_sum = even_sum + number;\n    };\n    even_sum\n}\n```\n\n----------------------------------------\n\nTITLE: Running Sui Move Test Help Command\nDESCRIPTION: Displays help information for the 'sui move test' command, showing available options and their descriptions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move test --help\n```\n\n----------------------------------------\n\nTITLE: Chaining Multiple Commands in a Transaction Block\nDESCRIPTION: Demonstrates executing multiple operations in a single transaction block. This command adds three new items to the TodoList and removes the first item (at index 0), showcasing the power of transaction blocks in Sui.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Finish Concepts chapter'\" \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Read the Move Basics chapter'\" \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Learn about Object Model'\" \\\n--move-call $PACKAGE_ID::todo_list::remove @$LIST_ID 0\n```\n\n----------------------------------------\n\nTITLE: Exposing UID for Dynamic Field Access in Move\nDESCRIPTION: Example showing how to expose an object's UID to allow other modules to access its dynamic fields, demonstrating both a simple accessor and security considerations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-fields.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n/// Access Character's UID (allows adding / removing / reading dynamic fields!)\npublic fun uid(character: &mut Character): &mut UID {\n    &mut character.id\n}\n\n// ... now in a foreign module ...\nlet josh_uid = character::uid(josh);\nlet hat = df::borrow<vector<u8>, Hat>(josh_uid, b\"hat\");\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Object Structure in Move\nDESCRIPTION: This snippet demonstrates how to create a nested object structure, which can be used with Display templates for more complex metadata representation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/display.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nstruct LittlePony has key {\n    id: UID,\n    name: String,\n    image_url: Url,\n    metadata: Metadata\n}\n\nstruct Metadata has store {\n    description: String,\n    attributes: vector<String>\n}\n```\n\n----------------------------------------\n\nTITLE: Dev Address Configuration Example\nDESCRIPTION: Example of package manifest showing how to configure named addresses for development mode using dev-addresses section.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_9\n\nLANGUAGE: ini\nCODE:\n```\n[package]\nname = \"example_pkg\"\n...\n[addresses]\nnamed_addr = \"_\"\n\n[dev-addresses]\nnamed_addr = \"0xC0FFEE\"\n```\n\n----------------------------------------\n\nTITLE: Vector BCS Decoding\nDESCRIPTION: Illustrates how to decode vectors using BCS, including handling vector length and elements.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/bcs.move:decode_vector}}\n```\n\n----------------------------------------\n\nTITLE: Defining Package Dependencies in Move.toml\nDESCRIPTION: This TOML snippet demonstrates how to define package dependencies in the Move.toml file, including both git and local dependencies.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_6\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nExample = { git = \"https://github.com/Example/example.git\", subdir = \"path/to/package\", rev = \"v1.2.3\" }\nLocal = { local = \"../my_other_package\" }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Visibility in Move\nDESCRIPTION: Shows the default internal visibility of functions and how it affects module access.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m {\n    fun foo(): u64 { 0 }\n    fun calls_foo(): u64 { foo() } // valid\n}\n\nmodule b::other {\n    fun calls_m_foo(): u64 {\n        a::m::foo() // ERROR!\n//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Freeze Object Implementation\nDESCRIPTION: Demonstrates how to implement object freezing functionality with Config object creation and access.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n/// Some `Config` object that the admin can `create_and_freeze`.\npublic struct Config has key {\n    id: UID,\n    message: String\n}\n\n/// Creates a new `Config` object and freezes it.\npublic fun create_and_freeze(\n    _: &AdminCap,\n    message: String,\n    ctx: &mut TxContext\n) {\n    let config = Config {\n        id: object::new(ctx),\n        message\n    };\n\n    // Freeze the object so it becomes immutable.\n    transfer::freeze_object(config);\n}\n\n/// Returns the message from the `Config` object.\n/// Can access the object by immutable reference!\npublic fun message(c: &Config): String { c.message }\n```\n\n----------------------------------------\n\nTITLE: Using break to Exit a Loop in Move\nDESCRIPTION: This example demonstrates how to use the break statement to exit a loop early when a certain condition is met.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/control-flow.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet mut x = 0;\nloop {\n    x = x + 1;\n    if (x == 5) break;\n};\n```\n\n----------------------------------------\n\nTITLE: Ignoring Specific Tuple Return Values in Move\nDESCRIPTION: This example shows how to ignore specific values when unpacking tuple returns using the underscore symbol (_), which is useful when you only need some of the returned values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/function.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nfun test_sum_and_product_ignore() {\n    let (sum, _) = sum_and_product(2, 3);\n    assert!(sum == 5, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Test-Only Module Components in Move\nDESCRIPTION: Shows how to mark various module components as test-only using the #[test_only] annotation.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n#[test_only] // test only attributes can be attached to modules\nmodule abc { ... }\n\n#[test_only] // test only attributes can be attached to constants\nconst MY_ADDR: address = @0x1;\n\n#[test_only] // .. to uses\nuse pkg_addr::some_other_module;\n\n#[test_only] // .. to structs\npublic struct SomeStruct { ... }\n\n#[test_only] // .. and functions. Can only be called from test code, but this is _not_ a test!\nfun test_only_function(...) { ... }\n```\n\n----------------------------------------\n\nTITLE: Displaying Sui Transaction Data Structure\nDESCRIPTION: Shows the detailed structure of a transaction including sender address, gas parameters, input objects, and executed commands (Publish and TransferObjects). The snippet demonstrates how transaction data is organized and what information is included in a Sui transaction.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Transaction Data                                                                                             │\n├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │\n│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │\n│ Gas Budget: 100000000 MIST                                                                                   │\n│ Gas Price: 1000 MIST                                                                                         │\n│ Gas Payment:                                                                                                 │\n│  ┌──                                                                                                         │\n│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                                    │\n│  │ Version: 7                                                                                                │\n│  │ Digest: AXYPnups8A5J6pkvLa6RekX2ye3qur66EZ88mEbaUDQ1                                                      │\n│  └──                                                                                                         │\n│                                                                                                              │\n│ Transaction Kind: Programmable                                                                               │\n│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │\n│ │ Input Objects                                                                                            │ │\n│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │\n│ │ 0   Pure Arg: Type: address, Value: \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\" │ │\n│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │\n│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │\n│ │ Commands                                                                │                                  │\n│ ├─────────────────────────────────────────────────────────────────────────┤                                  │\n│ │ 0  Publish:                                                             │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Dependencies:                                                        │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │\n│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │\n│ │  └                                                                      │                                  │\n│ │                                                                         │                                  │\n│ │ 1  TransferObjects:                                                     │                                  │\n│ │  ┌                                                                      │                                  │\n│ │  │ Arguments:                                                           │                                  │\n│ │  │   Result 0                                                           │                                  │\n│ │  │ Address: Input  0                                                    │                                  │\n│ │  └                                                                      │                                  │\n│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │\n│                                                                                                              │\n│ Signatures:                                                                                                  │\n│    gebjSbVwZwTkizfYg2XIuzdx+d66VxFz8EmVaisVFiV3GkDay6L+hQG3n2CQ1hrWphP6ZLc7bd1WRq4ss+hQAQ==                  │\n│                                                                                                              │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Implementing Rule 3: Returning Boolean Instead of Asserting\nDESCRIPTION: Improved pattern that returns boolean values from validation functions, allowing callers to decide how to handle failures and which error messages to display.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/better-error-handling.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule book::some_app {\n    const ENotAuthorized: u64 = 0;\n\n    public fun do_a() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun do_b() {\n        assert!(is_authorized(), ENotAuthorized);\n        // ...\n    }\n\n    public fun is_authorized(): bool {\n        /* some condition */ true\n    }\n\n    // a private function can still be used to avoid code duplication for a case\n    // when the same condition with the same abort code is used in multiple places\n    fun assert_is_authorized() {\n        assert!(is_authorized(), ENotAuthorized);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Epoch from Transaction Context in Sui Move\nDESCRIPTION: This snippet demonstrates how to read the current epoch from the transaction context in Sui Move. The epoch represents operational periods in the system and changes roughly every 24 hours.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/epoch-and-time.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nlet epoch = tx_context::epoch(ctx);\n```\n\n----------------------------------------\n\nTITLE: Invalid Label Usage Examples in Move\nDESCRIPTION: Examples showing incorrect usage of labeled control flow, demonstrating restrictions on break, continue, and return statements.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/labeled-control-flow.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nfun bad_loop() {\n    'name: loop {\n        return 'name 5\n            // ^^^^^ Invalid usage of 'return' with a loop block label\n    }\n}\n\nfun bad_block() {\n    'name: {\n        continue 'name;\n              // ^^^^^ Invalid usage of 'break' with a loop block label\n        break 'name;\n           // ^^^^^ Invalid usage of 'break' with a loop block label\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an Infinite While Loop in Move\nDESCRIPTION: This snippet shows how to create an infinite while loop in Move using the condition 'true'. This will result in a loop that never terminates.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/loops.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nfun foo() {\n    while (true) { }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up a Sui Account\nDESCRIPTION: Interactive command to set up a new Sui account, including connecting to a local network and generating a keypair.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client\nConfig file [\"/path/to/home/.sui/sui_config/client.yaml\"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?\n> y\nSui Full node server URL (Defaults to Sui Testnet if not specified) :\n> http://127.0.0.1:9000\nEnvironment alias for [http://127.0.0.1:9000] :\n> localnet\nSelect key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):\n> 0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Index Syntax Definitions in Move\nDESCRIPTION: Illustrates invalid index syntax definitions, including duplicate definitions and incorrect type constraints.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\n#[syntax(index)]\npublic fun borrow_matrix_u64(s: &Matrix<u64>, i: u64, j: u64): &u64 { ... }\n\n#[syntax(index)]\npublic fun borrow_matrix<T>(s: &Matrix<T>, i: u64, j: u64): &T { ... }\n    // ERROR! Matrix already has a definition\n    // for its immutable index syntax method\n\n#[syntax(index)]\npublic fun borrow_fst(x: &(u64, u64), ...): &u64 { ... }\n    // ERROR because the subject type is a tuple\n\n#[syntax(index)]\npublic fun borrow_tyarg<T>(x: &T, ...): &T { ... }\n    // ERROR because the subject type is a type parameter\n\n#[syntax(index)]\npublic fun borrow_value(x: Matrix<u64>, ...): &u64 { ... }\n    // ERROR because x is not a reference\n\n#[syntax(index)]\npublic fun borrow_imm(x: &mut Matrix<u64>, ...): &u64 { ... }\n    // ERROR! incompatible mutability\n    // expected a mutable reference '&mut' return type\n```\n\n----------------------------------------\n\nTITLE: Package Directory Structure\nDESCRIPTION: Displays the directory structure of the 'hello_world' package, showing the manifest file, sources, and tests directories.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nhello_world\n├── Move.toml\n├── sources\n│   └── hello_world.move\n└── tests\n    └── hello_world_tests.move\n```\n\n----------------------------------------\n\nTITLE: Invalid Friend Declaration Across Addresses in Move\nDESCRIPTION: This example shows an error when attempting to declare a module from a different address as a friend.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::m {}\n\nmodule 0x42::n { friend 0x42::m; // ERROR! }\n//                      ^^^^^^^ Cannot declare modules out of the current address as a friend\n```\n\n----------------------------------------\n\nTITLE: Incorrect Recursive Enum Definitions in Move\nDESCRIPTION: This snippet demonstrates incorrect ways to define recursive enums, which are not allowed in Move. It includes examples of direct and mutual recursion.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum Foo {\n    Recursive(Foo),\n    //        ^ error: recursive enum variant\n}\npublic enum List {\n    Nil,\n    Cons { head: u64, tail: List },\n    //                      ^ error: recursive enum variant\n}\npublic enum BTree<T> {\n    Leaf(T),\n    Node { left: BTree<T>, right: BTree<T> },\n    //           ^ error: recursive enum variant\n}\n\n// Mutually recursive enums are also not allowed\npublic enum MutuallyRecursiveA {\n    Base,\n    Other(MutuallyRecursiveB),\n    //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant\n}\n\npublic enum MutuallyRecursiveB {\n    Base,\n    Other(MutuallyRecursiveA),\n    //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Local Package Directory Structure\nDESCRIPTION: This snippet shows the typical directory structure of a Move package, including the sources directory for module files, optional tests and examples directories, and the Move.toml manifest file.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/packages.md#2025-04-22_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nsources/\n    my_module.move\n    another_module.move\n    ...\ntests/\n    ...\nexamples/\n    using_my_module.move\nMove.toml\n```\n\n----------------------------------------\n\nTITLE: TodoList Object Details Display in Plaintext\nDESCRIPTION: Shows the formatted output of querying a TodoList object, including its metadata and contents. The output confirms that the 'Finish the Hello, Sui chapter' item was successfully added to the list.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_24\n\nLANGUAGE: plaintext\nCODE:\n```\n╭───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ objectId      │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                                               │\n│ version       │  24                                                                                                               │\n│ digest        │  FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ                                                                     │\n│ objType       │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList                          │\n│ owner         │ ╭──────────────┬──────────────────────────────────────────────────────────────────────╮                           │\n│               │ │ AddressOwner │  0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1  │                           │\n│               │ ╰──────────────┴──────────────────────────────────────────────────────────────────────╯                           │\n│ prevTx        │  EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1                                                                     │\n│ storageRebate │  1558000                                                                                                          │\n│ content       │ ╭───────────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮ │\n│               │ │ dataType          │  moveObject                                                                               │ │\n│               │ │ type              │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │ │\n│               │ │ hasPublicTransfer │  true                                                                                     │ │\n│               │ │ fields            │ ╭───────┬───────────────────────────────────────────────────────────────────────────────╮ │ │\n│               │ │                   │ │ id    │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │\n│               │ │                   │ │       │ │ id │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │ │ │\n│               │ │                   │ │       │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │\n│               │ │                   │ │ items │ ╭─────────────────────────────────╮                                           │ │ │\n│               │ │                   │ │       │ │  finish the Hello, Sui chapter  │                                           │ │ │\n│               │ │                   │ │       │ ╰─────────────────────────────────╯                                           │ │ │\n│               │ │                   │ ╰───────┴───────────────────────────────────────────────────────────────────────────────╯ │ │\n│               │ ╰───────────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯ │\n╰───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Invalid Coin Destruction via Reference Example\nDESCRIPTION: Demonstrates how Move prevents destruction of resources through reference writes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/references.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nfun destroy_coin_via_ref_bad(mut ten_coins: Coin, c: Coin) {\n    let ref = &mut ten_coins;\n    *ref = c; // ERROR! not allowed--would destroy 10 coins!\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving TodoList Object as JSON\nDESCRIPTION: Queries the TodoList object in JSON format for a more structured and machine-readable representation. This is useful for parsing or processing the data programmatically.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client object $LIST_ID --json\n```\n\n----------------------------------------\n\nTITLE: CopyBox Macro Implementation\nDESCRIPTION: Example demonstrating type constraints in macro functions using a CopyBox struct.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\npublic struct NoAbilities()\npublic struct CopyBox<T: copy> has copy, drop { value: T }\nmacro fun make_box<$T>($x: $T): CopyBox<$T> {\n    CopyBox { value: $x }\n}\n```\n\n----------------------------------------\n\nTITLE: Requesting Coins from Sui Faucet\nDESCRIPTION: Command to request coins from the Sui faucet for testing purposes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client faucet\nRequest successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.\n```\n\n----------------------------------------\n\nTITLE: Invalid Mutable Index Method Implementations in Move\nDESCRIPTION: Examples of invalid mutable index method implementations that fail type compatibility constraints when paired with the immutable version.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\n#[syntax(index)]\npublic fun borrow_mut<T: drop>(s: &mut Matrix<T>, i: u64, j: u64): &mut T { ... }\n    // ERROR! `T` has `drop` here, but no in the immutable version\n\n#[syntax(index)]\npublic fun borrow_mut(s: &mut Matrix<u64>, i: u64, j: u64): &mut u64 { ... }\n    // ERROR! This takes a different number of type parameters\n\n#[syntax(index)]\npublic fun borrow_mut<T, U>(s: &mut Matrix<U>, i: u64, j: u64): &mut U { ... }\n    // ERROR! This takes a different number of type parameters\n\n#[syntax(index)]\npublic fun borrow_mut<U>(s: &mut Matrix<U>, i_j: (u64, u64)): &mut U { ... }\n    // ERROR! This takes a different number of arguments\n\n#[syntax(index)]\npublic fun borrow_mut<U>(s: &mut Matrix<U>, i: u64, j: u32): &mut U { ... }\n    // ERROR! `j` is a different type\n```\n\n----------------------------------------\n\nTITLE: Importing Move Standard Library Dependency\nDESCRIPTION: TOML configuration showing how to import the Move Standard Library directly into a package without the Sui Framework.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/standard-library.md#2025-04-22_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\nMoveStdlib = { git = \"https://github.com/MystenLabs/sui.git\", subdir = \"crates/sui-framework/packages/move-stdlib\", rev = \"framework/mainnet\" }\n```\n\n----------------------------------------\n\nTITLE: Method Usage Example\nDESCRIPTION: Demonstrates valid and invalid method calls based on function parameter order.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/method-syntax.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun example(x: a::m::X) {\n    x.foo(); // valid\n    // x.bar(true); ERROR!\n}\n```\n\n----------------------------------------\n\nTITLE: Adding an Item to TodoList via Sui CLI\nDESCRIPTION: Constructs a transaction to call the 'add' function from the todo_list module, passing the list object and a string item. The command uses the programmable transaction blocks (ptb) feature of Sui CLI.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client ptb \\\n--gas-budget 100000000 \\\n--move-call $PACKAGE_ID::todo_list::add @$LIST_ID \"'Finish the Hello, Sui chapter'\"\n```\n\n----------------------------------------\n\nTITLE: Creating a New Move Package\nDESCRIPTION: Creates a new Move package named 'test_example' and changes the current directory to it.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move new test_example; cd test_example\n```\n\n----------------------------------------\n\nTITLE: Implementing Test for Hello World Module\nDESCRIPTION: Shows the implementation of a test function for the 'hello_world' module, verifying the output of the hello_world() function.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_9\n\nLANGUAGE: move\nCODE:\n```\n#[test_only]\nmodule hello_world::hello_world_tests;\n\nuse hello_world::hello_world;\n\n#[test]\nfun test_hello_world() {\n    assert!(hello_world::hello_world() == b\"Hello, World!\".to_string(), 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Module Expected Failure Tests in Move\nDESCRIPTION: Shows how to handle expected failures across different modules and reference constants from other modules in expected failure annotations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule pkg_addr::other_module {\n    const ENotFound: u64 = 1;\n    public fun will_abort() {\n        abort ENotFound\n    }\n}\n\nmodule pkg_addr::my_module {\n    use pkg_addr::other_module;\n    const ENotFound: u64 = 1;\n\n    #[test]\n    #[expected_failure(abort_code = ENotFound)]\n    fun test_will_abort_and_pass() { abort ENotFound }\n\n    #[test]\n    #[expected_failure(abort_code = other_module::ENotFound)]\n    fun test_will_abort_and_pass() { other_module::will_abort() }\n\n    // FAIL: Will not pass since we are expecting the constant from the wrong module.\n    #[test]\n    #[expected_failure(abort_code = ENotFound)]\n    fun test_will_abort_and_pass() { other_module::will_abort() }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Implicit and Explicit Returns in Move Functions\nDESCRIPTION: This snippet demonstrates two equivalent functions in Move, one using an explicit return statement and the other using an implicit return.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\nfun f1(): u64 { return 0 }\nfun f2(): u64 { 0 }\n```\n\n----------------------------------------\n\nTITLE: Invalid Self-Declaration as Friend in Move\nDESCRIPTION: This example shows an invalid friend declaration where a module attempts to declare itself as a friend, which is not allowed.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::m { friend Self; // ERROR! }\n//                      ^^^^ Cannot declare the module itself as a friend\n\nmodule 0x43::m { friend 0x43::M; // ERROR! }\n//                      ^^^^^^^ Cannot declare the module itself as a friend\n```\n\n----------------------------------------\n\nTITLE: Inspecting TodoList Object with Sui CLI\nDESCRIPTION: Queries the TodoList object to verify that the item was added correctly. This command displays detailed information about the object including its ID, version, type, and content.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client object $LIST_ID\n```\n\n----------------------------------------\n\nTITLE: Running Specific Move Tests\nDESCRIPTION: Runs only the tests containing 'non_zero' in their fully qualified name using the 'sui move test' command with a filter.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move test non_zero\n```\n\n----------------------------------------\n\nTITLE: Package Dependency Configuration with Address Renaming\nDESCRIPTION: Package manifest example showing how to rename named addresses when importing dependencies using the addr_subst property.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_8\n\nLANGUAGE: ini\nCODE:\n```\n[package]\nname = \"P\"\n...\n[dependencies]\nP1 = { local = \"some_path_to_P1\", addr_subst = { \"P1N\" = \"N\" } }\nP2 = { local = \"some_path_to_P2\"  }\n```\n\n----------------------------------------\n\nTITLE: Named Address Module Example in Move\nDESCRIPTION: Example showing how to reference renamed named addresses in a Move module, demonstrating access to address after renaming in package dependencies.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nmodule N::A {\n    public fun x(): address { @P1N }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting TodoList Object ID Variable in Bash\nDESCRIPTION: Sets an environment variable to store the TodoList object ID for later use in transactions. This ID is needed to reference the specific object when calling functions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n$ export LIST_ID=0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\n```\n\n----------------------------------------\n\nTITLE: Invalid Coin Copy via Reference Example\nDESCRIPTION: Shows how Move prevents copying of assets through references, maintaining resource safety.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/references.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nfun copy_coin_via_ref_bad(c: Coin) {\n    let c_ref = &c;\n    let counterfeit: Coin = *c_ref; // not allowed!\n    pay(c);\n    pay(counterfeit);\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing Balance Changes in Transaction\nDESCRIPTION: Shows the SUI coin balance changes after transaction execution, displaying spent amount in MIST\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\n╭───────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Balance Changes                                                                                   │\n├───────────────────────────────────────────────────────────────────────────────────────────────────┤\n│  ┌──                                                                                              │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │\n│  │ CoinType: 0x2::sui::SUI                                                                        │\n│  │ Amount: -10426280                                                                              │\n│  └──                                                                                              │\n╰───────────────────────────────────────────────────────────────────────────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Byte and Hex String Operations in Move\nDESCRIPTION: Example demonstrating equality between byte strings and hex strings in Move, including various escape sequences.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/primitive-types/vector.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nfun byte_and_hex_strings() {\n    assert!(b\"\" == x\"\", 0);\n    assert!(b\"Hello!\\n\" == x\"48656C6C6F210A\", 1);\n    assert!(b\"\\x48\\x65\\x6C\\x6C\\x6F\\x21\\x0A\" == x\"48656C6C6F210A\", 2);\n    assert!(\n        b\"\\\"Hello\\tworld!\\\"\\n \\r \\\\Null=\\0\" ==\n            x\"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00\",\n        3\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Index Syntax Usage in Move\nDESCRIPTION: Illustrates different ways of using index syntax, including immutable and mutable access, and how they are translated by the compiler.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nlet mut mat = matrix::make_matrix(...);\n\nlet m_0_0 = mat[0, 0];\n// translates to `copy matrix::borrow(&mat, 0, 0)`\n\nlet m_0_0 = &mat[0, 0];\n// translates to `matrix::borrow(&mat, 0, 0)`\n\nlet m_0_0 = &mut mat[0, 0];\n// translates to `matrix::borrow_mut(&mut mat, 0, 0)`\n```\n\n----------------------------------------\n\nTITLE: Build Directory Structure\nDESCRIPTION: Directory structure showing the layout of build artifacts including bytecode modules, documentation, source maps, and source files.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\na_move_package\n├── BuildInfo.yaml\n├── bytecode_modules\n│   ├── dependencies\n│   │   ├── <dep_pkg_name>\n│   │   │   └── *.mv\n│   │   ...\n│   │   └──  <dep_pkg_name>\n│   │       └── *.mv\n│   ...\n│   └── *.mv\n├── docs\n│   ├── dependencies\n│   │   ├── <dep_pkg_name>\n│   │   │   └── *.md\n│   │   ...\n│   │   └──  <dep_pkg_name>\n│   │       └── *.md\n│   ...\n│   └── *.md\n├── source_maps\n│   ├── dependencies\n│   │   ├── <dep_pkg_name>\n│   │   │   └── *.mvsm\n│   │   ...\n│   │   └──  <dep_pkg_name>\n│   │       └── *.mvsm\n│   ...\n│   └── *.mvsm\n└── sources\n    ...\n    └── *.move\n    ├── dependencies\n    │   ├── <dep_pkg_name>\n    │   │   └── *.move\n    │   ...\n    │   └──  <dep_pkg_name>\n    │       └── *.move\n    ...\n    └── *.move\n```\n\n----------------------------------------\n\nTITLE: Initial Test File Template\nDESCRIPTION: Shows the initial commented-out test module template in the hello_world_tests.move file, including test function examples.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\n/*\n#[test_only]\nmodule hello_world::hello_world_tests;\n// uncomment this line to import the module\n// use hello_world::hello_world;\n\nconst ENotImplemented: u64 = 0;\n\n#[test]\nfun test_hello_world() {\n    // pass\n}\n\n#[test, expected_failure(abort_code = hello_world::hello_world_tests::ENotImplemented)]\nfun test_hello_world_fail() {\n    abort ENotImplemented\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Frozen Object Access Limitations\nDESCRIPTION: Shows examples of functions that cannot be called on frozen objects, illustrating access limitations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\n// === Functions below can't be called on a frozen object! ===\n\n/// The function can be defined, but it won't be callable on a frozen object.\n/// Only immutable references are allowed.\npublic fun message_mut(c: &mut Config): &mut String { &mut c.message }\n\n/// Deletes the `Config` object, takes it by value.\n/// Can't be called on a frozen object!\npublic fun delete_config(c: Config) {\n    let Config { id, message: _ } = c;\n    id.delete()\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing Object Changes in Transaction\nDESCRIPTION: Displays the changes to objects including created UpgradeCap, mutated Gas object, and published package details\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n╭──────────────────────────────────────────────────────────────────────────────────────────────────╮\n│ Object Changes                                                                                   │\n├──────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Created Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                  │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │\n│  │ ObjectType: 0x2::package::UpgradeCap                                                          │\n│  │ Version: 8                                                                                    │\n│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                          │\n│  └──                                                                                             │\n│ Mutated Objects:                                                                                 │\n│  ┌──                                                                                             │\n│  │ ObjectID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                  │\n│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │\n│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │\n│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │\n│  │ Version: 8                                                                                    │\n│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                          │\n│  └──                                                                                             │\n│ Published Objects:                                                                               │\n│  ┌──                                                                                             │\n│  │ PackageID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                 │\n│  │ Version: 1                                                                                    │\n│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                          │\n│  │ Modules: todo_list                                                                            │\n│  └──                                                                                             │\n╰──────────────────────────────────────────────────────────────────────────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Querying Sui Objects Owned by Account\nDESCRIPTION: Command to query objects owned by the Sui account, showing object details.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client objects\n╭───────────────────────────────────────────────────────────────────────────────────────╮\n│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │\n│ │ objectId   │  0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de  │ │\n│ │ version    │  4                                                                   │ │\n│ │ digest     │  nA68oa8gab/CdIRw+240wze8u0P+sRe4vcisbENcR4U=                        │ │\n│ │ objectType │  0x0000..0002::coin::Coin                                            │ │\n│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │\n╰───────────────────────────────────────────────────────────────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Struct BCS Encoding Example\nDESCRIPTION: Shows how to encode a custom struct using BCS serialization.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/bcs.move:encode_struct}}\n```\n\n----------------------------------------\n\nTITLE: Viewing Transaction Events Output\nDESCRIPTION: Shows the empty events section output from a transaction execution\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n╭─────────────────────────────╮\n│ No transaction block events │\n╰─────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Member Aliasing Syntax\nDESCRIPTION: Syntax for importing specific module members with aliases.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nuse <address>::<module name>::<module member>;\nuse <address>::<module name>::<module member> as <member alias>;\n```\n\n----------------------------------------\n\nTITLE: Constraint Verification Examples\nDESCRIPTION: Examples showing how constraints are checked at instantiation sites for structs.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_14\n\nLANGUAGE: move\nCODE:\n```\npublic struct Foo<T: copy> { x: T }\n\npublic struct Bar { x: Foo<u8> }\n//                         ^^ valid, u8 has `copy`\n\npublic struct Baz<T> { x: Foo<T> }\n//                            ^ ERROR! T does not have 'copy'\n```\n\n----------------------------------------\n\nTITLE: Running Move Tests with Gas Limit\nDESCRIPTION: Executes Move tests with a gas consumption limit of 0 using the '-i' or '--gas_used' option.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move test -i 0\n```\n\n----------------------------------------\n\nTITLE: Move Toolchain Version Section\nDESCRIPTION: Example of toolchain version section in Move.lock file containing compiler version, edition, and flavor information.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_13\n\nLANGUAGE: ini\nCODE:\n```\n[move.toolchain-version]\ncompiler-version = <string> # The version of the Move compiler used to build the package, e.g. \"1.21.0\"\nedition = <string> # The edition of the Move language used to build the package, e.g. \"2024.alpha\"\nflavor = <string> # The flavor of the Move compiler used to build the package, e.g. \"sui\"\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Error Testing in Move\nDESCRIPTION: Demonstrates how to test for arithmetic errors using the expected_failure annotation with arithmetic_error option.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule pkg_addr::other_module {\n    public fun will_arith_error() { 1/0; }\n}\n\nmodule pkg_addr::my_module {\n    use pkg_addr::other_module;\n    #[test]\n    #[expected_failure(arithmetic_error, location = Self)]\n    fun test_will_arith_error_and_pass1() { 1/0; }\n\n    #[test]\n    #[expected_failure(arithmetic_error, location = pkg_addr::other_module)]\n    fun test_will_arith_error_and_pass2() { other_module::will_arith_error() }\n\n    // FAIL: Will fail since the location we expect it the fail at is different from where the test actually failed.\n    #[test]\n    #[expected_failure(arithmetic_error, location = Self)]\n    fun test_will_arith_error_and_fail() { other_module::will_arith_error() }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Move Package\nDESCRIPTION: Uses the Sui Move CLI to create a new package named 'hello_world' with the necessary directory structure and files.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsui move new hello_world\n```\n\n----------------------------------------\n\nTITLE: Alternative Module Initializer Implementation in Move\nDESCRIPTION: Example of another module in the same package with its own `init` function, showing how multiple modules can have their own initialization logic.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/module-initializer.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/module-initializer-2.move:other}}\n```\n\n----------------------------------------\n\nTITLE: Creating a New Sui Move Package\nDESCRIPTION: Command to create a new Sui Move package named 'todo_list'.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move new todo_list\n```\n\n----------------------------------------\n\nTITLE: Implementing Sum with Threshold Using Labeled Loops in Move\nDESCRIPTION: Function that sums numbers from nested vectors until reaching a threshold. Uses labeled loops to break out of nested iterations when the threshold would be exceeded.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/control-flow/labeled-control-flow.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nfun sum_until_threshold(input: &vector<vector<u64>>, threshold: u64): u64 {\n    let mut sum = 0;\n    let mut i = 0;\n    let input_size = input.length();\n\n    'outer: loop {\n        // breaks to outer since it is the closest enclosing loop\n        if (i >= input_size) break sum;\n\n        let vec = &input[i];\n        let size = vec.length();\n        let mut j = 0;\n\n        while (j < size) {\n            let v_entry = vec[j];\n            if (sum + v_entry < threshold) {\n                sum = sum + v_entry;\n            } else {\n                // the next element we saw would break the threshold,\n                // so we return the current sum\n                break 'outer sum\n            };\n            j = j + 1;\n        };\n        i = i + 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Macro-Based Clever Errors\nDESCRIPTION: Shows how to use exported macros and functions that implement clever errors in a client module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert/clever-errors.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::user_module;\n\nuse 0x42::macro_exporter::{\n    assert_false,\n    abort_always,\n    assert_false_fun,\n    abort_always_fun\n};\n\nfun invoke_assert_false() {\n    assert_false!(); // Will abort with the line number of this invocation\n}\n\nfun invoke_abort_always() {\n    abort_always!(); // Will abort with the line number of this invocation\n}\n\nfun invoke_assert_false_fun() {\n    assert_false_fun(); // Will abort with the line number of the assertion in `assert_false_fun`\n}\n\nfun invoke_abort_always_fun() {\n    abort_always_fun(); // Will abort with the line number of the `abort` in `abort_always_fun`\n}\n```\n\n----------------------------------------\n\nTITLE: Module-Level Use Declaration\nDESCRIPTION: Example showing use declarations inside a module context.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/uses.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmodule a::example;\n\nuse std::vector;\n\nfun new_vec(): vector<Option<u8>> {\n    let mut v = vector[];\n    vector::push_back(&mut v, 0);\n    vector::push_back(&mut v, 10);\n    v\n}\n\nuse std::option::{Option, some, none};\n```\n\n----------------------------------------\n\nTITLE: Installing Sui using Chocolatey on Windows\nDESCRIPTION: This command installs Sui using the Chocolatey package manager on Windows systems. It provides a straightforward installation method for Windows users.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/before-we-begin/install-sui.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nchoco install sui\n```\n\n----------------------------------------\n\nTITLE: Running Move Tests with Statistics\nDESCRIPTION: Executes Move tests and displays statistics including runtime and gas usage for each test using the '-s' or '--statistics' option.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/unit-testing.md#2025-04-22_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move test -s\n```\n\n----------------------------------------\n\nTITLE: Usage Demonstration of Dynamic Object Fields in Move\nDESCRIPTION: Example usage of dynamic object fields functionality, referenced from a samples package but not directly visible in the provided content.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-object-fields.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/dynamic-object-fields.move:usage}}\n```\n\n----------------------------------------\n\nTITLE: Inspecting TodoList After Multiple Operations\nDESCRIPTION: Queries the TodoList object in JSON format after executing multiple operations. This command helps verify that all operations (adding three items and removing one) were completed successfully.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nsui client object $LIST_ID --json\n```\n\n----------------------------------------\n\nTITLE: Checking Sui Installation with Version Command\nDESCRIPTION: Verifies the installation of Sui by printing the client version using the command line interface.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsui client --version\n```\n\n----------------------------------------\n\nTITLE: Using Flexible Index Syntax with Default Values in Move\nDESCRIPTION: Shows how to use the flexible index syntax that requires a default value when accessing elements in a custom table structure.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/index-syntax.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet string_key: String = ...;\nlet mut table: MTable<String, u64> = m_table::make_table();\nlet entry: &mut u64 = &mut table[string_key, 0];\n```\n\n----------------------------------------\n\nTITLE: Initial Source File Template\nDESCRIPTION: Presents the initial commented-out module definition template in the hello_world.move source file.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\n/*\n/// Module: hello_world\nmodule hello_world::hello_world;\n*/\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Upgradeability Constraints in Move Modules\nDESCRIPTION: This snippet illustrates the constraints and allowed changes when upgrading a Move module. It shows which elements can be modified or removed and which must remain unchanged to maintain compatibility.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/upgradeability-practices.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n// module can not be removed from the package\nmodule book::upgradable {\n    // dependencies can be changed (if they are not used in public signatures)\n    use std::string::String;\n    use sui::event; // can be removed\n\n    // public structs can not be removed and can't be changed\n    public struct Book has key {\n        id: UID,\n        title: String,\n    }\n\n    // public structs can not be removed and can't be changed\n    public struct BookCreated has copy, drop {\n        /* ... */\n    }\n\n    // public functions can not be removed and their signature can never change\n    // but the implementation can be changed\n    public fun create_book(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n\n        // can be removed and changed\n        event::emit(BookCreated {\n            /* ... */\n        })\n    }\n\n    // package-visibility functions can be removed and changed\n    public(package) fun create_book_package(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // entry functions can be removed and changed as long they're not public\n    entry fun create_book_entry(ctx: &mut TxContext): Book {\n        create_book_internal(ctx)\n    }\n\n    // private functions can be removed and changed\n    fun create_book_internal(ctx: &mut TxContext): Book {\n        abort 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Clever Errors with Macros in Move\nDESCRIPTION: Demonstrates how clever errors work with macros, showing line number derivation from macro invocation locations.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert/clever-errors.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::macro_exporter;\n\npublic macro fun assert_false() {\n    assert!(false);\n}\n\npublic macro fun abort_always() {\n    abort\n}\n\npublic fun assert_false_fun() {\n    assert!(false); // Will always abort with the line number of this invocation\n}\n\npublic fun abort_always_fun() {\n    abort // Will always abort with the line number of this invocation\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Sui Move Package\nDESCRIPTION: Command to build the Sui Move package and its output, showing dependency inclusion and successful build.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sui move build\nUPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Bridge\nINCLUDING DEPENDENCY DeepBook\nINCLUDING DEPENDENCY SuiSystem\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING todo_list\n```\n\n----------------------------------------\n\nTITLE: Updating Rust to the latest stable version\nDESCRIPTION: This command updates the Rust compiler to the latest stable version. It's recommended to ensure the system has the most recent Rust version before installing Sui.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/before-we-begin/install-sui.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrustup update stable\n```\n\n----------------------------------------\n\nTITLE: Checking Sui Account Balance\nDESCRIPTION: Command to check the balance of coins owned by the Sui account.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client balance\n╭────────────────────────────────────────╮\n│ Balance of coins owned by this address │\n├────────────────────────────────────────┤\n│ ╭──────────────────────────────────╮   │\n│ │ coin  balance (raw)  balance     │   │\n│ ├──────────────────────────────────┤   │\n│ │ Sui   1000000000    1.00 SUI     │   │\n│ ╰──────────────────────────────────╯   │\n╰────────────────────────────────────────╯\n```\n\n----------------------------------------\n\nTITLE: Address-Based Access Control Implementation\nDESCRIPTION: Demonstrates traditional address-based access control for creating users, showing the alternative to capability-based approach.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/capability.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n{{#include ../../../packages/samples/sources/programmability/capability-3.move:with_address}}\n```\n\n----------------------------------------\n\nTITLE: Directory Structure Example for Move Book Samples\nDESCRIPTION: Demonstrates the expected directory structure for storing Move code samples, showing how samples directory mirrors the src directory hierarchy\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/packages/samples/sources/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsamples/\n    basic-syntax/\n        address.move\n```\n\n----------------------------------------\n\nTITLE: Installing Sui using Homebrew on MacOS\nDESCRIPTION: This command installs Sui using the Homebrew package manager on MacOS systems. It's a simple one-line installation method for MacOS users.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/before-we-begin/install-sui.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install sui\n```\n\n----------------------------------------\n\nTITLE: Abort Type Examples\nDESCRIPTION: Demonstrates how abort expressions can take on any type in the type system.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert.md#2025-04-22_snippet_7\n\nLANGUAGE: move\nCODE:\n```\nlet y: address = abort 0;\n\nlet b =\n    if (x == 0) false\n    else if (x == 1) true\n    else abort 42;\n```\n\n----------------------------------------\n\nTITLE: Viewing Package Contents\nDESCRIPTION: Lists the contents of the newly created 'hello_world' package directory to verify its structure.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nls -l hello_world\n```\n\n----------------------------------------\n\nTITLE: Generic Add Macro with Placeholder Types\nDESCRIPTION: Example of a macro function using the _ placeholder type for flexible type handling.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_6\n\nLANGUAGE: move\nCODE:\n```\nmacro fun add($x: _, $y: _, $z: _): u256 {\n    ($x as u256) + ($y as u256) + ($z as u256)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Clever Abort Codes in Move\nDESCRIPTION: Demonstrates how to use the #[error] attribute to create custom abort codes with vector<u8> values instead of u64.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/abort-and-assert/clever-errors.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::a_module;\n\n#[error]\nconst EIsThree: vector<u8> = b\"The value is three\";\n\n// Will abort with `EIsThree` if `x` is 3\npublic fun double_except_three(x: u64): u64 {\n    assert!(x != 3, EIsThree);\n    x * x\n}\n\n// Will always abort with `EIsThree`\npublic fun clever_abort() {\n    abort EIsThree\n}\n```\n\n----------------------------------------\n\nTITLE: TOML Inline Style Dependencies\nDESCRIPTION: Example of dependencies configured using TOML's inline table syntax.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/manifest.md#2025-04-22_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n# Inline style\n[dependencies]\nExample = { override = true, git = \"https://github.com/example/example.git\", subdir = \"crates/sui-framework/packages/sui-framework\", rev = \"framework/testnet\" }\nMyPackage = { local = \"../my-package\" }\n```\n\n----------------------------------------\n\nTITLE: Declaring Multiple Friends in Move\nDESCRIPTION: This snippet illustrates how to declare multiple friend modules. Both 'b' and 'c' modules are declared as friends of module 'a'.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::a;\n\nfriend 0x42::b;\nfriend 0x42::c;\n```\n\n----------------------------------------\n\nTITLE: Building Transaction Command\nDESCRIPTION: Complete command to create a new todo list and transfer it to the user's account\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nsui client ptb \\\n--gas-budget 100000000 \\\n--assign sender @$MY_ADDRESS \\\n--move-call $PACKAGE_ID::todo_list::new \\\n--assign list \\\n--transfer-objects \"[list]\" sender\n```\n\n----------------------------------------\n\nTITLE: Native BCS Bytes Conversion in Move\nDESCRIPTION: Native function declaration for converting any type to BCS-encoded bytes.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/bcs.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\npublic native fun to_bytes<T>(t: &T): vector<u8>;\n```\n\n----------------------------------------\n\nTITLE: Organizing Move Project Directory Structure\nDESCRIPTION: Demonstrates the recommended directory structure for a Move project, showing the separation of source files, tests, and examples. Examples are placed in a separate directory to avoid inclusion in package bytecode while still being testable.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/open-sourcing-libraries.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsources/\n    protocol.move\n    library.move\ntests/\n    protocol_test.move\nexamples/\n    my_example.move\nMove.toml\n```\n\n----------------------------------------\n\nTITLE: Moving Built Move Book Contents\nDESCRIPTION: Shell command to move the built Move book contents from a temporary location to the current directory, typically used when updating the gh-pages branch.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/README.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nmv L/* .\n```\n\n----------------------------------------\n\nTITLE: Security Considerations for Random Number Generation - Markdown\nDESCRIPTION: Documentation of security considerations and potential issues when implementing random number generation in smart contracts, including predictability concerns and gas optimization strategies.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/randomness.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nDifficulties:\n\n- If you know the seed, then you can predict the random number.\n- Random should not be used in a public function - predictable.\n- Random failure is more expensive than a success scenario.\n    - one way out is to first calculate randomness and then do a separate expensive operation.\n    - they can set a limit to gas for failure scenarios, so the failure never happens.\n```\n\n----------------------------------------\n\nTITLE: Installing Sui using Cargo on MacOS and Linux\nDESCRIPTION: This command installs and builds Sui locally using the Cargo package manager. It requires Rust to be installed on the system. The command targets the mainnet branch of the Sui repository.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/before-we-begin/install-sui.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo install --git https://github.com/MystenLabs/sui.git sui --branch mainnet\n```\n\n----------------------------------------\n\nTITLE: Installing mdbook via Cargo\nDESCRIPTION: Command to install mdbook using Cargo, the Rust package manager. This is a prerequisite for working with the Move book.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install mdbook\n```\n\n----------------------------------------\n\nTITLE: Invalid Transfer of Shared Object\nDESCRIPTION: Example of an invalid operation that attempts to transfer a shared object. The Sui Verifier will reject this transaction as shared objects cannot be transferred.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\npublic fun transfer_shared(c: Config, to: address) {\n    transfer::transfer(c, to);\n}\n```\n\n----------------------------------------\n\nTITLE: Example of a Standard Address in Move\nDESCRIPTION: A demonstration of a standard 32-byte address in Move, represented as a 64-character hexadecimal string prefixed with 0x.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/address.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n0xe51ff5cd221a81c3d6e22b9e670ddf99004d71de4f769b0312b68c7c4872e2f1\n```\n\n----------------------------------------\n\nTITLE: Defining Background Object Structure in Move\nDESCRIPTION: This snippet demonstrates the historical approach of defining display fields directly in object structs, which had limitations in flexibility and efficiency.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/display.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nstruct Background {\n    id: UID,\n    name: String,\n    description: String,\n    url: Url,\n    // ... other fields\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Package with JSON Output\nDESCRIPTION: Command to publish a package with JSON formatted output\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nsui client publish --gas-budget 100000000 --json\n```\n\n----------------------------------------\n\nTITLE: Failed Attempt to Call Internal Functions from Another Module\nDESCRIPTION: Shows code that will not compile because it attempts to call an internal function from a different module. Internal functions cannot be accessed outside their defining module.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/visibility.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nmodule book::try_calling_internal;\n\nuse book::internal_visibility;\n\n// Different module -> can't call internal()\nfun try_calling_internal() {\n    internal_visibility::internal();\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda Type Declaration Syntax\nDESCRIPTION: Demonstrates the syntax for declaring lambda types in Move macros.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/functions/macros.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n|u64, u64| -> u128 // a lambda that takes two u64s and returns a u128\n|&mut vector<u8>| -> &mut u8 // a lambda that takes a &mut vector<u8> and returns a &mut u8\n```\n\n----------------------------------------\n\nTITLE: Compiling the Move Package\nDESCRIPTION: Uses the Sui Move CLI to compile the 'hello_world' package, demonstrating the build process and dependency inclusion.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-world.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nsui move build\n```\n\n----------------------------------------\n\nTITLE: Problematic Error Handling Pattern in Move\nDESCRIPTION: Example showing a function with multiple calls that may abort with the same code, making it difficult to determine which call caused the error.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/better-error-handling.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::module_a {\n    use book::module_b;\n\n    public fun do_something() {\n        let field_1 = module_b::get_field(1); // may abort with 0\n        /* ... a lot of logic ... */\n        let field_2 = module_b::get_field(2); // may abort with 0\n        /* ... some more logic ... */\n        let field_3 = module_b::get_field(3); // may abort with 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Constants Syntax\nDESCRIPTION: Basic syntax for declaring constants in Move, showing the required components of a constant declaration.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/constants.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nconst <name>: <type> = <expression>;\n```\n\n----------------------------------------\n\nTITLE: Grouping Imports in Move\nDESCRIPTION: This snippet shows how to group multiple imports from the same module or package using curly braces.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/importing-modules.md#2025-04-22_snippet_3\n\nLANGUAGE: move\nCODE:\n```\nmodule package::example {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n\n    struct Example has key {\n        id: UID\n    }\n\n    public fun new(ctx: &mut TxContext): Example {\n        Example { id: object::new(ctx) }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Active Sui Address\nDESCRIPTION: Command to check the active Sui address after account setup.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ sui client active-address\n0x....\n```\n\n----------------------------------------\n\nTITLE: Creating a Minimal Move Package Manifest\nDESCRIPTION: Demonstrates the simplest possible Move.toml file for a package, containing only the package name.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/packages.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"AName\"\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Library Address in TOML Configuration\nDESCRIPTION: Configuration snippet showing the exported std address alias definition for the Move Standard Library.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/standard-library.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[addresses]\nstd = \"0x1\"\n```\n\n----------------------------------------\n\nTITLE: Collection Index Access in Move\nDESCRIPTION: Demonstrates the equivalent syntax for accessing collection elements using index notation and borrow methods.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/dynamic-collections.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nlet hat: &Hat = &bag[b\"key\"];\nlet hat_mut: &mut Hat = &mut bag[b\"key\"];\n\n// is equivalent to\nlet hat: &Hat = bag.borrow(b\"key\");\nlet hat_mut: &mut Hat = bag.borrow_mut(b\"key\");\n```\n\n----------------------------------------\n\nTITLE: Documentation Structure in Markdown\nDESCRIPTION: Comprehensive table of contents in markdown format organizing educational content about Move programming language and Sui blockchain, including setup instructions, basic concepts, object model, storage, and advanced programmability topics.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/SUMMARY.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Summary\n\n- [The Move Book](README.md)\n- [Foreword](foreword.md)\n- [Before we begin](before-we-begin/README.md)\n  - [Install Sui](before-we-begin/install-sui.md)\n  - [Set up your IDE](before-we-begin/ide-support.md)\n  - [Move 2024](before-we-begin/move-2024.md)\n- [Hello, World!](your-first-move/hello-world.md)\n- [Hello, Sui!](your-first-move/hello-sui.md)\n- [Concepts](./concepts/README.md)\n  - [Package](./concepts/packages.md)\n  - [Manifest](./concepts/manifest.md)\n  - [Address](./concepts/address.md)\n  - [Account](./concepts/what-is-an-account.md)\n  - [Transaction](./concepts/what-is-a-transaction.md)\n[...remaining structure omitted for brevity...]\n```\n\n----------------------------------------\n\nTITLE: Running Move Books Locally with mdBook in Bash\nDESCRIPTION: Commands to serve the Move Book and Move Language Reference locally using mdBook. These commands start local servers for both books, making them accessible at http://localhost:3000.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mdbook serve book\n$ mdbook serve reference\n```\n\n----------------------------------------\n\nTITLE: Constant Naming Convention in Move\nDESCRIPTION: Shows naming conventions for constants using SCREAMING_SNAKE_CASE and error constants using EPascalCase.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/coding-conventions.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nconst MAX_PRICE: u64 = 1000;\nconst EInvalidInput: u64 = 0;\n```\n\n----------------------------------------\n\nTITLE: Markdown Title for Balance & Coin Section\nDESCRIPTION: Section header for Balance and Coin documentation in Move language documentation\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/balance-and-coin.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Balance & Coin\n```\n\n----------------------------------------\n\nTITLE: Overwriting Enum Values in Move\nDESCRIPTION: This snippet demonstrates how to overwrite enum values that have the 'drop' ability. It shows a function that replaces the enum value with a new variant.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/enums.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\nmodule a::m;\n\npublic enum X has drop {\n    A(u64),\n    B(u64),\n}\n\npublic fun overwrite_enum(x: &mut X) {\n    *x = X::A(10);\n}\n```\n\n----------------------------------------\n\nTITLE: Building Move Book for Publication\nDESCRIPTION: Command to build the Move book using mdbook, generating output in the 'book' directory for publication.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/README.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nmdbook build\n```\n\n----------------------------------------\n\nTITLE: Defining Publisher struct in Move\nDESCRIPTION: Definition of the Publisher struct from the sui::package module in the Sui Framework. It contains fields for id, package, and module_name.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/programmability/publisher.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\npublic struct Publisher has key, store {\n    id: UID,\n    package: String,\n    module_name: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Updated TodoList Object JSON Representation\nDESCRIPTION: Displays the updated TodoList object after multiple operations. The JSON shows that the first item was removed and three new items were added, confirming that all operations in the transaction block were executed correctly.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_29\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"objectId\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\",\n  \"version\": \"25\",\n  \"digest\": \"EDTXDsteqPGAGu4zFAj5bbQGTkucWk4hhuUquk39enGA\",\n  \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n  \"owner\": {\n    \"AddressOwner\": \"0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1\"\n  },\n  \"previousTransaction\": \"7SXLGBSh31jv8G7okQ9mEgnw5MnTfvzzHEHpWf3Sa9gY\",\n  \"storageRebate\": \"1922800\",\n  \"content\": {\n    \"dataType\": \"moveObject\",\n    \"type\": \"0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList\",\n    \"hasPublicTransfer\": true,\n    \"fields\": {\n      \"id\": {\n        \"id\": \"0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553\"\n      },\n      \"items\": [\n        \"Finish Concepts chapter\",\n        \"Read the Move Basics chapter\",\n        \"Learn about Object Model\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Named Address Configuration in Move.toml\nDESCRIPTION: Example of defining a named address in the Move.toml package manifest file. This configuration allows using symbolic names instead of literal addresses throughout the code.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/module.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n# Move.toml\n[addresses]\nbook = \"0x0\"\n```\n\n----------------------------------------\n\nTITLE: Package Address Example\nDESCRIPTION: Example of a published package address on Sui blockchain\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_14\n\nLANGUAGE: plaintext\nCODE:\n```\n0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe\n```\n\n----------------------------------------\n\nTITLE: Example of a Reserved Address with Zero Padding in Move\nDESCRIPTION: Illustrates how short addresses like 0x1 are padded with zeros to reach the full 32-byte length. This example shows the Standard Library's address.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/address.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Checking Errors in Move Equality Operations\nDESCRIPTION: This snippet shows type checking errors that occur when comparing operands of different types using equality operators in Move.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/equality.md#2025-04-22_snippet_2\n\nLANGUAGE: move\nCODE:\n```\n1u8 == 1u128; // ERROR!\n//     ^^^^^ expected an argument of type 'u8'\nb\"\" != 0; // ERROR!\n//     ^ expected an argument of type 'vector<u8>'\n```\n\n----------------------------------------\n\nTITLE: Invalid Friend Declaration of Non-existent Module in Move\nDESCRIPTION: This snippet demonstrates an error when trying to declare a non-existent module as a friend.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/friends.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\nmodule 0x42::m { friend 0x42::nonexistent; // ERROR! }\n//                      ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'\n```\n\n----------------------------------------\n\nTITLE: Invalid Phantom Type Parameter Usage\nDESCRIPTION: Examples showing invalid uses of phantom type parameters where they appear in non-phantom positions.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/generics.md#2025-04-22_snippet_10\n\nLANGUAGE: move\nCODE:\n```\npublic struct S1<phantom T> { f: T }\n//               ^^^^^^^ ERROR!  ^ Not a phantom position\n\npublic struct S2<T> { f: T }\npublic struct S3<phantom T> { f: S2<T> }\n//               ^^^^^^^ ERROR!     ^ Not a phantom position\n```\n\n----------------------------------------\n\nTITLE: Listing Sui Reserved Addresses\nDESCRIPTION: List of special Sui blockchain addresses used for system operations and core functionality, including the Standard Library (0x1), Sui Framework (0x2), SuiSystem object (0x5), Clock object (0x6), Random object (0x8), and DenyList system object (0x403).\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/appendix/reserved-addresses.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- `0x1` - address of the [Standard Library](./../move-basics/standard-library.md) (alias `std`)\n- `0x2` - address of the [Sui Framework](./../programmability/sui-framework.md) (alias `sui`)\n- `0x5` - address of the `SuiSystem` object\n- `0x6` - address of the system [`Clock` object](./../programmability/epoch-and-time.md)\n- `0x8` - address of the system `Random` object\n- `0x403` - address of the `DenyList` system object\n```\n\n----------------------------------------\n\nTITLE: Implementing Store Ability in Move Structs\nDESCRIPTION: Demonstrates the implementation of 'store' ability in Move through three struct definitions: Storable, Config, and MegaConfig. Shows how types with 'store' ability can be nested within other structs that have the 'key' ability.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/store-ability.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\n/// This type has the `store` ability.\npublic struct Storable has store {}\n\n/// Config contains a `Storable` field which must have the `store` ability.\npublic struct Config has key, store {\n    id: UID,\n    stores: Storable,\n}\n\n/// MegaConfig contains a `Config` field which has the `store` ability.\npublic struct MegaConfig has key {\n    id: UID,\n    config: Config, // there it is!\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Test Functions with #[test] Attribute in Move\nDESCRIPTION: Demonstrates how to create test functions using the #[test] attribute in Move. Test functions take no arguments, have no return value, and are excluded from published bytecode.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/testing.md#2025-04-22_snippet_0\n\nLANGUAGE: move\nCODE:\n```\nmodule book::testing;\n\n// The test attribute is placed before the `fun` keyword (can be both above or\n// right before the `fun` keyword, as in `#[test] fun my_test() { ... }`)\n// The name of the test in this case would be `book::testing::simple_test`.\n#[test]\nfun simple_test() {\n    let sum = 2 + 2;\n    assert!(sum == 4);\n}\n\n// The name of this test would be `book::testing::more_advanced_test`.\n#[test] fun more_advanced_test() {\n    let sum = 2 + 2 + 2;\n    assert!(sum == 4);\n}\n```\n\n----------------------------------------\n\nTITLE: Operators in Move\nDESCRIPTION: Shows the use of arithmetic, logical, and bitwise operators in Move, which are expressions that produce values.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/expression.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\nfun operators() {\n    // Arithmetic operators\n    let _ = 1 + 2;\n    let _ = 3 - 4;\n    let _ = 5 * 6;\n    let _ = 7 / 8;\n    let _ = 9 % 10;\n\n    // Logical operators\n    let _ = true && false;\n    let _ = true || false;\n    let _ = !true;\n\n    // Comparison operators\n    let _ = 1 == 2;\n    let _ = 3 != 4;\n    let _ = 5 < 6;\n    let _ = 7 > 8;\n    let _ = 9 <= 10;\n    let _ = 11 >= 12;\n\n    // Bitwise operators\n    let _ = 1 & 2;\n    let _ = 3 | 4;\n    let _ = 5 ^ 6;\n}\n```\n\n----------------------------------------\n\nTITLE: Markdown Header for Concepts Chapter\nDESCRIPTION: A markdown header introducing the Concepts chapter of the Move Book for Sui development. It outlines the topics covered and references the official Sui documentation for more detailed information.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Concepts\n\nIn this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a\npackage, how to interact with it, what is an account and a transaction, and how data is stored on\nSui. While this chapter is not a complete reference, and you should refer to the\n[Sui Documentation](https://docs.sui.io) for that, it will give you a good understanding of the\nbasic concepts required to write Move programs on Sui.\n```\n\n----------------------------------------\n\nTITLE: Reading Struct Fields in Move\nDESCRIPTION: Demonstrates how to read and copy struct field values using dereferencing and the dot operator. The dot operator is shown to be more canonical for reading fields without borrowing.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/src/structs.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nlet foo = Foo { x: 3, y: true };\nlet bar = Bar(copy foo);\nlet x: u64 = *&foo.x;\nlet y: bool = *&foo.y;\nlet foo2: Foo = *&bar.0;\n```\n\nLANGUAGE: move\nCODE:\n```\nlet foo = Foo { x: 3, y: true };\nlet x = foo.x;  // x == 3\nlet y = foo.y;  // y == true\n```\n\nLANGUAGE: move\nCODE:\n```\nlet bar = Bar(Foo { x: 3, y: true });\nlet x = baz.0.x; // x = 3;\n```\n\n----------------------------------------\n\nTITLE: Using Borrowing Operator for Built-in Types in Move 2024\nDESCRIPTION: Shows how to use the new borrowing operator '[]' for accessing elements in built-in types like vectors in Move 2024.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_8\n\nLANGUAGE: move\nCODE:\n```\nfun play_vec() {\n    let v = vector[1,2,3,4];\n    let first = &v[0];         // calls vector::borrow(v, 0)\n    let first_mut = &mut v[0]; // calls vector::borrow_mut(v, 0)\n    let first_copy = v[0];     // calls *vector::borrow(v, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Package Visibility Functions from Within the Same Package\nDESCRIPTION: Demonstrates how to call a package-visible function from another module within the same package. This is allowed as package-visible functions are accessible to all modules in the same package.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/move-basics/visibility.md#2025-04-22_snippet_5\n\nLANGUAGE: move\nCODE:\n```\nmodule book::try_calling_package;\n\nuse book::package_visibility;\n\n// Same package `book` -> can call package_only()\nfun try_calling_package() {\n    package_visibility::package_only();\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing 'friend' with 'public(package)' in Move 2024\nDESCRIPTION: Demonstrates how to replace the deprecated 'friend' keyword with the new 'public(package)' visibility modifier for functions in Move 2024.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/guides/2024-migration-guide.md#2025-04-22_snippet_4\n\nLANGUAGE: move\nCODE:\n```\n// Move 2020\nfriend book::friend_module;\npublic(friend) fun protected_function() {}\n\n// Move 2024\npublic(package) fun protected_function_2024() {}\n```\n\n----------------------------------------\n\nTITLE: Transferring Objects to Sender in Sui CLI\nDESCRIPTION: Command syntax for transferring a list of objects to the sender in Sui CLI. This command is used to move ownership of objects to the specified address.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/your-first-move/hello-sui.md#2025-04-22_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n--transfer-objects \"[list]\" sender\n```\n\n----------------------------------------\n\nTITLE: Previewing Move Book Changes with mdbook\nDESCRIPTION: Commands to preview changes to the Move book using mdbook. 'mdbook serve' provides a static preview, while 'mdbook watch' updates the preview as changes are made.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/reference/README.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nmdbook serve\n```\n\nLANGUAGE: shell\nCODE:\n```\nmdbook watch\n```\n\n----------------------------------------\n\nTITLE: TOML Multiline Style Dependencies\nDESCRIPTION: Example of dependencies configured using TOML's multiline table syntax.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/concepts/manifest.md#2025-04-22_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n# Multiline style\n[dependencies.Example]\noverride = true\ngit = \"https://github.com/example/example.git\"\nsubdir = \"crates/sui-framework/packages/sui-framework\"\nrev = \"framework/testnet\"\n\n[dependencies.MyPackage]\nlocal = \"../my-package\"\n```\n\n----------------------------------------\n\nTITLE: Transfer Function Signature\nDESCRIPTION: Shows the signature of the transfer function from the Sui Framework, used to transfer objects to addresses.\nSOURCE: https://github.com/mystenlabs/move-book/blob/main/book/src/storage/storage-functions.md#2025-04-22_snippet_1\n\nLANGUAGE: move\nCODE:\n```\n// File: sui-framework/sources/transfer.move\npublic fun transfer<T: key>(obj: T, recipient: address);\n```"
  }
]