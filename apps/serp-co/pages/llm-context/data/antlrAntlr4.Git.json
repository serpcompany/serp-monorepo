[
  {
    "owner": "antlr",
    "repo": "antlr4.git",
    "content": "TITLE: Defining Expression Grammar Rules in ANTLR4\nDESCRIPTION: Complete ANTLR4 grammar definition for parsing arithmetic expressions. Includes rules for basic operations (+-*/), parentheses grouping, variable assignments, and lexer rules for tokens. Handles integers, identifiers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/AmbigLR_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\nprog:   stat ;\nstat:   expr NEWLINE       # printExpr\n    |   ID '=' expr NEWLINE# assign\n    |   NEWLINE   # blank\n    ;\nexpr:   expr ('*'|'/') expr      # MulDiv\n    |   expr ('+'|'-') expr      # AddSub\n    |   INT    # int\n    |   ID     # id\n    |   '(' expr ')'    # parens\n    ;\n\nMUL :   '*' ; // assigns token name to '*' used above in grammar\nDIV :   '/' ;\nADD :   '+' ;\nSUB :   '-' ;\nID  :   [a-zA-Z]+ ;      // match identifiers\nINT :   [0-9]+ ;// match integers\nNEWLINE:'\n'? '\n' ;     // return newlines to parser (is end-statement signal)\nWS  :   [ \t]+ -> skip ; // toss out whitespace\n```\n\n----------------------------------------\n\nTITLE: Windows CLASSPATH Configuration for ANTLR4\nDESCRIPTION: Command to temporarily set the CLASSPATH environment variable on Windows to include the ANTLR JAR file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nSET CLASSPATH=.;C:\\Javalib\\antlr-4.13.2-complete.jar;%CLASSPATH%\n```\n\n----------------------------------------\n\nTITLE: Java Expression Grammar Definition in ANTLR4\nDESCRIPTION: Comprehensive ANTLR4 grammar that defines rules for parsing Java-like expressions. Supports operations like method calls, array access, type casting, unary/binary operators, and object instantiation. Includes lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_9.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |\\<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |\\<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Parser Grammar in ANTLR4\nDESCRIPTION: Specifies a complete ANTLR4 grammar for parsing mathematical expressions with support for multiplication, division, addition, subtraction, parentheses grouping, and variable assignments. Includes lexer rules for operators, identifiers, integers, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/AmbigLR_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\nprog:   stat ;\nstat:   expr NEWLINE       # printExpr\n    |   ID '=' expr NEWLINE# assign\n    |   NEWLINE   # blank\n    ;\nexpr:   expr ('*'|'/') expr      # MulDiv\n    |   expr ('+'|'-') expr      # AddSub\n    |   INT    # int\n    |   ID     # id\n    |   '(' expr ')'    # parens\n    ;\n\nMUL :   '*' ; // assigns token name to '*' used above in grammar\nDIV :   '/' ;\nADD :   '+' ;\nSUB :   '-' ;\nID  :   [a-zA-Z]+ ;      // match identifiers\nINT :   [0-9]+ ;// match integers\nNEWLINE:'\n'? '\n' ;     // return newlines to parser (is end-statement signal)\nWS  :   [ \\t]+ -> skip ; // toss out whitespace\n```\n\n----------------------------------------\n\nTITLE: Using tokenVocab Option for Token Type Values\nDESCRIPTION: Example demonstrating how to use the tokenVocab option to reuse token type values from a separate lexer grammar. This ensures consistent token type assignments across grammar files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cat SomeLexer.g4\nlexer grammar SomeLexer;\nID : [a-z]+ ;\n$ cat R.g4\nparser grammar R;\noptions {tokenVocab=SomeLexer;}\ntokens {A,B,C} // normally, these would be token types 1, 2, 3\na : ID ;\n$ antlr4 SomeLexer.g4\n$ cat SomeLexer.tokens \nID=1\n$ antlr4 R.g4\n$ cat R.tokens\nA=2\nB=3\nC=4\nID=1\n```\n\n----------------------------------------\n\nTITLE: Java Expression Grammar Definition in ANTLR4\nDESCRIPTION: ANTLR4 grammar that defines parsing rules for Java-like expressions including arithmetic operations, method calls, array access, object creation, and type casting. The grammar handles operator precedence and associativity, and includes support for basic tokens like identifiers and integers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_12.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |\\<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |\\<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<=' \n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Creating a Visitor-based Expression Evaluator in Python\nDESCRIPTION: A visitor implementation that traverses the parse tree and evaluates arithmetic expressions, handling different expression types like binary operations, unary operations, and parenthesized expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom antlr4 import *\nfrom ExprParser import ExprParser\nfrom ExprVisitor import ExprVisitor\n\nclass VisitorInterp(ExprVisitor):\n    def visitAtom(self, ctx:ExprParser.AtomContext):\n        return int(ctx.getText())\n\n    def visitExpr(self, ctx:ExprParser.ExprContext):\n        if ctx.getChildCount() == 3:\n            if ctx.getChild(0).getText() == \"(\":\n                return self.visit(ctx.getChild(1))\n            op = ctx.getChild(1).getText()\n            v1 = self.visit(ctx.getChild(0))\n            v2 = self.visit(ctx.getChild(2))\n            if op == \"+\":\n                return v1 + v2\n            if op == \"-\":\n                return v1 - v2\n            if op == \"*\":\n                return v1 * v2\n            if op == \"/\":\n                return v1 / v2\n            return 0\n        if ctx.getChildCount() == 2:\n            opc = ctx.getChild(0).getText()\n            if opc == \"+\":\n                return self.visit(ctx.getChild(1))\n            if opc == \"-\":\n                return - self.visit(ctx.getChild(1))\n            return 0\n        if ctx.getChildCount() == 1:\n            return self.visit(ctx.getChild(0))\n        return 0\n\n    def visitStart_(self, ctx:ExprParser.Start_Context):\n        for i in range(0, ctx.getChildCount(), 2):\n            print(self.visit(ctx.getChild(i)))\n        return 0\n```\n\n----------------------------------------\n\nTITLE: Parsing with GUI Visualization\nDESCRIPTION: Command to parse an expression and display the parse tree in a graphical user interface window, providing a visual representation of the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4-parse Expr.g4 prog -gui\n10+20*30\n^D\n```\n\n----------------------------------------\n\nTITLE: Creating and Using CharStream in Java with ANTLR 4.7+\nDESCRIPTION: Example of using the new CharStreams factory method to create a stream from a file path, initializing a lexer, and processing tokens. This demonstrates the recommended approach for handling Unicode in ANTLR 4.7+.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic static void main(String[] args) {\n  CharStream charStream = CharStreams.fromPath(Paths.get(args[0]));\n  Lexer lexer = new UnicodeLexer(charStream);\n  CommonTokenStream tokens = new CommonTokenStream(lexer);\n  tokens.fill();\n  for (Token token : tokens.getTokens()) {\n    System.out.println(\"Got token: \" + token.toString());\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining C-Style Declarator Grammar in ANTLR4\nDESCRIPTION: ANTLR4 grammar that handles C-style declarations including pointers (*), arrays ([]), and function calls (). The grammar includes rules for declarators, expressions, identifiers, integers, and whitespace handling. Features a tree output visualization using the @after attribute.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Creating and Matching Parse Tree Patterns in Java with ANTLR4\nDESCRIPTION: Demonstrates how to compile a parse tree pattern and check if a tree matches that pattern. The example checks if a parse tree matches an assignment statement pattern with an ID and expression.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tree-matching.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nParseTree t = ...; // assume t is a statement\nParseTreePattern p = parser.compileParseTreePattern(\"<ID> = <expr>;\", MyParser.RULE_statement);\nParseTreeMatch m = p.match(t);\nif ( m.succeeded() ) {...}\n```\n\n----------------------------------------\n\nTITLE: Generating Java Parser Code from Grammar\nDESCRIPTION: Commands to generate Java parser code from an ANTLR grammar file and list the resulting Java files. This shows the standard code generation for the default target language (Java).\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 Expr.g4\n$ ls Expr*.java\nExprBaseListener.java  ExprLexer.java         ExprListener.java      ExprParser.java\n```\n\n----------------------------------------\n\nTITLE: Simple Expression Grammar Definition in ANTLR4\nDESCRIPTION: A simple ANTLR grammar for parsing mathematical expressions with basic operations like addition, subtraction, multiplication, and division.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar Expr;\t\t\nprog:\texpr EOF ;\nexpr:\texpr ('*'|'/') expr\n    |\texpr ('+'|'-') expr\n    |\tINT\n    |\t'(' expr ')'\n    ;\nNEWLINE : [\\r\\n]+ -> skip;\nINT     : [0-9]+ ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Conditional Statements\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing 'if-then-else' and 'return' statements. It includes special annotations for ambiguity detection and DFA dumping. The grammar handles nested conditional statements and potential ambiguities in 'else' clause matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n@after {<DumpDFA()>}\n   : '{' stat* '}' ;\nstat: 'if' ID 'then' stat ('else' ID)?\n       | 'return'\n       ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic ANTLR4 Parser Driver in Python\nDESCRIPTION: A Python driver script that sets up the ANTLR4 runtime environment, reads input from a file, creates a lexer and parser, and processes the input according to the grammar rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom antlr4 import *\nfrom ExprLexer import ExprLexer\nfrom ExprParser import ExprParser\nfrom VisitorInterp import VisitorInterp\n\ndef main(argv):\n    input_stream = FileStream(argv[1])\n    lexer = ExprLexer(input_stream)\n    stream = CommonTokenStream(lexer)\n    parser = ExprParser(stream)\n    tree = parser.start_()\n\nif __name__ == '__main__':\n    main(sys.argv)\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Scoping in ANTLR4 Grammar\nDESCRIPTION: This ANTLR4 grammar demonstrates the use of dynamic scoping to define variables and check their usage. It includes rules for block structure, variable declaration, and statement matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_7\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar DynScope;\n\nprog: block ;\n\nblock\n\t/* List of symbols defined within this block */\n\tlocals [\n\tList<String> symbols = new ArrayList<String>()\n\t]\n\t: '{' decl* stat+ '}'\n\t// print out all symbols found in block\n\t// $block::symbols evaluates to a List as defined in scope\n\t{System.out.println(\"symbols=\"+$symbols);}\n\t;\n\n/** Match a declaration and add identifier name to list of symbols */\ndecl: 'int' ID {$block::symbols.add($ID.text);} ';' ;\n\n/** Match an assignment then test list of symbols to verify\n * that it contains the variable on the left side of the assignment.\n * Method contains() is List.contains() because $block::symbols\n * is a List.\n */\nstat: ID '=' INT ';'\n\t{\n\tif ( !$block::symbols.contains($ID.text) ) {\n\tSystem.err.println(\"undefined variable: \"+$ID.text);\n\t}\n\t}\n\t| block\n\t;\n\nID : [a-z]+ ;\nINT : [0-9]+ ;\nWS : [ \\t\\r\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Running Generated TypeScript Lexer and Parser\nDESCRIPTION: Example of how to use the generated TypeScript lexer and parser. Demonstrates importing necessary classes, creating a character stream, and parsing input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/typescript-target.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CharStream, CommonTokenStream }  from 'antlr4';\nimport MyGrammarLexer from './MyGrammarLexer';\nimport MyGrammarParser from './MyGrammarParser';\n\nconst input = \"your text to parse here\"\nconst chars = new CharStream(input); // replace this with a FileStream as required\nconst lexer = new MyGrammarLexer(chars);\nconst tokens = new CommonTokenStream(lexer);\nconst parser = new MyGrammarParser(tokens);\nconst tree = parser.MyStartRule();\n```\n\n----------------------------------------\n\nTITLE: Compiling and Testing the Hello Grammar\nDESCRIPTION: Series of commands to compile the Hello grammar with ANTLR4, generate Java code, and test it with example input using both text and GUI output modes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n$ cd /tmp\n$ antlr4 Hello.g4\n$ javac Hello*.java\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ grun Hello r -tree\nhello parrt\n^D\n(r hello parrt)\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ grun Hello r -gui\nhello parrt\n^D\n```\n\n----------------------------------------\n\nTITLE: Parsing Java and Walking Parse Tree with Listener in ANTLR 4\nDESCRIPTION: Example showing how to parse Java code and walk the resulting parse tree using a custom listener and the ParseTreeWalker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/listeners.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nJavaLexer lexer = new JavaLexer(input);\nCommonTokenStream tokens = new CommonTokenStream(lexer);\nJavaParser parser = new JavaParser(tokens);\nJavaParser.CompilationUnitContext tree = parser.compilationUnit(); // parse a compilationUnit\n\nMyListener extractor = new MyListener(parser);\nParseTreeWalker.DEFAULT.walk(extractor, tree); // initiate walk of tree with listener in use of default walker\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR4 Tools with Python's pip\nDESCRIPTION: Command to install the antlr4-tools Python package, which provides a convenient wrapper for ANTLR4 without requiring manual Java installation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install antlr4-tools\n```\n\n----------------------------------------\n\nTITLE: Implementing Left-recursive Grammar Rules in ANTLR 4\nDESCRIPTION: A basic ANTLR 4 grammar snippet demonstrating left-recursive expression rules for defining statements and expressions, including multiplication, addition, function calls, and variable references.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/left-recursion.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nstat: expr '=' expr ';' // e.g., x=y; or x=f(x);\n    | expr ';'          // e.g., f(x); or f(g(x));\n    ;\nexpr: expr '*' expr\n    | expr '+' expr\n    | expr '(' expr ')' // f(x)\n    | id\n    ;\n```\n\n----------------------------------------\n\nTITLE: Accessing Token Attributes in ANTLR4 Grammar Actions\nDESCRIPTION: Shows how to access token attributes within actions in ANTLR4 grammar rules. The actions print variable declarations using the text of matched tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\ndecl: type ID ';'\n      {System.out.println(\"var \"+$ID.text+\":\"+$type.text+\";\");}\n    | t=ID id=ID ';'\n      {System.out.println(\"var \"+$id.text+\":\"+$t.text+\";\");}\n    ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Declarator Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing declarators with various syntactic elements. It includes rules for handling nested declarators, arrays, function calls, pointers, and identifiers. The grammar also specifies lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_10.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Parser in PHP with ANTLR4\nDESCRIPTION: A complete PHP example demonstrating how to use the generated parser and lexer to parse JSON input. It includes necessary imports, a custom listener implementation, and the main parsing logic.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/php-target.md#2025-04-21_snippet_2\n\nLANGUAGE: php\nCODE:\n```\n<?php\n\nnamespace JsonParser;\n\nuse Antlr\\Antlr4\\Runtime\\CommonTokenStream;\nuse Antlr\\Antlr4\\Runtime\\Error\\Listeners\\DiagnosticErrorListener;\nuse Antlr\\Antlr4\\Runtime\\InputStream;\nuse Antlr\\Antlr4\\Runtime\\ParserRuleContext;\nuse Antlr\\Antlr4\\Runtime\\Tree\\ErrorNode;\nuse Antlr\\Antlr4\\Runtime\\Tree\\ParseTreeListener;\nuse Antlr\\Antlr4\\Runtime\\Tree\\ParseTreeWalker;\nuse Antlr\\Antlr4\\Runtime\\Tree\\TerminalNode;\n\nfinal class TreeShapeListener implements ParseTreeListener {\n    public function visitTerminal(TerminalNode $node) : void {}\n    public function visitErrorNode(ErrorNode $node) : void {}\n    public function exitEveryRule(ParserRuleContext $ctx) : void {}\n\n    public function enterEveryRule(ParserRuleContext $ctx) : void {\n        echo $ctx->getText();\n    }\n}\n\n$input = InputStream::fromPath($argv[1]);\n$lexer = new JSONLexer($input);\n$tokens = new CommonTokenStream($lexer);\n$parser = new JSONParser($tokens);\n$parser->addErrorListener(new DiagnosticErrorListener());\n$tree = $parser->json();\n\nParseTreeWalker::default()->walk(new TreeShapeListener(), $tree);\n```\n\n----------------------------------------\n\nTITLE: Parsing with Token and Trace Information\nDESCRIPTION: Using antlr4-parse with the -tokens and -trace flags to display token information and trace the parse process for a simple expression.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4-parse Expr.g4 prog -tokens -trace\n10+20*30\n^D\n[@0,0:1='10',<INT>,1:0]\n[@1,2:2='+',<'+'>,1:2]\n[@2,3:4='20',<INT>,1:3]\n[@3,5:5='*',<'*'>,1:5]\n[@4,6:7='30',<INT>,1:6]\n[@5,9:8='<EOF>',<EOF>,2:0]\nenter   prog, LT(1)=10\nenter   expr, LT(1)=10\nconsume [@0,0:1='10',<8>,1:0] rule expr\nenter   expr, LT(1)=+\nconsume [@1,2:2='+',<3>,1:2] rule expr\nenter   expr, LT(1)=20\nconsume [@2,3:4='20',<8>,1:3] rule expr\nenter   expr, LT(1)=*\nconsume [@3,5:5='*',<1>,1:5] rule expr\nenter   expr, LT(1)=30\nconsume [@4,6:7='30',<8>,1:6] rule expr\nexit    expr, LT(1)=<EOF>\nexit    expr, LT(1)=<EOF>\nexit    expr, LT(1)=<EOF>\nconsume [@5,9:8='<EOF>',<-1>,2:0] rule prog\nexit    prog, LT(1)=<EOF>\n```\n\n----------------------------------------\n\nTITLE: Expression Grammar with Token Association Option\nDESCRIPTION: A grammar for expressions that uses the assoc token option to specify right associativity for the exponentiation operator, while maintaining left associativity for other operators.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_6\n\nLANGUAGE: g4\nCODE:\n```\ngrammar ExprLR;\n \t \nexpr : expr '^'<assoc=right> expr\n \t| expr '*' expr // match subexpressions joined with '*' operator\n \t| expr '+' expr // match subexpressions joined with '+' operator\n \t| INT // matches simple integer atom\n \t;\n \t \nINT : '0'..'9'+ ;\nWS : [ \\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Basic ANTLR4 Grammar Structure\nDESCRIPTION: This snippet shows the general structure of an ANTLR4 grammar file, including optional components like options, imports, tokens, channels, and actions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\n/** Optional javadoc style comment */\ngrammar Name; ①\noptions {...}\nimport ... ;\n \ntokens {...}\nchannels {...} // lexer only\n@actionName {...}\n \t \nrule1 // parser and lexer rules, possibly intermingled\n...\nruleN\n```\n\n----------------------------------------\n\nTITLE: Running the ANTLR4 Python Parser with Shell Script\nDESCRIPTION: A simple shell command to execute the Python driver script with an input file as an argument, demonstrating how to use the generated parser.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython Driver.py input.txt\n```\n\n----------------------------------------\n\nTITLE: Running ANTLR4 Tool Command\nDESCRIPTION: Example of running the antlr4 command which will download the ANTLR jar file and Java JRE if needed. Shows the beginning of the help output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 \nDownloading antlr4-4.13.2-complete.jar\nANTLR tool needs Java to run; install Java JRE 11 yes/no (default yes)? y\nInstalled Java in /Users/parrt/.jre/jdk-11.0.15+10-jre; remove that dir to uninstall\nANTLR Parser Generator  Version 4.13.2\n -o ___              specify output directory where all output is generated\n -lib ___            specify location of grammars, tokens files\n...\n```\n\n----------------------------------------\n\nTITLE: Collecting Node Text from XPath Results in ANTLR4\nDESCRIPTION: Demonstrates how to collect the text of all nodes matching an XPath expression. The code distinguishes between rule context nodes and terminal nodes to extract appropriate text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tree-matching.md#2025-04-21_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nList<String> nodes = new ArrayList<String>();\nfor (ParseTree t : XPath.findAll(tree, xpath, parser) ) {\n    if ( t instanceof RuleContext) {\n        RuleContext r = (RuleContext)t;\n        nodes.add(parser.getRuleNames()[r.getRuleIndex()]);    }      \n    else { \n        TerminalNode token = (TerminalNode)t;\n        nodes.add(token.getText());\n    }      \n}\n```\n\n----------------------------------------\n\nTITLE: Combining XPath and Pattern Matching in ANTLR4\nDESCRIPTION: Shows how to combine XPath and pattern matching to find specific tree structures. The example finds Java variable declarations by first using XPath to select block statement children, then applying a pattern match.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tree-matching.md#2025-04-21_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n// assume we are parsing Java\nParserRuleContext tree = parser.compilationUnit();\nString xpath = \"//blockStatement/*\"; // get children of blockStatement\nString treePattern = \"int <Identifier> = <expression>;\";\nParseTreePattern p =\n    parser.compileParseTreePattern(treePattern,   \n        ExprParser.RULE_localVariableDeclarationStatement);\nList<ParseTreeMatch> matches = p.findAll(tree, xpath);\nSystem.out.println(matches);\n```\n\n----------------------------------------\n\nTITLE: Declarator Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing C-style declarator syntax including array subscripts, function calls, pointer declarations, and identifiers. Includes lexer rules for identifiers, integers, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_9.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Hello World Grammar Definition in ANTLR4\nDESCRIPTION: A simple ANTLR4 grammar that matches the keyword 'hello' followed by an identifier, demonstrating the basic structure of an ANTLR grammar file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_13\n\nLANGUAGE: antlr\nCODE:\n```\n// Define a grammar called Hello\ngrammar Hello;\nr  : 'hello' ID ;         // match keyword hello followed by an identifier\nID : [a-z]+ ;             // match lower-case identifiers\nWS : [ \\t\\r\\n]+ -> skip ; // skip spaces, tabs, newlines\n```\n\n----------------------------------------\n\nTITLE: Generating Maven Project Structure for ANTLR4 Java Application\nDESCRIPTION: Commands to create a new Maven project structure for an ANTLR4-based Java application. It sets up the initial directory structure and pom.xml file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmkdir SimpleAntlrMavenProject\ncd SimpleAntlrMavenProject\nmvn archetype:generate -DgroupId=org.abcd.examples -DartifactId=array-example -Dpackage=org.abcd.examples.ArrayInit -Dversion=1.0\n# Accept all the default values\ncd array-example\n```\n\n----------------------------------------\n\nTITLE: Implementing a Visitor-based Expression Evaluator Driver\nDESCRIPTION: An enhanced Python driver that not only creates a parser but also initializes and uses a visitor to evaluate expressions in the parse tree, with error handling for syntax errors.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom antlr4 import *\nfrom ExprLexer import ExprLexer\nfrom ExprParser import ExprParser\nfrom VisitorInterp import VisitorInterp\n\ndef main(argv):\n    input_stream = FileStream(argv[1])\n    lexer = ExprLexer(input_stream)\n    stream = CommonTokenStream(lexer)\n    parser = ExprParser(stream)\n    tree = parser.start_()\n    if parser.getNumberOfSyntaxErrors() > 0:\n        print(\"syntax errors\")\n    else:\n        vinterp = VisitorInterp()\n        vinterp.visit(tree)\n\nif __name__ == '__main__':\n    main(sys.argv)\n```\n\n----------------------------------------\n\nTITLE: Right-Associative Expression Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar with right-associative operators including multiplication, addition, conditional (ternary), and assignment. The grammar handles basic expressions with single-letter identifiers and includes EOF handling for proper input matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_6.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Embedding Basic Action in ANTLR4 Grammar Rule\nDESCRIPTION: Demonstrates how to embed a simple Java action in an ANTLR4 grammar rule. The action prints a message after parsing a valid declaration.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ndecl: type ID ';' {System.out.println(\"found a decl\");} ;\ntype: 'int' | 'float' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Lexer Rules in ANTLR4\nDESCRIPTION: This snippet shows the definition of basic lexer rules in ANTLR4 for identifiers, integers, newlines, and whitespace. It includes the use of the 'skip' command to discard whitespace tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_14\n\nLANGUAGE: ANTLR4\nCODE:\n```\nID : [a-zA-Z]+ ; // match identifiers\nINT : [0-9]+ ; // match integers\nNEWLINE:'\n'? '\n' ; // return newlines to parser (is end-statement signal)\nWS : [ \t]+ -> skip ; // toss out whitespace\n```\n\n----------------------------------------\n\nTITLE: Setting Grammar-Level Options in ANTLR4 with Bash\nDESCRIPTION: Demonstrates how to override grammar-level options using the -D flag, specifically showing how to change the target language for code generation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Dlanguage=Java T.g4 # default\n$ antlr4 -Dlanguage=C T.g4\nerror(31): ANTLR cannot generate C code as of version 4.0b3\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR Runtime Package with NuGet\nDESCRIPTION: Command for installing the official ANTLR 4 runtime package for C# using NuGet Package Manager Console. This adds the required runtime dependency to your C# project.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/CSharp/src/README.md#2025-04-21_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nInstall-Package Antlr4.Runtime.Standard\n```\n\n----------------------------------------\n\nTITLE: Multiple Ambiguous Alternatives with One Predicate in ANTLR\nDESCRIPTION: Demonstrates a scenario where three alternatives are viable for the same input, but only one is predicated. In this case, ANTLR will pick the first alternative when the predicate evaluates to false.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nexpr: ID '(' expr ')' // array reference (ANTLR picks this one)\n \t| {istype()}? ID '(' expr ')' // ctor-style typecast\n \t| ID '(' expr ')' // function call\n \t;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing mathematical expressions. It includes support for unary minus, multiplication, addition, subtraction, member access, integers, and identifiers. The grammar also specifies lexer rules and includes a custom after-rule action to print the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Expressions_7.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\ne : e '.' ID\n  | e '.' 'this'\n  | '-' e\n  | e '*' e\n  | e ('+'|'-') e\n  | INT\n  | ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Declarator Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing declarators with various constructs. It includes a main 's' rule, a recursive 'declarator' rule for handling different declarator types, and lexer rules for identifiers, integers, and whitespace. The grammar also specifies a custom after-rule action to print the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Expression Parser Grammar Implementation in ANTLR4\nDESCRIPTION: ANTLR4 grammar that defines rules for parsing arithmetic expressions with operators (+, *, ++, --), integers, parentheses, and identifiers. The grammar includes labeled alternatives and returns an integer value from expression evaluation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleAlternativesWithCommonLabel_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : e '*' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> * <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | e '+' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> + <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | INT{$v = $INT.int;} # anInt\n  | '(' e ')'   {$v = $e.v;}     # parens\n  | left=e INC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"INC()\"):Concat(\" != null\"):Assert()>$v = $left.v + 1;}      # unary\n  | left=e DEC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"DEC()\"):Concat(\" != null\"):Assert()>$v = $left.v - 1;}      # unary\n  | ID {<AssignLocal(\"$v\",\"3\")>}        # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nINC : '++' ;\nDEC : '--' ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Visitor Pattern with ANTLR4 in JavaScript\nDESCRIPTION: Example demonstrating how to create and use a visitor with ANTLR4 in JavaScript. The code initializes the parser components and implements a basic visitor with a visitChildren method to traverse the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/javascript-target.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// test.js\nimport antlr4 from 'antlr4';\nimport MyGrammarLexer from './QueryLexer.js';\nimport MyGrammarParser from './QueryParser.js';\nimport MyGrammarListener from './QueryListener.js';\n\nconst input = \"field = 123 AND items in (1,2,3)\"\nconst chars = new antlr4.InputStream(input);\nconst lexer = new MyGrammarLexer(chars);\nconst tokens = new antlr4.CommonTokenStream(lexer);\nconst parser = new MyGrammarParser(tokens);\nconst tree = parser.MyQuery();\n\nclass Visitor {\n  visitChildren(ctx) {\n    if (!ctx) {\n      return;\n    }\n\n    if (ctx.children) {\n      return ctx.children.map(child => {\n        if (child.children && child.children.length != 0) {\n          return child.accept(this);\n        } else {\n          return child.getText();\n        }\n      });\n    }\n  }\n}\n\ntree.accept(new Visitor());\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Listener for ANTLR4 in JavaScript\nDESCRIPTION: Example showing how to extend a generated ANTLR4 listener to customize behavior. This implementation overrides the exitKey method to print a message when a key is found.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/javascript-target.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nclass KeyPrinter extends MyGrammarListener {\n    // override default listener behavior\n    exitKey(ctx) {\n        console.log(\"Oh, a key!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Combined ANTLR4 Grammars from File in Java\nDESCRIPTION: This Java method loads a combined grammar from a file, creates lexer and parser interpreters, and parses input. It demonstrates how to handle file input and grammar loading for ANTLR4 interpreters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/interpreters.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic static ParseTree parse(String fileName,\n                              String combinedGrammarFileName,\n                              String startRule)\n    throws IOException\n{\n    final Grammar g = Grammar.load(combinedGrammarFileName);\n    LexerInterpreter lexEngine = g.createLexerInterpreter(CharStreams.fromPath(Paths.get(fileName)));\n    CommonTokenStream tokens = new CommonTokenStream(lexEngine);\n    ParserInterpreter parser = g.createParserInterpreter(tokens);\n    ParseTree t = parser.parse(g.getRule(startRule).index);\n    System.out.println(\"parse tree: \"+t.toStringTree(parser));\n    return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Java-like Expressions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing Java-like expressions. It includes rules for various expression types, operator precedence, and basic token definitions. The grammar also specifies a custom after-rule action for the root rule 's'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_8.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with If-Then-Else Rules\nDESCRIPTION: Defines a grammar with support for if-then-else statements and basic identifiers. Includes initialization for ambiguity detection and DFA dumping after parsing. Contains lexer rules for identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n@after {<DumpDFA()>}\n   : '{' stat* '}' ;\nstat: 'if' ID 'then' stat ('else' ID)?\n       | 'return'\n       ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Custom Visitor in TypeScript\nDESCRIPTION: Example of creating a custom visitor class that extends the generated visitor. Shows how to implement the visitChildren method and use it to traverse the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/typescript-target.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ParserRuleContext } from 'antlr4';\nimport MyGrammarVisitor from './MyGrammarVisitor';\n\nclass CustomVisitor extends MyGrammarVisitor {\n\n  visitChildren(ctx: ParserRuleContext) {\n    if (!ctx) {\n      return;\n    }\n    if (ctx.children) {\n      return ctx.children.map(child => {\n        if (child.children && child.children.length != 0) {\n          return child.accept(this);\n        } else {\n          return child.getText();\n        }\n      });\n    }\n  }\n}\n\ntree.accept(new CustomVisitor());\n```\n\n----------------------------------------\n\nTITLE: Implementing String Parsing in ANTLR4 Lexer\nDESCRIPTION: This snippet shows how to implement string parsing in an ANTLR4 lexer. It uses modes to switch between default and string parsing modes, and the 'more' command to collect text for the string.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_16\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar Strings;\nLQUOTE : '\"' -> more, mode(STR) ;\nWS : [ \n\t\n]+ -> skip ;\nmode STR;\nSTRING : '\"' -> mode(DEFAULT_MODE) ; // token we want parser to see\nTEXT : . -> more ; // collect more text for string\n```\n\n----------------------------------------\n\nTITLE: Creating a Listener-based Expression Evaluator in Python\nDESCRIPTION: A listener implementation that evaluates expressions by storing results for each context in a dictionary, handling different expression types during tree traversal and printing final results.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom antlr4 import *\nfrom ExprParser import ExprParser\nfrom ExprListener import ExprListener\n\nclass ListenerInterp(ExprListener):\n    def __init__(self):\n        self.result = {}\n\n    def exitAtom(self, ctx:ExprParser.AtomContext):\n        self.result[ctx] = int(ctx.getText())\n\n    def exitExpr(self, ctx:ExprParser.ExprContext):\n        if ctx.getChildCount() == 3:\n            if ctx.getChild(0).getText() == \"(\":\n                self.result[ctx] = self.result[ctx.getChild(1)]\n            else:\n                opc = ctx.getChild(1).getText()\n                v1 = self.result[ctx.getChild(0)]\n                v2 = self.result[ctx.getChild(2)]\n                if opc == \"+\":\n                    self.result[ctx] = v1 + v2\n                elif opc == \"-\":\n                    self.result[ctx] = v1 - v2\n                elif opc == \"*\":\n                    self.result[ctx] = v1 * v2\n                elif opc == \"/\":\n                    self.result[ctx] = v1 / v2\n                else:\n                    ctx.result[ctx] = 0\n        elif ctx.getChildCount() == 2:\n            opc = ctx.getChild(0).getText()\n            if opc == \"+\":\n                v = self.result[ctx.getChild(1)]\n                self.result[ctx] = v\n            elif opc == \"-\":\n                v = self.result[ctx.getChild(1)]\n                self.result[ctx] = - v\n        elif ctx.getChildCount() == 1:\n            self.result[ctx] = self.result[ctx.getChild(0)]\n\n    def exitStart_(self, ctx:ExprParser.Start_Context):\n        for i in range(0, ctx.getChildCount(), 2):\n            print(self.result[ctx.getChild(i)])\n```\n\n----------------------------------------\n\nTITLE: ANTLR 4.7 CharStream Creation with Custom Encoding\nDESCRIPTION: Example of creating a character stream in ANTLR 4.7+ using the CharStreams factory method with a specified character encoding (Windows-1252 in this case).\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nCharStream input = CharStreams.fromFileName(\"inputfile\", Charset.forName(\"windows-1252\"));\n```\n\n----------------------------------------\n\nTITLE: Building an ANTLR4 Python Project with Shell Script\nDESCRIPTION: A build script that installs required dependencies and generates Python code from the ANTLR4 grammar, ensuring the correct target language is specified.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\nantlr4 -Dlanguage=Python3 Expr.g4\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Lexer Rules in ANTLR4\nDESCRIPTION: Example of a recursive lexer rule for matching nested structures like balanced curly braces, which is a distinctive capability of ANTLR lexers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_9\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar Recur;\n \nACTION : '{' ( ACTION | ~[{}] )* '}' ;\n \nWS : [ \\r\\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR4 PHP Runtime with Composer\nDESCRIPTION: Command to install the ANTLR4 PHP runtime using Composer package manager.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/php-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncomposer require antlr/antlr4-php-runtime\n```\n\n----------------------------------------\n\nTITLE: Simple Control Flow Statement Grammar in ANTLR4\nDESCRIPTION: Defines an ANTLR4 grammar that recognizes three control flow statements (break, continue, return) and outputs the matched text. The grammar includes a semantic action to write the matched text and handles multiple statements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Keyword_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nprogram : sempred*{<writeln(\"$text\")>} EOF ;\nsempred: 'break;' | 'continue;' | 'return;' ;\n```\n\n----------------------------------------\n\nTITLE: Generating JavaListener Interface in ANTLR 4\nDESCRIPTION: Example of an ANTLR-generated listener interface for a Java grammar. This interface extends ParseTreeListener and contains enter/exit methods for each grammar rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/listeners.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic interface JavaListener extends ParseTreeListener<Token> {\n  void enterClassDeclaration(JavaParser.ClassDeclarationContext ctx);\n  void exitClassDeclaration(JavaParser.ClassDeclarationContext ctx);\n  void enterMethodDeclaration(JavaParser.MethodDeclarationContext ctx);\n ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Channel Command in ANTLR4 Lexer Rules\nDESCRIPTION: This snippet shows how to use the 'channel' command in ANTLR4 lexer rules. It demonstrates sending comments and whitespace to a hidden channel.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_18\n\nLANGUAGE: ANTLR4\nCODE:\n```\nBLOCK_COMMENT\n\t: '/*' .*? '*/' -> channel(HIDDEN)\n\t;\nLINE_COMMENT\n\t: '//' ~[\\r\\n]* -> channel(HIDDEN)\n\t;\n... \n// ----------\n// Whitespace\n//\n// Characters and character constructs that are of no import\n// to the parser and are used to make the grammar easier to read\n// for humans.\n//\nWS : [ \\t\\r\\n\\f]+ -> channel(HIDDEN) ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with various operators, identifiers, and literals. It includes parser rules for expressions and lexer rules for tokens. The grammar handles dot notation, unary minus, multiplication, addition/subtraction, integers, and identifiers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Expressions_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\ne : e '.' ID\n  | e '.' 'this'\n  | '-' e\n  | e '*' e\n  | e ('+'|'-') e\n  | INT\n  | ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic ANTLR4 Parser in C#\nDESCRIPTION: Demonstrates the basic setup for parsing text using ANTLR4-generated lexer and parser classes. Shows initialization of character stream, lexer, token stream, and parser to generate a parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/csharp-target.md#2025-04-21_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing Antlr4.Runtime;\nusing Antlr4.Runtime.Tree;\n     \npublic void MyParseMethod() {\n      String input = \"your text to parse here\";\n      ICharStream stream = CharStreams.fromString(input);\n      ITokenSource lexer = new MyGrammarLexer(stream);\n      ITokenStream tokens = new CommonTokenStream(lexer);\n      MyGrammarParser parser = new MyGrammarParser(tokens);\n      IParseTree tree = parser.StartRule();\n}\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Listener with ANTLR4 Parse Tree Walker\nDESCRIPTION: Code snippet showing how to apply a custom listener to an ANTLR4 parse tree using the ParseTreeWalker. This demonstrates the pattern for traversing the parse tree with a listener.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/javascript-target.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n...\ntree = parser.MyStartRule() // assumes grammar \"MyGrammar\" has rule \"MyStartRule\"\nconst printer = new KeyPrinter();\nantlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);\n```\n\n----------------------------------------\n\nTITLE: Expression Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing arithmetic expressions with support for multiplication, division, addition, subtraction, parentheses, variables, and integers. Includes lexer rules for operators, identifiers, integers, newlines and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/AmbigLR_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\nprog:   stat ;\nstat:   expr NEWLINE       # printExpr\n    |   ID '=' expr NEWLINE# assign\n    |   NEWLINE   # blank\n    ;\nexpr:   expr ('*'|'/') expr      # MulDiv\n    |   expr ('+'|'-') expr      # AddSub\n    |   INT    # int\n    |   ID     # id\n    |   '(' expr ')'    # parens\n    ;\n\nMUL :   '*' ; // assigns token name to '*' used above in grammar\nDIV :   '/' ;\nADD :   '+' ;\nSUB :   '-' ;\nID  :   [a-zA-Z]+ ;      // match identifiers\nINT :   [0-9]+ ;// match integers\nNEWLINE:'\n'? '\n' ;     // return newlines to parser (is end-statement signal)\nWS  :   [ \t]+ -> skip ; // toss out whitespace\n```\n\n----------------------------------------\n\nTITLE: Using Custom Channels in ANTLR4 Lexer Rules\nDESCRIPTION: This snippet demonstrates how to use custom channels within ANTLR4 lexer rules, specifically for whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_5\n\nLANGUAGE: ANTLR4\nCODE:\n```\nWS : [ \\r\\t\\n]+ -> channel(WHITESPACE_CHANNEL) ;\n```\n\n----------------------------------------\n\nTITLE: Specifying Operator Associativity in ANTLR 4 Grammar Rules\nDESCRIPTION: Shows how to specify right-associativity for operators in ANTLR 4, demonstrated with ternary and assignment operators. The associativity is now specified at the alternative level rather than on individual tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/left-recursion.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\ne : e '*' e\n  | e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | INT\n  ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Java-like Expressions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing Java-like expressions. It includes support for method calls, object instantiation, array access, and various operators. The grammar also defines basic tokens like identifiers and integers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_11.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Parser and Tree Walker in Go\nDESCRIPTION: This Go code implements a main function that uses the ANTLR4-generated JSON parser and lexer. It defines a TreeShapeListener to walk the parse tree and print each context. The code reads JSON input from a file specified as a command-line argument.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_7\n\nLANGUAGE: golang\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/antlr4-go/antlr/v4\"\n\t\"./parser\"  // Note that with modules you may not be able to use a relative immport path\n\t\"os\"\n\t\"fmt\"\n)\n\ntype TreeShapeListener struct {\n\t*parser.BaseJSONListener\n}\n\nfunc NewTreeShapeListener() *TreeShapeListener {\n\treturn new(TreeShapeListener)\n}\n\nfunc (this *TreeShapeListener) EnterEveryRule(ctx antlr.ParserRuleContext) {\n\tfmt.Println(ctx.GetText())\n}\n\nfunc main() {\n\tinput, _ := antlr.NewFileStream(os.Args[1])\n\tlexer := parser.NewJSONLexer(input)\n\tstream := antlr.NewCommonTokenStream(lexer,0)\n\tp := parser.NewJSONParser(stream)\n\tp.AddErrorListener(antlr.NewDiagnosticErrorListener(true))\n\ttree := p.Json()\n\tantlr.ParseTreeWalkerDefault.Walk(NewTreeShapeListener(), tree)\n}\n```\n\n----------------------------------------\n\nTITLE: Using Unicode Properties in ANTLR Lexer Character Sets\nDESCRIPTION: Example of using Unicode properties in lexer character sets to match groups of code points based on their Unicode properties, including emoji, script-based characters, and negated properties.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nEMOJI : [\\p{Emoji}] ;\nJAPANESE : [\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Han}] ;\nNOT_CYRILLIC : [\\P{Script=Cyrillic}] ;\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Custom Listener in TypeScript\nDESCRIPTION: Example of creating a custom listener class that extends the generated listener. Demonstrates how to implement a specific rule exit method and use ParseTreeWalker to traverse the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/typescript-target.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ParseTreeWalker } from 'antlr4';\nimport MyGrammarListener from './MyGrammarListener';\n\nclass MyTreeWalker extends MyGrammarListener {\n\n    exitMyStartRule = (ctx: MyStartRuleContext) => {\n        console.log(\"In MyStartRule\");\n    };\n    \n}\n\nconst walker = new MyTreeWalker();\nParseTreeWalker.DEFAULT.walk(walker, tree);\n```\n\n----------------------------------------\n\nTITLE: Semantic Predicate with Fail Option\nDESCRIPTION: Example of using the fail option with a semantic predicate to provide a custom error message when the predicate condition fails. This helps provide more meaningful error messages to users.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_7\n\nLANGUAGE: g4\nCODE:\n```\nints[int max]\n \tlocals [int i=1]\n \t: INT ( ',' {$i++;} {$i<=$max}?<fail={\"exceeded max \"+$max}> INT )*\n \t;\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Expression Grammar in ANTLR4\nDESCRIPTION: A complete ANTLR4 grammar definition for parsing boolean expressions with AND/OR operators, boolean literals, and identifiers. The grammar supports parenthesized expressions and defines lexer rules for logical operators, identifiers, and whitespace skipping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/TokenMismatch3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nexpression\n:   value\n|   expression op=AND expression\n|   expression op=OR expression\n;\nvalue\n:   BOOLEAN_LITERAL\n|   ID\n|   ID1\n|   '(' expression ')'\n;\n\nAND : '&&';\nOR  : '||';\n\nBOOLEAN_LITERAL : 'true' | 'false';\n\nID  : [a-z]+;\nID1 : '$';\n\nWS  : [ \\t\\r\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexical Modes in ANTLR4\nDESCRIPTION: Lexical modes allow grouping lexical rules by context, creating multiple sublexers. The lexer starts in the default mode and can switch to other modes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR\nCODE:\n```\nrules in default mode\n...\nmode MODE1;\nrules in MODE1\n...\nmode MODEN;\nrules in MODEN\n...\n```\n\n----------------------------------------\n\nTITLE: Defining an Expression Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar definition for parsing logical expressions. The grammar handles identifiers, 'not', 'and', and 'or' operations with recursive rules. It includes lexer rules for identifiers, whitespace, and error handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/ExpressionGrammar_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\n\nprogram: expr EOF;\n\nexpr\n   : ID\n   | 'not' expr\n   | expr 'and' expr\n   | expr 'or' expr\n   ;\n\nID: [a-zA-Z_][a-zA-Z_0-9]*;\nWS: [ \\t\\n\\r\\f]+ -> skip;\nERROR: .;\n```\n\n----------------------------------------\n\nTITLE: Generating Go Parser Files with ANTLR4\nDESCRIPTION: This command invokes ANTLR4 to generate Go parser files from a JSON grammar. It creates several Go files in the parser directory, including the parser, lexer, and listener implementations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nantlr4 -Dlanguage=Go JSON.g4\n```\n\n----------------------------------------\n\nTITLE: Implementing a Listener-based Expression Evaluator Driver\nDESCRIPTION: A Python driver script that uses the listener-based approach for tree traversal, creating a parse tree walker and applying the listener to evaluate expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nfrom antlr4 import *\nfrom ExprLexer import ExprLexer\nfrom ExprParser import ExprParser\nfrom ListenerInterp import ListenerInterp\n\ndef main(argv):\n    input_stream = FileStream(argv[1])\n    lexer = ExprLexer(input_stream)\n    stream = CommonTokenStream(lexer)\n    parser = ExprParser(stream)\n    tree = parser.start_()\n    if parser.getNumberOfSyntaxErrors() > 0:\n        print(\"syntax errors\")\n    else:\n        linterp = ListenerInterp()\n        walker = ParseTreeWalker()\n        walker.walk(linterp, tree)\n\nif __name__ == '__main__':\n    main(sys.argv)\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom ANTLR4 Listener in C++\nDESCRIPTION: Complete example showing how to implement a custom listener for ANTLR4 generated parser, including initialization of lexer, parser, and tree walker\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/cpp-target.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\n#include \"antlr4-runtime.h\"\n#include \"MyGrammarLexer.h\"\n#include \"MyGrammarParser.h\"\n#include \"MyGrammarBaseListener.h\"\n\nusing namespace antlr4;\n\nclass TreeShapeListener : public MyGrammarBaseListener {\npublic:\n  void enterKey(ParserRuleContext *ctx) override {\n\t// Do something when entering the key rule.\n  }\n};\n\n\nint main(int argc, const char* argv[]) {\n  std::ifstream stream;\n  stream.open(argv[1]);\n  ANTLRInputStream input(stream);\n  MyGrammarLexer lexer(&input);\n  CommonTokenStream tokens(&lexer);\n  MyGrammarParser parser(&tokens);\n\n  tree::ParseTree *tree = parser.key();\n  TreeShapeListener listener;\n  tree::ParseTreeWalker::DEFAULT.walk(&listener, tree);\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Case-Insensitive Option in ANTLR4 Lexer Rules\nDESCRIPTION: This snippet shows how to use the caseInsensitive option in ANTLR4 lexer rules. It demonstrates setting the option globally and overriding it for a specific rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_20\n\nLANGUAGE: ANTLR4\nCODE:\n```\noptions { caseInsensitive=true; }\nSTRING options { caseInsensitive=false; } : 'N'? '\\'' (~'\\'' | '\\'\\''')* '\\'';\n```\n\n----------------------------------------\n\nTITLE: Defining OpenDeviceStatement Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar that defines parsing rules for 'OPEN DEVICE' statements with optional parameters. The grammar includes token definitions for various options (OPT1, OPT2, OPT3) and a parser rule that captures 'OPEN DEVICE' commands.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/OpenDeviceStatement_Case1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar OpenDeviceStatement;\nprogram : statement+ '.' ;\n\nstatement : 'OPEN' ( 'DEVICE' (  OPT1  |  OPT2  |  OPT3  )? )+ {<writeln(\"$text\")>} ;\n\nOPT1 : 'OPT-1';\nOPT2 : 'OPT-2';\nOPT3 : 'OPT-3';\n\nWS : (' '|'\\n')+ -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Using Character Negation in ANTLR4 Lexer Rules\nDESCRIPTION: Example showing how to use the negation operator (~) to match any character not in a specified set, here used to define single-line comments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_8\n\nLANGUAGE: ANTLR\nCODE:\n```\nCOMMENT : '#' ~[\\r\\n]* '\\r'? '\\n' -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Java-like Expressions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing Java-like expressions. It includes support for arithmetic operations, method calls, object instantiation, array access, and various other language constructs. The grammar handles operator precedence and associativity.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_6.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Expression Grammar Definition in ANTLR 4\nDESCRIPTION: A simple calculator grammar (CalcNoLR) for parsing expressions with addition, subtraction, multiplication, and division operations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/listeners.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar CalcNoLR;\n\ns : expr EOF ;\n\nexpr:\tadd ((MUL | DIV) add)* ;\n\nadd :   atom ((ADD | SUB) atom)* ;\n\natom : INT ;\n\nINT : [0-9]+;\nMUL : '*';\nDIV : '/';\nADD : '+';\nSUB : '-';\nWS : [ \\t]+ -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Generating ANTLR4 C++ Parser\nDESCRIPTION: Command to generate C++ lexer/parser code from an ANTLR grammar file using the C++ language target\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/cpp-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Dlanguage=Cpp MyGrammar.g4\n```\n\n----------------------------------------\n\nTITLE: Implementing Island Grammar for Class Definitions in ANTLR4\nDESCRIPTION: This ANTLR4 grammar defines an island grammar to parse simple class definitions without handling the internal details of methods and blocks.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_8\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar Island;\nfile : clazz* ;\nclazz : 'class' ID '{' ignore '}' ;\nignore : (method|.)*? ;\nmethod : type ID '()' block ;\ntype : 'int' | 'void' ;\nblock : '{' (block | .)*? '}' ;\nID : [a-zA-Z] [a-zA-Z0-9]* ;\nWS : [ \\r\\t\\n]+ -> skip ;\nANY : . ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Multiple Alternatives Rule\nDESCRIPTION: Demonstrates a parser rule with multiple alternatives separated by the | operator.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr4\nCODE:\n```\noperator:\n\tstat: retstat\n\t| 'break' ';'\n\t| 'continue' ';'\n\t;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Parser Rules\nDESCRIPTION: Defines a grammar 'T' with parser rules for handling sequences of '$' or '@' followed by optional integers and identifiers. Includes lexer rules for integers, identifiers and whitespace, with DFA dump functionality.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/CtxSensitiveDFATwoDiffInput.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<DumpDFA()>}\n  : ('$' a | '@' b)+ ;\na : e ID ;\nb : e INT ID ;\ne : INT | ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition for Boolean and Conditional Expressions\nDESCRIPTION: A grammar defining expressions with boolean operators (and, or, not), conditional operators (?:), and 'between' operations. The grammar includes rules for statements that end with semicolons or periods, and various expression forms.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\n\nstat : expr ';'\n     | expr '.'\n     ;\n\nexpr\n   : ID\n   | 'not' expr\n   | expr 'and' expr\n   | expr 'or' expr\n   | '(' ID ')' expr\n   | expr '?' expr ':' expr\n   | 'between' expr 'and' expr\n   ;\n\nID: [a-zA-Z_][a-zA-Z_0-9]*;\nWS: [ \\t\\n\\r\\f]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Channels in ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet shows how to define custom channels in an ANTLR4 lexer grammar, which can be used within lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR4\nCODE:\n```\nchannels {\n  WHITESPACE_CHANNEL,\n  COMMENTS_CHANNEL\n}\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Parser Rule\nDESCRIPTION: Shows the most basic form of an ANTLR parser rule with a Javadoc comment and single alternative.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\n/** Javadoc comment can precede rule */\nretstat : 'return' expr ';' ;\n```\n\n----------------------------------------\n\nTITLE: Custom ANTLR4 Listener Implementation in C#\nDESCRIPTION: Demonstrates implementation of a custom listener by extending the base listener class. Shows how to override the ExitKey method to provide custom behavior when exiting the 'key' rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/csharp-target.md#2025-04-21_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass KeyPrinter : MyGrammarBaseListener {\n    // override default listener behavior\n    void ExitKey (MyGrammarParser.KeyContext context) {\n        Console.WriteLine(\"Oh, a key!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Island Grammar for Nested Classes in ANTLR4\nDESCRIPTION: This ANTLR4 grammar extends the previous island grammar to handle nested class definitions by adding the 'clazz' alternative to the 'ignore' rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_9\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar Island;\nfile : clazz* ;\nclazz : 'class' ID '{' ignore '}' ;\nignore : (method|clazz|.)*? ; // <- only change is to add clazz alt here\nmethod : type ID '()' block ;\ntype : 'int' | 'void' ;\nblock : '{' (block | .)*? '}' ;\nID : [a-zA-Z] [a-zA-Z0-9]* ;\nWS : [ \\r\\t\\n]+ -> skip ;\nANY : . ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Expression Parsing\nDESCRIPTION: This ANTLR4 grammar named 'T' defines rules for parsing expressions. It includes a start rule that expects an expression followed by EOF, and an expression rule that can be either a single 'x' token or a combination of expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/DuplicatedLeftRecursiveCall_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : expr EOF;\nexpr : 'x'\n     | expr expr\n     ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing and evaluating simple arithmetic expressions. It includes support for multiplication, addition, parentheses, increment/decrement operations, and variable identifiers. The grammar also specifies lexer rules for integers, identifiers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsAndLabels_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : q=e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : a=e op='*' b=e {$v = $a.v * $b.v;}  # mult\n  | a=e '+' b=e {$v = $a.v + $b.v;}     # add\n  | INT{$v = $INT.int;}        # anInt\n  | '(' x=e ')' {$v = $x.v;}   # parens\n  | x=e '++'    {$v = $x.v+1;} # inc\n  | e '--'   # dec\n  | ID {$v = 3;}      # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Generating Dart Parser with ANTLR4 CLI\nDESCRIPTION: This command demonstrates how to use the ANTLR4 command-line tool to generate a Dart parser from a grammar file. It assumes ANTLR4 is set up as an alias on a UNIX system.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/dart-target.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nantlr4 -Dlanguage=Dart MyGrammar.g4\n```\n\n----------------------------------------\n\nTITLE: Generating JavaScript Lexer/Parser with ANTLR4 CLI\nDESCRIPTION: Command to generate JavaScript lexer/parser code from an ANTLR grammar file using the language target option.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/javascript-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Dlanguage=JavaScript MyGrammar.g4\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with various operators and precedence. It includes rules for multiplication, addition, ternary conditional, and assignment operations, as well as identifier recognition and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_7.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Custom Binary Stream Implementation\nDESCRIPTION: Custom ANTLR file stream implementation for enhanced binary data handling and representation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parsing-binary-files.md#2025-04-21_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nclass BinaryANTLRFileStream extends ANTLRFileStream {\n\tpublic BinaryANTLRFileStream(String fileName) throws IOException {\n\t\tsuper(fileName, \"ISO-8859-1\");\n\t}\n\n\t@Override\n\tpublic String getText(Interval interval) {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tint start = interval.a;\n\t\tint stop = interval.b;\n\t\tif(stop >= this.n) {\n\t\t\tstop = this.n - 1;\n\t\t}\n\n\t\tfor (int i = start; i<=stop; i++) {\n\t\t\tint v = data[i];\n\t\t\tbuf.append(v);\n\t\t}\n\t\treturn buf.toString();\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ANTLR4 Parser in Dart\nDESCRIPTION: This Dart code snippet shows a complete example of using ANTLR4-generated parser and lexer. It includes a custom TreeShapeListener and demonstrates how to parse a JSON file, walking through the parse tree and printing each context.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/dart-target.md#2025-04-21_snippet_2\n\nLANGUAGE: dart\nCODE:\n```\nimport 'package:antlr4/antlr4.dart';\nimport 'package:my_project/JSONParser.dart';\nimport 'package:my_project/JSONLexer.dart';\n\nclass TreeShapeListener implements ParseTreeListener {\n  @override\n  void enterEveryRule(ParserRuleContext ctx) {\n    print(ctx.text);\n  }\n\n  @override\n  void exitEveryRule(ParserRuleContext node) {\n  }\n\n  @override\n  void visitErrorNode(ErrorNode node) {\n  }\n\n  @override\n  void visitTerminal(TerminalNode node) {\n  }\n}\n\nvoid main(List<String> args) async {\n  JSONLexer.checkVersion();\n  JSONParser.checkVersion();\n  final input = await InputStream.fromPath(args[0]);\n  final lexer = JSONLexer(input);\n  final tokens = CommonTokenStream(lexer);\n  final parser = JSONParser(tokens);\n  parser.addErrorListener(DiagnosticErrorListener());\n  final tree = parser.json();\n  ParseTreeWalker.DEFAULT.walk(TreeShapeListener(), tree);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating C++ Parser Code from Grammar\nDESCRIPTION: Commands to generate C++ parser code from an ANTLR grammar file by specifying the target language and listing the resulting C++ files. Shows how to use the -Dlanguage option.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Dlanguage=Cpp Expr.g4\n$ ls Expr*.cpp Expr*.h\nExprBaseListener.cpp  ExprLexer.cpp         ExprListener.cpp      ExprParser.cpp\nExprBaseListener.h    ExprLexer.h           ExprListener.h        ExprParser.h\n```\n\n----------------------------------------\n\nTITLE: Using Fragment Rules for Integer Recognition in ANTLR4\nDESCRIPTION: Example of using a fragment rule to define a common pattern (digits) that is used by an actual token rule (INT).\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nINT : DIGIT+ ; // references the DIGIT helper rule\nfragment DIGIT : [0-9] ; // not a token by itself\n```\n\n----------------------------------------\n\nTITLE: Accessing Token Attributes with Labels in ANTLR4\nDESCRIPTION: Illustrates various ways to access token attributes in ANTLR4 grammar actions, including using labels and direct token references.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR4\nCODE:\n```\nr : INT {int x = $INT.line;}\n    ( ID {if ($INT.line == $ID.line) ...;} )?\n    a=FLOAT b=FLOAT {if ($a.line == $b.line) ...;}\n  ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Grammar with Enum Token Rules\nDESCRIPTION: Defines a lexer grammar with competing rules for the 'enum' token using semantic predicates. Includes identifier and whitespace rules along with DFA state transitions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/DisableRule.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nE1 : 'enum' { <False()> }? ;\nE2 : 'enum' { <True()> }? ;  // winner not E1 or ID\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Unix Installation Commands for ANTLR4\nDESCRIPTION: Series of commands to manually install ANTLR4 on Unix systems, including downloading the JAR file, adding it to the CLASSPATH, and creating command aliases.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ cd /usr/local/lib\n$ curl -O https://www.antlr.org/download/antlr-4.13.2-complete.jar\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ export CLASSPATH=\".:/usr/local/lib/antlr-4.13.2-complete.jar:$CLASSPATH\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ alias antlr4='java -Xmx500M -cp \"/usr/local/lib/antlr-4.13.2-complete.jar:$CLASSPATH\" org.antlr.v4.Tool'\n$ alias grun='java -Xmx500M -cp \"/usr/local/lib/antlr-4.13.2-complete.jar:$CLASSPATH\" org.antlr.v4.gui.TestRig'\n```\n\n----------------------------------------\n\nTITLE: Using a Parse Listener During Parsing in ANTLR 4\nDESCRIPTION: Example showing how to attach a listener to the parser to execute code during the parsing process instead of after completion.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/listeners.md#2025-04-21_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nString input = \"2 + 8 / 2\";\nCalcNoLRLexer lexer = new CalcNoLRLexer(new ANTLRInputStream(input));\nCalcNoLRParser parser = new CalcNoLRParser(new CommonTokenStream(lexer));\nCountListener counter = new CountListener();\nparser.addParseListener(counter);\n\n// Check that the purses valid first\nCalcNoLRParser.SContext context = parser.s();\nString parseTreeS = context.toStringTree(parser);\nassertEquals(\"(s (expr (add (atom 2) + (atom 8)) / (add (atom 2))) <EOF>)\", parseTreeS);\nassertEquals(3, counter.nums);\nassertEquals(true, counter.execExitS);\n```\n\n----------------------------------------\n\nTITLE: Basic Parser Implementation in JavaScript\nDESCRIPTION: Example showing how to initialize and run an ANTLR4 parser in JavaScript. This code creates input streams, lexer, token stream, and parser to parse input text according to the grammar rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/javascript-target.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport antlr4 from 'antlr4';\nimport MyGrammarLexer from './MyGrammarLexer.js';\nimport MyGrammarParser from './MyGrammarParser.js';\nimport MyGrammarListener from './MyGrammarListener.js';\n\nconst input = \"your text to parse here\"\nconst chars = new antlr4.InputStream(input);\nconst lexer = new MyGrammarLexer(chars);\nconst tokens = new antlr4.CommonTokenStream(lexer);\nconst parser = new MyGrammarParser(tokens);\nconst tree = parser.MyStartRule();\n```\n\n----------------------------------------\n\nTITLE: ANTLR Rule with Parameters and Return Values\nDESCRIPTION: Example of a rule that takes parameters and returns values, demonstrating attribute usage.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_12\n\nLANGUAGE: java\nCODE:\n```\n// Return the argument plus the integer value of the INT token\nadd[int x] returns [int result] : '+=' INT {$result = $x + $INT.int;} ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing complex expressions, including arithmetic operations, method calls, object instantiation, and type casting. It includes lexer rules for identifiers and integers, and handles operator precedence and associativity.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Basic ANTLR4 Rule Structure\nDESCRIPTION: This snippet demonstrates the basic structure of rules in ANTLR4 grammars, showing alternatives separated by the | operator.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nruleName : alternative1 | ... | alternativeN ;\n```\n\n----------------------------------------\n\nTITLE: Using Type Command in ANTLR4 Lexer Rules\nDESCRIPTION: This snippet demonstrates the use of the 'type' command in ANTLR4 lexer rules. It shows how to set the token type for different string literals to a common STRING type.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_17\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar SetType;\ntokens { STRING }\nDOUBLE : '\"' .*? '\"'   -> type(STRING) ;\nSINGLE : '\\'' .*? '\\'' -> type(STRING) ;\nWS     : [ \n\t\n]+    -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Control Flow Statements\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing a program containing simple control flow statements. It includes a main 'program' rule that allows multiple 'ruleIndexMap' instances, followed by a custom action to print the parsed text, and an EOF marker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Keyword_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nprogram : ruleIndexMap*{<writeln(\"$text\")>} EOF ;\nruleIndexMap: 'break;' | 'continue;' | 'return;' ;\n```\n\n----------------------------------------\n\nTITLE: Parsing Expressions with Text Tree Output\nDESCRIPTION: Using antlr4-parse to parse an expression and display the parse tree in text form. The example parses \"10+20*30\" and shows the resulting tree structure.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4-parse Expr.g4 prog -tree\n10+20*30\n^D\n(prog:1 (expr:2 (expr:3 10) + (expr:1 (expr:3 20) * (expr:3 30))) <EOF>)\n```\n\n----------------------------------------\n\nTITLE: Configuring Whitespace Token Handling in ANTLR4\nDESCRIPTION: This snippet shows a whitespace rule configuration in ANTLR4. By using the 'skip' command, whitespace tokens are removed from the token stream. To make whitespace tokens available in the token stream while still invisible to the parser, 'channel(HIDDEN)' should be used instead.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/lexical.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nWS : [ \\t\\r\\n\\u000C]+ -> skip\n   ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple arithmetic expressions. It includes operator precedence, right associativity for some operators, and a custom after-rule action to print the parse tree. The grammar handles multiplication, addition, ternary conditional, assignment, and identifier tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Custom IP Parser Listener Implementation\nDESCRIPTION: Custom listener implementation to process parsed IP addresses and convert them to readable format.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parsing-binary-files.md#2025-04-21_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nclass MyIPListener extends IPBaseListener {\n\t@Override\n\tpublic void exitIp(IPParser.IpContext ctx) {\n\t\tList<TerminalNode> octets = ctx.BYTE();\n\t\tshort[] ip = new short[4];\n\t\tfor (int i = 0; i<octets.size(); i++) {\n\t\t\tString oneCharStringHoldingOctet = octets.get(i).getText();\n\t\t\tip[i] = (short)oneCharStringHoldingOctet.charAt(0);\n\t\t}\n\t\tSystem.out.println(Arrays.toString(ip));\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR Go Package with 'go get'\nDESCRIPTION: Command to install the ANTLR Go runtime package. The Go target has a dedicated repository for importing, though development still happens in the main ANTLR repository.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ go get github.com/antlr4-go/antlr\n```\n\n----------------------------------------\n\nTITLE: Accessing Literal Tokens with Labels in ANTLR4\nDESCRIPTION: Demonstrates how to access attributes of literal tokens in ANTLR4 grammar actions by using labels.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR4\nCODE:\n```\nstat: r='return' expr ';' {System.out.println(\"line=\"+$r.line);} ;\n```\n\n----------------------------------------\n\nTITLE: Creating Nongreedy Lexer Rule for Strings with Escaped Quotes in ANTLR4\nDESCRIPTION: This ANTLR4 grammar snippet defines a nongreedy lexer rule for matching strings that allow '\\\"' as an escaped quote character.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar Nongreedy;\ns : STRING+ ;\nSTRING : '\"' ( '\\\\\"' | . )*? '\"' ; // match \"foo\", \"\\\"\", \"x\\\"\\\"y\", ...\nWS : [ \\r\\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Control Flow Structures\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing control flow structures. It includes a root rule, a 'continue' rule with multiple alternatives, and an 'args' rule. The grammar also defines lexer rules for keywords like 'for', 'break', 'if', and 'continue'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/ReservedWordsEscaping.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar G;\n\nroot\n    : {0==0}? continue+ {<write(\"$text\")>}\n    ;\n\ncontinue returns [<IntArg(\"return\")>]\n    : for for? {1==1}?              #else\n    | break=BREAK BREAK+ (for | IF) #else\n    | if+=IF  if+=IF*               #int\n    | continue CONTINUE_ {<AssignLocal(\"$return\",\"0\")>}   #class\n    ;\n\nargs[int else] locals [<IntArg(\"return\")>]\n    : for\n    ;\n\nfor: FOR;\nFOR: 'for ';\nBREAK: 'break ';\nIF: 'if ';\nCONTINUE_: 'continue';\n```\n\n----------------------------------------\n\nTITLE: Accessing Token Objects in ANTLR4 Grammar Actions\nDESCRIPTION: Shows how to access the Token object itself in ANTLR4 grammar actions, useful for checking if an optional subrule matched a token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR4\nCODE:\n```\nstat: 'if' expr 'then' stat (el='else' stat)?\n{if ( $el!=null ) System.out.println(\"found an else\");}\n| ...\n;\n```\n\n----------------------------------------\n\nTITLE: Logical Expression Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing logical expressions with 'not', 'and', and 'or' operators. Includes rules for identifiers and whitespace handling. The grammar is designed to test parser performance with complex boolean expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/ExpressionGrammar_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\n\nprogram: expr EOF;\n\nexpr\n   : ID\n   | 'not' expr\n   | expr 'and' expr\n   | expr 'or' expr\n   ;\n\nID: [a-zA-Z_][a-zA-Z_0-9]*;\nWS: [ \\t\\n\\r\\f]+ -> skip;\nERROR: .;\n```\n\n----------------------------------------\n\nTITLE: Creating and Using ANTLR4 Interpreters in Java\nDESCRIPTION: This snippet demonstrates how to create LexerGrammar and Grammar objects, then use them to create and run lexer and parser interpreters in Java. It includes setting up the grammar, creating interpreters, and parsing input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/interpreters.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nLexerGrammar lg = new LexerGrammar(\n    \"lexer grammar L;\\n\" +\n    \"A : 'a' ;\\n\" +\n    \"B : 'b' ;\\n\" +\n    \"C : 'c' ;\\n\");\nGrammar g = new Grammar(\n    \"parser grammar T;\\n\" +\n    \"s : (A|B)* C ;\\n\",\n    lg);   \nLexerInterpreter lexEngine =\n    lg.createLexerInterpreter(new ANTLRInputStream(input));\nCommonTokenStream tokens = new CommonTokenStream(lexEngine);\nParserInterpreter parser = g.createParserInterpreter(tokens);\nParseTree t = parser.parse(g.rules.get(startRule).index);\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Expression Parser\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple expressions. It includes support for dot notation, unary minus, multiplication, addition/subtraction, integers, and identifiers. The grammar also specifies lexer rules for tokens and handles whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Expressions_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\ne : e '.' ID\n  | e '.' 'this'\n  | '-' e\n  | e '*' e\n  | e ('+'|'-') e\n  | INT\n  | ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Expression Grammar Definition in ANTLR4\nDESCRIPTION: ANTLR4 grammar that defines rules for parsing arithmetic expressions. Includes support for multiplication, addition, increment/decrement operators, parentheses grouping, integers and identifiers. Contains embedded actions to compute expression values.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsAndLabels_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : q=e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : a=e op='*' b=e {$v = $a.v * $b.v;}  # mult\n  | a=e '+' b=e {$v = $a.v + $b.v;}     # add\n  | INT{$v = $INT.int;}        # anInt\n  | '(' x=e ')' {$v = $x.v;}   # parens\n  | x=e '++'    {$v = $x.v+1;} # inc\n  | e '--'   # dec\n  | ID {$v = 3;}      # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Right-Associative Expression Grammar Definition in ANTLR4\nDESCRIPTION: Grammar definition that includes right-associative operators for multiplication, addition, conditional expressions, and assignment. The grammar parses simple identifiers and includes rules for whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar Definition with Action\nDESCRIPTION: Defines a grammar named T with parser rule 'a' that matches an identifier followed by an integer. Includes lexer rules for ID, INT, and whitespace, with an embedded action to print the matched text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ID INT {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Creating an Error-Throwing Listener in ANTLR 4\nDESCRIPTION: Example of a listener that intentionally throws a NullPointerException from one of its methods to demonstrate exception handling during parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/listeners.md#2025-04-21_snippet_6\n\nLANGUAGE: java\nCODE:\n```\n// Now throw an exception in the listener\nclass ErrorListener extends CalcNoLRBaseListener {\n\tpublic boolean execExitS = false;\n\tpublic boolean execExitAtom = false;\n\n\t@Override\n\tpublic void exitS(CalcNoLRParser.SContext ctx) {\n\t\texecExitS = true;\n\t}\n\n\t@Override\n\tpublic void exitAtom(CalcNoLRParser.AtomContext ctx) {\n\t\texecExitAtom = true;\n\t\tthrow new NullPointerException(\"bail out\");\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Helper Rules for Identifier Parsing in ANTLR4\nDESCRIPTION: Example showing how to define an ID token that references a LETTER fragment rule for recognizing identifiers in a language.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_5\n\nLANGUAGE: ANTLR\nCODE:\n```\nID : LETTER (LETTER|'0'..'9')* ;\n \nfragment\nLETTER : [a-zA-Z\\u0080-\\u00FF_] ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing with Operator Precedence\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with multiplication and addition operators. It uses semantic predicates to handle operator precedence and includes exact ambiguity detection. The grammar also defines lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/ExprAmbiguity_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n:   expr[0] {<ToStringTree(\"$expr.ctx\"):writeln()>};\n   expr[int _p]\n       : ID\n       (\n  {5 >= $_p}? '*' expr[6]\n  | {4 >= $_p}? '+' expr[5]\n       )*\n       ;\nID  : [a-zA-Z]+ ;\nWS  : [ \\r\\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Compiling and Testing Fuzzy Java Parser in ANTLR4\nDESCRIPTION: This bash script demonstrates how to compile and test the FuzzyJava grammar using ANTLR4 tools and grun, showing the extraction of constants from a Java file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 FuzzyJava.g4\n$ javac FuzzyJava*.java\n$ grun FuzzyJava file C.java\nconstant: A\nconstant: B\nconstant: C\n```\n\n----------------------------------------\n\nTITLE: Compiling ANTLR4 with Maven\nDESCRIPTION: Commands to clean the Maven repository, set memory options, and compile ANTLR4 using Maven.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/building-antlr.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ export MAVEN_OPTS=\"-Xmx1G\"   # don't forget this on linux\ncd /tmp/antlr4 # or wherever you have the software\nrm -rf ~/.m2/repository/org/antlr*\nmvn clean\nmvn -DskipTests install\n```\n\n----------------------------------------\n\nTITLE: Getting Text from Token Stream Example\nDESCRIPTION: Simple example showing how to get text from a token stream using a parse tree subtree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/parse-trees.md#2025-04-21_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nmytokens.getText(mySubTree);\n```\n\n----------------------------------------\n\nTITLE: Parser Grammar Referencing Ambiguous Tokens in ANTLR4\nDESCRIPTION: Example showing how a parser grammar can reference ambiguous tokens by token name but not by string literal, which would result in a tool error.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_11\n\nLANGUAGE: ANTLR\nCODE:\n```\nparser grammar P;\noptions { tokenVocab=L; }\na : '&' // results in a tool error: no such token\n    AND // no problem\n    MASK // no problem\n  ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Rule Attribute Definition Syntax\nDESCRIPTION: Shows the general syntax for defining rule attributes including arguments, return values, and local variables.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_11\n\nLANGUAGE: java\nCODE:\n```\nrulename[args] returns [retvals] locals [localvars] : ... ;\n```\n\n----------------------------------------\n\nTITLE: Implementing ANTLR4 Grammar with Ambiguous Alternatives for Testing\nDESCRIPTION: This grammar defines a parser that intentionally creates ambiguity between alternative productions. It uses semantic predicates and actions to demonstrate how ANTLR4 handles ambiguity detection and resolution both in ATN and DFA modes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/TwoUnpredicatedAlts.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : {<LL_EXACT_AMBIG_DETECTION()>} a ';' a; // do 2x: once in ATN, next in DFA\na : ID {<writeln(\"\\\"alt 1\\\"\")>}\n  | ID {<writeln(\"\\\"alt 2\\\"\")>}\n  | {<False()>}? ID {<writeln(\"\\\"alt 3\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard with Escape Character in ANTLR4\nDESCRIPTION: Example showing how to use the dot wildcard to match any single character, here used to match any escaped character.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_6\n\nLANGUAGE: ANTLR\nCODE:\n```\nESC : '\\\\' . ; // match any escaped \\x character\n```\n\n----------------------------------------\n\nTITLE: Expression Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a complete grammar for parsing mathematical expressions with support for basic arithmetic operations (+, -, *, /), parentheses grouping, variable assignments, and integer literals. Includes lexer rules for tokens and handling of whitespace and newlines.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/AmbigLR_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\nprog:   stat ;\nstat:   expr NEWLINE       # printExpr\n    |   ID '=' expr NEWLINE# assign\n    |   NEWLINE   # blank\n    ;\nexpr:   expr ('*'|'/') expr      # MulDiv\n    |   expr ('+'|'-') expr      # AddSub\n    |   INT    # int\n    |   ID     # id\n    |   '(' expr ')'    # parens\n    ;\n\nMUL :   '*' ; // assigns token name to '*' used above in grammar\nDIV :   '/' ;\nADD :   '+' ;\nSUB :   '-' ;\nID  :   [a-zA-Z]+ ;      // match identifiers\nINT :   [0-9]+ ;// match integers\nNEWLINE:'\n'? '\n' ;     // return newlines to parser (is end-statement signal)\nWS  :   [ \t]+ -> skip ; // toss out whitespace\n```\n\n----------------------------------------\n\nTITLE: Accessing Parser Rule Attributes in ANTLR4\nDESCRIPTION: Demonstrates how to access parser rule attributes in ANTLR4 grammar actions, including using rule labels and accessing attributes of the current rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_5\n\nLANGUAGE: ANTLR4\nCODE:\n```\nreturnStat : 'return' expr {System.out.println(\"matched \"+$expr.text);} ;\n```\n\nLANGUAGE: ANTLR4\nCODE:\n```\nreturnStat : 'return' e=expr {System.out.println(\"matched \"+$e.text);} ;\n```\n\nLANGUAGE: ANTLR4\nCODE:\n```\nreturnStat : 'return' expr {System.out.println(\"first token \"+$start.getText());} ;\n```\n\n----------------------------------------\n\nTITLE: Creating a Worker for ACE Editor\nDESCRIPTION: This code snippet shows how to create a worker for the ACE Editor to handle syntax validation. It sets up event listeners for errors and annotations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nvar WorkerClient = require(\"ace/worker/worker_client\").WorkerClient;\nthis.createWorker = function(session) {\n    this.$worker = new WorkerClient([\"ace\"], \"ace/worker/my-worker\", \"MyWorker\", \"../js/my-worker.js\");\n    this.$worker.attachToDocument(session.getDocument());\n\n    this.$worker.on(\"errors\", function(e) {\n        session.setAnnotations(e.data);\n    });\n\n    this.$worker.on(\"annotate\", function(e) {\n        session.setAnnotations(e.data);\n    });\n\n    this.$worker.on(\"terminate\", function() {\n        session.clearAnnotations();\n    });\n\n    return this.$worker;\n\n};\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Labeled Alternatives Grammar\nDESCRIPTION: Example of labeled alternatives in a grammar using the # operator for precise parse-tree listener events.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr4\nCODE:\n```\ngrammar T;\nstat: 'return' e ';' # Return\n\t| 'break' ';' # Break\n\t;\ne   : e '*' e # Mult\n    | e '+' e # Add\n    | INT # Int\n    ;\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Parser Interpreter in ANTLR v4\nDESCRIPTION: Shows how to programmatically create lexer and parser grammars and use them with the ANTLR interpreter. It demonstrates creating a lexer interpreter and parser interpreter from grammar definitions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/CHANGES.txt#2025-04-21_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nLexerGrammar lg = new LexerGrammar(\n\t\"lexer grammar L;\\n\" +\n  \t\"A : 'a' ;\\n\" +\n  \t\"B : 'b' ;\\n\" +\n  \t\"C : 'c' ;\\n\");\nGrammar g = new Grammar(\n  \t\"parser grammar T;\\n\" +\n  \t\"s : (A{;}|B)* C ;\\n\",\n  \tlg);\n\nLexerInterpreter lexEngine = lg.createLexerInterpreter(new ANTLRInputStream(input));\nCommonTokenStream tokens = new CommonTokenStream(lexEngine);\nParserInterpreter parser = g.createParserInterpreter(tokens);\nParseTree t = parser.parse(g.rules.get(startRule).index);\n```\n\n----------------------------------------\n\nTITLE: Expression Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing expressions including multiplication, addition, ternary operations, and assignment. Features right associativity for ternary and assignment operators, along with basic identifier and whitespace rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_8.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |\\<assoc=right> e '?' e ':' e\n  |\\<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Unicode Character Support\nDESCRIPTION: Specifies a grammar rule 'a' that matches LETTERS token and outputs the matched text. The LETTERS token matches sequences containing 'a' and specific Unicode characters followed by 'c'. Includes Java-style Unicode escape sequences with double backslashes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeEscapedSMPSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : LETTERS  {<InputText():writeln()>} ;\n// Note the double-backslash to avoid Java passing\n// unescaped values as part of the grammar.\nLETTERS : ('a'|'\\\\u{1D5BA}'|'\\\\u{1D5BE}'|'\\\\u{1D5C2}'|'\\\\u{1D5C8}'|'\\\\u{1D5CE}')* 'c';\n```\n\n----------------------------------------\n\nTITLE: Using ANTLR4 Separate Grammar Parser in Java\nDESCRIPTION: This snippet demonstrates how to use the parse method for separate lexer and parser grammar files in Java. It calls the parse method with a file to parse, lexer and parser grammar files, and a start rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/interpreters.md#2025-04-21_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nParseTree t = parse(fileName, XMLLexerGrammar, XMLParserGrammar, \"document\");\n```\n\n----------------------------------------\n\nTITLE: Character Set Examples in ANTLR4 Lexer Rules\nDESCRIPTION: Examples showing various character set patterns including whitespace, Unicode properties, identifiers, emoji, and special character handling in ANTLR4 lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR\nCODE:\n```\nWS : [ \\n\\u000D] -> skip ; // same as [ \\n\\r]\n\nUNICODE_WS : [\\p{White_Space}] -> skip; // match all Unicode whitespace\n\nID : [a-zA-Z] [a-zA-Z0-9]* ; // match usual identifier spec\n\nUNICODE_ID : [\\p{Alpha}\\p{General_Category=Other_Letter}] [\\p{Alnum}\\p{General_Category=Other_Letter}]* ; // match full Unicode alphabetic ids\n\nEMOJI : [\\u{1F4A9}\\u{1F926}] ; // note Unicode code points > U+FFFF\n\nDASHBRACK : [\\-\\]]+ ; // match - or ] one or more times\n\nDASH : [---] ; // match a single -, i.e., \"any character\" between - and - (note first and last - not escaped)\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Compound Operators\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with compound operators. It includes rules for multiplication, comma-separated expressions, a send operation, and identifier recognition. The grammar also specifies a tree-building after-action for the start rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList2_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr ',' b+=expr #Comma\n    | b+=expr '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n   ;\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Worker for ACE Editor\nDESCRIPTION: This code implements a basic worker for ACE Editor. It sets up the worker structure and includes a simple validation function that always returns a hello message.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimportScripts(\"worker-base.js\");\nace.define('ace/worker/my-worker',[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\"], function(require, exports, module) {\n    \"use strict\";\n\n    var oop = require(\"ace/lib/oop\");\n    var Mirror = require(\"ace/worker/mirror\").Mirror;\n\n    var MyWorker = function(sender) {\n        Mirror.call(this, sender);\n        this.setTimeout(200);\n        this.$dialect = null;\n    };\n\n    oop.inherits(MyWorker, Mirror);\n\n    (function() {\n\n        this.onUpdate = function() {\n            var value = this.doc.getValue();\n            var annotations = validate(value);\n            this.sender.emit(\"annotate\", annotations);\n        };\n\n    }).call(MyWorker.prototype);\n\n    exports.MyWorker = MyWorker;\n});\n\nvar validate = function(input) {\n    return [ { row: 0, column: 0, text: \"MyMode says Hello!\", type: \"error\" } ];\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Up Java and Maven Environment on Ubuntu\nDESCRIPTION: Bash script to check and install Java and Maven on a clean Ubuntu system.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/building-antlr.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt-get update\n$ # Get Java\n$ java > /dev/null 2>&1\n$ if [[ \"$?\" != \"0\" ]]; then sudo apt install -y openjdk-11-jre-headless; fi\n$ # Get Mvn\n$ mvn > /dev/null 2>&1\n$ if [[ \"$?\" != \"0\" ]]; then sudo apt install -y maven; fi\n```\n\n----------------------------------------\n\nTITLE: Setting up ANTLR4 Basic Environment Configuration\nDESCRIPTION: Basic setup for ANTLR4 including alias definitions and initial CLASSPATH configuration that leads to a common error where the parser cannot be found due to missing current directory in CLASSPATH.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/installation.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ alias antlr4='java -jar /usr/local/lib/antlr-4.2.2-complete.jar'\n$ alias grun='java org.antlr.v4.runtime.misc.TestRig'\n$ export CLASSPATH=\"/usr/local/lib/antlr-4.2.2-complete.jar\"\n$ antlr4 Hello.g4\n$ javac Hello*.java\n$ grun Hello r -tree\nCan't load Hello as lexer or parser\n$\n```\n\n----------------------------------------\n\nTITLE: Custom Exception Handling in ANTLR Rules\nDESCRIPTION: Demonstrates how to override default exception handling for a specific rule by specifying custom catch blocks.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_10\n\nLANGUAGE: java\nCODE:\n```\nr : ...\n  ;\n  catch[RecognitionException e] { throw e; }\n```\n\nLANGUAGE: java\nCODE:\n```\nr : ...\n  ;\n  catch[FailedPredicateException fpe] { ... }\n  catch[RecognitionException e] { ... }\n```\n\nLANGUAGE: java\nCODE:\n```\nr : ...\n  ;\n  // catch blocks go first\n  finally { System.out.println(\"exit rule r\"); }\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar with Column-Based Token Recognition\nDESCRIPTION: This ANTLR4 lexer grammar defines tokens that are recognized based on their column position. It uses semantic predicates to check the column position and categorize letter sequences into WORD1 (for columns < 2) and WORD2 (for columns >= 2). Each matched token's text is written to the output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/LexerInputPositionSensitivePredicates.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nWORD1 : ID1+ { <Text():writeln()> } ;\nWORD2 : ID2+ { <Text():writeln()> } ;\nfragment ID1 : { <Column()> \\< 2 }? [a-zA-Z];\nfragment ID2 : { <Column()> >= 2 }? [a-zA-Z];\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Combining Predicates from Multiple Alternatives in ANTLR\nDESCRIPTION: Shows how ANTLR combines predicates from different alternatives with logical OR when making a parsing decision. This example illustrates a rule where the parser will only predict an expression if either predicate evaluates to true.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nstat: decl | expr ;\ndecl: ID ID ;\nexpr: {istype()}? ID '(' expr ')' // ctor-style typecast\n \t| {isfunc()}? ID '(' expr ')' // function call\n \t;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar for IP Address Parsing\nDESCRIPTION: Complete grammar definition for parsing IP addresses and markers from binary data, including byte matching rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parsing-binary-files.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar IP;\n\nfile : ip+ (MARKER ip)* ;\n\nip : BYTE BYTE BYTE BYTE ;\n\nMARKER : '\\u00CA' '\\u00FE' ;\nBYTE : '\\u0000'..'\\u00FF' ;\n```\n\n----------------------------------------\n\nTITLE: Symbol Table Scope Management Example\nDESCRIPTION: Example of using a listener to manage symbol table scopes in a compiler implementation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/parse-trees.md#2025-04-21_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nscopeStack.peek().define(new VariableSymbol(\"foo\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Nongreedy Lexer Rule for C-style Comments in ANTLR4\nDESCRIPTION: This ANTLR4 lexer rule defines a nongreedy match for C-style comments, consuming any characters until it encounters the trailing '*/'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nCOMMENT : '/*' .*? '*/' -> skip ; // .*? matches anything until the first */\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expressions\nDESCRIPTION: This snippet defines the grammar rules for parsing arithmetic expressions. It includes rules for binary operations, unary operations, integers, parentheses, and identifiers. The grammar also specifies actions for calculating expression values using Java code.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleAlternativesWithCommonLabel_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : e '*' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> * <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | e '+' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> + <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | INT{$v = $INT.int;} # anInt\n  | '(' e ')'   {$v = $e.v;}     # parens\n  | left=e INC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"INC()\"):Concat(\" != null\"):Assert()>$v = $left.v + 1;}      # unary\n  | left=e DEC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"DEC()\"):Concat(\" != null\"):Assert()>$v = $left.v - 1;}      # unary\n  | ID {<AssignLocal(\"$v\",\"3\")>}        # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nINC : '++' ;\nDEC : '--' ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Declaring Parser-Only ANTLR4 Grammar\nDESCRIPTION: This snippet shows how to declare a parser-only grammar in ANTLR4, which only allows parser rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar Name;\n...\n```\n\n----------------------------------------\n\nTITLE: Testing for Specific Expression Patterns in ANTLR4\nDESCRIPTION: Shows how to test if a parse tree matches a specific expression pattern. The example checks if the tree is an expression with an identifier added to 0.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tree-matching.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nParseTree t = ...; // assume t is an expression\nParseTreePattern p = parser.compileParseTreePattern(\"<ID>+0\", MyParser.RULE_expr);\nParseTreeMatch m = p.match(t);\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar with Parse Tree Actions\nDESCRIPTION: A complete ANTLR4 grammar definition named 'T' that recognizes the pattern 'xy'. The grammar uses @init and @after action blocks to build parse trees during parsing and output the tree structure when parsing completes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/Token2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : 'x' 'y'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Using Predicates for Keyword Recognition in ANTLR4 Lexer\nDESCRIPTION: This example shows an alternative way to match the 'enum' keyword using a predicate. It includes actions that are executed after the rule is matched.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_10\n\nLANGUAGE: ANTLR4\nCODE:\n```\nENUM: [a-z]+ {getText().equals(\"enum\")}?\n\t   {System.out.println(\"enum!\");}\n    ;\nID  : [a-z]+ {System.out.println(\"ID \"+getText());} ;\n```\n\n----------------------------------------\n\nTITLE: Building ANTLR4 Grammar in Current Directory with Output Option\nDESCRIPTION: Demonstrates building a grammar from the current directory while specifying an output directory, showing how the generated files are placed directly in the output directory.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ a4.7 -o /tmp/build B.g4\n$ tree /tmp/build\n/tmp/build\n├── B.tokens\n├── BBaseListener.java\n├── BLexer.java\n├── BLexer.tokens\n├── BListener.java\n├── BParser.java\n└── src\n    └── pkg\n        ├── A.tokens\n        ├── ABaseListener.java\n        ├── ALexer.java\n        ├── ALexer.tokens\n        ├── AListener.java\n        └── AParser.java\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Labeled Rules\nDESCRIPTION: Grammar definition that implements compound operators with labeled alternatives. Includes rules for multiplication, comma operator, send operator, and identifier handling. Features labeled alternatives and token definitions for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList2_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr ',' b+=expr #Comma\n    | b+=expr '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n   ;\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Error Listener for ANTLR in ACE Worker\nDESCRIPTION: This code defines a custom error listener for ANTLR to route errors to the ACE Editor. It extends the ANTLR error listener to collect annotations for the editor.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// class for gathering errors and posting them to ACE editor\nvar AnnotatingErrorListener = function(annotations) {\n    antlr4.error.ErrorListener.call(this);\n    this.annotations = annotations;\n    return this;\n};\n\nAnnotatingErrorListener.prototype = Object.create(antlr4.error.ErrorListener.prototype);\nAnnotatingErrorListener.prototype.constructor = AnnotatingErrorListener;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Build Commands for Grammar Files\nDESCRIPTION: Command-line sequence for building lexer and parser grammars, showing how tokenVocab option requires the .tokens file generated from the lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 L.g4 # yields L.tokens file needed by tokenVocab option in P.g4\n$ antlr4 P.g4\nerror(126): P.g4:3:4: cannot create implicit token for string literal '&' in non-combined grammar\n```\n\n----------------------------------------\n\nTITLE: ANTLR Reserved Keywords\nDESCRIPTION: Lists all the reserved keywords in ANTLR that cannot be used as identifiers. These words have special meaning in the ANTLR grammar syntax and are used for specific grammar constructs.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexicon.md#2025-04-21_snippet_5\n\nLANGUAGE: ANTLR\nCODE:\n```\nimport, fragment, lexer, parser, grammar, returns,\nlocals, throws, catch, finally, mode, options, tokens\n```\n\n----------------------------------------\n\nTITLE: Defining Tokens Section in ANTLR4 Grammar\nDESCRIPTION: This snippet shows the syntax for defining a tokens section in an ANTLR4 grammar, which is used to declare token types without associated lexical rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_6\n\nLANGUAGE: ANTLR4\nCODE:\n```\ntokens { Token1, ..., TokenN }\n```\n\n----------------------------------------\n\nTITLE: ANTLR Parser Setup and Execution\nDESCRIPTION: Complete setup for parsing binary data using ANTLR, including lexer, parser, and listener initialization.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parsing-binary-files.md#2025-04-21_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nCharStream bytesAsChar = CharStreams.fromFileName(\"/tmp/ips\", StandardCharsets.ISO_8859_1);\nIPLexer lexer = new IPLexer(bytesAsChar);\nCommonTokenStream tokens = new CommonTokenStream(lexer);\nIPParser parser = new IPParser(tokens);\nParseTree tree = parser.file();\nIPBaseListener listener = new MyIPListener();\nParseTreeWalker.DEFAULT.walk(listener, tree);\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' for parsing expressions. It includes rules for various operators, precedence, and a custom after-rule action to print the parse tree. The grammar handles multiplication, addition, ternary operations, assignment, and identifiers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_6.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition for Expression Parsing\nDESCRIPTION: Comprehensive ANTLR4 grammar that defines rules for parsing expressions with operator precedence, method calls, object instantiation, and type casting. Includes lexer rules for identifiers, integers, and whitespace handling. The grammar supports various Java-like expressions including this/super references, array access, and operator assignments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |\\<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |\\<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<=' \n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Iterating Through XPath Results in ANTLR4\nDESCRIPTION: Shows how to use XPath to find all matching nodes in a parse tree and process them in a loop. The pattern is evaluated against the tree using the parser for context.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tree-matching.md#2025-04-21_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nfor (ParseTree t : XPath.findAll(tree, xpath, parser) ) {\n    ... process t ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Unbuffered Streams in ANTLR 4\nDESCRIPTION: Example of creating and using unbuffered character and token streams for processing infinite input streams. This requires setting the token factory to copy text from the sliding buffer, and disabling parse tree building for better performance.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_8\n\nLANGUAGE: java\nCODE:\n```\nCharStream input = new UnbufferedCharStream(is);\nCSVLexer lex = new CSVLexer(input); // copy text out of sliding buffer and store in tokens\nlex.setTokenFactory(new CommonTokenFactory(true));\nTokenStream tokens = new UnbufferedTokenStream<CommonToken>(lex);\nCSVParser parser = new CSVParser(tokens);\nparser.setBuildParseTree(false);\nparser.file();\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' for parsing expressions. It includes rules for arithmetic operations, object property access, and basic tokens like identifiers and integers. The grammar also specifies a custom action to print the parse tree after parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Expressions_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\ne : e '.' ID\n  | e '.' 'this'\n  | '-' e\n  | e '*' e\n  | e ('+'|'-') e\n  | INT\n  | ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Grammar-Level Actions in ANTLR4\nDESCRIPTION: This snippet shows how to define grammar-level actions in ANTLR4, including header and members actions, and how to restrict actions to parser or lexer.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_8\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Count;\n\n@header {\npackage foo;\n}\n\n@members {\nint count = 0;\n}\n\nlist\n@after {System.out.println(count+\" ints\");}\n: INT {count++;} (',' INT {count++;} )*\n;\n\nINT : [0-9]+ ;\nWS : [ \\r\\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Finding Multiple Parse Tree Pattern Matches Using XPath in ANTLR v4\nDESCRIPTION: Shows how to find all matches of a specific tree pattern using XPath expressions in ANTLR v4. The example demonstrates matching Java variable declarations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/CHANGES.txt#2025-04-21_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\nString xpath = \"//blockStatement/*\";\nString treePattern = \"int <Identifier> = <expression>;\";\nParseTreePattern p =\n\tparser.compileParseTreePattern(treePattern,\n\t\t\t\t\t\t\t   JavaParser.RULE_localVariableDeclarationStatement);\nList<ParseTreeMatch> matches = p.findAll(tree, xpath);\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with operators, integers, and identifiers. It includes a start rule 's' with an after-rule action to print the parse tree, and defines various expression rules and lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Expressions_6.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\ne : e '.' ID\n  | e '.' 'this'\n  | '-' e\n  | e '*' e\n  | e ('+'|'-') e\n  | INT\n  | ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Listener Integration\nDESCRIPTION: Defines a grammar with rules for parsing integers, identifiers, and operators. Includes special listener annotations and post-parsing actions. Features rules for basic arithmetic operators, integers, identifiers, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Listeners/TokenGetters_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\n<ImportListener(\"T\")>\n<TokenGetterListener(\"T\")>\n\ns\n@after {\n<ContextMember(\"$ctx\", \"r\"):ToStringTree():writeln()>\n<ContextMember(\"$ctx\", \"r\"):WalkListener()>\n}\n  : r=a ;\na : INT INT\n  | ID\n  ;\nMULT: '*' ;\nADD : '+' ;\nINT : [0-9]+ ;\nID  : [a-z]+ ;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple ANTLR4 Grammar with Parser and Lexer Rules\nDESCRIPTION: A complete ANTLR4 grammar named 'T' that defines a parser rule 'a' and lexer rules for ID, INT, and whitespace. The parser rule contains an embedded action to write the matched text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/LL1OptionalBlock_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|{}INT)? {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining Action-like Tokens with Different Delimiters in ANTLR4\nDESCRIPTION: This ANTLR4 grammar snippet defines three different action-like tokens using various delimiters and nongreedy/greedy subrules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nACTION1 : '{' ( STRING | . )*? '}' ; // Allows {\"foo}\nACTION2 : '[' ( STRING | ~'\"' )*? ']' ; // Doesn't allow [\"foo]; nongreedy *?\nACTION3 : '<' ( STRING | ~[\">] )* '>' ; // Doesn't allow <\"foo>; greedy *\nSTRING : '\"' ( '\\\\\"' | . )*? '\"' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR's Transformation of Left-recursive Rules Using Semantic Predicates\nDESCRIPTION: Demonstrates how ANTLR internally transforms left-recursive rules into non-left recursive equivalents using semantic predicates that compare operator precedence to resolve ambiguities.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/left-recursion.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nexpr[int pr] : id\n               ( {4 >= $pr}? '*' expr[5]\n               | {3 >= $pr}? '+' expr[4]\n               | {2 >= $pr}? '(' expr[0] ')'\n               )*\n             ;\n```\n\n----------------------------------------\n\nTITLE: Array Declaration Grammar Implementation in ANTLR4\nDESCRIPTION: Grammar definition for parsing array declarations, pointer declarations, and function declarations. Includes rules for handling nested declarations, empty array dimensions, and pointer operators. The grammar processes simple identifiers, integers, and handles whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Compiling and Matching Parse Tree Patterns in ANTLR v4\nDESCRIPTION: Demonstrates how to create and use parse tree patterns in ANTLR v4. The code shows how to compile a pattern, match it against a parse tree, and extract matched elements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/CHANGES.txt#2025-04-21_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nParseTree t = parser.expr();\nParseTreePattern p = parser.compileParseTreePattern(\"<ID>+0\", MyParser.RULE_expr);\nParseTreeMatch m = p.match(t);\nString id = m.get(\"ID\");\n```\n\n----------------------------------------\n\nTITLE: Defining Keyword and Identifier Rules in ANTLR4 Lexer\nDESCRIPTION: This snippet demonstrates how to define lexer rules for the 'enum' keyword and identifiers in ANTLR4. The order of rules is important for resolving ambiguities.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_9\n\nLANGUAGE: ANTLR4\nCODE:\n```\nENUM : 'enum' ;\nID : [a-z]+ ;\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR Maven Components\nDESCRIPTION: Commands to install ANTLR components using Maven while skipping tests, which prepares the environment for testing new language targets.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/creating-a-language-target.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ANTLR-ROOT-DIR\nmvn install -DskipTests=true\ncd runtime-tests \nmvn install -DskipTests=true # yes do it again\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Go Runtime Import Example\nDESCRIPTION: Example of importing the ANTLR4 Go runtime in Go code.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_5\n\nLANGUAGE: golang\nCODE:\n```\nimport \"github.com/antlr4-go/antlr/v4\"\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for T Language\nDESCRIPTION: This ANTLR4 grammar defines the structure of the T language. It includes rules for statements, if-else constructs, and basic lexer rules. The grammar also features a custom action to print the matched text for if-statements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/IfIfElseGreedyBinding1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : statement+ ;\nstatement : 'x' | ifStatement;\nifStatement : 'if' 'y' statement ('else' statement)? {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Semantic Predicate Grammar Implementation in ANTLR4\nDESCRIPTION: Grammar definition that includes parser member declarations, semantic predicates, and lexer rules. The grammar demonstrates predicate evaluation in parsing rules and includes basic token definitions for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/PredsInGlobalFOLLOW.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {\n<Declare_pred()>\n}\ns : e {<True():Invoke_pred()>}? {<writeln(\"\\\"parse\\\"\")>} '!' ;\nt : e {<False():Invoke_pred()>}? ID ;\ne : ID | ; // non-LL(1) so we use ATN\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Case-Insensitive Lexer Grammar Example\nDESCRIPTION: Example of a lexer grammar using the caseInsensitive option to enable case-insensitive token matching across multiple languages and character sets.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_5\n\nLANGUAGE: g4\nCODE:\n```\nlexer grammar L;\noptions { caseInsensitive = true; }\nENGLISH_TOKEN:   [a-z]+;\nGERMAN_TOKEN:    [äéöüß]+;\nFRENCH_TOKEN:    [àâæ-ëîïôœùûüÿ]+;\nCROATIAN_TOKEN:  [ćčđšž]+;\nITALIAN_TOKEN:   [àèéìòù]+;\nSPANISH_TOKEN:   [áéíñóúü¡¿]+;\nGREEK_TOKEN:     [α-ω]+;\nRUSSIAN_TOKEN:   [а-я]+;\nWS:              [ ]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Always-False Predicate Causing Rule Failure in ANTLR\nDESCRIPTION: Shows how a predicate that always evaluates to false causes a rule to fail with a FailedPredicateException, even when there is only one alternative to match.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR\nCODE:\n```\nprog: {false}? 'return' INT ; // throws FailedPredicateException\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Declarator Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing declarators with various syntactic elements. It includes parser rules for declarators, expressions, and lexer rules for identifiers, integers, and whitespace. The grammar handles nested structures, array declarations, function calls, and pointer declarations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_7.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Declaring Lexer-Only ANTLR4 Grammar\nDESCRIPTION: This snippet demonstrates how to declare a lexer-only grammar in ANTLR4, which can contain mode specifications and custom channels.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar Name;\n...\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Program Actions\nDESCRIPTION: This ANTLR4 grammar defines a program consisting of multiple actions (break, continue, return) and includes a custom action to print the parsed text. The grammar specifies the structure of valid input and how it should be processed.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Keyword_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nprogram : action*{<writeln(\"$text\")>} EOF ;\naction: 'break;' | 'continue;' | 'return;' ;\n```\n\n----------------------------------------\n\nTITLE: Simple Integer/Identifier Parser Grammar in ANTLR4\nDESCRIPTION: Defines a grammar with two alternatives - one for identifiers and one for integers. When matched, each alternative prints which rule was selected. Includes lexer rules for IDs, integers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AorB.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ID {\n<writeln(\"\\\"alt 1\\\"\")>\n} | INT {\n<writeln(\"\\\"alt 2\\\"\")>\n};\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Using Mode Commands in ANTLR4 Lexer Rules\nDESCRIPTION: This snippet demonstrates the use of mode commands in ANTLR4 lexer rules. It shows how to switch between different lexer modes for parsing XML-like structures.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_15\n\nLANGUAGE: ANTLR4\nCODE:\n```\n// Default \"mode\": Everything OUTSIDE of a tag\nCOMMENT : '<!--' .*? '-->' ;\nCDATA   : '<![CDATA[' .*? ']]>' ;\nOPEN : '<' -> pushMode(INSIDE) ;\n ...\nXMLDeclOpen : '<?xml' S -> pushMode(INSIDE) ;\nSPECIAL_OPEN: '<?' Name -> more, pushMode(PROC_INSTR) ;\n// ----------------- Everything INSIDE of a tag ---------------------\nmode INSIDE;\nCLOSE        : '>' -> popMode ;\nSPECIAL_CLOSE: '?>' -> popMode ; // close <?xml...?>\nSLASH_CLOSE  : '/>' -> popMode ;\n```\n\n----------------------------------------\n\nTITLE: Compiling and Testing Nongreedy ANTLR4 Grammar\nDESCRIPTION: This bash script demonstrates how to compile and test the Nongreedy grammar using ANTLR4 tools and grun.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 Nongreedy.g4\n$ javac Nongreedy*.java\n$ grun Nongreedy s -tokens\n=> \t\"quote:\\\"\"\n=> \tEOF\n<= \t[@0,0:9='\"quote:\\\"\"',<1>,1:0]\n \t[@1,11:10='<EOF>',<-1>,2:0]\n```\n\n----------------------------------------\n\nTITLE: Setting Up ANTLR4 Interpreters in C++\nDESCRIPTION: This C++ function demonstrates how to set up and use ANTLR4 interpreters for non-Java targets. It loads interpreter data from files, creates lexer and parser interpreters, and parses input. This approach is used when the ANTLR4 tool jar is not available.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/interpreters.md#2025-04-21_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nvoid parse(std::string const& sourceFileName,\n  std::string const& lexerName, std::string const& parserName,\n  std::string const& lexerDataFileName, std::string const& parserDataFileName,\n  std::string const& startRule) {\n  \n    InterpreterData lexerData = InterpreterDataReader::parseFile(lexerDataFileName);\n    InterpreterData parserData = InterpreterDataReader::parseFile(parserDataFileName);\n\n    ANTLRFileStream input(sourceFileName);\n    LexerInterpreter lexEngine(lexerName, lexerData.vocabulary, lexerData.ruleNames,\n      lexerData.channels, lexerData.modes, lexerData.atn, &input);\n    CommonTokenStream tokens(&lexEngine);\n\n    /* Remove comment to print the tokens.\n    tokens.fill();\n    std::cout << \"INPUT:\" << std::endl;\n    for (auto token : tokens.getTokens()) {\n      std::cout << token->toString() << std::endl;\n    }\n    */\n\n    ParserInterpreter parser(parserName, parserData.vocabulary, parserData.ruleNames,\n      parserData.atn, &tokens);\n    tree::ParseTree *tree = parser.parse(parser.getRuleIndex(startRule));\n\n    std::cout << \"parse tree: \" << tree->toStringTree(&parser) << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with C# Listener Integration\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with rules for parsing expressions. It includes C# code for importing and using listeners, as well as custom actions for tree visualization.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Listeners/LRWithLabels.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\n<ImportListener(\"T\")>\n<LRWithLabelsListener(\"T\")>\n\ns\n@after {\n<ContextMember(\"$ctx\", \"r\"):ToStringTree():writeln()>\n<ContextMember(\"$ctx\", \"r\"):WalkListener()>\n}\n  : r=e ;\ne : e '(' eList ')' # Call\n  | INT    # Int\n  ;\neList : e (',' e)* ;\nMULT: '*' ;\nADD : '+' ;\nINT : [0-9]+ ;\nID  : [a-z]+ ;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Using Actions in ANTLR4 Lexer Rules\nDESCRIPTION: Example showing how to embed actions in lexer rules that will be executed when the rule matches. Actions placed after a group apply to all alternatives.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_7\n\nLANGUAGE: ANTLR\nCODE:\n```\nEND : ('endif'|'end') {System.out.println(\"found an end\");} ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple expressions with various operators and precedence rules. It includes multiplication, addition, ternary conditional, and assignment operators, as well as identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR NameChar and NameStartChar Fragment Rules\nDESCRIPTION: Defines the valid characters for ANTLR identifiers. NameChar specifies characters allowed anywhere in an identifier, while NameStartChar specifies characters allowed as the first character. These rules support Unicode characters in identifiers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexicon.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR\nCODE:\n```\nfragment\nNameChar\n   : NameStartChar\n   | '0'..'9'\n   | '_'\n   | '\\u00B7'\n   | '\\u0300'..'\\u036F'\n   | '\\u203F'..'\\u2040'\n   ;\nfragment\nNameStartChar\n   : 'A'..'Z' | 'a'..'z'\n   | '\\u00C0'..'\\u00D6'\n   | '\\u00D8'..'\\u00F6'\n   | '\\u00F8'..'\\u02FF'\n   | '\\u0370'..'\\u037D'\n   | '\\u037F'..'\\u1FFF'\n   | '\\u200C'..'\\u200D'\n   | '\\u2070'..'\\u218F'\n   | '\\u2C00'..'\\u2FEF'\n   | '\\u3001'..'\\uD7FF'\n   | '\\uF900'..'\\uFDCF'\n   | '\\uFDF0'..'\\uFFFD'\n   ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR 4.7 CharStream Creation with Default UTF-8 Encoding\nDESCRIPTION: Example of creating a character stream in ANTLR 4.7+ using the new CharStreams factory method with default UTF-8 encoding. This approach supports full Unicode range up to U+10FFFF.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nCharStream input = CharStreams.fromFileName(\"inputfile\");\nJavaLexer lexer = new JavaLexer(input);\nCommonTokenStream tokens = new CommonTokenStream(lexer);\n```\n\n----------------------------------------\n\nTITLE: Getting Token Stream Text using Context\nDESCRIPTION: Method to retrieve text from a token stream for a specific parse tree context interval. This is the preferred method for getting text from a parse tree subtree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/parse-trees.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\n/**\n * Return the text of all tokens in the source interval of the specified\n * context. This method behaves like the following code, including potential\n * exceptions from the call to {@link #getText(Interval)}, but may be\n * optimized by the specific implementation.\n *\n * <p>If {@code ctx.getSourceInterval()} does not return a valid interval of\n * tokens provided by this stream, the behavior is unspecified.</p>\n *\n * <pre>\n * TokenStream stream = ...;\n * String text = stream.getText(ctx.getSourceInterval());\n * </pre>\n *\n * @param ctx The context providing the source interval of tokens to get\n * text for.\n * @return The text of all tokens within the source interval of {@code ctx}.\n */\npublic String getText(RuleContext ctx);\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Rules in ANTLR4\nDESCRIPTION: Lexer rules defining the token patterns for identifiers, numbers, dates, strings, whitespace, and comments. Includes fragment rules for basic character patterns used in token definitions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/WhitespaceInfluence_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nfragment DIGIT    : '0' .. '9';\nfragment UPPER    : 'A' .. 'Z';\nfragment LOWER    : 'a' .. 'z';\nfragment LETTER   : LOWER | UPPER;\nfragment WORD     : LETTER | '_' | '$' | '#' | '.';\nfragment ALPHANUM : WORD | DIGIT;\n\nID     : LETTER ALPHANUM*;\nNUMBER : DIGIT+ ('.' DIGIT+)? (('e'|'E')('+'|'-')? DIGIT+)?;\nDATE   : '\\'' DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT (' ' DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT ('.' DIGIT+)?)? '\\'';\nSQ_STRING       : '\\'' ('\\'\\'' | ~'\\'')* '\\'';\nDQ_STRING       : '\"' ('\\\\\\\"' | ~'\"')* '\"';\nWS     : [ \\t\\n\\r]+ -> skip ;\nCOMMENTS        : ('/*' .*? '*' '/' | '//' ~'\\n'* '\\n' ) -> skip;\n```\n\n----------------------------------------\n\nTITLE: Extracting Tagged Values from Parse Tree Matches in ANTLR4\nDESCRIPTION: Shows how to extract a specific token that matched a tag in the pattern. The example retrieves the ID token from a successful pattern match.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tree-matching.md#2025-04-21_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nString id = m.get(\"ID\");\n```\n\n----------------------------------------\n\nTITLE: Setting TokenLabelType Option for Custom Token Types\nDESCRIPTION: Example showing how to use the TokenLabelType option to specify a custom token type. This is necessary when using a custom TokenFactory to create tokens of a specific type.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ cat T2.g4\ngrammar T2;\noptions {TokenLabelType=MyToken;}\na : x=ID ;\n$ antlr4 T2.g4\n$ grep MyToken T2Parser.java\n    public MyToken x;\n```\n\n----------------------------------------\n\nTITLE: Left-Recursive Expression Grammar in ANTLR4\nDESCRIPTION: Example of how ANTLR4 handles left-recursive grammar rules for arithmetic expressions, demonstrating the natural expression syntax that v4 supports.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/general.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\ne : e '*' e\n  | e '+' e\n  | INT\n  ;\n```\n\n----------------------------------------\n\nTITLE: Using Predicates for Indentation in ANTLR4 Lexer\nDESCRIPTION: This example demonstrates the use of a predicate to check for indentation at the beginning of a line in ANTLR4 lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_13\n\nLANGUAGE: ANTLR4\nCODE:\n```\nINDENT : [ \\t]+ {System.out.println(\"INDENT\")>} {this.getCharPositionInLine()==0}? ;\n```\n\n----------------------------------------\n\nTITLE: Testing Nested Scopes in ANTLR4 Grammar\nDESCRIPTION: This bash command demonstrates testing the ANTLR4 grammar with nested scopes, showing how variable definitions in inner scopes hide those in outer scopes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ grun DynScope prog nested-input\nsymbols=[i, x]\nundefined variable: x\nsymbols=[i, j]\n```\n\n----------------------------------------\n\nTITLE: Using Tokens Section with Lexer Actions in ANTLR4\nDESCRIPTION: This snippet demonstrates how to use the tokens section in conjunction with lexer actions to define keyword token types and handle them in the lexer.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/grammars.md#2025-04-21_snippet_7\n\nLANGUAGE: ANTLR4\nCODE:\n```\n// explicitly define keyword token types to avoid implicit definition warnings\ntokens { BEGIN, END, IF, THEN, WHILE }\n\n@lexer::members { // keywords map used in lexer to assign token types\nMap<String,Integer> keywords = new HashMap<String,Integer>() {{\n\tput(\"begin\", KeywordsParser.BEGIN);\n\tput(\"end\", KeywordsParser.END);\n\t...\n}};\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up ANTLR Parser with Custom Error Listener in JavaScript\nDESCRIPTION: This function sets up an ANTLR parser for a custom language, integrating the custom error listener. It creates a character stream, lexer, token stream, and parser, then adds the custom error listener before parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nvar validate = function(input) {\n    var stream = CharStreams.fromString(input);\n    var lexer = new mylanguage.MyLexer(stream);\n    var tokens = new antlr4.CommonTokenStream(lexer);\n    var parser = new mylanguage.MyParser(tokens);\n    var annotations = [];\n    var listener = new AnnotatingErrorListener(annotations)\n    parser.removeErrorListeners();\n    parser.addErrorListener(listener);\n    parser.parseMyRule();\n    return annotations;\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Expression Parser Grammar in ANTLR4\nDESCRIPTION: Defines a grammar for parsing simple expressions with operators *, +, ?, :, and = with proper precedence and associativity. Includes lexer rules for identifiers and whitespace handling, with tree visualization output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |\\<assoc=right> e '?' e ':' e\n  |\\<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: String Token Lexer Grammar Definition in ANTLR\nDESCRIPTION: Defines a lexer grammar that recognizes strings delimited by exclamation marks. The grammar handles escaped sequences using '!!' and matches any characters between the delimiters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyTermination1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar L;\nSTRING : '!' ('!!' | .)*? '!';\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Custom Listener Interface in C#\nDESCRIPTION: Shows the generated listener interface with entry and exit methods for grammar rules 'key' and 'value'. This interface extends IParseTreeListener and defines the structure for custom listener implementations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/csharp-target.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\ninterface IMyGrammarParserListener : IParseTreeListener {\n      void EnterKey (MyGrammarParser.KeyContext context);\n      void ExitKey (MyGrammarParser.KeyContext context);\n      void EnterValue (MyGrammarParser.ValueContext context);\n      void ExitValue (MyGrammarParser.ValueContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 4.7 Output Directory Behavior\nDESCRIPTION: Shows how ANTLR4 4.7 handles output directory structure differently from 4.7.1, maintaining package directory hierarchy.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ a4.7 -package pkg -o /tmp/build src/pkg/A.g4\nbeast:/tmp/parrt $ tree /tmp/build\n/tmp/build\n└── src\n    └── pkg\n        ├── A.tokens\n        ├── ABaseListener.java\n        ├── ALexer.java\n        ├── ALexer.tokens\n        ├── AListener.java\n        └── AParser.java\n```\n\n----------------------------------------\n\nTITLE: Defining Fragment Helper Rules in ANTLR4\nDESCRIPTION: Fragment rules help in the recognition of tokens but do not produce tokens visible to the parser. They are used as building blocks for actual token rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nfragment\nHelperTokenRule : alternative1 | ... | alternativeN ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing and evaluating simple arithmetic expressions. It includes operations like addition, multiplication, parentheses grouping, increment, and decrement. The grammar also defines lexer rules for integers, identifiers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsAndLabels_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : q=e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : a=e op='*' b=e {$v = $a.v * $b.v;}  # mult\n  | a=e '+' b=e {$v = $a.v + $b.v;}     # add\n  | INT{$v = $INT.int;}        # anInt\n  | '(' x=e ')' {$v = $x.v;}   # parens\n  | x=e '++'    {$v = $x.v+1;} # inc\n  | e '--'   # dec\n  | ID {$v = 3;}      # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Building and Testing ANTLR4 Grammar with Dynamic Scoping\nDESCRIPTION: This bash script demonstrates how to build and test the ANTLR4 grammar with dynamic scoping. It includes commands for generating Java code, compiling, and running a test input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 DynScope.g4\n$ javac DynScope*.java\n$ grun DynScope prog\n=> \t{\n=> \tint i;\n=> \ti = 0;\n=> \tj = 3;\n=> \t}\n=> \tEOF\n<= \tundefined variable: j\n \tsymbols=[i]\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Nested Actions in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for recognizing nested action blocks enclosed in curly braces. It includes an ACTION rule that allows for nested curly braces and a WS rule to skip whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/EnforcedGreedyNestedBraces_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nACTION : '{' (ACTION | ~[{}])* '}';\nWS : [ \\r\\n\\t]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Declarator Grammar Rules in ANTLR4\nDESCRIPTION: Defines grammar rules for parsing variable declarations, array access, function calls, and pointer declarations. Includes lexer rules for identifiers, integers, and whitespace. Contains special handling for tree output visualization.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Configuring Maven POM for ANTLR4 Java Project\nDESCRIPTION: XML configuration for the pom.xml file, including ANTLR4 dependencies, plugins for compilation, and packaging the application as a standalone JAR.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_6\n\nLANGUAGE: xml\nCODE:\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>org.abcd.examples</groupId>\n  <artifactId>array-init</artifactId>\n  <version>1.0</version>\n  <packaging>jar</packaging>\n  <name>array-init</name>\n  <url>http://maven.apache.org</url>\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n  </properties>\n  <dependencies>\n    <dependency>\n      <groupId>org.antlr</groupId>\n      <artifactId>antlr4-runtime</artifactId>\n      <version>4.9.3</version>\n    </dependency>\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.13.1</version>\n    </dependency>\n  </dependencies>\n  <build>\n    <plugins>\n      <!-- This plugin sets up maven to use Java 7 -->\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.1</version>\n        <configuration>\n          <source>1.8</source>\n          <target>1.8</target>\n        </configuration>\n      </plugin>\n      <!-- Plugin to compile the g4 files ahead of the java files\n           See https://github.com/antlr/antlr4/blob/master/antlr4-maven-plugin/src/site/apt/examples/simple.apt.vm\n           Except that the grammar does not need to contain the package declaration as stated in the documentation (I do not know why)\n           To use this plugin, type:\n             mvn antlr4:antlr4\n           In any case, Maven will invoke this plugin before the Java source is compiled\n        -->\n      <plugin>\n        <groupId>org.antlr</groupId>\n        <artifactId>antlr4-maven-plugin</artifactId>\n        <version>4.9.3</version>\n        <executions>\n          <execution>\n            <goals>\n              <goal>antlr4</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n      <!-- plugin to create a self-contained portable package\n           This allows us to execute our application like this:\n           java -cp target/array-init-1.0-jar-with-dependencies.jar org.abcd.examples.ArrayInit.ArrayInit\n         -->\n      <plugin>\n        <artifactId>maven-assembly-plugin</artifactId>\n        <configuration>\n          <descriptorRefs>\n            <descriptorRef>jar-with-dependencies</descriptorRef>\n          </descriptorRefs>\n        </configuration>\n        <executions>\n          <execution>\n            <id>simple-command</id>\n            <phase>package</phase>\n            <goals>\n              <goal>attached</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing complex expressions. It includes support for arithmetic, logical, and object-oriented operations, as well as various unary and binary operators. The grammar also defines lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Handling Ambiguous String Literals Across Modes in ANTLR4\nDESCRIPTION: Example showing potential issues with defining the same string literal in multiple lexer rules or across different modes, which makes the literal unavailable to the parser.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_10\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar L;\nAND : '&' ;\nmode STR;\nMASK : '&' ;\n```\n\n----------------------------------------\n\nTITLE: Declarator Parser Grammar in ANTLR4\nDESCRIPTION: Defines a grammar for parsing declarator expressions including array subscripts, function calls, pointer declarations, and parenthesized expressions. Includes lexer rules for identifiers, integers, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_6.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Context-Dependent Predicates in Recursive Rules in ANTLR\nDESCRIPTION: Demonstrates a complex case where a predicate depends on a local variable but can't be evaluated properly during prediction because the prediction process re-enters the rule with a different context.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_8\n\nLANGUAGE: ANTLR\nCODE:\n```\nprog: stat+ ; // stat can follow stat\nstat\nlocals [int i=0]\n \t: {$i==0}? 'if' expr 'then' stat {$i=5;} ('else' stat)?\n \t| 'break' ';'\n \t;\n```\n\n----------------------------------------\n\nTITLE: Implementing Conditional Token Type in ANTLR4 Lexer Rule\nDESCRIPTION: This snippet demonstrates how to conditionally set the token type in an ANTLR4 lexer rule. It changes the 'enum' token to an Identifier if the 'enumIsKeyword' flag is false.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_13\n\nLANGUAGE: ANTLR4\nCODE:\n```\nENUM : 'enum' {if (!enumIsKeyword) setType(Identifier);} ;\n```\n\n----------------------------------------\n\nTITLE: Using Extended Unicode Escapes for Characters Beyond U+FFFF in ANTLR\nDESCRIPTION: Example of defining lexer rules for Unicode characters beyond the BMP (U+FFFF) using the extended \\u{...} syntax, specifically for emoticon characters from the Emoticons Unicode block.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nEMOTICONS : ('\\u{1F600}' | '\\u{1F602}' | '\\u{1F615}') ; // or [\\u{1F600}\\u{1F602}\\u{1F615}]\n```\n\n----------------------------------------\n\nTITLE: Direct Left-Recursive Expression Grammar Example\nDESCRIPTION: Another example showing direct left recursion support in ANTLR4 grammar rules for arithmetic expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/general.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nexpr : expr '*' expr\n     | expr '+' expr\n     | INT\n     ;\n```\n\n----------------------------------------\n\nTITLE: Right-Associative Expression Grammar in ANTLR4\nDESCRIPTION: Grammar definition for parsing expressions with right-associative operators including multiplication, addition, ternary conditional, and assignment. The grammar supports basic identifier tokens and includes a start rule that outputs parse trees.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar for Comments\nDESCRIPTION: Defines a lexer grammar that recognizes C-style comments (/* */) and whitespace. The CMT rule handles nested comments using non-greedy matching (+?).\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardPlus_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : '/*' (CMT | .)+? '*' '/' ;\nWS : (' '|'\\n')+;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Channels in ANTLR4 Lexer\nDESCRIPTION: This snippet demonstrates how to define custom channel names in ANTLR4 lexer rules. It shows the syntax for declaring channel names as enumerations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_19\n\nLANGUAGE: ANTLR4\nCODE:\n```\nchannels { WSCHANNEL, MYHIDDEN }\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 4.7 Token Vocabulary Error Example\nDESCRIPTION: Demonstrates an error case in ANTLR4 4.7 where token file lookup fails in a common usage scenario.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ cd /tmp/parrt\n$ tree\n.\n└── src\n    └── pkg\n        ├── L.g4\n        └── P.g4\n$ a4.7 -o /tmp/build src/pkg/*.g4\nerror(160): P.g4:2:21: cannot find tokens file /tmp/build/L.tokens\nwarning(125): P.g4:3:4: implicit definition of token A in parser\n```\n\n----------------------------------------\n\nTITLE: Accessing Token Text in Grammar Actions with Unbuffered Streams\nDESCRIPTION: Example of a grammar rule with an embedded action that accesses token text immediately after token creation, which is necessary when using unbuffered streams where tokens may be garbage collected.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_9\n\nLANGUAGE: antlr\nCODE:\n```\ndata : a=INT {int x = Integer.parseInt($a.text);} ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing complex expressions, including arithmetic, logical, and object-oriented operations. It covers a wide range of expression types, from simple identifiers to complex method calls and array access.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Fortran Column-Sensitive Comment Parsing\nDESCRIPTION: Example of Fortran90 code showing how comments must begin with 'C' in column 1, and how this creates a context-sensitive parsing requirement that needs semantic predicates.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/target-agnostic-grammars.md#2025-04-21_snippet_0\n\nLANGUAGE: fortran\nCODE:\n```\nc Hello World.\n   c This is a syntax error because 'c' does not start in column 1\nprogram hello\n\tprint *, 'Hello World!'\nend\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expression Parsing and Evaluation\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing and evaluating simple arithmetic expressions. It includes multiplication, addition, integers, and parenthesized expressions. The grammar uses semantic predicates to calculate and store values in a custom attribute 'v'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActions_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v, <StringList()> ignored]\n  : a=e '*' b=e {$v = $a.v * $b.v;}\n  | a=e '+' b=e {$v = $a.v + $b.v;}\n  | INT {$v = $INT.int;}\n  | '(' x=e ')' {$v = $x.v;}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Lexer Output Token Stream\nDESCRIPTION: Generated token stream showing how the lexer processes the input text into tokens, including position information and token types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyTermination1.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:3='!hi!',<1>,1:0]\n[@1,4:8='!mom!',<1>,1:4]\n[@2,9:8='<EOF>',<-1>,1:9]\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar with Listener Annotations\nDESCRIPTION: Defines a grammar 'T' with parser rules for handling integer pairs and identifiers, includes listener integration directives and context member handling. Features lexer rules for multiplication, addition, integers, identifiers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Listeners/Basic.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\n<ImportListener(\"T\")>\n<BasicListener(\"T\")>\n\ns\n@after {\n<ContextMember(\"$ctx\", \"r\"):ToStringTree():writeln()>\n<ContextMember(\"$ctx\", \"r\"):WalkListener()>\n}\n  : r=a ;\na : INT INT\n  | ID\n  ;\nMULT: '*' ;\nADD : '+' ;\nINT : [0-9]+ ;\nID  : [a-z]+ ;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Building and Running ANTLR4 Java Application with Maven\nDESCRIPTION: Commands to build the ANTLR4 Java application using Maven, create a standalone JAR, and run the application. It also shows how to provide input to the application.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmvn package\njava -cp target/array-init-1.0-jar-with-dependencies.jar org.abcd.examples.ArrayInit.ArrayInit\n{1,2,3}\n^D\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Optional Rule with Empty Alternative\nDESCRIPTION: Shows how to create an optional rule using an empty alternative.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_2\n\nLANGUAGE: antlr4\nCODE:\n```\nsuperClass\n\t: 'extends' ID\n\t| // empty means other alternative(s) are optional\n\t;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Ambiguous If-Else Statements\nDESCRIPTION: This grammar defines rules for parsing if-else statements and other basic constructs. It includes initialization for exact ambiguity detection and DFA dumping after parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n@after {<DumpDFA()>}\n   : '{' stat* '}' ;\nstat: 'if' ID 'then' stat ('else' ID)?\n       | 'return'\n       ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Implementing a CountListener for Parse Event Tracking in ANTLR 4\nDESCRIPTION: Example of a custom listener that counts integer literals during parsing and tracks when rule execution completes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/listeners.md#2025-04-21_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nclass CountListener extends CalcNoLRBaseListener {\n\tpublic int nums = 0;\n\tpublic boolean execExitS = false;\n\n\t@Override\n\tpublic void exitS(CalcNoLRParser.SContext ctx) {\n\t\texecExitS = true;\n\t}\n\n\t@Override\n\tpublic void exitAtom(CalcNoLRParser.AtomContext ctx) {\n\t\tnums++;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Conditional Statements\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing 'if-else' statements and identifiers. It includes a special semantic predicate to handle the dangling else problem. The grammar supports nested if statements and optional else clauses.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/PredicatedIfIfElse.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : stmt EOF ;\nstmt : ifStmt | ID;\nifStmt : 'if' ID stmt ('else' stmt | { <LANotEquals(\"1\", {T<ParserToken(\"Parser\", \"ELSE\")>})> }?);\nELSE : 'else';\nID : [a-zA-Z]+;\nWS : [ \\n\\t]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Generating PHP Parser with ANTLR4 Tool\nDESCRIPTION: Command to generate a PHP parser from a grammar file using the ANTLR4 tool.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/php-target.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nantlr4 -Dlanguage=PHP MyGrammar.g4\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR Grammar with 66 Literal Tokens\nDESCRIPTION: An ANTLR grammar named 'L' that defines a rule 'a' accepting 66 different literal tokens (numbers 1-66). The rule captures one or more occurrences of these literals and outputs the matched text. This test verifies ANTLR can correctly handle more than 65 tokens in a grammar rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/TokenOffset.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar L;\na : ('1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|'10'|'11'|'12'|'13'|'14'|'15'|'16'\n|'17'|'18'|'19'|'20'|'21'|'22'|'23'|'24'|'25'|'26'|'27'|'28'|'29'|'30'|'31'|'32'\n|'33'|'34'|'35'|'36'|'37'|'38'|'39'|'40'|'41'|'42'|'43'|'44'|'45'|'46'|'47'|'48'\n|'49'|'50'|'51'|'52'|'53'|'54'|'55'|'56'|'57'|'58'|'59'|'60'|'61'|'62'|'63'|'64'\n|'65'|'66')+ {\n<writeln(\"$text\")>\n};\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Two-Stage Parsing Implementation in Java\nDESCRIPTION: Implementation of two-stage parsing for improved expression parser performance, demonstrating SLL and LL prediction modes with error handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/general.md#2025-04-21_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nCharStream input = CharStreams.fromPath(Paths.get(args[0]));\nExprLexer lexer = new ExprLexer(input);\nCommonTokenStream tokens = new CommonTokenStream(lexer);\nExprParser parser = new ExprParser(tokens);\nparser.getInterpreter().setPredictionMode(PredictionMode.SLL);\ntry {\n    parser.stat();  // STAGE 1\n}\ncatch (Exception ex) {\n    tokens.reset(); // rewind input stream\n    parser.reset();\n    parser.getInterpreter().setPredictionMode(PredictionMode.LL);\n    parser.stat();  // STAGE 2\n    // if we parse ok, it's LL not SLL\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Expression Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar 'T' with rules for parsing expressions including integers, identifiers, dot notation, operators, and whitespace. Includes a tree visualization output feature using @after annotation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Expressions_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\ne : e '.' ID\n  | e '.' 'this'\n  | '-' e\n  | e '*' e\n  | e ('+'|'-') e\n  | INT\n  | ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Generating ANTLR4 Parser with Visitor in CMake\nDESCRIPTION: Example of using the antlr4_generate function to create a lexer with visitor classes placed in a specific C++ namespace. This demonstrates the basic usage pattern for the generator.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/Antlr4Package.md#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\n # generate parser with visitor classes.\n # put the classes in C++ namespace 'antlrcpptest::'\n antlr4_generate(\n   antlrcpptest_parser\n   ${CMAKE_CURRENT_SOURCE_DIR}/TLexer.g4\n   LEXER\n   FALSE\n   TRUE\n   \"antlrcpptest\"\n   )\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing with Duplicate Actions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing mathematical expressions. It includes a start rule 's', an expression rule 'e' with operator precedence, and rules for integers and whitespace. The expression rule demonstrates the use of duplicate empty actions ({}{}) which was the subject of a regression test.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleActions_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e ;\ne : a=e op=('*'|'/') b=e  {}{}\n  | INT {}{}\n  | '(' x=e ')' {}{}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Invalid Lexical Scoping in Java\nDESCRIPTION: This Java code snippet illustrates an invalid reference to a local variable from a nested method call, demonstrating the concept of lexical scoping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/actions.md#2025-04-21_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nvoid f() {\n\tint x = 0;\n\tg();\n}\nvoid g() {\n\th();\n}\nvoid h() {\n\tint y = x; // INVALID reference to f's local variable x\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ANTLR4 Output Directory Behavior in Bash (v4.7)\nDESCRIPTION: Shows how the -o option interacts with relative paths in grammar files in ANTLR 4.7, maintaining the directory structure when generating output files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ cd /tmp/parrt\n$ tree\n.\n├── B.g4\n└── src\n    └── pkg\n        └── A.g4\n$ a4.7 -o /tmp/build src/pkg/A.g4\n$ tree /tmp/build\n/tmp/build/\n└── src\n    └── pkg\n        ├── A.tokens\n        ├── ABaseListener.java\n        ├── ALexer.java\n        ├── ALexer.tokens\n        ├── AListener.java\n        └── AParser.java\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Right-Associative Expressions\nDESCRIPTION: This grammar defines rules for parsing expressions with right associativity. It includes operators for multiplication, addition, ternary, and assignment. The grammar also defines lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Non-Visible Predicates After Token References in ANTLR\nDESCRIPTION: Illustrates predicates that depend on the current token's text, which cannot be evaluated during prediction because they occur after token references that would advance the input stream.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_6\n\nLANGUAGE: ANTLR\nCODE:\n```\nstat: '{' decl '}'\n \t| '{' stat '}'\n \t;\ndecl: {istype(getCurrentToken().getText())}? ID ID ';' ;\nexpr: {isvar(getCurrentToken().getText())}? ID ;\n```\n\n----------------------------------------\n\nTITLE: Lexer Token Output\nDESCRIPTION: Token stream output showing how the lexer recognizes and categorizes each pattern in the input string. Each token includes position, value, type, and line information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/Slashes.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:0='\\',<1>,1:0]\n[@1,2:2='/',<2>,1:2]\n[@2,4:5='\\/',<3>,1:4]\n[@3,7:8='/\\',<4>,1:7]\n[@4,9:8='<EOF>',<-1>,1:9]\n```\n\n----------------------------------------\n\nTITLE: Generated Listener Methods for Reused Labels\nDESCRIPTION: Shows the Java listener methods generated for rules with reused labels.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_6\n\nLANGUAGE: java\nCODE:\n```\nvoid enterBinaryOp(AParser.BinaryOpContext ctx);\nvoid exitBinaryOp(AParser.BinaryOpContext ctx);\nvoid enterInt(AParser.IntContext ctx);\nvoid exitInt(AParser.IntContext ctx);\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for T Language\nDESCRIPTION: This snippet defines the grammar rules for the T language, including lexer and parser rules. It specifies the structure for integers, identifiers, and whitespace, as well as more complex rules for combining these elements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/SLLSeesEOFInLLGrammar.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<DumpDFA()>}\n  : a;\na : e ID ;\nb : e INT ID ;\ne : INT | ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar Rules in ANTLR4\nDESCRIPTION: This snippet defines lexer grammar rules for parsing hexadecimal, decimal, and floating-point literals, as well as identifiers and whitespace. It includes a fragment rule for hexadecimal digits.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/HexVsID.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nHexLiteral : '0' ('x'|'X') HexDigit+ ;\nDecimalLiteral : ('0' | '1'..'9' '0'..'9'*) ;\nFloatingPointLiteral : ('0x' | '0X') HexDigit* ('.' HexDigit*)? ;\nDOT : '.' ;\nID : 'a'..'z'+ ;\nfragment HexDigit : ('0'..'9'|'a'..'f'|'A'..'F') ;\nWS : (' '|'\\n')+;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar with Indentation Detection\nDESCRIPTION: An ANTLR4 lexer grammar named 'L' that recognizes identifiers, indentation at the start of a line, newlines, and whitespace. The INDENT token uses a semantic predicate to check if it starts at column 0 and includes an action to write 'INDENT' when matched.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/Indent.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nID : [a-z]+  ;\nINDENT : [ \\t]+ { <TokenStartColumnEquals(\"0\")> }?\n{ <writeln(\"\\\"INDENT\\\"\")> }  ;\nNL : '\\n';\nWS : [ \\t]+ ;\n```\n\n----------------------------------------\n\nTITLE: Right-Associative Expression Grammar in ANTLR4\nDESCRIPTION: Defines a grammar that implements right-associative operators including multiplication, addition, conditional (ternary), and assignment. The grammar includes rules for parsing expressions with proper operator precedence and associativity.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_7.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF;\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Getting Parse Tree Text using getText() Method\nDESCRIPTION: Method to retrieve combined text of all leaf nodes in a parse tree, excluding off-channel tokens like whitespace and comments on hidden channels.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/parse-trees.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n/** Return the combined text of all leaf nodes. Does not get any\n * off-channel tokens (if any) so won't return whitespace and\n * comments if they are sent to parser on hidden channel.\n */\nString getText();\n```\n\n----------------------------------------\n\nTITLE: Token Set Addition Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar with rules for parsing identifiers followed by optional numeric values (integers or floats). Tests the += operator functionality when applied to a set of tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/ListLabelsOnSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : b b* ';' ;\nb : ID val+=(INT | FLOAT)*;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nFLOAT : [0-9]+ '.' [0-9]+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Customizing Parse Tree Pattern Delimiters in ANTLR4\nDESCRIPTION: Demonstrates how to customize the delimiters used in parse tree patterns. The example changes the default angle brackets to double angle brackets and sets the escape character.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tree-matching.md#2025-04-21_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nParseTreePatternMatcher m = new ParseTreePatternMatcher();\nm.setDelimiters(\"<<\", \">>\", \"$\"); // $ is the escape character\n```\n\n----------------------------------------\n\nTITLE: Defining Logical Expression Grammar in ANTLR4\nDESCRIPTION: A complete ANTLR4 grammar definition for parsing logical expressions with AND, OR, and NOT operators. It includes an @after action with a special assertion to verify that the 'args' variable is properly recognized as a list, addressing GitHub issue #2016.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/ListLabelsOnRuleRefStartOfAlt.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar Test;\n\nexpression\n@after {\n<AssertIsList(\"$args\")>\n}\n    : op=NOT args+=expression\n    | args+=expression (op=AND args+=expression)+\n    | args+=expression (op=OR args+=expression)+\n    | IDENTIFIER\n    ;\n\nAND : 'and' ;\nOR : 'or' ;\nNOT : 'not' ;\nIDENTIFIER : [a-zA-Z_][a-zA-Z0-9_]* ;\nWS : [ \\t\\r\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Creating an Alias for ANTLR4 Docker Command\nDESCRIPTION: Command to create a shell alias that simplifies running ANTLR4 commands through Docker. The alias maps the current directory to the container's work directory and executes ANTLR4 with user permissions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/docker/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nalias antlr4='docker run -it -u $(id -u ${USER}):$(id -g ${USER}) -v $(pwd):/work antlr/antlr4 $@'\n```\n\n----------------------------------------\n\nTITLE: Template Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing template expressions with ${} syntax. Includes rules for handling variables 'a' and 'b', whitespace management, and error recovery. Features init and after actions for parse tree building and visualization.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/ExtraTokensAndAltLabels.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$ctx\"):writeln()>\n}\n  : '${' v '}'\n  ;\n\nv : A #altA\n  | B #altB\n  ;\n\nA : 'a' ;\nB : 'b' ;\n\nWHITESPACE : [ \\n\\t\\r]+ -> channel(HIDDEN) ;\n\nERROR : . ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Parameterized Rules and Semantic Predicates\nDESCRIPTION: The grammar defines a parser that passes integer parameters to rules and uses semantic predicates to choose between alternatives based on those parameters. The parser initializes an integer member 'i' to 0, defines a start rule 's' that calls rule 'a' with different parameters, and uses semantic predicates to select alternatives in rule 'a' based on the parameter value.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/PredicateDependentOnArg.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {<InitIntMember(\"i\",\"0\")>}\ns : a[2] a[1];\na[int i]\n  : {<ValEquals(\"$i\",\"1\")>}? ID {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<ValEquals(\"$i\",\"2\")>}? ID {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Updated Variable Declaration with Pointers for Generated Recognizers\nDESCRIPTION: Shows how to update variable declarations to use pointer types for generated recognizers. This change is necessary because the generated recognizers now return struct pointers instead of interfaces.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-changes.md#2025-04-21_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nvar lexer *parser.MySqlLexer\nvar p *parser.MySqlParser\n// ...\nlexer = parser.NewMySqlLexer(nil)\np = parser.NewMySqlParser(nil)\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expression Parsing and Evaluation\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing and evaluating simple arithmetic expressions. It handles addition, multiplication, integers, and parentheses, with embedded actions to calculate the result.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActions_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v, <StringList()> ignored]\n  : a=e '*' b=e {$v = $a.v * $b.v;}\n  | a=e '+' b=e {$v = $a.v + $b.v;}\n  | INT {$v = $INT.int;}\n  | '(' x=e ')' {$v = $x.v;}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Updating ANTLR Import Paths\nDESCRIPTION: Shell script to update ANTLR import paths in Go files from old to new package location.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nfind . -type f \\\n    -name '*.go' \\\n    -exec sed -i -e 's,github.com/antlr/antlr4/runtime/Go/antlr/v4,github.com/antlr4-go/antlr/v4,g' {} \\;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with If-Then-Else Rules\nDESCRIPTION: Defines a grammar with rules for parsing if-then-else statements and basic identifiers. Includes initialization hooks for ambiguity detection and DFA dumping. The grammar handles nested if statements and optional else clauses.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_6.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n@after {<DumpDFA()>}\n   : '{' stat* '}' ;\nstat: 'if' ID 'then' stat ('else' ID)?\n       | 'return'\n       ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Grammar Definition for Comments\nDESCRIPTION: Defines a lexer grammar named 'L' with rules for matching single-line comments starting with '//' and whitespace characters. The CMT rule captures comments until newline, and WS rule handles spaces and tabs.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyOptional.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : '//' .*? '\\n' CMT??;\nWS : (' '|'\\t')+;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar in ANTLR4\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions including logical operators, parentheses, and ternary operations. It includes lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\n\nstat : expr ';'\n     | expr '.'\n     ;\n\nexpr\n   : ID\n   | 'not' expr\n   | expr 'and' expr\n   | expr 'or' expr\n   | '(' ID ')' expr\n   | expr '?' expr ':' expr\n   | 'between' expr 'and' expr\n   ;\n\nID: [a-zA-Z_][a-zA-Z_0-9]*;\nWS: [ \\t\\n\\r\\f]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parsing IDs and Integers\nDESCRIPTION: This ANTLR4 grammar defines a parser rule 'a' that matches a sequence of IDs and INTs, with a custom action to print the matched text. It also includes lexer rules for IDs, INTs, and whitespace skipping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AorBPlus.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|INT{\n})+ {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Handling Listener Exceptions During Parsing in ANTLR 4\nDESCRIPTION: Override of the triggerExitRuleEvent method from Parser to handle exceptions thrown in listener code during parsing, preventing them from disrupting the parser.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/listeners.md#2025-04-21_snippet_5\n\nLANGUAGE: java\nCODE:\n```\nprotected boolean listenerExceptionOccurred = false;\n\n/**\n * Notify any parse listeners of an exit rule event.\n *\n * @see #addParseListener\n */\n@override\nprotected void triggerExitRuleEvent() {\n\tif ( listenerExceptionOccurred ) return;\n\ttry {\n\t\t// reverse order walk of listeners\n\t\tfor (int i = _parseListeners.size() - 1; i >= 0; i--) {\n\t\t\tParseTreeListener listener = _parseListeners.get(i);\n\t\t\t_ctx.exitRule(listener);\n\t\t\tlistener.exitEveryRule(_ctx);\n\t\t}\n\t}\n\tcatch (Throwable e) {\n\t\t// If an exception is thrown in the user's listener code, we need to bail out\n\t\t// completely out of the parser, without executing anymore user code. We\n\t\t// must also stop the parse otherwise other listener actions will attempt to execute\n\t\t// almost certainly with invalid results. So, record the fact an exception occurred\n\t\tlistenerExceptionOccurred = true;\n\t\tthrow e;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Generating TypeScript Lexer/Parser with ANTLR4\nDESCRIPTION: Command to generate TypeScript lexer or parser using ANTLR4 tool. Specifies the language target as TypeScript.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/typescript-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Dlanguage=TypeScript MyGrammar.g4\n```\n\n----------------------------------------\n\nTITLE: Defining Right-Associative Grammar Rules in ANTLR4\nDESCRIPTION: This grammar defines a set of right-associative rules for expressions, including multiplication, addition, ternary conditional, and assignment. It also includes a rule for matching identifiers and skipping whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_8.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Ambiguous IF-THEN-ELSE Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing statements including nested IF-THEN-ELSE constructs. It initializes exact ambiguity detection and DFA dumping. The grammar includes rules for statement structure, IF-THEN-ELSE statements, identifiers, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n@after {<DumpDFA()>}\n   : '{' stat* '}' ;\nstat: 'if' ID 'then' stat ('else' ID)?\n       | 'return'\n       ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expression Parsing\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' for parsing simple arithmetic expressions. It includes rules for addition, multiplication, and integer literals, as well as lexer rules for operators and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Listeners/LR.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\n<ImportListener(\"T\")>\n<LRListener(\"T\")>\n\ns\n@after {\n<ContextMember(\"$ctx\", \"r\"):ToStringTree():writeln()>\n<ContextMember(\"$ctx\", \"r\"):WalkListener()>\n}\n   : r=e ;\ne : e op='*' e\n   | e op='+' e\n   | INT\n   ;\nMULT: '*' ;\nADD : '+' ;\nINT : [0-9]+ ;\nID  : [a-z]+ ;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: False Predicate Conversion to Exception in Generated Parser\nDESCRIPTION: Shows how ANTLR converts a false predicate in the grammar to a conditional in the generated parser code that throws a FailedPredicateException.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR\nCODE:\n```\nif ( !false ) throw new FailedPredicateException(...);\n```\n\n----------------------------------------\n\nTITLE: Downloading and Extracting ANTLR4 Book Examples\nDESCRIPTION: Commands to download and extract example code from the ANTLR4 book, which includes the ArrayInit.g4 grammar file needed for the project.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npushd ~/Downloads\nwget http://media.pragprog.com/titles/tpantlr2/code/tpantlr2-code.tgz\ntar xvfz tpantlr2-code.tgz\npopd\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expression Parsing and Evaluation\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing and evaluating simple arithmetic expressions. It includes rules for addition, multiplication, parentheses, and integer literals, with embedded actions to compute the expression's value.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActions_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v, <StringList()> ignored]\n  : a=e '*' b=e {$v = $a.v * $b.v;}\n  | a=e '+' b=e {$v = $a.v + $b.v;}\n  | INT {$v = $INT.int;}\n  | '(' x=e ')' {$v = $x.v;}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Lexer Rules in ANTLR4\nDESCRIPTION: The basic syntax for defining lexer rules in ANTLR4. Lexer rule names must begin with an uppercase letter to distinguish them from parser rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexer-rules.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\n/** Optional document comment */\nTokenName : alternative1 | ... | alternativeN ;\n```\n\n----------------------------------------\n\nTITLE: Test Input for Right-Associative Grammar\nDESCRIPTION: Sample input string testing nested conditional expressions to verify right associativity implementation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_9.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\na?b: c?d:e\n```\n\n----------------------------------------\n\nTITLE: Running ANTLR4 Swift Runtime Boot Script\nDESCRIPTION: Command to get help information about the boot.py script used for supporting both Xcode and SPM-based Swift projects with ANTLR4.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython boot.py --help\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Evaluation\nDESCRIPTION: This snippet defines an ANTLR4 grammar for parsing and evaluating mathematical expressions. It includes rules for binary operations, unary operations, parentheses, and variable references. The grammar also incorporates semantic actions to compute expression values during parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleAlternativesWithCommonLabel_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : e '*' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> * <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | e '+' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> + <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | INT{$v = $INT.int;} # anInt\n  | '(' e ')'   {$v = $e.v;}     # parens\n  | left=e INC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"INC()\"):Concat(\" != null\"):Assert()>$v = $left.v + 1;}      # unary\n  | left=e DEC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"DEC()\"):Concat(\" != null\"):Assert()>$v = $left.v - 1;}      # unary\n  | ID {<AssignLocal(\"$v\",\"3\")>}        # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nINC : '++' ;\nDEC : '--' ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Running Dart ANTLR4 Parser from Command Line\nDESCRIPTION: This shell command demonstrates how to run the Dart script that uses the ANTLR4-generated parser to process a JSON file named 'example.json'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/dart-target.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ndart bin/main.dart example.json\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Rules with Overlapping Patterns\nDESCRIPTION: Defines three lexer rules A, B, and C that match increasingly longer patterns starting with 'ab'. Shows how ANTLR4 handles overlapping token patterns during lexical analysis.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/DFAToATNThatMatchesThenFailsInATN.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'ab' ;\nB : 'abc' ;\nC : 'abcd' ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Testing Repeating Subtree Accessibility\nDESCRIPTION: ANTLR4 grammar definition that demonstrates a bug where repeating subtrees are not properly accessible in visitors. The grammar defines an ifStatement rule with a list of elseIfStatement elements that should be accessible as a list rather than a single node.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/ListLabelForClosureContext.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\nifStatement\n@after {\n<AssertIsList({<ContextListFunction(\"$ctx\",\"elseIfStatement\")>})>\n}\n    : 'if' expression\n      ( ( 'then'\n executableStatement*\n elseIfStatement*  // \\<--- problem is here; should yield a list not node\n elseStatement?\n 'end' 'if'\n        ) | executableStatement )\n    ;\n\nelseIfStatement\n    : 'else' 'if' expression 'then' executableStatement*\n    ;\nexpression : 'a' ;\nexecutableStatement : 'a' ;\nelseStatement : 'a' ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Parser Rules and Lexer Rules\nDESCRIPTION: This snippet defines a grammar named 'T' with a parser rule 'a' that matches a sequence of identifiers and integers. It includes embedded actions to output the matched text and defines lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AorBStar_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|INT{\n})* {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar with Custom Tokens and Predicates\nDESCRIPTION: This ANTLR4 lexer grammar defines tokens for 'enum', identifiers, and whitespace. It includes a semantic predicate on the ENUM token that always evaluates to false, effectively disabling it.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/IDvsEnum.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nENUM : 'enum' { <False()> }? ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parser Testing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing a simple language. It includes predicates in the 'a' rule to control matching, and uses a semicolon for error recovery in the 's' rule. The grammar also defines lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/ValidateInDFA.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : a ';' a;\n// ';' helps us to resynchronize without consuming\n// 2nd 'a' reference. We our testing that the DFA also\n// throws an exception if the validating predicate fails\na : {<False()>}? ID  {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<True()>}?  INT {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple If-Else Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar definition for a simple language with if-else statements. The grammar includes rules for handling statements, if statements with optional else clauses, and whitespace skipping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Optional_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\nstat : ifstat | 'x';\nifstat : 'if' stat ('else' stat)?;\nWS : [ \\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' for parsing expressions. It includes rules for various operations, identifier recognition, and whitespace handling. The grammar also specifies a custom after-rule action to print the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Rule for Token and Rule Name Classification\nDESCRIPTION: Defines an ID rule that determines whether an identifier is a token reference or rule reference based on the case of its first character. This is how ANTLR determines the type of identifier during parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexicon.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nID : a=NameStartChar NameChar*\n     {  \n     if ( Character.isUpperCase(getText().charAt(0)) ) setType(TOKEN_REF);\n     else setType(RULE_REF);\n     }  \n   ;\n```\n\n----------------------------------------\n\nTITLE: Running ANTLR4 in Docker with a Grammar File\nDESCRIPTION: Example command sequence to download a JSON grammar file and process it with ANTLR4 in Docker, generating Go code. The command maps the current directory to the container's work directory and runs ANTLR4 with the current user's permissions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/docker/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nwget https://raw.githubusercontent.com/antlr/grammars-v4/master/json/JSON.g4\ndocker run --rm -u $(id -u ${USER}):$(id -g ${USER}) -v `pwd`:/work antlr/antlr4 -Dlanguage=Go JSON.g4\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Calculator Grammar in ANTLR4\nDESCRIPTION: Defines a grammar for parsing and evaluating basic arithmetic expressions with addition and multiplication. The grammar includes rules for handling integers, parentheses, and basic operations while tracking computed values through the parsing process.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActions_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v, <StringList()> ignored]\n  : a=e '*' b=e {$v = $a.v * $b.v;}\n  | a=e '+' b=e {$v = $a.v + $b.v;}\n  | INT {$v = $INT.int;}\n  | '(' x=e ')' {$v = $x.v;}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Test Input for Complex Expression Parsing\nDESCRIPTION: A test input with many repeated logical expressions designed to demonstrate a performance issue in ANTLR4. This input previously took 5 minutes to parse before the fix, but processes instantaneously after the fix was implemented.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_3.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 or\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7\n;\n```\n\n----------------------------------------\n\nTITLE: Publishing C# Runtime to NuGet\nDESCRIPTION: This command publishes the C# runtime package to NuGet using the NuGet CLI tool.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_13\n\nLANGUAGE: cmd\nCODE:\n```\ncd bin/Release\nnuget push Antlr4.Runtime.Standard.<version>.nupkg <your-key> -Source https://www.nuget.org/api/v2/package\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression and Assignment Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions and assignments. It includes special actions for exact ambiguity detection and custom output generation. The grammar handles nested expressions, function-like calls, and assignment operations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/LoopsSimulateTailRecursion.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nprog\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n   : expr_or_assign*;\nexpr_or_assign\n   : expr '++' {<writeln(\"\\\"fail.\\\"\")>}\n   |  expr {<AppendStr(\"\\\"pass: \\\"\",\"$expr.text\"):writeln()>}\n   ;\nexpr: expr_primary ('\\<-' ID)?;\nexpr_primary\n   : '(' ID ')'\n   | ID '(' ID ')'\n   | ID\n   ;\nID  : [a-z]+ ;\n```\n\n----------------------------------------\n\nTITLE: Setting Unsupported Language Option\nDESCRIPTION: Example showing the error message when attempting to generate code in an unsupported language using the language option.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Dlanguage=C MyGrammar.g4\nerror(31):  ANTLR cannot generate C code as of version 4.0\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar with Unicode Character Ranges in ANTLR4\nDESCRIPTION: This lexer grammar defines an ID token that includes Unicode character ranges. It allows characters from A-Z, underscore, and Unicode range U+0100 to U+FFFC in the first character, with additional allowance for digits in subsequent characters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/UnicodeCharSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nID : ([A-Z_]|'Ā'..'￼') ([A-Z_0-9]|'Ā'..'￼')*; // FFFD+ are not valid char\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Parser\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing a sequence of identifiers and integers, with optional semicolons. It includes parser rules 'a' and 'b', and lexer rules for ID, INT, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Labels.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : b1=b b2+=b* b3+=';' ;\nb : id_=ID val+=INT*;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with multiplication, a compound send operator, and identifiers. It includes an after-rule action to print the parse tree, and defines lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr (',' b+=expr)* '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n;\n\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\n\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Parser Rule and Action\nDESCRIPTION: Defines an ANTLR4 grammar named 'T' with a parser rule 'a' that matches sequences of identifiers and executes an action to write the parsed text. The grammar includes lexer rules for identifiers (lowercase letters) and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AorAStar_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|ID)* {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Statement Grammar with Embedded Action in ANTLR4\nDESCRIPTION: This ANTLR4 grammar definition named 'T' recognizes a program consisting of multiple statements (break, continue, return) and includes an embedded action to write out the matched text. The grammar demonstrates how to incorporate custom code actions within grammar rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Keyword_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nprogram : state*{<writeln(\"$text\")>} EOF ;\nstate: 'break;' | 'continue;' | 'return;' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Binary File Stream Creation\nDESCRIPTION: Creates a character stream from binary file using ISO-8859-1 encoding to treat bytes as characters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parsing-binary-files.md#2025-04-21_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nCharStream bytesAsChar = CharStreams.fromFileName(\"/tmp/ips\", StandardCharsets.ISO_8859_1);\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Grammar with If-Else Statements in ANTLR4\nDESCRIPTION: An ANTLR4 grammar that defines a simple language with if-statements and optional else clauses. The grammar includes a semantic action block that writes the matched text of each if-statement. The grammar also defines basic lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/IfIfElseGreedyBinding2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : statement+ ;\nstatement : 'x' | ifStatement;\nifStatement : 'if' 'y' statement ('else' statement|) {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Expression Parser Grammar Definition with Precedence Rules\nDESCRIPTION: Defines a grammar for parsing expressions with multiplication and addition operators. Includes precedence rules with parametrized recursion, ambiguity detection initialization, and token definitions for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/ExprAmbiguity_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n:   expr[0] {<ToStringTree(\"$expr.ctx\"):writeln()>};\n   expr[int _p]\n       : ID\n       (\n  {5 >= $_p}? '*' expr[6]\n  | {4 >= $_p}? '+' expr[5]\n       )*\n       ;\nID  : [a-zA-Z]+ ;\nWS  : [ \\r\\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Fuzzy Parsing for Java Constants in ANTLR4\nDESCRIPTION: This ANTLR4 grammar demonstrates fuzzy parsing to extract integer constants from a Java file without specifying the full Java grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_5\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar FuzzyJava;\n\n/** Match anything in between constant rule matches */\nfile : .*? (constant .*?)+ ;\n\n/** Faster alternate version (Gets an ANTLR tool warning about\n * a subrule like .* in parser that you can ignore.)\n */\naltfile : (constant | .)* ; // match a constant or any token, 0-or-more times\n\n/** Match things like \"public static final SIZE\" followed by anything */\nconstant\n    :   'public' 'static' 'final' 'int' Identifier\n        {System.out.println(\"constant: \"+$Identifier.text);}\n    ;\n\nIdentifier : [a-zA-Z_$] [a-zA-Z_$0-9]* ; // simplified\n```\n\n----------------------------------------\n\nTITLE: Lexer Analysis Output with Token Recognition\nDESCRIPTION: Shows the token recognition output including token type, text, position, and line number. Includes EOF token and error message for unrecognized character.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/DFAToATNThatMatchesThenFailsInATN.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:1='ab',<1>,1:0]\n[@1,2:4='abc',<2>,1:2]\n[@2,6:5='<EOF>',<-1>,1:6]\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nline 1:5 token recognition error at: 'x'\n```\n\n----------------------------------------\n\nTITLE: Testing ANTLR4 Installation\nDESCRIPTION: Commands to verify that ANTLR4 is correctly installed by launching the tool and checking that it displays the help information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n$ java org.antlr.v4.Tool\nANTLR Parser Generator Version 4.13.2\n-o ___ specify output directory where all output is generated\n-lib ___ specify location of .tokens files\n...\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ java -jar /usr/local/lib/antlr-4.13.2-complete.jar\nANTLR Parser Generator Version 4.13.2\n-o ___ specify output directory where all output is generated\n-lib ___ specify location of .tokens files\n...\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Java-like Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing Java-like expressions and statements. It includes rules for various operations, method calls, object instantiation, and type specifications. The grammar also defines lexer rules for identifiers and integers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Lexer Token Output\nDESCRIPTION: Generated lexer output showing token recognition with position information and token types. Each token includes position, text, type, and line/column information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RefToRuleDoesNotSetTokenNorEmitAnother.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:1='34',<2>,1:0]\n[@1,3:5='-21',<1>,1:3]\n[@2,7:7='3',<2>,1:7]\n[@3,8:7='<EOF>',<-1>,1:8]\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Assignment Pattern Matching with Wildcards\nDESCRIPTION: This ANTLR4 grammar defines rules to identify assignment statements in the form 'ID = INT;' while ignoring all other tokens. When an assignment is found, it executes an action to write the matched text. The grammar demonstrates how to use wildcards to ignore unwanted patterns.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Wildcard.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (assign|.)+ EOF ;\nassign : ID '=' INT ';' {\n<writeln(\"$text\")>\n} ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Initializing ACE Editor in HTML\nDESCRIPTION: This snippet shows how to include and initialize the ACE Editor in an HTML page.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<script src=\"../js/ace/ace.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script>\n    var editor = ace.edit(\"editor\");\n</script>\n```\n\n----------------------------------------\n\nTITLE: Defining Main Grammar M in ANTLR4\nDESCRIPTION: This snippet defines the main grammar 'M' which imports the slave grammar 'S'. It includes a simple rule for 's' and defines whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/BringInLiteralsFromDelegate.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\ns : a ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Identifier Parsing\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with rules for parsing a sequence of identifiers. It includes a start rule 's', a recursive rule 'a' for handling multiple identifiers, and lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Simple_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : a ;\na : a ID\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parser 'T'\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with a parser rule 'a' and a lexer rule 'A'. The parser rule includes a semantic action to write the input text. The grammar is designed to parse an optional 'b' followed by a 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/OptionalSingleElement.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A? 'c' {<InputText():writeln()>} ;\nA : 'b' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Labeled Rules\nDESCRIPTION: Defines a grammar that handles compound operators and labeled expressions. The grammar includes rules for multiplication, sending operations with multiple expressions, and basic identifier matching. It demonstrates label usage with operators ',' and '>>' as compound elements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr (',' b+=expr)* '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n;\n\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\n\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Embedded Action\nDESCRIPTION: A simple ANTLR4 grammar named 'T' that defines a rule 'a' which matches one or more identifiers and uses an embedded action to write the matched text. The grammar also defines lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/APlus.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ID+ {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR Grammar for Expression Parsing\nDESCRIPTION: Defines a grammar 'T' that parses expressions with operators (*,+), ternary conditions (?:), assignments (=), and identifiers. Includes rules for operator precedence and right associativity for ternary and assignment operators. Also defines lexer rules for identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_9.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |\\<assoc=right> e '?' e ':' e\n  |\\<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Java Expression Parser Grammar Definition in ANTLR4\nDESCRIPTION: Complete ANTLR4 grammar defining rules for parsing Java-like expressions. Includes support for operator precedence, method calls, array access, type casting, and basic lexer rules for identifiers and integers. The grammar handles complex expressions including arithmetic operations, method invocations, and array declarations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_7.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |\\<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |\\<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='\n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic Arithmetic Expression Parser Grammar in ANTLR4\nDESCRIPTION: Defines a parser grammar named 'T' that handles basic arithmetic expressions with multiplication, division, integers, and parenthesized expressions. Includes a tree visualization output after parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/LabelsOnOpSubrule_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e;\ne : a=e op=('*'|'/') b=e  {}\n  | INT {}\n  | '(' x=e ')' {}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Using ANTLR4 Output Directory Option in Bash\nDESCRIPTION: Demonstrates how to specify an output directory for ANTLR-generated files using the -o option, showing the resulting generated files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -o /tmp T.g4\n$ ls /tmp/T*\n/tmp/T.tokens /tmp/TListener.java\n/tmp/TBaseListener.java /tmp/TParser.java\n```\n\n----------------------------------------\n\nTITLE: Defining C++-Specific Lexer Named Actions in ANTLR4 Grammars\nDESCRIPTION: These named actions are specific to the C++ target for the lexer. They allow for customization of various parts of the generated lexer code, such as includes, context, declarations, and definitions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/cpp-target.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR4\nCODE:\n```\n@lexer::preinclude\n@lexer::postinclude\n@lexer::context\n@lexer::declarations\n@lexer::definitions\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple arithmetic expressions. It includes rules for multiplication, division, parentheses, and integer literals. The grammar also incorporates actions and a tree output for debugging purposes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleActions_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e ;\ne : a=e op=('*'|'/') b=e  {}{}\n  | INT {}{}\n  | '(' x=e ')' {}{}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar Rules in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for integers (I), identifiers (ID), and whitespace (WS). It includes Java actions to print token types for integers and identifiers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetRange.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : [0-9]+ {<writeln(\"\\\"I\\\"\")>} ;\nID : [a-zA-Z] [a-zA-Z0-9]* {<writeln(\"\\\"ID\\\"\")>} ;\nWS : [ \\n\\u0009\\r]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Semantic Predicates\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with rules for parsing expressions and statements. It includes parser members, semantic predicates, and actions to control parsing behavior and output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/ActionsHidePredsInGlobalFOLLOW.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {\n<Declare_pred()>\n}\ns : e {} {<True():Invoke_pred()>}? {<writeln(\"\\\"parse\\\"\")>} '!' ;\nt : e {} {<False():Invoke_pred()>}? ID ;\ne : ID | ; // non-LL(1) so we use ATN\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Syntax Highlighting Rules for ACE Editor\nDESCRIPTION: This code defines custom syntax highlighting rules for a new language mode in ACE Editor. It includes rules for comments, strings, numbers, operators, and keywords.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nace.define('ace/mode/my-mode',[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/text_highlight_rules\", \"ace/worker/worker_client\" ], function(require, exports, module) {\n    var oop = require(\"ace/lib/oop\");\n    var TextMode = require(\"ace/mode/text\").Mode;\n    var TextHighlightRules = require(\"ace/mode/text_highlight_rules\").TextHighlightRules;\n\n    var MyHighlightRules = function() {\n        var keywordMapper = this.createKeywordMapper({\n            \"keyword.control\": \"if|then|else\",\n            \"keyword.operator\": \"and|or|not\",\n            \"keyword.other\": \"class\",\n            \"storage.type\": \"int|float|text\",\n            \"storage.modifier\": \"private|public\",\n            \"support.function\": \"print|sort\",\n            \"constant.language\": \"true|false\"\n  }, \"identifier\");\n        this.$rules = {\n            \"start\": [\n                { token : \"comment\", regex : \"//\" },\n                { token : \"string\",  regex : '[\"'](?:(?:\\\\\\.)|(?:[^\"'\\\\]))*?[\"']' },\n                { token : \"constant.numeric\", regex : \"0[xX][0-9a-fA-F]+\\\\b\" },\n                { token : \"constant.numeric\", regex: \"[+-]?\\\\d+(?:(?:\\\\.\\\\d*)?(?:[eE][+-]?\\\\d+)?)?\\\\b\" },\n                { token : \"keyword.operator\", regex : \"!|%|\\\\\\\\|/|\\\\*|\\\\-|\\\\+|~=|==|<>|!=|<=|>=|=|<|>|&&|\\\\|\\\\|\" },\n                { token : \"punctuation.operator\", regex : \"\\\\?|\\\\:|\\\\,|\\\\;|\\\\.\" },\n                { token : \"paren.lparen\", regex : \"[[({]\" },\n                { token : \"paren.rparen\", regex : \"[\\\\])}]\" },\n                { token : \"text\", regex : \"\\\\s+\" },\n                { token: keywordMapper, regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\" }\n            ]\n        };\n    };\n    oop.inherits(MyHighlightRules, TextHighlightRules);\n\n    var MyMode = function() {\n        this.HighlightRules = MyHighlightRules;\n    };\n    oop.inherits(MyMode, TextMode);\n\n    (function() {\n\n        this.$id = \"ace/mode/my-mode\";\n\n    }).call(MyMode.prototype);\n\n    exports.Mode = MyMode;\n});\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar Rules\nDESCRIPTION: Defines a lexer grammar named 'L' with two token rules: LF for line feed (\\u000A) and X for the character 'x'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EscapedCharacters.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar L;\nLF : '\\\\u000A';\nX  : 'x';\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition for Letter Sequence Parsing\nDESCRIPTION: Defines a grammar that parses sequences of 'a' and 'b' letters, with specific rules for handling consecutive 'a' characters. The grammar includes a prog rule that captures statements and outputs the parse tree structure.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/PrecedenceFilterConsidersContext.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nprog\n@after {<ToStringTree(\"$ctx\"):writeln()>}\n: statement* EOF {};\nstatement: letterA | statement letterA 'b' ;\nletterA: 'a';\n```\n\n----------------------------------------\n\nTITLE: Expression Parser Grammar Definition in ANTLR4\nDESCRIPTION: Comprehensive ANTLR4 grammar for parsing expressions with support for method calls, field access, operators, type casting, and array operations. Includes lexer rules for identifiers, integers, and whitespace. The grammar handles operator precedence and associativity through rule ordering.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/JavaExpressions_10.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\nexpressionList\n    :   e (',' e)*\n    ;\ne   :   '(' e ')'\n    |   'this'\n    |   'super'\n    |   INT\n    |   ID\n    |   typespec '.' 'class'\n    |   e '.' ID\n    |   e '.' 'this'\n    |   e '.' 'super' '(' expressionList? ')'\n    |   e '.' 'new' ID '(' expressionList? ')'\n    |   'new' typespec ( '(' expressionList? ')' | ('[' e ']')+)\n    |   e '[' e ']'\n    |   '(' typespec ')' e\n    |   e ('++' | '--')\n    |   e '(' expressionList? ')'\n    |   ('+'|'-'|'++'|'--') e\n    |   ('~'|'!') e\n    |   e ('*'|'/'|'%') e\n    |   e ('+'|'-') e\n    |   e ('\\<\\<' | '>>>' | '>>') e\n    |   e ('\\<=' | '>=' | '>' | '\\<') e\n    |   e 'instanceof' e\n    |   e ('==' | '!=') e\n    |   e '&' e\n    |\\<assoc=right> e '^' e\n    |   e '|' e\n    |   e '&&' e\n    |   e '||' e\n    |   e '?' e ':' e\n    |\\<assoc=right>\n        e ('='\n |'+='\n |'-='\n |'*='\n |'/='\n |'&='\n |'|='\n |'^='\n |'>>='\n |'>>>='\n |'\\<\\<='/n |'%=') e\n    ;\ntypespec\n    : ID\n    | ID '[' ']'\n    | 'int'\n    | 'int' '[' ']'\n    ;\nID  : ('a'..'z'|'A'..'Z'|'_'|'$')+;\nINT : '0'..'9'+ ;\nWS  : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Custom Error Handling and Tree Output\nDESCRIPTION: This snippet defines an ANTLR4 grammar 'T' with rules for parsing identifiers. It includes a custom error message, tree visualization, and token definitions for IDs and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/SemPredFailOption.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : a ;\na : a ID {<False()>}?<fail='custom message'>\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing with Actions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing arithmetic expressions. It includes actions, semantic predicates, and custom attributes to test specific ANTLR4 behaviors, particularly related to operator precedence and action placement.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleActionsPredicatesOptions_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e ;\ne : a=e op=('*'|'/') b=e  {}{<True()>}?\n  | a=e op=('+'|'-') b=e  {}<p=3>{<True()>}?<fail='Message'>\n  | INT {}{}\n  | '(' x=e ')' {}{}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Loading Separate ANTLR4 Lexer and Parser Grammars in Java\nDESCRIPTION: This Java method loads separate lexer and parser grammars from files, creates interpreters, and parses input. It demonstrates handling separate grammar files and file input for ANTLR4 interpreters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/interpreters.md#2025-04-21_snippet_3\n\nLANGUAGE: java\nCODE:\n```\npublic static ParseTree parse(String fileNameToParse,\n                              String lexerGrammarFileName,\n                              String parserGrammarFileName,\n                              String startRule)\n    throws IOException\n{\n    final LexerGrammar lg = (LexerGrammar) Grammar.load(lexerGrammarFileName);\n    final Grammar pg = Grammar.load(parserGrammarFileName, lg);\n    CharStream input = CharStreams.fromPath(Paths.get(fileNameToParse));\n    LexerInterpreter lexEngine = lg.createLexerInterpreter(input);\n    CommonTokenStream tokens = new CommonTokenStream(lexEngine);\n    ParserInterpreter parser = pg.createParserInterpreter(tokens);\n    ParseTree t = parser.parse(pg.getRule(startRule).index);\n    System.out.println(\"parse tree: \" + t.toStringTree(parser));\n    return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines tokens for colon, pointer, and identifier. It includes rules for recognizing these tokens in the input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/LexerExecDFA.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCOLON : ':' ;\nPTR : '->' ;\nID : [a-z]+;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Comments and Whitespace in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for single-line comments (CMT) and whitespace (WS). The CMT rule matches '//' followed by any characters up to a newline, allowing for nested comments. The WS rule matches one or more spaces or tabs.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyClosure.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : '//' .*? '\\n' CMT*;\nWS : (' '|'\\t')+;\n```\n\n----------------------------------------\n\nTITLE: Basic Control Flow Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar named 'T' with rules for parsing break, continue, and return statements. Includes an embedded action to write the matched text and handles error listening.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Keyword_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nprogram : addErrorListener*{<writeln(\"$text\")>} EOF ;\naddErrorListener: 'break;' | 'continue;' | 'return;' ;\n```\n\n----------------------------------------\n\nTITLE: Basic Arithmetic Expression Grammar in ANTLR4\nDESCRIPTION: Defines a grammar for parsing simple arithmetic expressions with multiplication, division, and parentheses. Includes a tree output visualization feature using the @after annotation. The grammar handles integers, basic operators (*,/), and nested parentheses expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/LabelsOnOpSubrule_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e;\ne : a=e op=('*'|'/') b=e  {}\n  | INT {}\n  | '(' x=e ')' {}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Actions and Predicates in ANTLR4 Lexer\nDESCRIPTION: This snippet illustrates an incorrect way of using actions and predicates in ANTLR4 lexer rules. The action will not execute as expected during rule matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_14\n\nLANGUAGE: ANTLR4\nCODE:\n```\nStuff : ( 'a'+ {count++;} | 'b') 'c' 'd' {count == 3}? ;\n```\n\n----------------------------------------\n\nTITLE: Complex ANTLR Rule with Actions and Attributes\nDESCRIPTION: Comprehensive example showing rule attributes with init and after actions in a CSV parser context.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_13\n\nLANGUAGE: java\nCODE:\n```\n/** Derived from rule \"row : field (',' field)* '\\r'? '\\n' ;\" */\nrow[String[] columns]\n   returns [Map<String,String> values]\n   locals [int col=0]\n\t@init {\n\t$values = new HashMap<String,String>();\n\t}\n\t@after {\n\tif ($values!=null && $values.size()>0) {\n\tSystem.out.println(\"values = \"+$values);\n\t}\n\t}\n\t: ...\n\t;\n```\n\n----------------------------------------\n\nTITLE: Defining Common Named Actions in ANTLR4 Grammars\nDESCRIPTION: These are the common named actions supported by all ANTLR4 targets. They allow for customization of generated files by adding code to specific areas. The @header action is placed at the top of all generated files, while @members is placed in the public section of lexer or parser class declarations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/cpp-target.md#2025-04-21_snippet_3\n\nLANGUAGE: ANTLR4\nCODE:\n```\n@parser::header\n@parser::members\n@lexer::header\n@lexer::members\n@header\n@members\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition for Expression Parsing\nDESCRIPTION: Defines a grammar 'T' with rules for parsing expressions including multiplication, comma-separated values, and send operations. Includes special handling for compound operators and labeled alternatives.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList2_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr ',' b+=expr #Comma\n    | b+=expr '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n   ;\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Integer and Whitespace Tokens in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for recognizing integer tokens and skipping whitespace. It includes a custom action to print the recognized integer token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : '0'..'9'+ {<writeln(\"\\\"I\\\"\")>} ;\nWS : [ \\n\\u000D] -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining T Grammar Rules in ANTLR4\nDESCRIPTION: ANTLR4 grammar definition that specifies rules for parsing paragraphs with special handling of newlines and character tokens 's' and 'x'. Includes a custom after-rule action for tree visualization and predicate evaluation for newline handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/PredFromAltTestedInLoopBack_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nfile_\n@after {<ToStringTree(\"$ctx\"):writeln()>}\n  : para para EOF ;\npara: paraContent NL NL ;\nparaContent : ('s'|'x'|{<LANotEquals(\"2\",{T<ParserToken(\"Parser\", \"NL\")>})>}? NL)+ ;\nNL : '\\n' ;\ns : 's' ;\nX : 'x' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar with Tree Output\nDESCRIPTION: Defines a simple grammar 'T' with recursive rule 'a' that matches sequences of identifiers. Includes a custom tree output format using the @after action and ToStringTree template. The grammar handles basic ID tokens and whitespace skipping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/SemPred.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : a ;\na : a {<True()>}? ID\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Token Definition for Binary Marker\nDESCRIPTION: Defines a token rule for matching a specific 2-byte marker sequence (0xCA 0xFE) in binary data.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parsing-binary-files.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\nMARKER : '\\u00CA' '\\u00FE' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar with ANTLR4\nDESCRIPTION: Grammar specification for parsing expressions including multiplication, addition, ternary operations, and assignments. Includes lexer rules for identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne : e '*' e\n  | e '+' e\n  |\\<assoc=right> e '?' e ':' e\n  |\\<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Right-Associative Expression Grammar in ANTLR4\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with right-associative operators. It includes multiplication, addition, ternary, and assignment operators, as well as identifiers. The grammar is designed to test right-associativity of the first alternative.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Arithmetic Expressions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple arithmetic expressions. It includes rules for integers, multiplication, division, and parentheses. The grammar also specifies a custom after-rule action to print the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/LabelsOnOpSubrule_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e;\ne : a=e op=('*'|'/') b=e  {}\n  | INT {}\n  | '(' x=e ')' {}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar for Comments\nDESCRIPTION: Defines lexer rules for matching C-style block comments and whitespace. The CMT rule uses non-greedy matching for nested comment structures, while WS handles spaces and newlines.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardPlus_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : '/*' (CMT | .)+? '*' '/' ;\nWS : (' '|'\\n')+;\n```\n\n----------------------------------------\n\nTITLE: T Grammar Definition with Semantic Predicates\nDESCRIPTION: Grammar that defines rules for matching input sequences with semantic predicates and embedded actions. Contains rules for matching identifiers and handling whitespace with predicates controlling alternative selection.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/IndependentPredNotPassedOuterCtxToAvoidCastException.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : b ';' |  b '.' ;\nb : a ;\na\n  : {<False()>}? ID {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<True()>}? ID {<writeln(\"\\\"alt 2\\\"\")>}\n ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Integer and Whitespace Lexer Rules in ANTLR4\nDESCRIPTION: Defines two lexer rules: 'I' for matching integer literals with a custom writeln action, and 'WS' for skipping whitespace characters including spaces, newlines and carriage returns.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetPlus.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : '0'..'9'+ {<writeln(\"\\\"I\\\"\")>} ;\nWS : [ \\n\\u000D]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Label Type Matching Grammar Definition in ANTLR4\nDESCRIPTION: ANTLR4 grammar definition that tests label type consistency between rule and token references. The grammar processes 'x' and 'y' tokens with labeled alternatives and actions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/LabelAliasingAcrossLabeledAlternatives.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : a* EOF;\na\n  : label=subrule {<writeln(\"$label.text\")>} #One\n  | label='y' {<writeln(\"$label.text\")>} #Two\n  ;\nsubrule : 'x';\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar Rules\nDESCRIPTION: Defines a lexer grammar named 'L' with three token rules: A matches 'a' followed by EOF, B matches just 'a', and C matches 'c'. The grammar demonstrates different token matching patterns including EOF handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EOFSuffixInFirstRule_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'a' EOF ;\nB : 'a';\nC : 'c';\n```\n\n----------------------------------------\n\nTITLE: Configuring ANTLR4 Access Levels in Grammar File\nDESCRIPTION: Grammar file options for specifying access levels in generated Swift code. This affects the visibility of generated classes and methods.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\noptions {\n    accessLevel = 'value';\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Default Generated Listener in JavaScript\nDESCRIPTION: Example of a generated listener class structure in JavaScript. Shows the default methods that ANTLR4 generates for a grammar with 'key' and 'value' rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/javascript-target.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nclass MyGrammarListener extends ParseTreeListener {\n    constructor() {\n        super();\n    }\n   \n    enterKey(ctx) {}\n    exitKey(ctx) {}\n    enterValue(ctx) {}\n    exitValue(ctx) {}\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Flag Configuration\nDESCRIPTION: Sets up compiler-specific warning flags and build configurations for different build types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n  set(CMAKE_CXX_FLAGS_DEBUG          \"${CMAKE_CXX_FLAGS_DEBUG} /Od /Zi /MP ${MY_CXX_WARNING_FLAGS}\")\n  set(CMAKE_CXX_FLAGS_MINSIZEREL     \"${CMAKE_CXX_FLAGS_MINSIZEREL} /O1 /Oi /Ob2 /Gy /MP /DNDEBUG ${MY_CXX_WARNING_FLAGS}\")\n  set(CMAKE_CXX_FLAGS_RELEASE        \"${CMAKE_CXX_FLAGS_RELEASE} /O2 /Oi /Ob2 /Gy /MP /DNDEBUG ${MY_CXX_WARNING_FLGAS}\")\n  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"${CMAKE_CXX_FLAGS_RELWITHDEBINFO} /O2 /Oi /Ob2 /Gy /MP /Zi ${MY_CXX_WARNING_FLAGS}\")\nelse()\n  set(CMAKE_CXX_FLAGS_DEBUG          \"${CMAKE_CXX_FLAGS_DEBUG} -O0 -g ${MY_CXX_WARNING_FLAGS}\")\n  set(CMAKE_CXX_FLAGS_MINSIZEREL     \"${CMAKE_CXX_FLAGS_MINSIZEREL} -Os -DNDEBUG ${MY_CXX_WARNING_FLAGS}\")\n  set(CMAKE_CXX_FLAGS_RELEASE        \"${CMAKE_CXX_FLAGS_RELEASE} -O3 -DNDEBUG ${MY_CXX_WARNING_FLGAS}\")\n  set(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -O2 -g ${MY_CXX_WARNING_FLAGS}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for EOF Testing\nDESCRIPTION: ANTLR4 grammar that defines a simple parser structure for testing EOF handling. The grammar includes a cppCompilationUnit rule that requires EOF at the end, and defines content and anything rules for matching characters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/DisabledAlternative.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ncppCompilationUnit : content+ EOF;\ncontent: anything | {<False()>}? .;\nanything: ANY_CHAR;\nANY_CHAR: [_a-zA-Z0-9];\n```\n\n----------------------------------------\n\nTITLE: Integer Token Lexer Grammar Definition\nDESCRIPTION: Defines a lexer grammar with two rules: one for matching integer sequences and another for skipping whitespace. The integer rule includes an action to write out 'I' when matched.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithMissingEscapeChar.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : [0-9]+ {<writeln(\"\\\"I\\\"\")>} ;\nWS : [ \\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Master Grammar Definition in ANTLR4\nDESCRIPTION: Defines the main grammar M that imports slave grammar S. Includes basic token rules and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/ImportedGrammarWithEmptyOptions.txt#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\ngrammar M;\nimport S;\ns : a ;\nB : 'b' ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar definition for a simple expression language that supports logical operations (and, or, not), conditional expressions, and parenthesized expressions. This grammar was used to test a performance issue (#1398) that was causing extremely slow parsing for complex expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\n\nstat : expr ';'\n     | expr '.'\n     ;\n\nexpr\n   : ID\n   | 'not' expr\n   | expr 'and' expr\n   | expr 'or' expr\n   | '(' ID ')' expr\n   | expr '?' expr ':' expr\n   | 'between' expr 'and' expr\n   ;\n\nID: [a-zA-Z_][a-zA-Z_0-9]*;\nWS: [ \\t\\n\\r\\f]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Rule Invocation Stack and Parse Tree Visualization\nDESCRIPTION: This grammar defines a simple parser that recognizes the letter 'x'. It uses template actions to import rule invocation stack functionality, build parse trees, and output the tree structure. The grammar demonstrates how to use @init and @after blocks with custom actions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/TokenAndRuleContextString.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n<ImportRuleInvocationStack()>\n\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : 'x' {\n<RuleInvocationStack():writeln()>\n} ;\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Expression Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing arithmetic expressions with integers and +/- operators. Includes a parser rule for the start symbol 's', expression rules, literal handling, and operator definitions. Features a custom tree output format using the @after action.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/PrefixAndOtherAlt_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF ;\nexpr : literal\n     | op expr\n     | expr op expr\n     ;\nliteral : '-'? Integer ;\nop : '+' | '-' ;\nInteger : [0-9]+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar definition named 'Expr' that specifies rules for parsing expressions with logical operators, ternary conditionals, parenthesized expressions, and identifiers. The grammar includes lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\n\nstat : expr ';'\n     | expr '.'\n     ;\n\nexpr\n   : ID\n   | 'not' expr\n   | expr 'and' expr\n   | expr 'or' expr\n   | '(' ID ')' expr\n   | expr '?' expr ':' expr\n   | 'between' expr 'and' expr\n   ;\n\nID: [a-zA-Z_][a-zA-Z_0-9]*;\nWS: [ \\t\\n\\r\\f]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Expression Rules\nDESCRIPTION: Grammar definition that includes rules for mathematical expressions with binary operations, parentheses, increments/decrements, and identifier handling. Tests context accessor method generation for labeled alternatives.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleAlternativesWithCommonLabel_5.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns : e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : e '*' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> * <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | e '+' e     {$v = <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(0)}, {<Result(\"v\")>})> + <Cast(\"BinaryContext\",\"$ctx\"):SubContextLocal({<Production(\"e\")>(1)}, {<Result(\"v\")>})>;}  # binary\n  | INT{$v = $INT.int;} # anInt\n  | '(' e ')'   {$v = $e.v;}     # parens\n  | left=e INC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"INC()\"):Concat(\" != null\"):Assert()>$v = $left.v + 1;}      # unary\n  | left=e DEC  {<ContextRuleFunction(Cast(\"UnaryContext\",\"$ctx\"), \"DEC()\"):Concat(\" != null\"):Assert()>$v = $left.v - 1;}      # unary\n  | ID {<AssignLocal(\"$v\",\"3\")>}        # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nINC : '++' ;\nDEC : '--' ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar Rules for Comments\nDESCRIPTION: ANTLR lexer grammar defining rules for C-style comments and whitespace. The CMT rule matches comments with optional nesting, and WS rule handles spaces and newlines.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardStar_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar L;\nCMT : '/*' (CMT | .)*? '*' '/' ;\nWS : (' '|'\\n')+;\n```\n\n----------------------------------------\n\nTITLE: Right-Associative Expression Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar with right-associative operators including multiplication (*), addition (+), ternary (?:), and assignment (=). The grammar includes a root rule 's' and expression rule 'e' with multiple alternatives. Includes lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :<assoc=right> e '*' e\n  |<assoc=right> e '+' e\n  |<assoc=right> e '?' e ':' e\n  |<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Unicode Ranges in ANTLR Lexer Rules\nDESCRIPTION: Example of defining lexer rules for Unicode character ranges using standard escape sequences. This snippet shows how to create a rule for Cyrillic characters using the \\u escape with 4 hex digits.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\nCYRILLIC : '\\u0400'..'\\u04FF' ; // or [\\u0400-\\u04FF] without quotes\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar Rules in ANTLR4\nDESCRIPTION: This snippet defines a lexer grammar named 'L' with rules for matching actions, strings, and whitespace. It includes patterns for handling escaped quotes within strings.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/StringsEmbeddedInActions_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nACTION2 : '[' (STRING | ~'\"')*? ']';\nSTRING : '\"' ('\\\\\\\\' '\"' | .)*? '\"';\nWS : [ \\t\\r\\n]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Reused Labels Example\nDESCRIPTION: Demonstrates reusing labels across multiple alternatives to trigger the same event.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_5\n\nLANGUAGE: antlr4\nCODE:\n```\ne : e '*' e # BinaryOp\n\t| e '+' e # BinaryOp\n\t| INT # Int\n\t;\n```\n\n----------------------------------------\n\nTITLE: Testing ANTLR4 Lexer Rules with grun\nDESCRIPTION: This bash script demonstrates how to compile and test ANTLR4 lexer rules using the grun tool. It shows the output for the 'enum' and identifier recognition.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_11\n\nLANGUAGE: Bash\nCODE:\n```\n$ antlr4 Enum3.g4\n$ javac Enum3.java\n$ grun Enum3 tokens\n=> \tenum abc\n=> \tEOF\n<= \tenum!\n \tID abc\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar with Predicate Testing\nDESCRIPTION: Defines a grammar with parser predicates that validate context-dependent conditions. Includes rules for parameter passing, value comparison, and selective parsing based on predicate evaluation. Features custom lexer rules for identifiers, integers, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/DepedentPredsInGlobalFOLLOW.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {\n<Declare_pred()>\n}\ns : a[99] ;\na[int i] : e {<ValEquals(\"$i\",\"99\"):Invoke_pred()>}? {<writeln(\"\\\"parse\\\"\")>} '!' ;\nb[int i] : e {<ValEquals(\"$i\",\"99\"):Invoke_pred()>}? ID ;\ne : ID | ; // non-LL(1) so we use ATN\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Semantic Predicates\nDESCRIPTION: An ANTLR4 grammar definition that demonstrates the use of semantic predicates to control rule alternatives. The grammar includes a start rule 's' that accepts one or more 'a' elements, where rule 'a' has two alternatives controlled by semantic predicates.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/ToLeft.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n   s : a+ ;\na : {<False()>}? ID {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<True()>}?  ID {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Setting Up ANTLR4 C++ Runtime Tests with Google Test in CMake\nDESCRIPTION: Configures the build process for ANTLR4 C++ runtime tests using Google Test framework. It fetches the Google Test library, sets up the test executable, and configures test discovery.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif (ANTLR_BUILD_CPP_TESTS)\n  include(FetchContent)\n\n  FetchContent_Declare(\n    googletest\n    URL https://github.com/google/googletest/archive/e2239ee6043f73722e7aa812a459f54a28552929.zip\n  )\n\n  if(WITH_STATIC_CRT)\n    set(gtest_force_shared_crt ON CACHE BOOL \"\" FORCE)\n  endif()\n\n  FetchContent_MakeAvailable(googletest)\n\n  file(GLOB libantlrcpp_TESTS\n    \"${PROJECT_SOURCE_DIR}/runtime/tests/*.cpp\"\n  )\n\n  add_executable(\n    antlr4_tests\n    ${libantlrcpp_TESTS}\n  )\n\n  target_link_libraries(\n    antlr4_tests\n\t$<IF:$<TARGET_EXISTS:antlr4_static>,antlr4_static,antlr4_shared>\n    gtest_main\n  )\n\n  include(GoogleTest)\n\n  gtest_discover_tests(antlr4_tests)\nendif()\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Paragraph Parsing\nDESCRIPTION: Grammar for parsing paragraphs with content and newlines. Includes semantic predicate to control newline matching and custom after-rule action for tree output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/PredFromAltTestedInLoopBack_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nfile_\n@after {<ToStringTree(\"$ctx\"):writeln()>}\n  : para para EOF ;\npara: paraContent NL NL ;\nparaContent : ('s'|'x'|{<LANotEquals(\"2\",{T<ParserToken(\"Parser\", \"NL\")>})>}? NL)+ ;\nNL : '\\n' ;\ns : 's' ;\nX : 'x' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Lexer Grammar in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines two token rules: DONE for end-of-file and A for the literal 'a'. It demonstrates basic token definition syntax in ANTLR4.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EOFByItself.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nDONE : EOF ;\nA : 'a';\n```\n\n----------------------------------------\n\nTITLE: Defining Main Grammar M in ANTLR4\nDESCRIPTION: This snippet defines the main grammar 'M' which imports the slave grammar 'S' and specifies a simple parser rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/CombinedImportsCombined.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\ns : x INT;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for T Language\nDESCRIPTION: This snippet defines the complete grammar for the T language, including parser rules, lexer rules, and embedded actions. It demonstrates the use of predicates and action blocks within rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/Order.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : a {} a; // do 2x: once in ATN, next in DFA;\n// action blocks lookahead from falling off of 'a'\n// and looking into 2nd 'a' ref. !ctx dependent pred\na : ID {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<True()>}?  ID {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Expected Output from ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet shows the expected output after processing the input 'ab' with the defined lexer grammar. It demonstrates how the tokens are recognized, including their types, channels, and positions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ReservedWordsEscaping.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:0='a',<1>,1:0]\n[@1,1:1='b',<2>,channel=2,1:1]\n[@2,2:1='<EOF>',<-1>,1:2]\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR Grammar for Declarator Parsing\nDESCRIPTION: This ANTLR grammar defines rules for parsing declarators, including array declarators, function declarators, pointer declarators, and simple identifiers. It also includes lexer rules for identifiers and integers, and a custom after-rule action to print the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing with Duplicate Actions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple arithmetic expressions. It includes a start rule 's', expression rules 'e' for handling operators, integers, and parentheses, and lexer rules for integers and whitespace. The grammar specifically tests the handling of duplicate empty actions in the expression rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleActions_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e ;\ne : a=e op=('*'|'/') b=e  {}{}\n  | INT {}{}\n  | '(' x=e ')' {}{}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar Definition with DFA Dump\nDESCRIPTION: Defines a grammar 'T' with parser rules for handling dollar and at-sign prefixed expressions. Includes lexer rules for identifiers, integers, and whitespace. Features a DFA dump after parsing using the @after attribute.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/CtxSensitiveDFA_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<DumpDFA()>}\n  : '$' a | '@' b ;\na : e ID ;\nb : e INT ID ;\ne : INT | ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Ambiguity Detection\nDESCRIPTION: Defines a grammar 'T' with ambiguous rules for parsing expressions. Includes initialization code for exact ambiguity detection and custom output handling. The grammar demonstrates parsing of IDs and '@' symbols with potential ambiguous paths.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/AmbiguityNoLoop.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nprog\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n   : expr expr {<writeln(\"\\\"alt 1\\\"\")>}\n   | expr\n   ;\nexpr: '@'\n   | ID '@'\n   | ID\n   ;\nID  : [a-z]+ ;\nWS  : [ \\r\\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Sequential Predicates Combined with Logical AND in ANTLR\nDESCRIPTION: Demonstrates how multiple predicates occurring in a sequence are joined with the logical AND operator. The parser will only predict the second alternative if both conditions are true.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR\nCODE:\n```\nstat: decl | {java5}? expr ;\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar with Action Tags\nDESCRIPTION: Defines a grammar named T with parser rule 'a' that matches sequences of identifiers and integers. Includes lexer rules for IDs, integers, and whitespace with custom output formatting.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AorBStar_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|INT{\n})* {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Simplified Enum Keyword Rule in ANTLR4 Lexer\nDESCRIPTION: This snippet shows a simpler and more efficient way to match the 'enum' keyword in ANTLR4 lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_12\n\nLANGUAGE: ANTLR4\nCODE:\n```\nENUM : 'enum' ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Ambiguity Detection\nDESCRIPTION: This snippet defines an ANTLR4 grammar 'T' with rules for parsing sequences of integers and identifiers. It includes ambiguous rules and semantic predicates for testing exact ambiguity detection.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/TwoUnpredicatedAltsAndOneOrthogonalAlt.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : {<LL_EXACT_AMBIG_DETECTION()>} a ';' a ';' a;\na : INT {<writeln(\"\\\"alt 1\\\"\")>}\n  | ID {<writeln(\"\\\"alt 2\\\"\")>} // must pick this one for ID since pred is false\n  | ID {<writeln(\"\\\"alt 3\\\"\")>}\n  | {<False()>}? ID {<writeln(\"\\\"alt 4\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions with dot notation, arithmetic operations, and identifiers. It includes parser rules, lexer rules, and an after-rule action to print the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Expressions_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF ; // must indicate EOF can follow\ne : e '.' ID\n  | e '.' 'this'\n  | '-' e\n  | e '*' e\n  | e ('+'|'-') e\n  | INT\n  | ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Main Grammar Definition with Import\nDESCRIPTION: Defines main grammar 'M' that imports grammar 'S' and includes a rule with an action to invoke foo()\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorAccessesDelegateMembers.txt#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\ngrammar M; // uses no rules from the import\nimport S;\ns : 'b' {<Invoke_foo()>} ; // gS is import pointer\nWS : (' '|'\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar with Semantic Predicate\nDESCRIPTION: Lexer grammar that defines rules for matching enum keywords and identifiers. Includes a semantic predicate that always evaluates to false on the ENUM token, causing it to fall through to the ID rule. Contains token definitions for identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/IDnotEnum.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nENUM : [a-z]+  { <False()> }? ;\nID : [a-z]+  ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Setting Up ANTLR4 Grammar File in Maven Project Structure\nDESCRIPTION: Commands to create the necessary directory structure for the ANTLR4 grammar file and copy it from the downloaded examples to the Maven project.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p src/main/antlr4/org/abcd/examples/ArrayInit\ncp ~/Downloads/code/starter/ArrayInit.g4 src/main/antlr4/org/abcd/examples/ArrayInit\n```\n\n----------------------------------------\n\nTITLE: Updating Go Module Dependencies\nDESCRIPTION: This shell command updates the go.mod file to ensure all required dependencies are properly listed and versioned for the project.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\ngo mod tidy\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Character Sets and Token Access Action\nDESCRIPTION: A simple ANTLR4 grammar named 'T' that defines a rule 'myset' with alternatives 'b' or 'c', and a rule 'a' that matches 'a' followed by 'myset' and 'd', with an action that outputs the stop token of 'myset'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionConsumption.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nmyset: ('b'|'c') ;\na: 'a' myset 'd' {<writeln(Append(\"\\\"\\\"\",\"$myset.stop\"))>} ; <! bit complicated because of the JavaScript target !>\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar Rules in ANTLR4\nDESCRIPTION: This snippet defines a lexer grammar named 'L' with rules for matching 'a' or 'ab', whitespace, and any other character. It includes a custom action for the 'I' rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyConfigs.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : ('a' | 'ab') {<Text():writeln()>} ;\nWS : (' '|'\\n') -> skip ;\nJ : .;\n```\n\n----------------------------------------\n\nTITLE: Right-Associative Expression Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar with right-associative operators including multiplication, addition, conditional (ternary), and assignment. The grammar includes rules for parsing expressions with proper operator precedence and right associativity.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_9.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e EOF; // must indicate EOF can follow or 'a\\<EOF>' won't match\ne :\\<assoc=right> e '*' e\n  |\\<assoc=right> e '+' e\n  |\\<assoc=right> e '?' e ':' e\n  |\\<assoc=right> e '=' e\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Action Template\nDESCRIPTION: An ANTLR4 grammar definition named 'T' that contains a rule 'a' which matches the pattern 'a' followed by either 'b' or 'c', followed by 'd'. It includes a custom action template that outputs information about the matched token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/ConjuringUpTokenFromSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' x=('b'|'c') {<Append(\"\\\"conjured=\\\"\",\"$x\"):writeln()>} 'd' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Main Grammar M in ANTLR4\nDESCRIPTION: This snippet defines the main grammar 'M' which imports slave grammars 'S' and 'T'. It includes rules for parsing 'b' and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesDelegates.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S, T;\nb : 'b'|'c' {<writeln(\"\\\"M.b\\\"\")>}|B|A;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar with Parameterized Rules and Predicates\nDESCRIPTION: Defines a parser grammar 'T' with context-dependent predicates and parameterized rules. The grammar includes rules for matching identifiers, handling integer parameters, and conditional alternatives based on parameter values.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/DependentPredNotInOuterCtxShouldBeIgnored.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : b[2] ';' |  b[2] '.' ; // decision in s drills down to ctx-dependent pred in a;\nb[<IntArg(\"i\")>] : a[<VarRef(\"i\")>] ;\na[<IntArg(\"i\")>]\n  : {<ValEquals(\"$i\",\"1\")>}? ID {<writeln(\"\\\"alt 1\\\"\")>}\n    | {<ValEquals(\"$i\",\"2\")>}? ID {<writeln(\"\\\"alt 2\\\"\")>}\n    ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic If-Else Statement Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing conditional statements including nested if-else structures. The grammar handles basic 'x' statements and conditional 'if y' statements with optional else clauses. Includes lexer rules for identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/IfIfElseNonGreedyBinding2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\nstart : statement+ ;\nstatement : 'x' | ifStatement;\nifStatement : 'if' 'y' statement (|'else' statement) {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Semantic Predicates and Actions\nDESCRIPTION: This ANTLR4 grammar defines a parser with conditional rules and embedded actions. It includes a main rule 's', a rule 'a' with semantic predicates, and lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/SimpleValidate.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : a ;\na : {<False()>}? ID  {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<True()>}?  INT {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expression Parsing and Evaluation\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing and evaluating arithmetic expressions. It includes operations like addition, multiplication, parentheses grouping, increment, and decrement. The grammar also specifies lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsAndLabels_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : q=e {<writeln(\"$e.v\")>};\ne returns [int v]\n  : a=e op='*' b=e {$v = $a.v * $b.v;}  # mult\n  | a=e '+' b=e {$v = $a.v + $b.v;}     # add\n  | INT{$v = $INT.int;}        # anInt\n  | '(' x=e ')' {$v = $x.v;}   # parens\n  | x=e '++'    {$v = $x.v+1;} # inc\n  | e '--'   # dec\n  | ID {$v = 3;}      # anID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR Exception Handling Implementation\nDESCRIPTION: Shows the basic try/catch/finally structure that ANTLR wraps around every rule for error handling and recovery.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nvoid r() throws RecognitionException {\n \ttry {\n \t\trule-body\n \t}\n \tcatch (RecognitionException re) {\n\t \t_errHandler.reportError(this, re);\n\t \t_errHandler.recover(this, re);\n \t}\n \tfinally {\n\t\texitRule();\n \t}\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Numeric Grammar with Output Action\nDESCRIPTION: Defines an ANTLR4 grammar named 'T' with rules for parsing numeric sequences. Includes fragment rules A and B for digit combinations, and a main rule 'a' with an embedded action to write the matched input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/SeqDoesNotBecomeSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : C {<InputText():writeln()>} ;\nfragment A : '1' | '2';\nfragment B : '3' '4';\nC : A | B;\n```\n\n----------------------------------------\n\nTITLE: Displaying ANTLR4 Help Message in Bash\nDESCRIPTION: Shows the default help output when ANTLR4 is invoked without arguments, displaying all available command line options.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4\nANTLR Parser Generator  Version 4.7.1\n -o ___              specify output directory where all output is generated\n -lib ___            specify location of grammars, tokens files\n -atn                generate rule augmented transition network diagrams\n -encoding ___       specify grammar file encoding; e.g., euc-jp\n -message-format ___ specify output style for messages in antlr, gnu, vs2005\n -long-messages      show exception details when available for errors and warnings\n -listener           generate parse tree listener (default)\n -no-listener        don't generate parse tree listener\n -visitor            generate parse tree visitor\n -no-visitor         don't generate parse tree visitor (default)\n -package ___        specify a package/namespace for the generated code\n -depend             generate file dependencies\n -D<option>=value    set/override a grammar-level option\n -Werror             treat warnings as errors\n -XdbgST             launch StringTemplate visualizer on generated code\n -XdbgSTWait         wait for STViz to close before continuing\n -Xforce-atn         use the ATN simulator for all predictions\n -Xlog               dump lots of logging info to antlr-timestamp.log\n -Xexact-output-dir  all output goes into -o dir regardless of paths/package\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Grammar with ANTLR4\nDESCRIPTION: This snippet defines a simple grammar using ANTLR4. It includes parser rules, lexer tokens, and parser initialization and finalization actions. The grammar recognizes a sequence of 'x' followed by 'y'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/ExtraToken.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : 'x' 'y'\n  ;\nZ : 'z'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Defining T Grammar with ANTLR4\nDESCRIPTION: This snippet defines the grammar for language T using ANTLR4. It includes parser rules, lexer rules, and semantic predicates. The grammar handles identifiers, integers, and whitespace, with specific conditions for parsing alternatives.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/RewindBeforePredEval.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : a a;\na : {<LTEquals(\"1\", \"\\\"x\\\"\")>}? ID INT {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<LTEquals(\"1\", \"\\\"y\\\"\")>}? ID INT {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Grammar Definition with Actions\nDESCRIPTION: Defines a lexer grammar 'L' with rules for matching character sequences and embedded actions for text output. Includes rules for handling whitespace and any single character.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ActionPlacement.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : ({<PlusText(\"stuff fail: \"):writeln()>} 'a'\n| {<PlusText(\"stuff0:\"):writeln()>}\n       'a' {<PlusText(\"stuff1: \"):writeln()>}\n       'b' {<PlusText(\"stuff2: \"):writeln()>})\n       {<Text():writeln()>} ;\nWS : (' '|'\\n') -> skip ;\nJ : .;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple ANTLR4 Grammar with Semantic Predicates\nDESCRIPTION: This grammar defines a parser that recognizes three tokens and uses semantic predicates to control rule selection. It demonstrates how the ATN processes the first match, the DFA handles the second match, and the INT rule handles the third match.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/Simple.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : a a a; // do 3x: once in ATN, next in DFA then INT in ATN\na : {<False()>}? ID {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<True()>}?  ID {<writeln(\"\\\"alt 2\\\"\")>}\n  | INT{<writeln(\"\\\"alt 3\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Unicode Character Parser Grammar in ANTLR4\nDESCRIPTION: ANTLR4 grammar that defines a parser rule 'a' and a lexer rule 'LETTERS' to match specific Unicode characters. The LETTERS rule matches zero or more occurrences of 'a', 'ä', '亜', or 'あ' followed by 'c'. The parser includes an action to write the matched input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeUnescapedBMPSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : LETTERS {<InputText():writeln()>} ;\n// These are actually not escaped -- Java passes the\n// raw unescaped Unicode values to the grammar compiler.\nLETTERS : ('a'|'ä'|'亜'|'あ')* 'c';\n```\n\n----------------------------------------\n\nTITLE: Simple ANTLR4 Grammar Definition\nDESCRIPTION: Defines a basic grammar with rules for parsing expressions that must end with an exclamation mark. Includes lexer rules for dot and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/NoViableAltAvoidance.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : e '!' ;\ne : 'a' 'b'\n  | 'a'\n  ;\nDOT : '.' ;\nWS : [ \\t\\r\\n]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Comments and Whitespace in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines two rules: CMT for matching single-line comments, and WS for matching whitespace characters. The CMT rule matches one or more occurrences of '//' followed by any characters up to a newline. The WS rule matches one or more spaces or tabs.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyPositiveClosure.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : ('//' .*? '\\n')+;\nWS : (' '|'\\t')+;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parsing Expressions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions starting with '$' or '@', followed by optional integers and identifiers. It includes lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/CtxSensitiveDFA_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<DumpDFA()>}\n  : '$' a | '@' b ;\na : e ID ;\nb : e INT ID ;\ne : INT | ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Rule Definition with Action\nDESCRIPTION: Defines a grammar named 'T' with a parser rule 'a' that matches pattern 'A' and includes an action to write the input text. Rule 'A' matches one or more 'b' characters followed by a 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/PlusLexerSingleElement.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : A {<InputText():writeln()>} ;\nA : 'b'+ 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Grammar T in ANTLR4\nDESCRIPTION: This snippet defines the slave grammar 'T' as a parser grammar. It declares a token 'A' and includes a rule for parsing 'b'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesDelegates.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar T;\ntokens { A }\nb : 'b' {<writeln(\"\\\"T.b\\\"\")>};\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Parser Rules and Actions\nDESCRIPTION: Grammar definition named 'T' with parser rules for matching 'yx' pattern. Includes @init action for building parse trees and @after action for printing the parse tree structure.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/RuleRef.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : b 'x'\n  ;\nb : 'y'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar Rules in ANTLR4\nDESCRIPTION: Grammar definition for an expression parser that handles arithmetic operations, variable assignments, and basic math expressions. Includes parser rules for program structure, statements, expressions, and lexer rules for tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/AmbigLR_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\nprog:   stat ;\nstat:   expr NEWLINE       # printExpr\n    |   ID '=' expr NEWLINE# assign\n    |   NEWLINE   # blank\n    ;\nexpr:   expr ('*'|'/') expr      # MulDiv\n    |   expr ('+'|'-') expr      # AddSub\n    |   INT    # int\n    |   ID     # id\n    |   '(' expr ')'    # parens\n    ;\n\nMUL :   '*' ; // assigns token name to '*' used above in grammar\nDIV :   '/' ;\nADD :   '+' ;\nSUB :   '-' ;\nID  :   [a-zA-Z]+ ;      // match identifiers\nINT :   [0-9]+ ;// match integers\nNEWLINE:'\n'? '\n' ;     // return newlines to parser (is end-statement signal)\nWS  :   [ \\t]+ -> skip ; // toss out whitespace\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Parser and Lexer Rules\nDESCRIPTION: This ANTLR4 grammar defines parser rules for parsing expressions with alternatives, and lexer rules for identifying tokens. It includes actions for writing output based on the parsed alternatives.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/UnpredicatedPathsInAlt.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : a {<writeln(\"\\\"alt 1\\\"\")>}\n  | b {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\na : {<False()>}? ID INT\n  | ID INT\n  ;\nb : ID ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Rule Reference in ANTLR4 Grammar\nDESCRIPTION: This snippet demonstrates how to define a grammar rule with an optional component in ANTLR4. The rule 'decl' includes an optional initialization clause with an EQUALS token and an expr rule reference.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/actions-preds.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ndecl : 'var' ID (EQUALS expr)? ;\n```\n\n----------------------------------------\n\nTITLE: Simple ANTLR4 Grammar Definition\nDESCRIPTION: Defines a basic ANTLR4 grammar named 'T' with a parser rule 'a' and lexer rule 'A'. Includes an embedded action to write the input text. The grammar matches an optional 'b' followed by a required 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/OptionalLexerSingleElement.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<InputText():writeln()>} ;\nA : 'b'? 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Options Syntax in ANTLR Grammars\nDESCRIPTION: The standard syntax for specifying options in ANTLR grammars. Options are defined within curly braces with name-value pairs separated by semicolons.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_0\n\nLANGUAGE: g4\nCODE:\n```\noptions { name1=value1; ... nameN=valueN; } // ANTLR not target language syntax\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Issue2301 Regression Test\nDESCRIPTION: An ANTLR4 grammar definition that includes token declarations, parser rules for expressions, and rule patterns to test issue #2301. The grammar handles expressions with ID terminals that can be followed by optional constants or by 'AT X' or 'AT Y' patterns.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/OrderingPredicates.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Issue2301;\n\nSPACES: [ \\t\\r\\n]+ -> skip;\n\nAT: 'AT';\nX : 'X';\nY : 'Y';\n\nID: [A-Z]+;\n\nconstant\n: 'DUMMY'\n;\n\nexpr\n: ID constant?\n| expr AT X\n| expr AT Y\n;\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Parser Grammar in ANTLR4\nDESCRIPTION: ANTLR4 grammar definition that specifies rules for parsing if-then-else statements and return statements. Includes initialization for exact ambiguity detection and DFA dumping. Contains lexer rules for identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {<LL_EXACT_AMBIG_DETECTION()>}\n@after {<DumpDFA()>}\n   : '{' stat* '}' ;\nstat: 'if' ID 'then' stat ('else' ID)?\n       | 'return'\n       ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Running the Go JSON Parser\nDESCRIPTION: This command runs the Go program that uses the ANTLR4-generated JSON parser. It takes an input file as a command-line argument to parse JSON content.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ngo run test.go input\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Embedded Template Action\nDESCRIPTION: This grammar defines a simple language for parsing control flow statements (break, continue, return). It includes an embedded action that outputs the parsed text using the template mechanism.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Keyword_6.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nprogram : reset*{<writeln(\"$text\")>} EOF ;\nreset: 'break;' | 'continue;' | 'return;' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Main Grammar M in ANTLR4\nDESCRIPTION: This snippet defines the main grammar M, which imports rules from grammar S. It includes lexer rules for basic types, identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesLookaheadInDelegate.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\nprog : decl ;\ntype_ : 'int' | 'float' ;\nID  : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Start Rule Examples in ANTLR\nDESCRIPTION: Examples demonstrating different start rule patterns and EOF handling in ANTLR grammars.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_14\n\nLANGUAGE: java\nCODE:\n```\ns : ID\n  | ID '+'\n  | ID '+' INT\n  ;\n```\n\nLANGUAGE: java\nCODE:\n```\nconfig : element*; // can \"match\" even with invalid input.\n```\n\nLANGUAGE: java\nCODE:\n```\nfile : element* EOF; // don't stop early. must match all input\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Rules in ANTLR4\nDESCRIPTION: Defines two lexer rules: 'I' matches any character sequence except specific characters, and 'WS' handles whitespace. The 'I' rule writes output when matched. Includes test input 'xaf' and corresponding token output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetNot.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : ~[ab \\n] ~[ \\ncd]* {<writeln(\"\\\"I\\\"\")>} ;\nWS : [ \\n\\\\u000D]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Integer Lexer Grammar Definition in ANTLR4\nDESCRIPTION: Defines a lexer grammar with rules for matching negative numbers (A), positive integers (I), and whitespace (WS). The grammar handles basic integer parsing with optional negative signs.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RefToRuleDoesNotSetTokenNorEmitAnother.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : '-' I ;\nI : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Parser\nDESCRIPTION: This ANTLR4 grammar defines a parser that recognizes 'x' or 'y'. It includes actions to build parse trees and output the result as a string tree. The grammar consists of two rules: 's' and 'a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/TwoAlts.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : 'x' | 'y'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR Grammar for Parsing Emoticon Text\nDESCRIPTION: This ANTLR grammar defines a rule 'a' that matches a pattern starting with 'a', followed by one or more characters that are not 'b' (including emoticons), and ending with 'c'. The matched text is then printed using a custom action.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeNegatedBMPSetIncludesSMPCodePoints.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : LETTERS {<InputText():writeln()>} ;\nLETTERS : 'a' ~('b')+ 'c';\n```\n\n----------------------------------------\n\nTITLE: Defining Main Grammar 'M' in ANTLR4\nDESCRIPTION: This snippet defines the main ANTLR4 grammar 'M' which imports grammar 'S'. It includes a rule for 's', defines token 'B', and specifies whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorInvokesDelegateRule.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\ns : a ;\nB : 'b' ; // defines B from inherited token space\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar Rules in ANTLR4\nDESCRIPTION: Comprehensive grammar definition for parsing expressions with support for function calls, mathematical operations, logical operations, arrays, and various data types. Includes lexer rules for identifiers, numbers, dates, strings, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/WhitespaceInfluence_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\nprog : expression EOF;\nexpression\n    : ID '(' expression (',' expression)* ')'      # doFunction\n    | '(' expression ')'# doParenthesis\n    | '!' expression    # doNot\n    | '-' expression    # doNegate\n    | '+' expression    # doPositiv\n    | expression '^' expression  # doPower\n    | expression '*' expression  # doMultipy\n    | expression '/' expression  # doDivide\n    | expression '%' expression  # doModulo\n    | expression '-' expression  # doMinus\n    | expression '+' expression  # doPlus\n    | expression '=' expression  # doEqual\n    | expression '!=' expression # doNotEqual\n    | expression '>' expression  # doGreather\n    | expression '>=' expression # doGreatherEqual\n    | expression '\\<' expression  # doLesser\n    | expression '\\<=' expression # doLesserEqual\n    | expression K_IN '(' expression (',' expression)* ')'  # doIn\n    | expression ( '&' | K_AND) expression# doAnd\n    | expression ( '|' | K_OR) expression # doOr\n    | '[' expression (',' expression)* ']'# newArray\n    | K_TRUE   # newTrueBoolean\n    | K_FALSE  # newFalseBoolean\n    | NUMBER   # newNumber\n    | DATE     # newDateTime\n    | ID       # newIdentifier\n    | SQ_STRING# newString\n    | K_NULL   # newNull\n    ;\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar Rules in ANTLR4\nDESCRIPTION: This snippet defines the main grammar rules for parsing expressions. It includes rules for function calls, arithmetic operations, logical operations, comparisons, and various literal types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/WhitespaceInfluence_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar Expr;\nprog : expression EOF;\nexpression\n    : ID '(' expression (',' expression)* ')'      # doFunction\n    | '(' expression ')'# doParenthesis\n    | '!' expression    # doNot\n    | '-' expression    # doNegate\n    | '+' expression    # doPositiv\n    | expression '^' expression  # doPower\n    | expression '*' expression  # doMultipy\n    | expression '/' expression  # doDivide\n    | expression '%' expression  # doModulo\n    | expression '-' expression  # doMinus\n    | expression '+' expression  # doPlus\n    | expression '=' expression  # doEqual\n    | expression '!=' expression # doNotEqual\n    | expression '>' expression  # doGreather\n    | expression '>=' expression # doGreatherEqual\n    | expression '\\<' expression  # doLesser\n    | expression '\\<=' expression # doLesserEqual\n    | expression K_IN '(' expression (',' expression)* ')'  # doIn\n    | expression ( '&' | K_AND) expression# doAnd\n    | expression ( '|' | K_OR) expression # doOr\n    | '[' expression (',' expression)* ']'# newArray\n    | K_TRUE   # newTrueBoolean\n    | K_FALSE  # newFalseBoolean\n    | NUMBER   # newNumber\n    | DATE     # newDateTime\n    | ID       # newIdentifier\n    | SQ_STRING# newString\n    | K_NULL   # newNull\n    ;\n```\n\n----------------------------------------\n\nTITLE: Defining Basic ANTLR4 Grammar with Actions\nDESCRIPTION: Defines a simple ANTLR4 grammar with parser rules for handling identifiers. Includes an @after action to print the parse tree, lexer rules for IDs and whitespace, and demonstrates left recursion handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Simple_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : a ;\na : a ID\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining a Grammar in ANTLR4 for Python3 Target\nDESCRIPTION: An example of an ANTLR4 grammar file (Expr.g4) that defines a simple expression grammar with operations like addition, subtraction, multiplication, division, and parenthesized expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar Expr;\nstart_ : expr (';' expr)* EOF;\nexpr : atom | ('+' | '-') expr | expr '**' expr | expr ('*' | '/') expr | expr ('+' | '-') expr | '(' expr ')' | atom ;\natom : INT ;\nINT : [0-9]+ ;\nWS : [ \\t\\n\\r]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple ANTLR4 Grammar with Required Token Sequence\nDESCRIPTION: Defines an ANTLR4 grammar named 'T' with a single rule 'a' that expects a token sequence of 'a' followed by either 'b' or 'c', and then 'd'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleSetInsertion.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' ('b'|'c') 'd' ;\n```\n\n----------------------------------------\n\nTITLE: Generating Swift Lexer/Parser with Xcode Integration Options\nDESCRIPTION: ANTLR4 command with additional options for better Xcode integration, including GNU message format for error parsing and output directory specification.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nantlr4 -Dlanguage=Swift -message-format gnu -o Autogen MyGrammar.g4\n```\n\n----------------------------------------\n\nTITLE: Simple ANTLR Grammar with Negation Pattern\nDESCRIPTION: Defines a grammar rule that matches any character except 'x' followed by 'z' and outputs the matched text. The rule demonstrates the use of the negation operator (~) and embedded action code.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/ParserNotTokenWithLabel.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : t=~'x' 'z' {<writeln(\"$t.text\")>} ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar with Escaped Characters in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines two rules: 'A' for matching quoted and escaped characters, and 'WS' for skipping whitespace. The 'A' rule includes a Java action to print the matched token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithQuote2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : [\"\\\\ab]+ {<writeln(\"\\\"A\\\"\")>} ;\nWS : [ \\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Go Generate Configuration\nDESCRIPTION: Example Go file for configuring go generate command for ANTLR4 code generation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_3\n\nLANGUAGE: golang\nCODE:\n```\npackage parser\n\n//go:generate ./generate.sh\n```\n\n----------------------------------------\n\nTITLE: Context-Dependent Predicates with Local Variables in ANTLR\nDESCRIPTION: Shows a predicate that depends on a local variable of the surrounding rule, which can only be evaluated within that specific rule context.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_7\n\nLANGUAGE: ANTLR\nCODE:\n```\nprog: vec5\n \t| ...\n \t;\nvec5\nlocals [int i=1]\n \t: ( {$i<=5}? INT {$i++;} )* // match 5 INTs\n \t;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 4.7.1 Package Option with Exact Output Directory\nDESCRIPTION: Shows how package option works with -Xexact-output-dir, maintaining output location while adding package declarations to generated files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n$ a4.7.1 -Xexact-output-dir -package pkg -o /tmp/build src/pkg/A.g4\n$ tree /tmp/build\n/tmp/build\n├── A.tokens\n├── ABaseListener.java\n├── ALexer.java\n├── ALexer.tokens\n├── AListener.java\n└── AParser.java\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Single Token Parser\nDESCRIPTION: This ANTLR4 grammar defines a parser that recognizes a single token 'A' and performs a write action. The token 'A' matches any character except 'b' or 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/NotCharSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<writeln(\"$A.text\")>} ;\nA : ~('b'|'c') ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for T Language\nDESCRIPTION: This snippet defines the complete grammar for the T language, including lexer and parser rules. It uses ANTLR4 syntax and includes special annotations for listener import and rule getter generation. The grammar defines rules for simple expressions with integers, identifiers, and basic arithmetic operators.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Listeners/RuleGetters_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\n<ImportListener(\"T\")>\n<RuleGetterListener(\"T\")>\n\ns\n@after {\n<ContextMember(\"$ctx\", \"r\"):ToStringTree():writeln()>\n<ContextMember(\"$ctx\", \"r\"):WalkListener()>\n}\n  : r=a ;\na : b b        // forces list\n  | b      // a list still\n  ;\nb : ID | INT;\nMULT: '*' ;\nADD : '+' ;\nINT : [0-9]+ ;\nID  : [a-z]+ ;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Nested Action Lexer\nDESCRIPTION: This snippet provides a sample input string to test the lexer grammar. It contains nested curly braces, which should be recognized by the ACTION rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/EnforcedGreedyNestedBraces_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n{ { }\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Grammar Definition for Slash Patterns\nDESCRIPTION: Defines lexer rules for recognizing backslash, forward slash, and their combinations. Includes rules for Backslash, Slash, Vee (backslash followed by slash), and Wedge (slash followed by backslash). Also includes whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/Slashes.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nBackslash : '\\\\\\\\';\nSlash : '/';\nVee : '\\\\\\\\/';\\nWedge : '/\\\\\\\\';\nWS : [ \\t] -> skip;\n```\n\n----------------------------------------\n\nTITLE: Main Grammar M Definition\nDESCRIPTION: Main ANTLR grammar 'M' that imports grammars S and T, defines basic lexer rules for tokens A, B, C and whitespace\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatesSeeSameTokenType.txt#2025-04-21_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\ngrammar M;\nimport S,T;\ns : x y ; // matches AA, which should be 'aa'\nB : 'b' ; // another order: B, A, C\nA : 'a' ;\nC : 'c' ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Predicates and Context-Sensitive Parsing\nDESCRIPTION: This grammar 'T' defines rules for parsing with predicates and context-sensitive behavior. It includes a parser member initialization, parameterized rules with predicates, and basic lexer rules for identifiers, integers, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/PredicateDependentOnArg2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {<InitIntMember(\"i\",\"0\")>}\ns : a[2] a[1];\na[int i]\n  : {<ValEquals(\"$i\",\"1\")>}? ID\n  | {<ValEquals(\"$i\",\"2\")>}? ID\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Position Adjusting Lexer Grammar Definition\nDESCRIPTION: Defines a lexer grammar with rules for handling tokens, labels, and assignments. Includes special handling for whitespace and position-sensitive token matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/PositionAdjustingLexer.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar PositionAdjustingLexer;\n\n@definitions {\n<PositionAdjustingLexerDef()>\n}\n\n@members {\n<PositionAdjustingLexer()>\n}\n\nASSIGN : '=' ;\nPLUS_ASSIGN : '+=' ;\nLCURLY:    '{';\n\n// 'tokens' followed by '{'\nTOKENS : 'tokens' IGNORED '{';\n\n// IDENTIFIER followed by '+=' or '='\nLABEL\n   :   IDENTIFIER IGNORED '+'? '='\n   ;\n\nIDENTIFIER\n   :   [a-zA-Z_] [a-zA-Z0-9_]*\n   ;\n\nfragment\nIGNORED\n   :   [ \\t\\r\\n]*\n   ;\n\nNEWLINE\n   :   [\\r\\n]+ -> skip\n   ;\n\nWS\n   :   [ \\t]+ -> skip\n   ;\n```\n\n----------------------------------------\n\nTITLE: Using Custom Listener with ANTLR4 Parser in C#\nDESCRIPTION: Shows how to integrate a custom listener with the parser by creating a parse tree walker and executing the walk operation with the custom listener.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/csharp-target.md#2025-04-21_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n...\nIParseTree tree = parser.StartRule() - only repeated here for reference\nKeyPrinter printer = new KeyPrinter();\nParseTreeWalker.Default.Walk(printer, tree);\n```\n\n----------------------------------------\n\nTITLE: Simple ID Token Grammar Definition in ANTLR4\nDESCRIPTION: Defines a basic ANTLR4 grammar that expects one or more ID tokens composed of lowercase letters. The grammar validates the parser's behavior when handling empty input against required tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/InvalidEmptyInput.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : ID+;\nID : [a-z]+;\n```\n\n----------------------------------------\n\nTITLE: Unicode Lexer Grammar with Whitespace Fragments\nDESCRIPTION: Slave grammar defining Unicode whitespace character class fragments used by the main grammar for whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/ImportLexerWithOnlyFragmentRules.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar Unicode;\n\nfragment\nUNICODE_CLASS_Zs    : ' ' | ' ' | ' ' | '᠎'\n    | ' '..' '\n    | ' ' | ' ' | '　'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar for Dash and Bracket Characters\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for matching dash and bracket characters (DASHBRACK) and whitespace (WS). The DASHBRACK rule includes a custom action to write out the token name.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithEscapedChar.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nDASHBRACK : [\\\\-\\]]+ {<writeln(\"\\\"DASHBRACK\\\"\")>} ;\nWS : [ \\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR Target Configuration\nDESCRIPTION: Example of generating C++ files from an ANTLR grammar file using the FindANTLR module.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/README.md#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(ANTLR REQUIRED)\nantlr_target(Sample T.g4)\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar Rules in ANTLR4\nDESCRIPTION: This snippet defines a lexer grammar named 'L' with two rules: 'A' for matching lowercase letters and 'WS' for skipping whitespace. The 'A' rule includes a custom action to write output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithQuote1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : [\"a-z]+ {<writeln(\"\\\"A\\\"\")>} ;\nWS : [ \\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Generation Shell Script\nDESCRIPTION: Shell script for generating Go code from ANTLR4 grammar files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n#!/bin/sh\n\nalias antlr4='java -Xmx500M -cp \"./antlr-4.13.2-complete.jar:$CLASSPATH\" org.antlr.v4.Tool'\nantlr4 -Dlanguage=Go -no-visitor -package parsing *.g4\n```\n\n----------------------------------------\n\nTITLE: Defining Comment and Whitespace Lexer Rules in ANTLR4\nDESCRIPTION: Defines two lexer rules: CMT for handling consecutive single-line comments, and WS for handling whitespace characters (spaces and tabs). The CMT rule uses non-greedy matching for comment content.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyPositiveClosure.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : ('//' .*? '\\n')+?;\nWS : (' '|'\\t')+;\n```\n\n----------------------------------------\n\nTITLE: Using ANTLR4 Dependency Generation Option in Bash\nDESCRIPTION: Shows how to use the -depend option to generate a list of file dependencies instead of generating a parser, displaying what each grammar depends on and what it generates.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -depend T.g\t\nT.g: A.tokens\nTParser.java : T.g\nT.tokens : T.g\nTLexer.java : T.g\nTListener.java : T.g\nTBaseListener.java : T.g\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parser T\nDESCRIPTION: This snippet defines an ANTLR4 grammar for a parser named T. It includes rules for matching 'a' or any character except 'a' and 'c', with a custom action to print the matched text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/NotCharSetWithRuleRef3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<writeln(\"$A.text\")>} ;\nA : ('a'|B) ;  // this doesn't collapse to set but works\nfragment\nB : ~('a'|'c') ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Nested 'a' Rules with Identifiers\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing nested 'a' structures with identifiers. It includes a start rule 's' that triggers a tree output, nested 'a' rules, and lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Simple_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : a ;\na : a ID\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Expected Output for ANTLR4 Grammar Parsing\nDESCRIPTION: This snippet shows the expected output from parsing the input string 'a*b' using the defined grammar. It displays the parse tree in a string representation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_1.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[output]\n\"\"\"(s (expr (expr a) * (expr b)) <EOF>)\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition for IF-ELSE Statement Parsing\nDESCRIPTION: Defines a simple grammar that handles IF-ELSE statements with optional ELSE clauses. The grammar includes rules for basic statements, IF statements, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Optional_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstat : ifstat | 'x';\nifstat : 'if' stat ('else' stat)?;\nWS : [ \\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Parser\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with rules for parsing 'x' or 'y'. It includes initialization for building parse trees and outputting the result as a string tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/NoViableAlt.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : 'x' | 'y'\n  ;\nZ : 'z'\n  ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Grammar Definition\nDESCRIPTION: Defines a lexer grammar with rules for matching single-line comments (CMT) that can appear consecutively and whitespace characters (WS). The CMT rule matches '//' followed by any characters up to a newline, with optional recursive matching for consecutive comments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyOptional.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : '//' .*? '\\n' CMT?;\nWS : (' '|'\\t')+;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parsing Lowercase Letter Sequences\nDESCRIPTION: This ANTLR4 grammar defines a parser that recognizes sequences of lowercase letters. It includes a parser rule 'a' that matches zero or more identifiers, lexer rules for identifiers and whitespace, and a custom action to print the matched text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AStar_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ID* {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Arithmetic Expressions\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple arithmetic expressions. It includes support for integers, unary minus, addition, and subtraction operations. The grammar also specifies a custom after-rule action to print the parse tree using the ToStringTree function.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/PrefixAndOtherAlt_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF ;\nexpr : literal\n     | op expr\n     | expr op expr\n     ;\nliteral : '-'? Integer ;\nop : '+' | '-' ;\nInteger : [0-9]+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic CMake Configuration and Version Requirements\nDESCRIPTION: Sets up the basic CMake project configuration including minimum version requirements and build type settings.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required (VERSION 3.15)\nset(CMAKE_MACOSX_RPATH OFF)\nenable_testing()\n```\n\n----------------------------------------\n\nTITLE: Expected Output from ANTLR4 Lexer\nDESCRIPTION: This snippet shows the expected output after processing the input through the defined lexer grammar. It demonstrates how the lexer tokenizes the input, identifying the comments as a single token and recognizing the end of file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyPositiveClosure.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\n[@0,0:13='//blah\\n//blah\\n',<1>,1:0]\n[@1,14:13='<EOF>',<-1>,3:0]\n```\n\n----------------------------------------\n\nTITLE: Main Grammar Definition (Grammar M)\nDESCRIPTION: Primary grammar file that imports a slave grammar S and defines basic lexer rules for character 'b' and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/ImportedRuleWithAction.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\ns : a;\nB : 'b';\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Action Code for Regression Testing\nDESCRIPTION: A simple ANTLR4 grammar definition with a rule 'a' that matches sequences of identifiers and numbers, followed by an optional number token. The rule contains an embedded action to write the matched text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/ReferenceToATN_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|ATN)* ATN? {<writeln(\"$text\")>} ;\nID : 'a'..'z'+ ;\nATN : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Declarator Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing declarators with array and function notation. It includes a start rule 's', declarator rules, and lexer rules for identifiers and integers. The grammar also demonstrates the use of the @after action to print the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Declarations_8.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : declarator EOF ; // must indicate EOF can follow\ndeclarator\n        : declarator '[' e ']'\n        | declarator '[' ']'\n        | declarator '(' ')'\n        | '*' declarator // binds less tight than suffixes\n        | '(' declarator ')'\n        | ID\n        ;\ne : INT ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Specifying ANTLR4 Python3 Runtime Dependencies\nDESCRIPTION: A requirements.txt file that specifies the ANTLR4 Python3 runtime dependency with an exact version to ensure compatibility with the ANTLR4 tool used for code generation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nantlr4-python3-runtime==4.13.0\n```\n\n----------------------------------------\n\nTITLE: Main Grammar Definition with Unicode Import\nDESCRIPTION: Defines main Test grammar that imports Unicode lexer grammar and specifies basic program structure with whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/ImportLexerWithOnlyFragmentRules.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar Test;\nimport Unicode;\n\nprogram : 'test' 'test';\n\nWS : (UNICODE_CLASS_Zs)+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Enabling ANTLR4 Logging with Bash\nDESCRIPTION: Shows how to use the -Xlog option to create a detailed log file with information about how ANTLR processes your grammar, useful for debugging and understanding rule translations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Xlog T.g4 \t\nwrote ./antlr-2012-09-06-17.56.19.log\n```\n\n----------------------------------------\n\nTITLE: Creating ANTLR4 C++ Runtime Libraries in CMake\nDESCRIPTION: Adds library targets for the ANTLR4 C++ runtime, creating shared and/or static libraries based on the build options. It also sets up include directories for the libraries.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif (ANTLR_BUILD_SHARED)\n  add_library(antlr4_shared SHARED ${libantlrcpp_SRC})\n  target_include_directories(antlr4_shared PUBLIC \n    \"$<BUILD_INTERFACE:${libantlrcpp_INCLUDE_DIRS}>\" \n    \"$<INSTALL_INTERFACE:${libantlrcpp_INCLUDE_INSTALL_DIR}>\")\nendif()\nif (ANTLR_BUILD_STATIC)\n  add_library(antlr4_static STATIC ${libantlrcpp_SRC})\n  target_include_directories(antlr4_static PUBLIC \n    \"$<BUILD_INTERFACE:${libantlrcpp_INCLUDE_DIRS}>\" \n    \"$<INSTALL_INTERFACE:${libantlrcpp_INCLUDE_INSTALL_DIR}>\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar Rule for Parsing 'a' or 'b' Sequences Followed by 'c'\nDESCRIPTION: This ANTLR4 grammar snippet defines a rule 'a' that matches one or more occurrences of 'a' or 'b', followed by 'c'. It includes a semantic action to write the input text using the <InputText():writeln()> function.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/PlusSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ('a'|'b')+ 'c' {<InputText():writeln()>} ;\n```\n\n----------------------------------------\n\nTITLE: Unicode Range Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar rule that matches zero or more letters (including emoji Unicode ranges) followed by 'd'. Uses double-backslash escaping for Unicode character ranges and includes a writeln action.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeEscapedSMPRangeSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : LETTERS* 'd' {<InputText():writeln()>} ;\n// Note the double-backslash to avoid Java passing\n// unescaped values as part of the grammar.\nLETTERS : ('a'|'\\\\u{1F600}'..'\\\\u{1F943}');\n```\n\n----------------------------------------\n\nTITLE: Lexical Analysis Output\nDESCRIPTION: This snippet displays the output of lexical analysis, showing recognized tokens and their positions in the input stream.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeLexers/LexerDelegatorInvokesDelegateRule.txt#2025-04-21_snippet_3\n\nLANGUAGE: Plain Text\nCODE:\n```\nS.A\n[@0,0:0='a',<3>,1:0]\n[@1,1:1='b',<1>,1:1]\n[@2,2:2='c',<4>,1:2]\n[@3,3:2='<EOF>',<-1>,1:3]\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for T Language\nDESCRIPTION: This snippet defines the grammar rules for the T language using ANTLR4 syntax. It includes rules for members, body, and file structure, as well as a token definition for 'b'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/ExtraneousInput.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nmember : 'a';\nbody : member*;\nfile : body EOF;\nB : 'b';\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Single Non-Newline Character Parsing\nDESCRIPTION: This ANTLR4 grammar defines a parser that accepts any single character except a newline. It includes a parser rule 'parse' and a lexer rule for newline characters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/ComplementSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nparse : ~NEW_LINE;\nNEW_LINE: '\\\\r'? '\\\\n';\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar with Boolean Parser Member and Custom Rules\nDESCRIPTION: Defines a grammar T with a parser rule 'primary' that handles identifiers and conditionally matches 'enum' keyword based on a boolean member flag. Includes lexer rules for ID and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/PredTestedEvenWhenUnAmbig_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {<InitBooleanMember(\"enumKeyword\",True())>}\nprimary\n    :   ID {<AppendStr(\"\\\"ID \\\"\", \"$ID.text\"):writeln()>}\n    |   {<GetMember(\"enumKeyword\"):Not()>}? 'enum' {<writeln(\"\\\"enum\\\"\")>}\n    ;\nID : [a-z]+ ;\nWS : [ \\t\\n\\r]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for 'enum' Keyword in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for recognizing the 'enum' keyword, identifiers, and whitespace. It uses a semantic predicate to ensure 'enum' is treated as a special token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/EnumNotID.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nENUM : [a-z]+  { <TextEquals(\"enum\")> }? ;\nID : [a-z]+  ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Setting ANTLR4 C++ Runtime Library Properties in CMake\nDESCRIPTION: Configures properties for the ANTLR4 C++ runtime libraries, including version information, output names, and compile flags. It handles both shared and static library targets.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif (TARGET antlr4_shared)\n  set_target_properties(antlr4_shared\n                        PROPERTIES VERSION   ${ANTLR_VERSION}\n                                   SOVERSION ${ANTLR_VERSION}\n                                   OUTPUT_NAME antlr4-runtime\n                                   COMPILE_FLAGS \"${disabled_compile_warnings} ${extra_share_compile_flags}\")\nendif()\n\nif (TARGET antlr4_static)\n  set_target_properties(antlr4_static\n                        PROPERTIES VERSION   ${ANTLR_VERSION}\n                                   SOVERSION ${ANTLR_VERSION}\n                                   OUTPUT_NAME \"antlr4-runtime${static_lib_suffix}\"\n                                   COMPILE_PDB_NAME \"antlr4-runtime${static_lib_suffix}\"\n                                   COMPILE_FLAGS \"${disabled_compile_warnings} ${extra_static_compile_flags}\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Output for Comment Input\nDESCRIPTION: This snippet displays the output generated by the ANTLR4 lexer when processing the sample input. It shows one token for the two comments combined, followed by the end-of-file token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyClosure.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:13='//blah\\n//blah\\n',<1>,1:0]\n[@1,14:13='<EOF>',<-1>,3:0]\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Lexer Grammar in ANTLR4\nDESCRIPTION: This snippet defines the slave lexer grammar 'S' with rules for tokens 'A' and 'C'. It includes an embedded action for token 'A'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeLexers/LexerDelegatorInvokesDelegateRule.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar S;\nA : 'a' {<writeln(\"\\\"S.A\\\"\")>};\nC : 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for T Language\nDESCRIPTION: This snippet defines the grammar rules and lexer tokens for the T language. It includes parsing rules for statements and expressions, as well as token definitions for integers, identifiers, and operators.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Listeners/TokenGetters_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\n<ImportListener(\"T\")>\n<TokenGetterListener(\"T\")>\n\ns\n@after {\n<ContextMember(\"$ctx\", \"r\"):ToStringTree():writeln()>\n<ContextMember(\"$ctx\", \"r\"):WalkListener()>\n}\n  : r=a ;\na : INT INT\n  | ID\n  ;\nMULT: '*' ;\nADD : '+' ;\nINT : [0-9]+ ;\nID  : [a-z]+ ;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer with Indentation\nDESCRIPTION: Example input text for testing the lexer grammar. Contains identifiers and indentation at different positions to demonstrate the lexer's ability to detect and handle indentation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/Indent.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nabc\n  def  \n\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Module Project\nDESCRIPTION: Commands for creating a new Go module project for use with ANTLR4.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd mymodproject\n$ go mod init mymodproject\n```\n\n----------------------------------------\n\nTITLE: Left-Recursive Grammar Definition in ANTLR4\nDESCRIPTION: Defines a simple ANTLR4 grammar with a left-recursive rule 'a' that can match sequences of identifiers. Includes token definitions for IDs and whitespace, with a tree printing action after rule matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/DirectCallToLeftRecursiveRule_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na @after {<ToStringTree(\"$ctx\"):writeln()>} : a ID\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Quote Lexer\nDESCRIPTION: Provides a test input consisting of a single double quote character to demonstrate lexer functionality.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/QuoteTranslation.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n\"\n```\n\n----------------------------------------\n\nTITLE: Creating ANTLR4 Demo Executable in CMake\nDESCRIPTION: Adds the ANTLR4 demo executable target, sets up dependencies, and links it with the ANTLR4 static library. It also sets MSVC-specific compile options if applicable.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nadd_executable(antlr4-demo\n  ${antlr4-demo_SRC}\n  )\n\nif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n  target_compile_options(antlr4-demo PRIVATE \"/MT$<$<CONFIG:Debug>:d>\")\nendif()\n\nadd_dependencies(antlr4-demo GenerateParser)\n\ntarget_link_libraries(antlr4-demo antlr4_static)\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parser T\nDESCRIPTION: This snippet defines an ANTLR4 grammar named T with a parser rule 'a' and a lexer rule 'A'. The parser rule includes an embedded action to write the input text. The lexer rule matches an optional 'a' or 'b' followed by a 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/LexerOptionalSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<InputText():writeln()>} ;\nA : ('a'|'b')? 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple ANTLR Grammar for If-Statement Testing\nDESCRIPTION: A basic ANTLR grammar named 'T' that defines rules for statements including if-statements with optional else clauses. The grammar is designed to test a specific parsing scenario related to issue #41.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Optional_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\nstat : ifstat | 'x';\nifstat : 'if' stat ('else' stat)?;\nWS : [ \\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Specifying ANTLR4 Grammar Start Rule\nDESCRIPTION: This snippet specifies the start rule for the ANTLR4 grammar, which is 'a' in this case.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LL2.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Parser\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with rules for parsing a sequence of three 'a' elements. It includes semantic predicates, lexer rules for identifiers and integers, and output actions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/SimpleValidate2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns : a a a;\na : {<False()>}? ID  {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<True()>}?  INT {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR Grammar Rule with Negation Pattern\nDESCRIPTION: Defines a grammar rule 'a' that matches any character except 'x' or 'y' followed by 'z'. The matched character is stored in variable 't' and its text is written to output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/ParserNotSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : t=~('x'|'y') 'z' {<writeln(\"$t.text\")>} ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for T Language\nDESCRIPTION: This snippet defines the grammar rules for the T language, including parser rules (r, a, b) and lexer rules (X, Y, WS). It also specifies a custom output format for the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/PredictionMode_LL.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nr\n   : (a b | a) EOF {<ToStringTree(\"$ctx\"):writeln()>}\n   ;\na\n   : X Y?\n   ;\nb\n   : Y\n   ;\nX: 'X';\nY: 'Y';\nWS  : [ \\r\\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Basic ANTLR4 Grammar Rules\nDESCRIPTION: Defines a grammar named 'T' with parser rules for matching sequences of X and Y tokens. Includes main rule 'r', supporting rules 'a' and 'b', and lexer rules for tokens X, Y, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/PredictionMode_SLL.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nr\n   : (a b | a) EOF {<writeln(\"$text\")>}\n   ;\na\n   : X Y?\n   ;\nb\n   : Y\n   ;\nX: 'X';\nY: 'Y';\nWS  : [ \\r\\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Comment Lexer\nDESCRIPTION: Example input text containing two consecutive single-line comments to test the lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyOptional.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n//blah\n//blah\n```\n\n----------------------------------------\n\nTITLE: Gathering ANTLR4 C++ Runtime Source Files in CMake\nDESCRIPTION: Uses file(GLOB) to collect all the source files for the ANTLR4 C++ runtime library from various subdirectories.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nfile(GLOB libantlrcpp_SRC\n  \"${PROJECT_SOURCE_DIR}/runtime/src/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/atn/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/dfa/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/internal/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/misc/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/support/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/tree/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/tree/pattern/*.cpp\"\n  \"${PROJECT_SOURCE_DIR}/runtime/src/tree/xpath/*.cpp\"\n)\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output\nDESCRIPTION: Token stream output showing the lexer's recognition of the comment block as a single token followed by EOF. The output includes token position, text content, token type, and line/column information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyOptional.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:13='//blah\\n//blah\\n',<1>,1:0]\n[@1,14:13='<EOF>',<-1>,3:0]\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Expression Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar named 'T' that defines rules for parsing expressions. It includes a start rule that expects an expression followed by EOF, and an expr rule that recognizes either a single 'x' character or a combination of expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/DuplicatedLeftRecursiveCall_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : expr EOF;\nexpr : 'x'\n     | expr expr\n     ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar Rules\nDESCRIPTION: This snippet defines a simple ANTLR4 grammar with rules for parsing 'a' followed by 'b' or 'c', and a separate rule for 'e'. The grammar is named 'T' and the start rule is 'a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LL2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' 'b'\n  | 'a' 'c'\n;\nq : 'e' ;\n```\n\n----------------------------------------\n\nTITLE: Lexer Token Output\nDESCRIPTION: ANTLR4 lexer output showing the tokens generated from the input, including position information and token types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EscapedCharacters.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:0='x',<2>,1:0]\n[@1,1:1='\\n',<1>,1:1]\n[@2,2:1='<EOF>',<-1>,2:0]\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Grammar S in ANTLR4\nDESCRIPTION: This snippet defines the slave grammar 'S' with token declarations, a parser rule with an embedded action, and lexer rules for integers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/CombinedImportsCombined.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\ntokens { A, B, C }\nx : 'x' INT {<writeln(\"\\\"S.x\\\"\")>};\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Left-Recursive Grammar Rule in ANTLR4\nDESCRIPTION: This snippet defines a grammar 'T' with a left-recursive rule 'a'. It includes an action to print the parse tree after processing. The grammar also defines an ID token for lowercase letters and skips whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/DirectCallToLeftRecursiveRule_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na @after {<ToStringTree(\"$ctx\"):writeln()>} : a ID\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR Grammar Rule with Action\nDESCRIPTION: Defines a grammar named T with a single rule 'a' that matches either 'x' or 'y' and outputs the matched text using a template action. The rule demonstrates basic token matching and text access.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/ParserSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : t=('x'|'y') {<writeln(\"$t.text\")>} ;\n```\n\n----------------------------------------\n\nTITLE: Complete ANTLR4 CMake Integration Example\nDESCRIPTION: A full example demonstrating how to use both ANTLR4 packages to generate a lexer and parser, include the necessary directories, and link against the runtime library in a CMake project.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/Antlr4Package.md#2025-04-21_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\n # Bring in the required packages\n find_package(antlr4-runtime REQUIRED)\n find_package(antlr4-generator REQUIRED)\n\n # Set path to generator\n set(ANTLR4_JAR_LOCATION ${PROJECT_SOURCE_DIR}/thirdparty/antlr/antlr-4.13.2-complete.jar)\n\n # generate lexer\n antlr4_generate(\n   antlrcpptest_lexer\n   ${CMAKE_CURRENT_SOURCE_DIR}/TLexer.g4\n   LEXER\n   FALSE\n   FALSE\n   \"antlrcpptest\"\n   )\n\n # generate parser\n antlr4_generate(\n   antlrcpptest_parser\n   ${CMAKE_CURRENT_SOURCE_DIR}/TParser.g4\n   PARSER\n   FALSE\n   TRUE\n   \"antlrcpptest\"\n   \"${ANTLR4_TOKEN_FILES_antlrcpptest_lexer}\"\n   \"${ANTLR4_TOKEN_DIRECTORY_antlrcpptest_lexer}\"\n   )\n\n # add directories for generated include files\n include_directories( ${PROJECT_BINARY_DIR} ${ANTLR4_INCLUDE_DIR} ${ANTLR4_INCLUDE_DIR_antlrcpptest_lexer} ${ANTLR4_INCLUDE_DIR_antlrcpptest_parser} )\n\n # add generated source files\n add_executable( Parsertest main.cpp ${ANTLR4_SRC_FILES_antlrcpptest_lexer} ${ANTLR4_SRC_FILES_antlrcpptest_parser} )\n\n # add required runtime library\n add_dependencies( Parsertest antlr4_shared )\n\n target_link_libraries( Parsertest PRIVATE\n                        antlr4_shared)\n\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parsing Letters and 'd'\nDESCRIPTION: This ANTLR4 grammar defines a parser rule 'a' that matches zero or more LETTERS followed by 'd'. The LETTERS token includes ASCII 'a' and a range of Unicode characters. The grammar also includes an action to write the entire input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeEscapedBMPRangeSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : LETTERS* 'd' {<InputText():writeln()>} ;\n// Note the double-backslash to avoid Java passing\n// unescaped values as part of the grammar.\nLETTERS : ('a'|'\\\\u00E0'..'\\\\u00E5');\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Word Token Lexer in ANTLR4\nDESCRIPTION: Lexer grammar that defines a WORD token matching sequences of lowercase letters, hyphens and plus signs. The grammar demonstrates basic token definition using character class notation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/StackoverflowDueToNotEscapedHyphen.txt#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\nlexer grammar L;\nWORD   : [a-z-+]+;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Simple Rules\nDESCRIPTION: Defines a grammar 'T' with two rules: rule 'a' matches one or more 'a' characters followed by either 'b' or 'c', and rule 'q' matches character 'e'. The grammar starts with rule 'a' and attempts to parse input 'aaae' which results in an error.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LLStar.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a'+ 'b'\n  | 'a'+ 'c'\n;\nq : 'e' ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR Grammar for Testing ATNConfig.hashCode Issue\nDESCRIPTION: This ANTLR grammar defines rules for parsing a simple expression language. It includes a start rule, an expression rule with alternatives, and a primary rule for identifiers. The grammar is designed to test a specific NullPointerException issue in ANTLR4's ATN state optimization.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/InvalidATNStateRemoval.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\nstart : ID ':' expr;\nexpr : primary expr? {<Pass()>} | expr '->' ID;\nprimary : ID;\nID : [a-z]+;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Position Adjusting Lexer\nDESCRIPTION: Example input text demonstrating various token patterns including labels and assignments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/PositionAdjustingLexer.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\ntokens\ntokens {\nnotLabel\nlabel1 =\nlabel2 +=\nnotLabel\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parsing 'b*c' Pattern\nDESCRIPTION: This ANTLR4 grammar defines a parser that recognizes a sequence of zero or more 'b' characters followed by a 'c'. It includes a parser rule 'a' and a lexer rule 'A'. The parser rule has an associated action to write the input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/StarLexerSingleElement_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<InputText():writeln()>} ;\nA : 'b'* 'c' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar with Parser Members and Conditional Rules\nDESCRIPTION: Defines a grammar 'T' with parser member variable 'i' and rules that conditionally match based on the member value. The grammar includes lexer rules for identifiers, integers, and whitespace, with actions that set and check member values.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/ActionHidesPreds.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {<InitIntMember(\"i\",\"0\")>}\ns : a+ ;\na : {<SetMember(\"i\",\"1\")>} ID {<MemberEquals(\"i\",\"1\")>}? {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<SetMember(\"i\",\"2\")>} ID {<MemberEquals(\"i\",\"2\")>}? {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR4 Demo Executable in CMake\nDESCRIPTION: Configures the installation of the ANTLR4 demo executable. It specifies the destination directory and marks it as part of the 'dev' component.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\ninstall(TARGETS antlr4-demo \n        DESTINATION \"share\" \n        COMPONENT dev \n        )\n```\n\n----------------------------------------\n\nTITLE: Deploying JavaScript Runtime to npm\nDESCRIPTION: This series of commands prepares and publishes the ANTLR4 JavaScript runtime to npm, including building and packaging the source.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4/runtime/JavaScript\nrm -rf node_modules # seems we might need this later but try it here\nnpm update\nnpm install\nnpm run build \nnpm login     # asks for username/password/2FA (npmjs.com)\nnpm publish   # don't put antlr4 on there or it will try to push the old version for some reason\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar Definition with Multiple Rules\nDESCRIPTION: Defines a simple ANTLR4 grammar named 'T' with two rules: 'a' for matching patterns of 'a', 'b', and 'c'/'d', and 'q' for matching 'e'. The grammar demonstrates alternation and repetition operators.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LL3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' 'b'* 'c'\n  | 'a' 'b' 'd'\n;\nq : 'e' ;\n```\n\n----------------------------------------\n\nTITLE: Configuring Java Main Class for ANTLR4 Project\nDESCRIPTION: Commands to replace the default Maven-generated App.java with the ANTLR4 example's main Java program, renaming it to ArrayInit.java.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Remove the maven file\nrm ./src/main/java/org/abcd/examples/ArrayInit/App.java\n# Copy and rename the example from the book\ncp ~/Downloads/code/starter/Test.java ./src/main/java/org/abcd/examples/ArrayInit/ArrayInit.java\n```\n\n----------------------------------------\n\nTITLE: Defining OpenDeviceStatement Grammar in ANTLR4\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing 'OPEN DEVICE' statements. It includes a main 'statement' rule with optional parameters and lexer tokens for different options. The grammar also handles whitespace and defines the starting rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/OpenDeviceStatement_Case3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar OpenDeviceStatement;\nprogram : statement+ '.' ;\n\nstatement : 'OPEN' ( 'DEVICE' (  (OPT1)  |  OPT2  |  OPT3  )? )+ {<writeln(\"$text\")>} ;\n\nOPT1 : 'OPT-1';\nOPT2 : 'OPT-2';\nOPT3 : 'OPT-3';\n\nWS : (' '|'\\n')+ -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for XYZ Parser\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing a sequence of 'x' and 'y' characters followed by a 'z'. It includes initialization to build parse trees and a post-processing action to output the parse tree as a string.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/TwoAltLoop.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : ('x' | 'y')* 'z'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Setting superClass Option with Command Line\nDESCRIPTION: Example showing how to set the superClass option using the command line -D parameter. This overrides the parser's parent class while leaving the lexer's parent class as the default.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/options.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ cat Hi.g4\ngrammar Hi;\na : 'hi' ;\n$ antlr4 -DsuperClass=XX Hi.g4\n$ grep 'public class' HiParser.java\npublic class HiParser extends XX {\n$ grep 'public class' HiLexer.java\npublic class HiLexer extends Lexer {\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Rule Context Class Example\nDESCRIPTION: Shows the Java context class generated for a parser rule with single rule reference.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npublic static class IncContext extends ParserRuleContext {\n\tpublic EContext e() { ... } // return context object associated with e\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Output for Mismatched Input\nDESCRIPTION: This snippet displays the output of the lexer when processing the mismatched input. It shows an EOF token as no valid tokens were recognized.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/ErrorInMiddle.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\n[@0,3:2='<EOF>',<-1>,1:3]\n```\n\n----------------------------------------\n\nTITLE: Documentation Navigation Structure in Markdown\nDESCRIPTION: A markdown-formatted table of contents and resource links for ANTLR 4 documentation, including sections on grammar basics, parser rules, lexer rules, and tool usage.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/index.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# ANTLR 4 Documentation\n\n* [Getting Started with ANTLR v4](getting-started.md)\n* [Grammar Lexicon](lexicon.md)\n* [Grammar Structure](grammars.md)\n* [Parser Rules](parser-rules.md)\n* [Left-recursive rules](left-recursion.md)\n* [Actions and Attributes](actions.md)\n* [Lexer Rules](lexer-rules.md)\n* [Wildcard Operator and Nongreedy Subrules](wildcard.md)\n* [Parse Tree Listeners](listeners.md)\n* [Parse Tree Matching and XPath](tree-matching.md)\n* [Semantic Predicates](predicates.md)\n* [Options](options.md)\n* [ANTLR Tool Command Line Options](tool-options.md)\n* [Runtime Libraries and Code Generation Targets](targets.md)\n* [Unicode U+FFFF, U+10FFFF character streams](unicode.md)\n* [Parsing binary streams](parsing-binary-files.md)\n* [Parser and lexer interpreters](interpreters.md)\n* [Writing target-agnostic grammars](target-agnostic-grammars.md)\n* [Resources](resources.md)\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parsing Letters and 'd'\nDESCRIPTION: This ANTLR4 grammar defines a parser rule 'a' that matches zero or more letters followed by 'd', and a lexer rule 'LETTERS' for matching various letter characters including accented ones. The parser rule includes an action to print the input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeUnescapedBMPRangeSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : LETTERS* 'd' {<InputText():writeln()>} ;\n// These are actually not escaped -- Java passes the\n// raw unescaped Unicode values to the grammar compiler.\nLETTERS : ('a'|'à'..'å');\n```\n\n----------------------------------------\n\nTITLE: Loading ANTLR and Custom Language Parser in ACE Worker\nDESCRIPTION: This snippet demonstrates how to load ANTLR and a custom language parser in the ACE Editor worker. It handles the complexities of different 'require' functions between ACE and ANTLR.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// load nodejs compatible require\nvar ace_require = require;\nrequire = undefined;\nvar Honey = { 'requirePath': ['..'] }; // walk up to js folder, see Honey docs\nimportScripts(\"../lib/require.js\");\nvar antlr4_require = require;\nrequire = ace_require;\n\n// load antlr4 and myLanguage\nvar antlr4, mylanguage;\ntry {\n    require = antlr4_require;\n    antlr4 = require('antlr4/index');\n    mylanguage = require('mylanguage/index');\n} finally {\n    require = ace_require;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Custom Rule Node\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with options for a custom context superclass and tree node with alt num field. It includes rules for parsing simple strings like 'f', 'g', and 'xyz'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/AltNum.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\noptions { contextSuperClass=MyRuleNode; }\n\n<TreeNodeWithAltNumField(X=\"T\")>\n\n\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\n\na : 'f'\n  | 'g'\n  | 'x' b 'z'\n  ;\nb : 'e' {} | 'y'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar with Parser Actions\nDESCRIPTION: An ANTLR4 grammar named 'T' that defines rules for accepting 'x' followed by zero or more 'y's and an exclamation mark. It includes parser initialization code to build parse trees and after-rule actions to print the resulting tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParseTrees/Sync.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns\n@init {\n<BuildParseTrees()>\n}\n@after {\n<ToStringTree(\"$r.ctx\"):writeln()>\n}\n  : r=a ;\na : 'x' 'y'* '!'\n  ;\nZ : 'z'\n  ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer\nDESCRIPTION: This snippet provides a sample input string to be tokenized by the defined lexer grammar. It includes various combinations of the defined tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/KeywordID.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nend eend ending a\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar with Embedded Action\nDESCRIPTION: Defines a grammar with one parser rule 'a' and one lexer rule 'A'. The parser rule includes an action to write the input text. The lexer rule matches zero or more 'a' or 'b' characters followed by 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/LexerStarSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<InputText():writeln()>} ;\nA : ('a'|'b')* 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple ANTLR4 Grammar with Token Name Output\nDESCRIPTION: A complete ANTLR4 grammar definition that recognizes sentences about animals and services. It includes a special rule 'acClass' with an @init action that prints expected token names using the GetExpectedTokenNames() template function.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LL1ErrorInfo.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : animal (AND acClass)? service EOF;\nanimal : (DOG | CAT );\nservice : (HARDWARE | SOFTWARE) ;\nAND : 'and';\nDOG : 'dog';\nCAT : 'cat';\nHARDWARE: 'hardware';\nSOFTWARE: 'software';\nWS : ' ' -> skip ;\nacClass\n@init\n{<GetExpectedTokenNames():writeln()>}\n  : ;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ANTLR Comment Types\nDESCRIPTION: Shows the three types of comments supported in ANTLR grammars: Javadoc-style, multi-line, and single-line comments. Javadoc comments are meant for grammar documentation at the start of grammar files and rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexicon.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\n/** This grammar is an example illustrating the three kinds\n * of comments.\n */\ngrammar T;\n/* a multi-line\n  comment\n*/\n\n/** This rule matches a declarator for my language */\ndecl : ID ; // match a variable name\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake for ANTLR4 C++ Project\nDESCRIPTION: Main CMakeLists.txt configuration for setting up an ANTLR4 C++ project. Includes compiler settings, external dependencies, and build targets for ANTLR grammar files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/README.md#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\n# minimum required CMAKE version\nCMAKE_MINIMUM_REQUIRED(VERSION 3.7 FATAL_ERROR)\n\nlist(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)\n\n# compiler must be 17\nset(CMAKE_CXX_STANDARD 17)\n\n# required if linking to static library\nadd_definitions(-DANTLR4CPP_STATIC)\n\n# using /MD flag for antlr4_runtime (for Visual C++ compilers only)\nset(ANTLR4_WITH_STATIC_CRT OFF)\n\n# add external build for antlrcpp\ninclude(ExternalAntlr4Cpp)\n# add antlr4cpp artifacts to project environment\ninclude_directories(${ANTLR4_INCLUDE_DIRS})\n\n# set variable pointing to the antlr tool that supports C++\nset(ANTLR_EXECUTABLE /home/user/antlr-4.13.2-complete.jar)\n# add macros to generate ANTLR Cpp code from grammar\nfind_package(ANTLR REQUIRED)\n\n# Call macro to add lexer and grammar to your build dependencies.\nantlr_target(SampleGrammarLexer TLexer.g4 LEXER\n             PACKAGE antlrcpptest)\nantlr_target(SampleGrammarParser TParser.g4 PARSER\n             PACKAGE antlrcpptest\n             DEPENDS_ANTLR SampleGrammarLexer\n             COMPILE_FLAGS -lib ${ANTLR_SampleGrammarLexer_OUTPUT_DIR})\n\ninclude_directories(${ANTLR_SampleGrammarLexer_OUTPUT_DIR})\ninclude_directories(${ANTLR_SampleGrammarParser_OUTPUT_DIR})\n\nadd_executable(demo main.cpp\n               ${ANTLR_SampleGrammarLexer_CXX_OUTPUTS}\n               ${ANTLR_SampleGrammarParser_CXX_OUTPUTS})\ntarget_link_libraries(demo antlr4_static)\n```\n\n----------------------------------------\n\nTITLE: Cloning ANTLR4 Repository\nDESCRIPTION: Git command to clone the ANTLR4 source code repository, necessary for compiling the Swift runtime from source.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/antlr/antlr4\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar Rule\nDESCRIPTION: Defines a basic ANTLR4 grammar rule 'a' that matches pattern: single 'a', followed by zero or more 'b's, ending with 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/MultiTokenDeletionBeforeLoop.txt#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\ngrammar T;\na : 'a' 'b'* 'c';\n```\n\n----------------------------------------\n\nTITLE: Modifying Java Main Class for ANTLR4 Project\nDESCRIPTION: Example of how to modify the ArrayInit.java file to include the package declaration and rename the class to match the file name.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npackage org.abcd.examples.ArrayInit;\nimport org.antlr.v4.runtime.*;\nimport org.antlr.v4.runtime.tree.*;\n \npublic class ArrayInit {\n...\n```\n\n----------------------------------------\n\nTITLE: Left-Recursive Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar with a left-recursive rule 'a' that matches sequences of identifiers. Includes lexer rules for IDs and whitespace, with a tree visualization action after matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/DirectCallToLeftRecursiveRule_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na @after {<ToStringTree(\"$ctx\"):writeln()>} : a ID\n  | ID\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Action Before Predicate in ANTLR\nDESCRIPTION: Demonstrates how actions placed before predicates create dependencies that prevent the parser from evaluating the predicate during prediction, since actions must be executed first.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/predicates.md#2025-04-21_snippet_5\n\nLANGUAGE: ANTLR\nCODE:\n```\n@members {boolean allowgoto=false;}\nstat: {System.out.println(\"goto\"); allowgoto=true;} {java5}? 'goto' ID ';'\n \t| ...\n \t;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Expression Parsing\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions composed of 'x' characters. It includes a start rule, an expression rule that allows for single 'x' or concatenation of expressions, and specifies 'start' as the entry point for parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/DuplicatedLeftRecursiveCall_4.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : expr EOF;\nexpr : 'x'\n     | expr expr\n     ;\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output\nDESCRIPTION: Token stream output showing recognized comments and whitespace tokens, including position information and token types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardPlus_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:8='/* ick */',<1>,1:0]\n[@1,10:10='\\n',<2>,1:10]\n[@2,11:36='/* /* */x\\n/* /*nested*/ */',<1>,2:0]\n[@3,38:38='\\n',<2>,3:17]\n[@4,39:38='<EOF>',<-1>,4:0]\n```\n\n----------------------------------------\n\nTITLE: Example Input for ANTLR4 Expression Parser\nDESCRIPTION: Sample input file containing different arithmetic expressions that will be parsed by the ANTLR4 grammar, demonstrating various expression patterns.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/python-target.md#2025-04-21_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n-(1 + 2)/3;\n1;\n2+3;\n8*9\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with ToStringTree Action\nDESCRIPTION: A simple ANTLR4 grammar that defines rules for parsing 'A B' input and outputs the parse tree using the ToStringTree function. The grammar includes parser rules (r, a, b) and lexer rules (A, B, WS) with a custom action in the 'r' rule to display the parse tree.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/BuildParseTree_TRUE.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nr\n   : a b {<ToStringTree(\"$ctx\"):writeln()>}\n   ;\na\n   : A\n   ;\nb\n   : B\n   ;\nA  : 'A';\nB  : 'B';\nWS  : [ \\r\\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Listener for ANTLR in JavaScript\nDESCRIPTION: This snippet defines a custom error listener that creates annotations for syntax errors. It overrides the syntaxError method to push error details into an annotations array.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nAnnotatingErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {\n    this.annotations.push({\n        row: line - 1,\n        column: column,\n        text: msg,\n        type: \"error\"\n });\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Grammar with Semantic Predicate in ANTLR4\nDESCRIPTION: This code snippet defines a simple ANTLR4 grammar named 'T' with a single rule 'a' that matches 'a' followed by zero or more occurrences of 'b' or 'z' (with a Pass() semantic predicate), and ends with 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/MultiTokenDeletionBeforeLoop2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' ('b'|'z'{<Pass()>})* 'c';\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parser T\nDESCRIPTION: This snippet defines an ANTLR4 grammar named T with a single rule 'a'. The rule matches any character except 'x' followed by 'z', and includes an embedded action to write the input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/ParserNotToken.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ~'x' 'z' {<InputText():writeln()>} ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Parser Testing\nDESCRIPTION: Example input string testing the if-then-else grammar structure with nested statements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n{ if x then return else foo }\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar with Error Token Definition\nDESCRIPTION: Defines a simple grammar with rules for parsing parenthesized expressions, identifiers, and string literals. Includes an explicit error token '~FORCE_ERROR~' for testing error handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/TokenMismatch2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nstat:   ( '(' expr? ')' )? EOF ;\nexpr:   ID '=' STR ;\n\nERR :   '~FORCE_ERROR~' ;\nID  :   [a-zA-Z]+ ;\nSTR :   '\"' ~[\"]* '\"' ;\nWS  :   [ \\t\\r\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet defines a simple ANTLR4 lexer grammar named 'L'. It includes token rules for the keyword 'end', identifiers consisting of lowercase letters, and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/KeywordID.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nKEND : 'end' ; // has priority\nID : 'a'..'z'+ ;\nWS : (' '|'\\n')+;\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR4 Libraries to Local Maven Cache\nDESCRIPTION: Commands to install ANTLR4 artifacts into the local Maven repository without running tests.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/building-antlr.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ export MAVEN_OPTS=\"-Xmx1G\"     # don't forget this on linux\n$ mvn install -DskipTests   # make sure all artifacts are visible on this machine\n```\n\n----------------------------------------\n\nTITLE: Windows Doskey Commands for ANTLR4\nDESCRIPTION: Doskey commands to create shortcuts for the ANTLR tool and TestRig GUI on Windows command prompt, providing an alternative to batch files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ndoskey antlr4=java org.antlr.v4.Tool $*\ndoskey grun =java org.antlr.v4.gui.TestRig $*\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar with Token Set Rule\nDESCRIPTION: An ANTLR4 grammar named 'T' that defines a rule 'myset' as a set of alternatives ('b' or 'c'), and a rule 'a' that expects a sequence of 'a', followed by myset, followed by 'd', with an action that writes the stop position of myset.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleSetInsertionConsumption.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nmyset: ('b'|'c') ;\na: 'a' myset 'd' {<writeln(Append(\"\\\"\\\"\",\"$myset.stop\"))>} ; <! bit complicated because of the JavaScript target !>\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar Rule with After Action\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with a single rule 'a' that matches 'a', 'b', or 'c'. It includes an @after action to print the recognized input text using a template.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/RuleAsSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na @after {<InputText():writeln()>} : 'a' | 'b' |'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with ToStringTree Action\nDESCRIPTION: An ANTLR4 grammar that defines simple rules for parsing 'A B' input with a custom action to print the parse tree using ToStringTree. The grammar includes rules for 'r', 'a', and 'b', along with token definitions for 'A', 'B', and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/BuildParseTree_FALSE.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\nr\n   : a b {<ToStringTree(\"$ctx\"):writeln()>}\n   ;\na\n   : A\n   ;\nb\n   : B\n   ;\nA  : 'A';\nB  : 'B';\nWS  : [ \\r\\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Parser T\nDESCRIPTION: This snippet defines an ANTLR4 grammar named T with a single parser rule 'a' and a lexer rule 'A'. The parser rule includes an embedded action to write the matched text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/NotChar.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<writeln(\"$A.text\")>} ;\nA : ~'b' ;\n```\n\n----------------------------------------\n\nTITLE: Signing Git Commits for ANTLR 4 Contributions\nDESCRIPTION: Command to create a signed git commit using the -s flag for DCO (Developer Certificate of Origin) compliance. Required for all commits to the ANTLR 4 project.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -s -m 'This is my commit message'\n```\n\n----------------------------------------\n\nTITLE: Tokenized Output from ANTLR4 Lexer\nDESCRIPTION: This snippet shows the tokenized output produced by the lexer when processing the sample input. Each line represents a token with its text, token type, and position information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/KeywordID.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:2='end',<1>,1:0]\n[@1,3:3=' ',<3>,1:3]\n[@2,4:7='eend',<2>,1:4]\n[@3,8:8=' ',<3>,1:8]\n[@4,9:14='ending',<2>,1:9]\n[@5,15:15=' ',<3>,1:15]\n[@6,16:16='a',<2>,1:16]\n[@7,17:16='<EOF>',<-1>,1:17]\n```\n\n----------------------------------------\n\nTITLE: Alternative Method for Running ANTLR4 Java Application with Maven\nDESCRIPTION: Commands to build and run the ANTLR4 Java application using Maven's exec plugin, which doesn't require creating a standalone JAR.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmvn install\nmvn exec:java -Dexec.mainClass=org.abcd.examples.ArrayInit.ArrayInit\n{1,2,3}\n^D\n```\n\n----------------------------------------\n\nTITLE: ANTLR Identifier Examples\nDESCRIPTION: Examples of valid ANTLR identifiers for token names/lexer rules (capital first letter) and parser rule names (lowercase first letter). Names can contain letters, digits, and underscores after the initial character.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexicon.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\nID, LPAREN, RIGHT_CURLY // token names/lexer rules\nexpr, simpleDeclarator, d2, header_file // parser rule names\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output for Nested Comments\nDESCRIPTION: This output shows the expected tokens generated by the lexer when processing the input text. Each token is represented with its text, token type, line number, and character position.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardStar_1.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:8='/* ick */',<1>,1:0]\n[@1,9:9='\\n',<2>,1:9]\n[@2,10:34='/* /* */\\n/* /*nested*/ */',<1>,2:0]\n[@3,35:35='\\n',<2>,3:16]\n[@4,36:35='<EOF>',<-1>,4:0]\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Recursive Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar named 'T' that defines rules for parsing expressions consisting of 'x' characters. It includes a start rule that expects an expression followed by EOF, and an expr rule that recursively handles sequences of 'x'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/DuplicatedLeftRecursiveCall_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : expr EOF;\nexpr : 'x'\n     | expr expr\n     ;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar with Rule for 'a' followed by 'b' or 'c'\nDESCRIPTION: A basic ANTLR4 grammar named 'T' with a single rule that expects the character 'a' followed by either 'b' or 'c'. This grammar is used to demonstrate error handling when invalid input is provided.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionExpectingSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' ('b'|'c') ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input with Nested Comments\nDESCRIPTION: Test input demonstrating various comment patterns including simple comments and nested comment structures.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardPlus_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n/* ick */\n/* /* */\n/* /*nested*/ */\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Lexer Rules in ANTLR4\nDESCRIPTION: Defines a lexer grammar named 'L' with two rules: 'I' matches any character except 'a', 'b', space, and newline (or matches 'a'), and 'WS' skips whitespace characters including spaces and newlines.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetInSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : (~[ab \\\\n]|'a')  {<writeln(\"\\\"I\\\"\")>} ;\nWS : [ \\n\\\\u000D]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar with Semantic Predicate in ANTLR4\nDESCRIPTION: This snippet defines a lexer grammar named 'L' with a single token 'T' that matches 'a' and includes a semantic predicate. The predicate always evaluates to true.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/RuleSempredFunction.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nT : 'a' {<True()>}? ;\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Nested Actions in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for matching nested action blocks enclosed in curly braces and skipping whitespace. The ACTION rule uses recursive matching to handle nested braces.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/EnforcedGreedyNestedBraces_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nACTION : '{' (ACTION | ~[{}])* '}';\nWS : [ \\r\\n\\t]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Generating Xcode Project for ANTLR4 Swift Runtime\nDESCRIPTION: Commands to navigate to the Swift runtime directory and generate an Xcode project using the boot.py script.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd antlr4/runtime/Swift\npython boot.py --gen-xcodeproj\n```\n\n----------------------------------------\n\nTITLE: Running Single Target Tests with Maven\nDESCRIPTION: Maven command to run tests for a specific target language\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/antlr-project-testing.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ cd runtime-testsuite\n$ export MAVEN_OPTS=\"-Xmx1G\"     # don't forget this on linux\n$ mvn -Dtest='java.**' test\n```\n\n----------------------------------------\n\nTITLE: Defining Basic ANTLR Grammar with Alternatives and Semantic Predicate\nDESCRIPTION: A simple ANTLR grammar named 'T' that defines a rule 'a' which accepts an 'a' followed by zero or more 'b' or 'z' characters (with 'z' triggering a Pass() semantic action) and ending with EOF.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionBeforeLoop2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : 'a' ('b'|'z'{<Pass()>})* EOF ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Label Testing\nDESCRIPTION: Defines a grammar that tests label functionality with compound operators. The grammar includes rules for multiplication, comma-separated expressions, and send operations with the '>>' operator.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList2_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr ',' b+=expr #Comma\n    | b+=expr '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n   ;\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar Definition with ID Matching\nDESCRIPTION: Defines a simple ANTLR4 grammar named 'T' that includes a parser rule 'a' matching zero or more ID tokens, with an action to write the matched text. Includes lexer rules for ID tokens (lowercase letters) and whitespace skipping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AStar_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ID* {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Cloning ANTLR4 Repository using Git\nDESCRIPTION: Commands to clone the ANTLR4 repository from GitHub to a local directory.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/building-antlr.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd /tmp\n/tmp $ git clone https://github.com/antlr/antlr4.git\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar for String Matching with Mode Transitions\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for matching string content with single quotes, including mode transitions. It demonstrates handling of zero-length tokens and lexer commands.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ZeroLengthToken.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nBeginString\n   :   '\\'' -> more, pushMode(StringMode)\n   ;\nmode StringMode;\n   StringMode_X : 'x' -> more;\n   StringMode_Done : -> more, mode(EndStringMode);\nmode EndStringMode;\n   EndString : '\\'' -> popMode;\n```\n\n----------------------------------------\n\nTITLE: Providing Input for ANTLR4 Grammar Parsing\nDESCRIPTION: This snippet shows the input string 'ae' that will be parsed using the defined grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LL2.txt#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR4\nCODE:\n```\nae\n```\n\n----------------------------------------\n\nTITLE: Installing ANTLR4 Go Runtime\nDESCRIPTION: Command to install the latest version of ANTLR4 Go runtime using go get.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-target.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/antlr4-go/antlr\n```\n\n----------------------------------------\n\nTITLE: ANTLR 4.6 CharStream Creation (Deprecated)\nDESCRIPTION: Example of creating a character stream in ANTLR 4.6 using the now-deprecated ANTLRFileStream class. This approach only supports Unicode code points up to U+FFFF and doesn't use UTF-8 by default.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_4\n\nLANGUAGE: java\nCODE:\n```\nCharStream input = new ANTLRFileStream(\"myinputfile\");\nJavaLexer lexer = new JavaLexer(input);\nCommonTokenStream tokens = new CommonTokenStream(lexer);\n```\n\n----------------------------------------\n\nTITLE: Sample Input with Nested Comments\nDESCRIPTION: Test input containing various comment patterns including simple comments and nested comments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardStar_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n/* ick */x\n/* /* */x\n/* /*nested*/ */x\n```\n\n----------------------------------------\n\nTITLE: Adding ANTLR4 Dependency in Dart's pubspec.yaml\nDESCRIPTION: This snippet shows how to add the ANTLR4 runtime as a dependency in a Dart project's pubspec.yaml file. The version should match the main ANTLR tool version being used.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/dart-target.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n...\ndependencies:\n  antlr4: <ANTLR version>\n...\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Output Format\nDESCRIPTION: Shows the expected output format for an EOF token match, including position information and token type.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EOFSuffixInFirstRule_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[@0,0:-1='<EOF>',<-1>,1:0]\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar Rules in ANTLR4\nDESCRIPTION: This snippet defines a lexer grammar named 'L' with three rules. The 'I' rule matches any characters followed by 'a' or 'ab' and writes the matched text. 'WS' skips whitespace, and 'J' is a catch-all rule that writes any single character.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyConfigs.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nI : .*? ('a' | 'ab') {<Text():writeln()>} ;\nWS : (' '|'\\n') -> skip ;\nJ : . {<Text():writeln()>};\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar with Text Output\nDESCRIPTION: Defines a grammar that matches sequences of lowercase letters with a single parser rule 'a' and two lexer rules 'ID' and 'WS'. The parser outputs the matched text using an embedded action.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AorAStar_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|ID)* {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Sample Input with Comments\nDESCRIPTION: Example input text containing two single-line comments to test the lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyOptional.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n//blah\n//blah\n```\n\n----------------------------------------\n\nTITLE: Publishing Dart Runtime to pub.dev\nDESCRIPTION: This command publishes the Dart runtime package to pub.dev using the Dart SDK's pub tool.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4/runtime/Dart\ndart pub publish\n```\n\n----------------------------------------\n\nTITLE: Parser Decision Output for IF-THEN-ELSE Ambiguity\nDESCRIPTION: This output snippet shows the decision process of the parser when encountering the 'else' token. It demonstrates how the parser handles the potential ambiguity in the nested IF-THEN-ELSE structure.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_3.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\nDecision 1:\ns0-'}'->:s2=>2\ns0-'else'->:s1^=>1\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Parser\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with a single rule 'a' and a token 'A'. The rule 'a' matches the token 'A' and includes an action to write the input text. The token 'A' is defined as a sequence of 'a' or 'b' characters followed by 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/LexerPlusSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : A {<InputText():writeln()>} ;\nA : ('a'|'b')+ 'c' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar with Unicode Character\nDESCRIPTION: Example of an ANTLR grammar that uses a Unicode character directly in a rule. This demonstrates how ANTLR supports non-ASCII characters in grammar definitions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/lexicon.md#2025-04-21_snippet_4\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar Foreign;\na : '外' ;\n```\n\n----------------------------------------\n\nTITLE: Main Grammar Definition with Imports\nDESCRIPTION: Main grammar file 'M' that imports slave grammars S and T, defines basic token rules and entry point.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorInvokesFirstVersionOfDelegateRule.txt#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\ngrammar M;\nimport S,T;\ns : a ;\nB : 'b' ; // defines B from inherited token space\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining C++-Specific Parser Named Actions in ANTLR4 Grammars\nDESCRIPTION: These named actions are specific to the C++ target for the parser, listener, and visitor classes. They allow for customization of various parts of the generated code, such as includes, declarations, members, and definitions for each class type.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/cpp-target.md#2025-04-21_snippet_5\n\nLANGUAGE: ANTLR4\nCODE:\n```\n@parser::listenerpreinclude\n@parser::listenerpostinclude\n@parser::listenerdeclarations\n@parser::listenermembers\n@parser::listenerdefinitions\n\n@parser::baselistenerpreinclude\n@parser::baselistenerpostinclude\n@parser::baselistenerdeclarations\n@parser::baselistenermembers\n@parser::baselistenerdefinitions\n\n@parser::visitorpreinclude\n@parser::visitorpostinclude\n@parser::visitordeclarations\n@parser::visitormembers\n@parser::visitordefinitions\n\n@parser::basevisitorpreinclude\n@parser::basevisitorpostinclude\n@parser::basevisitordeclarations\n@parser::basevisitormembers\n@parser::basevisitordefinitions\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Conditional Statements\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing simple 'if-else' statements and basic expressions. It includes rules for statements, if-statements, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Optional_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstat : ifstat | 'x';\nifstat : 'if' stat ('else' stat)?;\nWS : [ \\n\\t]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Git Merge Operations for ANTLR Release\nDESCRIPTION: Commands to merge dev branch into master as part of the release process.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4\ngit checkout master\ngit merge dev\n```\n\n----------------------------------------\n\nTITLE: Running the PHP JSON Parser\nDESCRIPTION: Command to execute the PHP script that parses the JSON input file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/php-target.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nphp json.php example.json\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Lexer Grammar\nDESCRIPTION: Defines a lexer grammar with two token rules: A matches 'ab' and B matches 'abc'. Shows how ANTLR4 processes overlapping token patterns.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/DFAToATNThatFailsBackToDFA.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'ab' ;\nB : 'abc' ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input Text for Lexer Testing\nDESCRIPTION: Provides a test input string containing overlapping patterns that match multiple lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/DFAToATNThatMatchesThenFailsInATN.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nababcx\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet provides a sample input string to test the lexer grammar. It contains an unclosed action with a string inside.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/StringsEmbeddedInActions_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\n[\"foo]\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Comments and Whitespace in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for single-line comments (CMT) and whitespace (WS). The CMT rule matches '//' followed by any characters up to a newline, allowing for nested comments. The WS rule matches one or more spaces or tabs.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyClosure.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : '//' .*? '\\n' CMT*?;\nWS : (' '|'\\t')+;\n```\n\n----------------------------------------\n\nTITLE: Slave Grammar Definition (S)\nDESCRIPTION: Defines a parser grammar S with rules for handling 'a' and 'b' tokens, including an embedded action to write 'S.a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesDelegate.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\na : b {<write(\"\\\"S.a\\\"\")>};\nb : B ;\n```\n\n----------------------------------------\n\nTITLE: Parser Grammar S Definition\nDESCRIPTION: Slave parser grammar 'S' defining rules 'a' and 'b', where 'a' matches 'b' and 'b' matches token B.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorInvokesFirstVersionOfDelegateRule.txt#2025-04-21_snippet_2\n\nLANGUAGE: antlr4\nCODE:\n```\nparser grammar S;\na : b {<writeln(\"\\\"S.a\\\"\")>};\nb : B;\n```\n\n----------------------------------------\n\nTITLE: Defining T Grammar with If-Else Statements in ANTLR4\nDESCRIPTION: An ANTLR4 grammar definition that parses a simple language with statement rules, if-else constructs, and basic tokens. It includes a semantic action to print the matched text of if statements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/IfIfElseNonGreedyBinding1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : statement+ ;\nstatement : 'x' | ifStatement;\nifStatement : 'if' 'y' statement ('else' statement)?? {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Version Check Command\nDESCRIPTION: Command to find files containing specific version numbers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmvn clean\nfind . -type f -exec grep -l '4\\.12.0' {} \\; | grep -v -E '\\.o|\\.a|\\.jar|\\.dylib|node_modules/|\\.class|tests/|CHANGELOG|\\.zip|\\.gz|.iml|\\.svg'\n```\n\n----------------------------------------\n\nTITLE: Parser Error Reporting for Ambiguity Detection\nDESCRIPTION: This snippet shows the error messages generated by the parser when it encounters ambiguity in the input. It reports attempting full context and detected ambiguity at specific positions in the input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_3.txt#2025-04-21_snippet_3\n\nLANGUAGE: Plain Text\nCODE:\n```\nline 1:29 reportAttemptingFullContext d=1 (stat), input='else'\nline 1:38 reportAmbiguity d=1 (stat): ambigAlts={1, 2}, input='elsefoo}'\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar with Optional Character Match\nDESCRIPTION: Defines a grammar rule 'a' that matches an optional 'a' or 'b' followed by a required 'c'. Includes an embedded action to write the input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/OptionalSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ('a'|'b')? 'c' {<InputText():writeln()>} ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for Simple Identifier Matching\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with a single rule 's' for matching identifiers. It includes a lexer rule for identifiers and whitespace skipping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/AmbigYieldsCtxSensitiveDFA.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<DumpDFA()>}\n   : ID | ID {} ;\nID : 'a'..'z'+;\nWS : (' '|'\\t'|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Main Grammar M in ANTLR4\nDESCRIPTION: This snippet defines the main grammar 'M' which imports grammar 'S'. It includes a rule for 's', defines a token 'B', and specifies whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorInvokesDelegateRuleWithArgs.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\ns : label=a[3] {<writeln(\"$label.y\")>} ;\nB : 'b' ; // defines B from inherited token space\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Configuring CLASSPATH for Windows\nDESCRIPTION: Correct CLASSPATH configuration for Windows systems that includes the current directory (.) and ANTLR jar file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/installation.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nSET CLASSPATH=.;C:\\Javalib\\antlr4-complete.jar;%CLASSPATH%\n```\n\n----------------------------------------\n\nTITLE: Defining OpenDeviceStatement Grammar in ANTLR4\nDESCRIPTION: An ANTLR4 grammar that defines rules for parsing 'OPEN DEVICE' statements with optional modifiers. This grammar is specifically designed to test the handling of repeated element groups in parser rules, which was the subject of issue #1545.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/OpenDeviceStatement_Case2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar OpenDeviceStatement;\nprogram : statement+ '.' ;\n\nstatement : 'OPEN' ( 'DEVICE' (  (OPT1)  |  OPT2  |  OPT3  )? )+ {<writeln(\"$text\")>} ;\n\nOPT1 : 'OPT-1';\nOPT2 : 'OPT-2';\nOPT3 : 'OPT-3';\n\nWS : (' '|'\\n')+ -> channel(HIDDEN);\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar with Custom Semantic Predicates\nDESCRIPTION: A lexer grammar with three rules: ENUM that matches 'enum' using a semantic predicate, ID for other lowercase letter sequences, and WS for whitespace. The grammar includes custom actions to output specific text when tokens are matched.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/PredicatedKeywords.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nENUM : [a-z]+ { <TextEquals(\"enum\")> }? { <writeln(\"\\\"enum!\\\"\")> } ;\nID   : [a-z]+ { <PlusText(\"ID \"):writeln()> } ;\nWS   : [ \\n] -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Binary File Generation in Java\nDESCRIPTION: Java class to create a binary file containing IP addresses and markers for testing purposes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parsing-binary-files.md#2025-04-21_snippet_2\n\nLANGUAGE: java\nCODE:\n```\npublic class WriteBinaryFile {\n\tpublic static final byte[] bytes = {\n\t\t(byte)172, 0, 0, 1, (byte)0xCA, (byte)0xFE,\n\t\t(byte)10, 10, 10, 1, (byte)0xCA, (byte)0xFE,\n\t\t(byte)10, 10, 10, 99\n\t};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tFiles.write(new File(\"/tmp/ips\").toPath(), bytes);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Main Grammar Definition (M)\nDESCRIPTION: Defines the main grammar M that imports slave grammar S and includes basic token rules for 'b' or 'c' and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesDelegate.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\nb : 'b'|'c';\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR Lexer Grammar with Type Directive\nDESCRIPTION: Defines a lexer grammar with a single token rule T_FFFF that matches the literal 'FFFF' and redirects it to token type 65535.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/TokenType0xFFFF.txt#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\nlexer grammar L;\nT_FFFF: 'FFFF' -> type(65535);\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Lexer Testing\nDESCRIPTION: Provides test input string containing 'a' followed by 'x' with whitespace between them.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetInSet.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\na x\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Comments and Whitespace in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for matching C-style comments (including nested comments) and whitespace. The CMT rule uses a non-greedy match to handle nested comments, while the WS rule matches spaces and newlines.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardStar_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nCMT : '/*' (CMT | .)*? '*' '/' ;\nWS : (' '|'\\n')+;\n```\n\n----------------------------------------\n\nTITLE: Executing Java Actions in ANTLR4 Grammar Rules\nDESCRIPTION: This snippet shows Java code embedded within ANTLR4 grammar rules. It demonstrates how to perform actions like writing output and appending strings when certain grammar rules are matched during parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/LoopsSimulateTailRecursion.txt#2025-04-21_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n{<LL_EXACT_AMBIG_DETECTION()>}\n```\n\nLANGUAGE: Java\nCODE:\n```\n{<writeln(\"\\\"fail.\\\"\")>}\n```\n\nLANGUAGE: Java\nCODE:\n```\n{<AppendStr(\"\\\"pass: \\\"\",\"$expr.text\"):writeln()>}\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Definition with Multiple Rules\nDESCRIPTION: Defines a simple ANTLR grammar with two rules: rule 'a' accepting one or more 'a' followed by either 'b' or 'c', and rule 'q' accepting 'e'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionBeforePredict.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : 'a'+ 'b'\n  | 'a'+ 'c'\n;\nq : 'e' ;\n```\n\n----------------------------------------\n\nTITLE: Generated ANTLR4 Listener Interface\nDESCRIPTION: Shows the Java listener interface generated by ANTLR for labeled alternatives.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_4\n\nLANGUAGE: java\nCODE:\n```\npublic interface AListener extends ParseTreeListener {\n\tvoid enterReturn(AParser.ReturnContext ctx);\n\tvoid exitReturn(AParser.ReturnContext ctx);\n\tvoid enterBreak(AParser.BreakContext ctx);\n\tvoid exitBreak(AParser.BreakContext ctx);\n\tvoid enterMult(AParser.MultContext ctx);\n\tvoid exitMult(AParser.MultContext ctx);\n\tvoid enterAdd(AParser.AddContext ctx);\n\tvoid exitAdd(AParser.AddContext ctx);\n\tvoid enterInt(AParser.IntContext ctx);\n\tvoid exitInt(AParser.IntContext ctx);\n}\n```\n\n----------------------------------------\n\nTITLE: Lexer Error Output for Nested Action Input\nDESCRIPTION: This snippet displays the error message produced by the lexer when attempting to process the sample input. It indicates a token recognition error at the beginning of the input string.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/EnforcedGreedyNestedBraces_2.txt#2025-04-21_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nline 1:0 token recognition error at: '{ { }'\n```\n\n----------------------------------------\n\nTITLE: Simple ANTLR4 Grammar Rule Definition\nDESCRIPTION: Defines a grammar rule 'a' that matches zero or more occurrences of 'a' or 'b' followed by 'c', with an embedded action to write the input text. The grammar includes main rule definition, parser type specification, and start rule designation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/StarSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ('a'|'b')* 'c' {<InputText():writeln()>} ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 4.7.1 Exact Output Directory Example\nDESCRIPTION: Demonstrates how ANTLR4 4.7.1 generates output files in the exact specified directory using -Xexact-output-dir flag, showing file structure with tree command.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n$ cd /tmp/parrt\n$ a4.7.1 -Xexact-output-dir  -o /tmp/build src/pkg/A.g4\n$ tree /tmp/build\n/tmp/build\n├── A.tokens\n├── ABaseListener.java\n├── ALexer.java\n├── ALexer.tokens\n├── AListener.java\n└── AParser.java\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Grammar S in ANTLR4\nDESCRIPTION: This snippet defines the slave grammar 'S' as a parser grammar. It includes a rule 'a' with parameters and return values.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorInvokesDelegateRuleWithArgs.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\na[int x] returns [int y] : B {<write(\"\\\"S.a\\\"\")>} {$y=1000;} ;\n```\n\n----------------------------------------\n\nTITLE: Feature Parity Table in Markdown\nDESCRIPTION: A markdown table showing feature parity across different ANTLR target languages. The table tracks which features from the Java target have been implemented in other language targets, with the specific version numbers indicating when features were added.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/targets.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|Feature|Java|C&sharp;|Python3|JavaScript|Go|C++|Swift|PHP|Dart\n|---|---|---|---|---|---|---|---|---|---|\n|Ambiguous tree construction|4.5.1|-|-|-|-|-|-|-|-|\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar with False Predicates\nDESCRIPTION: Defines a grammar with two alternatives in rule 'a', both guarded by False() predicates. The grammar includes lexer rules for identifiers, integers, and whitespace. Due to the false predicates, no input can successfully parse.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/NoTruePredsThrowsNoViableAlt.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns : a a;\na : {<False()>}? ID INT {<writeln(\"\\\"alt 1\\\"\")>}\n  | {<False()>}? ID INT {<writeln(\"\\\"alt 2\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nINT : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Error Output\nDESCRIPTION: The error output showing token recognition failure and EOF token\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharAtStart.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,1:0='<EOF>',<-1>,1:1]\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nline 1:0 token recognition error at: 'x'\n```\n\n----------------------------------------\n\nTITLE: Manual Git Commands for Committing and Pushing Website Updates in Bash\nDESCRIPTION: These commands are used to commit and push the updated website content, including javadoc and jars, to the gh-pages branch.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/sites/website-antlr4\ngit commit -a -m 'Update website, javadoc, jars to 4.13.2'\ngit push origin gh-pages\n```\n\n----------------------------------------\n\nTITLE: Sample Input for IF-THEN-ELSE Parsing\nDESCRIPTION: This snippet provides a sample input string to test the ANTLR4 grammar. It contains nested IF-THEN-ELSE statements with potential ambiguity.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_3.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\n{ if x then if y then return else foo }\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet defines a simple ANTLR4 lexer grammar with a single rule that matches the literal 'abc'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/ErrorInMiddle.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'abc' ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet shows the input text 'ab' that will be processed by the defined lexer grammar. It's used to demonstrate how the lexer rules will tokenize the input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ReservedWordsEscaping.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nab\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar with Custom Channel and Mode in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines two tokens 'A' and 'B', with 'A' switching to a custom mode and 'B' using a custom channel. It demonstrates how to use channels and modes in ANTLR4 lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ReservedWordsEscaping.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\n\nchannels { break }\n\nA: 'a' -> mode(for);\n\nmode for;\nB: 'b' -> channel(break);\n```\n\n----------------------------------------\n\nTITLE: Building ANTLR4 Grammar without Output Directory Option\nDESCRIPTION: Shows how ANTLR respects the relative path specified in the input grammar when generating output files without an explicit output directory.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ a4.7 src/pkg/A.g4\n$ tree\n.\n├── B.g4\n└── src\n    └── pkg\n        ├── A.g4\n        ├── A.tokens\n        ├── ABaseListener.java\n        ├── ALexer.java\n        ├── ALexer.tokens\n        ├── AListener.java\n        └── AParser.java\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar S for M Language in ANTLR4\nDESCRIPTION: This snippet defines a lexer grammar named 'S' for the M language. It includes a rule for identifying identifiers consisting of lowercase letters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/KeywordVSIDOrder.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar S;\nID : 'a'..'z'+;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Parser Rule and Lexer Tokens\nDESCRIPTION: This code defines an ANTLR4 grammar named 'T' with a parser rule 'a' that matches a sequence of identifiers or numbers followed by an optional number, then writes the matched text. It includes lexer rules for identifiers (lowercase letters), numbers (digits), and whitespace (spaces or newlines).\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/ReferenceToATN_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|ATN)* ATN? {<writeln(\"$text\")>} ;\nID : 'a'..'z'+ ;\nATN : '0'..'9'+;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar Rule Definition\nDESCRIPTION: Defines a simple grammar rule 'a' that matches a pattern starting with 'a', followed by zero or more 'b's, and ending with 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionDuringLoop.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' 'b'* 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This code snippet provides a sample input string to test the lexer grammar. It contains a quoted string enclosed in square brackets.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/StringsEmbeddedInActions_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n[\"foo\"]\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar with Unicode Character Support\nDESCRIPTION: Defines a grammar rule that matches sequences of characters including ASCII 'a', German umlaut 'ä', Japanese hiragana 'あ', and kanji '亜' followed by 'c'. The grammar uses escaped Unicode values and includes an action to print the matched text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeEscapedBMPSet.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : LETTERS {<InputText():writeln()>} ;\n// Note the double-backslash to avoid Java passing\n// unescaped values as part of the grammar.\nLETTERS : ('a'|'\\\\u00E4'|'\\\\u4E9C'|'\\\\u3042')* 'c';\n```\n\n----------------------------------------\n\nTITLE: Sample Test Descriptor Format\nDESCRIPTION: Example of an ANTLR test descriptor file showing the structure and format for defining grammar tests\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/antlr-project-testing.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n[notes]\nThis is a regression test for blah blah blah...\n\n[type]\nParser\n\n[grammar]\ngrammar T;\na : ID* {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nWS : (' '|'\\n') -> skip;\n\n[start]\na\n\n[input]\na b c\n\n[output]\n\"\"\"abc\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Labeled Rules\nDESCRIPTION: Grammar definition that tests label functionality with compound operators. Includes parser rules for expressions with multiplication, compound send operation with multiple expressions, and simple identifier matching.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr (',' b+=expr)* '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n;\n\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\n\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Error Message for Unrecognized Input\nDESCRIPTION: This snippet shows the error message generated by the lexer when it encounters input that doesn't match any defined rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/ErrorInMiddle.txt#2025-04-21_snippet_3\n\nLANGUAGE: Plain Text\nCODE:\n```\nline 1:0 token recognition error at: 'abx'\n```\n\n----------------------------------------\n\nTITLE: Slave Parser Grammar Definition (Grammar S)\nDESCRIPTION: Secondary parser grammar that defines rule 'a' with a semantic action to initialize variable 'x' to '0' after matching token B.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/ImportedRuleWithAction.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\na @after {<InitIntVar(\"x\",\"0\")>} : B;\n```\n\n----------------------------------------\n\nTITLE: Adding ANTLR4 Swift Runtime as Package Dependency\nDESCRIPTION: Swift Package Manager code snippet for adding ANTLR4 as a dependency in a Package.swift file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_6\n\nLANGUAGE: swift\nCODE:\n```\n.package(url: \"https://github.com/antlr/antlr4\", from: \"4.13.2\")\n```\n\n----------------------------------------\n\nTITLE: Deploying Python Runtime to PyPI\nDESCRIPTION: These commands build and upload the Python runtime package to PyPI using twine.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4/runtime/Python3\npython -m build\n# assume you have ~/.pypirc set up\ntwine upload dist/antlr4_python3_runtime-4.13.2.tar.gz dist/antlr4_python3_runtime-4.13.2-py3-none-any.whl\n```\n\n----------------------------------------\n\nTITLE: Parser Decision Analysis Output\nDESCRIPTION: Decision analysis output showing the state transitions and context sensitivity for the 'else' token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nDecision 1:\ns0-'else'->:s1^=>1\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Lexical Analysis\nDESCRIPTION: This snippet shows a sample input string 'abc' for lexical analysis using the defined grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeLexers/LexerDelegatorInvokesDelegateRule.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\nabc\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet defines a simple ANTLR4 lexer grammar named 'L' with a single rule 'A' that matches the sequence 'ab'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharAtStartAfterDFACache.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'a' 'b' ;\n```\n\n----------------------------------------\n\nTITLE: Defining NULL Keyword Lexer Rule in ANTLR4\nDESCRIPTION: This code snippet defines a lexer rule for matching the NULL keyword in a case-insensitive manner using ANTLR4 grammar syntax. It allows for variations in capitalization of each letter in the word 'NULL'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ReservedWordsEscaping_NULL.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\n\nNULL : ('N' | 'n')('U' | 'u')('L' | 'l')('L' | 'l') ;\n```\n\n----------------------------------------\n\nTITLE: Building ANTLR4 without Running Tests\nDESCRIPTION: Command to build ANTLR4 using Maven while skipping the test phase to save time.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/building-antlr.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ mvn -DskipTests install\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Grammar Rule in ANTLR4\nDESCRIPTION: Defines a grammar rule 'a' that matches 'a' followed by zero or more 'b's, and ending with 'c'. This grammar is named 'T'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/MultiTokenDeletionDuringLoop.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' 'b'* 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar Rule\nDESCRIPTION: This snippet defines a basic ANTLR4 grammar with a single rule 'a' that expects the sequence 'ab'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletion.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' 'b' ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Lexer Testing\nDESCRIPTION: Provides test input containing two integer literals separated by whitespace to demonstrate lexer functionality.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetPlus.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n34\n 34\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Unicode Character Support\nDESCRIPTION: This ANTLR4 grammar defines a rule 'a' that matches zero or more LETTERS followed by 'd'. The LETTERS token includes both the lowercase 'a' and a range of Unicode characters (emojis). The grammar also includes a custom action to write the input text.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeEscapedSMPRangeSetMismatch.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : LETTERS* 'd' {<InputText():writeln()>} ;\n// Note the double-backslash to avoid Java passing\n// unescaped values as part of the grammar.\nLETTERS : ('a'|'\\\\u{1F600}'..'\\\\u{1F943}');\n```\n\n----------------------------------------\n\nTITLE: Slave Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a slave parser grammar S that provides rule 'a' which references token B from the master grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/ImportedGrammarWithEmptyOptions.txt#2025-04-21_snippet_1\n\nLANGUAGE: antlr4\nCODE:\n```\nparser grammar S;\noptions {}\na : B ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR Grammar with Parser Property Actions\nDESCRIPTION: This ANTLR grammar defines a simple rule 'a' that uses parser property member and call actions. It includes a lexer rule for ID and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/ParserProperty.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\n<ParserPropertyMember()>\na : {<ParserPropertyCall({$parser}, \"Property()\")>}? ID {<writeln(\"\\\"valid\\\"\")>}\n  ;\nID : 'a'..'z'+ ;\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Grammar 'S' in ANTLR4\nDESCRIPTION: This snippet defines the slave parser grammar 'S' which is imported by the main grammar 'M'. It includes a rule for 'a' with an embedded action.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorInvokesDelegateRule.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\na : B {<writeln(\"\\\"S.a\\\"\")>};\n```\n\n----------------------------------------\n\nTITLE: Specifying Start Rule and Test Input for M Grammar\nDESCRIPTION: This section specifies the start rule for the grammar and provides a test input for parsing. The start rule is 'prog', and the test input is a float declaration with initialization.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesLookaheadInDelegate.txt#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR4\nCODE:\n```\n[start]\nprog\n```\n\nLANGUAGE: ANTLR4\nCODE:\n```\n[input]\nfloat x = 3;\n```\n\n----------------------------------------\n\nTITLE: Simple ANTLR4 Grammar with Optional ID/INT Pattern\nDESCRIPTION: Defines a grammar named T with a single parser rule 'a' that optionally matches an identifier or integer, followed by writing the matched text. Includes lexer rules for ID, INT, and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/LL1OptionalBlock_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|{}INT)? {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Lexer Testing\nDESCRIPTION: Test input string containing positive and negative integers separated by spaces.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RefToRuleDoesNotSetTokenNorEmitAnother.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n34 -21 3\n```\n\n----------------------------------------\n\nTITLE: Maven Local Repository Installation\nDESCRIPTION: Bash commands to install ANTLR artifacts into the local Maven repository\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/antlr-project-testing.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ export MAVEN_OPTS=\"-Xmx1G\"  # don't forget this on linux\n$ mvn install -DskipTests     # make sure all artifacts are visible on this machine\n```\n\n----------------------------------------\n\nTITLE: Specifying Start Rule for ANTLR4 Parser\nDESCRIPTION: Defines the entry point for the parser by specifying 'start' as the rule to begin parsing from.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/DuplicatedLeftRecursiveCall_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nstart\n```\n\n----------------------------------------\n\nTITLE: Windows Batch Files for ANTLR4 and TestRig\nDESCRIPTION: Content for Windows batch files to create shortcuts for running the ANTLR tool and TestRig GUI, making it easier to use ANTLR on Windows systems.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/getting-started.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\njava org.antlr.v4.Tool %*\n```\n\nLANGUAGE: bash\nCODE:\n```\n@ECHO OFF\nSET TEST_CURRENT_DIR=%CLASSPATH:.;=%\nif \"%TEST_CURRENT_DIR%\" == \"%CLASSPATH%\" ( SET CLASSPATH=.;%CLASSPATH% )\n@ECHO ON\njava org.antlr.v4.gui.TestRig %*\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer\nDESCRIPTION: This snippet shows the input text 'abax' that will be processed by the lexer.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharInTokenAfterDFACache.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nabax\n```\n\n----------------------------------------\n\nTITLE: Defining String Token Rule in ANTLR4 Lexer Grammar\nDESCRIPTION: This ANTLR4 lexer grammar defines a STRING token rule. It matches strings that start and end with an exclamation mark, allowing double exclamation marks or any other character in between.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyTermination2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nSTRING : '!' ('!!' | .)+? '!';\n```\n\n----------------------------------------\n\nTITLE: Performing ANTLR4 Release with Maven\nDESCRIPTION: This command performs the actual release of ANTLR4, deploying artifacts to the repository and pushing changes to the version control system.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmvn release:perform -Darguments=\"-DskipTests\"\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar for 'u' Rule\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'u' with a single rule that matches the literal 'u' and writes the matched text using a custom action.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/uStartingCharDoesNotCauseIllegalUnicodeEscape.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar u;\nu : 'u' {<writeln(\"$text\")>};\n```\n\n----------------------------------------\n\nTITLE: Defining Catchall Lexer Rule for Fuzzy Parsing in ANTLR4\nDESCRIPTION: This ANTLR4 lexer rule acts as a catchall to match any character not matched by another lexer rule, essential for fuzzy parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_6\n\nLANGUAGE: antlr\nCODE:\n```\nOTHER : . -> skip ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Parsing Error Output\nDESCRIPTION: This snippet displays the parsing error message generated when trying to parse the input 'ae' with the defined grammar. The error indicates that there is no viable alternative for parsing the input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LL2.txt#2025-04-21_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nline 1:1 no viable alternative at input 'ae'\n```\n\n----------------------------------------\n\nTITLE: Test Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet provides a test input string for the lexer grammar. It contains a simple string enclosed in single quotes.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ZeroLengthToken.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n'xxx'\n```\n\n----------------------------------------\n\nTITLE: ANTLR Grammar Rule with Unicode Emoji Exclusion\nDESCRIPTION: Defines a grammar rule that matches text starting with 'a', followed by characters not in the emoji Unicode range, and ending with 'c'. Includes an action to write the matched input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeNegatedSMPSetIncludesBMPCodePoints.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : LETTERS {<InputText():writeln()>} ;\nLETTERS : 'a' ~('\\u{1F600}'..'\\u{1F943}')+ 'c';\n```\n\n----------------------------------------\n\nTITLE: Expected Parse Tree Output\nDESCRIPTION: Expected parse tree output showing correct right-associative interpretation of the nested conditional expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExprExplicitAssociativity_9.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n(s (e (e a) ? (e b) : (e (e c) ? (e d) : (e e))) <EOF>)\n```\n\n----------------------------------------\n\nTITLE: Create Go Release Tags\nDESCRIPTION: Commands to create and push Go-specific version tags with 'v' prefix.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -a runtime/Go/antlr/v4/v4.13.2 -m \"Go runtime module only\"\ngit push upstream runtime/Go/antlr/v4/v4.13.2\ngit push origin runtime/Go/antlr/v4/v4.13.2\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output\nDESCRIPTION: Shows the token output generated by the lexer, including token types, positions, and line numbers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetInSet.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nI\nI\n[@0,0:0='a',<1>,1:0]\n[@1,2:2='x',<1>,1:2]\n[@2,3:2='<EOF>',<-1>,1:3]\n```\n\n----------------------------------------\n\nTITLE: Defining Main Lexer Grammar in ANTLR4\nDESCRIPTION: This snippet defines the main lexer grammar 'M' which imports the slave grammar 'S'. It includes rules for tokens 'B' and 'WS'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeLexers/LexerDelegatorInvokesDelegateRule.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar M;\nimport S;\nB : 'b';\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input Text Processing\nDESCRIPTION: Sample input string used to test the lexer grammar, containing multiple potential matches for rule A.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/DFAToATNThatFailsBackToDFA.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nababx\n```\n\n----------------------------------------\n\nTITLE: Converting Between Code Point Indices and UTF-16 Indices in Java\nDESCRIPTION: Utility class to convert between code point indices (used by ANTLR 4.7+ streams) and UTF-16 code unit indices (used by Java String APIs). This is necessary when working with surrogate pairs in Unicode strings.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/unicode.md#2025-04-21_snippet_7\n\nLANGUAGE: java\nCODE:\n```\npublic final class CodePointCounter {\n  private final String input;\n  public int inputIndex = 0;\n  public int codePointIndex = 0;\n  \n  public int advanceToIndex(int newCodePointIndex) {\n    assert newCodePointIndex >= codePointIndex;\n    while (codePointIndex < newCodePointOffset) {\n        int codePoint = Character.codePointAt(input, inputIndex);\n        inputIndex += Character.charCount(codePoint);\n        codePointIndex++;\n    }\n    return inputIndex;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing the New Go Runtime Module\nDESCRIPTION: Command to install the ANTLR Go runtime from its new repository location using the Go module system.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-changes.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo get github.com/antlr4-go/antlr\n```\n\n----------------------------------------\n\nTITLE: Setting Up ANTLR4 C++ Runtime Include Directories in CMake\nDESCRIPTION: Defines the include directories for the ANTLR4 C++ runtime library. These directories contain various components of the runtime such as ATN, DFA, and tree-related functionality.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(libantlrcpp_INCLUDE_INSTALL_DIR \"include/antlr4-runtime\")\n\nset(libantlrcpp_INCLUDE_DIRS\n  ${PROJECT_SOURCE_DIR}/runtime/src\n  ${PROJECT_SOURCE_DIR}/runtime/src/atn\n  ${PROJECT_SOURCE_DIR}/runtime/src/dfa\n  ${PROJECT_SOURCE_DIR}/runtime/src/internal\n  ${PROJECT_SOURCE_DIR}/runtime/src/misc\n  ${PROJECT_SOURCE_DIR}/runtime/src/support\n  ${PROJECT_SOURCE_DIR}/runtime/src/tree\n  ${PROJECT_SOURCE_DIR}/runtime/src/tree/pattern\n  ${PROJECT_SOURCE_DIR}/runtime/src/tree/xpath\n)\n```\n\n----------------------------------------\n\nTITLE: Test Input for Label Grammar\nDESCRIPTION: Sample input string to test the grammar's handling of compound operators and labels.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\na,c>>x\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Error Output\nDESCRIPTION: Shows the error output when the lexer encounters invalid input that doesn't match the defined rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharInToken.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,2:1='<EOF>',<-1>,1:2]\nline 1:0 token recognition error at: 'ax'\n```\n\n----------------------------------------\n\nTITLE: Updating and Merging Git Branches for ANTLR Development in Bash\nDESCRIPTION: This series of Git commands updates the master and dev branches, merges master into dev, and pushes the changes to both origin and upstream repositories.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout master\ngit pull upstream master\ngit checkout dev\ngit pull upstream dev\ngit merge master\ngit push origin dev\ngit push upstream dev\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer\nDESCRIPTION: This is an example input string to be processed by the lexer. It contains a string token '!!!mom!' that matches the defined STRING rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyTermination2.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\n!!!mom!\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Grammar S in ANTLR4\nDESCRIPTION: This snippet defines the slave grammar 'S' as a parser grammar. It includes a rule 'a' with a specific parsing action.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/BringInLiteralsFromDelegate.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\na : '=' 'a' {<write(\"\\\"S.a\\\"\")>};\n```\n\n----------------------------------------\n\nTITLE: Renaming and Updating Test File for ANTLR4 Project\nDESCRIPTION: Commands to rename the default Maven test file and update its contents to match the new class name.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/java-target.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npushd src/test/java/org/abcd/examples/ArrayInit\nmv AppTest.java ArrayInitTest.java\nsed 's/App/ArrayInit/g' ArrayInitTest.java >ArrayInitTest.java.tmp\nmv ArrayInitTest.java.tmp ArrayInitTest.java\npopd\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C# Context-Sensitive Token Parsing\nDESCRIPTION: Example of C# code showing how '>>' can be interpreted differently depending on context: as a right shift operator (which doesn't allow spaces) or as part of nested template declarations (which allows spaces).\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/target-agnostic-grammars.md#2025-04-21_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass Foo {\n\tvoid Func()\n\t{\n\t\tint x = 1000 > > 2;               // syntax error if a space exists in the double greater-than sign\n\t}\n\tDictionary<int, List<int> > mapping;  // nested template declaration, valid\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar Rule for Simple Language\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with a single rule 'a'. The rule matches 'a' followed by zero or more 'b' or 'z' (with an action), and ends with 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionDuringLoop2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' ('b'|'z'{<Pass()>})* 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining Quote Token in ANTLR Lexer Grammar\nDESCRIPTION: Defines a lexer grammar named 'L' with a single token rule QUOTE that matches a double quote character. Includes a comment to ensure compilation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/QuoteTranslation.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar L;\nQUOTE : '\"' ; // make sure this compiles\n```\n\n----------------------------------------\n\nTITLE: Expected Output from ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet shows the expected output after processing the input 'ab' through the defined lexer grammar. It includes the matched token and EOF token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyConfigs.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nab\n[@0,0:1='ab',<1>,1:0]\n[@1,2:1='<EOF>',<-1>,1:2]\n```\n\n----------------------------------------\n\nTITLE: Specifying Start Rule for ANTLR4 Parser\nDESCRIPTION: Defines 'a' as the start rule for the parser, indicating which rule should be used as the entry point for parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleSetInsertion.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Building ANTLR with Maven\nDESCRIPTION: Command to compile ANTLR using Maven, which is a necessary first step before creating a new language target.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/creating-a-language-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ mvn compile\n```\n\n----------------------------------------\n\nTITLE: Compiling and Testing Action Tokens Grammar in ANTLR4\nDESCRIPTION: This bash script shows how to compile and test the Actions grammar using ANTLR4 tools and grun, demonstrating different token recognition behaviors.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/wildcard.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 Actions.g4\n$ javac Actions*.java\n$ grun Actions tokens -tokens\n=> \t{\"foo}\n=> \tEOF\n<= \t[@0,0:5='{\"foo}',<1>,1:0]\n \t[@1,7:6='<EOF>',<-1>,2:0]\n=> \t$ grun Actions tokens -tokens\n=> \t[\"foo]\n=> \tEOF\n<= \tline 1:0 token recognition error at: '[\"foo]\n \t'\n \t[@0,7:6='<EOF>',<-1>,2:0]\n=> \t$ grun Actions tokens -tokens\n=> \t<\"foo>\n=> \tEOF\n<= \tline 1:0 token recognition error at: '<\"foo>\n \t'\n \t[@0,7:6='<EOF>',<-1>,2:0]\n```\n\n----------------------------------------\n\nTITLE: Defining Source Files for ANTLR4 Demo in CMake\nDESCRIPTION: Sets up the list of source files for the ANTLR4 demo project, including the main cpp file and the previously defined generated source files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nset(antlr4-demo_SRC \n  ${PROJECT_SOURCE_DIR}/demo/Linux/main.cpp\n  ${antlr4-demo-GENERATED_SRC}\n  )\n```\n\n----------------------------------------\n\nTITLE: Setting Generated File Properties in CMake\nDESCRIPTION: Marks the generated source files as GENERATED to inform CMake that these files will be created during the build process. This prevents CMake from searching for these files before they are generated.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nforeach(src_file ${antlr4-demo-GENERATED_SRC})\n      set_source_files_properties(\n          ${src_file}\n          PROPERTIES\n          GENERATED TRUE\n          )\nendforeach(src_file ${antlr4-demo-GENERATED_SRC})\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Output for Sample Input\nDESCRIPTION: This snippet shows the lexer output for the given sample input. Each token is represented as a tuple containing its index, text, type, line, and column information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/HexVsID.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\n[@0,0:0='x',<5>,1:0]\n[@1,1:1=' ',<6>,1:1]\n[@2,2:2='0',<2>,1:2]\n[@3,3:3=' ',<6>,1:3]\n[@4,4:4='1',<2>,1:4]\n[@5,5:5=' ',<6>,1:5]\n[@6,6:6='a',<5>,1:6]\n[@7,7:7='.',<4>,1:7]\n[@8,8:8='b',<5>,1:8]\n[@9,9:9=' ',<6>,1:9]\n[@10,10:10='a',<5>,1:10]\n[@11,11:11='.',<4>,1:11]\n[@12,12:12='l',<5>,1:12]\n[@13,13:12='<EOF>',<-1>,1:13]\n```\n\n----------------------------------------\n\nTITLE: Lexer Output for Nested Action Input\nDESCRIPTION: This snippet shows the lexer output for the given input. It demonstrates how the lexer tokenizes the nested curly braces as a single ACTION token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/EnforcedGreedyNestedBraces_1.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\n[@0,0:6='{ { } }',<1>,1:0]\n[@1,7:6='<EOF>',<-1>,1:7]\n```\n\n----------------------------------------\n\nTITLE: Defining Expression Grammar in ANTLR4\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions including logical operations, parentheses, and ternary expressions. It includes lexer rules for identifiers and whitespace.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar Expr;\n\nstat : expr ';'\n     | expr '.'\n     ;\n\nexpr\n   : ID\n   | 'not' expr\n   | expr 'and' expr\n   | expr 'or' expr\n   | '(' ID ')' expr\n   | expr '?' expr ':' expr\n   | 'between' expr 'and' expr\n   ;\n\nID: [a-zA-Z_][a-zA-Z_0-9]*;\nWS: [ \\t\\n\\r\\f]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Specifying Start Rule and Input for ANTLR4 Grammar\nDESCRIPTION: This snippet defines the start rule for the grammar and provides a sample input string to be parsed. It demonstrates how to use the grammar with a simple expression.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\n[start]\ns\n\n[input]\na*b\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Labeled Rules and Compound Operators\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing expressions, including multiplication, a compound send operation, and identifier recognition. It uses labels to reference parts of rules and demonstrates a custom operator using ',' and '>>'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : expr EOF;\nexpr:\n    a=expr '*' a=expr #Factor\n    | b+=expr (',' b+=expr)* '>>' c=expr #Send\n    | ID #JustId //semantic check on modifiers\n;\n\nID  : ('a'..'z'|'A'..'Z'|'_')\n      ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*\n;\n\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Parser Grammar T Definition\nDESCRIPTION: Slave parser grammar 'T' defining rule 'a' that matches token B with an action to write output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorInvokesFirstVersionOfDelegateRule.txt#2025-04-21_snippet_1\n\nLANGUAGE: antlr4\nCODE:\n```\nparser grammar T;\na : B {<writeln(\"\\\"T.a\\\"\")>};<! hidden by S.a !>\n```\n\n----------------------------------------\n\nTITLE: Deploying C++ Runtime Source\nDESCRIPTION: These commands package the C++ runtime source code and copy the resulting zip file to the website download directory.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4/runtime/Cpp\n./deploy-source.sh\ncp antlr4-cpp-runtime-source.zip ~/antlr/sites/website-antlr4/download/antlr4-cpp-runtime-4.13.2-source.zip\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Grammar Definition with Parser Rules\nDESCRIPTION: Defines a grammar 'T' with parser rules for handling identifiers and enum keywords. Includes initialization of a boolean member 'enumKeyword' and custom output formatting for matched tokens.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/PredTestedEvenWhenUnAmbig_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n@parser::members {<InitBooleanMember(\"enumKeyword\",True())>}\nprimary\n    :   ID {<AppendStr(\"\\\"ID \\\"\", \"$ID.text\"):writeln()>}\n    |   {<GetMember(\"enumKeyword\"):Not()>}? 'enum' {<writeln(\"\\\"enum\\\"\")>}\n    ;\nID : [a-z]+ ;\nWS : [ \\t\\n\\r]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Specifying Start Rule for ANTLR Grammar\nDESCRIPTION: This snippet specifies the start rule for the ANTLR grammar. In this case, the parsing should begin with the 'a' rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeNegatedBMPSetIncludesSMPCodePoints.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar\nDESCRIPTION: This snippet defines a basic ANTLR4 grammar with two rules. The first rule 'a' matches either 'b' or 'c', while the second rule 'q' matches 'a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionBeforeAlt.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : ('b' | 'c')\n;\nq : 'a'\n;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Nested Action Lexer\nDESCRIPTION: This snippet provides a sample input string containing nested curly braces to test the lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/EnforcedGreedyNestedBraces_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\n{ { } }\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Shared Library Integration\nDESCRIPTION: Example of building and linking ANTLR4 shared library to a target with runtime library copying.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/README.md#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(ExternalAntlr4Cpp)\ninclude_directories(${ANTLR4_INCLUDE_DIRS})\nadd_executable(output main.cpp)\ntarget_link_libraries(output antlr4_shared)\nadd_custom_command(TARGET output\n                   POST_BUILD\n                   COMMAND ${CMAKE_COMMAND}\n                           -E copy ${ANTLR4_RUNTIME_LIBRARIES} .\n                   WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})\n```\n\n----------------------------------------\n\nTITLE: Simple ANTLR4 Grammar with Action\nDESCRIPTION: Defines a grammar named T with a single parser rule 'a' and lexer rule 'A'. The parser rule contains an embedded action to write the input text. Rule A matches zero or more 'b' characters followed by a 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/StarLexerSingleElement_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: antlr4\nCODE:\n```\ngrammar T;\na : A {<InputText():writeln()>} ;\nA : 'b'* 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Test Input for Expression Parsing\nDESCRIPTION: This is a test input designed to demonstrate the performance issue. It consists of a long chain of 'and' and 'or' operations with multiple repetitions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7\n.\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Flags for ANTLR4 Demo in CMake\nDESCRIPTION: Sets compiler-specific flags for the ANTLR4 demo project. It uses different flags for MSVC and other compilers to suppress warnings and enable multi-process compilation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n  set (flags_1 \"-Wno-overloaded-virtual\")\nelse()\n  set (flags_1 \"-MP /wd4251\")\nendif()\n\nforeach(src_file ${antlr4-demo_SRC})\n      set_source_files_properties(\n          ${src_file}\n          PROPERTIES\n          COMPILE_FLAGS \"${COMPILE_FLAGS} ${flags_1}\"\n          )\nendforeach(src_file ${antlr4-demo_SRC})\n```\n\n----------------------------------------\n\nTITLE: Configuring CLASSPATH for Mac/Linux\nDESCRIPTION: Correct CLASSPATH configuration for Mac/Linux systems that includes the current directory (.) and ANTLR jar file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/installation.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nexport CLASSPATH=\".:/usr/local/lib/antlr-4.2.2-complete.jar:$CLASSPATH\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Input Test\nDESCRIPTION: Test input that doesn't match the defined lexer rule, triggering an error\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharAtStart.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nx\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Token Output\nDESCRIPTION: Token stream output showing how the lexer processes the input, including token types, text content, and position information for each matched token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardPlus_1.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:8='/* ick */',<1>,1:0]\n[@1,9:9='\\n',<2>,1:9]\n[@2,10:34='/* /* */\\n/* /*nested*/ */',<1>,2:0]\n[@3,35:35='\\n',<2>,3:16]\n[@4,36:35='<EOF>',<-1>,4:0]\n```\n\n----------------------------------------\n\nTITLE: Test Input for Large Expression Parsing\nDESCRIPTION: This input demonstrates a large expression that caused performance issues in parsing. It consists of multiple 'and' and 'or' operations with numerous variables.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7 or\nX1 and X2 and X3 and X4 and X5 and X6 and X7\n;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer\nDESCRIPTION: This snippet shows the input provided to the lexer, which doesn't match the defined rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/ErrorInMiddle.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\nabx\n```\n\n----------------------------------------\n\nTITLE: Expected Output from ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet shows the expected output when processing the sample input with the defined lexer grammar. It indicates that only the end-of-file token was recognized.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/StringsEmbeddedInActions_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\n[@0,6:5='<EOF>',<-1>,1:6]\n```\n\n----------------------------------------\n\nTITLE: File Path List for ANTLR4 Version Updates\nDESCRIPTION: List of file paths that contain ANTLR version numbers that need to be updated during releases. The list is generated using find and grep commands to locate files containing version strings. Files marked with '*' allow multiple version number changes within the same file.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/scripts/files-to-update.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ndocker/Dockerfile\nruntime/Go/antlr/v4/recognizer.go\nruntime/Go/antlr/v4/antlrdoc.go\nruntime/Python3/pyproject.toml\nruntime/Python3/src/antlr4/Recognizer.py\nruntime/Dart/pubspec.yaml\nruntime/Dart/lib/src/runtime_meta_data.dart\nruntime/Java/src/org/antlr/v4/runtime/RuntimeMetaData.java\nruntime/Cpp/CPackConfig.cmake\nruntime/Cpp/demo/generate.cmd\nruntime/Cpp/cmake/Antlr4Package.md\nruntime/Cpp/cmake/README.md\nruntime/Cpp/cmake/ExternalAntlr4Cpp.cmake\nruntime/Cpp/cmake/FindANTLR.cmake\nruntime/Cpp/runtime/src/Version.h\nruntime/Cpp/runtime/cmake_install.cmake\nruntime/Cpp/VERSION\nruntime/Swift/Sources/Antlr4/RuntimeMetaData.swift\nruntime/CSharp/src/README.md\nruntime/CSharp/src/Properties/AssemblyInfo.cs\nruntime/CSharp/src/Antlr4.csproj\nruntime/JavaScript/package-lock.json\nruntime/JavaScript/package.json\nruntime/JavaScript/src/antlr4/Recognizer.js\nruntime/JavaScript/spec/rewriter/Makefile\nruntime-testsuite/resources/org/antlr/v4/test/runtime/helpers/package_ts.json\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Output for Sample Input\nDESCRIPTION: This code snippet shows the lexer output for the given sample input. It demonstrates how the lexer tokenizes the input string, identifying it as an ACTION2 token followed by the end of file (EOF) marker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/StringsEmbeddedInActions_1.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:6='[\"foo\"]',<1>,1:0]\n[@1,7:6='<EOF>',<-1>,1:7]\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet shows a sample input for the defined lexer grammar. It contains two single-line comments, which will be matched by the CMT rule in the grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyClosure.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n//blah\n//blah\n```\n\n----------------------------------------\n\nTITLE: Defining Simple Grammar in ANTLR4\nDESCRIPTION: A basic ANTLR4 grammar named 'T' that defines a rule 'a' which accepts 'a' followed by zero or more 'b's and ending with EOF. This grammar is being tested against an invalid input to demonstrate error handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionBeforeLoop.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' 'b'* EOF ;\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Grammar S in ANTLR4\nDESCRIPTION: This snippet defines the slave grammar 'S' as a parser grammar. It includes rules for parsing 'a' and 'b'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesDelegates.txt#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\na : b {<writeln(\"\\\"S.a\\\"\")>};\nb : 'b' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Test Input\nDESCRIPTION: Sample input string to test the lexer grammar rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetNot.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nxaf\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Parameterized Rule for Testing Element+ Issue\nDESCRIPTION: An ANTLR4 grammar definition that tests handling of the '+' repetition operator in expression rules. The grammar includes a parameterized rule e with precedence handling and alternatives containing the '+' operator within a nested expression.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalParser/AtomWithClosureInTranslatedLRRule.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nstart : e[0] EOF;\ne[int _p]\n    :   ( 'a' | 'b'+ ) ( {3 >= $_p}? '+' e[4] )*\n    ;\n```\n\n----------------------------------------\n\nTITLE: Lexer Error Output\nDESCRIPTION: Error messages indicating unrecognized 'x' characters in the input that don't match any token rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardPlus_2.txt#2025-04-21_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nline 1:9 token recognition error at: 'x'\nline 3:16 token recognition error at: 'x'\n```\n\n----------------------------------------\n\nTITLE: Parser Compilation Error Due to Missing Runtime\nDESCRIPTION: Compilation error when the ANTLR runtime library is missing from the CLASSPATH, showing missing package errors.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/installation.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n/tmp $ javac Hello*.java\nHelloBaseListener.java:3: package org.antlr.v4.runtime does not exist\nimport org.antlr.v4.runtime.ParserRuleContext;\n                           ^\n...\n```\n\n----------------------------------------\n\nTITLE: Build Type Configuration\nDESCRIPTION: Configures build type settings with a fallback to Release mode if not specified.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nif(NOT CMAKE_BUILD_TYPE)\n  message(WARNING \"Build type not set, falling back to Release mode.\n To specify build type use:\n -DCMAKE_BUILD_TYPE=<mode> where <mode> is Debug or Release.\")\n  set(CMAKE_BUILD_TYPE \"Release\" CACHE STRING\n       \"Choose the type of build, options are: Debug Release.\"\n       FORCE)\nendif(NOT CMAKE_BUILD_TYPE)\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Parser Error Output\nDESCRIPTION: Error message generated by ANTLR4 parser when encountering invalid input 'aac'. Shows position and expected token information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/MultiTokenDeletionBeforeLoop.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nline 1:1 extraneous input 'a' expecting {'b', 'c'}\n```\n\n----------------------------------------\n\nTITLE: Test Input for Comment Lexer\nDESCRIPTION: Sample input text containing various comment patterns including a simple comment, attempted nested comment, and a nested comment structure.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardPlus_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n/* ick */x\n/* /* */x\n/* /*nested*/ */x\n```\n\n----------------------------------------\n\nTITLE: Lexer Token Output\nDESCRIPTION: Token stream output showing recognized comments and whitespace tokens, along with their positions and types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardStar_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:8='/* ick */',<1>,1:0]\n[@1,10:10='\\n',<2>,1:10]\n[@2,11:36='/* /* */x\\n/* /*nested*/ */',<1>,2:0]\n[@3,38:38='\\n',<2>,3:17]\n[@4,39:38='<EOF>',<-1>,4:0]\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer\nDESCRIPTION: This snippet provides a sample input string to be processed by the defined lexer grammar. It includes various literals and identifiers to test the lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/HexVsID.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\nx 0 1 a.b a.l\n```\n\n----------------------------------------\n\nTITLE: Lexer Token Output\nDESCRIPTION: Generated token stream showing how the lexer processes the input. Each token includes position information, matched text, token type, and line/column numbers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyOptional.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[@0,0:6='//blah\\n',<1>,1:0]\n[@1,7:13='//blah\\n',<1>,2:0]\n[@2,14:13='<EOF>',<-1>,3:0]\n```\n\n----------------------------------------\n\nTITLE: Setting Custom Mode for ACE Editor\nDESCRIPTION: This snippet demonstrates how to set a custom mode for the ACE Editor after initializing it.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/ace-javascript-target.md#2025-04-21_snippet_2\n\nLANGUAGE: xml\nCODE:\n```\n<script src=\"../js/ace/ace.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script src=\"../js/my-mode.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<script>\n    var editor = ace.edit(\"editor\");\n    editor.getSession().setMode(\"ace/mode/my-mode\");\n</script>\n```\n\n----------------------------------------\n\nTITLE: Test Input Pattern\nDESCRIPTION: Sample input string for testing the lexer grammar rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/Parentheses.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n-.-.-!\n```\n\n----------------------------------------\n\nTITLE: Configuring ANTLR4 C++ Runtime Build Options in CMake\nDESCRIPTION: Sets up build options for the ANTLR4 C++ runtime, including whether to build C++ tests, trace ATN simulation, and build shared or static libraries. It also checks that at least one of shared or static library builds is enabled.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\noption(ANTLR_BUILD_CPP_TESTS \"Build C++ tests.\" ON)\noption(TRACE_ATN \"Trace ATN simulation\" OFF)\noption(ANTLR_BUILD_SHARED \"Build the shared library of the ANTLR runtime\" ON)\noption(ANTLR_BUILD_STATIC \"Build the static library of the ANTLR runtime\" ON)\n\nif (NOT ANTLR_BUILD_SHARED AND NOT ANTLR_BUILD_STATIC)\n  message(FATAL_ERROR \"Options ANTLR_BUILD_SHARED and ANTLR_BUILD_STATIC can't both be OFF\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet provides a sample input 'ab' to test the defined lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyConfigs.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nab\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar Rule with Action\nDESCRIPTION: This snippet defines an ANTLR4 grammar named 'T' with a single rule 'a'. The rule matches a sequence 'abc' and includes an action to append a 'conjured' attribute for the 'b' token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/ConjuringUpToken.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' x='b' {<Append(\"\\\"conjured=\\\"\",\"$x\"):writeln()>} 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Simple ANTLR4 Lexer Rule Definition\nDESCRIPTION: Defines a basic lexer grammar with a single rule that matches the sequence of characters 'ab'\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharAtStart.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'a' 'b' ;\n```\n\n----------------------------------------\n\nTITLE: Slave Grammar S Definition\nDESCRIPTION: Parser grammar 'S' that defines token types and a rule for parsing token A with action\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatesSeeSameTokenType.txt#2025-04-21_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nparser grammar S;\ntokens { A, B, C }\nx : A {<writeln(\"\\\"S.x\\\"\")>};\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Testing Nested Comments\nDESCRIPTION: This input text provides examples of simple and nested comments to test the lexer grammar. It includes a single-line comment, an empty comment, and a nested comment structure.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardStar_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n/* ick */\n/* /* */\n/* /*nested*/ */\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet shows a sample input string containing a dash and a bracket character, which will be tokenized by the lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithEscapedChar.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\n\"\"\"- ] \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Delete Existing Release Tags\nDESCRIPTION: Commands to remove existing Git tags before creating new release tags.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit tag -d 4.13.2\ngit push origin :refs/tags/4.13.2\ngit push upstream :refs/tags/4.13.2\n```\n\n----------------------------------------\n\nTITLE: Expected Parser Error\nDESCRIPTION: The expected error message when parsing the input, indicating a mismatched input where an exclamation mark was expected.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/NoViableAltAvoidance.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nline 1:1 mismatched input '.' expecting '!'\n```\n\n----------------------------------------\n\nTITLE: Lexer Output Tokens\nDESCRIPTION: Token stream output showing how the input was tokenized, with each token's type, position, and line information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/DFAToATNThatFailsBackToDFA.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[@0,0:1='ab',<1>,1:0]\n[@1,2:3='ab',<1>,1:2]\n[@2,5:4='<EOF>',<-1>,1:5]\n```\n\n----------------------------------------\n\nTITLE: Parse Tree Output Format\nDESCRIPTION: Shows the expected parse tree output format for the input 'x', demonstrating the tree structure with nested parentheses notation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/Simple_1.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n(s (a x))\n```\n\n----------------------------------------\n\nTITLE: Sample Input Text\nDESCRIPTION: Example input text containing the character 'x' followed by a newline for testing the lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EscapedCharacters.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nx\n\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output\nDESCRIPTION: Shows the expected token output from the lexer, including token type, text, position information, and EOF marker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/QuoteTranslation.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[@0,0:0='\"',<1>,1:0]\n[@1,1:0='<EOF>',<-1>,1:1]\n```\n\n----------------------------------------\n\nTITLE: Test Input for Slash Pattern Lexer\nDESCRIPTION: Sample input string containing various combinations of backslash and forward slash characters to test the lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/Slashes.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n\\ / \\/ /\\\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Static Library Integration\nDESCRIPTION: Example of building and linking ANTLR4 static library to a target using ExternalAntlr4Cpp.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/README.md#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(ExternalAntlr4Cpp)\ninclude_directories(${ANTLR4_INCLUDE_DIRS})\nadd_executable(output main.cpp)\ntarget_link_libraries(output antlr4_static)\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Grammar\nDESCRIPTION: This code snippet provides a sample input to test the lexer grammar. It consists of two single-line comments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/GreedyPositiveClosure.txt#2025-04-21_snippet_1\n\nLANGUAGE: Plain Text\nCODE:\n```\n//blah\n//blah\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 DFA State Transitions\nDESCRIPTION: Shows the DFA state transitions for processing input tokens, particularly focusing on the paths for 'enum' and identifier recognition.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/SemPredEvalLexer/DisableRule.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\ns0-' '->:s5=>4\ns0-'a'->:s6=>3\ns0-'e'->:s1=>3\n:s1=>3-'n'->:s2=>3\n:s2=>3-'u'->:s3=>3\n:s6=>3-'b'->:s6=>3\n:s6=>3-'c'->:s6=>3\n```\n\n----------------------------------------\n\nTITLE: Opening Swift Runtime Directory in Finder\nDESCRIPTION: Command to open the current directory (Swift runtime) in Finder for dragging the Xcode project into your own project.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# From antlr4/runtime/Swift\nopen .\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Target for Parser Generation in CMake\nDESCRIPTION: Sets up a custom target and command to generate the parser files using the ANTLR tool. This command creates the necessary directory and invokes Java to run ANTLR with specific parameters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_custom_target(GenerateParser DEPENDS ${antlr4-demo-GENERATED_SRC})\nadd_custom_command(OUTPUT ${antlr4-demo-GENERATED_SRC}\n   COMMAND \n   ${CMAKE_COMMAND} -E make_directory ${PROJECT_SOURCE_DIR}/demo/generated/\n   COMMAND\n   \"${Java_JAVA_EXECUTABLE}\" -jar ${ANTLR_JAR_LOCATION} -Werror -Dlanguage=Cpp -listener -visitor -o ${PROJECT_SOURCE_DIR}/demo/generated/ -package antlrcpptest ${PROJECT_SOURCE_DIR}/demo/TLexer.g4 ${PROJECT_SOURCE_DIR}/demo/TParser.g4\n   WORKING_DIRECTORY \"${CMAKE_BINARY_DIR}\"\n   DEPENDS ${PROJECT_SOURCE_DIR}/demo/TLexer.g4 ${PROJECT_SOURCE_DIR}/demo/TParser.g4\n   )\n```\n\n----------------------------------------\n\nTITLE: Lexer Token Output\nDESCRIPTION: Token stream output showing how the lexer processes the input. Each token includes position information, text content, token type, and line/column numbers.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyPositiveClosure.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:6='//blah\\n',<1>,1:0]\n[@1,7:13='//blah\\n',<1>,2:0]\n[@2,14:13='<EOF>',<-1>,3:0]\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Input Sample\nDESCRIPTION: Sample input text for testing the lexer grammar, consisting of a single character 'a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EOFSuffixInFirstRule_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Lexer Error Output\nDESCRIPTION: Error message indicating unrecognized character 'x' at position 4 of line 1.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/DFAToATNThatFailsBackToDFA.txt#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nline 1:4 token recognition error at: 'x'\n```\n\n----------------------------------------\n\nTITLE: Grammar Test Input\nDESCRIPTION: Test input string that demonstrates grammar validation with invalid sequence of characters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/MultiTokenDeletionDuringLoop2.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nabaaababc\n```\n\n----------------------------------------\n\nTITLE: Lexer Error Output\nDESCRIPTION: Error messages showing unrecognized 'x' characters in the input stream.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/RecursiveLexerRuleRefWithWildcardStar_2.txt#2025-04-21_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nline 1:9 token recognition error at: 'x'\nline 3:16 token recognition error at: 'x'\n```\n\n----------------------------------------\n\nTITLE: Expected Parse Tree Output\nDESCRIPTION: The expected parse tree output showing the hierarchical structure of the parsed input with nested ternary operations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_8.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n(s (e (e a) ? (e (e b) ? (e c) : (e d)) : (e e)) <EOF>)\n```\n\n----------------------------------------\n\nTITLE: Defining Test Input for ANTLR4 Parser\nDESCRIPTION: Provides the input string 'ad' for testing the parser, which is intentionally missing the required middle token ('b' or 'c').\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleSetInsertion.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nad\n```\n\n----------------------------------------\n\nTITLE: Expected Output for ANTLR4 Lexer Grammar Test\nDESCRIPTION: This snippet shows the expected output from the ANTLR4 lexer when processing the test input. It includes token information and EOF marker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/ZeroLengthToken.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:4=''xxx'',<1>,1:0]\n[@1,5:4='<EOF>',<-1>,1:5]\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Embedded Action Tags\nDESCRIPTION: This ANTLR4 grammar named 'T' defines a rule 'a' that matches one or more occurrences of token 'A', which consists of characters in the range [AaBb]. For each match, it executes an action that writes the matched text. Whitespace is skipped during parsing.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/CharSetLiteral.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (A {<writeln(\"$A.text\")>})+ ;\nA : [AaBb] ;\nWS : (' '|'\\n')+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Sample Input Text for String Lexer\nDESCRIPTION: Example input text showing string tokens that should be recognized by the lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyTermination1.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n!hi!!mom!\n```\n\n----------------------------------------\n\nTITLE: Slave Grammar T Definition\nDESCRIPTION: Parser grammar 'T' that defines token types and a rule for parsing token A with action\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatesSeeSameTokenType.txt#2025-04-21_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nparser grammar T;\ntokens { C, B, A } // reverse order\ny : A {<writeln(\"\\\"T.y\\\"\")>};\n```\n\n----------------------------------------\n\nTITLE: Test Input for If-Then-Else Grammar\nDESCRIPTION: Sample input text testing nested if-then-else statements and return statements within curly braces.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_6.txt#2025-04-21_snippet_1\n\nLANGUAGE: plain\nCODE:\n```\n{ if x then return else foo\nif x then if y then return else foo }\n```\n\n----------------------------------------\n\nTITLE: Deploying C++ Runtime for macOS\nDESCRIPTION: These commands build and package the C++ runtime for macOS, then copy the resulting zip file to the website download directory.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4/runtime/Cpp\nrm CMakeCache.txt  # otherwise can't find some include files\n./deploy-macos.sh\ncp antlr4-cpp-runtime-macos.zip ~/antlr/sites/website-antlr4/download/antlr4-cpp-runtime-4.13.2-macos.zip\n```\n\n----------------------------------------\n\nTITLE: Using ANTLR4 Combined Grammar Parser in Java\nDESCRIPTION: This snippet shows how to use the parse method for a combined grammar file in Java. It calls the parse method with a file to parse, a grammar file, and a start rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/interpreters.md#2025-04-21_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nParseTree t = parse(\"T.om\",\n                    MantraGrammar,\n                    \"compilationUnit\");\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Grammar Definition\nDESCRIPTION: Defines a lexer grammar with rules for parsing Morse code-like patterns with specific focus on parentheses behavior. Includes rules for START_BLOCK, ID, and fragment definitions for letters and separators.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/Parentheses.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar L;\nSTART_BLOCK: '-.-.-';\nID : (LETTER SEPARATOR) (LETTER SEPARATOR)+;\nfragment LETTER: L_A|L_K;\nfragment L_A: '.-';\nfragment L_K: '-.-';\nSEPARATOR: '!';\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Parser Error Output\nDESCRIPTION: Error message generated when attempting to parse invalid input sequence 'aaae' which doesn't match any valid alternatives in rule 'a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LLStar.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nline 1:3 no viable alternative at input 'aaae'\n```\n\n----------------------------------------\n\nTITLE: ANTLR Tool Missing Class Definition Error\nDESCRIPTION: Error output when the ANTLR tool jar is missing from the CLASSPATH, showing the stack trace and class loading failure.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/installation.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n/tmp $ java org.antlr.v4.Tool Hello.g4\nException in thread \"main\" java.lang.NoClassDefFoundError: org/antlr/v4/Tool\nCaused by: java.lang.ClassNotFoundException: org.antlr.v4.Tool\n    at java.net.URLClassLoader$1.run(URLClassLoader.java:202)\n    at java.security.AccessController.doPrivileged(Native Method)\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:190)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:306)\n    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:247)\n```\n\n----------------------------------------\n\nTITLE: Specifying Start Rule for Parser T\nDESCRIPTION: This snippet specifies the start rule for the parser T, which is 'a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/NotChar.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\na\n```\n\n----------------------------------------\n\nTITLE: Parser Error Output\nDESCRIPTION: Shows the error message produced when parsing invalid input 'caaab' which violates the grammar rules by starting with 'c' instead of 'a'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionBeforePredict.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nline 1:0 extraneous input 'c' expecting 'a'\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output\nDESCRIPTION: Expected token output from the lexer showing recognition of START_BLOCK and SEPARATOR tokens with position information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/Parentheses.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[@0,0:4='-.-.-',<1>,1:0]\n[@1,5:5='!',<3>,1:5]\n[@2,6:5='<EOF>',<-1>,1:6]\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Comment Lexer\nDESCRIPTION: Example input text containing two consecutive single-line comments to test the lexer rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyPositiveClosure.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n//blah\n//blah\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Runtime Testing Notice\nDESCRIPTION: Markdown documentation explaining the purpose of automatically generated files in target subdirectories for testing purposes in development environments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/test/org/antlr/v4/test/runtime/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Runtime test mechanism\n\nThe files in the various target subdirectories were automatically generated\nand exist as a convenience so that we can test individual targets and also\ngroups of tests using the development environments like Intellij.\n```\n\n----------------------------------------\n\nTITLE: Empty Test Descriptor Template\nDESCRIPTION: Template structure for creating new ANTLR runtime tests\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/antlr-project-testing.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n[notes]\n\n[type]\n\n[grammar]\n\n[slaveGrammar]\n\n[start]\n\n[input]\n\n[output]\n\n[errors]\n\n[flags]\n\n[skip]\n```\n\n----------------------------------------\n\nTITLE: Building the ANTLR4 Docker Image from Source\nDESCRIPTION: Commands to clone the ANTLR4 repository and build the Docker image locally. This builds a platform-specific image for linux/amd64.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/docker/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/antlr/antlr4.git\ncd antlr4/docker\ndocker build -t antlr/antlr4 --platform linux/amd64 .\n```\n\n----------------------------------------\n\nTITLE: Token Type Constants Definition in Java\nDESCRIPTION: Definition of token type constants for lexer rules including EOF, A, B, C, and whitespace tokens\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatesSeeSameTokenType.txt#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\npublic static final int C=6;\npublic static final int EOF=-1;\npublic static final int B=5;\npublic static final int WS=7;\npublic static final int A=4;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 C++ Export Macro Definition\nDESCRIPTION: Example of export macro definition for DLL export/import configuration in Visual C++\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/cpp-target.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#ifdef ANTLR4CPP_EXPORTS\n  #define ANTLR4CPP_PUBLIC __declspec(dllexport)\n#else\n  #ifdef ANTLR4CPP_STATIC\n    #define ANTLR4CPP_PUBLIC\n  #else\n    #define ANTLR4CPP_PUBLIC __declspec(dllimport)\n  #endif\n#endif\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar for BailErrorStrategy Test\nDESCRIPTION: This ANTLR4 grammar defines rules for parsing a file containing items separated by semicolons. It uses the BailErrorStrategy and includes actions for initialization and tree output.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/PredictionIssue334.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nfile_ @init{\n<BailErrorStrategy()>\n}\n@after {\n<ToStringTree(\"$ctx\"):writeln()>\n}\n  :   item (SEMICOLON item)* SEMICOLON? EOF ;\nitem : A B?;\nSEMICOLON: ';';\nA : 'a'|'A';\nB : 'b'|'B';\nWS      : [ \\r\\t\\n]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Generating Swift Lexer/Parser with ANTLR4\nDESCRIPTION: Basic command to generate Swift lexer or parser code from an ANTLR grammar file. This specifies Swift as the target language.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/swift-target.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ antlr4 -Dlanguage=Swift MyGrammar.g4\n```\n\n----------------------------------------\n\nTITLE: Maven Settings Configuration\nDESCRIPTION: XML configuration for Maven settings with repository credentials and GPG signing information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<settings>\n   <servers>\n        <server>\n          <id>sonatype-nexus-staging</id>\n          <username>sonatype-username</username>\n          <password>XXX</password>\n        </server>\n        <server>\n          <id>sonatype-nexus-snapshots</id>\n          <username>sonatype-username</username>\n          <password>XXX</password>\n        </server>\n   </servers>\n    <profiles>\n            <profile>\n              <activation>\n                    <activeByDefault>false</activeByDefault>\n              </activation>\n              <properties>\n                    <gpg.keyname>UUU</gpg.keyname>\n                    <gpg.passphrase>XXX</gpg.passphrase>\n              </properties>\n            </profile>\n    </profiles>\n</settings>\n```\n\n----------------------------------------\n\nTITLE: Defining Generated Source Files for ANTLR4 Demo in CMake\nDESCRIPTION: Sets up a list of generated source files for the ANTLR4 demo project. These files are produced by the ANTLR tool and include lexer, parser, listener, and visitor components.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nset(antlr4-demo-GENERATED_SRC\n   ${PROJECT_SOURCE_DIR}/demo/generated/TLexer.cpp \n   ${PROJECT_SOURCE_DIR}/demo/generated/TParser.cpp\n   ${PROJECT_SOURCE_DIR}/demo/generated/TParserBaseListener.cpp\n   ${PROJECT_SOURCE_DIR}/demo/generated/TParserBaseVisitor.cpp\n   ${PROJECT_SOURCE_DIR}/demo/generated/TParserListener.cpp\n   ${PROJECT_SOURCE_DIR}/demo/generated/TParserVisitor.cpp\n )\n```\n\n----------------------------------------\n\nTITLE: Unchanged Variable Declaration and Initialization for Generated Recognizers\nDESCRIPTION: Shows the variable declaration and initialization pattern that doesn't require changes after the update. This pattern uses type inference and doesn't explicitly declare variable types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-changes.md#2025-04-21_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nvar lexer = parser.NewMySqlLexer(nil)\nvar p = parser.NewMySqlParser(nil)\n```\n\n----------------------------------------\n\nTITLE: Parser Test Input\nDESCRIPTION: Test input for the grammar that should produce a parsing error due to missing exclamation mark.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/NoViableAltAvoidance.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\na.\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Grammar with Multiple EOF References\nDESCRIPTION: An ANTLR4 grammar definition named 'T' that contains a parser rule 'prog' which accepts either 'x' or 'x y' followed by two explicit EOF tokens. This grammar is used to test the correct handling of multiple EOF references in parser rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/MultipleEOFHandling.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\nprog : ('x' | 'x' 'y') EOF EOF;\n```\n\n----------------------------------------\n\nTITLE: Defining Extended Pictographic Characters in Unicode\nDESCRIPTION: This code snippet defines ranges of Unicode characters classified as ExtendedPictographic. It includes various symbols, emoticons, and pictographs from different Unicode blocks.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/scripts/parse-extended-pictographic/ExtendedPictographic.txt#2025-04-21_snippet_0\n\nLANGUAGE: Unicode\nCODE:\n```\nU+2605\t; ExtendedPictographic #\t[★]\tBLACK STAR\nU+2607..U+260D\t; ExtendedPictographic #\t[☇-☍]\tLIGHTNING .. OPPOSITION\nU+260F..U+2610\t; ExtendedPictographic #\t[☏☐]\tWHITE TELEPHONE .. BALLOT BOX\nU+2612\t; ExtendedPictographic #\t[☒]\tBALLOT BOX WITH X\nU+2616..U+2617\t; ExtendedPictographic #\t[☖☗]\tWHITE SHOGI PIECE .. BLACK SHOGI PIECE\n# ... (truncated for brevity)\nU+1F6F7..U+1F6F8\t; ExtendedPictographic #\t[🛷🛸]\tSLED .. FLYING SAUCER\nU+1F6D5..U+1F6DF\t; ExtendedPictographic #\tGC=Cn\nU+1F6ED..U+1F6EF\t; ExtendedPictographic #\tGC=Cn\nU+1F6F9..U+1F6FF\t; ExtendedPictographic #\tGC=Cn\n```\n\n----------------------------------------\n\nTITLE: Setting Up PHP Target for Development\nDESCRIPTION: Commands to clone the PHP runtime repository into the correct location and install dependencies using Composer, which is necessary for testing the PHP target.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/creating-a-language-target.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b dev https://github.com/antlr/antlr-php-runtime.git runtime/PHP\ncd runtime/PHP\ncomposer install\n```\n\n----------------------------------------\n\nTITLE: Example JSON Input for ANTLR4 Parser\nDESCRIPTION: This JSON snippet serves as an example input file for the ANTLR4 parser. It contains a simple JSON object with a single key-value pair.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/dart-target.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\"a\":1}\n```\n\n----------------------------------------\n\nTITLE: Configuring ANTLR4 C++ Runtime for Unix Systems in CMake\nDESCRIPTION: Sets up threading library linkage for Unix systems to avoid runtime errors related to std::call_once usage.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif (CMAKE_HOST_UNIX)\n  find_package(Threads REQUIRED)\n\n  if (TARGET antlr4_shared)\n    target_link_libraries(antlr4_shared Threads::Threads)\n  endif()\n  if (TARGET antlr4_static)\n    target_link_libraries(antlr4_static Threads::Threads)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Slave Parser Grammar Definition\nDESCRIPTION: Defines slave parser grammar 'S' with a parser member declaration for foo() and a rule for 'a'\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorAccessesDelegateMembers.txt#2025-04-21_snippet_1\n\nLANGUAGE: antlr4\nCODE:\n```\nparser grammar S;\n@parser::members {\n<Declare_foo()>\n}\na : B;\n```\n\n----------------------------------------\n\nTITLE: Maven Deploy Commands\nDESCRIPTION: Commands to deploy ANTLR snapshot version to Maven staging server.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmvn install -DskipTests\nmvn deploy -DskipTests\n```\n\n----------------------------------------\n\nTITLE: Configuring ANTLR4 C++ Runtime Installation in CMake\nDESCRIPTION: Sets up installation targets for the ANTLR4 C++ runtime libraries and header files. It configures the installation of both shared and static libraries, as well as the header files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_8\n\nLANGUAGE: CMake\nCODE:\n```\nif (TARGET antlr4_shared)\n  install(TARGETS antlr4_shared\n          EXPORT antlr4-targets\n          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif (TARGET antlr4_static)\n  install(TARGETS antlr4_static\n          EXPORT antlr4-targets\n          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\ninstall(DIRECTORY \"${PROJECT_SOURCE_DIR}/runtime/src/\"\n        DESTINATION \"${libantlrcpp_INCLUDE_INSTALL_DIR}\"\n        COMPONENT dev\n        FILES_MATCHING PATTERN \"*.h\"\n        )\n```\n\n----------------------------------------\n\nTITLE: Lexer Output Token Stream\nDESCRIPTION: Generated token stream showing the lexer's output with token types and positions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/PositionAdjustingLexer.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,0:5='tokens',<6>,1:0]\n[@1,7:12='tokens',<4>,2:0]\n[@2,14:14='{',<3>,2:7]\n[@3,16:23='notLabel',<6>,3:0]\n[@4,25:30='label1',<5>,4:0]\n[@5,32:32='=',<1>,4:7]\n[@6,34:39='label2',<5>,5:0]\n[@7,41:42='+=',<2>,5:7]\n[@8,44:51='notLabel',<6>,6:0]\n[@9,53:52='<EOF>',<-1>,7:0]\n```\n\n----------------------------------------\n\nTITLE: Alternative Unchanged Variable Declaration for Generated Recognizers\nDESCRIPTION: Another variable declaration and initialization pattern that doesn't require changes after the update, using the short variable declaration syntax.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-changes.md#2025-04-21_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nlexer := parser.NewMySqlLexer(nil)\np := parser.NewMySqlParser(nil)\n```\n\n----------------------------------------\n\nTITLE: Specifying Expected Output for Parser T\nDESCRIPTION: This snippet specifies the expected output when parsing the input 'x' with the defined grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/NotChar.txt#2025-04-21_snippet_3\n\nLANGUAGE: Plain Text\nCODE:\n```\n\"\"\"x\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Token Output\nDESCRIPTION: Token output showing the lexical analysis result, including token type, text, position, and EOF marker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EOFSuffixInFirstRule_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:0='a',<1>,1:0]\n[@1,1:0='<EOF>',<-1>,1:1]\n```\n\n----------------------------------------\n\nTITLE: Defining Main Grammar for M Language in ANTLR4\nDESCRIPTION: This snippet defines the main grammar for the M language, including a rule for parsing 'abc' and generating custom output. It imports a slave grammar 'S' and includes a whitespace rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/KeywordVSIDOrder.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar M;\nimport S;\na : A {<Append(\"\\\"M.a: \\\"\",\"$A\"):writeln()>};\nA : 'abc' {<writeln(\"\\\"M.A\\\"\")>};\nWS : (' '|'\\n') -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Verifying Java Class File Version\nDESCRIPTION: These commands use the 'od' utility to verify the Java class file version for the ANTLR4 tool and runtime.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nod -h tool/target/classes/org/antlr/v4/Tool.class |head -1\n```\n\nLANGUAGE: bash\nCODE:\n```\nod -h runtime/Java/target/classes/org/antlr/v4/runtime/Token.class | head -1\n```\n\n----------------------------------------\n\nTITLE: DFA Output for Grammar Analysis\nDESCRIPTION: Generated DFA (Deterministic Finite Automaton) output showing state transitions for the grammar decisions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/FullContextParsing/FullContextIF_THEN_ELSEParse_6.txt#2025-04-21_snippet_2\n\nLANGUAGE: plain\nCODE:\n```\nDecision 1:\ns0-'}'->:s2=>2\ns0-'else'->:s1^=>1\n```\n\n----------------------------------------\n\nTITLE: Defining Slave Grammar S in ANTLR4\nDESCRIPTION: This snippet defines the slave grammar S, which is imported by grammar M. It includes parser rules for 'int' type declarations and initializations, with a Java action to print declarations.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/CompositeParsers/DelegatorRuleOverridesLookaheadInDelegate.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\nparser grammar S;\ntype_ : 'int' ;\ndecl : type_ ID ';'\n    | type_ ID init_ ';' {<AppendStr(\"\\\"JavaDecl: \\\"\",\"$text\"):writeln()>};\ninit_ : '=' INT;\n```\n\n----------------------------------------\n\nTITLE: Running Test Script for ANTLR4 Issue 3079 in Bash\nDESCRIPTION: Command to execute the test script for Issue 3079 in the current directory. This script modifies the CSharp runtime to enable debug mode in ParserATNSimulator.cs.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/CSharp/tests/issue-3079/readme.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash test.sh\n```\n\n----------------------------------------\n\nTITLE: Test Input for IF-ELSE Statement Parsing\nDESCRIPTION: Sample input string to test nested if-else statement parsing capabilities. Tests the grammar's ability to handle multiple levels of IF statements.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/Optional_4.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nif if x else x\n```\n\n----------------------------------------\n\nTITLE: Providing Input for ANTLR Grammar Testing\nDESCRIPTION: This snippet provides a test input for the ANTLR grammar. It includes a string starting with 'a', followed by several emoticons, and ending with 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/UnicodeNegatedBMPSetIncludesSMPCodePoints.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\na😳😡😝🤓c\n```\n\n----------------------------------------\n\nTITLE: Signing Git Commits for ANTLR Contributions\nDESCRIPTION: This command demonstrates how to sign a git commit using the -s flag, which is required for contributions to ANTLR as per the Developer Certificate of Origin process.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/developer-cert-of-origin.txt#2025-04-21_snippet_0\n\nLANGUAGE: git\nCODE:\n```\ngit commit -s -m 'This is my commit message'\n```\n\n----------------------------------------\n\nTITLE: Executing ANTLR Version Update and Deployment Script in Bash\nDESCRIPTION: This script updates the ANTLR version and copies javadoc and java jars to the website. It requires Python and takes two version numbers as arguments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4\npython scripts/deploy_to_website.py 4.13.1 4.13.2\n```\n\n----------------------------------------\n\nTITLE: Deploying ANTLR4 Artifacts to Sonatype Staging Server\nDESCRIPTION: This command deploys the ANTLR project artifacts and POMs to the Sonatype remote staging server, skipping tests for faster deployment.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmvn deploy -DskipTests\n```\n\n----------------------------------------\n\nTITLE: Error Message from ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet displays the error message generated when processing the sample input. It indicates a token recognition error at the beginning of the input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/StringsEmbeddedInActions_2.txt#2025-04-21_snippet_3\n\nLANGUAGE: Plain Text\nCODE:\n```\nline 1:0 token recognition error at: '[\"foo]'\n```\n\n----------------------------------------\n\nTITLE: Generated ANTLR4 Token Output\nDESCRIPTION: Token stream output showing the recognized WORD token and EOF token with their positions and types\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/StackoverflowDueToNotEscapedHyphen.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[@0,0:3='word',<1>,1:0]\n[@1,4:3='<EOF>',<-1>,1:4]\n```\n\n----------------------------------------\n\nTITLE: Checking Operating System Compatibility in CMake\nDESCRIPTION: Checks if the operating system is UNIX-based and issues a warning if not. This ensures the build process is compatible with the current environment.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif(NOT UNIX)\n  message(WARNING \"Unsupported operating system\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Test Input for Expression Parser with Nested Ternary Operators\nDESCRIPTION: A sample input for testing the expression parser, containing multiple nested ternary expressions joined by 'or' operators. This input previously caused performance issues taking minutes to parse before optimization.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_5.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z or\nX ? Y : Z\n;\n```\n\n----------------------------------------\n\nTITLE: Test Input for Lexer Grammar\nDESCRIPTION: Sample input string that will trigger a lexer error due to not matching the expected pattern.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharInToken.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nax\n```\n\n----------------------------------------\n\nTITLE: Parser Error Output\nDESCRIPTION: Shows the error message generated when parsing the input 'abe', which doesn't match any of the defined grammar rules.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/LL3.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nline 1:2 no viable alternative at input 'abe'\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Error Output\nDESCRIPTION: This snippet shows the error message generated by the lexer when it encounters unrecognized input 'ax'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharInTokenAfterDFACache.txt#2025-04-21_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nline 1:2 token recognition error at: 'ax'\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output\nDESCRIPTION: Shows the expected token stream output from the lexer, displaying the recognized FFFF token with type 65535 and EOF token.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/TokenType0xFFFF.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n[@0,0:3='FFFF',<65535>,1:0]\n[@1,4:3='<EOF>',<-1>,1:4]\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Lexer Grammar Rules\nDESCRIPTION: Defines three lexer rules: A matches 'a' followed by EOF, B matches standalone 'a', and C matches 'c'. Demonstrates EOF token handling and basic character matching in ANTLR4.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EOFSuffixInFirstRule_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'a' EOF ;\nB : 'a';\nC : 'c';\n```\n\n----------------------------------------\n\nTITLE: Tokenization Output from ANTLR4 Lexer\nDESCRIPTION: This output shows the result of tokenizing the input string using the defined lexer grammar. It includes the recognized DASHBRACK tokens and their positions in the input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithEscapedChar.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\nDASHBRACK\nDASHBRACK\n[@0,0:0='-',<1>,1:0]\n[@1,2:2=']',<1>,1:2]\n[@2,4:3='<EOF>',<-1>,1:4]\n```\n\n----------------------------------------\n\nTITLE: Parser Error Output\nDESCRIPTION: Error message indicating invalid input at position 1:2 where an extra 'a' was found when expecting either 'b' or 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionDuringLoop.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nline 1:2 extraneous input 'a' expecting {'b', 'c'}\n```\n\n----------------------------------------\n\nTITLE: Deploying C++ Runtime for Windows\nDESCRIPTION: This command deploys the C++ runtime for Windows using Visual Studio 2019 Community edition and copies the resulting zip file to the website download directory.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/antlr/code/antlr4/runtime/Cpp\ndeploy-windows.cmd Community\ncp antlr4-cpp-runtime-vs2019.zip ~/antlr/sites/website-antlr4/download/antlr4-cpp-runtime-4.13.2-vs2019.zip\n```\n\n----------------------------------------\n\nTITLE: Providing Test Input for Parser T\nDESCRIPTION: This snippet provides a test input 'x' for the parser T.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Sets/NotChar.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\nx\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar Rule for 'a b' Sequence\nDESCRIPTION: A minimal ANTLR4 grammar that defines a single rule 'a' which expects the literal sequence 'a' followed by 'b'. This grammar will produce parse errors if any other input is provided.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/TokenMismatch.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : 'a' 'b' ;\n```\n\n----------------------------------------\n\nTITLE: Updating Website with New C++ Runtime Files\nDESCRIPTION: These commands add the new C++ runtime zip files to the website repository, commit the changes, and push them to the gh-pages branch.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\npushd ~/antlr/sites/website-antlr4/download\ngit add antlr4-cpp-runtime-4.13.2-macos.zip\ngit add antlr4-cpp-runtime-4.13.2-windows.zip\ngit add antlr4-cpp-runtime-4.13.2-source.zip\ngit commit -a -m 'update C++ runtime'\ngit push origin gh-pages\npopd\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Lexer Grammar\nDESCRIPTION: Defines a basic lexer grammar with a single rule that matches the sequence 'ab'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharInToken.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'a' 'b' ;\n```\n\n----------------------------------------\n\nTITLE: Configuring ANTLR4 C++ Runtime Compiler Flags in CMake\nDESCRIPTION: Sets up compiler-specific flags and warnings for building the ANTLR4 C++ runtime library. It handles different compilers (MSVC, Clang, GNU, Intel) and platforms (Windows, Unix).\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/runtime/CMakeLists.txt#2025-04-21_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n  set(disabled_compile_warnings \"/wd4251\")\nelse()\n  set(disabled_compile_warnings \"-Wno-overloaded-virtual\")\nendif()\n\nif(CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  set(disabled_compile_warnings \"${disabled_compile_warnings} -Wno-dollar-in-identifier-extension -Wno-four-char-constants\")\nelseif(CMAKE_CXX_COMPILER_ID MATCHES \"GNU\" OR CMAKE_CXX_COMPILER_ID MATCHES \"Intel\")\n  set(disabled_compile_warnings \"${disabled_compile_warnings} -Wno-multichar\")\nendif()\n\nset(extra_share_compile_flags \"\")\nset(extra_static_compile_flags \"\")\nset(static_lib_suffix \"\")\n\nif (WIN32)\n  set(static_lib_suffix \"-static\")\n  if (TARGET antlr4_shared)\n    target_compile_definitions(antlr4_shared PUBLIC ANTLR4CPP_EXPORTS)\n  endif()\n  if (TARGET antlr4_static)\n    target_compile_definitions(antlr4_static PUBLIC ANTLR4CPP_STATIC)\n  endif()\n  if(CMAKE_CXX_COMPILER_ID MATCHES \"MSVC\")\n    set(extra_share_compile_flags \"-MP /wd4251\")\n    set(extra_static_compile_flags \"-MP\")\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Handling Escape Characters in String Tokens in ANTLR4\nDESCRIPTION: This snippet demonstrates how to replace escape sequences in string tokens within an ANTLR4 lexer rule. It uses a StringBuilder to accumulate characters and set the token text when the string is complete. The example handles common escape sequences like \\r, \\n, \\t, \\, and \\\".\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/lexical.md#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar Foo;\n \n@members {\nStringBuilder buf = new StringBuilder(); // can't make locals in lexer rules\n}\n \nSTR :   '\"'\n        (   '\\\\'\n            (   'r'     {buf.append('\\r');}\n            |   'n'     {buf.append('\\n');}\n            |   't'     {buf.append('\\t');}\n            |   '\\\\'    {buf.append('\\\\');}\n            |   '\\\"'   {buf.append('\"');}\n            )\n        |   ~('\\\\'|'\"') {buf.append((char)_input.LA(-1));}\n        )*\n        '\"'\n        {setText(buf.toString()); buf.setLength(0); System.out.println(getText());}\n    ;\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output\nDESCRIPTION: Shows the expected token recognition output, including the matched integer token and EOF marker with position information.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithMissingEscapeChar.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nI\n[@0,0:1='34',<1>,1:0]\n[@1,3:2='<EOF>',<-1>,1:3]\n```\n\n----------------------------------------\n\nTITLE: Testing ANTLR4 Grammar with Invalid Input\nDESCRIPTION: Test case that provides the input 'aab' to the grammar, which is invalid because after the first 'a', it expects either 'b' or 'c', but gets another 'a'. The error message shows how ANTLR4 reports this syntax error.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionExpectingSet.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nline 1:1 extraneous input 'a' expecting {'b', 'c'}\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directories for ANTLR4 Demo in CMake\nDESCRIPTION: Specifies the include directories for the ANTLR4 demo project. This includes various subdirectories of the runtime source and the generated files directory.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/demo/CMakeLists.txt#2025-04-21_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(\n  ${PROJECT_SOURCE_DIR}/runtime/src\n  ${PROJECT_SOURCE_DIR}/runtime/src/misc\n  ${PROJECT_SOURCE_DIR}/runtime/src/atn\n  ${PROJECT_SOURCE_DIR}/runtime/src/dfa\n  ${PROJECT_SOURCE_DIR}/runtime/src/tree\n  ${PROJECT_SOURCE_DIR}/runtime/src/support\n  ${PROJECT_SOURCE_DIR}/demo/generated\n  )\n```\n\n----------------------------------------\n\nTITLE: Test Input String\nDESCRIPTION: Sample input string 'ababbc' to test against the grammar rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenDeletionDuringLoop.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nababbc\n```\n\n----------------------------------------\n\nTITLE: Adding Unicode Character Ranges to Set\nDESCRIPTION: Configures a set object with multiple Unicode character ranges using hexadecimal values. Each add() call either adds a single code point or defines a range with start and end points inclusive.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/scripts/parse-extended-pictographic/ExtendedPictographic-Parsed.txt#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nset.add(0x1F774, 0x1F77F);\nset.add(0x2700, 0x2701);\nset.add(0x2703, 0x2704);\nset.add(0x270E);\nset.add(0x2710, 0x2711);\nset.add(0x2765, 0x2767);\nset.add(0x1F030, 0x1F093);\nset.add(0x1F094, 0x1F09F);\nset.add(0x1F10D, 0x1F10F);\nset.add(0x1F12F);\nset.add(0x1F16C, 0x1F16F);\nset.add(0x1F1AD, 0x1F1E5);\nset.add(0x1F260, 0x1F265);\nset.add(0x1F203, 0x1F20F);\nset.add(0x1F23C, 0x1F23F);\nset.add(0x1F249, 0x1F24F);\nset.add(0x1F252, 0x1F25F);\nset.add(0x1F266, 0x1F2FF);\nset.add(0x1F7D5, 0x1F7FF);\nset.add(0x1F000, 0x1F003);\nset.add(0x1F005, 0x1F02B);\nset.add(0x1F02C, 0x1F02F);\nset.add(0x1F322, 0x1F323);\nset.add(0x1F394, 0x1F395);\nset.add(0x1F398);\nset.add(0x1F39C, 0x1F39D);\nset.add(0x1F3F1, 0x1F3F2);\nset.add(0x1F3F6);\nset.add(0x1F4FE);\nset.add(0x1F53E, 0x1F548);\nset.add(0x1F54F);\nset.add(0x1F568, 0x1F56E);\nset.add(0x1F571, 0x1F572);\nset.add(0x1F57B, 0x1F586);\nset.add(0x1F588, 0x1F589);\nset.add(0x1F58E, 0x1F58F);\nset.add(0x1F591, 0x1F594);\nset.add(0x1F597, 0x1F5A3);\nset.add(0x1F5A6, 0x1F5A7);\nset.add(0x1F5A9, 0x1F5B0);\nset.add(0x1F5B3, 0x1F5BB);\nset.add(0x1F5BD, 0x1F5C1);\nset.add(0x1F5C5, 0x1F5D0);\nset.add(0x1F5D4, 0x1F5DB);\nset.add(0x1F5DF, 0x1F5E0);\nset.add(0x1F5E2);\nset.add(0x1F5E4, 0x1F5E7);\nset.add(0x1F5E9, 0x1F5EE);\nset.add(0x1F5F0, 0x1F5F2);\nset.add(0x1F5F4, 0x1F5F9);\nset.add(0x2605);\nset.add(0x2607, 0x260D);\nset.add(0x260F, 0x2610);\nset.add(0x2612);\nset.add(0x2616, 0x2617);\nset.add(0x2619, 0x261C);\nset.add(0x261E, 0x261F);\nset.add(0x2621);\nset.add(0x2624, 0x2625);\nset.add(0x2627, 0x2629);\nset.add(0x262B, 0x262D);\nset.add(0x2630, 0x2637);\nset.add(0x263B, 0x2647);\nset.add(0x2654, 0x265F);\nset.add(0x2661, 0x2662);\nset.add(0x2664);\nset.add(0x2667);\nset.add(0x2669, 0x267A);\nset.add(0x267C, 0x267E);\nset.add(0x2680, 0x2691);\nset.add(0x2695);\nset.add(0x2698);\nset.add(0x269A);\nset.add(0x269D, 0x269F);\nset.add(0x26A2, 0x26A9);\nset.add(0x26AC, 0x26AF);\nset.add(0x26B2, 0x26BC);\nset.add(0x26BF, 0x26C3);\nset.add(0x26C6, 0x26C7);\nset.add(0x26C9, 0x26CD);\nset.add(0x26D0);\nset.add(0x26D2);\nset.add(0x26D5, 0x26E8);\nset.add(0x26EB, 0x26EF);\nset.add(0x26F6);\nset.add(0x26FB, 0x26FC);\nset.add(0x26FE, 0x26FF);\nset.add(0x2388);\nset.add(0x1FA00, 0x1FFFD);\nset.add(0x1F0A0, 0x1F0AE);\nset.add(0x1F0B1, 0x1F0BF);\nset.add(0x1F0C1, 0x1F0CF);\nset.add(0x1F0D1, 0x1F0F5);\nset.add(0x1F0AF, 0x1F0B0);\nset.add(0x1F0C0);\nset.add(0x1F0D0);\nset.add(0x1F0F6, 0x1F0FF);\nset.add(0x1F80C, 0x1F80F);\nset.add(0x1F848, 0x1F84F);\nset.add(0x1F85A, 0x1F85F);\nset.add(0x1F888, 0x1F88F);\nset.add(0x1F8AE, 0x1F8FF);\nset.add(0x1F900, 0x1F90B);\nset.add(0x1F91F);\nset.add(0x1F928, 0x1F92F);\nset.add(0x1F931, 0x1F932);\nset.add(0x1F94C);\nset.add(0x1F95F, 0x1F96B);\nset.add(0x1F992, 0x1F997);\nset.add(0x1F9D0, 0x1F9E6);\nset.add(0x1F90C, 0x1F90F);\nset.add(0x1F93F);\nset.add(0x1F94D, 0x1F94F);\nset.add(0x1F96C, 0x1F97F);\nset.add(0x1F998, 0x1F9BF);\nset.add(0x1F9C1, 0x1F9CF);\nset.add(0x1F9E7, 0x1F9FF);\nset.add(0x1F6C6, 0x1F6CA);\nset.add(0x1F6D3, 0x1F6D4);\nset.add(0x1F6E6, 0x1F6E8);\nset.add(0x1F6EA);\nset.add(0x1F6F1, 0x1F6F2);\nset.add(0x1F6F7, 0x1F6F8);\nset.add(0x1F6D5, 0x1F6DF);\nset.add(0x1F6ED, 0x1F6EF);\nset.add(0x1F6F9, 0x1F6FF);\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR Grammar with Sequential Tokens\nDESCRIPTION: A basic ANTLR grammar definition named 'T' with a single rule 'a' that requires three consecutive tokens 'a', 'b', and 'c' in that order.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleTokenInsertion.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\na : 'a' 'b' 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Defining ANTLR4 Lexer Grammar\nDESCRIPTION: This snippet defines a simple ANTLR4 lexer grammar named 'L' with a single rule 'A' that matches the sequence 'ab'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharInTokenAfterDFACache.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nA : 'a' 'b' ;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Output for String Token\nDESCRIPTION: This is the lexer output for the given input. It shows the recognized STRING token and the EOF (End of File) token, including their positions and types.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/NonGreedyTermination2.txt#2025-04-21_snippet_2\n\nLANGUAGE: Plain Text\nCODE:\n```\n[@0,0:6='!!!mom!',<1>,1:0]\n[@1,7:6='<EOF>',<-1>,1:7]\n```\n\n----------------------------------------\n\nTITLE: Expected Lexer Output for Nested Action Input\nDESCRIPTION: This snippet shows the expected output from the lexer when processing the sample input. It indicates that the lexer reached the end of the file (EOF) without successfully tokenizing the input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/EnforcedGreedyNestedBraces_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\n[@0,5:4='<EOF>',<-1>,1:5]\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Lexer Output\nDESCRIPTION: This snippet displays the output of the lexer after processing the input. It shows the recognized token 'ab' and the EOF marker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/InvalidCharInTokenAfterDFACache.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[@0,0:1='ab',<1>,1:0]\n[@1,4:3='<EOF>',<-1>,1:4]\n```\n\n----------------------------------------\n\nTITLE: Test Input for FFFF Token\nDESCRIPTION: Sample input text to test the lexer grammar token recognition.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/TokenType0xFFFF.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nFFFF\n```\n\n----------------------------------------\n\nTITLE: Simple Parser Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar named 'T' with rules for parsing identifiers and integers. Includes listener annotations and custom after-rule actions for tree visualization and listener walking. The grammar supports basic arithmetic expressions with multiplication and addition operators.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Listeners/RuleGetters_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\n\n<ImportListener(\"T\")>\n<RuleGetterListener(\"T\")>\n\ns\n@after {\n<ContextMember(\"$ctx\", \"r\"):ToStringTree():writeln()>\n<ContextMember(\"$ctx\", \"r\"):WalkListener()>\n}\n  : r=a ;\na : b b        // forces list\n  | b      // a list still\n  ;\nb : ID | INT;\nMULT: '*' ;\nADD : '+' ;\nINT : [0-9]+ ;\nID  : [a-z]+ ;\nWS : [ \\t\\n]+ -> skip ;\n```\n\n----------------------------------------\n\nTITLE: Test Input for Parser Grammar\nDESCRIPTION: Sample input string demonstrating nested ternary operations to test the parser grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/TernaryExpr_8.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\na? b?c:d : e\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Token Output\nDESCRIPTION: Generated token output showing the matched input 'xaf' as token type 'I' and the EOF marker.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetNot.txt#2025-04-21_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nI\n[@0,0:2='xaf',<1>,1:0]\n[@1,3:2='<EOF>',<-1>,1:3]\n```\n\n----------------------------------------\n\nTITLE: Sample Input Expression\nDESCRIPTION: Example input showing variable assignment syntax for the expression parser.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/AmbigLR_3.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nb = 6\n```\n\n----------------------------------------\n\nTITLE: Arithmetic Expression Grammar Definition in ANTLR4\nDESCRIPTION: Defines a grammar for parsing arithmetic expressions with operator precedence. Includes support for basic arithmetic operators (*,/,+,-), parentheses, and integer literals. Contains multiple semantic actions and predicates to test action duplication handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleActionsPredicatesOptions_2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e ;\ne : a=e op=('*'|'/') b=e  {}{<True()>}?\n  | a=e op=('+'|'-') b=e  {}<p=3>{<True()>}?<fail='Message'>\n  | INT {}{}\n  | '(' x=e ')' {}{}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Testing ANTLR4 Grammar\nDESCRIPTION: A test input containing two consecutive 'x' characters to validate the grammar's ability to parse expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/DuplicatedLeftRecursiveCall_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: ANTLR4\nCODE:\n```\nxx\n```\n\n----------------------------------------\n\nTITLE: Defining Simple ANTLR4 Grammar with Parser Rule and Text Output Action\nDESCRIPTION: This ANTLR4 grammar defines a parser rule 'a' that matches one or more ID tokens and includes a semantic action to output the matched text. The grammar also defines lexer rules for identifiers and whitespace handling.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserExec/AorAPlus.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : (ID|ID)+ {\n<writeln(\"$text\")>\n};\nID : 'a'..'z'+;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Complex Boolean Logic Expression in Disjunctive Normal Form\nDESCRIPTION: A Boolean expression where each clause has exactly one variable set to true and the rest set to false. This pattern is repeated multiple times, likely to test parser performance with large expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/ExpressionGrammar_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: logical expression\nCODE:\n```\nnot X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 and not X8 and not X9 and not X10 and not X11 and not X12 or     X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 and not X8 and not X9 and not X10 and not X11 and not X12 or not X1 and     X2 and not X3 and not X4 and not X5 and not X6 and not X7 and not X8 and not X9 and not X10 and not X11 and not X12 or not X1 and not X2 and     X3 and not X4 and not X5 and not X6 and not X7 and not X8 and not X9 and not X10 and not X11 and not X12 or not X1 and not X2 and not X3 and     X4 and not X5 and not X6 and not X7 and not X8 and not X9 and not X10 and not X11 and not X12 or not X1 and not X2 and not X3 and not X4 and     X5 and not X6 and not X7 and not X8 and not X9 and not X10 and not X11 and not X12 or not X1 and not X2 and not X3 and not X4 and not X5 and     X6 and not X7 and not X8 and not X9 and not X10 and not X11 and not X12 or not X1 and not X2 and not X3 and not X4 and not X5 and not X6 and     X7 and not X8 and not X9 and not X10 and not X11 and not X12 or not X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 and     X8 and not X9 and not X10 and not X11 and not X12 or not X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 and not X8 and     X9 and not X10 and not X11 and not X12 or not X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 and not X8 and not X9 and     X10 and not X11 and not X12 or not X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 and not X8 and not X9 and not X10 and     X11 and not X12 or not X1 and not X2 and not X3 and not X4 and not X5 and not X6 and not X7 and not X8 and not X9 and not X10 and not X11 and     X12  or\n```\n\n----------------------------------------\n\nTITLE: Complex Expression Input for Performance Testing\nDESCRIPTION: A test input with repetitive 'between' expressions connected by 'and' and 'or' operators, designed to stress test the parser's performance with complex, nested expressions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/Performance/DropLoopEntryBranchInLRRule_4.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4 and\nbetween X1 and X2 or between X3 and X4\n;\n```\n\n----------------------------------------\n\nTITLE: Expected Parse Tree Output\nDESCRIPTION: Expected string representation of the parse tree generated from the test input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/ReturnValueAndActionsList1_2.txt#2025-04-21_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n(s (expr (expr a) , (expr c) >> (expr x)) <EOF>)\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar for Actions and Strings in ANTLR4\nDESCRIPTION: This ANTLR4 lexer grammar defines rules for matching actions enclosed in square brackets, quoted strings with escape handling, and whitespace. It includes three main token rules: ACTION2 for bracketed content, STRING for quoted text, and WS for whitespace skipping.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerErrors/StringsEmbeddedInActions_1.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\nlexer grammar L;\nACTION2 : '[' (STRING | ~'\"')*? ']';\nSTRING : '\"' ('\\\\\\\\' '\"' | .)*? '\"';\nWS : [ \\t\\r\\n]+ -> skip;\n```\n\n----------------------------------------\n\nTITLE: Old-Style Variable Declaration that Needs Changes\nDESCRIPTION: Shows the variable declaration pattern that needs to be modified after the update because it explicitly declares variables using interface types that have been removed.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-changes.md#2025-04-21_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nvar lexer parser.MySqlLexer\nvar p parser.MySqlParser\n// ...\nlexer = parser.NewMySqlLexer(nil)\np = parser.NewMySqlParser(nil)\n```\n\n----------------------------------------\n\nTITLE: Resolving Keyword and Identifier Ambiguity in ANTLR4\nDESCRIPTION: This example shows how to properly order lexical rules to resolve ambiguity between keywords and identifiers in ANTLR4. By placing the identifier rule after all keywords, ANTLR gives precedence to the keywords when matching input.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/faq/lexical.md#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\n \ndecl : DEF 'int' ID ';'\n \nDEF : 'def' ;   // ambiguous with ID as is 'int'\nID  : [a-z]+ ;\n```\n\n----------------------------------------\n\nTITLE: Running ATN Tracing for Target Comparison\nDESCRIPTION: Command to trace and compare ATN (Augmented Transition Network) execution between Java and a new target language, which helps ensure the parsing decision-making is correct.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/creating-a-language-target.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n../scripts/traceatn.sh /tmp/JSON.g4 json -target Go /tmp/foo.json\n```\n\n----------------------------------------\n\nTITLE: Building ANTLR4 C++ Runtime on Android using CMake\nDESCRIPTION: Command to build the ANTLR4 C++ runtime for Android platform using CMake with specific NDK and architecture settings.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncmake -DCMAKE_ANDROID_NDK=/folder/of/android_ndkr17_and_above -DCMAKE_SYSTEM_NAME=Android -DCMAKE_ANDROID_API=14 -DCMAKE_ANDROID_ARCH_ABI=x86 -DCMAKE_ANDROID_STL_TYPE=c++_shared -DCMAKE_ANDROID_NDK_TOOLCHAIN_VERSION=clang -DCMAKE_BUILD_TYPE=Release /folder/antlr4_src_dir -G Ninja\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer\nDESCRIPTION: Test input string to demonstrate lexer token recognition\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/StackoverflowDueToNotEscapedHyphen.txt#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nword\n```\n\n----------------------------------------\n\nTITLE: Preparing ANTLR4 Release with Maven\nDESCRIPTION: This command prepares the ANTLR4 release, updating version numbers in POM files and creating a release tag in the version control system.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmvn release:prepare -Darguments=\"-DskipTests\"\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 Multiple Reference Context Class\nDESCRIPTION: Demonstrates the context class generated for rules with multiple references to the same rule.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/parser-rules.md#2025-04-21_snippet_8\n\nLANGUAGE: java\nCODE:\n```\npublic static class FieldContext extends ParserRuleContext {\n\tpublic EContext e(int i) { ... } // get ith e context\n\tpublic List<EContext> e() { ... } // return ALL e contexts\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting GPG_TTY Environment Variable for GPG Signing\nDESCRIPTION: This command sets the GPG_TTY environment variable to the current TTY, which is necessary for GPG signing during the release process.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nexport GPG_TTY=$(tty)\n```\n\n----------------------------------------\n\nTITLE: Linking with ANTLR4 Runtime in CMake\nDESCRIPTION: Example showing how to include ANTLR4 runtime directories and link the runtime library with a project. This demonstrates the basic pattern for consuming the ANTLR4 runtime.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/Antlr4Package.md#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\n# add runtime include directories on this project.\ninclude_directories( ${ANTLR4_INCLUDE_DIR} )\n\n# add runtime to project dependencies\nadd_dependencies( Parsertest antlr4_shared )\n\n# add runtime to project link libraries\ntarget_link_libraries( Parsertest PRIVATE\n                       antlr4_shared)\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 4.7.1 Package Declaration Verification\nDESCRIPTION: Shows package declarations in generated Java files when using the package option.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n$ grep package /tmp/build/A*.java\n/tmp/build/ABaseListener.java:package pkg;\n/tmp/build/ALexer.java:package pkg;\n/tmp/build/AListener.java:package pkg;\n/tmp/build/AParser.java:package pkg;\n```\n\n----------------------------------------\n\nTITLE: ANTLR4 4.7.1 Token Vocabulary Resolution\nDESCRIPTION: Shows improved token file lookup behavior in ANTLR4 4.7.1, where it checks grammar directory for token files.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/tool-options.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n$ a4.7.1 -o /tmp/build src/pkg/*.g4\n$ tree /tmp/build\n/tmp/build\n├── L.java\n├── L.tokens\n├── P.java\n├── P.tokens\n├── PBaseListener.java\n├── PListener.java\n└── src\n    └── pkg\n        ├── L.java\n        └── L.tokens\n```\n\n----------------------------------------\n\nTITLE: Expected Error Output from ANTLR4 Parser\nDESCRIPTION: Specifies the expected error message when parsing the input, indicating that either 'b' or 'c' is missing at position 'd'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/SingleSetInsertion.txt#2025-04-21_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nline 1:1 missing {'b', 'c'} at 'd'\n```\n\n----------------------------------------\n\nTITLE: Example JSON Input for Parsing\nDESCRIPTION: A simple JSON object used as an example input for the JSON parser.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/php-target.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\"a\":1}\n```\n\n----------------------------------------\n\nTITLE: Sample Input for ANTLR4 Lexer Testing\nDESCRIPTION: This code snippet provides a sample input string to test the defined lexer grammar. It includes integers, identifiers, and whitespace characters.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetRange.txt#2025-04-21_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n\"\"\"34\n 34 a2 abc \n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Package Configuration and Installation\nDESCRIPTION: Configures package installation settings and CPack configuration for distribution.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/CMakeLists.txt#2025-04-21_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nif(EXISTS LICENSE.txt)\ninstall(FILES LICENSE.txt\n        DESTINATION \"share/doc/libantlr4\")\nelseif(EXISTS ../../LICENSE.txt)\ninstall(FILES ../../LICENSE.txt\n    DESTINATION \"share/doc/libantlr4\")\nendif()\n\ninstall(FILES README.md VERSION\n    DESTINATION \"share/doc/libantlr4\")\n\nset(CPACK_PACKAGE_CONTACT \"antlr-discussion@googlegroups.com\")\nset(CPACK_PACKAGE_VERSION ${ANTLR_VERSION})\ninclude(CPack)\n```\n\n----------------------------------------\n\nTITLE: Generating C# Code from ANTLR Grammar\nDESCRIPTION: Command line example for generating C# code from an ANTLR grammar file. This uses the Java-based ANTLR tool to create C# parser and lexer code based on your grammar definition.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/CSharp/src/README.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\njava -jar antlr4-4.13.2.jar -Dlanguage=CSharp grammar.g4\n```\n\n----------------------------------------\n\nTITLE: Finding the ANTLR4 Runtime Package in CMake\nDESCRIPTION: Simple find_package command to include the ANTLR4 runtime library in a CMake project. This makes the runtime targets available for linking.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/Antlr4Package.md#2025-04-21_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(antlr4-runtime REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Building ANTLR4 C++ Runtime on Linux using CMake\nDESCRIPTION: Commands to build the ANTLR4 C++ runtime on Linux systems using CMake. Includes optional demo build configuration.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd <antlr4-dir>/runtime/Cpp\nmkdir build && mkdir run && cd build\ncmake .. -DANTLR_JAR_LOCATION=full/path/to/antlr4-4.5.4-SNAPSHOT.jar -DWITH_DEMO=True\nmake\nDESTDIR=<antlr4-dir>/runtime/Cpp/run make install\n```\n\n----------------------------------------\n\nTITLE: Sample Input for Lexer Testing\nDESCRIPTION: Test input string containing numbers and spaces to validate the lexer grammar.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/CharSetWithMissingEscapeChar.txt#2025-04-21_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n34 \n```\n\n----------------------------------------\n\nTITLE: Finding the ANTLR4 Generator Package in CMake\nDESCRIPTION: Simple find_package command to include the ANTLR4 generator functionality in a CMake project. This makes the antlr4_generate function available for use.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime/Cpp/cmake/Antlr4Package.md#2025-04-21_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nfind_package(antlr4-generator REQUIRED)\n```\n\n----------------------------------------\n\nTITLE: Importing the New Go Runtime Module\nDESCRIPTION: Shows how to import the ANTLR Go runtime from its new repository location. All future projects using the ANTLR Go runtime should use this import path.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/go-changes.md#2025-04-21_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n    \"github.com/antlr4-go/antlr/v4\"\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Grammar with Dollar Sign Token in ANTLR\nDESCRIPTION: This ANTLR lexer grammar defines a single token 'ACTION_WITH_DOLLAR' that matches the literal '$ACTION'. It's designed to test proper handling of the dollar sign in PHP code generation.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LexerExec/EscapeTargetStringLiteral.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\nlexer grammar L;\nACTION_WITH_DOLLAR: '$ACTION';\n```\n\n----------------------------------------\n\nTITLE: Basic ANTLR4 Grammar Definition with Action\nDESCRIPTION: Defines a simple grammar rule 'a' that matches pattern starting with 'a', followed by zero or more occurrences of 'b' or 'z' (with Pass action), and ending with 'c'.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/ParserErrors/MultiTokenDeletionDuringLoop2.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR4\nCODE:\n```\ngrammar T;\na : 'a' ('b'|'z'{<Pass()>})* 'c' ;\n```\n\n----------------------------------------\n\nTITLE: Loading a Grammar File in ANTLR v4\nDESCRIPTION: Shows how to load a grammar file and create a Grammar object in ANTLR v4. This demonstrates the simplified grammar loading API.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/CHANGES.txt#2025-04-21_snippet_3\n\nLANGUAGE: Java\nCODE:\n```\nfinal Grammar g = Grammar.load(\"/tmp/MyGrammar.g4\");\n```\n\n----------------------------------------\n\nTITLE: Defining Lexer Rules for Tokens in ANTLR4\nDESCRIPTION: This snippet defines lexer rules for various tokens used in the expression grammar, including identifiers, numbers, dates, strings, whitespace, and comments.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/WhitespaceInfluence_2.txt#2025-04-21_snippet_1\n\nLANGUAGE: ANTLR4\nCODE:\n```\n// Fragments\nfragment DIGIT    : '0' .. '9';\nfragment UPPER    : 'A' .. 'Z';\nfragment LOWER    : 'a' .. 'z';\nfragment LETTER   : LOWER | UPPER;\nfragment WORD     : LETTER | '_' | '$' | '#' | '.';\nfragment ALPHANUM : WORD | DIGIT;\n\n// Tokens\nID     : LETTER ALPHANUM*;\nNUMBER : DIGIT+ ('.' DIGIT+)? (('e'|'E')('+'|'-')? DIGIT+)?;\nDATE   : '\\'' DIGIT DIGIT DIGIT DIGIT '-' DIGIT DIGIT '-' DIGIT DIGIT (' ' DIGIT DIGIT ':' DIGIT DIGIT ':' DIGIT DIGIT ('.' DIGIT+)?)? '\\'';\nSQ_STRING       : '\\'' ('\\'\\'' | ~'\\'')* '\\'';\nDQ_STRING       : '\"' ('\\\\\\\"' | ~'\"')* '\"';\nWS     : [ \\t\\n\\r]+ -> skip ;\nCOMMENTS        : ('/*' .*? '*' '/' | '//' ~'\\n'* '\\n' ) -> skip;\n```\n\n----------------------------------------\n\nTITLE: Defining Antlr4 Grammar for Expression Parsing with Operator Precedence\nDESCRIPTION: This grammar defines rules for parsing mathematical expressions with operator precedence. It includes actions, semantic predicates, and demonstrates handling of potential issues with duplicate actions.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/runtime-testsuite/resources/org/antlr/v4/test/runtime/descriptors/LeftRecursion/MultipleActionsPredicatesOptions_3.txt#2025-04-21_snippet_0\n\nLANGUAGE: ANTLR\nCODE:\n```\ngrammar T;\ns @after {<ToStringTree(\"$ctx\"):writeln()>} : e ;\ne : a=e op=('*'|'/') b=e  {}{<True()>}?\n  | a=e op=('+'|'-') b=e  {}<p=3>{<True()>}?<fail='Message'>\n  | INT {}{}\n  | '(' x=e ')' {}{}\n  ;\nINT : '0'..'9'+ ;\nWS : (' '|'\\n') -> skip;\n```\n\n----------------------------------------\n\nTITLE: Zipping JavaScript Runtime for Website\nDESCRIPTION: This command creates a zip archive of the JavaScript runtime source for distribution on the ANTLR website.\nSOURCE: https://github.com/antlr/antlr4.git/blob/dev/doc/releasing-antlr.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncd src\nzip -r ~/antlr/sites/website-antlr4/download/antlr-javascript-runtime-4.13.2.zip .\n```"
  }
]