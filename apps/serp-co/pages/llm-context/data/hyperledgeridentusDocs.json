[
  {
    "owner": "hyperledger-identus",
    "repo": "docs",
    "content": "TITLE: Handling Authentication Challenge with TypeScript Wallet SDK\nDESCRIPTION: This snippet demonstrates how to handle an authentication challenge using the TypeScript Wallet SDK. It initializes Apollo and Castor modules, retrieves keys for a DID, signs a challenge nonce, and submits the signature to an authentication service.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/authenticate.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport {Apollo, Castor, Domain} from \"@input-output-hk/atala-prism-wallet-sdk\";\nimport * as jose from \"jose\";\n\n// init Apollo and Castor SDK modules. \n// Apollo = cryptography, Castor = DIDs management.\nconst apollo = new Apollo();\nconst castor = new Castor(apollo);\n\n/**\n * Wallet will receive encoded authentication challenge as a deep link, QR code,\n * or in some other way. This is the function which will handle decoded challenge. \n * We assume that user has already selected a DID to use for signing the challenge.\n * DID is usually a part of wallet specific abstraction - contact/account/avatar.\n *\n * @param {type, from, nonce, expireAt, submissionEndpoint} authChallenge\n * @param {string} did\n */\nasync function handleDidRequest(authChallenge, did) {\n    if (authChallenge.type !== \"https://atalaprism.io/authentication-challenge\") {\n        throw new Error(\"Invalid Authentication Challenge\");\n    }\n\n    // application specific logic to retrieve private keys for DID from wallet storage\n    const keys = await getKeysForDidFromStorage(did);\n    \n    // we need to sign with ED25519 key\n    const authKeyPair = keys.find(key => key.curve === Domain.Curve.ED25519);\n    const signature = apollo.signStringMessage(authKeyPair.privateKey, authChallenge.nonce);\n    \n    // POST signature & did back to the Authenticate service - using axios for example\n    await axios.post(authChallenge.submissionEndpoint, {\n        did,\n        signature: jose.base64url.encode(signature.value),\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Credential Offer with Existing Connection\nDESCRIPTION: Creates a credential offer for a holder with an existing connection. Requires connectionId and publishedPrismDID as parameters.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location --request POST 'http://localhost:8000/cloud-agent/issue-credentials/credential-offers' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"claims\": {\"emailAddress\":\"sampleEmail\", \"familyName\":\"\", \"dateOfIssuance\":\"2023-01-01T02:02:02Z\", \"drivingLicenseID\":\"\", \"drivingClass\":1},\n    \"connectionId\": [[connectionId]],\n    \"issuingDID\": [[publishedPrismDID]],\n    \"automaticIssuance\": true\n}'\n```\n\n----------------------------------------\n\nTITLE: Implementing the Common Failure Trait in Scala\nDESCRIPTION: Demonstrates how to create a common Failure trait and service-specific error types that extend it. This pattern allows for consistent error handling throughout the application with proper status codes and user-facing messages.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_8\n\nLANGUAGE: scala\nCODE:\n```\ntrait Failure {\n  val statusCode: StatusCode\n  val userFacingMessage: String\n}\n\nsealed trait ConnectionServiceError(\n                                     val statusCode: StatusCode,\n                                     val userFacingMessage: String\n                                   ) extends Failure\n\nobject ConnectionServiceError {\n  final case class InvitationAlreadyReceived(invitationId: String)\n    extends ConnectionServiceError(\n      StatusCode.BadRequest,\n      s\"The provided invitation has already been used: invitationId=$invitationId\"\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Connectionless Presentation Request in Verifier Cloud Agent\nDESCRIPTION: This bash script shows how to create a connectionless presentation request invitation that can be shared with a Holder. It uses the /present-proof/presentations/invitation endpoint to generate an OOB message containing the presentation request that can be scanned or shared directly.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request POST 'http://localhost:9000/cloud-agent/present-proof/presentations/invitation' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"goalCode\": [[goalCode]],\n    \"goal\": [[goal]],\n    \"credentialFormat\": \"JWT\",\n    \"proofs\": [\n        {\n            \"schemaId\": [[schemaId]],\n            \"trustIssuers\": [\n                [[PUBLISHED PRISM DID FROM THE ISSUER]]\n            ]\n        }\n    ],\n    \"options\": {\n        \"challenge\": \"A challenge for the holder to sign\",\n        \"domain\": \"domain.com\"\n    }\n}'\n```\n\n----------------------------------------\n\nTITLE: Handling DID Authentication Request in JavaScript\nDESCRIPTION: This function creates a new authentication challenge, encodes it as a QR code, and sends it to the application front-end. It uses a generated API client to interact with the Authenticate service.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/authenticate.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nasync function handleDidAuthRequest() {\n  // we are using generated API client here to interact with Authenticate service.\n  const authChallengeState = await prismApiClient.createAuthenticationChallenge({\n    from: 'Application ABC',\n  });\n\n  // depends on the use-case: QR code, deep link or something else!\n  const encodedAuthChallenge = encodeAsQrCode(authChallengeState.challenge);\n\n  await respondWithSuccessToApplicationFrontend(authChallengeState.id, encodedAuthChallenge);\n  console.info(`Challenge \"${authChallengeState.id}\" has been created and sent to the front-end.`);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Connectionless Credential Offer\nDESCRIPTION: Creates a credential offer without requiring a pre-existing connection. Includes optional goalCode and goal parameters for context.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location --request POST 'http://localhost:8000/cloud-agent/issue-credentials/credential-offers/invitation' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"claims\": {\"emailAddress\":\"sampleEmail\", \"familyName\":\"\", \"dateOfIssuance\":\"2023-01-01T02:02:02Z\", \"drivingLicenseID\":\"\", \"drivingClass\":1},\n    \"goalCode\": [[goalCode]],\n    \"goal\": [[goal]],\n    \"credentialFormat\": \"JWT\",\n    \"issuingDID\": [[publishedPrismDID]],\n    \"automaticIssuance\": true\n}'\n```\n\n----------------------------------------\n\nTITLE: Configuring Tapir Endpoints with RFC-9457 Error Responses\nDESCRIPTION: Shows how to declare Tapir endpoints with standardized error responses that comply with RFC-9457 (Problem Details for HTTP APIs). This ensures all API errors have a consistent format.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_12\n\nLANGUAGE: scala\nCODE:\n```\nobject ConnectionEndpoints {\n\n  val createConnection: Endpoint[\n    (ApiKeyCredentials, JwtCredentials),\n    (RequestContext, CreateConnectionRequest),\n    ErrorResponse,\n    Connection,\n    Any\n  ] = ???\n\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Presentation Request with Existing Connection in Verifier Cloud Agent\nDESCRIPTION: This bash script demonstrates how to create a presentation request from a Verifier to a Holder when they already have an established connection. It uses the /present-proof/presentations endpoint, specifying the connectionId, schema, and trusted issuers along with challenge options.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request POST 'http://localhost:9000/cloud-agent/present-proof/presentations' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"connectionId\": [[connectionId]],\n    \"proofs\": [\n        {\n            \"schemaId\": [[schemaId]],\n            \"trustIssuers\": [\n                [[PUBLISHED PRISM DID FROM THE ISSUER]]\n            ]\n        }\n    ],\n    \"options\": {\n        \"challenge\": \"A challenge for the holder to sign\",\n        \"domain\": \"domain.com\"\n    }\n}'\n```\n\n----------------------------------------\n\nTITLE: Creating and Sending DID Request in JavaScript\nDESCRIPTION: This server-side JavaScript function creates a DID request, encodes it, and sends it to a user. It demonstrates how to interact with the Onboard API, encode the request as a deep link, and schedule background tracking of the request's state.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/onboard.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * This is an example of a server side handler. Imagine a web application which \n * has a \"Connect with DID\" button on the user profile page, which triggers this\n * flow.\n */\nasync function createDidRequest(context) {\n  // get the existing user profile from the application database for a given userId\n  let userProfile = await getUserById(context.userId);\n\n  // to interact with Onboard API, we use an API client generated based on OpenAPI\n  // specification, with a tool such as Orval.\n  let didRequestState = await prismApiClient.createDidRequest({\n    from: \"Application ABC\"\n  })\n\n  // depends on the use-case: deep link, QR code, or something else!\n  let encodedDidRequest = encodeAsDeepLink(didRequestState.didRequest);\n  \n  // could be any communication channel, we use email here as an example\n  await sendDidRequestToEmail(userProfile.email, encodedDidRequest);\n  \n  // track the state of DID request in the background - no events yet!\n  await scheduleBackgroundTrackingJob({\n    requestId: didRequestState.id, \n    userId: context.userId\n  });\n  await respondWithSuccessToApplicationFrontend();\n  \n  console.info(`DID request \"${didRequestState.id}\" has been created and sent to user.`);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating LongForm PrismDID\nDESCRIPTION: cURL command to create a PRISM DID using the Issuer API, specifying public keys for authentication and assertion.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request POST 'http://localhost:8000/cloud-agent/did-registrar/dids' \\\n--header 'Accept: application/json' \\\n--data-raw '{\n    \"documentTemplate\": {\n        \"publicKeys\": [\n        {\n          \"id\": \"auth-1\",\n          \"purpose\": \"authentication\"\n        },\n        {\n          \"id\": \"issue-1\",\n              \"purpose\": \"assertionMethod\"\n        }\n      ],\n      \"services\": []\n    }\n}'\n```\n\n----------------------------------------\n\nTITLE: Using Scala 3 Union Types for Error Channels in ZIO\nDESCRIPTION: Shows how to use Scala 3 union types in ZIO effect error channels to precisely specify which errors a function might return. This provides better type safety and documentation at compile time.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_11\n\nLANGUAGE: scala\nCODE:\n```\nclass ConnectionServiceImpl() extends ConnectionService {\n\n  override def receiveConnectionRequest(request: ConnectionRequest, expirationTime: Option[Duration] = None):\n  ZIO[WalletAccessContext, ThreadIdNotFound | InvalidStateForOperation | InvitationExpired, ConnectionRecord] = ???\n\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Credential Offer and Request in TypeScript Sample App\nDESCRIPTION: This code demonstrates how to handle incoming credential offers in a TypeScript implementation. It filters incoming messages for credential offers, creates credential requests in response, and sends them back to the issuer via the agent.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\nprops.agent.addListener(ListenerKey.MESSAGE,async (newMessages:SDK.Domain.Message[]) => {\n    //newMessages can contain any didcomm message that is received, including\n    //Credential Offers, Issued credentials and Request Presentation Messages\n    const credentialOffers = newMessages.filter((message) => message.piuri === \"https://didcomm.org/issue-credential/2.0/offer-credential\");\n\n    if (credentialOffers.length) {\n        for(const credentialOfferMessage of credentialOffers) {\n        const credentialOffer = OfferCredential.fromMessage(credentialOfferMessage);\n        const requestCredential = await props.agent.prepareRequestCredentialWithIssuer(credentialOffer);\n        try {\n            await props.agent.sendMessage(requestCredential.makeMessage())\n        } catch (err) {\n            console.log(\"continue after err\", err)\n        }\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing DID Document with linkedResources Field in JSON\nDESCRIPTION: This code demonstrates a sample DID document with a linkedResources field that associates a credential schema resource with a DID. The example shows how resource metadata is described in the document, including URL, type, and name.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"@context\": \"https://w3id.org/did/v1\",\n  \"id\": \"did:example:123456789abcdefghi\",\n  \"publicKey\": [{\n    \"id\": \"did:example:123456789abcdefghi#keys-1\",\n    \"type\": \"Ed25519VerificationKey2018\",\n    \"controller\": \"did:example:123456789abcdefghi\",\n    \"publicKeyBase58\": \"7dNN1A8H4DwPU1h4btvohGadnbx8sHF2U6XJU6vLBBfA\"\n  }],\n  \"linkedResources\": [{\n    \"url\": \"https://example.com/credentialschema/123\",\n    \"type\": \"CredentialSchema\",\n    \"name\": \"DrivingLicense\"\n  }]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing User Input Validation with ZIO Prelude in Scala\nDESCRIPTION: Shows how to validate user input at the service layer using ZIO Prelude's Validation framework. This ensures consistent validation across all interfaces that interact with services, not just REST endpoints.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_9\n\nLANGUAGE: scala\nCODE:\n```\nclass ConnectionServiceImpl() extends ConnectionService {\n  def validateInputs(\n                      label: Option[String],\n                      goalCode: Option[String],\n                      goal: Option[String]\n                    ): IO[UserInputValidationError, Unit] = {\n    val validation = Validation\n      .validate(\n        ValidationUtils.validateLengthOptional(\"label\", label, 0, 255),\n        ValidationUtils.validateLengthOptional(\"goalCode\", goalCode, 0, 255),\n        ValidationUtils.validateLengthOptional(\"goal\", goal, 0, 255)\n      )\n      .unit\n    ZIO.fromEither(validation.toEither).mapError(UserInputValidationError.apply)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Issued Credentials in Android Sample App\nDESCRIPTION: This Kotlin code for Android demonstrates how to handle and process received credential messages. It filters incoming messages for issue-credential types and processes them using the agent's processIssuedCredentialMessage method.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_33\n\nLANGUAGE: kotlin\nCODE:\n```\nagent.handleReceivedMessagesEvents().collect { list ->\n    list.forEach { message ->\n        if (message.piuri == ProtocolType.DidcommIssueCredential.value) {\n                agent.processIssuedCredentialMessage(\n                    IssueCredential.fromMessage(\n                    message\n                )\n            )\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Presentation Requests with Message Listeners\nDESCRIPTION: Implementation of message listeners to handle incoming presentation requests, create presentations from credentials, and send responses.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nprops.agent.addListener(ListenerKey.MESSAGE,async (newMessages:SDK.Domain.Message[]) => {\n    const requestPresentations = newMessages.filter((message) => message.piuri === \"https://didcomm.atalaprism.io/present-proof/3.0/request-presentation\");\n\n    if (requestPresentations.length) {\n        for(const requestPresentation of requestPresentations) {\n            const lastCredentials = await props.pluto.getAllCredentials();\n            const lastCredential = lastCredentials.at(-1);\n            const requestPresentationMessage = RequestPresentation.fromMessage(requestPresentation);\n            try {\n            if (lastCredential === undefined) throw new Error(\"last credential not found\");\n\n            const presentation = await props.agent.createPresentationForRequestProof(requestPresentationMessage, lastCredential)\n            await props.agent.sendMessage(presentation.makeMessage())\n            } catch (err) {\n            console.log(\"continue after err\", err)\n            }\n        }\n    }\n})\n```\n\nLANGUAGE: swift\nCODE:\n```\nagent\n  .handleMessagesEvents()\n  .sink(receiveCompletion: { _ in }, receiveValue: { [weak self] in\n    guard\n          let message,\n          message.direction == .received,\n          let msgType = ProtocolTypes(rawValue: message.piuri)\n      else { return }\n\n      Task.detached { [weak self] in\n        do {\n          switch msgType {\n          case .didcommRequestPresentation:\n              let credential = try await agent.verifiableCredentials().map { $0.first }.first().await()\n              guard let credential else {\n                  throw UnknownError.somethingWentWrongError()\n              }\n              let presentation = try await agent.createPresentationForRequestProof(\n                  request: try RequestPresentation(fromMessage: message),\n                  credential: credential\n              )\n              _ = try await agent.sendMessage(message: try presentation.makeMessage())\n          }\n        } catch {}\n      }\n  })\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nagent.handleReceivedMessagesEvents().collect { list ->\n    list.forEach { message ->\n        if (message.piuri == ProtocolType.DidcommRequestPresentation.value && !presentationDone) {\n            viewModelScope.launch {\n                presentationDone = true\n                agent.getAllCredentials().collect {\n                    val credential = it.first()\n                    val presentation = agent.preparePresentationForRequestProof(\n                        RequestPresentation.fromMessage(message),\n                        credential\n                    )\n                    mercury.sendMessage(presentation.makeMessage())\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Modeling Validation Errors with Detailed Reporting in Scala\nDESCRIPTION: Demonstrates how to create a dedicated error type for validation failures that provides detailed information about what failed. Uses NonEmptyChunk to ensure at least one error is reported.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_10\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait ConnectionServiceError(\n                                     val statusCode: StatusCode,\n                                     val userFacingMessage: String\n                                   ) extends Failure\n\nobject ConnectionServiceError {\n  final case class UserInputValidationError(errors: NonEmptyChunk[String])\n    extends ConnectionServiceError(\n      StatusCode.BadRequest,\n      s\"The provided input failed validation: errors=${errors.mkString(\\\"[\\\", \\\"]\\\", \\\"[\\\", \\\"]\\\")}\"\n    )\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Driving License Credential Schema with JWT W3C Format\nDESCRIPTION: This curl command creates a new credential schema for a driving license with specific fields like email, name, issuance date, and driving class. It uses the Issuer API to register the schema in the schema registry and requires a published PRISM DID as the author.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X 'POST' \\\n  'http://localhost:8000/cloud-agent/schema-registry/schemas' \\\n  -H 'accept: application/json' \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n  \"name\": \"driving-license\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Driving License Schema\",\n  \"type\": \"https://w3c-ccg.github.io/vc-json-schemas/schema/2.0/schema.json\",\n  \"author\": [[publishedPrismDID]],\n  \"tags\": [\n    \"driving\",\n    \"license\"\n  ],\n  \"schema\": {\n    \"$id\": \"https://example.com/driving-license-1.0.0\",\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"description\": \"Driving License\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"emailAddress\": {\n        \"type\": \"string\",\n        \"format\": \"email\"\n      },\n      \"givenName\": {\n        \"type\": \"string\"\n      },\n      \"familyName\": {\n        \"type\": \"string\"\n      },\n      \"dateOfIssuance\": {\n        \"type\": \"string\",\n        \"format\": \"date-time\"\n      },\n      \"drivingLicenseID\": {\n        \"type\": \"string\"\n      },\n      \"drivingClass\": {\n        \"type\": \"integer\"\n      }\n    },\n    \"required\": [\n      \"emailAddress\",\n      \"familyName\",\n      \"dateOfIssuance\",\n      \"drivingLicenseID\",\n      \"drivingClass\"\n    ],\n    \"additionalProperties\": true\n  }\n}'\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Queries with Slick in Scala\nDESCRIPTION: Example code demonstrating how to use Slick to query a PostgreSQL database. It defines a Person case class and creates a query to retrieve people with ID 1, showing Slick's approach which uses a more type-safe DSL.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-01-18-quill-library-for-sql-statement-generation.md#2025-04-21_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nimport slick.jdbc.PostgresProfile.api._\n\nval db = Database.forConfig(\"database\")\n\ncase class Person(id: Int, name: String)\n\nval q = TableQuery[Person].filter(_.id === 1)\n\nval result: Future[Seq[Person]] = db.run(q.result)\n```\n\n----------------------------------------\n\nTITLE: Establishing Mediation in TypeScript\nDESCRIPTION: TypeScript code for establishing mediation and instantiating a Cloud Agent in a custom application. It initializes the required SDK components and starts the agent with mediator connection.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n  const mediatorDID = SDK.Domain.DID.fromString(\n    [[MEDIATOR DID PEER]]\n  );\n  const api = new SDK.ApiImpl();\n  const apollo = new SDK.Apollo();\n  const castor = new SDK.Castor(apollo);\n  const didcomm = new SDK.DIDCommWrapper(apollo, castor, pluto);\n  const mercury = new SDK.Mercury(castor, didcomm, api);\n  const store = new SDK.PublicMediatorStore(pluto);\n  const handler = new SDK.BasicMediatorHandler(mediatorDID, mercury, store);\n  const manager = new SDK.ConnectionsManager(castor, mercury, pluto, handler);\n  const seed = apollo.createRandomSeed()\n  const agent = new SDK.Agent(\n    apollo,\n    castor,\n    pluto,\n    mercury,\n    handler,\n    manager,\n    seed.seed\n  );\n   /**\n   * This internally will attempt to load an existing mediator from the\n   * database. If it does not exist it will try to achieve mediation\n   * automatically, by creating a PeerDID and sending a MediationRequest.\n   * After this step the mediator starts capturing messages for the PeerDID we specied.\n   */\n  await agent.start()\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Queries with Doobie in Scala\nDESCRIPTION: Example code demonstrating how to use Doobie to query a PostgreSQL database. It defines a Person case class and creates a SQL query to retrieve people with ID 1 from the database, showing Doobie's approach to database access.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-01-18-quill-library-for-sql-statement-generation.md#2025-04-21_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\nimport doobie._\nimport doobie.implicits._\nimport doobie.postgres._\n\ncase class Person(id: Int, name: String)\n\nval q = sql\"SELECT id, name FROM person WHERE id = 1\".query[Person]\n\nval result: ConnectionIO[List[Person]] = q.to[List].transact(Transactor.fromDriverManager[IO](\n  \"org.postgresql.Driver\", \"jdbc:postgresql:world\", \"username\", \"password\"\n))\n```\n\n----------------------------------------\n\nTITLE: Configuring Single Tenant with API Key Authentication in Cloud Agent\nDESCRIPTION: Environment variable configuration for enabling API key authentication and using the Default Wallet for all interactions in single-tenant mode.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Environment Variable                 | Value |\n|--------------------------------------|-------|\n| API_KEY_ENABLED                      | true  |\n| API_KEY_AUTHENTICATE_AS_DEFAULT_USER | true  |\n```\n\n----------------------------------------\n\nTITLE: Using Scala 3 Union Types for ZIO Error Handling\nDESCRIPTION: Demonstrates how to use Scala 3 Union Types to declare specific expected failures in ZIO effects, providing more precise error handling capabilities.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_1\n\nLANGUAGE: scala\nCODE:\n```\ntrait MyService {\n  def myMethod(): ZIO[Any, BusinessLogicError | DataValidationError, Unit]\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing and Accepting DIDComm Invitations\nDESCRIPTION: Code examples showing how to parse and accept Out-of-Band (OOB) DIDComm invitations across different platforms.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\nconst parsed = await props.agent.parseOOBInvitation(new URL([[OOB URL]]));\nawait props.agent.acceptDIDCommInvitation(parsed);\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet message = try agent.parseOOBInvitation(url: oobUrl)\ntry await agent.acceptDIDCommInvitation(invitation: message)\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nval invitation = agent.parseInvitation(oobUrl)\nagent.acceptOutOfBandInvitation(invitation)\n```\n\n----------------------------------------\n\nTITLE: Self-Service Wallet Registration Request\nDESCRIPTION: REST API endpoint for self-service wallet registration. Requires a valid JWT token and accepts seed and wallet name parameters. Creates a wallet resource in Keycloak and grants access to the user. The seed value remains private and x-api-key header is not needed.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_8\n\nLANGUAGE: json\nCODE:\n```\nPOST /wallets \n{\n    \"seed\": \"secured-seed-value\",\n    \"name\": \"wallet-name\"\n}\n```\n\n----------------------------------------\n\nTITLE: Storing Issued Credentials in TypeScript Sample App\nDESCRIPTION: This code snippet demonstrates how to process and store issued credentials received from a Cloud Agent in a TypeScript application. It filters received messages for issued credentials and processes each one using the agent's processIssuedCredentialMessage method.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\nprops.agent.addListener(ListenerKey.MESSAGE,async (newMessages:SDK.Domain.Message[]) => {\n    //newMessages can contain any didcomm message that is received, including\n    //Credential Offers, Issued credentials and Request Presentation Messages\n    const issuedCredentials = newMessages.filter((message) => message.piuri === \"https://didcomm.org/issue-credential/2.0/issue-credential\");\n    if (issuedCredentials.length) {\n        for(const issuedCredential of issuedCredentials) {\n            const issueCredential = IssueCredential.fromMessage(issuedCredential);\n            await props.agent.processIssuedCredentialMessage(issueCredential);\n        }\n    }\n})\n```\n\n----------------------------------------\n\nTITLE: Repository Interface with Get/Find Pattern\nDESCRIPTION: Definition of repository methods following the get/find pattern for consistent error handling.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_5\n\nLANGUAGE: scala\nCODE:\n```\ntrait ConnectionRepository {\n  def findById(recordId: UUID): URIO[WalletAccessContext, Option[ConnectionRecord]]\n\n  def getById(recordId: UUID): URIO[WalletAccessContext, ConnectionRecord]\n}\n```\n\n----------------------------------------\n\nTITLE: Establishing Issuer Cloud Agent Connection\nDESCRIPTION: Creates a new connection on the Issuer Cloud Agent running on port 8000. Returns an invitation URL and connectionId that can be shared via QR code.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request POST 'http://localhost:8000/cloud-agent/connections' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"label\": \"Cloud Agent demo connection with holder\"\n}'\n```\n\n----------------------------------------\n\nTITLE: Publishing PrismDID\nDESCRIPTION: cURL command to publish the created PrismDID, replacing {didRef} with the longFormDid value from the previous step.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request POST 'http://localhost:8000/cloud-agent/did-registrar/dids/{didRef}/publications' \\\n--header 'Accept: application/json'\n```\n\n----------------------------------------\n\nTITLE: Service Layer Not Found Error Handling\nDESCRIPTION: Service implementation showing how to handle not found scenarios by converting them to proper error types.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_7\n\nLANGUAGE: scala\nCODE:\n```\nclass ConnectionServiceImpl() extends ConnectionService {\n  override def markConnectionRequestSent(recordId: UUID):\n  ZIO[WalletAccessContext, RecordIdNotFound | InvalidStateForOperation, ConnectionRecord] =\n    for {\n      maybeRecord <- connectionRepository.findById(recordId)\n      record <- ZIO.fromOption(maybeRecord).mapError(_ => RecordIdNotFound(recordId))\n      updatedRecord <- updateConnectionProtocolState(\n        recordId,\n        ProtocolState.ConnectionRequestPending,\n        ProtocolState.ConnectionRequestSent\n      )\n    } yield updatedRecord\n}\n```\n\n----------------------------------------\n\nTITLE: Establishing Verifier Cloud Agent Connection\nDESCRIPTION: Creates a new connection on the Verifier Cloud Agent running on port 9000. Returns an invitation URL and connectionId that can be shared via QR code.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request POST 'http://localhost:9000/cloud-agent/connections' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\n    \"label\": \"Cloud Agent demo connection with holder\"\n}'\n```\n\n----------------------------------------\n\nTITLE: Establishing Mediation in Swift\nDESCRIPTION: Swift code for establishing mediation and instantiating a Cloud Agent in a custom iOS application. It initializes the agent with a mediator DID and starts message fetching.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_21\n\nLANGUAGE: swift\nCODE:\n```\n  let agent = CloudAgent(mediatorDID: did)\n  try await agent.start()\n  agent.startFetchingMessages()\n```\n\n----------------------------------------\n\nTITLE: Repository Create Method with Row Count Validation\nDESCRIPTION: Implementation of a create method that validates affected row count and converts to defect if unexpected.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_6\n\nLANGUAGE: scala\nCODE:\n```\nclass JdbcConnectionRepository(xa: Transactor[ContextAwareTask], xb: Transactor[Task]) extends ConnectionRepository {\n  override def create(record: ConnectionRecord): URIO[WalletAccessContext, Unit] = {\n    val cxnIO =\n      sql\"\"\"\n           | INSERT INTO public.connection_records(\n           |   id,\n           |   created_at,\n           |   ...\n           | ) values (\n           |   ${record.id},\n           |   ${record.createdAt},\n           |   ...\n           | )\n        \"\"\".stripMargin.update\n\n    cxnIO.run\n      .transactWallet(xa)\n      .ensureOneAffectedRowOrDie\n  }\n}\n\nextension[Int](ma: RIO[WalletAccessContext, Int]) {\n  def ensureOneAffectedRowOrDie: URIO[WalletAccessContext, Unit] = ma.flatMap {\n    case 1 => ZIO.unit\n    case count => ZIO.fail(RuntimeException(s\"Unexpected affected row count: $count\"))\n  }.orDie\n}\n```\n\n----------------------------------------\n\nTITLE: Establishing Mediation in Android Kotlin\nDESCRIPTION: Kotlin code for establishing mediation and instantiating a Cloud Agent in a custom Android application. It initializes the required SDK components and starts the agent with mediator connection.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_22\n\nLANGUAGE: kotlin\nCODE:\n```\nval apollo = ApolloImpl()\nval castor = CastorImpl(apollo)\nval pluto = Pluto(DbConnection())\n(pluto as PlutoImpl).start(context)\nval mercury = mercury = MercuryImpl(\n    castor,\n    DIDCommWrapper(castor, pluto, apollo),\n    ApiImpl(httpClient())\n)\nval pollux = PolluxImpl(castor)\nval seed = apollo.createRandomSeed()\nval handler = BasicMediatorHandler(\n  mediatorDID = DID(<DID_STRING>),\n  mercury = mercury,\n  store = BasicMediatorHandler.PlutoMediatorRepositoryImpl(pluto)\n)\nagent = CloudAgent(\n    apollo = apollo,\n    castor = castor,\n    pluto = pluto,\n    mercury = mercury,\n    pollux = pollux,\n    seed = seed,\n    mediatorHandler = handler\n)\nagent.start()\nagent.startFetchingMessages()\n```\n\n----------------------------------------\n\nTITLE: Implementing Repository Method with SQL Query and Error Handling\nDESCRIPTION: Implementation of a repository method showing SQL query execution with Doobie and conversion to UIO using orDie.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nclass JdbcConnectionRepository(xa: Transactor[ContextAwareTask], xb: Transactor[Task]) extends ConnectionRepository {\n  override def findAll: URIO[WalletAccessContext, Seq[ConnectionRecord]] = {\n    val cxnIO =\n      sql\"\"\"\n           | SELECT\n           |   id,\n           |   created_at,\n           |   ...\n           | FROM public.connection_records\n           | ORDER BY created_at\n        \"\"\".stripMargin\n        .query[ConnectionRecord]\n        .to[Seq]\n\n    cxnIO\n      .transactWallet(xa)\n      .orDie\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Credential Offer and Request in Swift Sample App\nDESCRIPTION: This Swift code sample shows how to handle DIDComm message events in a mobile app. It specifically processes credential offers by creating a new PRISM DID, preparing a credential request, and sending it back to the issuer agent.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_29\n\nLANGUAGE: swift\nCODE:\n```\nagent\n  .handleMessagesEvents()\n  .sink(receiveCompletion: { _ in }, receiveValue: { [weak self] in\n    guard\n        let message,\n        message.direction == .received,\n        let msgType = ProtocolTypes(rawValue: message.piuri)\n      else { return }\n\n      Task.detached { [weak self] in\n          do {\n            switch msgType {\n             case .didcommOfferCredential:\n                let newPrismDID = try await agent.createNewPrismDID()\n                guard let requestCredential = try await agent.prepareRequestCredentialWithIssuer(\n                    did: newPrismDID,\n                    offer: try OfferCredential(fromMessage: message)\n                ) else { throw UnknownError.somethingWentWrongError() }\n\n                _ = try await agent.sendMessage(message: try requestCredential.makeMessage())\n          } catch {}\n      }\n  })\n```\n\n----------------------------------------\n\nTITLE: Visualizing User Onboarding and Configuration with Keycloak and Cloud Agent\nDESCRIPTION: Mermaid sequence diagram illustrating the process of user onboarding, authentication flow configuration, wallet creation, and UMA policy setup in Keycloak and Cloud Agent.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n  participant Admin\n  participant Keycloak\n  participant CloudAgent\n\n  Admin->>Keycloak: 1. Creates User\n  Keycloak-->>Admin: 2. User Created\n\n  Admin->>Keycloak: 3. Configures Authentication Flow\n  Keycloak-->>Admin: 4. Authentication Flow Configured\n\n  Admin->>CloudAgent: 5. Creates Wallet in Agent\n  CloudAgent-->>Admin: 6. Sends Wallet ID\n\n  Admin->>Keycloak: 7. Registers Wallet Resource\n  Keycloak-->>Admin: 8. Resource Registered\n\n  Admin->>CloudAgent: 9. Configures UMA Policy\n  CloudAgent-->>Admin: 10. UMA Policy Configured\n```\n\n----------------------------------------\n\nTITLE: Configuring Issuer Agent Environment Variables\nDESCRIPTION: Content for the .env-issuer file to configure the Issuer Agent environment variables.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nAPI_KEY_ENABLED=false\nAGENT_VERSION=1.36.1\nPRISM_NODE_VERSION=2.4.1\nPORT=8000\nNETWORK=identus\nVAULT_DEV_ROOT_TOKEN_ID=root\nPG_PORT=5432\n```\n\n----------------------------------------\n\nTITLE: Handling Credential Offer and Request in Android Sample App\nDESCRIPTION: This Kotlin code sample for Android demonstrates how to process received DIDComm messages, filter for credential offers, and create credential requests. It checks if credentials exist before generating a new PRISM DID and sending a request back to the issuer.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_30\n\nLANGUAGE: kotlin\nCODE:\n```\nagent.handleReceivedMessagesEvents().collect { list ->\n    list.forEach { message ->\n        if (message.piuri == ProtocolType.DidcommOfferCredential.value) {\n            val credentials = pluto.getAllCredentials().first()\n            if (credentials.isEmpty()) {\n                val offer = OfferCredential.fromMessage(message)\n                val subjectDID = agent.createNewPrismDID()\n                val request =\n                agent.prepareRequestCredentialWithIssuer(\n                    subjectDID,\n                    offer\n                )\n                mercury.sendMessage(request.makeMessage())\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing User Authentication Process with Keycloak and Cloud Agent\nDESCRIPTION: Mermaid sequence diagram showing the steps involved in user authentication, JWT token validation, RPT request and validation, and API operation in Cloud Agent using Keycloak.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n  participant User\n  participant Keycloak\n  participant Agent\n\n  User->>Keycloak: 1. Initiates Authentication\n  Keycloak->>Keycloak: 2. Authenticates User\n  Keycloak-->>User: 3. Sends JWT Token\n  User->>Agent: 4. Requests API with JWT Token\n  Agent->>Agent: 5. Validates JWT Token\n  Agent->>Keycloak: 6. Requests RPT\n  Keycloak->>Keycloak: 7. Validates JWT Token\n  Keycloak-->>Agent: 8. Sends RPT\n  Agent->>Agent: 9. Validates RPT\n  Agent->>Agent: 10. Performs Operation\n  Agent-->>User: 11. Returns Result\n```\n\n----------------------------------------\n\nTITLE: Storing Issued Credentials in Swift Sample App\nDESCRIPTION: This Swift code snippet shows how to handle and process received issued credentials in a mobile app. It filters for issue-credential messages, converts them to the appropriate type, and processes them through the agent's processIssuedCredentialMessage method.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_32\n\nLANGUAGE: swift\nCODE:\n```\nagent\n  .handleMessagesEvents()\n  .sink(receiveCompletion: { _ in }, receiveValue: { [weak self] in\n    guard\n        let message = $0\n        message.direction == .received,\n        let msgType = ProtocolTypes(rawValue: message.piuri)\n      else { return }\n\n      Task.detached { [weak self] in\n          do {\n            switch msgType {\n              case .didcommIssueCredential:\n                  let issueCredential = try IssueCredential(fromMessage: message)\n                  _ = try await agent.processIssuedCredentialMessage(message: issueCredential)\n            }\n          } catch {}\n      }\n  })\n```\n\n----------------------------------------\n\nTITLE: JWT Payload Structure with ClientRole Implementation\nDESCRIPTION: Example JWT payload showing the structure of ClientRole-based authorization claims. Contains role definitions for both cloud-agent admin access and account management permissions.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-03-use-jwt-claims-for-agent-admin-auth.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"exp\": 1704267723,\n  \"aud\": [\n    \"cloud-agent\",\n    \"account\"\n  ],\n  \"realm_access\": {\n    \"roles\": [\n      \"default-roles-atala-demo\",\n      \"offline_access\",\n      \"uma_authorization\"\n    ]\n  },\n  \"resource_access\": {\n    \"cloud-agent\": {\n      \"roles\": [\n        \"admin\"\n      ]\n    },\n    \"account\": {\n      \"roles\": [\n        \"manage-account\",\n        \"manage-account-links\",\n        \"view-profile\"\n      ]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling DID Requests in TypeScript Wallet SDK\nDESCRIPTION: This TypeScript function demonstrates how a wallet can process an incoming DID request. It creates a new Peer DID with authentication and key agreement key pairs, stores the new contact, and sends the DID back to the requesting application through the Onboard service.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/onboard.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {Apollo, Castor, Domain} from \"@input-output-hk/atala-prism-wallet-sdk\";\n\n// init Apollo and Castor SDK modules. \n// Apollo = cryptography, Castor = DIDs management.\nconst apollo = new Apollo();\nconst castor = new Castor(apollo);\n\n/**\n * Wallet will receive encoded DID request as a deep link, QR code, or in some\n * other way. This is the function which will handle decoded DID request. This \n * is just a simple example where new Peer DID is created and sent back to the \n * Onboard service. In a real-world application, there would be some more \n * complex flow in which user would be asked to confirm the request, and create\n * a new contact or avatar in the wallet (or select an existing one).\n *\n * @param {type, from, onboardEndpoint} didRequest\n */\nasync function handleDidRequest(didRequest) {\n    if (didRequest.type !== \"https://atalaprism.io/did-request\") {\n        throw new Error(\"Invalid DID request\");\n    }\n\n    // create new authentication and key agreement key pairs, and use them to \n    // create a new Peer DID. Onboard service accepts any DID, but if you plan\n    // to use it with Authenticate, you should use Peer DIDs.\n    const authKeyPair = apollo.createKeyPairFromKeyCurve({\n        curve: Domain.Curve.ED25519,\n    });\n    const keyAgreementKeyPair = apollo.createKeyPairFromKeyCurve({\n        curve: Domain.Curve.X25519,\n    });\n    const peerDID = await castor.createPeerDID(\n        [authKeyPair, keyAgreementKeyPair],\n        []\n    );\n    const didStr = peerDID.toString();\n    \n    const newContact = {\n        name: didRequest.from,\n        did: didStr,\n        keys: [authKeyPair, keyAgreementKeyPair]\n    };\n    \n    // store the new contact in the wallet database\n    await storeContact(newContact);\n    \n    // POST created DID back to the Onboard service - using axios for example\n    await axios.post(didRequestReceived.onboardEndpoint, {\n        did: didStr,\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Authorization Flow with Mermaid Diagram\nDESCRIPTION: Sequence diagram depicting the authorization process flow between User, Client, CloudAgent, and Keycloak. The diagram shows authentication with JWT tokens, permission checking, and conditional responses based on user permissions for accessing credential records.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-09-26-use-keycloak-authorisation-service-for-managing-wallet-permissions.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    actor Admin\n    actor User\n    participant Client\n    participant CloudAgent\n    participant Keycloak\n\n    autonumber\n\n    User ->> Client: First visit\n    Note over Client: User is not logged in\n    Client ->> Keycloak: Login with preconfigured flow\n    Keycloak ->> Client: JWT AccessToken\n    User ->> Client: Check my VC\n    Client ->> CloudAgent: Get CredentialRecord\n\n    opt Bearer token is not RPT\n      CloudAgent ->> Keycloak: Get permissions\n      Keycloak ->> CloudAgent: Permitted resource(s)\n    end\n\n    alt is permitted\n        CloudAgent ->> Client: CredentialRecord\n    else is not permitted\n        CloudAgent ->> Client: 403 Forbidden\n    end\n```\n\n----------------------------------------\n\nTITLE: Configuring UMA Permissions for Wallet Access\nDESCRIPTION: REST API endpoint for configuring UMA permissions in Keycloak for wallet access. Requires walletId parameter and subject UUID in the request body. Only authenticated users (admin or wallet owner) can configure permissions.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_7\n\nLANGUAGE: http\nCODE:\n```\nPOST /wallets/{walletId}/uma-permissions\n```\n\n----------------------------------------\n\nTITLE: Converting Option to Defect in Repository\nDESCRIPTION: Example of converting an Option to a defect using ZIO.fromOption and orDieWith for handling missing records.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_4\n\nLANGUAGE: scala\nCODE:\n```\nclass JdbcConnectionRepository(xa: Transactor[ContextAwareTask], xb: Transactor[Task]) extends ConnectionRepository {\n  override def getById(recordId: UUID): URIO[WalletAccessContext, ConnectionRecord] =\n    for {\n      maybeRecord <- findById(recordId)\n      record <- ZIO.fromOption(maybeRecord).orDieWith(_ => RuntimeException(s\"Record not found: $recordId\"))\n    } yield record\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Mediator's Peer DID\nDESCRIPTION: Command to retrieve the Mediator's Peer DID which is needed to establish DIDCOMM V2 Mediation protocol.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request GET 'localhost:8080/invitation' \\\n--header 'Content-Type: application/json'\n```\n\n----------------------------------------\n\nTITLE: Visualizing Multi-Tenancy Component Relationships with Mermaid\nDESCRIPTION: Mermaid diagram illustrating the relationships between key components in Identus' multi-tenancy model, showing how tenants, entities, wallets, and various assets are connected. The diagram demonstrates the hierarchical structure and ownership relationships between different system components.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/concepts/multi-tenancy.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TB;\n    Tenant(Tenant) --> |Represented by| Entity\n    Tenant --> |Authenticates by| AuthMethod(Authentication Method)\n\n    subgraph Identus Platform\n            Wallet(Wallet) -->|Contains| DIDs(DIDs )\n            Wallet(Wallet) -->|Contains| VCs(Verifiable Credentials)\n            Wallet(Wallet) -->|Contains| VSSchemas(VC Schemas)\n            Wallet(Wallet) -->|Contains| Assets(Other Assets...)\n            Entity(Entity) -->|Owns| Wallet(Wallet)\n            Entity(Entity) -->|Uses| AuthMethod(Authentication Method)\n    end\n```\n\n----------------------------------------\n\nTITLE: Defining Repository Interface with URIO Return Type\nDESCRIPTION: Example of a repository interface using URIO return type to handle database operations through defects rather than explicit error types.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_2\n\nLANGUAGE: scala\nCODE:\n```\ntrait ConnectionRepository {\n  def findAll: URIO[WalletAccessContext, Seq[ConnectionRecord]]\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Node Component Interactions with Mermaid Diagram\nDESCRIPTION: A mermaid diagram illustrating the relationships between the Node's four main components: gRPC Server, PostgreSQL Database, Cardano Wallet Backend, and DB Sync. The diagram shows how these components interact with each other and with the Cardano node.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/prism-node/running-node.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TB\n    GRPC[\"Node gRPC Server\"]\n    DB[\"Node PostgreSQL Database\"]\n    CWB[\"Cardano Wallet Backend\"]\n    DBS[\"DB Sync\"]\n    CN[\"Cardano node\"]\n    \n    GRPC -->|\"Submits transactions via\"| CWB\n    GRPC -->|\"Processes data for storage\"| DB\n    DBS --> |\"Indexes the whole blockchain\"| CN\n    CWB -->|\"Submits trasactions\"| CN\n    GRPC --> |\"retrieves blocks and their transactions\"| DBS\n```\n\n----------------------------------------\n\nTITLE: Sequence Diagram for Multi-Tenant Request Routing in Cloud Agent\nDESCRIPTION: This diagram illustrates the flow of tenant registration, authorization, and DIDCOMM message handling in a multi-tenant environment. It shows how a Cloud Agent manages tenant registration, wallet creation, and DID-to-tenant mapping in the database to ensure proper message routing.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-05-09-message-routing-for-multi-tenant.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    actor H as Holder(DidComm)\n    actor T as Tenant(Issuer)\n    participant A as CloudAgent\n    participant W as Wallet\n    participant DB as Database[did \\<- tenantId]\n    T->>A: Register Tenant\n    activate A\n    A->>W: Create wallet\n            activate W\n                note over W: Each Tenant has his own wallet where keys and dids are stored\n                W-->>A: tenantId\n            deactivate W\n            note over T, A: Subsequent requests include JWT header\n            activate DB\n                note over DB: did -> tenantId or did -> walletId\n                T->>A: Create PeerDID[JWT Header]\n                A->>A: authorised token extract tenantID\n                alt JWT validation\n                    A-->>T: 200 OK & JWT\n                else No user\n                    A-->>T: 401 Unauthorized\n                end\n                T-->>A: If authorised Create PeerDID\n                A-->>DB: Update [DID(PeerDID) -> tenantID]\n                A->>H: send DIDCOMM message to holder did\n            deactivate DB\n    deactivate A\n    activate H\n        H->>A: DIDCOMMV2 message to Agent(did)\n        A-->>DB:lookup to Agent DID identify tenantId\n        A-->>A:decrypt message\n    deactivate H\n```\n\n----------------------------------------\n\nTITLE: Visualizing User Onboarding Flow with Mermaid Diagram\nDESCRIPTION: Sequence diagram showing the steps involved in onboarding new users and wallets to the system. The diagram illustrates the interaction between Admin, Client, CloudAgent, and Keycloak during resource creation, user creation, and permission assignment.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-09-26-use-keycloak-authorisation-service-for-managing-wallet-permissions.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    actor Admin\n    actor User\n    participant Client\n    participant CloudAgent\n    participant Keycloak\n\n    autonumber\n\n    Admin ->> CloudAgent: Create a new wallet\n    CloudAgent ->> Keycloak: Register a new resource\n    Admin ->> Keycloak: Create a new user\n    Admin ->> Keycloak: Create a new user-credential\n    Admin ->> Keycloak: Create a new permission\n    Admin ->> Keycloak: Associate permission(s) with a resource\n```\n\n----------------------------------------\n\nTITLE: Configuring Admin-Api-Key Authentication in Cloud Agent\nDESCRIPTION: Environment variable configuration for setting up Admin-Api-Key authentication to protect administrative REST APIs.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| Environment Variable | Value  |\n|----------------------|--------|\n| ADMIN_API_KEY        | secret |\n```\n\n----------------------------------------\n\nTITLE: Verifying Presentation Request Completion\nDESCRIPTION: API endpoint example for checking the status of a presentation request completion.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\ncurl --location \\\n--request GET 'http://localhost:9000/cloud-agent/present-proof/presentations/[[presentationRequestId]]' \\\n--header 'Accept: application/json'\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Tenant with API Key Authentication and Auto-Provisioning in Cloud Agent\nDESCRIPTION: Environment variable configuration for enabling API Key authentication with auto-provisioning of tenant's Entity, Wallet, and API key during the first interaction in multi-tenant mode.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| Environment Variable                 | Value |\n|--------------------------------------|-------|\n| API_KEY_ENABLED                      | true  |\n| API_KEY_AUTHENTICATE_AS_DEFAULT_USER | false |\n| AUTO_PROVISIONING_ENABLED            | true  |\n```\n\n----------------------------------------\n\nTITLE: Tracking Authentication Challenge State in JavaScript\nDESCRIPTION: This function continuously checks the state of an authentication challenge, handling various outcomes such as expiration, error, or successful authentication. It includes user lookup by DID and JWT token generation upon successful authentication.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/authenticate.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nasync function trackAuthChallengeState(challengeId) {\n  while (true) {\n    const authChallengeState = await prismApiClient.getAuthenticationChallenge(challengeId);\n\n    // expiration time default is 2 minutes\n    if (isExpired(authChallengeState.challenge.expireAt)) {\n      console.info(`Challenge \"${authChallengeState.id}\" has been expired`);\n      return respondWithErrorToApplicationFrontend(\"CHALLENGE_EXPIRED\");\n    }\n\n    if (authChallengeState.state === \"error\") {\n      // invalid response has been received - either invalid signature or invalid body format\n      console.info(`Invalid response to challenge \"${authChallengeState.id}\" has been received`);\n      return respondWithErrorToApplicationFrontend(\"INVALID_CHALLENGE_RESPONSE\");\n    }\n\n    if (authChallengeState.state === \"success\") {\n      console.info(`Valid response to challenge \"${authChallengeState.id}\" has been received`);\n      console.info(`Challenge signed with DID: \"${authChallengeState.did}\"`);\n\n      // user has to use DID which is already registered in the application!\n      const userData = await getUserByDid(authChallengeState.did);\n\n      if (!userData) {\n        return respondWithErrorToApplicationFrontend(\"UNKNOWN_DID\");\n      }\n\n      // create JWT access token, in the same way as it's done for password-based login\n      const accessToken = jwt.sign({ userId: userData.id }, process.env.JWT_SECRET, {\n        expiresIn: \"1h\",\n      });\n\n      return respondWithSuccessToApplicationFrontend({\n        accessToken, \n        userData: {\n          id: userData.id,\n          did: userData.did, \n          email: userData.email, \n        }\n      });\n    }\n\n    // challenge is still pending - wait for a while and check again\n    await wait(5000);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multi-Tenant with API Key Authentication in Cloud Agent\nDESCRIPTION: Environment variable configuration for enabling API Key authentication and using the Entity and Wallet associated with the API-Key for all interactions in multi-tenant mode.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Environment Variable                 | Value |\n|--------------------------------------|-------|\n| API_KEY_ENABLED                      | true  |\n| API_KEY_AUTHENTICATE_AS_DEFAULT_USER | false |\n```\n\n----------------------------------------\n\nTITLE: Defining Authentication Challenge State in JSON\nDESCRIPTION: This JSON structure represents the state of an authentication challenge, including the challenge details, status, and associated metadata.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/authenticate.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"self\": \"https://demo.atalaprism.io/did-authentication/challenges/challenge-id-1234\",\n  \"kind\": \"AuthenticationChallengeState\",\n  \"id\": \"challenge-id-1234\",\n  \"challenge\": {\n    \"type\": \"https://atalaprism.io/authentication-challenge\",\n    \"submissionEndpoint\": \"https://demo.atalaprism.io:8085/did-authentication/challenge-submissions/request-id-1234\",\n    \"nonce\": \"authenticate-NzIxZTZmNjQtOGY0Ni00ODQ4LWFhYjAtZGYzNDJmYzNlMjM2\",\n    \"from\": \"Application ABC\",\n    \"expireAt\": \"2021-10-31T09:22:23Z\"\n  },\n  \"did\": null,\n  \"state\": \"pending\",\n  \"createdAt\": \"2023-02-24T19:13:23Z\",\n  \"updatedAt\": \"2023-02-24T19:13:23Z\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Single Tenant without API Key Authentication in Cloud Agent\nDESCRIPTION: Environment variable configuration for disabling API key authentication and using the Default Wallet for all interactions in single-tenant mode.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/authentication.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Environment Variable | Value |\n|----------------------|-------|\n| API_KEY_ENABLED      | false |\n```\n\n----------------------------------------\n\nTITLE: DID Request State Example in JSON\nDESCRIPTION: This JSON example shows the structure of a DID request state, containing the request details, current status, and metadata. It includes the didRequest object which should be encoded and sent to the receiving party.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/onboard.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"self\": \"https://demo.atalaprism.io/did-requests/did-request-1234\",\n  \"kind\": \"DidRequestState\",\n  \"id\": \"did-request-1234\",\n  \"didRequest\": {\n    \"type\": \"https://atalaprism.io/did-request\",\n    \"onboardEndpoint\": \"https://demo.atalaprism.io:8085/request-id-1234\",\n    \"from\": \"Application ABC\"\n  },\n  \"did\": null,\n  \"state\": \"pending\",\n  \"createdAt\": \"2023-02-24T10:22:23Z\",\n  \"updatedAt\": \"2023-02-24T10:22:23Z\"\n}\n```\n\n----------------------------------------\n\nTITLE: Checking DID Request Status in JavaScript\nDESCRIPTION: This JavaScript function implements a background job that periodically checks the status of a DID request. It handles error states, processes successful responses, and updates the user profile with the received DID when available.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/onboard.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nasync function checkDidRequest(didRequestId, userId) {\n  let didRequestState = await prismApiClient.getDidRequest(didRequestId);\n\n  if (didRequestState.state === \"error\") {\n    console.log(`DID request (${didRequestState.id}) for ${userId} has been either rejected or failed`);\n    await cancelBackgroundTrackingJob();\n    return;\n  } \n  \n  if (didRequestState.did) {\n    console.log(`Received a DID (`${didRequestState.did}`) from ${userId} at ${didRequestState.updatedAt}`);\n    await updateUserProfile(userId, {did: didRequestState.did});\n    await cancelBackgroundTrackingJob();\n    return;\n  }\n  \n  // ...still no response, wait for next check iteration\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a DID URL for Credential Schema Reference\nDESCRIPTION: Example of a DID URL format used to reference a credential schema within the Identus platform. This URL can be used in Issue Credential and Present Proof protocols to identify the schema being used.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_8\n\nLANGUAGE: json\nCODE:\n```\ndid:prism:abcdefg1234567890?service=credentialschema&relativeRef=%2Ff3d39687-69f5-4046-a960-3aae86a0d3ca\n```\n\n----------------------------------------\n\nTITLE: Visualizing Secrets Storage Sequence in Hyperledger Identus using Mermaid\nDESCRIPTION: This Mermaid sequence diagram illustrates the flow of secrets storage in Hyperledger Identus. It shows the interaction between the Application, Agent, Wallet, and Secrets Storage components during a typical secrets retrieval process.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/cloud-agent/secrets-storage.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Application->>+Agent: REST API\n    Agent->>+Wallet: route the request\n    Wallet->>+Secrets Storage: get secrets\n    Secrets Storage->>+Wallet: secrets\n    Wallet->>+Wallet: business logic\n    Wallet->>+Agent: route the response\n    Agent->>+Application: REST API\n```\n\n----------------------------------------\n\nTITLE: Issuance Flow Scenarios Table in Markdown\nDESCRIPTION: Defines error scenarios and problem report actions specific to the Issuance protocol flow\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-15-Error-handling-report-problem-agent.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n| Agent           | Behaviour                                    | Action                             |\n|-----------------|----------------------------------------------|------------------------------------|\\n| Scenario I1     | Send a problem report                        | e.p.msg.credential-format-mismatch |\n| Scenario I2     | Send a problem report                        | e.p.msg.invalid-signature          |\n| Scenario I3     | Send a problem report                        | e.p.msg.schema-mismatch            |\n| Scenario I4     | Send a problem report (DB connection issues) | e.p.me.res.storage                 |\n| Scenario I5     | Send a problem report (After max retries)    | e.p.req.max-retries-exceeded       |\n| Scenario I6(G3) | Send a problem report Any other error        | e.p.error                          |\n```\n\n----------------------------------------\n\nTITLE: Example of Prism Envelope Structure in JSON\nDESCRIPTION: Demonstrates the response format for endpoints implementing the Prism Anoncred method. The structure contains an encoded resource string and a DID URL for resolution.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/concepts/glossary.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\"resource\": <encoded resource as string>, url: <did url at which this resource can be resolved>}\n```\n\n----------------------------------------\n\nTITLE: Defining a Service Endpoint in a DID Document\nDESCRIPTION: Service endpoint definition within a DID Document that enables the resolution of credential schemas. This configuration allows any SSI ecosystem system to discover and fetch the schema resource using the Universal Resolver.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{  \n  \"service\": [\n    {\n      \"id\": \"did:prism:abcdefg#credentialschema\",\n      \"type\": \"CredentialSchemaService\",\n      \"serviceEndpoint\": \"https://agent.example.com/schema-registry/schemas\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Queries with Quill in Scala\nDESCRIPTION: Example code demonstrating how to use Quill to query a PostgreSQL database. It defines a Person case class and creates a query to retrieve people with ID 1, showing Quill's approach which generates SQL at compile time.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-01-18-quill-library-for-sql-statement-generation.md#2025-04-21_snippet_3\n\nLANGUAGE: scala\nCODE:\n```\nimport io.getquill._\n\nval ctx = new SqlMirrorContext(PostgresDialect, \"ctx\")\n\ncase class Person(id: Int, name: String)\n\nval q = quote {\n  query[Person].filter(p => p.id == 1)\n}\n\nval result: List[Person] = ctx.run(q)\n```\n\n----------------------------------------\n\nTITLE: Creating a Resource Metadata Object for Blockchain Storage\nDESCRIPTION: JSON structure representing the metadata required to store a credential schema as a general resource on the Cardano blockchain. It includes identifiers, resource type, and encoded data to maintain the resource's integrity.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n        \"id\": \"f3d39687-69f5-4046-a960-3aae86a0d3ca\",\n        \"name\": \"DrivingLicense-1.0\",\n        \"resourceType\": \"CredentialSchema\",\n        \"mediaType\": \"application/json\", // MIME Type of the resource\n        \"data\": \"SGVsbG8sIHdvcmxk\", // base 64 encoded or CBOR file\n        \"did\": \"did:prism:abdcefg\", // the DID reference to link the resource to the DID and create the anchor to the DID\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Domain Error ADTs in Scala\nDESCRIPTION: Example showing how to model domain-specific errors using Algebraic Data Types (ADTs) with a sealed trait and specific error cases defined in the companion object.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-16-use-zio-failures-and-defects-effectively.md#2025-04-21_snippet_0\n\nLANGUAGE: scala\nCODE:\n```\nsealed trait DomainError\n\nobject DomainError {\n  final case class BusinessLogicError(message: String) extends DomainError\n\n  final case class DataValidationError(message: String) extends DomainError\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a JSON Schema for a Driving License Credential\nDESCRIPTION: A JSON Schema definition for a driving license credential, including essential properties like email address, name, issuance date, and license details. The schema includes a proof section with RSA signature for verification.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$id\": \"driving-license-1.0\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"description\": \"Driving License\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"credentialSubject\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"emailAddress\": {\n          \"type\": \"string\",\n          \"format\": \"email\"\n        },\n        \"givenName\": {\n           \"type\": \"string\"\n        },\n        \"familyName\": {\n           \"type\": \"string\"\n        },\n        \"dateOfIssuance\": {\n           \"type\": \"datetime\"\n        },\n        \"drivingLicenseID\": {\n           \"type\": \"string\"\n        },\n        \"drivingClass\": {\n           \"type\": \"integer\"\n        },\n        \"required\": [\n          \"emailAddress\",\n          \"familyName\",\n          \"dateOfIssuance\",\n          \"drivingLicenseID\",\n          \"drivingClass\"\n        ],\n        \"additionalProperties\": true\n      }\n    }\n  },\n  \"proof\": {\n    \"type\": \"RsaSignature2018\",\n    \"created\": \"2023-04-18T10:30:00Z\",\n    \"jws\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6Imh0dHBzOi8vZXhhbXBsZS5jb20vY3JlZGVudGlhbHMvc3ViamVjdCIsInR5cGUiOiJWZXJpZmljYWxpY0NyZWRlbnRpYWwiLCJpc3N1ZXIiOiJodHRwczovL2V4YW1wbGUuY29tL2lzc3VlciIsImlzc3VlckRhdGUiOiIyMDIzLTA0LTE4VDEwOjMwOjAwWiIsImV4cGlyYXRpb25EYXRlIjoiMjAyNC0wNC0xOFQxMDowOTo1MFoiLCJjcmVkZW50aWFsU3ViamVjdCI6eyJpZCI6Imh0dHBzOi8vZXhhbXBsZS5jb20vY3JlZGVudGlhbHMvc3ViamVjdC9zdWJqZWN0IiwibmFtZSI6IkpvaG4gRG9lIiwic2lnbmF0dXJlIjoxMH19.OesuS6eC0gVh8SZpESM7Z4Yln9sGSsJHQ8s0LlcsD99H6_7U6vukUeT2_GZTtuTf9SwIfdtgViFTOfhzGTyM6oMGEeUJv6Umlh6TQ1fTm9XEDQV7JDBiaxRzV7S_vS6i\",\n    \"alg\": \"RS256\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Rust and Wasm-Pack for TypeScript SDK Dependencies\nDESCRIPTION: Commands to install Rust and Wasm-Pack, which are required dependencies for building the TypeScript SDK as it leverages AnonCreds and DIDComm Rust libraries.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\ncurl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n```\n\n----------------------------------------\n\nTITLE: DID URL Service Definition for Resource Dereferencing\nDESCRIPTION: Example of service definition in a DID document for resource dereferencing using W3C specification approach.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"service\": [\n    {\n      \"id\": \"did:prism:abcdefg#credentialschema\",\n      \"type\": \"CredentialSchema\",\n      \"serviceEndpoint\": \"https://agent.example.com/schema-registry\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Mediator with Docker on Linux\nDESCRIPTION: Command to run the Identus Mediator in a Docker container on Linux with appropriate service endpoints configured.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nMEDIATOR_VERSION=0.15.0 SERVICE_ENDPOINTS=\"http://$(ip addr show $(ip route show default | awk '/default/ {print $5}') | grep 'inet ' | awk '{print $2}' | cut -d/ -f1):8080;ws://$(ip addr show $(ip route show default | awk '/default/ {print $5}') | grep 'inet ' | awk '{print $2}' | cut -d/ -f1):8080/ws\" docker compose up\n```\n\n----------------------------------------\n\nTITLE: Implementing linkedResourceMetadata in DID Document (Cheqd)\nDESCRIPTION: Example of how resource metadata is stored within a DID document's didDocumentMetadata field, including versioning information and resource properties.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n \"didDocumentMetadata\": {\n  \"linkedResourceMetadata\": [\n    {\n      \"resourceURI\": \"did:cheqd:mainnet:1f8e08a2-eeb6-40c3-9e01-33e4a0d1479d/resources/f3d39687-69f5-4046-a960-3aae86a0d3ca\",\n      \"resourceCollectionId\": \"1f8e08a2-eeb6-40c3-9e01-33e4a0d1479d\",\n      \"resourceId\": \"f3d39687-69f5-4046-a960-3aae86a0d3ca\",\n      \"resourceName\": \"PassportSchema\",\n      \"resourceType\": \"CL-Schema\",\n      \"mediaType\": \"application/json\",\n      \"created\": \"2022-07-19T08:40:00Z\",\n      \"checksum\": \"7b2022636f6e74656e74223a202274657374206461746122207d0ae3b0c44298\",\n      \"previousVersionId\": null,\n      \"nextVersionId\": null\n    }\n  ]\n }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Mediator with Docker on Mac OSX\nDESCRIPTION: Command to run the Identus Mediator in a Docker container on Mac OSX with appropriate service endpoints configured.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nMEDIATOR_VERSION=0.15.0 SERVICE_ENDPOINTS=\"http://$(ipconfig getifaddr $(route get default | grep interface | awk '{print $2}')):8080;ws://$(ipconfig getifaddr $(route get default | grep interface | awk '{print $2}')):8080/ws\" docker compose up\n```\n\n----------------------------------------\n\nTITLE: Starting Verifier Cloud Agent on Linux\nDESCRIPTION: Command to start the Verifier Cloud Agent on Linux, specifying the configuration file and port.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./infrastructure/local/run.sh -n verifier -b -e ./infrastructure/local/.env-verifier -p 9000 -d \"$(ip addr show $(ip route show default | awk '/default/ {print $5}') | grep 'inet ' | awk '{print $2}' | cut -d/ -f1)\"\n```\n\n----------------------------------------\n\nTITLE: Feature Implementation Workflow Diagram with Tapir\nDESCRIPTION: A mermaid flowchart diagram illustrating the feature implementation workflow using Tapir library. It shows the process from feature start through endpoint definition, domain model editing, code generation, and compilation to feature completion.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2022-10-05-using-tapir-library-as-a-dsl-for-openapi-specification.md#2025-04-21_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    U[Start Feature] --> |Edit Endpoint Specification| ED(Endpoint Definition)\n    U --> |Edit Input/Output Types| DM(Domain Model)\n    ED --> |Input| TE(Tapir Library)\n    DM --> |Input| TE\n    TE --> |Generate| A\n    TE --> |Interpret| SC(Server Code)\n    TE --> |Interpret| CC(Client Code)\n    TE --> |Produce| SW(Swagger UI)\n    TE --> |Produce| RD(Redoc UI)\n    TE --> |Compilation Error| U\n    A[OAS File] --> |Input| E\n    U --> |Edit Template| E\n    E[Generator & Templates]-->|Generate Server Code| B(Server Code)\n    E -->|Generate Client Code| C(Client Code)\n    C -->|Compile| OC(Other Compiler)\n    OC -->|Compilation Error| I\n    OC -->|Success| T\n    E -->|Host file as Swagger UI| D(Swagger)\n    B --> |Compile| S(Scala Compiler)\n    S --> |Compilation Error| I(Investigate)\n    I --> |Try again| U\n    S --> |Success| T(Complete Feature)\n```\n\n----------------------------------------\n\nTITLE: Starting Issuer Cloud Agent on Linux\nDESCRIPTION: Command to start the Issuer Cloud Agent on Linux, specifying the configuration file and port.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./infrastructure/local/run.sh -n issuer -b -e ./infrastructure/local/.env-issuer -p 8000 -d \"$(ip addr show $(ip route show default | awk '/default/ {print $5}') | grep 'inet ' | awk '{print $2}' | cut -d/ -f1)\"\n```\n\n----------------------------------------\n\nTITLE: Starting Verifier Cloud Agent on macOS\nDESCRIPTION: Command to start the Verifier Cloud Agent on macOS, specifying the configuration file and port.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./infrastructure/local/run.sh -n verifier -b -e ./infrastructure/local/.env-verifier -p 9000 -d \"$(ipconfig getifaddr $(route get default | grep interface | awk '{print $2}''))\"\n```\n\n----------------------------------------\n\nTITLE: Visualizing Server-Side Flow with Tapir in Mermaid\nDESCRIPTION: A flow diagram showing how endpoint definitions in Tapir DSL generate OpenAPI specifications, server and client stubs, and documentation UIs.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2022-10-05-using-tapir-library-as-a-dsl-for-openapi-specification.md#2025-04-21_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    ED(Endpoint Definition) --> |Generate| OAS(OpenAPI Specification)\n    ED --> |Generate| AAUI(AsyncAPI Specification)\n    ED --> |Interpret| SSS(Scala Server Stub)\n    ED --> |Interpret| SCS(Scala Client Stub)\n    ED --> |Produce| SUI(Swagger UI)\n    ED --> |Produce| RUI(Redoc UI)\n    OAS --> |Input| OAT(OpenAPI Tools)\n    OAT --> |Generate| SS(Server Stub)\n    OAT --> |Generate| CS(Client Stub)\n```\n\n----------------------------------------\n\nTITLE: Starting Issuer Cloud Agent on macOS\nDESCRIPTION: Command to start the Issuer Cloud Agent on macOS, specifying the configuration file and port.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./infrastructure/local/run.sh -n issuer -b -e ./infrastructure/local/.env-issuer -p 8000 -d \"$(ipconfig getifaddr $(route get default | grep interface | awk '{print $2}''))\"\n```\n\n----------------------------------------\n\nTITLE: Processing OOB Invitation - Multiple Languages\nDESCRIPTION: Code examples for parsing and accepting Out of Bounds (OOB) invitations in different programming languages using agent SDKs.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_25\n\nLANGUAGE: javascript\nCODE:\n```\nconst parsed = await props.agent.parseOOBInvitation(new URL([[OOB URL]]))\nawait props.agent.acceptDIDCommInvitation(parsed)\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet message = try agent.parseOOBInvitation(url: oobUrl)\ntry await agent.acceptDIDCommInvitation(invitation: message)\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nval invitation = agent.parseInvitation(oobUrl)\nagent.acceptOutOfBandInvitation(invitation)\n```\n\n----------------------------------------\n\nTITLE: Storing Credential Schema Transaction in Hyperledger AnonCreds\nDESCRIPTION: Example of a credential schema transaction stored on-chain in the Hyperledger AnonCreds system. It includes the schema data, metadata, and transaction details.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"txn\": {\n    \"data\": {\n      \"data\": {\n        \"attr_names\": [\n          \"birthlocation\",\n          \"facephoto\",\n          \"expiry_date\",\n          \"citizenship\",\n          \"name\",\n          \"birthdate\",\n          \"firstname\",\n          \"uuid\"\n        ],\n        \"name\": \"BasicIdentity\",\n        \"version\": \"1.0.0\"\n      }\n    },\n    \"metadata\": {\n      \"digest\": \"06bf8a90335563826154700bf80003598932c8ffaffd4f3656fd8ed604bbb639\",\n      \"endorser\": \"Ar1YzNwcM74M2Z4XKUWXMW\",\n      \"from\": \"Y6LRXGU3ZCpm7yzjVRSaGu\",\n      \"payloadDigest\": \"44e0181c9f9d5080434f9bf11801f1b0768a6b985195e14d56e5dab06fde0cb8\",\n      \"reqId\": 1632381635230531300,\n      \"taaAcceptance\": {\n        \"mechanism\": \"at_submission\",\n        \"taaDigest\": \"8cee5d7a573e4893b08ff53a0761a22a1607df3b3fcd7e75b98696c92879641f\",\n        \"time\": 1632355200\n      }\n    },\n    \"protocolVersion\": 2,\n    \"type\": \"101\",\n    \"typeName\": \"SCHEMA\"\n  },\n  \"txnMetadata\": {\n    \"seqNo\": 73904,\n    \"txnId\": \"Y6LRXGU3ZCpm7yzjVRSaGu:2:BasicIdentity:1.0.0\",\n    \"txnTime\": \"2021-09-23T07:20:40.000Z\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Rotation in Docker Compose for Identus Mediator\nDESCRIPTION: This YAML snippet demonstrates how to set up log rotation in a Docker Compose configuration for the Identus mediator service. It limits log file size to 10MB and keeps up to 3 rotated log files.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/troubleshooting&considerations.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nversion: '3.8'\n\nservices:\n  identus-mediator:\n    image: ghcr.io/input-output-hk/atala-prism-mediator:0.14.2\n    logging:\n      driver: json-file\n      options:\n        max-size: \"10m\"\n        max-file: \"3\"\n```\n\n----------------------------------------\n\nTITLE: DID URL Resource Parameter Examples (ToIP)\nDESCRIPTION: Examples of DID URLs using the ToIP specification's resource parameter approach for different resource types and formats.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_3\n\nLANGUAGE: text\nCODE:\n```\ndid:example:21tDAKCERh95uGgKbJNHYp/some/path?resource=true\n\ndid:example:21tDAKCERh95uGgKbJNHYp/some/longer/path?resource=json\n\ndid:example:21tDAKCERh95uGgKbJNHYp/uuid:33ad7beb-1abc-4a26-b892-466df4379a51/?resource=ld+json\n\ndid:example:21tDAKCERh95uGgKbJNHYp/resources/uuid:33ad7beb-1abc-4a26-b892-466df4379a51/?resource=cbor\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Log Management in Docker Daemon\nDESCRIPTION: This JSON snippet shows how to configure global logging options in the Docker daemon configuration file. It sets a maximum log file size of 10MB and keeps up to 3 rotated log files for all containers.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/troubleshooting&considerations.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"log-driver\": \"json-file\",\n  \"log-opts\": {\n    \"max-size\": \"10m\",\n    \"max-file\": \"3\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Behavior Table in Markdown\nDESCRIPTION: Defines general error scenarios and their corresponding problem report actions for DIDComm agent behavior\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-15-Error-handling-report-problem-agent.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n | Agent       | Behaviour                      | Action              |\n |-------------|--------------------------------|-------------------|\n | Scenario G1 | Send a problem report          | e.p.msg.unsupported |\n | Scenario G2 | Send a problem report          | e.p.msg.unsupported |\n | Scenario G3 | Send a problem report          | e.p.error           |\n | Scenario G4 | (Sync ?) Send a problem report | e.p.trust.crypto    |\n | Scenario G5 | (Sync ?) Send a problem report | e.p.did             |\n | Scenario G6 | (Sync ?) Send a problem report | e.p.did.malformed   |\n | Scenario G7 | Send a problem report          | e.p.msg.\\<PIURI\\>     |\n```\n\n----------------------------------------\n\nTITLE: Cloning Mediator Repository\nDESCRIPTION: Command to clone the Hyperledger Identus Mediator repository, which provides services for message routing between issuers, verifiers, and holders.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/hyperledger/identus-mediator\n```\n\n----------------------------------------\n\nTITLE: Connection Flow Scenarios Table in Markdown\nDESCRIPTION: Defines error scenarios and problem report actions specific to the Connection protocol flow\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-15-Error-handling-report-problem-agent.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Agent            | Behaviour                                           | Action                       |\n|------------------|-----------------------------------------------------|------------------------------|\n| Scenario C1      | Send a problem report (Invitation expired)          | e.p.msg.invitation-expired   |\n| Scenario C2      | Send a problem report (Invitation parsing decoding) | e.p.msg.malformed-invitation |\n| Scenario C3      | Send a problem report (DB connection issues)        | e.p.me.res.storage           |\n| Scenario C4      | Send a problem report (After max retries)           | e.p.req.max-retries-exceeded |\n| Scenario C5 (G3) | Send a problem report Any other error               | e.p.error                    |\n```\n\n----------------------------------------\n\nTITLE: Cloning TypeScript SDK Repository\nDESCRIPTION: Command to clone the Hyperledger Identus TypeScript SDK repository, which provides wallet functionality for credential management.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/hyperledger-identus/sdk-ts\n```\n\n----------------------------------------\n\nTITLE: Verification Flow Scenarios Table in Markdown\nDESCRIPTION: Defines error scenarios and problem report actions specific to the Verification protocol flow\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2024-01-15-Error-handling-report-problem-agent.md#2025-04-21_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n| Agent           | Behaviour                                    | Action                                |\n|-----------------|----------------------------------------------|---------------------------------------|\n| Scenario V1     | Send a problem report                        | e.p.msg.credential-format-mismatch    |\n| Scenario V2     | Send a problem report                        | e.p.msg.invalid-signature             |\n| Scenario V3     | Send a problem report                        | e.p.msg.revoked-credentials           |\n| Scenario V4     | Send a problem report                        | e.p.msg.expired-credentials           |\n| Scenario V5     | Send a problem report                        | e.p.msg.proof-mismatch                |\n| Scenario V6     | Send a problem report                        | e.p.msg.schema-mismatch               |\n| Scenario V7     | Send a problem report                        | e.p.msg.revoked-or-expired-issuer-key |\n| Scenario V8     | Send a problem report (After max retries)    | e.p.req.max-retries-exceeded          |\n| Scenario V9(G3) | Send a problem report Any other error        | e.p.error                             |\n| Scenario V10    | Send a problem report (DB connection issues) | e.p.me.res.storage                    |\n```\n\n----------------------------------------\n\nTITLE: Cloning Identus Cloud Agent Repository\nDESCRIPTION: Command to clone the Hyperledger Identus Cloud Agent repository from GitHub.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/hyperledger/identus-cloud-agent\n```\n\n----------------------------------------\n\nTITLE: Discovering Credential Schema in Hyperledger AnonCreds\nDESCRIPTION: Example of how to discover a credential schema using Indy SDK in the Hyperledger AnonCreds system. The schema ID format is shown.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nY6LRXGU3ZCpm7yzjVRSaGu:2:BasicIdentity:1.0.0\n```\n\n----------------------------------------\n\nTITLE: Cloning Swift SDK Repository\nDESCRIPTION: Command to clone the Hyperledger Identus Swift SDK repository for iOS wallet implementation.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/hyperledger/identus-edge-agent-sdk-swift\n```\n\n----------------------------------------\n\nTITLE: Cloning KMM SDK Repository for Android\nDESCRIPTION: Command to clone the Hyperledger Identus Kotlin Multiplatform Mobile (KMM) SDK repository for Android wallet implementation.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/hyperledger/identus-edge-agent-sdk-kmm\n```\n\n----------------------------------------\n\nTITLE: DID Resource Options Comparison Table\nDESCRIPTION: Markdown table comparing different DID resource implementation options across multiple criteria including simplicity, trust, scalability, interoperability, discoverability and decentralization.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-04-05-did-linked-resources.md#2025-04-21_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n| Option                                     | Simplicity                           | Trust              | Scalability                          | Interop                              | Discoverability    | Decentalisation    |\n|--------------------------------------------|--------------------------------------|--------------------|--------------------------------------|--------------------------------------|--------------------|--------------------|\\n| linkedResources field                      | :heavy_plus_sign:                    | :heavy_check_mark: | :heavy_minus_sign:                   | :heavy_minus_sign:                   | :heavy_plus_sign:  | N/A                |\\n| linkedResourceMetadata (Cheqd)             | :heavy_minus_sign:/:heavy_plus_sign: | :heavy_check_mark: | :heavy_minus_sign:/:heavy_plus_sign: | :heavy_plus_sign:                    | :heavy_plus_sign:  | :heavy_check_mark: |\\n| DID URL Dereferencing (W3C specification)  | :heavy_plus_sign:                    | N/A                | :heavy_plus_sign:                    | :heavy_plus_sign:                    | :heavy_minus_sign: | :heavy_check_mark: |\\n| DID URL Dereferencing (ToIP specification) | :heavy_minus_sign:                   | :heavy_check_mark: | :heavy_plus_sign:/:heavy_minus_sign: | :heavy_plus_sign:/:heavy_minus_sign: | :heavy_plus_sign:  | :heavy_check_mark: |\\n| RootsID - Cardano AnonCreds                | :heavy_plus_sign:                    | :heavy_check_mark: | :heavy_plus_sign:/:heavy_minus_sign: | :heavy_plus_sign:                    | :heavy_plus_sign:  | :heavy_check_mark: |\\n| Hyperledger AnonCreds                      | :heavy_plus_sign:                    | :heavy_check_mark: | :heavy_plus_sign:                    | :heavy_minus_sign:                   | :heavy_minus_sign: | :heavy_check_mark: |\\n| Trinsic                                    | :heavy_minus_sign:                   | :heavy_check_mark: | :heavy_plus_sign:/:heavy_minus_sign: | :heavy_minus_sign:                   | :heavy_minus_sign: | :heavy_check_mark: |\\n| Solution #1 W3C                            | :heavy_plus_sign:                    | :heavy_check_mark: | :heavy_plus_sign:                    | :heavy_plus_sign:                    | :heavy_minus_sign: | :heavy_check_mark: |\\n| Solution #2 ToIP                           | :heavy_minus_sign:                   | :heavy_check_mark: | :heavy_minus_sign:/:heavy_plus_sign: | :heavy_plus_sign:/:heavy_minus_sign: | :heavy_plus_sign:  | :heavy_check_mark: |\n```\n\n----------------------------------------\n\nTITLE: Building TypeScript SDK from Source\nDESCRIPTION: Commands to build the Hyperledger Identus TypeScript SDK from source, including initializing git submodules, installing dependencies, and building the project.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncd sdk-ts\ngit submodule update --init --recursive\nnpm i\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Example DID URL Format in Markdown\nDESCRIPTION: Demonstrates the format of a DID URL with path and query parameters that can resolve a resource via service endpoints in the DID document.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/concepts/glossary.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\ndid:prism:9f847f8bbb66c112f71d08ab39930d468ccbfe1e0e1d002be53d46c431212c26?resourceService=agent-base-url&resourcePath=schema-registry/schemas/did-url&resourceHash=4074bb1a8e0ea45437ad86763cd7e12de3fe8349ef19113df773b0d65c8a9c46\n```\n```\n\n----------------------------------------\n\nTITLE: Starting TypeScript SDK React Demo Application\nDESCRIPTION: Commands to start the React demo application included with the TypeScript SDK for testing Identus wallet functionality.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncd demos/next\nnpm i\nnpm run build\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Explaining Doobie as a Pure Functional JDBC Layer for Scala\nDESCRIPTION: Quote from the Doobie documentation describing it as a pure functional JDBC layer for Scala and Cats, emphasizing that it's not an ORM but provides a functional approach to JDBC operations.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-01-18-quill-library-for-sql-statement-generation.md#2025-04-21_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nDoobie is a pure functional JDBC layer for Scala and Cats. It is not an ORM, nor is it a relational algebra; \nit simply provides a functional way to construct programs (and higher-level libraries) that use JDBC\ndoobie is a Typelevel project. \nThis means we embrace pure, typeful, functional programming, and provide a safe and friendly environment for teaching, learning, and contributing as described in the Scala Code of Conduct.\n```\n\n----------------------------------------\n\nTITLE: Explaining Quill as a Database Access Library\nDESCRIPTION: Quote from the Quill documentation describing it as a library that provides a Quoted Domain Specific Language to express queries in Scala with features like boilerplate-free mapping, quoted DSL, and compile-time query generation and validation.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2023-01-18-quill-library-for-sql-statement-generation.md#2025-04-21_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nQuill provides a Quoted Domain Specific Language (QDSL) to express queries in Scala and execute them in a target language. The library's core is designed to support multiple target languages, currently featuring specializations for Structured Query Language (SQL) and Cassandra Query Language (CQL).\n\n1. Boilerplate-free mapping: The database schema is mapped using simple case classes.\n2. Quoted DSL: Queries are defined inside a quote block. Quill parses each quoted block of code (quotation) at compile time and translates them to an internal Abstract Syntax Tree (AST)\n3. Compile-time query generation: The ctx.run call reads the quotation's AST and translates it to the target language at compile time, emitting the query string as a compilation message. As the query string is known at compile time, the runtime overhead is very low and similar to using the database driver directly.\n4. Compile-time query validation: If configured, the query is verified against the database at compile time, and the compilation fails if it is not valid. The query validation does not alter the database state.\n```\n\n----------------------------------------\n\nTITLE: Visualizing Feature Implementation Workflow with Manual OpenAPI\nDESCRIPTION: A flow diagram illustrating the feature implementation workflow when using manual OpenAPI specification files and code generation templates.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2022-10-05-using-tapir-library-as-a-dsl-for-openapi-specification.md#2025-04-21_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    U[Start Feature] --> |Edit OAS| A\n    A[OAS File] --> |Input| E\n    U --> |Edit Template| E\n    E[Generator & Templates]-->|Generate Server Code| B(Server Code)\n    E -->|Generate Client Code| C(Client Code)\n    C -->|Compile| OC(Other Compiler)\n    OC -->|Compilation Error| I\n    OC -->|Success| T\n    E -->|Host file as Swagger UI| D(Swagger)\n    B --> |Compile| S(Scala Compiler)\n    S --> |Compilation Error| I(Investigate)\n    I --> |Try again| U\n    S --> |Success| T(Complete Feature)\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Compose Services with Updated Logging Configuration\nDESCRIPTION: This shell command starts the Docker Compose services in detached mode after updating the logging configuration.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/troubleshooting&considerations.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndocker-compose up -d\n```\n\n----------------------------------------\n\nTITLE: Defining ADR File Structure in Markdown\nDESCRIPTION: This snippet shows the structure of an Architectural Decision Record (ADR) using the MADR 2.1.2 format with Log4brains patch. It includes fields for status, date, tags, context, decision drivers, considered options, and decision outcome.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/adrs/decisions/2022-09-19-use-markdown-architectural-decision-records.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Use Markdown Architectural Decision Records\n\n- Status: accepted\n- Date: 2022-09-19\n- Tags: doc\n\n## Context and Problem Statement\n\nWe want to record architectural decisions made in this project.\nWhich format and structure should these records follow?\n\n## Decision Drivers \n\n- We want to improve the information and technical documentation of our software engineering projects\n- We want to create an immutable log of important architectural decisions we have made during the software development\n- We recognise the need for a complement to RFCs that typically documents the process before a decision has been reached (and not after)\n- We want this decision log to offer a a standardised, lightweight, and extensible manner to increase consistency across systems\n- We want this decision log to live as close as possible to the relevant code-base\n- We want this decision log to be easily readable, discoverable and meaningfully searchable\n\n## Considered Options\n\n- [MADR](https://github.com/adr/madr/compare/3.0.0-beta...3.0.0-beta.2) 3.0.0-beta.2 \n- [MADR](https://adr.github.io/madr/) 2.1.2 with Log4brains patch\n- [MADR](https://adr.github.io/madr/) 2.1.2 – The original Markdown Architectural Decision Records\n- [Michael Nygard's template](http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions) – The first incarnation of the term \"ADR\"\n\n## Decision Outcome\n\nChosen option: \"MADR 2.1.2 with Log4brains patch\", because\n\n- The MADR format is lean and fits our development style.\n- The MADR structure is comprehensible and facilitates usage & maintenance.\n- The Log4brains patch adds more features, like tags.\n- This format is compatible with Log4brains and allows us to run a portal with a timeline of ADRs\n\nThe \"Log4brains patch\" performs the following modifications to the original template:\n\n- Change the ADR filenames format (`NNN-adr-name` becomes `YYYYMMDD-adr-name`), to avoid conflicts during Git merges.\n- Add a `Tags` field.\n\n### Additional Information\n\nWe will implement Architectural Decision Records (ADRs) with immediate effect;\n\n- ADRs are to be authored and published with (at minimum) 1 TA as decider;\n- ADRs will be formatted using MADR 2.12 with log4Brains Patches format;\n- ADRs are to be used to log system-wide decisions;\n- Should the system consist of multiple code-repositories, ADRs should live in the main system repository;\n- ADRs are to be stored in a subfolder docs/decisions/ of the repository for the software affected;\n- ADRs will follow a flat filename convention with relevant components in their filename\n\n## Links\n\n- Relates to [RFC-0016](https://input-output.atlassian.net/wiki/spaces/ATB/pages/3580559403/RFC+0016+-+Use+Architectural+Design+Records)\n```\n\n----------------------------------------\n\nTITLE: Restarting Docker Daemon to Apply Global Logging Configuration\nDESCRIPTION: This shell command restarts the Docker daemon to apply the new global logging settings specified in the daemon.json file.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/troubleshooting&considerations.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nsudo systemctl restart docker\n```\n\n----------------------------------------\n\nTITLE: Configuring Verifier Agent Environment Variables\nDESCRIPTION: Content for the .env-verifier file to configure the Verifier Agent environment variables.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/quick-start.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nAPI_KEY_ENABLED=false\nAGENT_VERSION=1.36.1\nPRISM_NODE_VERSION=2.4.1\nPORT=9000\nNETWORK=identus\nVAULT_DEV_ROOT_TOKEN_ID=root\nPG_PORT=5433\n```\n\n----------------------------------------\n\nTITLE: Markdown Support Status Table\nDESCRIPTION: Table listing DIDComm and related specifications with their support status and purposes. Uses emoji indicators for different states of implementation.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/specifications.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| | Specification | Purpose |\n|----|----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|\n| ✅ | [DIDComm Messaging v2.x Editor's Draft](https://identity.foundation/didcomm-messaging/spec/) | The core DIDCommV2 specification |\n| ✅ | [Peer DID 1.0](https://identity.foundation/peer-did-method-spec/) | ❓Peer DID specification, did:peer:2 is currently used |\n| ✅ | [BasicMessage 2.0](https://didcomm.org/basicmessage/2.0) | The BasicMessage protocol describes a stateless, easy to support user message protocol |\n| ✅ | [Coordinate Mediation 2.0](https://didcomm.org/coordinate-mediation/2.0/) | The protocol to coordinate mediation configuration between a mediating agent and the recipient |\n| 🚧 | [Coordinate Mediation 3.0](https://didcomm.org/coordinate-mediation/3.0/) *(TODO)* | The protocol to coordinate mediation configuration between a mediating agent and the recipient |\n| ✅ | [Message Pickup 3.0](https://didcomm.org/messagepickup/3.0/) | The protocol to facilitate an agent picking up messages held at a mediator |\n| ✅ | [Trust Ping 2.0](https://didcomm.org/trust-ping/2.0/) | The trust-ping protocol defined in the DIDComm Messaging Spec. This enables the sender and recipient to engage in an exchange of trust pings |\n| ✅ | [Report Problem 2.0](https://didcomm.org/report-problem/2.0/) | The Report Problem protocol is defined in the DIDComm Messaging Spec. This protocol describes sending a problem report to another party |\n```\n\n----------------------------------------\n\nTITLE: Pulling the Prism Node Docker Image\nDESCRIPTION: Command to pull the Prism Node Docker image from GitHub Container Registry, version 2.3.0. This is the first step in setting up a Prism Node instance.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/prism-node/running-node.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker pull ghcr.io/input-output-hk/prism-node:2.3.0\n```\n\n----------------------------------------\n\nTITLE: Building Docusaurus Website with Yarn\nDESCRIPTION: Command for building the Docusaurus website using Yarn. This step needs to be performed before creating the Docker image.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/infra/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Build Docusaurus website\nyarn build website\n```\n\n----------------------------------------\n\nTITLE: Generating HTTP Basic Auth Password\nDESCRIPTION: Command to generate a new password hash for HTTP Basic Authentication. This is used for updating access credentials to the documentation site.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/infra/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nhtpasswd -n demo\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Setting Up Identus Docs Project on MacOS\nDESCRIPTION: This snippet shows how to install necessary tools (brew, git, node, yarn), clone the Identus docs repository, initialize and update submodules, and start the local development server.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Install brew, git, node and yarn\n# If you have these tools, skip these steps\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nbrew install git\nbrew install node\nbrew install yarn\n\n# Create new projects directory\ncd ~ && mkdir projects && cd projects\ngit clone https://github.com/hyperledger-identus/docs.git\n# Initialize submodules\ngit submodule init\n# Update submodules\ngit submodule update --remote --recursive\n\n# Use this step to checkout custom branch to review from PR\n# git checkout feature-branch\n\n# Deploy local version of the website\ncd docs\nyarn install\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Defining User Model Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the structure of a user model, including fields for ID, email, password, optional DID, name, and company.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/documentation/home/identus/identus-cloud-agent/authenticate.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface User {\n  id: string;\n  email: string;\n  password: string;\n  did?: string;\n  name: string;\n  company?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Broken Links on Live Identus Docs Website\nDESCRIPTION: This command uses linkinator to check for broken links on the live Identus documentation website, using a specific configuration file.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ npx linkinator https://hyperledger-identus.github.io/docs/ --config .linkinatorrc.json --format text\n```\n\n----------------------------------------\n\nTITLE: Building Static Resources for Identus Docs Website\nDESCRIPTION: This command builds static resources for the Identus documentation website, which can be hosted to serve the full site.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn build --out-dir infra/website\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server for Identus Docs\nDESCRIPTION: This command starts a local development server for the Identus documentation website, allowing live updates without server restarts.\nSOURCE: https://github.com/hyperledger-identus/docs/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn start\n```"
  }
]