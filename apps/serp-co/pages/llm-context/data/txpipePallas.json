[
  {
    "owner": "txpipe",
    "repo": "pallas",
    "content": "TITLE: Complete TxSubmission Client Implementation in Rust\nDESCRIPTION: This is a comprehensive example of a TxSubmission client, including initialization, request handling for TxIds (blocking and non-blocking) and Txs, mempool management, and graceful termination with `send_done`. It showcases a full loop managing transactions.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n    let mut client = txsubmission::Client::new(channel4);\n    client.send_init()?;\n    loop {\n        match client.next_request()? {\n            Request::TxIds(acknowledged, next) => {\n                mempool.discard(acknowledged)?;\n                if !mempool.wait_for_at_least(next)? {\n                    client.send_done()?;\n                    break;\n                }\n                client.reply_tx_ids(\n                    mempool.iter()\n                        .take(next)\n                        .map(|tx| TxIdAndSize(tx.id(), tx.len()))\n                        .collect()\n                )?;\n            },\n            Request::TxIdsNonBlocking(acknowledged, next) => {\n                mempool.discard(acknowledged)?;\n                client.reply_tx_ids(\n                    mempool.iter()\n                        .take(next)\n                        .map(|tx| TxIdAndSize(tx.id(), tx.len()))\n                )?;\n            }\n            Request::Txs(ids) => {\n                let txs = mempool.find(ids);\n                client.reply_txs(txs)?;\n            }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Complete N2N Client Handshake Example in Rust\nDESCRIPTION: This code snippet presents a complete example of performing a handshake with an N2N client. It initializes the client and then calls the `handshake` method with the version table. `channel0` is assumed to be an established communication channel.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n    let mut client = handshake::N2NClient::new(channel0);\n    client.handshake(handshake::n2n::VersionTable::v7_and_above(MAINNET_MAGIC))?;\n```\n\n----------------------------------------\n\nTITLE: Complete TxSubmission Server Implementation in Rust\nDESCRIPTION: This is a complete example of a TxSubmission server, which includes initialization, waiting for the initial message, requesting transaction IDs, processing replies (TxIds, Txs, Done), and handling transactions.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n    let mut server = txsubmission::Server::new(channel4);\n    server.wait_for_init()?;\n    server.acknowledge_and_request_ids(true, 0, 16)?;\n    loop {\n        match server.receive_next_reply()? {\n            Reply::TxIds(ids_and_sizes) => {\n                server.request_txs(ids_and_sizes.iter().map(|tx| tx.0.clone()).collect())?;\n            },\n            Reply::Txs(txs) => {\n                tx_channel.send(txs);\n                server.acknowledge_and_request_ids(true, txs.len() as usize, 16)?;\n            },\n            Reply::Done => {\n                break;\n            }\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Executing a Handshake Client in Rust\nDESCRIPTION: This code snippet demonstrates how to execute a Handshake client against a remote relay node using the implemented library. It sets up a TCP connection, creates a multiplexer, obtains a channel for the handshake mini-protocol, initializes a client agent, and then runs the agent. Finally, it prints the final state of the agent.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// setup a TCP bearer against a relay node\nlet bearer = TcpStream::connect(\"relays-new.cardano-mainnet.iohk.io:3001\").unwrap();\nbearer.set_nodelay(true).unwrap();\nbearer.set_keepalive_ms(Some(30_000u32)).unwrap();\n\n// create a new multiplexer, specifying which mini-protocol IDs we want to sue\nlet mut muxer = Multiplexer::setup(bearer, &[0]).unwrap();\n\n// get a handle for the (client-side) handhsake mini-protocol handle\nlet mut channel = muxer.use_client_channel(pallas_miniprotocols::PROTOCOL_N2N_HANDSHAKE);\n\n// create a handshake client agent with an initial state \nlet agent = handshake::Client::initial(VersionTable::v4_and_above(MAINNET_MAGIC));\n\n// run the agent, which internally executes all the transitions\n// until it is done.\nlet agent = run_agent(agent, &mut channel).unwrap();\n\n// print the final state of the agent\nprintln!(\"{agent:?}\");\n```\n\n----------------------------------------\n\nTITLE: Required Signer Verification\nDESCRIPTION: This section describes how to verify that all required signers by the Plutus scripts are present in the transaction witness set. It includes `verify` function and `keyHash` functions for the verification.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_22\n\nLANGUAGE: Formal Specification\nCODE:\n```\nverify(vk, σ, ⟦txBody⟧<sub>TxBody</sub>)\n```\n\nLANGUAGE: Formal Specification\nCODE:\n```\nkeyHash(vk) = key_hash\n```\n\n----------------------------------------\n\nTITLE: Handling Server Requests in TxSubmission Client in Rust\nDESCRIPTION: This code outlines the structure for handling different types of requests from the server, including requests for transaction IDs (blocking and non-blocking) and transaction bodies.  It's a loop that continuously listens for and processes requests.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n    loop {\n        match client.next_request()? {\n            Request::TxIds(acknowledged, next) => {},\n            Request::TxIdsNonBlocking(acknowledged, next) => {}\n            Request::Txs(ids) => {}\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Receiving Replies from Client in Rust\nDESCRIPTION: This code illustrates how the server receives and processes different types of replies from the client, including transaction IDs, transaction bodies, and the `Done` message. Requires handling of `Reply::TxIds`, `Reply::Txs`, and `Reply::Done` variants.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n    match server.receive_next_reply()? {\n        Reply::TxIds(ids_and_sizes) => { }\n        Reply::Txs(txs) => { }\n        Reply::Done => { }\n    }\n```\n\n----------------------------------------\n\nTITLE: Replying to TxIdsNonBlocking Request in Rust\nDESCRIPTION: This snippet demonstrates how to respond to a `Request::TxIdsNonBlocking` request by providing a list of transaction IDs and sizes. It includes logic for discarding acknowledged transactions from the mempool. Requires a `mempool` implementation to function.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n    Request::TxIdsNonBlocking(acknowledged, next) => {\n        // discards the first N transactions, advancing the queue for this client\n        mempool.discard(acknowledged);\n        client.reply_tx_ids(\n            mempool.iter()\n                .take(next)\n                .map(|tx| TxIdAndSize(tx.id(), tx.len()))\n                .collect()\n        )?;\n    }\n```\n\n----------------------------------------\n\nTITLE: Complete N2N Server Handshake Example in Rust\nDESCRIPTION: This code snippet provides a complete example of handling a handshake on the server side. It initializes an N2NServer, receives the proposed versions, and then either accepts version 7 if present or refuses the connection due to a version mismatch.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n    let mut server = handshake::N2NServer::new(channel0);\n    let versions = server.receive_proposed_versions()?;\n    if let Some(params) = versions.values.get(7) {\n        server.send_accept_version(7, params)?;\n    } else {\n        server.send_refuse(RefuseReason::VersionMismatch(vec![7]))?;\n    }\n```\n\n----------------------------------------\n\nTITLE: Initializing TxSubmission Protocol in Rust\nDESCRIPTION: This code snippet shows how to initiate the TxSubmission protocol from the client side by sending an initialization message.  It transitions the protocol from the initial state to the idle state.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n    client.send_init()?;\n```\n\n----------------------------------------\n\nTITLE: Redeemer Matching Check\nDESCRIPTION: This snippet validates that the set of redeemers in the transaction witness set matches the set of Plutus scripts needed to validate the transaction. It relies on functions like `txRedeemers`, `txWits`, `redeemerPointer`, `txBody`, `scriptsNeeded`, `utxo`, `isPlutusScript`, `scriptHash`, and `txScripts`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_20\n\nLANGUAGE: Formal Specification\nCODE:\n```\n{(tag, index): (tag, index, \\_, \\_) ∈ txRedeemers(txWits)} = {redeemerPointer(txBody, sp): (sp, h) ∈ scriptsNeeded(utxo, txBody), (∃s ∈ txScripts(txWits): isPlutusScript(s), h = scriptHash(s)}\n```\n\n----------------------------------------\n\nTITLE: Validity Interval Check\nDESCRIPTION: This snippet validates that the block slot falls within the transaction's validity interval. This check ensures the transaction is included in a block within its specified time range. It depends on functions like `slot` and `txValidityInterval`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_3\n\nLANGUAGE: Formal Specification\nCODE:\n```\nslot ∈ txValidityInterval(txBody)\n```\n\n----------------------------------------\n\nTITLE: Performing Handshake with N2N Client in Rust\nDESCRIPTION: This code snippet demonstrates a helper method for performing the entire handshake process with an N2N client. It calls the `handshake` method, proposing a set of versions and handling the server's response. An error is returned upon failure.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n    n2n_client.handshake(handshake::n2n::VersionTable::v7_and_above(MAINNET_MAGIC))?;\n```\n\n----------------------------------------\n\nTITLE: Replying to Txs Request in Rust\nDESCRIPTION: This code demonstrates responding to a `Request::Txs` request by providing the transaction bodies corresponding to the requested IDs. Requires a `mempool` implementation with a `find` method to retrieve transaction data.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n    Request::Txs(ids) => {\n        let txs: Vec<TxBody> = mempool.find(ids);\n        client.reply_txs(txs)?;\n    }\n```\n\n----------------------------------------\n\nTITLE: Validate value preservation (Shelley/Allegra)\nDESCRIPTION: This rule ensures that the total value consumed by the transaction equals the total value produced plus the transaction fee in Shelley and Allegra eras.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_5\n\nLANGUAGE: mathematical notation\nCODE:\n```\nconsumed(pps, utxo, txBody) = produced(pps, txBody) + fee(txBody)\n```\n\n----------------------------------------\n\nTITLE: Initializing N2N and N2C Clients in Rust\nDESCRIPTION: This code snippet demonstrates how to instantiate N2NClient and N2CClient for the Handshake miniprotocol using a communication channel. `channel0` represents the established communication channel between the client and server.  These clients will then be used to initiate the handshake process.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n    let mut n2n_client = handshake::N2NClient::new(channel0);\n    let mut n2c_client = handshake::N2CClient::new(channel0);\n```\n\n----------------------------------------\n\nTITLE: Initializing TxSubmission Client in Rust\nDESCRIPTION: This code snippet demonstrates how to instantiate a `txsubmission::Client` with a given channel.  The `channel4` parameter represents the communication channel.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n    let mut client = txsubmission::Client::new(channel4);\n```\n\n----------------------------------------\n\nTITLE: Needed Scripts and Witnessed Scripts Equality Check\nDESCRIPTION: This snippet verifies that the set of script hashes of needed scripts matches the set of script hashes present in the transaction witness set. This ensures that all required scripts are provided in the witness set. It relies on functions like `scriptsNeeded`, `utxo`, `txBody`, `scriptHash`, and `txScripts`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_17\n\nLANGUAGE: Formal Specification\nCODE:\n```\n{h: (\\_, h) ∈ scriptsNeeded(utxo, txBody)} = {scriptHash(s) : s ∈ txScripts(txWits)}\n```\n\n----------------------------------------\n\nTITLE: Sending Accept or Refuse Message from N2N Server in Rust\nDESCRIPTION: This code snippet demonstrates how an N2N server sends either an accept or refuse message. It checks if version 7 is present in the received version table. If present, it sends an accept message with the corresponding parameters; otherwise, it sends a refuse message indicating a version mismatch, suggesting version 7.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n    // NOTE: in practice, your version selection is probably more complicated than this\n    if let Some(params) = versions.values.get(7) {\n        n2n_server.send_accept_version(7, params)?;\n    } else {\n        n2n_server.send_refuse(RefuseReason::VersionMismatch(vec![7]))?;\n    }\n```\n\n----------------------------------------\n\nTITLE: Datum Object Correspondence Check\nDESCRIPTION: This snippet validates that each datum object in the transaction witness set corresponds to either a Plutus script input datum hash or an output datum hash. It utilizes functions like `datumHash`, `txDats`, `txIns`, `utxo`, `isPlutusScriptAddress`, and `txOuts`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_19\n\nLANGUAGE: Formal Specification\nCODE:\n```\n{datumHash(d): d ∈ txDats(txWits)} ⊆ {h: (a,\\_,h) ∈ txIns(txBody) ◁ utxo, isPlutusScriptAddress(txWits, a)} ∪ {h: (\\_,\\_,h) ∈ txOuts(txBody)}\n```\n\n----------------------------------------\n\nTITLE: Block Phase-1 Validity Condition\nDESCRIPTION: This snippet defines the condition for a block to be considered phase-1 valid. It checks if the total execution units of all transactions in the block do not exceed the maximum allowed and if all transactions within the block are also phase-1 valid. It relies on helper functions such as `maxBlockExUnits`, `blockExUnits`, and `txs`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_0\n\nLANGUAGE: Formal Specification\nCODE:\n```\nmaxBlockExUnits(pps) ≥ blockExUnits(block) ∧ ∀ tx ∈ txs(block): txIsPhase1Valid(pps, tx)\n```\n\n----------------------------------------\n\nTITLE: Requesting Transaction Bodies from Client in Rust\nDESCRIPTION: This code demonstrates how the server requests the transaction bodies corresponding to the transaction IDs it has received.  It iterates through the IDs and requests the full transactions.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nserver.request_txs(ids.iter().map(|tx_and_size| tx_and_size.0.clone()).collect());\n```\n\n----------------------------------------\n\nTITLE: Validate Verification-Key Witnesses\nDESCRIPTION: This rule ensures that the transaction is signed by the owner of each transaction input. It verifies the signature against the verification key and confirms that the hash of the verification key matches the payment credential of the corresponding input.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_10\n\nLANGUAGE: mathematical notation\nCODE:\n```\nverify(vk, σ, ⟦txBody⟧<sub>TxBody</sub>)\n```\n\nLANGUAGE: mathematical notation\nCODE:\n```\npaymentCredential<sub>utxo</sub>(txIn) = hash(vk)\n```\n\n----------------------------------------\n\nTITLE: Initializing TxSubmission Server in Rust\nDESCRIPTION: This code snippet demonstrates how to create an instance of `txsubmission::Server` with a communication channel.  The server is responsible for requesting transactions from connected clients.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n    let mut server = txsubmission::Server::new(channel4);\n```\n\n----------------------------------------\n\nTITLE: Minimum Fee Check\nDESCRIPTION: This snippet checks whether the fee paid by the transaction is greater than or equal to the minimum fee required. It ensures that the transaction pays sufficient fees to be processed. It relies on functions like `fee`, `minFees`, and protocol parameters `pps`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_4\n\nLANGUAGE: Formal Specification\nCODE:\n```\nfee(txBody) ≥ minFees(pps, txBody)\n```\n\n----------------------------------------\n\nTITLE: Datum Hash Inclusion Check\nDESCRIPTION: This snippet verifies that each datum hash in a Plutus script input is present in the set of datum hashes in the transaction witness set. This ensures that the correct datum is provided for each Plutus script input. It leverages functions like `txIns`, `utxo`, `isPlutusScriptAddress`, `txWits`, `datumHash`, and `txDats`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_18\n\nLANGUAGE: Formal Specification\nCODE:\n```\n{h : (a,\\_,h) ∈ txIns(txBody) ◁ utxo, isPlutusScriptAddress(txWits, a)} ⊆ {datumHash(d) : d ∈ txDats(txWits)}\n```\n\n----------------------------------------\n\nTITLE: Running an Agent in Rust\nDESCRIPTION: This code snippet shows the entry point to trigger the execution of an agent, the `run_agent` function. It takes the agent and a `Channel` as parameters. The `Channel` is an Ouroboros multiplexer channel that is already connected to the remote party. The agent is executed until it reaches a terminal state.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nrun_agent<T>(agent: T, channel: &mut Channel)\n```\n\n----------------------------------------\n\nTITLE: Transaction Input Non-Emptiness Check\nDESCRIPTION: This snippet ensures that the set of transaction inputs within a transaction body is not empty. An empty set of inputs indicates an invalid transaction. It uses the function `txIns` to extract transaction inputs from the transaction body `txBody`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_1\n\nLANGUAGE: Formal Specification\nCODE:\n```\ntxIns(txBody) ≠ ∅\n```\n\n----------------------------------------\n\nTITLE: Verification-Key Witness Verification\nDESCRIPTION: This section describes the process to verify a verification-key witness. It requires a signature from the owner of each transaction input and each collateral input. It uses the `verify` function to perform the signature verification and the `paymentCredential_utxo` function to check key hash.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_21\n\nLANGUAGE: Formal Specification\nCODE:\n```\nverify(vk, σ, ⟦txBody⟧<sub>TxBody</sub>)\n```\n\nLANGUAGE: Formal Specification\nCODE:\n```\npaymentCredential<sub>utxo</sub>(txIn) = keyHash(vk)\n```\n\n----------------------------------------\n\nTITLE: Validate minimum UTxO value\nDESCRIPTION: This rule validates that each transaction output contains at least the minimum Lovelace value specified in the protocol parameters.  It iterates through the transaction outputs and compares the Lovelace value to the minimum required value.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_4\n\nLANGUAGE: mathematical notation\nCODE:\n```\n∀ (_, c) ∈ txOuts(txBody): minUTxOValue(pps) ≤ c\n```\n\n----------------------------------------\n\nTITLE: Sending a Propose Message from N2N Client in Rust\nDESCRIPTION: This code snippet shows how to send a propose message from an N2N client, suggesting a set of protocol versions. It uses the `send_propose` method with a `VersionTable` containing the supported versions (v7 and above) and a `MAINNET_MAGIC` value. An error is returned if sending fails.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n    // Note: Other helper methods exist as well\n    n2n_client.send_propose(handshake::n2n::VersionTable::v7_and_above(MAINNET_MAGIC))?;\n```\n\n----------------------------------------\n\nTITLE: Network ID Match for Outputs\nDESCRIPTION: This snippet validates that the network ID of each transaction output matches the global network ID. This ensures that the outputs are destined for the correct network. It uses the functions `txOuts`, `netId`, and `NetworkId`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_13\n\nLANGUAGE: Formal Specification\nCODE:\n```\n∀(a,\\_) ∈ txOuts(txBody): netId(a) = NetworkId\n```\n\n----------------------------------------\n\nTITLE: Receiving Proposed Versions from N2N Client in Rust\nDESCRIPTION: This code snippet shows how to receive proposed versions from an N2N client. The `receive_proposed_versions` method returns a `VersionTable` containing the versions proposed by the client.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n    let versions = n2n_server.receive_proposed_versions()?;\n```\n\n----------------------------------------\n\nTITLE: UTxO Membership Check\nDESCRIPTION: This snippet checks if all transaction inputs (regular inputs, collateral inputs, and reference inputs) are present in the Unspent Transaction Output (UTxO) set. This check verifies that the transaction is attempting to spend valid and existing UTxOs. It relies on functions like `txIns`, `collateral`, and `dom`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_2\n\nLANGUAGE: Formal Specification\nCODE:\n```\ntxIns(txBody) ∪ collateral(txBody) ⊆ dom(utxo)\n```\n\n----------------------------------------\n\nTITLE: Validate transaction size limit\nDESCRIPTION: This rule enforces the maximum transaction size limit defined in the protocol parameters. It checks if the transaction size is less than or equal to the maximum allowed size.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_3\n\nLANGUAGE: mathematical notation\nCODE:\n```\ntxSize(tx) ≤ maxTxSize(pps)\n```\n\n----------------------------------------\n\nTITLE: Validate value preservation (Mary)\nDESCRIPTION: This rule ensures that the total value consumed by the transaction equals the total value produced plus the transaction fee plus the minted value in the Mary era.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_6\n\nLANGUAGE: mathematical notation\nCODE:\n```\nconsumed(pps, utxo, txBody) = produced(pps, txBody) + fee(txBody) + minted(txBody) \n```\n\n----------------------------------------\n\nTITLE: Validate Script Witnesses\nDESCRIPTION: This rule ensures that each script address has a corresponding witness. It checks if for every script hash from the transaction, there exists a script in the script witnesses of the transaction such that hashing the script gives the script hash.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_11\n\nLANGUAGE: mathematical notation\nCODE:\n```\n∀ (script_hash, _) ∈ txScripts(txBody) ◁ utxo : ∃ script ∈ txScriptWits(tx): hash(script) = script_hash\n```\n\n----------------------------------------\n\nTITLE: Phase-1 Block Validation Rule\nDESCRIPTION: This snippet expresses the condition for a Babbage block to be considered phase-1 valid. It checks that the total execution units of all transactions in the block do not exceed the maximum allowed by the protocol and that each transaction within the block is also phase-1 valid. The `maxBlockExUnits(pps)` function determines the maximum execution units allowed for a block, `blockExUnits(block)` calculates the total execution units consumed by the block, `txs(block)` retrieves all transactions from the block, and `txIsPhase1Valid(pps, tx)` checks if a given transaction is phase-1 valid.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/babbage.md#_snippet_0\n\nLANGUAGE: Formal Specification\nCODE:\n```\nmaxBlockExUnits(pps) ≥ blockExUnits(block) ∧ ∀ tx ∈ txs(block): txIsPhase1Valid(pps, tx)\n```\n\n----------------------------------------\n\nTITLE: Collateral Lovelace Balance Check\nDESCRIPTION: This snippet ensures the total lovelace contained in collateral inputs is greater than or equal to the minimum fee percentage of the transaction fee. It relies on `balance`, `collateral`, `utxo`, `fee` and `collateralPercent` functions.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_9\n\nLANGUAGE: Formal Specification\nCODE:\n```\nbalance(collateral(txBody) ◁ utxo)) >= fee(txBody) * collateralPercent(pps)\n```\n\n----------------------------------------\n\nTITLE: Requesting Transaction IDs from Client in Rust\nDESCRIPTION: This code snippet demonstrates how the server requests transaction IDs from the client. It acknowledges previous transactions, sets an offset, and specifies the number of IDs to request.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n    server.acknowledge_and_request_ids(true, 0, 16)?;\n```\n\n----------------------------------------\n\nTITLE: Minimum Lovelace in Outputs Check\nDESCRIPTION: This snippet ensures that all transaction outputs (regular and collateral return outputs) contain at least the minimum lovelace amount, which is determined by the size of the output. It uses the functions `txOuts`, `adaValueOf`, `coinsPerUTxOWord`, `outputEntrySize`, and `getValue`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_11\n\nLANGUAGE: Formal Specification\nCODE:\n```\n∀ txOut ∈ txOuts(txBody): adaValueOf(coinsPerUTxOWord(pps) * outputEntrySize(txOut)) ≤ getValue(txOut)\n```\n\n----------------------------------------\n\nTITLE: Transaction Execution Units Limit Check\nDESCRIPTION: This snippet ensures the transaction's execution units do not exceed the maximum allowed. It uses `txExUnits` to get the transaction's execution units and compares it against `maxTxExUnits` from the protocol parameters.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_15\n\nLANGUAGE: Formal Specification\nCODE:\n```\ntxExUnits(txBody) ≤ maxTxExUnits(pps)\n```\n\n----------------------------------------\n\nTITLE: Initializing N2N and N2C Servers in Rust\nDESCRIPTION: This code snippet demonstrates initializing N2NServer and N2CServer for the Handshake miniprotocol using a channel. These servers are then ready to receive handshake proposals from clients.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n    let mut n2n_server = handshake::N2NServer::new(channel0);\n    let mut n2c_server = handshake::N2CServer::new(channel0);\n```\n\n----------------------------------------\n\nTITLE: Validate minimum fee\nDESCRIPTION: This rule enforces the minimum transaction fee required by the protocol parameters. It checks if the fee paid by the transaction is greater than or equal to the minimum fee.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_7\n\nLANGUAGE: mathematical notation\nCODE:\n```\nfee(txBody) ≥ minFees(pps, tx)\n```\n\n----------------------------------------\n\nTITLE: ADA-Only Collateral Check\nDESCRIPTION: This snippet verifies that collateral inputs contain only ADA (lovelace). It is a check to ensure that collateral cannot be used to spend other assets. It uses the functions `collateral`, `utxo`, and `balance`, along with the predicate `isADAOnly`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_8\n\nLANGUAGE: Formal Specification\nCODE:\n```\nisADAOnly(balance(collateral(txBody) ◁ utxo))\n```\n\n----------------------------------------\n\nTITLE: Transaction Size Limit Check\nDESCRIPTION: This snippet checks if the transaction size exceeds the protocol's maximum allowed size. It utilizes the `txSize` function to determine the transaction size and compares it against the `maxTxSize` parameter.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_14\n\nLANGUAGE: Formal Specification\nCODE:\n```\ntxSize(txBody) ≤ maxTxSize(pps)\n```\n\n----------------------------------------\n\nTITLE: Validate Time-To-Live (TTL)\nDESCRIPTION: This rule ensures that the transaction's time-to-live (TTL) has not been exceeded. It compares the current slot number against the transaction's TTL.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_2\n\nLANGUAGE: mathematical notation\nCODE:\n```\nslot ≥ txTTL(txBody)\n```\n\n----------------------------------------\n\nTITLE: Maximum Value Size Check\nDESCRIPTION: This snippet verifies that the size of the value in each transaction output does not exceed the maximum allowed size. It employs the functions `txOuts`, `getValue`, and `valSize`, along with the protocol parameter `maxValSize`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_12\n\nLANGUAGE: Formal Specification\nCODE:\n```\nvalSize(getValue(txOut)) ≤ maxValSize(pps)\n```\n\n----------------------------------------\n\nTITLE: Maximum Collateral Inputs Check\nDESCRIPTION: This snippet ensures that the number of collateral inputs does not exceed the maximum allowed as defined in the protocol parameters. It leverages the `collateral` function and the `maxCollateralInputs` parameter to perform the validation.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_6\n\nLANGUAGE: Formal Specification\nCODE:\n```\n∥collateral(txBody)∥ ≤ maxCollateralInputs(pps)\n```\n\n----------------------------------------\n\nTITLE: Check if transaction inputs are empty\nDESCRIPTION: This rule verifies that the transaction has at least one input. It checks if the set of transaction inputs from the transaction body is not empty.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_0\n\nLANGUAGE: mathematical notation\nCODE:\n```\ntxIns(txBody) ≠ ∅\n```\n\n----------------------------------------\n\nTITLE: Auxiliary Data Hash Verification\nDESCRIPTION: This snippet checks if the auxiliary data hash of the transaction is equal to the hash of the auxiliary data itself. It utilizes functions such as `txAuxDatHash`, `tx`, `hashMD` and `txAuxDat`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_24\n\nLANGUAGE: Formal Specification\nCODE:\n```\ntxAuxDatHash(tx) = hashMD(txAuxDat(tx))\n```\n\n----------------------------------------\n\nTITLE: Waiting for Initialization Message in Rust\nDESCRIPTION: This code shows how the server waits for the initial message from the client.  This is the first step in establishing the TxSubmission protocol.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n    server.wait_for_init()?;\n```\n\n----------------------------------------\n\nTITLE: No ADA Minting Check\nDESCRIPTION: This snippet verifies that no ADA is being minted in the transaction. This is a constraint of the Cardano protocol. It uses the functions `minted`, `policies` and the constant `adaID`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_16\n\nLANGUAGE: Formal Specification\nCODE:\n```\nadaID ∉ policies(minted(txBody))\n```\n\n----------------------------------------\n\nTITLE: Validate transaction inputs against UTxO set\nDESCRIPTION: This rule ensures that all transaction inputs are present in the current set of unspent transaction outputs (UTxO).  It checks if the set of transaction inputs is a subset of the domain of the UTxO set.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_1\n\nLANGUAGE: mathematical notation\nCODE:\n```\ntxIns(txBody) ⊆ dom(utxo)\n```\n\n----------------------------------------\n\nTITLE: Sending a Done Message in TxSubmission Client in Rust\nDESCRIPTION: This snippet shows how to gracefully terminate the TxSubmission protocol by sending a `Done` message from the client. This is typically done when the client cannot fulfill a blocking request.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n    client.send_done()?;\n```\n\n----------------------------------------\n\nTITLE: Receiving Confirmation from N2N Server in Rust\nDESCRIPTION: This code snippet illustrates how an N2N client receives a confirmation from the server after proposing versions. It uses `recv_while_confirm` to wait for the server's response, handling both acceptance (with version and parameters) and rejection (with a reason).\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/handshake/README.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n    match n2n_client.recv_while_confirm()? {\n        Confirmation::Accepted(version, parameters) => {},\n        Request::Rejected(reason) => {}\n    }\n```\n\n----------------------------------------\n\nTITLE: Validate network ID of transaction outputs\nDESCRIPTION: This rule ensures that the network ID of each transaction output matches the global network ID. It iterates through the transaction outputs and compares the network ID of the address with the global network ID.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_8\n\nLANGUAGE: mathematical notation\nCODE:\n```\n∀(_ -> (a, _)) ∈ txOuts(txBody): netId(a) = NetworkId\n```\n\n----------------------------------------\n\nTITLE: Collateral Non-Emptiness Check\nDESCRIPTION: This snippet validates that the set of collateral inputs is not empty when Plutus scripts are involved in the transaction. Collateral inputs are used to cover fees in case the script execution fails. It utilizes the `collateral` function to obtain collateral inputs from the transaction body.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_5\n\nLANGUAGE: Formal Specification\nCODE:\n```\ncollateral(txBody) ≠ ∅\n```\n\n----------------------------------------\n\nTITLE: Validate transaction metadata hash\nDESCRIPTION: This rule validates the integrity of the transaction metadata by comparing the metadata hash contained within the transaction body with the hash of the actual metadata.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/shelleyMA.md#_snippet_9\n\nLANGUAGE: mathematical notation\nCODE:\n```\ntxMDHash(tx) = hashMD(txMD(tx))\n```\n\n----------------------------------------\n\nTITLE: Acknowledging Received Transactions and Requesting More in Rust\nDESCRIPTION: This snippet shows how the server acknowledges the previously received transactions before requesting additional transaction IDs from the client. It increments the offset and specifies the number of new IDs to retrieve.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/txsubmission/README.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n    server.acknowledge_and_request_ids(true, 16, 16)?\n```\n\n----------------------------------------\n\nTITLE: Language Inclusion Check\nDESCRIPTION: This snippet validates that the required script languages are included in the protocol parameters. It depends on functions like `languages`, `txWits`, and `costModels`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_23\n\nLANGUAGE: Formal Specification\nCODE:\n```\nlanguages(txWits) ⊆ {l : (l -> _) ∈ costModels(pps, language)}\n```\n\n----------------------------------------\n\nTITLE: Script Data Integrity Hash Verification\nDESCRIPTION: This snippet validates that the script data integrity hash matches the hash of the redeemers, languages, and datums of the transaction witness set. The functions used are `scriptDataHash`, `txBody`, `hashScriptIntegrity`, `pps`, `txRedeemers`, `txWits`, `languages` and `txDats`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_25\n\nLANGUAGE: Formal Specification\nCODE:\n```\nscriptDataHash(txBody) = hashScriptIntegrity(pps, txRedeemers(txWits), languages(txWits), txDats(txWits))\n```\n\n----------------------------------------\n\nTITLE: Value Preservation Property Check\nDESCRIPTION: This snippet checks that the consumed value equals the produced value plus the fee and minted value. This represents the preservation of value property in a transaction. It relies on functions like `consumed`, `produced`, `fee`, and `minted`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_10\n\nLANGUAGE: Formal Specification\nCODE:\n```\nconsumed(utxo, txBody) = produced(txBody) + fee(txBody) + minted(txBody)\n```\n\n----------------------------------------\n\nTITLE: Verification-Key Address Check for Collateral Inputs\nDESCRIPTION: This snippet validates that each collateral input refers to a verification-key address. This check ensures that the collateral is owned by a valid address. It relies on the functions `collateral`, `utxo`, and `isVKeyAddress`.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-validate/docs/alonzo.md#_snippet_7\n\nLANGUAGE: Formal Specification\nCODE:\n```\n∀(a,\\_,\\_) ∈ collateral(txBody) ◁ utxo: isVKeyAddress(a)\n```\n\n----------------------------------------\n\nTITLE: Defining the Agent Trait for Mini-Protocol Participants in Rust\nDESCRIPTION: This code defines the `Agent` trait, which allows a struct to participate as an agent in an Ouroboros communication. The trait includes associated type `Message` and functions for checking the agent's state, agency, and sending or receiving the next message. `send_next` and `receive_next` methods will transition the state-machine from one state to the following without mutating any value.\nSOURCE: https://github.com/txpipe/pallas/blob/main/pallas-network/src/miniprotocols/README.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Agent: Sized {\n    type Message;\n\n    fn is_done(&self) -> bool;\n    fn has_agency(&self) -> bool;\n    fn send_next(self, tx: &impl MachineOutput) -> Transition<Self>;\n    fn receive_next(self, msg: Self::Message) -> Transition<Self>;\n}\n```"
  }
]