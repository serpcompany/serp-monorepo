[
  {
    "owner": "neo4j",
    "repo": "neo4j-graphrag-python",
    "content": "TITLE: Installing Neo4j GraphRAG with OpenAI Dependency (Shell)\nDESCRIPTION: Command to install the Neo4j GraphRAG package including optional dependencies for the OpenAI LLM provider. This is necessary to utilize functionalities that integrate with OpenAI models, such as specific KG builders or RAG components.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install \"neo4j-graphrag[openai]\"\n```\n\n----------------------------------------\n\nTITLE: Initializing GraphRAG with Neo4j, VectorRetriever, and OpenAI LLM in Python\nDESCRIPTION: This code snippet demonstrates how to initialize and use the GraphRAG pipeline with a Neo4j driver, VectorRetriever, and OpenAI LLM. It includes setting up the Neo4j connection, creating an OpenAI embedder and retriever, initializing the OpenAI LLM, and querying the graph using the RAG pipeline.  It requires the `neo4j`, `neo4j_graphrag`, and `openai` Python packages and an OpenAI API key.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.retrievers import VectorRetriever\nfrom neo4j_graphrag.llm import OpenAILLM\nfrom neo4j_graphrag.generation import GraphRAG\nfrom neo4j_graphrag.embeddings import OpenAIEmbeddings\n\n# 1. Neo4j driver\nURI = \"neo4j://localhost:7687\"\nAUTH = (\"neo4j\", \"password\")\n\nINDEX_NAME = \"index-name\"\n\n# Connect to Neo4j database\ndriver = GraphDatabase.driver(URI, auth=AUTH)\n\n# 2. Retriever\n# Create Embedder object, needed to convert the user question (text) to a vector\nembedder = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n\n# Initialize the retriever\nretriever = VectorRetriever(driver, INDEX_NAME, embedder)\n\n# 3. LLM\n# Note: the OPENAI_API_KEY must be in the env vars\nllm = OpenAILLM(model_name=\"gpt-4o\", model_params={\"temperature\": 0})\n\n# Initialize the RAG pipeline\nrag = GraphRAG(retriever=retriever, llm=llm)\n\n# Query the graph\nquery_text = \"How do I do similarity search in Neo4j?\"\nresponse = rag.search(query_text=query_text, retriever_config={\"top_k\": 5})\nprint(response.answer)\n```\n\n----------------------------------------\n\nTITLE: Building Knowledge Graph with SimpleKGPipeline (Python)\nDESCRIPTION: Demonstrates how to use the `SimpleKGPipeline` class to construct a knowledge graph from a piece of text. It covers connecting to a Neo4j database, configuring OpenAI embeddings and LLM, defining the potential graph schema (entities and relations), and executing the pipeline. Requires an active Neo4j instance with the APOC plugin and the 'openai' extra dependency.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.embeddings import OpenAIEmbeddings\nfrom neo4j_graphrag.experimental.pipeline.kg_builder import SimpleKGPipeline\nfrom neo4j_graphrag.llm import OpenAILLM\n\nNEO4J_URI = \"neo4j://localhost:7687\"\nNEO4J_USERNAME = \"neo4j\"\nNEO4J_PASSWORD = \"password\"\n\n# Connect to the Neo4j database\ndriver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USERNAME, NEO4J_PASSWORD))\n\n# List the entities and relations the LLM should look for in the text\nentities = [\"Person\", \"House\", \"Planet\"]\nrelations = [\"PARENT_OF\", \"HEIR_OF\", \"RULES\"]\npotential_schema = [\n    (\"Person\", \"PARENT_OF\", \"Person\"),\n    (\"Person\", \"HEIR_OF\", \"House\"),\n    (\"House\", \"RULES\", \"Planet\"),\n]\n\n# Create an Embedder object\nembedder = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n\n# Instantiate the LLM\nllm = OpenAILLM(\n    model_name=\"gpt-4o\",\n    model_params={\n        \"max_tokens\": 2000,\n        \"response_format\": {\"type\": \"json_object\"},\n        \"temperature\": 0,\n    },\n)\n\n# Instantiate the SimpleKGPipeline\nkg_builder = SimpleKGPipeline(\n    llm=llm,\n    driver=driver,\n    embedder=embedder,\n    entities=entities,\n    relations=relations,\n    on_error=\"IGNORE\",\n    from_pdf=False,\n)\n\n# Run the pipeline on a piece of text\ntext = (\n    \"The son of Duke Leto Atreides and the Lady Jessica, Paul is the heir of House \"\n    \"Atreides, an aristocratic family that rules the planet Caladan.\"\n)\nasyncio.run(kg_builder.run_async(text=text))\ndriver.close()\n\n```\n\n----------------------------------------\n\nTITLE: Closing Neo4j Driver Connection in Python\nDESCRIPTION: This snippet ensures proper resource management by closing the Neo4j driver connection after completing database operations. It helps prevent connection leaks and is essential for clean application shutdown procedures. The snippet relies on the driver object created earlier and does not produce output.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/tests/e2e/data/documents/harry_potter_part1.txt#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndriver.close()\n```\n\n----------------------------------------\n\nTITLE: Extracting Entities and Relations with LLM in Python\nDESCRIPTION: Shows the basic usage of the LLMEntityRelationExtractor component. This component uses an LLM (like OpenAILLM) to extract entities and relationships from text chunks, guided by an optional schema. Requires an LLM instance and input text chunks.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.entity_relation_extractor import (\n    LLMEntityRelationExtractor,\n)\nfrom neo4j_graphrag.llm import OpenAILLM\n\nextractor = LLMEntityRelationExtractor(\n    llm=OpenAILLM(\n        model_name=\"gpt-4o\",\n        model_params={\n            \"max_tokens\": 1000,\n            \"response_format\": {\"type\": \"json_object\"},\n        },\n    )\n)\nawait extractor.run(chunks=TextChunks(chunks=[TextChunk(text=\"some text\")]))\n```\n\n----------------------------------------\n\nTITLE: Using Environment Variables for Parameters in YAML Configuration\nDESCRIPTION: Shows the YAML syntax for securely loading parameters from environment variables. Similar to JSON, it uses the `resolver_: ENV` and `var_:` keys to specify the resolution method and the target environment variable.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_14\n\nLANGUAGE: YAML\nCODE:\n```\nneo4j_config:\n  params_:\n    uri: bolt://\n    user: neo4j\n    password:\n      resolver_: ENV\n      var_: NEO4J_PASSWORD\n```\n\n----------------------------------------\n\nTITLE: Configuring Pipeline Parameters with JSON\nDESCRIPTION: This JSON snippet illustrates how to configure various parameters of the `SimpleKGPipeline`. It demonstrates setting flags for PDF processing and entity resolution, specifying the Neo4j database, defining error handling behavior, setting the prompt template, and defining entities, relations, and potential schema for the knowledge graph.  The `entities` and `relations` arrays specify the schema for the knowledge graph.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"from_pdf\": false,\n    \"perform_entity_resolution\": true,\n    \"neo4j_database\": \"myDb\",\n    \"on_error\": \"IGNORE\",\n    \"prompt_template\": \"...\",\n    \"entities\": [\n        \"Person\",\n        {\n            \"label\": \"House\",\n            \"description\": \"Family the person belongs to\",\n            \"properties\": [\n                {\"name\": \"name\", \"type\": \"STRING\"}\n            ]\n        },\n        {\n            \"label\": \"Planet\",\n            \"properties\": [\n                {\"name\": \"name\", \"type\": \"STRING\"},\n                {\"name\": \"weather\", \"type\": \"STRING\"}\n            ]\n        }\n    ],\n    \"relations\": [\n        \"PARENT_OF\",\n        {\n            \"label\": \"HEIR_OF\",\n            \"description\": \"Used for inheritor relationship between father and sons\"\n        },\n        {\n            \"label\": \"RULES\",\n            \"properties\": [\n                {\"name\": \"fromYear\", \"type\": \"INTEGER\"}\n            ]\n        }\n    ],\n    \"potential_schema\": [\n        [\"Person\", \"PARENT_OF\", \"Person\"],\n        [\"Person\", \"HEIR_OF\", \"House\"],\n        [\"House\", \"RULES\", \"Planet\"]\n    ],\n    \"lexical_graph_config\": {\n        \"chunk_node_label\": \"TextPart\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Searching by Text with Vector Retriever and Embedder in Python\nDESCRIPTION: Illustrates searching with text input. Since the vector index works on vectors, an `embedder` is required to convert the `query_text` into a vector before the similarity search is performed. The `embedder` instance is passed during retriever initialization.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nembedder = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n\n# Initialize the retriever\nretriever = VectorRetriever(\n    driver,\n    index_name=POSTER_INDEX_NAME,\n    embedder=embedder,\n)\n\nquery_text = \"How do I do similarity search in Neo4j?\"\nretriever_result = retriever.search(query_text=query_text, top_k=3)\n```\n\n----------------------------------------\n\nTITLE: Running Pipeline from Configuration File using PipelineRunner (Python)\nDESCRIPTION: Shows how to execute a pre-defined pipeline using a configuration file (JSON or YAML). It involves importing `PipelineRunner`, loading the configuration using `from_config_file`, and then running the pipeline asynchronously with input data.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j_graphrag.experimental.pipeline.config.runner import PipelineRunner\n\nfile_path = \"my_config.json\"\n\npipeline = PipelineRunner.from_config_file(file_path)\nawait pipeline.run({\"text\": \"my text\"})\n```\n\n----------------------------------------\n\nTITLE: Performing Vector Similarity Search with GraphRAG (Python)\nDESCRIPTION: Demonstrates how to perform a similarity search on a Neo4j vector index using the `VectorRetriever` and integrate it into a basic `GraphRAG` pipeline. It establishes a connection to Neo4j, initializes the necessary retriever and LLM components, and executes a search query against the vector index. Requires the 'openai' extra dependency, an active Neo4j instance, and a populated vector index.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.embeddings import OpenAIEmbeddings\nfrom neo4j_graphrag.generation import GraphRAG\nfrom neo4j_graphrag.llm import OpenAILLM\nfrom neo4j_graphrag.retrievers import VectorRetriever\n\nNEO4J_URI = \"neo4j://localhost:7687\"\nNEO4J_USERNAME = \"neo4j\"\nNEO4J_PASSWORD = \"password\"\nINDEX_NAME = \"vector-index-name\"\n\n# Connect to the Neo4j database\ndriver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USERNAME, NEO4J_PASSWORD))\n\n# Create an Embedder object\nembedder = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n\n# Initialize the retriever\nretriever = VectorRetriever(driver, INDEX_NAME, embedder)\n\n# Instantiate the LLM\nllm = OpenAILLM(model_name=\"gpt-4o\", model_params={\"temperature\": 0})\n\n# Instantiate the RAG pipeline\nrag = GraphRAG(retriever=retriever, llm=llm)\n\n# Query the graph\nquery_text = \"Who is Paul Atreides?\"\nresponse = rag.search(query_text=query_text, retriever_config={\"top_k\": 5})\nprint(response.answer)\ndriver.close()\n\n```\n\n----------------------------------------\n\nTITLE: Configuring an LLM (OpenAI) in JSON Configuration\nDESCRIPTION: Provides an example of configuring an LLM, specifically OpenAI's model, within the `llm_config` section of a JSON file. It specifies the implementation class (`class_`), constructor parameters (`params_`), including resolving the API key from an environment variable and setting model-specific parameters like temperature and max tokens.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_15\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"llm_config\": {\n        \"class_\": \"OpenAILLM\",\n        \"params_\": {\n            \"mode_name\": \"gpt-4o\",\n            \"api_key\": {\n                \"resolver_\": \"ENV\",\n                \"var_\": \"OPENAI_API_KEY\",\n            },\n            \"model_params\": {\n                \"temperature\": 0,\n                \"max_tokens\": 2000,\n                \"response_format\": {\"type\": \"json_object\"}\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Neo4j Driver in JSON Configuration\nDESCRIPTION: Illustrates how to specify Neo4j connection details (URI, user, password) within the `neo4j_config` section of a JSON configuration file using the `params_` key.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_11\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"neo4j_config\": {\n        \"params_\": {\n            \"uri\": \"bolt://...\",\n            \"user\": \"neo4j\",\n            \"password\": \"password\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Embedder with YAML\nDESCRIPTION: This YAML snippet provides an alternative way to configure an embedder.  It mirrors the JSON example, setting up an OpenAIEmbeddings embedder with an API key sourced from the `OPENAI_API_KEY` environment variable. The configuration is used to embed text for use in RAG applications.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\nembedder_config:\n  class_: OpenAIEmbeddings\n  params_:\n    api_key:\n      resolver_: ENV\n      var_: OPENAI_API_KEY\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Data Loader\nDESCRIPTION: This Python code illustrates how to implement a custom data loader by inheriting from the `DataLoader` interface.  The example shows a `MyDataLoader` class with an overridden `run` method that processes a file (represented by a `Path` object) and returns a `PdfDocument` containing the extracted text. This allows for customized data ingestion into the graph.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom neo4j_graphrag.experimental.components.pdf_loader import DataLoader, PdfDocument\n\nclass MyDataLoader(DataLoader):\n    async def run(self, path: Path) -> PdfDocument:\n        # process file in `path`\n        return PdfDocument(text=\"text\")\n```\n\n----------------------------------------\n\nTITLE: Building Graph Schema with SchemaBuilder in Python\nDESCRIPTION: Illustrates how to use the SchemaBuilder component to define a graph schema. This involves specifying desired entities, their properties, relations, and potential triplets (valid start/end entity types for relations). The schema guides the LLM during extraction.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.schema import (\n    SchemaBuilder,\n    SchemaEntity,\n    SchemaProperty,\n    SchemaRelation,\n)\n\nschema_builder = SchemaBuilder()\n\nawait schema_builder.run(\n    entities=[\n        SchemaEntity(\n            label=\"Person\",\n            properties=[\n                SchemaProperty(name=\"name\", type=\"STRING\"),\n                SchemaProperty(name=\"place_of_birth\", type=\"STRING\"),\n                SchemaProperty(name=\"date_of_birth\", type=\"DATE\"),\n            ],\n        ),\n        SchemaEntity(\n            label=\"Organization\",\n            properties=[\n                SchemaProperty(name=\"name\", type=\"STRING\"),\n                SchemaProperty(name=\"country\", type=\"STRING\"),\n            ],\n        ),\n    ],\n    relations=[\n        SchemaRelation(\n            label=\"WORKED_ON\",\n        ),\n        SchemaRelation(\n            label=\"WORKED_FOR\",\n        ),\n    ],\n    possible_schema=[\n        (\"Person\", \"WORKED_ON\", \"Field\"),\n        (\"Person\", \"WORKED_FOR\", \"Organization\"),\n    ],\n)\n```\n\n----------------------------------------\n\nTITLE: Writing Knowledge Graph Data to Neo4j in Python\nDESCRIPTION: Demonstrates the usage of the Neo4jWriter component to persist a Neo4jGraph object (containing nodes and relationships) to a Neo4j database. It requires a Neo4j database driver instance and the graph data to write.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nimport neo4j\nfrom neo4j_graphrag.experimental.components.kg_writer import Neo4jWriter\nfrom neo4j_graphrag.experimental.components.types import Neo4jGraph\n\nwith neo4j.GraphDatabase.driver(\n    \"bolt://localhost:7687\", auth=(\"neo4j\", \"password\")\n) as driver:\n    writer = Neo4jWriter(driver)\n    graph = Neo4jGraph(nodes=[], relationships=[])\n    await writer.run(graph)\n```\n\n----------------------------------------\n\nTITLE: Basic SimpleKGPipeline Configuration File (JSON)\nDESCRIPTION: Provides a minimal structure for a JSON configuration file defining a `SimpleKGPipeline`. It includes essential keys like `version_`, `template_`, and placeholders for Neo4j driver, LLM, and embedder configurations.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_9\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"version_\": 1,\n    \"template_\": \"SimpleKGPipeline\",\n    \"neo4j_config\": {},\n    \"llm_config\": {},\n    \"embedder_config\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Component to a Pipeline (PdfLoader)\nDESCRIPTION: This Python code demonstrates how to add a component, again `PdfLoader`, to a `Pipeline`. It imports the necessary modules, creates a `Pipeline` instance, instantiates the `PdfLoader`, and then adds it to the pipeline using the `add_component` method, assigning it a name. This shows how components are structured in a pipeline setting.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.pipeline import Pipeline\nfrom neo4j_graphrag.experimental.components.pdf_loader import PdfLoader\npipeline = Pipeline()\nmy_component = PdfLoader()\npipeline.add_component(my_component, \"component_name\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Hybrid Retriever - Python\nDESCRIPTION: Illustrates initializing the `HybridRetriever` which combines vector and full-text search results. This retriever requires a Neo4j driver, the names of the vector and full-text indexes, and an embedder. Both a vector index and a full-text index must exist in the database.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.retrievers import HybridRetriever\n\nINDEX_NAME = \"embedding-name\"\nFULLTEXT_INDEX_NAME = \"fulltext-index-name\"\n\nretriever = HybridRetriever(\n    driver,\n    INDEX_NAME,\n    FULLTEXT_INDEX_NAME,\n    embedder,\n)\n```\n\n----------------------------------------\n\nTITLE: Using Ollama LLM with GraphRAG in Python\nDESCRIPTION: This code shows how to utilize a local Ollama model with the `neo4j-graphrag` package. It assumes Ollama is running at `127.0.0.1:11434`.  It creates an instance of the `OllamaLLM` class, specifying the model name.  The snippet demonstrates invoking the LLM with a simple input. It requires the `neo4j_graphrag` Python package and a running Ollama instance.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.llm import OllamaLLM\nllm = OllamaLLM(\n    model_name=\"orca-mini\",\n    # host=\"...\",  # when using a remote server\n)\nllm.invoke(\"say something\")\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Text2Cypher Retriever - Python\nDESCRIPTION: Demonstrates connecting to Neo4j, initializing the `Text2CypherRetriever` with a Neo4j driver and an LLM instance (like `OpenAILLM`), optionally providing schema and examples, and performing a search using a natural language query. The retriever generates and executes a Cypher query. Requires `neo4j` and `neo4j_graphrag[openai]` (if using OpenAI).\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.retrievers import Text2CypherRetriever\nfrom neo4j_graphrag.llm import OpenAILLM\n\nURI = \"neo4j://localhost:7687\"\nAUTH = (\"neo4j\", \"password\")\n\n# Connect to Neo4j database\ndriver = GraphDatabase.driver(URI, auth=AUTH)\n\n# Create LLM object\nllm = OpenAILLM(model_name=\"gpt-4o\")\n\n# (Optional) Specify your own Neo4j schema\nneo4j_schema = \"\"\"\nNode properties:\nPerson {name: STRING, born: INTEGER}\nMovie {tagline: STRING, title: STRING, released: INTEGER}\nRelationship properties:\nACTED_IN {roles: LIST}\nREVIEWED {summary: STRING, rating: INTEGER}\nThe relationships:\n(:Person)-[:ACTED_IN]->(:Movie)\n(:Person)-[:DIRECTED]->(:Movie)\n(:Person)-[:PRODUCED]->(:Movie)\n(:Person)-[:WROTE]->(:Movie)\n(:Person)-[:FOLLOWS]->(:Person)\n(:Person)-[:REVIEWED]->(:Movie)\n\"\"\"\n\n# (Optional) Provide user input/query pairs for the LLM to use as examples\nexamples = [\n    \"USER INPUT: 'Which actors starred in the Matrix?' QUERY: MATCH (p:Person)-[:ACTED_IN]->(m:Movie) WHERE m.title = 'The Matrix' RETURN p.name\"\n]\n\n# Initialize the retriever\nretriever = Text2CypherRetriever(\n    driver=driver,\n    llm=llm,  # type: ignore\n    neo4j_schema=neo4j_schema,\n    examples=examples,\n)\n\n# Generate a Cypher query using the LLM, send it to the Neo4j database, and return the results\nquery_text = \"Which movies did Hugo Weaving star in?\"\nprint(retriever.search(query_text=query_text))\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Running SimpleKGPipeline in Python\nDESCRIPTION: Demonstrates the basic usage of SimpleKGPipeline. It shows how to import the class, initialize it with required components (LLMInterface, Neo4j driver, Embedder), and execute the pipeline asynchronously using either a file path (if from_pdf=True) or raw text (if from_pdf=False).\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j_graphrag.experimental.pipeline.kg_builder import SimpleKGPipeline\n\nkg_builder = SimpleKGPipeline(\n    llm=llm, # an LLMInterface for Entity and Relation extraction\n    driver=neo4j_driver,  # a neo4j driver to write results to graph\n    embedder=embedder,  # an Embedder for chunks\n    from_pdf=True,   # set to False if parsing an already extracted text\n)\nawait kg_builder.run_async(file_path=str(file_path))\n# await kg_builder.run_async(text=\"my text\")  # if using from_pdf=False\n```\n\n----------------------------------------\n\nTITLE: Defining Entities and Relations for Graph Schema in Python\nDESCRIPTION: Illustrates how to define lists of entities and relations to guide the LLM during knowledge graph extraction. Entities and relations can be specified as simple strings (labels) or dictionaries containing 'label', optional 'description', and optional 'properties'.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nENTITIES = [\n    # entities can be defined with a simple label...\n    \"Person\",\n    # ... or with a dict if more details are needed,\n    # such as a description:\n    {\"label\": \"House\", \"description\": \"Family the person belongs to\"},\n    # or a list of properties the LLM will try to attach to the entity:\n    {\"label\": \"Planet\", \"properties\": [{\"name\": \"weather\", \"type\": \"STRING\"}]},\n]\n# same thing for relationships:\nRELATIONS = [\n    \"PARENT_OF\",\n    {\n        \"label\": \"HEIR_OF\",\n        \"description\": \"Used for inheritor relationship between father and sons\",\n    },\n    {\"label\": \"RULES\", \"properties\": [{\"name\": \"fromYear\", \"type\": \"INTEGER\"}]},\n]\n```\n\n----------------------------------------\n\nTITLE: Using MistralAI LLM with GraphRAG in Python\nDESCRIPTION: This snippet demonstrates how to integrate MistralAI LLM with the `neo4j-graphrag` package. It creates an instance of the `MistralAILLM` class using the model name and API key (or the `MISTRAL_API_KEY` environment variable). The snippet concludes by calling the LLM with a test prompt. It requires the `neo4j_graphrag` and `mistralai` Python packages.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.llm import MistralAILLM\n\nllm = MistralAILLM(\n    model_name=\"mistral-small-latest\",\n    api_key=api_key,  # can also set `MISTRAL_API_KEY` in env vars\n)\nllm.invoke(\"say something\")\n```\n\n----------------------------------------\n\nTITLE: Using Cohere LLM with GraphRAG in Python\nDESCRIPTION: This snippet illustrates how to use the Cohere LLM with the `neo4j-graphrag` package. It instantiates the `CohereLLM` class, specifying the model name and API key (or using the `CO_API_KEY` environment variable). The snippet then invokes the LLM with a sample prompt. It requires the `neo4j_graphrag` and `cohere` Python packages.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.llm import CohereLLM\n\nllm = CohereLLM(\n    model_name=\"command-r\",\n    api_key=api_key,  # can also set `CO_API_KEY` in env vars\n)\nllm.invoke(\"say something\")\n```\n\n----------------------------------------\n\nTITLE: Initializing SentenceTransformer Embeddings in Python\nDESCRIPTION: Shows how to create an instance of the `SentenceTransformerEmbeddings` class, which can be used by retrievers to convert text into vectors. It accepts a `model` name parameter, specifying the pre-trained sentence transformer model to use for embedding.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.embeddings import SentenceTransformerEmbeddings\n\nembedder = SentenceTransformerEmbeddings(model=\"all-MiniLM-L6-v2\")  # Note: this is the default model\n```\n\n----------------------------------------\n\nTITLE: Populating Neo4j Vector Index with Embeddings (Python)\nDESCRIPTION: Shows how to generate a vector embedding using OpenAIEmbeddings and then upsert it into a Neo4j database using the `upsert_vectors` function. It connects to the database and demonstrates adding the generated vector to a node identified by an ID, storing it under a specified property. Requires the 'openai' extra dependency and a vector index created prior to execution.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.embeddings import OpenAIEmbeddings\nfrom neo4j_graphrag.indexes import upsert_vectors\nfrom neo4j_graphrag.types import EntityType\n\nNEO4J_URI = \"neo4j://localhost:7687\"\nNEO4J_USERNAME = \"neo4j\"\nNEO4J_PASSWORD = \"password\"\n\n# Connect to the Neo4j database\ndriver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USERNAME, NEO4J_PASSWORD))\n\n# Create an Embedder object\nembedder = OpenAIEmbeddings(model=\"text-embedding-3-large\")\n\n# Generate an embedding for some text\ntext = (\n    \"The son of Duke Leto Atreides and the Lady Jessica, Paul is the heir of House \"\n    \"Atreides, an aristocratic family that rules the planet Caladan.\"\n)\nvector = embedder.embed_query(text)\n\n# Upsert the vector\nupsert_vectors(\n    driver,\n    ids=[\"1234\"],\n    embedding_property=\"vectorProperty\",\n    embeddings=[vector],\n    entity_type=EntityType.NODE,\n)\ndriver.close()\n\n```\n\n----------------------------------------\n\nTITLE: Defining Potential Schema Triples in Python\nDESCRIPTION: Shows how to define the potential graph schema as a list of tuples. Each tuple represents a valid triplet structure (source_node_label, relationship_label, target_node_label) to guide the LLM in connecting extracted entities.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nPOTENTIAL_SCHEMA = [\n    (\"Person\", \"PARENT_OF\", \"Person\"),\n    (\"Person\", \"HEIR_OF\", \"House\"),\n    (\"House\", \"RULES\", \"Planet\"),\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring SimpleKGPipeline with Custom Schema in Python\nDESCRIPTION: Demonstrates how to provide the defined entities, relations, and potential schema structure to the SimpleKGPipeline during initialization using the `entities`, `relations`, and `potential_schema` parameters.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nkg_builder = SimpleKGPipeline(\n    # ...\n    entities=ENTITIES,\n    relations=RELATIONS,\n    potential_schema=POTENTIAL_SCHEMA,\n    # ...\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing VectorCypher Retriever with Retrieval Query in Python\nDESCRIPTION: Initializes the `VectorCypherRetriever`, which combines vector search with graph traversal. The `retrieval_query` parameter takes a Cypher query string that is executed for each node found by the vector search, using the `node` and `score` variables available in its scope.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nretrieval_query = \"\"\"\nRETURN  node.title as movieTitle,\n        node.plot as moviePlot,\n        collect { MATCH (actor:Actor)-[:ACTED_IN]->(node) RETURN actor.name } AS actors\n\"\"\"\nretriever = VectorCypherRetriever(\n    driver,\n    index_name=INDEX_NAME,\n    retrieval_query=retrieval_query,\n)\n```\n\n----------------------------------------\n\nTITLE: Using the LexicalGraphBuilder Component\nDESCRIPTION: This Python code demonstrates how to use the `LexicalGraphBuilder` component to create a lexical graph from text chunks. It imports the necessary modules, instantiates the `LexicalGraphBuilder` with a `LexicalGraphConfig`, and then calls the `run` method with the text chunks and document information.  The resulting graph structure captures the document and its text chunks with relationships.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.pipeline.components.lexical_graph_builder import LexicalGraphBuilder\nfrom neo4j_graphrag.experimental.pipeline.components.types import LexicalGraphConfig\n\nlexical_graph_builder = LexicalGraphBuilder(config=LexicalGraphConfig())\ngraph = await lexical_graph_builder.run(\n    text_chunks=TextChunks(chunks=[\n        TextChunk(text=\"some text\", index=0),\n        TextChunk(text=\"some text\", index=1),\n    ]),\n    document_info=DocumentInfo(path=\"my_document.pdf\"),\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring VectorCypher Retriever with Result Formatter in Python\nDESCRIPTION: Demonstrates how to provide a custom function (`result_formatter`) to process the results from the `retrieval_query`. This function takes a Neo4j record and should return a `RetrieverResultItem`, allowing customization of the output format for the RAG context.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef result_formatter(record: neo4j.Record) -> RetrieverResultItem:\n    content=f\"Movie title: {record.get('movieTitle')}, description: {record.get('movieDescription')}, actors: {record.get('actors')}\",\n    return RetrieverResultItem(\n        metadata={\n            \"title\": record.get('movieTitle'),\n            \"score\": record.get(\"score\"),\n        }\n    )\n\nretriever = VectorCypherRetriever(\n    driver,\n    index_name=INDEX_NAME,\n    retrieval_query=\"OPTIONAL MATCH (node)<-[:ACTED_IN]-(p:Person) RETURN node.title as movieTitle, node.plot as movieDescription, collect(p.name) as actors, score\",\n    result_formatter=result_formatter,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Hybrid Cypher Retriever - Python\nDESCRIPTION: Shows how to initialize the `HybridCypherRetriever`, which performs vector and full-text search and then uses a Cypher query to expand the context around the retrieved nodes. It requires a Neo4j driver, vector and full-text index names, an optional `retrieval_query`, and an embedder.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.retrievers import HybridCypherRetriever\n\nINDEX_NAME = \"embedding-name\"\nFULLTEXT_INDEX_NAME = \"fulltext-index-name\"\n\nretriever = HybridCypherRetriever(\n    driver,\n    INDEX_NAME,\n    FULLTEXT_INDEX_NAME,\n    retrieval_query=\"MATCH (node)-[:AUTHORED_BY]->(author:Author) RETURN author.name\"\n    embedder=embedder,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating and Running a Simple Pipeline (Python)\nDESCRIPTION: Demonstrates the basic steps for building and executing a pipeline: instantiate `Pipeline`, add components by name using `add_component`, define data flow connections between components using `connect` and `input_config`, and run the pipeline asynchronously with `asyncio.run`, providing initial inputs.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom neo4j_graphrag.experimental.pipeline import Pipeline\n\npipe = Pipeline()\npipe.add_component(ComponentAdd(), \"a\")\npipe.add_component(ComponentAdd(), \"b\")\n\npipe.connect(\"a\", \"b\", input_config={\"number2\": \"a.result\"})\nasyncio.run(pipe.run({\"a\": {\"number1\": 10, \"number2\": 1}, \"b\": {\"number1\": 4}}))\n# result: 10+1+4 = 15\n```\n\n----------------------------------------\n\nTITLE: Configuring Entity Extraction Parameters in SimpleKGPipeline (Python)\nDESCRIPTION: Illustrates passing additional configuration parameters to the SimpleKGPipeline that influence the underlying EntityAndRelationExtractor component. Options include custom prompts, lexical graph settings, schema enforcement level, and error handling strategy.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nkg_builder = SimpleKGPipeline(\n    # ...\n    prompt_template=\"\",\n    lexical_graph_config=my_config,\n    enforce_schema=\"STRICT\"\n    on_error=\"RAISE\",\n    # ...\n)\n```\n\n----------------------------------------\n\nTITLE: Customizing Text Splitter in SimpleKGPipeline (Python)\nDESCRIPTION: Explains how to replace the default text splitter with a custom instance. This example uses `FixedSizeSplitter` to specify custom chunk size and overlap, passing the initialized splitter object via the `text_splitter` parameter.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.text_splitters.fixed_size_splitter import (\n    FixedSizeSplitter,\n)\n\ntext_splitter = FixedSizeSplitter(chunk_size=500, chunk_overlap=100)\n\nkg_builder = SimpleKGPipeline(\n    # ...\n    text_splitter=text_splitter,\n    # ...\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Pinecone Neo4j Retriever - Python\nDESCRIPTION: Demonstrates how to initialize the `PineconeNeo4jRetriever`. This requires a Pinecone client, a Neo4j driver, an index name, the Neo4j node ID property name, and an embedder. Ensure the `pinecone` and `neo4j_graphrag[pinecone]` Python clients are installed.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pinecone import Pinecone\nfrom neo4j_graphrag.retrievers import PineconeNeo4jRetriever\n\nclient = Pinecone()  # ... create your Pinecone client\n\nretriever = PineconeNeo4jRetriever(\n    driver=driver,\n    client=client,\n    index_name=\"Movies\",\n    id_property_neo4j=\"id\",\n    embedder=embedder,\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Neo4j Vector Index (Python)\nDESCRIPTION: Provides Python code to create a vector index within a Neo4j database using the `create_vector_index` helper function. It establishes a connection to Neo4j and defines the index's name, target node label, property holding the embedding vector, the dimension count, and the similarity function. An active Neo4j instance is required.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.indexes import create_vector_index\n\nNEO4J_URI = \"neo4j://localhost:7687\"\nNEO4J_USERNAME = \"neo4j\"\nNEO4J_PASSWORD = \"password\"\nINDEX_NAME = \"vector-index-name\"\n\n# Connect to the Neo4j database\ndriver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USERNAME, NEO4J_PASSWORD))\n\n# Create the index\ncreate_vector_index(\n    driver,\n    INDEX_NAME,\n    label=\"Chunk\",\n    embedding_property=\"embedding\",\n    dimensions=3072,\n    similarity_fn=\"euclidean\",\n)\ndriver.close()\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Vector Retriever with Return Properties in Python\nDESCRIPTION: Demonstrates how to restrict the node properties returned by the `VectorRetriever` search. The `return_properties` parameter, provided during initialization, takes a list of strings specifying the names of the properties to be included in the result objects.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.retrievers import VectorRetriever\n\nretriever = VectorRetriever(\n    driver,\n    index_name=POSTER_INDEX_NAME,\n    embedder=embedder,\n    return_properties=[\"title\"],\n)\n```\n\n----------------------------------------\n\nTITLE: Using the FixedSizeSplitter Component\nDESCRIPTION: This Python code demonstrates how to use the `FixedSizeSplitter` component to split text into chunks of a fixed size. It imports the component, instantiates it with specified chunk size and overlap, and then calls the `run` method with the text to be split.  The `approximate` flag controls whether to ensure clean chunk boundaries.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.text_splitters.fixed_size_splitter import FixedSizeSplitter\n\nsplitter = FixedSizeSplitter(chunk_size=4000, chunk_overlap=200, approximate=False)\nsplitter.run(text=\"Hello World. Life is beautiful.\")\n```\n\n----------------------------------------\n\nTITLE: Enforcing Schema in LLM Entity Relation Extraction in Python\nDESCRIPTION: Demonstrates how to enable schema enforcement in the LLMEntityRelationExtractor. By setting `enforce_schema` to a value like `SchemaEnforcementMode.STRICT`, the component will validate and prune extracted data that does not conform to the provided schema.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.entity_relation_extractor import LLMEntityRelationExtractor\nfrom neo4j_graphrag.experimental.components.types import SchemaEnforcementMode\n\nextractor = LLMEntityRelationExtractor(\n    # ...\n    enforce_schema=SchemaEnforcementMode.STRICT,\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Text Splitter with YAML\nDESCRIPTION: This YAML snippet provides the YAML equivalent of the previous JSON example. It configures a `FixedSizeSplitter` to split text into chunks, specifying the `chunk_size` and `chunk_overlap`. This configuration is used for preparing text data for LLMs and graph building.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_22\n\nLANGUAGE: yaml\nCODE:\n```\ntext_splitter:\n  class_: text_splitters.fixed_size_splitter.FixedSizeSplitter\n  params_:\n    chunk_size: 100\n    chunk_overlap: 10\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Retriever - Python\nDESCRIPTION: Shows how to create a custom retriever by inheriting from the `Retriever` base class and implementing the `get_search_results` method. The custom class must accept a Neo4j driver during initialization. Implement the `get_search_results` method to define the custom retrieval logic.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.retrievers.base import Retriever\n\nclass MyCustomRetriever(Retriever):\n    def __init__(\n        self,\n        driver: neo4j.Driver,\n        # any other required parameters\n    ) -> None:\n        super().__init__(driver)\n\n    def get_search_results(\n        self,\n        query_vector: Optional[list[float]] = None,\n        query_text: Optional[str] = None,\n        top_k: int = 5,\n        filters: Optional[dict[str, Any]] = None,\n    ) -> RawSearchResult:\n        pass\n```\n\n----------------------------------------\n\nTITLE: Searching with Pre-Filters in Vector Retriever in Python\nDESCRIPTION: Shows how to apply filters to a vector similarity search. The `filters` parameter is a dictionary specifying conditions based on node properties, which are applied *before* the similarity search (a warning notes this bypasses the vector index for an exact match).\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.retrievers import VectorRetriever\n\nretriever = VectorRetriever(\n    driver,\n    index_name=POSTER_INDEX_NAME,\n)\n\nfilters = {\n    \"year\": {\n        \"$gte\": 2000,\n    }\n}\n\nquery_text = \"How do I do similarity search in Neo4j?\"\nretriever_result = retriever.search(query_text=query_text, filters=filters)\n```\n\n----------------------------------------\n\nTITLE: Using LangChain LLM with GraphRAG in Python\nDESCRIPTION: This snippet illustrates how to integrate a LangChain chat model with the `neo4j-graphrag` package. It instantiates a `ChatOllama` model from `langchain_community.chat_models`, then initializes the `GraphRAG` pipeline with a retriever and the LangChain LLM. The snippet includes querying the graph and printing the response. It requires the `neo4j_graphrag` and `langchain-community` Python packages.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.generation import GraphRAG\nfrom langchain_community.chat_models import ChatOllama\n\n# retriever = ...\n\nllm = ChatOllama(model=\"llama3:8b\")\nrag = GraphRAG(retriever=retriever, llm=llm)\nquery_text = \"How do I do similarity search in Neo4j?\"\nresponse = rag.search(query_text=query_text, retriever_config={\"top_k\": 5})\nprint(response.answer)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Pipeline Component (Python)\nDESCRIPTION: Illustrates how to create a custom pipeline component by subclassing `Component` and defining a data model using `DataModel`. The core logic resides in the asynchronous `run` method, specifying input parameters and the output data model.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.pipeline import Component, DataModel\n\nclass IntResultModel(DataModel):\n    result: int\n\nclass ComponentAdd(Component):\n    async def run(self, number1: int, number2: int = 1) -> IntResultModel:\n        return IntResultModel(result = number1 + number2)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Entity Relation Extractor in Python\nDESCRIPTION: Provides an example of subclassing the base EntityRelationExtractor interface. This allows implementing custom logic for entity and relation extraction, returning a Neo4jGraph object containing the extracted nodes and relationships.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_call\nfrom neo4j_graphrag.experimental.components.entity_relation_extractor import EntityRelationExtractor\nfrom neo4j_graphrag.experimental.components.schema import SchemaConfig\nfrom neo4j_graphrag.experimental.components.types import (\n    Neo4jGraph,\n    Neo4jNode,\n    Neo4jRelationship,\n    TextChunks,\n)\n\nclass MyExtractor(EntityRelationExtractor):\n\n    @validate_call\n    async def run(self, chunks: TextChunks, **kwargs: Any) -> Neo4jGraph:\n        return Neo4jGraph(\n            nodes=[\n                Neo4jNode(id=\"0\", label=\"Person\", properties={\"name\": \"A. Einstein\"}),\n                Neo4jNode(id=\"1\", label=\"Concept\", properties={\"name\": \"Theory of relativity\"}),\n            ],\n            relationships=[\n                Neo4jRelationship(type=\"PROPOSED_BY\", start_node_id=\"1\", end_node_id=\"0\", properties={\"year\": 1915})\n            ],\n        )\n```\n\n----------------------------------------\n\nTITLE: Configuring a Custom Prompt for GraphRAG in Python\nDESCRIPTION: This code snippet shows how to customize the prompt used by the `GraphRAG` pipeline. It defines a custom `RagTemplate` with a specific prompt and expected input variables. The snippet then initializes the `GraphRAG` pipeline with the custom prompt template.  It requires the `neo4j_graphrag` Python package.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.generation import RagTemplate, GraphRAG\n\n# retriever = ...\n# llm = ...\n\nprompt_template = RagTemplate(\n    prompt=\"Answer the question {question} using context {context} and examples {examples}\",\n    expected_inputs=[\"context\", \"question\", \"examples\"]\n)\n\nrag = GraphRAG(retriever=retriever, llm=llm, prompt_template=prompt_template)\n\n# ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom LLM Interface for GraphRAG in Python\nDESCRIPTION: This example shows how to create a custom LLM class by subclassing the `LLMInterface` from the `neo4j-graphrag` package. It defines an `OllamaLLM` class that uses the Python Ollama client to interact with a local LLM.  It implements the `invoke` and `ainvoke` methods to handle synchronous and asynchronous requests. The snippet includes initializing the `GraphRAG` pipeline and querying the graph. It requires the `neo4j_graphrag` and `ollama` Python packages and a running Ollama instance.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport ollama\nfrom neo4j_graphrag.llm import LLMInterface, LLMResponse\n\nclass OllamaLLM(LLMInterface):\n\n    def invoke(self, input: str) -> LLMResponse:\n        response = ollama.chat(model=self.model_name, messages=[\n          {\n            'role': 'user',\n            'content': input,\n          },\n        ])\n        return LLMResponse(\n            content=response[\"message\"][\"content\"]\n        )\n\n    async def ainvoke(self, input: str) -> LLMResponse:\n        return self.invoke(input)  # TODO: implement async with ollama.AsyncClient\n\n\n# retriever = ...\n\nllm = OllamaLLM(\"llama3:8b\")\n\nrag = GraphRAG(retriever=retriever, llm=llm)\nquery_text = \"How do I do similarity search in Neo4j?\"\nresponse = rag.search(query_text=query_text, retriever_config={\"top_k\": 5})\nprint(response.answer)\n```\n\n----------------------------------------\n\nTITLE: Configuring Neo4jChunkReader Lexical Graph in Python\nDESCRIPTION: Shows how to configure the Neo4jChunkReader by providing a LexicalGraphConfig object. This allows customization of the node labels and relationship types used for the lexical graph elements (documents, chunks).\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.neo4j_reader import Neo4jChunkReader\nfrom neo4j_graphrag.experimental.components.types import LexicalGraphConfig, TextChunks\n\n# optionally, define a LexicalGraphConfig object\n# shown below with the default values\nconfig = LexicalGraphConfig(\n    chunk_node_label=\"Chunk\",\n    document_node_label=\"Document\",\n    chunk_to_document_relationship_type=\"PART_OF_DOCUMENT\",\n    next_chunk_relationship_type=\"NEXT_CHUNK\",\n    node_to_chunk_relationship_type=\"PART_OF_CHUNK\",\n    chunk_embedding_property=\"embeddings\",\n)\nreader = Neo4jChunkReader(driver)\nresult = await reader.run(lexical_graph_config=config)\n```\n\n----------------------------------------\n\nTITLE: Creating a Vector Index in Neo4j - Python\nDESCRIPTION: Provides code to connect to a Neo4j database and use the `create_vector_index` helper function. This function creates a vector index for a specified label and property with defined dimensions and similarity function.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.indexes import create_vector_index\n\nURI = \"neo4j://localhost:7687\"\nAUTH = (\"neo4j\", \"password\")\n\nINDEX_NAME = \"chunk-index\"\nDIMENSION=1536\n\n# Connect to Neo4j database\ndriver = GraphDatabase.driver(URI, auth=AUTH)\n\n# Creating the index\ncreate_vector_index(\n    driver,\n    INDEX_NAME,\n    label=\"Document\",\n    embedding_property=\"vectorProperty\",\n    dimensions=DIMENSION,\n    similarity_fn=\"euclidean\",\n)\n```\n\n----------------------------------------\n\nTITLE: Defining a JSON Knowledge Graph Writer in Python\nDESCRIPTION: Defines the JsonWriter class, inheriting from KGWriter, for exporting a Neo4jGraph object to JSON. The class initializes with a file name and asynchronously writes the knowledge graph's contents to disk using the Pydantic model serialization. It requires the validate_call decorator and proper exception handling ensures a status report; dependencies include the neo4j_graphrag.experimental.components.kg_writer and Pydantic.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_44\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.kg_writer import KGWriter\n\nclass JsonWriter(KGWriter):\n\n    def __init__(self, file_name: str) -> None:\n        self.file_name = file_name\n\n    @validate_call\n    async def run(self, graph: Neo4jGraph) -> KGWriterModel:\n        try:\n            with open(self.file_name, \"w\") as f:\n                json.dump(graph.model_dump(), f, indent=2)\n            return KGWriterModel(status=\"SUCCESS\")\n        except Exception:\n            return KGWriterModel(status=\"FAILURE\")\n```\n\n----------------------------------------\n\nTITLE: Filtering Entity Resolution in Neo4j with Python\nDESCRIPTION: Demonstrates the use of a custom Cypher filter_query for excluding certain nodes from entity resolution. Here, entities with the Resolved label are excluded from the resolver by providing a query string. The process involves passing both the driver and an optional filter_query to the SinglePropertyExactMatchResolver; modify the filter query to suit specific entity exclusion policies.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_46\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.resolver import (\n    SinglePropertyExactMatchResolver,\n)\nfilter_query = \"WHERE NOT entity:Resolved\"\nresolver = SinglePropertyExactMatchResolver(driver, filter_query=filter_query)\nres = await resolver.run()\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Running Entity Resolvers in Neo4j with Python\nDESCRIPTION: Shows how to import and instantiate different Neo4j entity resolversSinglePropertyExactMatchResolver, SpaCySemanticMatchResolver, and FuzzyMatchResolverand run them on a graph. These resolvers enable merging of nodes based on exact match, semantic similarity (requires spaCy), or fuzzy string similarity (requires RapidFuzz). Focuses on the usage of the resolver interface, expected to return a resolution result asynchronously; be sure to install the necessary dependencies for spaCy and RapidFuzz as noted.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_45\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.resolver import (\n    SinglePropertyExactMatchResolver,\n    # SpaCySemanticMatchResolver,\n    # FuzzyMatchResolver,\n)\nresolver = SinglePropertyExactMatchResolver(driver)  # exact match resolver\n# resolver = SpaCySemanticMatchResolver(driver)  # semantic match with spaCy\n# resolver = FuzzyMatchResolver(driver)  # fuzzy match with RapidFuzz\nres = await resolver.run()\n```\n\n----------------------------------------\n\nTITLE: Specifying Target Neo4j Database in SimpleKGPipeline (Python)\nDESCRIPTION: Demonstrates how to configure the SimpleKGPipeline to write the extracted knowledge graph to a specific Neo4j database instead of the default one, using the `neo4j_database` parameter.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nkg_builder = SimpleKGPipeline(\n    # ...\n    neo4j_database=\"myDb\",\n    # ...\n)\n```\n\n----------------------------------------\n\nTITLE: Using the TextChunkEmbedder Component\nDESCRIPTION: This Python code demonstrates how to use the `TextChunkEmbedder` component to embed text chunks using an `OpenAIEmbeddings` embedder. It imports the necessary modules, instantiates the `TextChunkEmbedder` with the `OpenAIEmbeddings` instance, and then calls the `run` method with the text chunks to be embedded.  This step prepares text data for vector search.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.embedder import TextChunkEmbedder\nfrom neo4j_graphrag.embeddings.openai import OpenAIEmbeddings\ntext_chunk_embedder = TextChunkEmbedder(embedder=OpenAIEmbeddings())\nawait text_chunk_embedder.run(text_chunks=TextChunks(chunks=[TextChunk(text=\"my_text\")]))\n```\n\n----------------------------------------\n\nTITLE: Disabling Entity Resolution in SimpleKGPipeline (Python)\nDESCRIPTION: Shows how to prevent the default entity resolution step (merging nodes with the same label and name) from running after pipeline execution by setting the `perform_entity_resolution` parameter to `False`.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nkg_builder = SimpleKGPipeline(\n    # ...\n    perform_entity_resolution=False,\n    # ...\n)\n```\n\n----------------------------------------\n\nTITLE: Disabling Lexical Graph Creation in LLM Extraction in Python\nDESCRIPTION: Illustrates how to prevent the LLMEntityRelationExtractor from creating lexical graph nodes (Document and Chunk) by setting `create_lexical_graph` to `False`. Relationships between extracted entities and chunks may still be created depending on other configurations.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nextractor = LLMEntityRelationExtractor(\n    llm=....,\n    create_lexical_graph=False,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Vector Retriever in Python\nDESCRIPTION: Demonstrates the basic initialization of the `VectorRetriever` class. It requires a Neo4j driver instance and the name of the vector index to be used for similarity searches. The `index_name` parameter specifies which pre-existing vector index in Neo4j the retriever will query.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.retrievers import VectorRetriever\n\nretriever = VectorRetriever(\n    driver,\n    index_name=POSTER_INDEX_NAME,\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Error Handling in LLM Entity Relation Extraction in Python\nDESCRIPTION: Shows how to configure the error handling behavior of the LLMEntityRelationExtractor using the `on_error` flag. Setting it to `OnError.RAISE` will cause the entire process to fail if any single chunk extraction fails.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.entity_relation_extractor import (\n    LLMEntityRelationExtractor,\n    OnError,\n)\n\nextractor = LLMEntityRelationExtractor(\n    # ...\n    on_error=OnError.RAISE,\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Text Splitter\nDESCRIPTION: This Python code shows how to implement a custom text splitter by inheriting from the `TextSplitter` interface. It presents a `MyTextSplitter` class that splits text based on a separator and returns `TextChunks`.  This demonstrates how to customize the text splitting process for specific needs.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.components.text_splitters.base import TextSplitter\nfrom neo4j_graphrag.experimental.components.types import TextChunks, TextChunk\n\n\nclass MyTextSplitter(TextSplitter):\n\n    def __init__(self, separator: str = \".\") -> None:\n        self.separator = separator\n\n    async def run(self, text: str) -> TextChunks:\n         return TextChunks(\n             chunks=[\n                 TextChunk(text=text_chunk)\n                 for text_chunk in text.split(self.separator)\n             ]\n         )\n```\n\n----------------------------------------\n\nTITLE: Searching by Vector with Vector Retriever in Python\nDESCRIPTION: Shows how to use the `search` method of the `VectorRetriever` when the query is provided as a pre-computed vector. It takes the `query_vector` (a list of floats matching the index vector size) and `top_k` (the number of top similar results to return) as parameters.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nvector = []  # a list of floats, same size as the vectors in the Neo4j vector index\nretriever_result = retriever.search(query_vector=vector, top_k=3)\n```\n\n----------------------------------------\n\nTITLE: Configuring Text Splitter with JSON\nDESCRIPTION: This JSON snippet shows how to configure a custom text splitter.  It uses the `FixedSizeSplitter` to divide the text into chunks of a specified size and overlap.  The `class_` parameter specifies the class to instantiate, and `params_` provides the constructor arguments.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"text_splitter\": {\n        \"class_\": \"text_splitters.FixedSizeSplitter\",\n        \"params_\": {\n            \"chunk_size\": 500,\n            \"chunk_overlap\": 100\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Azure OpenAI LLM with GraphRAG in Python\nDESCRIPTION: This snippet demonstrates how to configure and use the Azure OpenAI LLM with the `neo4j-graphrag` package. It instantiates the `AzureOpenAILLM` class, providing the model name, Azure endpoint, API version, and API key. The snippet also shows how to invoke the LLM with a sample input.  It requires the `neo4j_graphrag` and `openai` Python packages.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.llm import AzureOpenAILLM\nllm = AzureOpenAILLM(\n    model_name=\"gpt-4o\",\n    azure_endpoint=\"https://example-endpoint.openai.azure.com/\",  # update with your endpoint\n    api_version=\"2024-06-01\",  # update appropriate version\n    api_key=\"...\",  # api_key is optional and can also be set with OPENAI_API_KEY env var\n)\nllm.invoke(\"say something\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Pipeline Parameters with YAML\nDESCRIPTION: This YAML snippet offers a configuration alternative to the previous JSON example. It defines the same parameters for the `SimpleKGPipeline`, including settings for PDF processing, entity resolution, database connection, error handling, prompt templates, and entity/relation definitions for the knowledge graph.  The `potential_schema` section defines allowed relationship types.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\nfrom_pdf: false\nperform_entity_resolution: true\neo4j_database: myDb\non_error: IGNORE\nprompt_template: ...\nentities:\n  - label: Person\n  - label: House\n    description: Family the person belongs to\n    properties:\n      - name: name\n        type: STRING\n  - label: Planet\n    properties:\n      - name: name\n        type: STRING\n      - name: weather\n        type: STRING\nrelations:\n  - label: PARENT_OF\n  - label: HEIR_OF\n    description: Used for inheritor relationship between father and sons\n  - label: RULES\n    properties:\n      - name: fromYear\n        type: INTEGER\npotential_schema:\n  - [\"Person\", \"PARENT_OF\", \"Person\"]\n  - [\"Person\", \"HEIR_OF\", \"House\"]\n  - [\"House\", \"RULES\", \"Planet\"]\nlexical_graph_config:\n    chunk_node_label: TextPart\n```\n\n----------------------------------------\n\nTITLE: Customizing Prompt for LLM Entity Relation Extraction in Python\nDESCRIPTION: Shows how to provide a custom prompt string to the LLMEntityRelationExtractor. This allows tailoring the instructions given to the LLM for the entity and relation extraction task, utilizing variables like `{text}`, `{schema}`, and `{examples}`.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nextractor = LLMEntityRelationExtractor(\n    llm=....,\n    prompt=\"Extract entities from {text}\",\n)\n```\n\n----------------------------------------\n\nTITLE: Using VertexAI LLM with GraphRAG in Python\nDESCRIPTION: This code shows how to integrate Google VertexAI LLM with the `neo4j-graphrag` package.  It imports the `VertexAILLM` class and `GenerationConfig` from `vertexai.generative_models`, configures generation settings, and instantiates the LLM. The snippet concludes by invoking the LLM with a simple query. It requires the `neo4j_graphrag` and `google-cloud-aiplatform` Python packages.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.llm import VertexAILLM\nfrom vertexai.generative_models import GenerationConfig\n\ngeneration_config = GenerationConfig(temperature=0.0)\nllm = VertexAILLM(\n    model_name=\"gemini-1.5-flash-001\", generation_config=generation_config\n)\nllm.invoke(\"say something\")\n```\n\n----------------------------------------\n\nTITLE: Populating a Vector Index in Neo4j - Python\nDESCRIPTION: Shows how to connect to Neo4j and use the `upsert_vectors` function to add or update vector properties on existing nodes or relationships. This makes the entities findable via a vector index search.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom random import random\n\nfrom neo4j import GraphDatabase\nfrom neo4j_graphrag.indexes import upsert_vectors\nfrom neo4j_graphrag.types import EntityType\n\nURI = \"neo4j://localhost:7687\"\nAUTH = (\"neo4j\", \"password\")\n\n# Connect to Neo4j database\ndriver = GraphDatabase.driver(URI, auth=AUTH)\n\n# Upsert the vector\nDIMENSION = 1536\nvector = [random() for _ in range(DIMENSION)]\nupsert_vectors(\n    driver,\n    ids=[\"1234\"],\n    embedding_property=\"vectorProperty\",\n    embeddings=[vector],\n    entity_type=EntityType.NODE,\n)\n```\n\n----------------------------------------\n\nTITLE: Running Vector Search Retriever with Neo4j and Pinecone in Python\nDESCRIPTION: This snippet illustrates how to run a vector-based search retriever example using Poetry. Prior to execution, the user should configure the environment variables `NEO4J_AUTH`, `NEO4J_URL`, and `PC_API_KEY` appropriately. This command launches a Python module designed to perform similarity search based on vector embeddings stored in Pinecone and linked via Neo4j.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/pinecone/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python -m examples.customize.retrievers.external.pinecone.vector_search\n```\n\n----------------------------------------\n\nTITLE: Excluding Entities from Resolution by Document Origin in Neo4j with Python\nDESCRIPTION: Illustrates how to use a Cypher filter_query to avoid resolving entities linked to nodes with the OldDocument label, typically for handling results from multiple pipeline runs. The approach sets a filter_query to check that entities do not have a FROM_DOCUMENT relationship to OldDocument, allowing for selective entity resolution according to document provenance.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_47\n\nLANGUAGE: Python\nCODE:\n```\nfilter_query = \"WHERE NOT EXISTS((entity)-[:FROM_DOCUMENT]->(:OldDocument))\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Neo4j Connection in Python\nDESCRIPTION: This snippet establishes a connection to the Neo4j database using the official Python driver. It sets up the necessary driver instance to facilitate subsequent graph data operations. Dependencies include the neo4j Python library, and the snippet typically includes credentials and connection parameters. It outputs a driver object used for executing Cypher queries.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/tests/e2e/data/documents/harry_potter_part1.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j import GraphDatabase\n\n# Create a driver instance to connect to Neo4j\ndriver = GraphDatabase.driver(\"bolt://localhost:7687\", auth=(\"neo4j\", \"password\"))\n```\n\n----------------------------------------\n\nTITLE: Initializing Qdrant Neo4j Retriever - Python\nDESCRIPTION: Shows how to initialize the `QdrantNeo4jRetriever`. This requires a Qdrant client, a Neo4j driver, a collection name, a vector field name (`using`), external and Neo4j ID property names, and an embedder. Ensure the `qdrant-client` and `neo4j_graphrag[qdrant]` Python clients are installed.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom qdrant_client import QdrantClient\nfrom neo4j_graphrag.retrievers import QdrantNeo4jRetriever\n\nclient = QdrantClient(...)  # construct the Qdrant client instance\n\nretriever = QdrantNeo4jRetriever(\n    driver=driver,\n    client=client,\n    collection_name=\"my-collection\",\n    using=\"my-vector\",\n    id_property_external=\"neo4j_id\",    # The payload field that contains identifier to a corresponding Neo4j node id property\n    id_property_neo4j=\"id\",\n    embedder=embedder,\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Weaviate Neo4j Retriever in Python\nDESCRIPTION: Shows how to initialize the `WeaviateNeo4jRetriever`, which delegates vector search to a Weaviate database while linking results back to Neo4j nodes. It requires a Neo4j driver, a Weaviate client, an embedder, the Weaviate collection name, and properties to map between Weaviate and Neo4j IDs.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom weaviate.connect.helpers import connect_to_local\nfrom neo4j_graphrag.retrievers import WeaviateNeo4jRetriever\n\nclient = connect_to_local()\nretriever = WeaviateNeo4jRetriever(\n    driver=driver,\n    client=client,\n    embedder=embedder,\n    collection=\"Movies\",\n    id_property_external=\"neo4j_id\",\n    id_property_neo4j=\"id\",\n)\n```\n\n----------------------------------------\n\nTITLE: Dropping a Vector Index in Neo4j - Python\nDESCRIPTION: Provides code to connect to Neo4j and drop a vector index using the `drop_index_if_exists` helper function. This operation is irreversible and permanently removes the index.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j import GraphDatabase\n\nURI = \"neo4j://localhost:7687\"\nAUTH = (\"neo4j\", \"password\")\n\n# Connect to Neo4j database\ndriver = GraphDatabase.driver(URI, auth=AUTH)\ndrop_index_if_exists(driver, INDEX_NAME)\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with Poetry\nDESCRIPTION: This command uses Poetry to install all the necessary dependencies for the project, including the development dependencies. Poetry manages project dependencies in Python projects.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npoetry install --with dev\n```\n\n----------------------------------------\n\nTITLE: Populating Neo4j and Qdrant Databases via Python Script\nDESCRIPTION: Executes a Python script (`examples.customize.retrievers.external.qdrant.populate_dbs`) using the Poetry environment manager. This script is responsible for writing initial data into both the Neo4j graph database and the Qdrant vector database. It should be run from the project's root directory.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/qdrant/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python -m examples.customize.retrievers.external.qdrant.populate_dbs\n```\n\n----------------------------------------\n\nTITLE: Adding an Asynchronous Event Callback to Pipeline (Python)\nDESCRIPTION: Demonstrates how to register an asynchronous callback function with the pipeline during initialization. This function will receive `Event` objects representing various pipeline lifecycle and task progress notifications, allowing for monitoring and logging.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport logging\n\nfrom neo4j_graphrag.experimental.pipeline import Pipeline\nfrom neo4j_graphrag.experimental.pipeline.types import Event\n\nlogger = logging.getLogger(__name__)\nlogging.basicConfig()\nlogger.setLevel(logging.WARNING)\n\n\nasync def event_handler(event: Event) -> None:\n    \"\"\"Function can do anything about the event,\n    here we're just logging it if it's a pipeline-level event.\n    \"\"\"\n    if event.event_type.is_pipeline_event:\n        logger.warning(event)\n\npipeline = Pipeline(\n    callback=event_handler,\n)\n# ... add components, connect them as usual\n\nawait pipeline.run(...)\n```\n\n----------------------------------------\n\nTITLE: Sending Progress Events from a Component (Python)\nDESCRIPTION: Shows how a custom component can emit granular progress events (`TASK_PROGRESS`) during its execution. This is achieved by implementing the `run_with_context` method and using the `notify` function provided by the `RunContext` object.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.pipeline import Component, DataModel\nfrom neo4j_graphrag.experimental.pipeline.types.context import RunContext\n\nclass IntResultModel(DataModel):\n    result: int\n\nclass ComponentAdd(Component):\n    async def run_with_context(self, context_: RunContext, number1: int, number2: int = 1) -> IntResultModel:\n        for fake_iteration in range(10):\n            await context_.notify(\n                message=f\"Starting iteration {fake_iteration} out of 10\",\n                data={\"iteration\": fake_iteration, \"total\": 10}\n            )\n        return IntResultModel(result = number1 + number2)\n```\n\n----------------------------------------\n\nTITLE: Using Anthropic LLM with GraphRAG in Python\nDESCRIPTION: This snippet demonstrates how to use the Anthropic LLM with the `neo4j-graphrag` package. It instantiates the `AnthropicLLM` class, specifying the model name, parameters (including `max_tokens`), and API key (or using the `ANTHROPIC_API_KEY` environment variable). The snippet then invokes the LLM with a simple query. It requires the `neo4j_graphrag` and `anthropic` Python packages.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_rag.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.llm import AnthropicLLM\n\nllm = AnthropicLLM(\n    model_name=\"claude-3-opus-20240229\",\n    model_params={\"max_tokens\": 1000},  # max_tokens must be specified\n    api_key=api_key,  # can also set `ANTHROPIC_API_KEY` in env vars\n)\nllm.invoke(\"say something\")\n```\n\n----------------------------------------\n\nTITLE: Starting Neo4j and Weaviate Services with Docker Compose\nDESCRIPTION: Command to spin up Neo4j and Weaviate containers using Docker Compose. The configuration includes Weaviate with Hugging Face's Sentence Transformers using the 'all-MiniLM-L6-v2' model (384 dimensions).\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/weaviate/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose -f tests/e2e/docker-compose.yml up\n```\n\n----------------------------------------\n\nTITLE: Visualizing a Pipeline (Python)\nDESCRIPTION: Shows how to generate a visual representation of the pipeline structure using the `draw` method. This creates an image file (e.g., PNG) illustrating the components and their connections.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom neo4j_graphrag.experimental.pipeline import Pipeline\n\npipe = Pipeline()\n# ... define components and connections\n\npipe.draw(\"pipeline.png\")\n```\n\n----------------------------------------\n\nTITLE: Illustrating Ignored User Inputs in Pipeline Connection (Python)\nDESCRIPTION: Highlights a limitation where `input_config` specified in the `connect` method overrides user-provided inputs for the same parameter in the `pipeline.run` call. The example shows how a value set via `connect` takes precedence.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npipe.connect(\"a\", \"b\", input_config={\"number2\": \"a.result\"})\nasyncio.run(pipe.run({\"a\": {\"number1\": 10, \"number2\": 1}, \"b\": {\"number1\": 4, \"number2\": 42}}))\n```\n\n----------------------------------------\n\nTITLE: Running Text-Based Search Retriever with Local Embeddings in Python\nDESCRIPTION: This snippet runs a text search retriever example with embeddings generated locally instead of relying on remote services. It requires prior setup of environment variables `NEO4J_AUTH`, `NEO4J_URL`, and `PC_API_KEY` to authenticate and connect to the Neo4j and Pinecone databases. The command executes a Python module that fetches relevant data by converting text queries into embeddings and searching the Pinecone vector database.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/pinecone/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python -m examples.customize.retrievers.external.pinecone.text_search\n```\n\n----------------------------------------\n\nTITLE: Using LangChainTextSplitterAdapter\nDESCRIPTION: This Python code demonstrates how to use the `LangChainTextSplitterAdapter` to integrate a LangChain text splitter into the `neo4j-graphrag` pipeline.  It instantiates a `CharacterTextSplitter` from LangChain and then wraps it with the adapter. The `run` method is then called to split the text.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom langchain_text_splitters import CharacterTextSplitter\nfrom neo4j_graphrag.experimental.components.text_splitters.langchain import LangChainTextSplitterAdapter\nsplitter = LangChainTextSplitterAdapter(\n    CharacterTextSplitter(chunk_size=4000, chunk_overlap=200, separator=\".\")\n)\nawait splitter.run(text=\"Hello World. Life is beautiful.\")\n```\n\n----------------------------------------\n\nTITLE: Using the PdfLoader Component\nDESCRIPTION: This Python code demonstrates how to use the `PdfLoader` component to load and extract text from a PDF file. It imports the necessary modules, instantiates the `PdfLoader`, and then calls the `run` method with the path to the PDF. The result will be the extracted text from the PDF.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nfrom neo4j_graphrag.experimental.components.pdf_loader import PdfLoader\n\nloader = PdfLoader()\nawait loader.run(path=Path(\"my_file.pdf\"))\n```\n\n----------------------------------------\n\nTITLE: Querying Data from Neo4j with Python\nDESCRIPTION: This snippet shows how to query nodes and relationships from Neo4j using Cypher within Python scripts. It performs a match operation to retrieve all persons and their connections, processing the results for display or further use.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/tests/e2e/data/documents/harry_potter_part2.txt#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nwith driver.session() as session:\n    result = session.run(\"MATCH (a:Person)-[:KNOWS]->(b) RETURN a.name, b.name\")\n    for record in result:\n        print(f\"{record['a.name']} knows {record['b.name']}\")\n\n```\n\n----------------------------------------\n\nTITLE: Configuring an LLM (OpenAI) in YAML Configuration\nDESCRIPTION: Shows the YAML equivalent for configuring an OpenAI LLM. It includes specifying the class (`class_`), parameters (`params_`) like the model name, resolving the API key from an environment variable, and defining model-specific settings.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_16\n\nLANGUAGE: YAML\nCODE:\n```\nllm_config:\n  class_: OpenAILLM\n  params_:\n    model_name: gpt-4o\n    api_key:\n      resolver_: ENV\n      var_: OPENAI_API_KEY\n    model_params:\n      temperature: 0\n      max_tokens: 2000\n      response_format:\n        type: json_object\n```\n\n----------------------------------------\n\nTITLE: Running a Component Individually (PdfLoader)\nDESCRIPTION: This Python code demonstrates how to run a component, specifically the `PdfLoader`, individually. It imports the necessary modules, instantiates the component, and then uses `asyncio.run` to execute the `run` method with the path to a PDF file. This shows how to process data outside of a larger pipeline context.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom neo4j_graphrag.experimental.components.pdf_loader import PdfLoader\nmy_component = PdfLoader()\nasyncio.run(my_component.run(\"my_file.pdf\"))\n```\n\n----------------------------------------\n\nTITLE: Building Sphinx Documentation with Make in Neo4j GraphRAG Python Project\nDESCRIPTION: Command for building the HTML documentation using the Makefile in the docs directory. This command must be run from the root directory of the project after making changes to the .rst source files.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmake -C docs html\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Pytest and Poetry\nDESCRIPTION: This command runs the unit tests located in the tests/unit directory using pytest, managed through Poetry. It executes the tests within the Poetry environment.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\npoetry run pytest tests/unit\n```\n\n----------------------------------------\n\nTITLE: Performing Vector and Text Searches using Python Scripts\nDESCRIPTION: Provides commands to run Python search scripts via Poetry. The `vector_search` script likely performs searches using pre-computed vectors, while the `text_search` script takes text input, generates embeddings locally, and then executes the search against the Qdrant database.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/qdrant/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# search by vector\npoetry run python -m examples.customize.retrievers.external.qdrant.vector_search\n```\n\nLANGUAGE: bash\nCODE:\n```\n# search by text, with embeddings generated locally\npoetry run python -m examples.customize.retrievers.external.qdrant.text_search\n```\n\n----------------------------------------\n\nTITLE: Creating Nodes and Relationships in Neo4j with Python\nDESCRIPTION: This snippet illustrates how to add nodes and relationships to a Neo4j database using Cypher queries within Python. It defines functions to create a person node and a relationship between two nodes, requiring an active driver session for execution.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/tests/e2e/data/documents/harry_potter_part2.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef create_person(tx, name):\n    tx.run(\"CREATE (a:Person {name: $name})\", name=name)\n\ndef create_relationship(tx, name1, name2):\n    tx.run(\"MATCH (a:Person {name: $name1}), (b:Person {name: $name2}) CREATE (a)-[:KNOWS]->(b)\", name1=name1, name2=name2)\n\nwith driver.session() as session:\n    session.write_transaction(create_person, \"Harry\")\n    session.write_transaction(create_person, \"Ron\")\n    session.write_transaction(create_relationship, \"Harry\", \"Ron\")\n\n```\n\n----------------------------------------\n\nTITLE: Setting OpenAI API Key\nDESCRIPTION: This Python code snippet demonstrates how to set the OpenAI API key as an environment variable. This is a prerequisite for using the `OpenAIEmbeddings` or other OpenAI-based components. The `os.environ` dictionary is used to set the environment variable.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nimport os\nos.environ[\"OPENAI_API_KEY\"] = \"sk-...\"\n```\n\n----------------------------------------\n\nTITLE: Executing a Cypher Query with Neo4j Python Driver\nDESCRIPTION: This code executes a Cypher query using an active Neo4j Python driver session. It demonstrates how to run queries for retrieving or manipulating graph data, wrapping execution inside a session context. Dependencies include the neo4j library, with inputs such as Cypher query strings and parameters. The output is the query result or processed data.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/tests/e2e/data/documents/harry_potter_part1.txt#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nwith driver.session() as session:\n    result = session.run(\"MATCH (n) RETURN n LIMIT 10\")\n    for record in result:\n        print(record)\n```\n\n----------------------------------------\n\nTITLE: Configuring Neo4j Driver in YAML Configuration\nDESCRIPTION: Shows the YAML syntax for defining Neo4j connection details (URI, user, password) within the `neo4j_config` section, nested under the `params_` key.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_12\n\nLANGUAGE: YAML\nCODE:\n```\nneo4j_config:\n    params_:\n        uri: bolt://\n        user: neo4j\n        password: password\n```\n\n----------------------------------------\n\nTITLE: Installing Neo4j GraphRAG Base Package (Shell)\nDESCRIPTION: Command to install the core Neo4j GraphRAG Python package using pip. This is the fundamental installation step required to begin using the library's basic features.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install neo4j-graphrag\n```\n\n----------------------------------------\n\nTITLE: Using Environment Variables for Parameters in JSON Configuration\nDESCRIPTION: Demonstrates the parameter resolution mechanism in JSON configuration to securely fetch sensitive values like passwords from environment variables. It uses the mandatory `resolver_` key set to `ENV` and the `var_` key specifying the environment variable name.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_13\n\nLANGUAGE: JSON\nCODE:\n```\n{\n    \"neo4j_config\": {\n        \"params_\": {\n            \"uri\": \"bolt://...\",\n            \"user\": \"neo4j\",\n            \"password\": {\n                \"resolver_\": \"ENV\",\n                \"var_\": \"NEO4J_PASSWORD\"\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up pre-commit hooks\nDESCRIPTION: This command sets up pre-commit hooks in the local repository. Pre-commit hooks are scripts that run automatically before each commit to ensure code quality.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Basic SimpleKGPipeline Configuration File (YAML)\nDESCRIPTION: Provides the YAML equivalent of the minimal configuration file structure for a `SimpleKGPipeline`. It includes `version_`, `template_`, and placeholders for Neo4j, LLM, and embedder configurations.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_10\n\nLANGUAGE: YAML\nCODE:\n```\nversion_: 1\ntemplate_: SimpleKGPipeline\nneo4j_config:\nllm_config:\nembedder_config:\n```\n\n----------------------------------------\n\nTITLE: Running E2E Tests with Pytest and Poetry\nDESCRIPTION: This command runs the end-to-end (e2e) tests located in the tests/e2e directory using pytest, managed through Poetry. This command assumes that the necessary services are already running (e.g., via Docker Compose).\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npoetry run pytest tests/e2e\n```\n\n----------------------------------------\n\nTITLE: Starting Neo4j and Qdrant Services with Docker Compose\nDESCRIPTION: Uses Docker Compose to start Neo4j and Qdrant containers defined in the specified configuration file (`tests/e2e/docker-compose.yml`). This command initiates the necessary background services required for subsequent data population and search operations.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/qdrant/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose -f tests/e2e/docker-compose.yml up\n```\n\n----------------------------------------\n\nTITLE: Installing Weaviate Client\nDESCRIPTION: Command to install the Weaviate client Python package, which is required for interacting with the Weaviate vector database in the retriever examples.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/weaviate/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install weaviate-client\n```\n\n----------------------------------------\n\nTITLE: Starting Docker Compose for E2E Tests\nDESCRIPTION: This command starts the services defined in the docker-compose.yml file located in the tests/e2e directory. It is used to set up the environment required for running end-to-end tests, including Neo4j and Weaviate.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose -f tests/e2e/docker-compose.yml up\n```\n\n----------------------------------------\n\nTITLE: Installing All Extra Packages with Poetry\nDESCRIPTION: This command installs all extra packages defined in the project's pyproject.toml file using Poetry. This includes packages needed for specific functionalities, such as testing.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\npoetry install --all-extras\n```\n\n----------------------------------------\n\nTITLE: Initializing Neo4j Driver in Python\nDESCRIPTION: This snippet demonstrates how to establish a connection to a Neo4j database using the Python driver. It requires the neo4j Python package and sets up a driver instance with URI, username, and password for subsequent database operations.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/tests/e2e/data/documents/harry_potter_part2.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom neo4j import GraphDatabase\n\n# Create a driver instance\nuri = \"bolt://localhost:7687\"\nusername = \"neo4j\"\npassword = \"password\"\ndriver = GraphDatabase.driver(uri, auth=(username, password))\n\n# Use the driver to perform database operations\nwith driver.session() as session:\n    result = session.run(\"MATCH (n) RETURN n LIMIT 10\")\n    for record in result:\n        print(record)\n\n```\n\n----------------------------------------\n\nTITLE: Installing dependencies using Poetry for Neo4j GraphRAG Python development\nDESCRIPTION: Command to install project dependencies using Poetry, which is the required dependency management tool for this project. This needs to be run after installing Python 3.9+ and Poetry.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npoetry install\n```\n\n----------------------------------------\n\nTITLE: Installing Pinecone Client Python Package\nDESCRIPTION: This snippet covers the installation of the Pinecone client library via pip, which is a required dependency for interacting with the Pinecone vector database from Python code. Installation must be done before running any retrieval or database population scripts that depend on Pinecone services.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/pinecone/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install pinecone-client\n```\n\n----------------------------------------\n\nTITLE: Setting up pre-commit hooks for Neo4j GraphRAG Python development\nDESCRIPTION: Command to install the pre-commit hook that automatically performs code-format-checking on each commit, ensuring consistent code quality across contributions.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Installing the Qdrant Python Client\nDESCRIPTION: Installs the `qdrant-client` Python package using pip. This library is required for Python applications to interact with the Qdrant vector database API, enabling operations like data insertion and searching.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/qdrant/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install qdrant-client\n```\n\n----------------------------------------\n\nTITLE: Configuring Embedder with JSON\nDESCRIPTION: This JSON snippet demonstrates how to configure an embedder using a configuration file.  It sets up an OpenAIEmbeddings embedder, specifying the embedding model and providing an API key via an environment variable. The `resolver_` and `var_` keys define how to retrieve the API key from the environment.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"embedder_config\": {\n        \"class_\": \"OpenAIEmbeddings\",\n        \"params_\": {\n            \"mode\": \"text-embedding-ada-002\",\n            \"api_key\": {\n                \"resolver_\": \"ENV\",\n                \"var_\": \"OPENAI_API_KEY\",\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Changelog Suggestion using CodiumAI\nDESCRIPTION: This command is a special comment intended for the CodiumAI-Agent. When added to a pull request, it triggers the AI agent to generate a changelog suggestion based on the changes made in the PR.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n@CodiumAI-Agent /update_changelog\n```\n\n----------------------------------------\n\nTITLE: Manually checking file quality with pre-commit\nDESCRIPTION: This command manually checks if a specific file meets the quality requirements defined in the pre-commit configuration. It runs the configured hooks against the specified file.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/README.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npre-commit run --file path/to/file\n```\n\n----------------------------------------\n\nTITLE: Visualizing a Pipeline with All Outputs Shown (Python)\nDESCRIPTION: Explains how to customize the pipeline visualization to include all output fields, even those not connected to downstream components, by setting the `hide_unused_outputs` parameter to `False` in the `draw` method.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npipe.draw(\"pipeline.png\", hide_unused_outputs=False)\n```\n\n----------------------------------------\n\nTITLE: Populating Neo4j and Weaviate Databases\nDESCRIPTION: Command to run a Python script that writes data to both Neo4j and Weaviate databases. This needs to be executed once from the project root to initialize the data.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/weaviate/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python -m tests/e2e/weaviate_e2e/populate_dbs.py\n```\n\n----------------------------------------\n\nTITLE: Reading Chunks with Neo4jChunkReader in Python\nDESCRIPTION: Demonstrates the basic usage of the Neo4jChunkReader component to read text chunks from a Neo4j database. This component requires a Neo4j database driver instance.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nimport neo4j\nfrom neo4j_graphrag.experimental.components.neo4j_reader import Neo4jChunkReader\nfrom neo4j_graphrag.experimental.components.types import LexicalGraphConfig\n\nreader = Neo4jChunkReader(driver)\nresult = await reader.run()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Knowledge Graph Writer in Python\nDESCRIPTION: Shows the starting structure for implementing a custom knowledge graph writer by subclassing the KGWriter interface. This allows defining alternative methods for saving graph data beyond the default Neo4j implementation.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_kg_builder.rst#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom pydantic import validate_call\n```\n\n----------------------------------------\n\nTITLE: Running Test Data Population Script for Neo4j and Pinecone in Python\nDESCRIPTION: This snippet demonstrates the command used to populate test data into both Neo4j and Pinecone databases by executing a Python script with Poetry. Users must update the environment variables `NEO4J_AUTH`, `NEO4J_URL`, and `PC_API_KEY` in the script `tests/e2e/pinecone_e2e/populate_dbs.py` before running. This setup is necessary for enabling retriever functionality tests on a prepared dataset.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/pinecone/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npoetry run python -m tests/e2e/pinecone_e2e/populate_dbs.py\n```\n\n----------------------------------------\n\nTITLE: Running Vector and Text Search Examples\nDESCRIPTION: Commands to run three different search examples: direct vector search, text search using locally generated embeddings, and text search using embeddings generated on the Weaviate server.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/examples/customize/retrievers/external/weaviate/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# search by vector\npoetry run python -m examples.customize.retrievers.external.weaviate.vector_search\n\n# search by text, with embeddings generated locally (via embedder argument)\npoetry run python -m examples.customize.retrievers.external.weaviate.text_search_local_embedder\n\n# search by text, with embeddings generated on the Weaviate side, via configured vectorizer\npoetry run python -m examples.customize.retrievers.external.weaviate.text_search_remote_embedder\n```\n\n----------------------------------------\n\nTITLE: Data Flow Illustration (Text)\nDESCRIPTION: A text-based diagram visualizing the flow of data through the simple two-component pipeline example. It shows how inputs are processed by Component 'a', its output becomes an input for Component 'b', and the final result is produced.\nSOURCE: https://github.com/neo4j/neo4j-graphrag-python/blob/main/docs/source/user_guide_pipeline.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n10 ---\\\n            Component \"a\" -> 11\n    1 ----/                   \\\n                               \\\n                                 Component \"b\" -> 15\n    4 -------------------------/\n```"
  }
]