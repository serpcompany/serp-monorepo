[
  {
    "owner": "solana-developers",
    "repo": "solana-cookbook",
    "content": "TITLE: Sending SOL using SystemProgram.transfer in TypeScript\nDESCRIPTION: This snippet demonstrates how to create and send a basic transaction to transfer native SOL from one account to another on the Solana network. It utilizes the `SystemProgram.transfer` instruction, requiring the sender's Keypair (`fromKeypair`), the recipient's public key (`toKeypair`), and the amount of lamports to send (`lamportsToSend`). The transaction is then sent and confirmed using `sendAndConfirmTransaction`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/basic-transactions.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst transferTransaction = new Transaction().add(\n  SystemProgram.transfer({\n    fromPubkey: fromKeypair.publicKey,\n    toPubkey: toKeypair.publicKey,\n    lamports: lamportsToSend,\n  })\n);\n\nawait sendAndConfirmTransaction(connection, transferTransaction, [fromKeypair]);\n```\n```\n\n----------------------------------------\n\nTITLE: Cross Program Token Transfer (SPL Token Program CPI) in Solana (Rust)\nDESCRIPTION: Rust Solana program example demonstrating a cross-program invocation (CPI) to the SPL Token program's transfer instruction. Requires source/destination token accounts, source holder's wallet, and token_program account. Inputs are accounts and transferred amount, output is SPL token balance changes. Depends on spl-token and anchor or solana_program for CPI support.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/programs/cpi-transfer/program/src/lib.rs)\n```\n\n----------------------------------------\n\nTITLE: Sending SOL | Solana SystemProgram | TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to send SOL using Solana's SystemProgram from the solana/web3.js library. It constructs a transaction with a transfer instruction, signs it with the sender's keypair, and sends the transaction over an RPC connection. Dependencies include solana/web3.js and a valid connection and keypair. Inputs include the sender and receiver public keys and amount in lamports, returning a transaction signature upon success.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Sending SOL | Solana SystemProgram | Python\nDESCRIPTION: This Python code illustrates SOL transfer on the Solana blockchain utilizing the solana-py SDK. It forms, signs, and sends a transfer transaction using the SystemProgram API. Prerequisites are solana-py installed and access to sender and receiver keypairs. The snippet returns the transaction signature if successful.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Declaring SPL-Token Dependency - TypeScript\nDESCRIPTION: Declares the necessary SPL-Token package as a dependency for TypeScript-based Solana projects. The package is essential for all SPL-Token operations demonstrated in other examples. Add this line to your package.json or install via npm/yarn to proceed with token interactions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/token.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"\\\"@solana/spl-token\\\": \\\"^0.2.0\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Generating a PDA Address in TypeScript\nDESCRIPTION: Demonstrates how to find a Program Derived Address (PDA) and its corresponding bump seed using TypeScript. It uses the `PublicKey.findProgramAddress` function from `@solana/web3.js`, providing the seeds (as Buffers) and the program ID.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/derived-a-pda/find-program-address.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Public Solana Clusters using TypeScript\nDESCRIPTION: Demonstrates how to establish a connection to Solana's public RPC endpoints (mainnet-beta, devnet, testnet) using the `@solana/web3.js` library in TypeScript. This involves creating a `Connection` object with the specific cluster URL.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/local-development/connecting-cluster/connecting-cluster.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Extracting Player Stats from NFT Metadata using Metaplex SDK in JavaScript\nDESCRIPTION: This JavaScript snippet illustrates how to query NFT metadata using the Metaplex SDK to extract and use trait attributes in gameplay logic, such as calculating physical and magical damage. It demonstrates initializing the Metaplex client, fetching all NFTs owned by a keypair, loading metadata for each NFT, and iterating through attributes like Strength and Intelligence to augment player stats. Dependencies include @metaplex-foundation/js and a compatible Solana Web3 environment. Inputs are the wallet/connection context and NFT attributes; outputs are computed damage values displayed via console logs. Note: The snippet uses asynchronous calls within a forEach, which may require adjustment for robust error handling.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/nfts-in-games.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { Metaplex, keypairIdentity } from \"@metaplex-foundation/js\";\n\nJSON.parse(\n  // For example '.config/solana/devnet.json'\n  fs.readFileSync(\"yourKeyPair.json\").toString())\n);\nlet keyPair = Keypair.fromSecretKey(decodedKey);\n\nconst metaplex = Metaplex.make(connection).use(keypairIdentity(keyPair));\nconst nfts = await metaplex.nfts().findAllByOwner({owner: keyPair.publicKey});\n\nconst physicalDamage = 5;\nconst magicalDamage = 5;\n\nnfts.forEach(async nft => {\n  const metaData = await metaplex.nfts().load({metadata: nft});\n\n    metaData.json.attributes.forEach(async attribute => {\n      if (attribute.trait_type == \"Strength\") {\n        physicalDamage += parseInt(attribute.value)\n      }\n      if (attribute.trait_type == \"Int\") {\n        magicalDamage += parseInt(attribute.value)\n      }\n    });\n})\n\nconsole.log(\"Player Physical Damage: \" + physicalDamage)\nconsole.log(\"Player Magical Damage: \" + magicalDamage)\n```\n\n----------------------------------------\n\nTITLE: Sending SPL Tokens using Token.createTransferInstruction in TypeScript\nDESCRIPTION: This snippet shows how to send SPL (Solana Program Library) tokens between token accounts. It uses the `splToken.Token.createTransferInstruction` from the `@solana/spl-token` library. Key parameters include the SPL Token program ID (`splToken.TOKEN_PROGRAM_ID`), source and destination token account addresses, the owner's public key (`fromWallet.publicKey`), and the token amount (1 in this example). The transaction containing this instruction is then signed and sent.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/basic-transactions.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n// Add token transfer instructions to transaction\nconst transaction = new web3.Transaction().add(\n  splToken.Token.createTransferInstruction(\n    splToken.TOKEN_PROGRAM_ID,\n    fromTokenAccount.address,\n    toTokenAccount.address,\n    fromWallet.publicKey,\n    [],\n    1\n  )\n);\n\n// Sign transaction, broadcast, and confirm\nawait web3.sendAndConfirmTransaction(connection, transaction, [fromWallet]);\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a PDA Account - Rust Program\nDESCRIPTION: Provides the Rust program logic for creating a Program Derived Address (PDA) account. It uses `invoke_signed` to call the `system_instruction::create_account`, signing with the program ID and the provided seeds and bump seed. This allows the program to create an account at the derived address.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/create-a-pda/program/src/lib.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/create-a-pda/program/src/lib.preview.rs)\n```\n\n----------------------------------------\n\nTITLE: Finding All NFTs Owned by a Wallet - TypeScript\nDESCRIPTION: This TypeScript code fetches all NFTs associated with a given Solana wallet address, leveraging the Metaplex JS library's findDataByOwner API. The key input is the wallet's public key; the result is a filtered list of NFT objects (i.e., SPL tokens checked for NFT attributes). Prerequisites are a Solana connection and access to the Metaplex JS package.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/get-all-nfts/get-all-nfts.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Sending SPL-Tokens | Solana Token Program | TypeScript\nDESCRIPTION: Demonstrates how to transfer SPL tokens using the @solana/spl-token library in TypeScript. The code retrieves or creates associated token accounts, constructs a transfer instruction, and signs and sends the transaction. Requires @solana/spl-token and solana/web3.js as dependencies. Inputs include payer, sender, receiver, mint address, and amount; outputs a transaction signature.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-spl-token/sending-spl-token.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-spl-token/sending-spl-token.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Mnemonic Phrase using CLI\nDESCRIPTION: Generates a BIP39 mnemonic phrase using the Solana Command Line Interface (CLI). This is a direct way to create a mnemonic for wallet backups.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-mnemonic/from-bip39.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-mnemonic/from-bip39.sh)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Mnemonic Phrase in TypeScript\nDESCRIPTION: Generates a BIP39 mnemonic phrase for creating a Solana wallet backup using TypeScript. This utilizes the `bip39` library.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-mnemonic/from-bip39.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-mnemonic/from-bip39.preview.ts)\n```\n\n----------------------------------------\n\nTITLE: Filtering Solana Program Accounts with memcmp and dataSize (TypeScript/Rust/cURL)\nDESCRIPTION: Demonstrates querying Solana accounts owned by the SPL Token program using `getProgramAccounts`. It applies filters: `dataSize` to match the standard 165-byte token account size, and `memcmp` to match accounts where the owner field (at offset 32) corresponds to a specific wallet address. This efficiently finds all token accounts for a given wallet. Requires Solana JSON-RPC endpoint access and relevant libraries (@solana/web3.js for TS, solana-client for Rust).\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/get-program-accounts.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/get-program-accounts/memcmp/memcmp.en.ts)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/get-program-accounts/memcmp/memcmp.en.rs)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/get-program-accounts/memcmp/memcmp.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Cross Program Token Transfer Client (SPL Token Program CPI) in Solana (TypeScript)\nDESCRIPTION: TypeScript client code for calling a Rust Solana program that CPIs into the SPL token transfer instruction. Responsibilities include preparing correct accounts (source, destination, holder), and using @solana/web3.js and @solana/spl-token for transactions. Output: transaction signature after performing cross-program transfer.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/programs/cpi-transfer/client/main.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Invoking Instructions with `invoke_signed` for PDAs (Solana Rust)\nDESCRIPTION: Illustrates use of `invoke_signed` to call a CPI when a program-derived address (PDA) must sign the invoked instruction. Supplies the instruction, account infos (including a PDA), and the signer seeds used to re-derive the PDA for signature verification. Appropriate for interactions that require the PDA's authority, especially when interacting with SPL tokens or program-owned accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\ninvoke_signed(\\n    &some_instruction,                   // instruction to invoke\\n    &[account_one.clone(), pda.clone()], // accounts required by instruction, where one is a pda required as signer\\n    &[signers_seeds],                    // seeds to derive pda\\n)?;\n```\n\n----------------------------------------\n\nTITLE: Sending SOL | Solana SystemProgram | Rust\nDESCRIPTION: Shows how to send SOL via Rust using Solana's anchor or client SDKs. The code builds a transaction with a SystemProgram transfer instruction, signs with the sender's keypair, and submits via RPC. Assumes proper crate dependencies and a configured RPC client. Returns a transaction signature or error message.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.preview.rs)\n```\n\n----------------------------------------\n\nTITLE: Generating Address for Seeded Account in TypeScript\nDESCRIPTION: Demonstrates how to generate a public key for an account derived from a base public key and a seed string using TypeScript. It utilizes the `PublicKey.createWithSeed` function from `@solana/web3.js`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/generate/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/generate/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Creating an Account with Seed in TypeScript\nDESCRIPTION: Illustrates how to create a Solana account derived from a seed using TypeScript. It involves first generating the derived address with `PublicKey.createWithSeed` and then using the `SystemProgram.createAccountWithSeed` instruction in a transaction, signed by the base keypair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/creation/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/creation/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Airdropping SOL Using Solana Python SDK\nDESCRIPTION: This Python code example shows how to perform a test SOL airdrop using the Solana Python SDK ('solana-py'). It requires installing the 'solana' package and initializing a client to connect to a Solana RPC node. The snippet accepts a wallet's public key and airdrop amount as parameters, and submits an airdrop request, returning the resulting signature or error. Useful for scripting and automating local Solana development funding tasks.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Mnemonic Phrase in Python\nDESCRIPTION: Creates a BIP39 mnemonic phrase suitable for Solana wallet backups using Python. Requires a compatible BIP39 library.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-mnemonic/from-bip39.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-mnemonic/from-bip39.preview.py)\n```\n\n----------------------------------------\n\nTITLE: Creating a System Account in Rust\nDESCRIPTION: Shows the Rust implementation for creating a new Solana account owned by the System Program within a Solana program. It utilizes the `system_instruction::create_account` function and typically involves `invoke_signed` if the account creation is initiated by a PDA or `invoke` if initiated by an externally owned account.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/create-system-account/create-system-account.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/create-system-account/create-system-account.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Creating a Solana Stake Account in TypeScript\nDESCRIPTION: Demonstrates how to create a transaction to initialize a new stake account using `StakeProgram.createAccount`. It sets the stake and withdrawal authorities to the provided wallet's public key, specifies the amount of SOL (in lamports) to fund the account, and optionally configures a lockup period (set to zero here). The transaction is then sent and confirmed, requiring signatures from both the payer wallet and the new stake account Keypair. Finally, it checks the balance and activation status of the newly created stake account.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/staking.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// Setup a transaction to create our stake account\n// Note: `StakeProgram.createAccount` returns a `Transaction` preconfigured with the necessary `TransactionInstruction`s\nconst createStakeAccountTx = StakeProgram.createAccount({\n  authorized: new Authorized(wallet.publicKey, wallet.publicKey), // Here we set two authorities: Stake Authority and Withdrawal Authority. Both are set to our wallet.\n  fromPubkey: wallet.publicKey,\n  lamports: amountToStake,\n  lockup: new Lockup(0, 0, wallet.publicKey), // Optional. We'll set this to 0 for demonstration purposes.\n  stakePubkey: stakeAccount.publicKey,\n});\n\nconst createStakeAccountTxId = await sendAndConfirmTransaction(\n  connection,\n  createStakeAccountTx,\n  [\n    wallet,\n    stakeAccount, // Since we're creating a new stake account, we have that account sign as well\n  ]\n);\nconsole.log(`Stake account created. Tx Id: ${createStakeAccountTxId}`);\n\n// Check our newly created stake account balance. This should be 0.5 SOL.\nlet stakeBalance = await connection.getBalance(stakeAccount.publicKey);\nconsole.log(`Stake account balance: ${stakeBalance / LAMPORTS_PER_SOL} SOL`);\n\n// Verify the status of our stake account. This will start as inactive and will take some time to activate.\nlet stakeStatus = await connection.getStakeActivation(stakeAccount.publicKey);\nconsole.log(`Stake account status: ${stakeStatus.state}`);\n```\n\n----------------------------------------\n\nTITLE: Adding a Memo to a Solana Transaction in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a memo (arbitrary string data) to a Solana transaction using the Memo program (`MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr`). It creates a `TransactionInstruction` manually, specifying the Memo program's PublicKey, the signer's key, and the memo data encoded as a UTF-8 buffer. This instruction is added to an existing transaction (e.g., a SOL transfer).\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/basic-transactions.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst transferTransaction = new Transaction().add(\n  SystemProgram.transfer({\n    fromPubkey: fromKeypair.publicKey,\n    toPubkey: toKeypair.publicKey,\n    lamports: lamportsToSend,\n  })\n);\n\nawait transferTransaction.add(\n  new TransactionInstruction({\n    keys: [{ pubkey: fromKeypair.publicKey, isSigner: true, isWritable: true }],\n    data: Buffer.from(\"Data to send in transaction\", \"utf-8\"),\n    programId: new PublicKey(\"MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr\"),\n  })\n);\n\nawait sendAndConfirmTransaction(connection, transferTransaction, [fromKeypair]);\n```\n```\n\n----------------------------------------\n\nTITLE: Retrieving NFT Mint Addresses from Candy Machine V2 - TypeScript\nDESCRIPTION: This snippet details how to obtain all NFT mint addresses from a Candy Machine v2 by first deriving the \"Candy Machine Creator\" PDA, then applying the same querying logic as v1. It requires the Candy Machine v2 address and Metaplex JS SDK. Input is the Candy Machine v2 address, and output is a list of mints. Proper handling of PDA derivation is essential for accurate results.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/nfts-mint-addresses/mint-addresses-v2.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Deriving PDA-Based Account Maps with Anchor (Rust)\nDESCRIPTION: Demonstrates how to use PDAs in Anchor-based Solana programs for mapping users to blog accounts (1:1) and blogs to posts (1:N) by deriving PDA addresses using seeds. This snippet depends on the Anchor framework and uses user authorities as seeds for blog PDAs and blog addresses with unique identifiers (slugs) for post PDAs. It is intended to be deployed as part of an on-chain Solana Anchor program. Inputs include user's public key and unique post identifiers; outputs are derived PDA accounts for blogs and posts. Requires understanding of Anchor and Solana PDA conventions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/account-maps.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/account-maps/deriving-pda/anchor-pda-map.rs)\n```\n\n----------------------------------------\n\nTITLE: Minting Token Reward and Reducing Player Health - Anchor Rust\nDESCRIPTION: Implements the kill_enemy instruction, which decreases the player's health by 10 and rewards 1 token to the player's token account using a CPI to the Token program's mint_to function. Inputs require several accounts, including PDA-based and associated token accounts, and throws NotEnoughHealth error if player's health is zero. Dependencies include Anchor, Token, and AssociatedToken programs. Outputs are account mutations or error, with limitations around account constraints, proper bump seed use, and handling of actual mint decimals.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod anchor_token {\n    use super::*;\n    ...\n\n    // Mint token to player token account\n    pub fn kill_enemy(ctx: Context<KillEnemy>) -> Result<()> {\n        // Check if player has enough health\n        if ctx.accounts.player_data.health == 0 {\n            return err!(ErrorCode::NotEnoughHealth);\n        }\n        // Subtract 10 health from player\n        ctx.accounts.player_data.health = ctx.accounts.player_data.health.checked_sub(10).unwrap();\n\n        // PDA seeds and bump to \"sign\" for CPI\n        let seeds = b\"reward\";\n        let bump = *ctx.bumps.get(\"reward_token_mint\").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            MintTo {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                to: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.reward_token_mint.to_account_info(),\n            },\n            signer,\n        );\n\n        // Mint 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        mint_to(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n...\n\n#[derive(Accounts)]\npub struct KillEnemy<'info> {\n    #[account(mut)]\n    pub player: Signer<'info>,\n\n    #[account(\n        mut,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n\n    // Initialize player token account if it doesn't exist\n    #[account(\n        init_if_needed,\n        payer = player,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b\"reward\"],\n        bump,\n    )]\n    pub reward_token_mint: Account<'info, Mint>,\n\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n    pub system_program: Program<'info, System>,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Not enough health\")]\n    NotEnoughHealth,\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving NFT Mint Addresses from Candy Machine V1 - TypeScript\nDESCRIPTION: This snippet demonstrates how to query all NFT mint addresses generated from a Candy Machine v1 instance on Solana. It uses a memcmp filter based on the creator's address and leverages Metaplex/JS clients. Input is the public key of the Candy Machine, output is an array of mint addresses. This is limited to v1 Candy Machines wherein the first creator field is predictable.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/nfts-mint-addresses/mint-addresses.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Account State (v0) in Rust\nDESCRIPTION: Defines the initial Rust structure (`AccountContentCurrent`) for a Solana program account (v0). It includes a data version field (`data_version`), allocates extra space (`ACCOUNT_SPACE`) for future growth using padding, and initializes constants. This structure is prepared for future data migrations.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/zh/guides/data-migration.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v0.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v0.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Storing a Map in a Single BTreeMap Account (Rust)\nDESCRIPTION: Demonstrates storing an explicit key-value map using Rust's BTreeMap within a single Solana account, where the account can be created as a PDA or from a Keypair. The snippet outlines initialization, data serialization, and insert/update patterns. Inputs include the data to be mapped and account initialization parameters. Outputs involve updating the internal BTreeMap state. Limitations include the Solana account data size cap (10MB) and the requirement to track and initialize the mapping account. It demonstrates custom mapping logic without relying on derived addresses for each mapping.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/account-maps.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/account-maps/trivial/vanilla-trivial-map.rs)\n```\n\n----------------------------------------\n\nTITLE: Invoking Instructions with `invoke` Function (Solana Rust)\nDESCRIPTION: Demonstrates a practical invocation of the `invoke` function to perform a CPI when no PDAs are required as signers. Takes a reference to an instruction, and a list of account clones required by that instruction, returning a result. The `invoke` call must match accounts expected by the target program and propagates any errors encountered during execution.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ninvoke(\\n    &some_instruction,                           // instruction to invoke\\n    &[account_one.clone(), account_two.clone()], // accounts required by instruction\\n)?;\n```\n\n----------------------------------------\n\nTITLE: Calculating Total Staked Amount for a Wallet in TypeScript\nDESCRIPTION: Shows how to calculate the total amount of SOL staked by a specific wallet across potentially multiple stake accounts. This involves fetching all associated stake accounts using `getProgramAccounts` and summing their balances.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/get-stake-amount/get-stake-amount.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Updated Data Structures for Account Migration in Rust\nDESCRIPTION: Shows updated Rust structs designed for migrating Solana program data. The current structure `AccountContentCurrent` now includes a new field `somestring`. The previous structure is preserved as `AccountContentOld`. The main `ProgramAccountState` structure holds the current data version and the `AccountContentCurrent` data. This setup allows the program to deserialize older data using `AccountContentOld` and then convert it to the `AccountContentCurrent` format.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/guides/data-migration.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n```rs\n/// Current state (DATA_VERSION 1). If version changes occur, this\n/// should be copied to another (see AccountContentOld below)\n/// We've added a new field: 'somestring'\n#[derive(BorshDeserialize, BorshSerialize, Debug, Default, PartialEq)]\npub struct AccountContentCurrent {\n    pub somevalue: u64,\n    pub somestring: String,\n}\n\n/// Old content state (DATA_VERSION 0).\n#[derive(BorshDeserialize, BorshSerialize, Debug, Default, PartialEq)]\npub struct AccountContentOld {\n    pub somevalue: u64,\n}\n\n/// Maintains account data\n#[derive(BorshDeserialize, BorshSerialize, Debug, Default, PartialEq)]\npub struct ProgramAccountState {\n    is_initialized: bool,\n    data_version: u8,\n    account_data: AccountContentCurrent,\n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Generating Address for Seeded Account in Rust\nDESCRIPTION: Shows how to generate a public key for an account derived from a base public key and a seed string in Rust. It uses the `Pubkey::create_with_seed` function, requiring the base key, seed string, and owner program ID.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/generate/main.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/generate/main.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Updating Player State in Rust (Anchor Instruction)\nDESCRIPTION: This Rust function `kill_enemy` demonstrates how to modify a player's state stored in the `PlayerData` account within a Solana program instruction using the Anchor framework. It takes context `KillEnemy` (definition not shown but implies mutable access to `PlayerData`) and an `enemyId`. The function checks for sufficient energy, simulates battle logic (partially shown), increments player XP, decrements energy, and logs the results. It requires the `PlayerData` account and potentially an `ErrorCode` enum for error handling.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/saving-game-state.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n    pub fn kill_enemy(mut ctx: Context<KillEnemy>, enemyId: u8) -> Result<()> {\n        let account = &mut ctx.accounts;\n\n        ... handle energy\n\n        if ctx.accounts.player.energy == 0 {\n            return err!(ErrorCode::NotEnoughEnergy);\n        }\n\n        ... get enemy values by id and calculate battle\n\n        ctx.accounts.player.xp = ctx.accounts.player.xp + 1;\n        ctx.accounts.player.energy = ctx.accounts.player.energy - 1;\n\n        ... handle level up\n        \n        msg!(\"You killed enemy and got 1 xp. You have {} xp and {} energy left.\", ctx.accounts.player.xp, ctx.accounts.player.energy);\n        Ok(())\n    }\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Player Account with Anchor - Rust\nDESCRIPTION: Defines the MAX_HEALTH constant, the PlayerData account, and the init_player instruction using the Anchor framework in Rust. This snippet creates and initializes a unique player_data account for each player using a PDA, setting their starting health to 100. Dependencies include Anchor, Solana runtime, and associated macros; inputs are the Context carrying accounts as defined by Anchor, and outputs are the mutation of on-chain state or an error. The instruction requires seed-based constraints to ensure uniqueness and security.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// Player max health\nconst MAX_HEALTH: u8 = 100;\n\n#[program]\npub mod anchor_token {\n    use super::*;\n    ...\n\n    // Create new player account\n    pub fn init_player(ctx: Context<InitPlayer>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n        Ok(())\n    }\n}\n...\n\n#[derive(Accounts)]\npub struct InitPlayer<'info> {\n    #[account(\n        init,\n        payer = player,\n        space = 8 + 8,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct PlayerData {\n    pub health: u8,\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying Compute Budget and Priority Fee in TypeScript\nDESCRIPTION: This snippet illustrates how to customize a transaction's compute unit (CU) limit and add a priority fee using the `ComputeBudgetProgram`. `setComputeUnitLimit` sets the maximum CUs the transaction can consume, overriding the default. `setComputeUnitPrice` adds a fee per CU (in microLamports) on top of the base fee, effectively prioritizing the transaction. These instructions are added to the transaction before other instructions like `SystemProgram.transfer`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/basic-transactions.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({ \n  units: 1000000 \n});\n\nconst addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({ \n  microLamports: 1 \n});\n\nconst transaction = new Transaction()\n.add(modifyComputeUnits)\n.add(addPriorityFee)\n.add(\n    SystemProgram.transfer({\n      fromPubkey: payer.publicKey,\n      toPubkey: toAccount,\n      lamports: 10000000,\n    })\n  );\n```\n```\n\n----------------------------------------\n\nTITLE: Serializing Primitive and Compound Types for Borsh - TypeScript\nDESCRIPTION: Demonstrates how to serialize both primitive (numbers, strings) and compound (arrays, Maps) data types using Borsh schemas in TypeScript. Tailors schema definitions for compatibility with Borsh and ensures output can be deserialized by both on-chain and client Rust code. Requires borsh as a dependency.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/serialization/primitives/demo_primitives.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Minting a Key/Value Pair in Program Account - Rust\nDESCRIPTION: Illustrates operating on an initialized program account by minting a new key/value pair, serializing the update to the BTreeMap using Borsh as required by Solana's account model. Ensures that modifications comply with the byte layout and all updates remain Borsh-compatible.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/program/rust.program.mint.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Upgraded Instruction Set for Migrated Account - Solana Program - Rust\nDESCRIPTION: Expands the initial instruction set to include new operations compatible with the upgraded account, such as updating the new somestring field. Updates instruction enums or structs to accept new parameters for flexible account logic. Dependencies same as previously plus handling for new struct fields. Inputs/outputs extend previous instruction handling.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.instruction1.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Defining Admin Public Key Constraint in Rust\nDESCRIPTION: This Rust code snippet declares a constant `ADMIN_PUBKEY` using the `pubkey!` macro from the `solana_program` crate. This constant is intended to hold the public key of an administrator wallet and is used as an address constraint within Anchor account validation (`#[account(address = ADMIN_PUBKEY)]`) to restrict certain instruction calls, like `create_mint`, to only be invokable by the specified admin.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nconst ADMIN_PUBKEY: Pubkey = pubkey!(\"REPLACE_WITH_YOUR_WALLET_PUBKEY\");\n```\n\n----------------------------------------\n\nTITLE: Deserializing Instruction Data on Solana Program - Rust\nDESCRIPTION: Provides server-side deserialization of incoming instruction data within a Solana Rust program using Borsh. Reads, validates, and unpacks serialized data into defined Rust structs/enums for business logic processing. Relies on borsh-derive for unpacking types; input is a serialized byte slice and output is a native Rust instruction representation.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/instruction/rust.program.instruction.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Serializing Primitive and Compound Types for Borsh - Python\nDESCRIPTION: Presents equivalent serialization logic in Python using borsh-construct to handle primitive and compound types. Carefully creates schema mappings to ensure cross-language deserialization is practical for Solana applications.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/serialization/primitives/python.demo_primitives.py)\n```\n\n----------------------------------------\n\nTITLE: Creating a PDA Account - TypeScript Client\nDESCRIPTION: Shows the TypeScript client-side code for invoking a program instruction that creates a PDA. It first uses `findProgramAddress` to determine the PDA address and bump seed, then constructs a transaction calling the program, passing the necessary accounts (payer, PDA) and the bump seed as instruction data or arguments.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/create-a-pda/client/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/create-a-pda/client/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Calculating Transaction Fee using getFeeForMessage in TypeScript\nDESCRIPTION: This snippet shows an alternative way to estimate transaction fees using the `getFeeForMessage` method on the `Connection` object. This method takes a compiled transaction `Message` as input. It calculates the fee based on the message content and the current network conditions fetched via the connection. The result includes the fee value in lamports.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/basic-transactions.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst message = new Message(messageParams);\n\nconst fees = await connection.getFeeForMessage(message);\nconsole.log(`Estimated SOL transfer cost: ${fees.value} lamports`);\n// Estimated SOL transfer cost: 5000 lamports\n```\n```\n\n----------------------------------------\n\nTITLE: Getting Account Balance using TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to use the `@solana/web3.js` library to fetch the balance of a Solana account. It initializes a connection to the cluster and uses the `getBalance` method with the account's public key to retrieve the balance in Lamports.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Solana Wallet in React (TypeScript)\nDESCRIPTION: Demonstrates how to set up Solana wallet connection in a React application using the `@solana/wallet-adapter-react` and `@solana/wallet-adapter-react-ui` libraries. Uses Context providers (`ConnectionProvider`, `WalletProvider`, `WalletModalProvider`) and hooks (`useWallet`, `useWalletModal`) for state management and UI.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_37\n\nLANGUAGE: tsx\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/connect-to-wallet/connect-to-wallet-react.en.tsx)\n```\n\nLANGUAGE: tsx\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/connect-to-wallet/connect-to-wallet-react.preview.en.tsx)\n```\n\n----------------------------------------\n\nTITLE: Closing an Account - TypeScript Client\nDESCRIPTION: Shows the TypeScript client code for invoking a program instruction designed to close an account. It involves creating a transaction that calls the program, specifying the account to close and the recipient account for the remaining lamports.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/close-account/client/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/close-account/client/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Getting the Clock Sysvar: Passing Clock as an Account in Solana Program (TypeScript Client)\nDESCRIPTION: Shows how a TypeScript Solana client calls a program expecting the clock sysvar by passing the proper public key in the instruction accounts list. Prerequisites include @solana/web3.js and knowledge of the sysvar clock public key. Inputs: state account, SYSVAR_CLOCK_PUBKEY. Output: transaction signature or resulting confirmation.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/programs/get-clock/method-one/client/main.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Implementing Initialize Instruction in Rust (Anchor)\nDESCRIPTION: This snippet implements the `initialize` instruction for the 'Tiny Adventure' game. The `initialize` function within the `#[program]` module sets the `player_position` in the `GameDataAccount` to 0 and logs initial messages. The `Initialize` struct defines the accounts required: the `new_game_data_account` (initialized as a PDA using `init_if_needed`), the `signer` (payer), and the `system_program`. The PDA seed `level1` means only one global game account can be created with this code.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod tiny_adventure {\n    use super::*;\n\n    // Instruction to initialize GameDataAccount and set position to 0\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.new_game_data_account.player_position = 0;\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.......\");\n        Ok(())\n    }\n}\n\n// Specify the accounts required by the initialize instruction\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(\n        init_if_needed,\n        seeds = [b\"level1\"],\n        bump,\n        payer = signer,\n        space = 8 + 1\n    )]\n    pub new_game_data_account: Account<'info, GameDataAccount>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing Pack Trait for Account Data Serialization - Rust\nDESCRIPTION: Shows the implementation of the Pack trait for a custom account structure in a Solana Rust program. Encapsulates packing and unpacking logic, enabling uniform interface for reading and writing serialized account state. Depends on sol-template-shared and Borsh, and handles account initialization and byte layout. Facilitates transparent serialization and integrity checks.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/program/rust.program.packimpl.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from BIP39 Mnemonic in TypeScript\nDESCRIPTION: Restores a single Solana keypair from a BIP39 mnemonic phrase using TypeScript. This method is common for standard wallets and involves converting the mnemonic to a seed and then deriving the keypair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip39.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip39.preview.ts)\n```\n\n----------------------------------------\n\nTITLE: Instruction Usage Preview - Solana Program - Rust\nDESCRIPTION: A sample code or usage example for the initial instruction set, showing how to construct or process instructions for the program. Useful for visualizing how clients interact with instructions for the version 0 account. Inputs depend on instruction enums/structs; outputs are processed instructions or accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.instruction.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Defining Game Data Account Structure in Rust\nDESCRIPTION: This snippet defines the structure for the on-chain account that stores the game state. The `GameDataAccount` struct uses the `#[account]` attribute from Anchor and contains a single field `player_position` (an unsigned 8-bit integer) to track the player's current position.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\nmod tiny_adventure {\n    use super::*;\n\n}\n\n...\n\n// Define the Game Data Account structure\n#[account]\npub struct GameDataAccount {\n    player_position: u8,\n}\n```\n\n----------------------------------------\n\nTITLE: Transferring Lamports in a Solana Program using Rust\nDESCRIPTION: Illustrates how a Rust Solana program can transfer lamports directly from a program-owned account to another account. Requires Solana runtime and the transferring account must be owned by the program. Input accounts should include the source (program-owned) and destination; outputs include updated balances. The recipient does not need to be owned by the program.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/programs/transferring-lamports/transferring-lamports.rs)\n```\n\n----------------------------------------\n\nTITLE: Checking Solana Public Key Validity in Rust\nDESCRIPTION: Provides an example of checking if a Solana public key is on the ed25519 curve using the Rust Solana SDK. The `Pubkey::is_on_curve` method is typically used for this purpose.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.preview.rs)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using CPI Invocation Methods in Solana (Rust)\nDESCRIPTION: This snippet shows the Rust function signatures for `invoke` and `invoke_signed` from the `solana_program` crate, which are used to perform Cross Program Invocations (CPIs) within Solana programs. The first variant (`invoke`) is for standard calls when signers suffice; the second (`invoke_signed`) is for when a PDA is required as a signer, needing seed information for signature derivation. These functions require `Instruction` and a slice of `AccountInfo`, with the `invoke_signed` function also accepting signer seeds. Return type is `ProgramResult`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Used when there are not signatures for PDAs needed\\npub fn invoke(\\n    instruction: &Instruction,\\n    account_infos: &[AccountInfo<'_>]\\n) -> ProgramResult\\n\\n// Used when a program must provide a 'signature' for a PDA, hence the signer_seeds parameter\\npub fn invoke_signed(\\n    instruction: &Instruction,\\n    account_infos: &[AccountInfo<'_>],\\n    signers_seeds: &[&[&[u8]]]\\n) -> ProgramResult\n```\n\n----------------------------------------\n\nTITLE: Creating a Program Derived Address (PDA) - Client Example in Solana (TypeScript)\nDESCRIPTION: TypeScript client code for sending necessary accounts and seeds to a Rust Solana program to create a PDA. Uses @solana/web3.js for key generation, seed derivation, and transaction submission. Input: accounts and PDA seeds. Output: signature of transaction that creates and initializes the PDA.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/programs/create-pda/client/main.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Creating an Account with Seed in Rust\nDESCRIPTION: Provides the Rust code for creating a Solana account derived from a seed within a program. It uses the `system_instruction::create_account_with_seed` instruction, typically invoked via `invoke` or `invoke_signed`, requiring the base account, derived account address, seed, space, lamports, and owner program ID.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/creation/main.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/creation/main.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Calculating Transaction Fee using getEstimatedFee in TypeScript\nDESCRIPTION: This snippet demonstrates estimating the cost of a Solana transaction using the `getEstimatedFee` method available on the `Transaction` object. It first fetches the latest blockhash, creates a sample transaction (a SOL transfer in this case), and then calls `getEstimatedFee` with the connection object to get the estimated fee in lamports. This method requires a fully constructed transaction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/basic-transactions.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nconst recentBlockhash = await connection.getLatestBlockhash();\n\nconst transaction = new Transaction({\n  recentBlockhash: recentBlockhash.blockhash,\n}).add(\n  SystemProgram.transfer({\n    fromPubkey: payer.publicKey,\n    toPubkey: payee.publicKey,\n    lamports: 10,\n  })\n);\n\nconst fees = await transaction.getEstimatedFee(connection);\nconsole.log(`Estimated SOL transfer cost: ${fees} lamports`);\n// Estimated SOL transfer cost: 5000 lamports\n```\n```\n\n----------------------------------------\n\nTITLE: Invoking Move Instructions and Fetching State (Anchor JavaScript/TypeScript)\nDESCRIPTION: This TypeScript snippet exemplifies sending a transaction to invoke the moveRight (or moveLeft) instruction on the Tiny Adventure program, confirming the transaction, fetching the updated game data account, and displaying the player's position. It depends on an initialized Anchor JavaScript client, a valid keypair, and the PDA returned from previous code. The user can adjust which move instruction to send. Inputs include the PDA and keypair; the output includes transaction hashes, confirmed state, and current player position. Useful for integrating simple user controls on the client.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// Here you can play around now, move left and right\ntxHash = await pg.program.methods\n  //.moveLeft()\n  .moveRight()\n  .accounts({\n    gameDataAccount: globalLevel1GameDataAccount,\n  })\n  .signers([pg.wallet.keypair])\n  .rpc();\nconsole.log(`Use 'solana confirm -v ${txHash}' to see the logs`);\nawait pg.connection.confirmTransaction(txHash);\n\ngameDateAccount = await pg.program.account.gameDataAccount.fetch(\n  globalLevel1GameDataAccount\n);\n\nconsole.log(\"Player position is:\", gameDateAccount.playerPosition.toString());\n\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Secret Bytes in Python\nDESCRIPTION: Illustrates restoring a Solana keypair from its secret key (represented as bytes) using the Solana Python library. It takes the byte array and returns the corresponding keypair object.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Creating a Token Mint and Metadata with Anchor in Rust\nDESCRIPTION: This Rust snippet defines the `create_mint` instruction within an Anchor program. It demonstrates how to initialize a new token mint using a PDA derived from the seed \"reward\" as both the mint account address and its authority. The instruction takes URI, name, and symbol as inputs for the token's metadata and uses a CPI to call `create_metadata_accounts_v3` from the Metaplex Token Metadata program. An admin constraint is enforced using the `ADMIN_PUBKEY` constant and the `CreateMint` Accounts struct defines the necessary accounts, including validation and initialization logic.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Only this public key can call this instruction\nconst ADMIN_PUBKEY: Pubkey = pubkey!(\"REPLACE_WITH_YOUR_WALLET_PUBKEY\");\n\n#[program]\npub mod anchor_token {\n    use super::*;\n\n    // Create new token mint with PDA as mint authority\n    pub fn create_mint(\n        ctx: Context<CreateMint>,\n        uri: String,\n        name: String,\n        symbol: String,\n    ) -> Result<()> {\n        // PDA seeds and bump to \"sign\" for CPI\n        let seeds = b\"reward\";\n        let bump = *ctx.bumps.get(\"reward_token_mint\").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // On-chain token metadata for the mint\n        let data_v2 = DataV2 {\n            name: name,\n            symbol: symbol,\n            uri: uri,\n            seller_fee_basis_points: 0,\n            creators: None,\n            collection: None,\n            uses: None,\n        };\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_metadata_program.to_account_info(),\n            CreateMetadataAccountsV3 {\n                metadata: ctx.accounts.metadata_account.to_account_info(), // the metadata account being created\n                mint: ctx.accounts.reward_token_mint.to_account_info(), // the mint account of the metadata account\n                mint_authority: ctx.accounts.reward_token_mint.to_account_info(), // the mint authority of the mint account\n                update_authority: ctx.accounts.reward_token_mint.to_account_info(), // the update authority of the metadata account\n                payer: ctx.accounts.admin.to_account_info(), // the payer for creating the metadata account\n                system_program: ctx.accounts.system_program.to_account_info(), // the system program account\n                rent: ctx.accounts.rent.to_account_info(), // the rent sysvar account\n            },\n            signer,\n        );\n\n        create_metadata_accounts_v3(\n            cpi_ctx, // cpi context\n            data_v2, // token metadata\n            true,    // is_mutable\n            true,    // update_authority_is_signer\n            None,    // collection details\n        )?;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateMint<'info> {\n    #[account(\n        mut,\n        address = ADMIN_PUBKEY\n    )]\n    pub admin: Signer<'info>,\n\n    // The PDA is both the address of the mint account and the mint authority\n    #[account(\n        init,\n        seeds = [b\"reward\"],\n        bump,\n        payer = admin,\n        mint::decimals = 9,\n        mint::authority = reward_token_mint,\n\n    )]\n    pub reward_token_mint: Account<'info, Mint>,\n\n    ///CHECK: Using \"address\" constraint to validate metadata account address\n    #[account(\n        mut,\n        address=find_metadata_account(&reward_token_mint.key()).0\n    )]\n    pub metadata_account: UncheckedAccount<'info>,\n\n    pub token_program: Program<'info, Token>,\n    pub token_metadata_program: Program<'info, Metadata>,\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Solana CLI via Script on macOS/Linux\nDESCRIPTION: Installs the Solana Command Line Interface (CLI) using the official installation script on macOS or Linux. Replace `LATEST_RELEASE` with a specific version tag (e.g., v1.18.4) or a channel name (`stable`, `beta`, `edge`). Requires curl.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsh -c \"$(curl -sSfL https://release.solana.com/LATEST_RELEASE/install)\"\n```\n\n----------------------------------------\n\nTITLE: Signing Transactions Offline with Solana in TypeScript\nDESCRIPTION: This code demonstrates how to sign a Solana transaction offline in TypeScript. It requires the @solana/web3.js library and a prepared transaction object. The function takes a locally constructed transaction, uses a Keypair for signing, and serializes it for later broadcast. Inputs include a transaction and a Keypair; the output is a signed and serialized transaction buffer ready to be sent to the network. The code does not broadcast the transaction, leaving that to a later step.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/offline-transactions.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/sign-transaction/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/sign-transaction/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Account Version 1 Usage Preview - Solana Program - Rust\nDESCRIPTION: Shows an example instantiation or migration scenario for the v1 account with updated fields and conversion logic included, highlighting the new account layout. Focuses on using try_from_slice_unchecked and the new migration utility. Inputs are serialized account data in v0 format; outputs are migrated accounts in the v1 structure.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v1.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Closing an Account - Rust Program\nDESCRIPTION: Illustrates the Rust program logic for closing an account. It involves transferring all lamports from the account to be closed to a specified recipient account. The Solana runtime automatically reclaims the rent-exempt lamports and removes the account data once its balance drops to zero. The account being closed must be mutable and sign the transaction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/close-account/program/src/lib.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/close-account/program/src/lib.preview.rs)\n```\n\n----------------------------------------\n\nTITLE: Initializing Program Account State - Rust\nDESCRIPTION: Demonstrates how to initialize a new program account on-chain, composing the initialization byte layout and leveraging the Pack implementation to serialize the initial, empty or seeded, state. Uses Rust's borsh-derive and ensures account marking and zero-flags. Must only be called on uninitialized accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/program/rust.program.initialize.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Deploying a Solana Program via CLI (Bash)\nDESCRIPTION: This command uses the Solana Command Line Interface (CLI) to deploy a compiled program (an ELF shared object containing BPF bytecode) to the currently configured Solana cluster. The `<PROGRAM_FILEPATH>` placeholder must be replaced with the actual path to the compiled program file. Successful deployment uploads the program to an account marked as `executable`, assigns it to the BPF Loader, and provides a `program_id` for future interactions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/programs.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsolana program deploy <PROGRAM_FILEPATH>\n```\n\n----------------------------------------\n\nTITLE: Burning Token to Restore Player Health - Anchor Rust\nDESCRIPTION: Implements the heal instruction, which burns 1 token from the player's associated token account and restores the player's health to the preset maximum. Uses a CPI to call the Token program's burn instruction, with dependencies on Anchor, Token, and AssociatedToken. Inputs are context with several checked accounts, and outputs are state update on player health and token balances. Limitations involve proper PDA handling, token decimal calculation, and account initializations.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod anchor_token {\n    use super::*;\n    ...\n\n    // Burn token to health player\n    pub fn heal(ctx: Context<Heal>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.token_program.to_account_info(),\n            Burn {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                from: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.player.to_account_info(),\n            },\n        );\n\n        // Burn 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        burn(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n...\n\n#[derive(Accounts)]\npub struct Heal<'info> {\n    #[account(mut)]\n    pub player: Signer<'info>,\n\n    #[account(\n        mut,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n\n    #[account(\n        mut,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b\"reward\"],\n        bump,\n    )]\n    pub reward_token_mint: Account<'info, Mint>,\n\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n}\n```\n\n----------------------------------------\n\nTITLE: Airdropping SOL Using Solana Web3.js in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to use the Solana Web3.js library to programmatically request an airdrop of test SOL to a specific public key in a local development environment. It requires the '@solana/web3.js' dependency, a connection to a devnet/testnet/localnet node, and a valid public key. Inputs include the public key to receive SOL and the amount of lamports (smallest SOL unit) to airdrop. The output is a confirmation that funds have been airdropped, or an error if unsuccessful. Intended for developers needing automated test funding.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Fetching Current Solana Validators in TypeScript\nDESCRIPTION: Connects to the Solana devnet and fetches a list of all validator vote accounts, categorizing them into 'current' (active) and 'delinquent' (inactive). It then logs the current validators and the combined list of all validators. Depends on the '@solana/web3.js' library.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/staking.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { clusterApiUrl, Connection } from \"@solana/web3.js\";\n\n(async () => {\n  const connection = new Connection(clusterApiUrl(\"devnet\"), \"confirmed\");\n\n  // Get all validators, categorized by current (i.e. active) and deliquent (i.e. inactive)\n  const { current, delinquent } = await connection.getVoteAccounts();\n  console.log(\"current validators: \", current);\n  console.log(\"all validators: \", current.concat(delinquent));\n})();\n```\n\n----------------------------------------\n\nTITLE: Getting Program Accounts in TypeScript\nDESCRIPTION: Demonstrates how to fetch all accounts owned by a specific program using TypeScript. It uses the `connection.getProgramAccounts` method from `@solana/web3.js`, providing the program ID. Optional filters can be added for more specific queries.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/get-program-accounts/basic/basic.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Serializing Instruction Data on Solana Client - Rust\nDESCRIPTION: Demonstrates the serialization of instruction data within a Rust-based Solana client for instructions such as minting, aligned with the program's deserialization conventions. Uses borsh-derive macros, with inputs reflecting the user's intent and the resulting serialized vector fit for transaction dispatch.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/instruction/rust.client.mint.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Implementing Move Right Instruction in Rust (Anchor)\nDESCRIPTION: This snippet implements the `move_right` instruction. The function increments the `player_position` in the `GameDataAccount` by 1, ensuring it doesn't exceed 3. It then calls `print_player` to log the new position or a completion message. The `MoveRight` struct specifies that the instruction requires mutable access to the `game_data_account`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod tiny_adventure {\n    use super::*;\n\t\t...\n\n\t\t// Instruction to move right\n\t\tpub fn move_right(ctx: Context<MoveRight>) -> Result<()> {\n\t\t    let game_data_account = &mut ctx.accounts.game_data_account;\n\t\t    if game_data_account.player_position == 3 {\n\t\t        msg!(\"You have reached the end! Super!\");\n\t\t    } else {\n\t\t        game_data_account.player_position = game_data_account.player_position + 1;\n\t\t        print_player(game_data_account.player_position);\n\t\t    }\n\t\t    Ok(())\n\t\t}\n}\n\n// Specify the account required by the move_right instruction\n#[derive(Accounts)]\npub struct MoveRight<'info> {\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n}\n\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing Move Left Instruction in Rust (Anchor)\nDESCRIPTION: This snippet implements the `move_left` instruction. The function decrements the `player_position` in the `GameDataAccount` by 1, ensuring it doesn't go below 0. It then calls `print_player` to log the new position. The `MoveLeft` struct specifies that the instruction requires mutable access to the `game_data_account`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod tiny_adventure {\n    use super::*;\n    ...\n\n    // Instruction to move left\n    pub fn move_left(ctx: Context<MoveLeft>) -> Result<()> {\n        let game_data_account = &mut ctx.accounts.game_data_account;\n        if game_data_account.player_position == 0 {\n            msg!(\"You are back at the start.\");\n        } else {\n            game_data_account.player_position -= 1;\n            print_player(game_data_account.player_position);\n        }\n        Ok(())\n    }\n}\n\n// Specify the account required by the move_left instruction\n#[derive(Accounts)]\npub struct MoveLeft<'info> {\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n}\n\n...\n```\n\n----------------------------------------\n\nTITLE: Using Durable Nonce in Transactions with Solana in TypeScript\nDESCRIPTION: This code provides an example for referencing a durable nonce inside a transaction in Solana using TypeScript. It updates a transaction's recentBlockhash field with the durable nonce value from a nonce account and adds a 'nonce advance' instruction as the first item. Requires a previously created nonce account and authority signature. Ensures the transaction remains valid beyond the typical 150-block expiration limit. Proper construction and ordering of instructions are critical.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/offline-transactions.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/durable-nonce/use-nonce-account/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/durable-nonce/use-nonce-account/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Deriving a PDA for Game Data Account (Anchor JavaScript/TypeScript)\nDESCRIPTION: This TypeScript snippet shows how to derive a Program Derived Address (PDA) for the Tiny Adventure game's data account using Anchor's JavaScript client utilities. The function uses a fixed seed ('level1') and the deployed program ID to deterministically generate the PDA required for all further program interactions. Requires the anchor web3 library and a valid AnchorProvider context with configured programId. Inputs are the seed (as Buffer) and programId; outputs are the PDA and bump. The PDA will be needed as the main address argument for most on-chain instructions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// The PDA adress everyone will be able to control the character if the interact with your program\nconst [globalLevel1GameDataAccount, bump] =\n  await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from(\"level1\", \"utf8\")],\n    pg.program.programId\n  );\n\n```\n\n----------------------------------------\n\nTITLE: Verifying Solana Keypair using CLI\nDESCRIPTION: Shows how to use the Solana CLI to verify a keypair, typically by using a command like `solana-keygen verify`. This command takes the public key and prompts for the secret or reads it from a file to confirm the match.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_16\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.preview.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Creating a System Account in TypeScript\nDESCRIPTION: Demonstrates how to create a new Solana account owned by the System Program using TypeScript. It involves generating a new keypair for the account, calculating the required lamports for rent exemption based on the desired space, and creating a transaction with the `SystemProgram.createAccount` instruction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-system-account/create-system-account.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-system-account/create-system-account.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Setting up Anchor Program Dependencies and Structure in Rust\nDESCRIPTION: This snippet initializes an Anchor program in Rust by importing necessary crates like `anchor_lang`, `anchor_spl` (for associated token accounts, token program interactions, and metadata), `mpl_token_metadata`, and `solana_program`. It declares a placeholder program ID and defines the main program module `anchor_token`. This setup is foundational for building Solana programs with Anchor.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    metadata::{create_metadata_accounts_v3, CreateMetadataAccountsV3, Metadata},\n    token::{burn, mint_to, Burn, Mint, MintTo, Token, TokenAccount},\n};\nuse mpl_token_metadata::{pda::find_metadata_account, state::DataV2};\nuse solana_program::{pubkey, pubkey::Pubkey};\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\npub mod anchor_token {\n    use super::*;\n}\n```\n\n----------------------------------------\n\nTITLE: Withdrawing SOL from an Inactive Stake Account in TypeScript\nDESCRIPTION: Demonstrates how to withdraw SOL from a deactivated stake account back to a regular system account (e.g., the main wallet). This uses `StakeProgram.withdraw` and requires authorization from the withdrawal authority. The transaction specifies the stake account, the authorized withdrawer, the destination public key, and the amount of lamports to withdraw (here, the entire balance `stakeBalance`). After sending and confirming the transaction, it verifies that the stake account balance is now zero.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/staking.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\n// Once deactivated, we can withdraw our SOL back to our main wallet\nconst withdrawTx = StakeProgram.withdraw({\n  stakePubkey: stakeAccount.publicKey,\n  authorizedPubkey: wallet.publicKey,\n  toPubkey: wallet.publicKey,\n  lamports: stakeBalance, // Withdraw the full balance at the time of the transaction\n});\n\nconst withdrawTxId = await sendAndConfirmTransaction(connection, withdrawTx, [\n  wallet,\n]);\nconsole.log(`Stake account withdrawn. Tx Id: ${withdrawTxId}`);\n\n// Confirm that our stake account balance is now 0\nstakeBalance = await connection.getBalance(stakeAccount.publicKey);\nconsole.log(`Stake account balance: ${stakeBalance / LAMPORTS_PER_SOL} SOL`);\n```\n\n----------------------------------------\n\nTITLE: Cross Program Invocation: System Program create_account Instruction in Solana (Rust)\nDESCRIPTION: Rust program showing a CPI into the system program's create_account instruction, including the need to pass the system program's public key. Inputs: payer, new account to create, system program account; output: new account created and funded on chain. Relies on solana_program::system_instruction and related CPI logic.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/programs/cpi-transfer/program-system/src/lib.rs)\n```\n\n----------------------------------------\n\nTITLE: Minting an NFT via Metaplex SDK - TypeScript\nDESCRIPTION: This TypeScript code illustrates the process of minting an NFT on Solana once the asset and metadata are uploaded. It requires the Metaplex JS SDK and a configured wallet. Key parameters include the URI of the uploaded metadata and recipient wallet public key. Outputs are the confirmed NFT mint address and transaction signature. The function typically enforces creator ownership alignment and may be constrained by Metaplex protocol requirements.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/mint-nft/mint-nft.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Calculating Rent Exemption Cost in Rust\nDESCRIPTION: Illustrates how to calculate the rent exemption cost within a Rust Solana program. It uses the `Rent::get()?.minimum_balance(data_length)` method to determine the required lamports based on the account's data length.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/rent-exemption/rent-exemption.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Partial Signing of Multi-Signature Transactions with Solana in TypeScript\nDESCRIPTION: This snippet illustrates partial signing of a Solana transaction in scenarios requiring multiple signatures, using TypeScript and @solana/web3.js. The code sets up a transaction object where only one party signs, along with metadata explaining multi-party workflows. Inputs include a full or partly constructed transaction object and at least one signer's Keypair; the output is a partially signed transaction, which can be forwarded to others for completing the signature process. The code is particularly useful when sending SPL tokens in exchange scenarios or for authenticating user intent.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/offline-transactions.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/partial-sign/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/partial-sign/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Uploading Files to Arweave for NFT Minting - Python\nDESCRIPTION: This Python snippet shows how to upload files to Arweave from a Python application, for use as NFT assets. Compatible Arweave libraries are required, and users must handle wallet key management. Inputs are paths or byte buffers of files; outputs are URLs or transaction IDs of uploaded assets on Arweave. The code typically covers signing, broadcasting, and recording the upload process; careful error handling and file type specifications are advisable.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/nfts/upload-arweave/upload-arweave.en.py)\n```\n\n----------------------------------------\n\nTITLE: Using COption for Optional Data Serialization in TypeScript (Borsh)\nDESCRIPTION: TypeScript example using `borsh-js` to define a schema and serialize/deserialize an object containing an optional number field (`myOption`). It demonstrates handling `null` (representing None) and a numeric value (representing Some) using the `COption` type within the schema definition.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/fil/guides/serialization.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/serialization/coption/demo_coption.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Borsh in Solana Program - TOML\nDESCRIPTION: Demonstrates adding required Borsh dependencies to the Rust Solana program using Cargo.toml. Ensures that program-side serialization and deserialization with Borsh are available. Dependencies section must include the borsh and borsh-derive crates.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n@[code](@/code/serialization/setup/Cargo.program.en.toml)\n```\n\n----------------------------------------\n\nTITLE: Delegating SOL to a Validator in TypeScript\nDESCRIPTION: Illustrates how to delegate SOL held in a stake account to a chosen validator. It uses `StakeProgram.delegate` to create the delegation transaction, specifying the stake account's public key, the authorized staker's public key (the wallet), and the selected validator's vote account public key. The transaction is signed by the authorized wallet and sent to the network. Afterwards, it checks the stake account's activation status, which should transition towards 'activating'.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/staking.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// With a validator selected, we can now setup a transaction that delegates our stake to their vote account.\nconst delegateTx = StakeProgram.delegate({\n  stakePubkey: stakeAccount.publicKey,\n  authorizedPubkey: wallet.publicKey,\n  votePubkey: selectedValidatorPubkey,\n});\n\nconst delegateTxId = await sendAndConfirmTransaction(connection, delegateTx, [\n  wallet,\n]);\nconsole.log(\n  `Stake account delegated to ${selectedValidatorPubkey}. Tx Id: ${delegateTxId}`\n);\n\n// Check in on our stake account. It should now be activating.\nstakeStatus = await connection.getStakeActivation(stakeAccount.publicKey);\nconsole.log(`Stake account status: ${stakeStatus.state}`);\n```\n\n----------------------------------------\n\nTITLE: Example Solana Program Logs for Compute Budget Instructions\nDESCRIPTION: These are example program logs generated when a transaction including instructions from the Compute Budget program is executed on the Solana network. They show the successful invocation ([1]) and completion ([2], [5]) of the `ComputeBudget111...` program, confirming that the compute unit limit and/or priority fee instructions were processed.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/basic-transactions.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n```\n[ 1] Program ComputeBudget111111111111111111111111111111 invoke [1]\n[ 2] Program ComputeBudget111111111111111111111111111111 success\n[ 3]\n[ 4] Program ComputeBudget111111111111111111111111111111 invoke [1]\n[ 5] Program ComputeBudget111111111111111111111111111111 success\n```\n```\n\n----------------------------------------\n\nTITLE: Calculating Transaction Cost | getFeeForMessage | TypeScript\nDESCRIPTION: Shows how to compute estimated fees using the getFeeForMessage method from solana/web3.js. This approach involves serializing the transaction to a Message and querying the connection for the fee. Requires recent blockhash and a constructed transaction; helpful when working with custom or offline signing workflows.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/calc-tx-cost/calc-tx-est-fees-for-message.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/calc-tx-cost/calc-tx-est-fees-for-message.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Initializing Player Account via Anchor on Solana - Rust\nDESCRIPTION: This snippet demonstrates how to initialize a player's account on Solana using Anchor framework. It sets the starting energy, saves the current UNIX timestamp as last_login, and prepares the account for tracking resources. The context struct specifies relevant account constraints, and the PlayerData struct holds player's game information, such as energy and wood count. Dependencies include the Solana program library, Anchor macros, and Solana Clock for timekeeping. Inputs include a signer and system program, outputs are the created and initialized player account. Ensure appropriate space and seeds are used for reproducibility.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/energy-system.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn init_player(ctx: Context<InitPlayer>) -> Result<()> {\n    ctx.accounts.player.energy = MAX_ENERGY;\n    ctx.accounts.player.last_login = Clock::get()?.unix_timestamp;\n    Ok(())\n}\n\n...\n\n#[derive(Accounts)]\npub struct InitPlayer <'info> {\n    #[account(\n        init,\n        payer = signer,\n        space = 1000,\n        seeds = [b\"player\".as_ref(), signer.key().as_ref()],\n        bump,\n    )]\n    pub player: Account<'info, PlayerData>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct PlayerData {\n    pub name: String,\n    pub level: u8,\n    pub xp: u64,\n    pub wood: u64,\n    pub energy: u64,\n    pub last_login: i64\n}\n```\n\n----------------------------------------\n\nTITLE: Signing with a PDA - Rust Program\nDESCRIPTION: Illustrates a Rust program instruction that signs a transaction (e.g., a SOL transfer) using a PDA. It uses `invoke_signed` with the appropriate system instruction (like `system_instruction::transfer`), providing the PDA account info, seeds, and bump seed to authorize the action on behalf of the PDA.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/sign-a-pda/program/src/lib.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/sign-a-pda/program/src/lib.preview.rs)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Tiny Adventure Game Smart Contract with Anchor - Rust\nDESCRIPTION: Implements the core logic of a Solana anchor-based smart contract for a simple adventure game. This snippet includes initialization, level/chest resets, player movement, account definitions, PDA seeds, custom error handling, and SOL transfers between accounts. Dependencies are anchor_lang, system_program, and the Solana runtime. Required accounts and PDA rules are specified with #[account] attributes. Operates with GameData and ChestVault accounts, supports custom movement logic and password protection for gameplay, and emits program logs for user interaction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_lang::solana_program::native_token::LAMPORTS_PER_SOL;\nuse anchor_lang::system_program;\n\n// This is your program's public key and it will update\n// automatically when you build the project.\ndeclare_id!(\"7gZTdZg86YsYbs92Rhv63kZUAkoww1kLexJg8sNpgVQ3\");\n\n#[program]\nmod tiny_adventure_two {\n    use super::*;\n\n    // The amount of lamports that will be put into chests and given out as rewards.\n    const CHEST_REWARD: u64 = LAMPORTS_PER_SOL / 10; // 0.1 SOL\n\n    pub fn initialize_level_one(_ctx: Context<InitializeLevelOne>) -> Result<()> {\n        // Usually in your production code you would not print lots of text because it cost compute units.\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.......\");\n        Ok(())\n    }\n\n    pub fn reset_level_and_spawn_chest(ctx: Context<SpawnChest>) -> Result<()> {\n        ctx.accounts.game_data_account.player_position = 0;\n\n        let cpi_context = CpiContext::new(\n            ctx.accounts.system_program.to_account_info(),\n            system_program::Transfer {\n                from: ctx.accounts.payer.to_account_info().clone(),\n                to: ctx.accounts.chest_vault.to_account_info().clone(),\n            },\n        );\n        system_program::transfer(cpi_context, CHEST_REWARD)?;\n\n        msg!(\"Level Reset and Chest Spawned at position 3\");\n\n        Ok(())\n    }\n\n    pub fn move_right(ctx: Context<MoveRight>, password: String) -> Result<()> {\n        let game_data_account = &mut ctx.accounts.game_data_account;\n        if game_data_account.player_position == 3 {\n            msg!(\"You have reached the end! Super!\");\n        } else if game_data_account.player_position == 2 {\n            if password != \"gib\" {\n                return err!(MyError::WrongPassword);\n            }\n\n            game_data_account.player_position = game_data_account.player_position + 1;\n\n            msg!(\n                \"You made it! Here is your reward {0} lamports\",\n                CHEST_REWARD\n            );\n\n            **ctx\n                .accounts\n                .chest_vault\n                .to_account_info()\n                .try_borrow_mut_lamports()? -= CHEST_REWARD;\n            **ctx\n                .accounts\n                .player\n                .to_account_info()\n                .try_borrow_mut_lamports()? += CHEST_REWARD;\n        } else {\n            game_data_account.player_position = game_data_account.player_position + 1;\n            print_player(game_data_account.player_position);\n        }\n        Ok(())\n    }\n}\n\nfn print_player(player_position: u8) {\n    if player_position == 0 {\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.........\");\n    } else if player_position == 1 {\n        msg!(\"..o.......\");\n    } else if player_position == 2 {\n        msg!(\"....o.....\");\n    } else if player_position == 3 {\n        msg!(\"........\\\\o/\");\n        msg!(\"..........\\\\o/\");\n        msg!(\"You have reached the end! Super!\");\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeLevelOne<'info> {\n    // We must specify the space in order to initialize an account.\n    // First 8 bytes are default account discriminator,\n    // next 1 byte come from NewAccount.data being type u8.\n    // (u8 = 8 bits unsigned integer = 8 bytes)\n    // You can also use the signer as seed [signer.key().as_ref()],\n    #[account(\n        init_if_needed,\n        seeds = [b\"level1\"],\n        bump,\n        payer = signer,\n        space = 8 + 1\n    )]\n    pub new_game_data_account: Account<'info, GameDataAccount>,\n    // This is the PDA in which we will deposit the reward SOL and\n    // from where we send it back to the first player reaching the chest.\n    #[account(\n        init_if_needed,\n        seeds = [b\"chestVault\"],\n        bump,\n        payer = signer,\n        space = 8\n    )]\n    pub chest_vault: Account<'info, ChestVaultAccount>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct SpawnChest<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(mut, seeds = [b\"chestVault\"], bump)]\n    pub chest_vault: Account<'info, ChestVaultAccount>,\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct MoveRight<'info> {\n    #[account(mut, seeds = [b\"chestVault\"], bump)]\n    pub chest_vault: Account<'info, ChestVaultAccount>,\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n#[account]\npub struct GameDataAccount {\n    player_position: u8,\n}\n\n#[account]\npub struct ChestVaultAccount {}\n\n#[error_code]\npub enum MyError {\n    #[msg(\"Password was wrong\")]\n    WrongPassword,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Moving and Extracting Solana CLI Binaries on Linux\nDESCRIPTION: Commands to move the downloaded Solana CLI binary archive (tar.bz2) to the root directory and extract its contents. This is part of the manual installation process using prebuilt binaries on Linux.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nmv Downloads/solana-release-x86_64-unknown-linux-gnu.tar.bz2 .\n```\n\nLANGUAGE: bash\nCODE:\n```\ntar jxf solana-release-x86_64-unknown-linux-gnu.tar.bz2\n```\n\n----------------------------------------\n\nTITLE: Starting Solana Test Validator with Deactivated Features from `scfsd` Tool via CLI\nDESCRIPTION: Illustrates how to start `solana-test-validator` with a set of deactivated features dynamically generated by the `scfsd` tool to match a specific cluster (devnet in this example). It uses command substitution (`$(...)`) to pass the output of `scfsd` (which provides the necessary `--deactivate-feature` flags) directly as arguments to the validator startup command.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\nsolana-test-validator -l ./.ledger $(scfsd -c devnet -k -t)\n```\n\n----------------------------------------\n\nTITLE: Fetching Current Validators in TypeScript\nDESCRIPTION: Retrieves the list of current validators on the Solana network using the `@solana/web3.js` library. This is useful for identifying potential validators to delegate stake to.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/get-current-validators/get-current-validators.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Signing with a PDA - TypeScript Client\nDESCRIPTION: Provides the TypeScript client code to invoke a program instruction that requires a PDA signature. The client finds the PDA and bump seed using `findProgramAddress`, then constructs a transaction calling the program, passing the PDA, other relevant accounts, and the bump seed.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/sign-a-pda/client/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/sign-a-pda/client/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Importing NATIVE_MINT for Wrapped SOL - TypeScript\nDESCRIPTION: Demonstrates how to import the NATIVE_MINT constant from the SPL-Token TypeScript SDK, which is required when managing wrapped SOL token accounts. This import is a prerequisite for account creation or operations involving wrapped SOL tokens. Only the import statement is shown and must be used in combination with wrapped SOL account logic.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/token.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n\"import { NATIVE_MINT } from \\\"@solana/spl-token\\\";\"\n```\n\n----------------------------------------\n\nTITLE: Adding Memo to Transaction | Solana CLI | Shell\nDESCRIPTION: Uses the Solana CLI to append a memo to a transaction. The memo is specified as a command-line argument and the entire transaction (with memo) is sent and signed via CLI. Requires solana CLI and correct account setup.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/basic-transactions/memo/memo.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/basic-transactions/memo/memo.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Fetching or Initializing Game Data Account (Anchor JavaScript/TypeScript)\nDESCRIPTION: This TypeScript snippet demonstrates how to fetch the game's PDA-backed data account or initialize it if it does not exist, using Anchor's JavaScript API. The flow first attempts to fetch the existing game state; if unavailable, it sends a transaction invoking the 'initialize' instruction and confirms the result. Dependencies include an Anchor workspace with pg.program and pg.wallet set up. Inputs are the PDA and transaction context; outputs are the game data account info and console logs for transaction hash and progress. This approach helps ensure idempotent creation of the game state.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nlet txHash;\nlet gameDateAccount;\ntry {\n  gameDateAccount = await pg.program.account.gameDataAccount.fetch(\n    globalLevel1GameDataAccount\n  );\n} catch {\n  // Check if the account is already initialized, other wise initialize it\n  txHash = await pg.program.methods\n    .initialize()\n    .accounts({\n      newGameDataAccount: globalLevel1GameDataAccount,\n      signer: pg.wallet.publicKey,\n      systemProgram: web3.SystemProgram.programId,\n    })\n    .signers([pg.wallet.keypair])\n    .rpc();\n\n  console.log(`Use 'solana confirm -v ${txHash}' to see the logs`);\n  await pg.connection.confirmTransaction(txHash);\n  console.log(\"A journey begins...\");\n  console.log(\"o........\");\n}\n\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Vanity Address in TypeScript\nDESCRIPTION: Generates a Solana keypair whose public key starts with specific characters (vanity address) using TypeScript. This process can be computationally intensive and is slower than the CLI method.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Implementing Initialize Level One Instruction in Rust\nDESCRIPTION: This code implements the `initialize_level_one` instruction and defines its associated accounts struct `InitializeLevelOne`. The instruction's logic simply logs the starting game message. The `InitializeLevelOne` struct defines the required accounts: `new_game_data_account` and `chest_vault` (both initialized as PDAs using `init_if_needed`, fixed `seeds`, `bump`, `payer`, and `space`), the `signer` paying for account creation, and the `system_program`. This instruction sets up the initial game state and reward vault accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod tiny_adventure_two {\n    use super::*;\n\n    pub fn initialize_level_one(_ctx: Context<InitializeLevelOne>) -> Result<()> {\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.......\");\n        Ok(())\n    }\n\n    ...\n}\n\n// Specify the accounts required by the initialize_level_one instruction\n#[derive(Accounts)]\npub struct InitializeLevelOne<'info> {\n    #[account(\n        init_if_needed,\n        seeds = [b\"level1\"],\n        bump,\n        payer = signer,\n        space = 8 + 1\n    )]\n    pub new_game_data_account: Account<'info, GameDataAccount>,\n    #[account(\n        init_if_needed,\n        seeds = [b\"chestVault\"],\n        bump,\n        payer = signer,\n        space = 8\n    )]\n    pub chest_vault: Account<'info, ChestVaultAccount>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n...\n```\n\n----------------------------------------\n\nTITLE: Deactivating a Solana Stake Account in TypeScript\nDESCRIPTION: Explains how to deactivate delegation for a stake account using `StakeProgram.deactivate`. This action requires authorization from the stake authority (the wallet). The transaction is created, specifying the stake account and the authorized public key, then sent and confirmed. Deactivation takes some time (epochs) to complete. The code checks the stake account status after sending the transaction, which should eventually become 'inactive' or 'deactivating'.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/staking.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\n// At anytime we can choose to deactivate our stake. Our stake account must be inactive before we can withdraw funds.\nconst deactivateTx = StakeProgram.deactivate({\n  stakePubkey: stakeAccount.publicKey,\n  authorizedPubkey: wallet.publicKey,\n});\nconst deactivateTxId = await sendAndConfirmTransaction(\n  connection,\n  deactivateTx,\n  [wallet]\n);\nconsole.log(`Stake account deactivated. Tx Id: ${deactivateTxId}`);\n\n// Check in on our stake account. It should now be inactive.\nstakeStatus = await connection.getStakeActivation(stakeAccount.publicKey);\nconsole.log(`Stake account status: ${stakeStatus.state}`);\n```\n\n----------------------------------------\n\nTITLE: Initializing Player Data Account via Anchor in JavaScript Client\nDESCRIPTION: Finds the program derived address (PDA) for the player's account using a seed and generates a transaction to initialize player data on the Solana blockchain. The transaction is sent with the user's public key, and confirmation ensures on-chain state validity. Dependencies: @solana/web3.js, Anchor framework setup, existence of LUMBERJACK_PROGRAM_ID. Inputs: publicKey, program. Outputs: player account initialized and confirmed transaction signature.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/energy-system.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst [pda] = PublicKey.findProgramAddressSync(\n  [Buffer.from(\"player\", \"utf8\"), publicKey.toBuffer()],\n  new PublicKey(LUMBERJACK_PROGRAM_ID)\n);\n\nconst transaction = program.methods\n  .initPlayer()\n  .accounts({\n    player: pda,\n    signer: publicKey,\n    systemProgram: SystemProgram.programId,\n  })\n  .transaction();\n\nconst tx = await transaction;\nconst txSig = await sendTransaction(tx, connection, {\n  skipPreflight: true,\n});\n\nawait connection.confirmTransaction(txSig, \"confirmed\");\n\n```\n\n----------------------------------------\n\nTITLE: Serializing Optional Types (COption) for Borsh - TypeScript\nDESCRIPTION: Shows advanced serialization in TypeScript for Solana COption types (an optional construct). Constructed for cross-language compatibility with Rust's COption, using borsh schema extensions. Inputs may be null or present, and schema ensures correct serialization.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/serialization/coption/demo_coption.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Slicing Solana Program Account Data with dataSlice and memcmp (TypeScript/Rust/cURL)\nDESCRIPTION: Shows how to use `getProgramAccounts` with the `dataSlice` parameter to retrieve only a specific portion of account data, improving efficiency when the full data is not needed. This example queries SPL Token program accounts, filtering by mint address using `memcmp` (offset 0) and applying `dataSlice` with offset 0 and length 0 to retrieve minimal data, effectively just counting the accounts (e.g., finding token holders for a mint). Requires Solana JSON-RPC endpoint access and relevant libraries (@solana/web3.js for TS, solana-client for Rust).\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/get-program-accounts.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/get-program-accounts/dataSlice/dataSlice.en.ts)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/get-program-accounts/dataSlice/dataSlice.en.rs)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/get-program-accounts/dataSlice/dataSlice.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Initializing Solana Anchor Program Structure in Rust\nDESCRIPTION: This snippet sets up the basic structure for the 'Tiny Adventure Two' Anchor program. It imports necessary Anchor and Solana libraries, declares a placeholder program ID, defines the main program module `tiny_adventure_two`, and includes a helper function `print_player` to log the player's position visually during the game.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_lang::solana_program::native_token::LAMPORTS_PER_SOL;\nuse anchor_lang::system_program;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\nmod tiny_adventure_two {\n    use super::*;\n}\n\nfn print_player(player_position: u8) {\n    if player_position == 0 {\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.........\");\n    } else if player_position == 1 {\n        msg!(\"..o.......\");\n    } else if player_position == 2 {\n        msg!(\"....o.....\");\n    } else if player_position == 3 {\n        msg!(\"........\\\\o/\");\n        msg!(\"..........\\\\o/\");\n        msg!(\"You have reached the end! Super!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining the VersionedMessage Enum in Rust for Solana Transactions\nDESCRIPTION: This Rust enum `VersionedMessage` defines the possible structures for a Solana transaction message. It accommodates both the original `Legacy` message format and the new `V0` message format, which supports Address Lookup Tables (LUTs). The distinction is determined by the first bit of the message header: if unset, it's `Legacy`; if set, the remaining bits denote the version, starting with `V0(v0::Message)`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/ja/guides/versioned-transactions.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub enum VersionedMessage {\n    Legacy(Message),\n    V0(v0::Message),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Name Registry Header Schema in TypeScript\nDESCRIPTION: This snippet defines the TypeScript structure for the header of a Solana Name Service domain name registry entry. The registry stores information about a domain name, always prefixed by this header structure. Dependencies include `@solana/web3.js` and potentially buffer layout libraries.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/name-service.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/schema/schema.en.ts)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/schema/schema.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Account Updates and Decoding State - Solana/Anchor Client in JavaScript\nDESCRIPTION: Uses the connection.onAccountChange method to subscribe to real-time updates of a player's account on Solana. On every change, decodes account data with program.coder into usable TypeScript state for the UI. Includes initial fetch and error handling for missing data. Inputs: publicKey, connection. Outputs: React state updates. Dependencies: React (useEffect), @solana/web3.js, Anchor's program.coder.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/energy-system.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nuseEffect(() => {\n    if (!publicKey) {return;}\n    const [pda] = PublicKey.findProgramAddressSync(\n        [Buffer.from(\"player\", \"utf8\"), publicKey.toBuffer()],\n        new PublicKey(LUMBERJACK_PROGRAM_ID)\n      );\n    try {\n      program.account.playerData.fetch(pda).then((data) => {\n        setGameState(data);\n      });\n    } catch (e) {\n      window.alert(\"No player data found, please init!\");\n    }\n\n    connection.onAccountChange(pda, (account) => {\n        setGameState(program.coder.accounts.decode(\"playerData\", account.data));\n    });\n\n  }, [publicKey]);\n```\n\n----------------------------------------\n\nTITLE: Getting Program Accounts in Rust\nDESCRIPTION: Shows how to use the `RpcClient` in Rust to fetch all accounts owned by a specific program. It calls the `get_program_accounts` method, passing the program's public key.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/get-program-accounts/basic/basic.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Sending SOL | Solana Wallet-Adapter | TSX\nDESCRIPTION: This React (TSX) example uses Solana's Wallet-Adapter library to send SOL from the user's connected wallet. It prepares a transaction, inserts a transfer instruction, and uses the wallet-adapter's sendTransaction method. Requires the @solana/wallet-adapter packages and connection context. Suitable for UI-based dApps where the user signs via browser wallet extensions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.adapter.en.tsx)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.adapter.preview.en.tsx)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Verifying Accounts with Solana Program (Rust)\nDESCRIPTION: This Rust code snippet provides an instruction handler for initializing a hero state account with rigorous verification of account conditions within a Solana on-chain program. It checks that signer accounts have signed, that target state accounts are writable, that the correct program owns the accounts, and that the state account is not yet initialized, preventing duplicate state creation. Dependencies include the Solana Program Library and standard Rust crates; typically, accounts are passed via program entrypoints and parameters specify accounts and data. The output is a securely initialized on-chain account or a returned error if checks fail, ensuring safety against malicious inputs. Limitations: applicable to Solana program environments and presumes trusted client-side serialization.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n@[code](@/code/programs/verify-account/program/src/lib.rs)\n```\n\nLANGUAGE: Rust\nCODE:\n```\n@[code](@/code/programs/verify-account/program/src/lib.preview.rs)\n```\n\n----------------------------------------\n\nTITLE: Account Data Serialization and Deserialization Internals - Rust\nDESCRIPTION: Describes the detailed process of serializing and deserializing the account storage region, breaking apart the initialized flag, BTreeMap length, and actual key-value pairs using Borsh. Demonstrates direct manipulation of slice boundaries to meet Borsh's integrity checks. Suitable for custom on-chain account handling and expects Borsh-compliant byte slices as input/output.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/program/rust.program.serdeser.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Fetching Delegators by Validator in TypeScript\nDESCRIPTION: Demonstrates how to find all stake accounts delegated to a specific validator using the `getProgramAccounts` API via `@solana/web3.js`. It utilizes filters based on stake account structure, specifically the voter public key offset.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/get-delegators-by-validators/get-delegators-by-validators.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Preview: Retrieving Account Balance using Solana-Web3.js in TypeScript\nDESCRIPTION: A concise preview snippet showing the core `getBalance` call from `@solana/web3.js` in TypeScript to fetch an account's SOL balance. Assumes `connection` and `publicKey` variables are already defined.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Reading Multiple Transaction Instructions in Solana Program (Rust)\nDESCRIPTION: This Rust code illustrates how a Solana program can access and iterate over all instructions in the current transaction context. By extracting and analyzing instruction data, the program can implement custom transaction validation logicfor example, searching for suspicious patterns or cross-instruction dependencies. The example depends on Rust, the Solana Program crate, and expects the transaction instructions to be available via sysvar in the runtime. Inputs include the current process's instruction data; outputs can be logs, program state changes, or error returns. Use is restricted to on-chain instruction parsing contexts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\n@[code](@/code/programs/read-multiple-instructions/program/lib.rs)\n```\n\nLANGUAGE: Rust\nCODE:\n```\n@[code](@/code/programs/read-multiple-instructions/program/lib.preview.rs)\n```\n\n----------------------------------------\n\nTITLE: Reading Multiple Accounts in a Solana Program using iterators (Rust)\nDESCRIPTION: Rust Solana program example of parsing instruction accounts via iter() and next_account_info, improving readable handling of multiple input accounts. Requires input array of account infos; outputs are parsed references to the expected accounts for processing. Useful for complex instructions needing multiple account roles.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/programs/read-account/program/src/lib.rs)\n```\n\n----------------------------------------\n\nTITLE: Generating a PDA Address in Rust\nDESCRIPTION: Illustrates how to find a Program Derived Address (PDA) and its bump seed within a Rust Solana program. It uses the `Pubkey::find_program_address` function, taking the seeds and the program ID as input.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/program-derived-address/derived-a-pda/find-program-address.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Loading 3D NFT Models in JavaScript with gltf-loader-ts\nDESCRIPTION: This JavaScript snippet shows how to use the gltf-loader-ts library to import and work with 3D NFT models, such as those referenced in NFT metadata animation URLs, in a web-based environment. It includes installation instructions, creation of a GltfLoader instance, asynchronous loading of the .gltf file from a URL, and access to model, buffer, and image data. Dependencies: gltf-loader-ts (npm), async/await support. Key parameters are the source URI of the GLTF/GLB file. The output is a collection of loaded model data and associated assets, logged to the console.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/nfts-in-games.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nnpm install --save-dev gltf-loader-ts\n\nimport { GltfLoader } from 'gltf-loader-ts';\n\nlet loader = new GltfLoader();\nlet uri = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BoxTextured/glTF/BoxTextured.gltf';\nlet asset: Asset = await loader.load(uri);\nlet gltf: GlTf = asset.gltf;\nconsole.log(gltf);\n// -> {asset: {}, scene: 0, scenes: Array(1), nodes: Array(2), meshes: Array(1), }\n\nlet data = await asset.accessorData(0); // fetches BoxTextured0.bin\nlet image: Image = await asset.imageData.get(0) // fetches CesiumLogoFlat.png\n```\n\n----------------------------------------\n\nTITLE: Accessing Clock Directly in a Solana Program: TypeScript Client Example\nDESCRIPTION: TypeScript client code for calling a Rust Solana program that retrieves the clock sysvar internally. No need to pass SYSVAR_CLOCK_PUBKEY as an account; only required accounts like the program state and payer are included. Prerequisite: @solana/web3.js.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/programs/get-clock/method-two/client/main.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Preview: Withdrawing SOL from a Stake Account in TypeScript\nDESCRIPTION: Provides a preview or runnable example snippet for withdrawing SOL from a deactivated stake account using `@solana/web3.js`. This illustrates the withdrawal process.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/withdraw-stake/withdraw-stake.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Deserializing Account Data on Client - TypeScript\nDESCRIPTION: Provides TypeScript logic for fetching and deserializing Solana program account data using Borsh. Utilizes schema mapping to reconstruct the original storage state, supporting key/value BTreeMaps and initialized flag parsing. Requires borsh and RPC access to Solana, returns a JavaScript representation of data stored on-chain.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/serialization/clientdata/ts.client.data.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Resolving SOL Domain Name to PublicKey in TypeScript\nDESCRIPTION: This snippet demonstrates how to convert a human-friendly .SOL domain name into its corresponding Solana PublicKey using TypeScript. It utilizes Solana's web3.js library and the SPL Name Service library to perform the lookup. Requires a connection to a Solana cluster and the domain name as input.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/name-service.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/resolve-sol-domain/resolve-sol-domain.en.ts)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/resolve-sol-domain/resolve-sol-domain.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Sending SPL-Tokens | Solana Wallet-Adapter | TSX\nDESCRIPTION: Transfers SPL tokens using React and Solana Wallet-Adapter libraries for UI-based dApps. The snippet looks up or creates the associated token accounts and prompts the connected wallet for a signature. Dependencies include @solana/wallet-adapter and @solana/spl-token. Key parameters are wallet context, mint address, recipient, and amount.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-spl-token/sending-spl-token.adapter.en.tsx)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/sending-spl-token/sending-spl-token.adapter.preview.en.tsx)\n```\n\n----------------------------------------\n\nTITLE: Getting the Clock Sysvar: Passing Clock as an Account in Solana Program (Rust)\nDESCRIPTION: Demonstrates receiving the sysvar clock account as an input account to a Rust-based Solana program. Program depends on the SYSVAR_CLOCK_PUBKEY to be passed in, compatible with legacy code requirements. Inputs include a state account and the sysvar clock account; outputs depend on instruction logic, often accessing current slot or timestamp.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/programs/get-clock/method-one/program/src/lib.rs)\n```\n\n----------------------------------------\n\nTITLE: Calculating Rent Exemption Cost with Solana CLI\nDESCRIPTION: Shows the Solana CLI command to calculate the rent exemption cost for a given account size. The `solana rent <ACCOUNT_SIZE_IN_BYTES>` command queries the cluster for the current rent parameters and outputs the minimum lamport balance required.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/accounts/rent-exemption/rent-exemption.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Secret Bytes in TypeScript\nDESCRIPTION: Shows how to restore a Solana keypair from its secret key provided as an array of bytes (Uint8Array) using the Solana Web3.js library. This reconstructs the keypair object from the secret.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Upgraded Processor for Migrated Account - Solana Program - Rust\nDESCRIPTION: Provides processor logic capable of handling both legacy and upgraded account structures, dispatching instruction handling based on version fields and performing the necessary upgrade in place. Implements wrap/unwrap of data with support for account conversions and new parameters. Relies on the updated account  structs and expanded instruction set. Inputs are upgraded instruction and account data; outputs include migrated accounts and new state.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.processor1.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Example Output of Local Validator Node Test Execution\nDESCRIPTION: Displays the console output from executing the `test_validator_transaction` function, which utilizes the `solana-validator` crate to run integration tests against a programmatically loaded local validator node. The output includes validator status messages (e.g., fee stabilization), program invocation logs with `msg!` output, compute unit consumption details, program success status, and overall test results. This illustrates the output from a more comprehensive testing environment compared to the bare-bones local runtime.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/debugging-solana-programs.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrunning 1 test\nWaiting for fees to stabilize 1...\nWaiting for fees to stabilize 2...\nProgram 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM invoke [1]\nProgram log: process_instruction: 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM: 1 accounts, data=[1, 2, 3]\nProgram 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM consumed 13027 of 200000 compute units\nProgram 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM success\n\ntest test_validator_transaction ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 6.40s\n```\n\n----------------------------------------\n\nTITLE: Deactivating Stake Delegation in TypeScript\nDESCRIPTION: Shows how the Stake Authority can deactivate the delegation of a stake account using `@solana/web3.js`. Deactivation is a prerequisite for withdrawing SOL and takes several epochs to complete.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/deactivate-stake/deactivate-stake.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Account Version 0 - Solana Program - Rust\nDESCRIPTION: Defines the initial account structure for a Solana program using Rust, including a version field for forward compatibility and extra allocation for future upgrades. Uses Borsh for serialization and prescribes allocation patterns to facilitate future migrations. Expects a struct with fields for data version and core state; inputs/outputs are serialized/deserialized Rust structs in this form. Requires the borsh and solana_program crates.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v0.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Solana Account Changes using Rust\nDESCRIPTION: Provides an example of subscribing to Solana account changes using Rust, typically utilizing the WebSocket features of the `solana-client` or related crates. It involves setting up a subscription stream for specific accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/local-development/connecting-websocket/connecting-websocket.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Fetching Metaplex NFT Metadata - TypeScript\nDESCRIPTION: This TypeScript snippet retrieves the on-chain Arweave metadata for an NFT by fetching and decoding the relevant Metaplex PDA account. It relies on the Metaplex JS SDK and Solana connection. Main input is the NFT mint address; output is the detailed metadata URI and decoded info. Ensure correct PDA calculation and compatibility with your Solana cluster environment.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/get-metadata/get-metadata.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining VersionedMessage Enum in Rust\nDESCRIPTION: This Rust code defines an enum `VersionedMessage` used within Solana's transaction processing logic. It represents the two possible types of transaction messages: the original `Legacy` format and the newer `V0` format which supports features like Address Lookup Tables. The runtime determines the message version based on the first bit of the message header.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/versioned-transactions.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub enum VersionedMessage {\n    Legacy(Message),\n    V0(v0::Message),\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Program Instructions (v0) in Rust\nDESCRIPTION: Defines the instruction enum (`VersionProgramInstruction`) for the initial version (v0) of the Solana program in Rust. It likely includes instructions for initializing or interacting with the v0 account state. It uses Borsh for serialization/deserialization.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/zh/guides/data-migration.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.instruction.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.instruction.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Deriving Program Derived Addresses (PDA) using Anchor - JavaScript\nDESCRIPTION: This snippet demonstrates how to derive Program Derived Addresses (PDAs) for the `GameDataAccount` and `ChestVaultAccount` using Anchor's JavaScript client in Solana. The PDAs are computed with specific seeds and the program ID, enabling deterministic account addresses for game data and SOL reward storage. Dependencies: Anchor JavaScript SDK, access to `pg.program` and `pg.wallet`. Inputs are seed buffers and the program ID; outputs are PDAs and bump seeds. One can optionally include the player wallet as a seed for player-specific data accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\n// The PDA adress everyone will be able to control the character if the interact with your program\nconst [globalLevel1GameDataAccount, bump] =\n  await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from(\"level1\", \"utf8\")],\n    //[pg.wallet.publicKey.toBuffer()], <- You could also add the player wallet as a seed, then you would have one instance per player. Need to also change the seed in the rust part\n    pg.program.programId\n  );\n\n// This is where the program will save the sol reward for the chests and from which the reward will be payed out again\nconst [chestVaultAccount, chestBump] =\n  await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from(\"chestVault\", \"utf8\")],\n    pg.program.programId\n  );\n```\n\n----------------------------------------\n\nTITLE: Initializing Anchor Program Structure in Rust\nDESCRIPTION: This snippet sets up the basic structure for the 'Tiny Adventure' Solana program using the Anchor framework. It includes the necessary `use` statement for Anchor, declares a placeholder program ID, defines the main program module `tiny_adventure`, and includes a helper function `print_player` to display the player's state via transaction logs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\nmod tiny_adventure {\n    use super::*;\n}\n\nfn print_player(player_position: u8) {\n    if player_position == 0 {\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.......\");\n    } else if player_position == 1 {\n        msg!(\"..o.....\");\n    } else if player_position == 2 {\n        msg!(\"....o...\");\n    } else if player_position == 3 {\n        msg!(\"........\\\\o/\");\n        msg!(\"You have reached the end! Super!\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Restoring Multiple Solana Keypairs (HD Wallets) from BIP44 Mnemonic in TypeScript\nDESCRIPTION: Restores multiple Solana keypairs from a single seed mnemonic using the BIP44 standard (Hierarchical Deterministic wallets) in TypeScript. This allows deriving multiple accounts from one mnemonic.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip44.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip44.preview.ts)\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Solana Account Changes using TypeScript\nDESCRIPTION: Demonstrates how to use WebSockets via the `@solana/web3.js` `Connection` object to subscribe to account changes on the Solana network. It uses the `onAccountChange` method, providing a callback function that is triggered when the specified account's state updates.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/local-development/connecting-websocket/connecting-websocket.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Updating Instruction Enum for Solana Program Data Migration in Rust\nDESCRIPTION: Defines the `VersionProgramInstruction` enum in Rust, representing the different instructions the Solana program can process. A new variant, `SetString(String)`, has been added to accommodate the updated data structure requiring a string. The `unpack` function deserializes the input byte slice into a specific instruction variant using `try_from_slice_unchecked` and includes matching logic for the newly added instruction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/guides/data-migration.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n```rs\n//! instruction Contains the main VersionProgramInstruction enum\n\nuse {\n    crate::error::DataVersionError,\n    borsh::{BorshDeserialize, BorshSerialize},\n    solana_program::{borsh::try_from_slice_unchecked, msg, program_error::ProgramError},\n};\n\n#[derive(BorshDeserialize, BorshSerialize, Debug, PartialEq)]\n/// All custom program instructions\npub enum VersionProgramInstruction {\n    InitializeAccount,\n    SetU64Value(u64),\n    SetString(String), // Added with data version change\n    FailInstruction,\n}\n\nimpl VersionProgramInstruction {\n    /// Unpack inbound buffer to associated Instruction\n    /// The expected format for input is a Borsh serialized vector\n    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let payload = try_from_slice_unchecked::<VersionProgramInstruction>(input).unwrap();\n        // let payload = VersionProgramInstruction::try_from_slice(input).unwrap();\n        match payload {\n            VersionProgramInstruction::InitializeAccount => Ok(payload),\n            VersionProgramInstruction::SetU64Value(_) => Ok(payload),\n            VersionProgramInstruction::SetString(_) => Ok(payload), // Added with data version change\n            _ => Err(DataVersionError::InvalidInstruction.into()),\n        }\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Deserializing Primitives and Compound Types - Rust\nDESCRIPTION: Handles deserialization on the Rust program side for receiving Borsh-encoded primitives and compound types sent from clients. Schemas in Rust are constructed to exactly match the input, using the Borsh derive macros.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/primitives/src/main.rs)\n```\n\n----------------------------------------\n\nTITLE: Closing an Account - Wallet-Adapter Client (TSX)\nDESCRIPTION: Provides a React component example using TypeScript (TSX) and Solana Wallet-Adapter to close an account. It constructs the transaction to call the close account program instruction and uses the connected wallet to sign and send it.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_21\n\nLANGUAGE: tsx\nCODE:\n```\n@[code](@/code/accounts/close-account/client/close-account.adapter.en.tsx)\n```\n\nLANGUAGE: tsx\nCODE:\n```\n@[code](@/code/accounts/close-account/client/close-account.adapter.preview.en.tsx)\n```\n\n----------------------------------------\n\nTITLE: Querying Block and Transaction Data with Versioned Transactions - Solana Web3.js - JavaScript\nDESCRIPTION: Demonstrates how to use the @solana/web3.js library to connect to the devnet cluster, retrieve the current slot, fetch the latest block, and obtain a specific transaction, all with 'maxSupportedTransactionVersion' set to 0 to include v0 transactions. Requires Node.js environment, the @solana/web3.js library, internet connectivity, and optionally a valid transaction signature. The examples show the use of the new RPC parameter to handle versioned transactions and expect block or transaction data as output.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/ja/guides/versioned-transactions.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// connect to the `devnet` cluster and get the current `slot`\nconst connection = new web3.Connection(web3.clusterApiUrl(\"devnet\"));\nconst slot = await connection.getSlot();\n\n// get the latest block (allowing for v0 transactions)\nconst block = await connection.getBlock(slot, {\n  maxSupportedTransactionVersion: 0,\n});\n\n// get a specific transaction (allowing for v0 transactions)\nconst getTx = await connection.getTransaction(\n  \"3jpoANiFeVGisWRY5UP648xRXs3iQasCHABPWRWnoEjeA93nc79WrnGgpgazjq4K9m8g2NJoyKoWBV1Kx5VmtwHQ\",\n  {\n    maxSupportedTransactionVersion: 0,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Building Anchor SPL Token Game Logic in Rust\nDESCRIPTION: Implements an end-to-end Solana Anchor program that introduces SPL token minting, player state management, and game mechanics such as defeating enemies and healing, utilizing on-chain accounts and metaplex metadata. Dependencies include anchor_lang, anchor_spl, mpl_token_metadata (with the corresponding associated_token and metadata modules), and solana_program for PDA and system interactions. Developers can define and deploy this program on Solana, requiring correct setup for PDA authorities and the admin's wallet pubkey, and expecting interactions through Solana Playground or similar development environments.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_spl::{\n    associated_token::AssociatedToken,\n    metadata::{create_metadata_accounts_v3, CreateMetadataAccountsV3, Metadata},\n    token::{burn, mint_to, Burn, Mint, MintTo, Token, TokenAccount},\n};\nuse mpl_token_metadata::{pda::find_metadata_account, state::DataV2};\nuse solana_program::{pubkey, pubkey::Pubkey};\n\ndeclare_id!(\"CCLnXJAJYFjCHLCugpBCEQKrpiSApiRM4UxkBUHJRrv4\");\n\nconst ADMIN_PUBKEY: Pubkey = pubkey!(\"REPLACE_WITH_YOUR_WALLET_PUBKEY\");\nconst MAX_HEALTH: u8 = 100;\n\n#[program]\npub mod anchor_token {\n    use super::*;\n\n    // Create new token mint with PDA as mint authority\n    pub fn create_mint(\n        ctx: Context<CreateMint>,\n        uri: String,\n        name: String,\n        symbol: String,\n    ) -> Result<()> {\n        // PDA seeds and bump to \"sign\" for CPI\n        let seeds = b\"reward\";\n        let bump = *ctx.bumps.get(\"reward_token_mint\").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // On-chain token metadata for the mint\n        let data_v2 = DataV2 {\n            name: name,\n            symbol: symbol,\n            uri: uri,\n            seller_fee_basis_points: 0,\n            creators: None,\n            collection: None,\n            uses: None,\n        };\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_metadata_program.to_account_info(),\n            CreateMetadataAccountsV3 {\n                metadata: ctx.accounts.metadata_account.to_account_info(), // the metadata account being created\n                mint: ctx.accounts.reward_token_mint.to_account_info(), // the mint account of the metadata account\n                mint_authority: ctx.accounts.reward_token_mint.to_account_info(), // the mint authority of the mint account\n                update_authority: ctx.accounts.reward_token_mint.to_account_info(), // the update authority of the metadata account\n                payer: ctx.accounts.admin.to_account_info(), // the payer for creating the metadata account\n                system_program: ctx.accounts.system_program.to_account_info(), // the system program account\n                rent: ctx.accounts.rent.to_account_info(), // the rent sysvar account\n            },\n            signer,\n        );\n\n        create_metadata_accounts_v3(\n            cpi_ctx, // cpi context\n            data_v2, // token metadata\n            true,    // is_mutable\n            true,    // update_authority_is_signer\n            None,    // collection details\n        )?;\n\n        Ok(())\n    }\n\n    // Create new player account\n    pub fn init_player(ctx: Context<InitPlayer>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n        Ok(())\n    }\n\n    // Mint tokens to player token account\n    pub fn kill_enemy(ctx: Context<KillEnemy>) -> Result<()> {\n        // Check if player has enough health\n        if ctx.accounts.player_data.health == 0 {\n            return err!(ErrorCode::NotEnoughHealth);\n        }\n        // Subtract 10 health from player\n        ctx.accounts.player_data.health = ctx.accounts.player_data.health.checked_sub(10).unwrap();\n\n        // PDA seeds and bump to \"sign\" for CPI\n        let seeds = b\"reward\";\n        let bump = *ctx.bumps.get(\"reward_token_mint\").unwrap();\n        let signer: &[&[&[u8]]] = &[&[seeds, &[bump]]];\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            MintTo {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                to: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.reward_token_mint.to_account_info(),\n            },\n            signer,\n        );\n\n        // Mint 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        mint_to(cpi_ctx, amount)?;\n        Ok(())\n    }\n\n    // Burn Token to health player\n    pub fn heal(ctx: Context<Heal>) -> Result<()> {\n        ctx.accounts.player_data.health = MAX_HEALTH;\n\n        // CPI Context\n        let cpi_ctx = CpiContext::new(\n            ctx.accounts.token_program.to_account_info(),\n            Burn {\n                mint: ctx.accounts.reward_token_mint.to_account_info(),\n                from: ctx.accounts.player_token_account.to_account_info(),\n                authority: ctx.accounts.player.to_account_info(),\n            },\n        );\n\n        // Burn 1 token, accounting for decimals of mint\n        let amount = (1u64)\n            .checked_mul(10u64.pow(ctx.accounts.reward_token_mint.decimals as u32))\n            .unwrap();\n\n        burn(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateMint<'info> {\n    #[account(\n        mut,\n        address = ADMIN_PUBKEY\n    )]\n    pub admin: Signer<'info>,\n\n    // The PDA is both the address of the mint account and the mint authority\n    #[account(\n        init,\n        seeds = [b\"reward\"],\n        bump,\n        payer = admin,\n        mint::decimals = 9,\n        mint::authority = reward_token_mint,\n\n    )]\n    pub reward_token_mint: Account<'info, Mint>,\n\n    ///CHECK: Using \"address\" constraint to validate metadata account address\n    #[account(\n        mut,\n        address=find_metadata_account(&reward_token_mint.key()).0\n    )]\n    pub metadata_account: UncheckedAccount<'info>,\n\n    pub token_program: Program<'info, Token>,\n    pub token_metadata_program: Program<'info, Metadata>,\n    pub system_program: Program<'info, System>,\n    pub rent: Sysvar<'info, Rent>,\n}\n\n#[derive(Accounts)]\npub struct InitPlayer<'info> {\n    #[account(\n        init,\n        payer = player,\n        space = 8 + 8,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct KillEnemy<'info> {\n    #[account(mut)]\n    pub player: Signer<'info>,\n\n    #[account(\n        mut,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n\n    // Initialize player token account if it doesn't exist\n    #[account(\n        init_if_needed,\n        payer = player,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b\"reward\"],\n        bump,\n    )]\n    pub reward_token_mint: Account<'info, Mint>,\n\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct Heal<'info> {\n    #[account(mut)]\n    pub player: Signer<'info>,\n\n    #[account(\n        mut,\n        seeds = [b\"player\".as_ref(), player.key().as_ref()],\n        bump,\n    )]\n    pub player_data: Account<'info, PlayerData>,\n\n    #[account(\n        mut,\n        associated_token::mint = reward_token_mint,\n        associated_token::authority = player\n    )]\n    pub player_token_account: Account<'info, TokenAccount>,\n\n    #[account(\n        mut,\n        seeds = [b\"reward\"],\n        bump,\n    )]\n    pub reward_token_mint: Account<'info, Mint>,\n\n    pub token_program: Program<'info, Token>,\n    pub associated_token_program: Program<'info, AssociatedToken>,\n}\n\n#[account]\npub struct PlayerData {\n    pub health: u8,\n}\n\n#[error_code]\npub enum ErrorCode {\n    #[msg(\"Not enough health\")]\n    NotEnoughHealth,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from BIP39 Mnemonic using CLI\nDESCRIPTION: Uses the Solana CLI to restore a single keypair from a BIP39 mnemonic phrase. This is useful for command-line based wallet recovery.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_26\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip39.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip39.sh)\n```\n\n----------------------------------------\n\nTITLE: Executing 'Heal' Instruction in Solana Client (JavaScript)\nDESCRIPTION: Invokes the heal instruction to replenish the players health, requiring the same core PDAs as killEnemy. Confirms transaction, emits logs, and fetches the latest player and token state. Designed for use after combat; minimal parameters and expected outputs mirrored in console logging and state updates.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_12\n\nLANGUAGE: js\nCODE:\n```\ntxHash = await pg.program.methods\n  .heal()\n  .accounts({\n    playerData: playerPDA,\n    playerTokenAccount: playerTokenAccount,\n    rewardTokenMint: rewardTokenMintPda,\n  })\n  .rpc();\nawait logTransaction(txHash);\nconsole.log(\"Player Healed\");\nawait fetchAccountData();\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from BIP39 Mnemonic in Python\nDESCRIPTION: Recovers a single Solana keypair from a given BIP39 mnemonic phrase using Python. This involves using the mnemonic to generate the seed required for keypair derivation.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip39.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip39.preview.py)\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Base58 Secret in TypeScript\nDESCRIPTION: Demonstrates how to restore a Solana keypair from its Base58 encoded secret string using the Solana Web3.js library. This involves decoding the Base58 string and then creating the keypair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/from-bs58.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/from-bs58.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Data Structures for Solana Program Account in Rust\nDESCRIPTION: Defines the initial Rust data structures (`AccountContentCurrent`, `ProgramAccountState`) for a Solana program account using Borsh for serialization/deserialization. `ProgramAccountState` includes metadata like `is_initialized` and crucially, `data_version` (u8), which is essential for the versioning and migration strategy.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/guides/data-migration.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rs\n#[derive(BorshDeserialize, BorshSerialize, Debug, Default, PartialEq)]\npub struct AccountContentCurrent {\n    pub somevalue: u64,\n}\n\n#[derive(BorshDeserialize, BorshSerialize, Debug, Default, PartialEq)]\npub struct ProgramAccountState {\n    is_initialized: bool,\n    data_version: u8,\n    account_data: AccountContentCurrent,\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Signing and Verifying Solana Messages in Python\nDESCRIPTION: Shows how to sign a message with a Solana private key and verify the signature using the public key in Python. Requires appropriate cryptographic libraries like `pynacl` (implied dependency through `solders` or `solana-py`).\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/sign-verify-message/sign-verify-message.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/sign-verify-message/sign-verify-message.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Verifying Solana Keypair in Python\nDESCRIPTION: Illustrates how to verify that a secret key correctly generates a given public key using the Solana Python library. This confirms the relationship between the secret and public components of a keypair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Nonce Account Data with Solana in TypeScript\nDESCRIPTION: This snippet demonstrates fetching a durable nonce account's data in Solana using TypeScript and @solana/web3.js. Given a nonce account's public key, it retrieves details such as the current nonce value and authority. The main dependency is access to a connected Solana RPC client. Results include the nonce value and account status, allowing users to coordinate nonced transactions. The code expects proper error handling for missing or closed accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/offline-transactions.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/durable-nonce/get-nonce-account/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/durable-nonce/get-nonce-account/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Fetching Solana Data with Versioned Tx Support using @solana/web3.js (JavaScript)\nDESCRIPTION: This JavaScript code demonstrates using the `@solana/web3.js` library to interact with the Solana RPC. It establishes a connection to the devnet cluster, retrieves the latest slot, and then fetches a block and a specific transaction using `connection.getBlock` and `connection.getTransaction`. The key aspect is passing `{ maxSupportedTransactionVersion: 0 }` as an option to these methods, which signals to the RPC node that the client can handle responses containing versioned (v0) transactions. Requires the `@solana/web3.js` library.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/versioned-transactions.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// connect to the `devnet` cluster and get the current `slot`\nconst connection = new web3.Connection(web3.clusterApiUrl(\"devnet\"));\nconst slot = await connection.getSlot();\n\n// get the latest block (allowing for v0 transactions)\nconst block = await connection.getBlock(slot, {\n  maxSupportedTransactionVersion: 0,\n});\n\n// get a specific transaction (allowing for v0 transactions)\nconst getTx = await connection.getTransaction(\n  \"3jpoANiFeVGisWRY5UP648xRXs3iQasCHABPWRWnoEjeA93nc79WrnGgpgazjq4K9m8g2NJoyKoWBV1Kx5VmtwHQ\",\n  {\n    maxSupportedTransactionVersion: 0,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Defining Chest Vault Account and Reward Constant in Rust\nDESCRIPTION: This snippet defines a constant `CHEST_REWARD` representing the SOL reward amount (0.1 SOL converted to lamports) and declares the `ChestVaultAccount` struct using the `#[account]` macro. This account is intended to hold the SOL reward as lamports directly within the account's balance, hence the struct itself is empty. It serves as a Program Derived Address (PDA) for storing the reward.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\nuse anchor_lang::solana_program::native_token::LAMPORTS_PER_SOL;\nuse anchor_lang::system_program;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\nmod tiny_adventure_two {\n    use super::*;\n\n    // The amount of lamports that will be put into chests and given out as rewards.\n    const CHEST_REWARD: u64 = LAMPORTS_PER_SOL / 10; // 0.1 SOL\n}\n\n...\n\n// Define the Chest Vault Account structure\n#[account]\npub struct ChestVaultAccount {}\n```\n\n----------------------------------------\n\nTITLE: Starting Solana Test Validator with Multiple Deactivated Features via CLI\nDESCRIPTION: Shows the command structure for starting `solana-test-validator` with multiple features deactivated simultaneously. By providing a `--deactivate-feature <FEATURE_PUBKEY>` flag for each feature to disable, developers can achieve full feature parity with a specific target cluster like devnet or mainnet-beta during local testing.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\nsolana-test-validator --deactivate-feature PUBKEY_1 --deactivate-feature PUBKEY_2 ...\n```\n\n----------------------------------------\n\nTITLE: Starting Solana Test Validator with 'Transaction Wide Compute Cap' Deactivated via CLI\nDESCRIPTION: Demonstrates starting the `solana-test-validator` while specifically deactivating the 'transaction wide compute cap' feature (`5ekBxc8itEnPv4NzGJtr8BVVQLNMQuLMNQQj7pHoLNZ9`). This configuration mimics the behavior of clusters like devnet before this feature was activated, where each instruction had its own compute unit budget instead of drawing from a transaction-wide pool.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\nsolana-test-validator -l ./ledger --deactivate-feature 5ekBxc8itEnPv4NzGJtr8BVVQLNMQuLMNQQj7pHoLNZ9 --bpf-program target/deploy/PROGNAME.so --reset`\n```\n\n----------------------------------------\n\nTITLE: Cross Program Invocation: System Program create_account Client Example (TypeScript)\nDESCRIPTION: TypeScript client for invoking a Solana program that performs a system program CPI to create an account. Uses @solana/web3.js for transaction preparation. Accounts passed: payer, newly created account, and system program. Output: signature of account creation transaction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/programs/cpi-transfer/client-system/main.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining the AccountMeta Struct for Instructions in Solana (Rust)\nDESCRIPTION: Presents the definition of `AccountMeta`, a struct used to declare within an `Instruction` which accounts participate, whether they're signers, and if they're writable. This information is critical for Solana's runtime permissioning and must match the expectations of the receiving program. Properly setting `is_signer` and `is_writable` is necessary for program correctness and security.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub struct AccountMeta {\\n    pub pubkey: Pubkey,\\n    pub is_signer: bool,\\n    pub is_writable: bool,\\n}\n```\n\n----------------------------------------\n\nTITLE: Minting an NFT from a Candy Machine - TypeScript\nDESCRIPTION: This TypeScript code mints an NFT from a Candy Machine v2 with the option to set a custom owner by providing a `newOwner` public key. Prerequisites are Candy Machine address, Metaplex SDK, and a wallet context. Input parameters include the new owner's public key; output is the NFT mint address. It may enforce collection or authority checks on the minted token.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/mint-nft.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining the Instruction Struct for CPIs in Solana (Rust)\nDESCRIPTION: Defines the `Instruction` struct from the `solana_program` crate. This struct encapsulates what program to target (`program_id`), which accounts to involve (`accounts` as a vector of `AccountMeta`), and the required raw instruction data (`data`). Constructing and serializing this struct appropriately is essential for successful CPIs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub struct Instruction {\\n    pub program_id: Pubkey,\\n    pub accounts: Vec<AccountMeta>,\\n    pub data: Vec<u8>,\\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Feature Status on Solana Clusters using CLI\nDESCRIPTION: Demonstrates using the Solana CLI command `solana feature status` with different flags (`-ud`, `-ut`, `-um`, `-ul`) to display the activation status of features on devnet, testnet, mainnet-beta, and a local test validator, respectively. This helps identify feature differences between environments.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nsolana feature status -ud   // Displays by feature status for devnet\nsolana feature status -ut   // Displays for testnet\nsolana feature status -um   // Displays for mainnet-beta\nsolana feature status -ul   // Displays for local, requires running solana-test-validator\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Keypair in TypeScript\nDESCRIPTION: Demonstrates how to generate a new Solana keypair using the Solana Web3.js library. This involves calling the appropriate function to create a fresh public/private key pair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Private Solana Cluster using Python\nDESCRIPTION: Shows how to connect to a private Solana RPC endpoint (local or remote) using the `solana-py` library in Python. The custom URL of the private cluster is provided when initializing the client object.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/local-development/connecting-private-cluster/connecting-private-cluster.en.py)\n```\n\n----------------------------------------\n\nTITLE: Checking Solana Public Key Validity in C++\nDESCRIPTION: Shows how to validate if a Solana public key lies on the ed25519 curve using C++ and a suitable library. This check helps differentiate standard public keys from Program Derived Addresses (PDAs).\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.cpp)\n```\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.preview.cpp)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Keypair using CLI\nDESCRIPTION: Demonstrates using the Solana Command Line Interface (CLI) tool to generate a new keypair. The `solana-keygen` command is typically used for this purpose.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.preview.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Preview: Delegating Stake in TypeScript\nDESCRIPTION: Provides a preview or runnable example snippet for delegating stake using `@solana/web3.js`. This likely simplifies setup for demonstrating stake delegation.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/delegate-stake/delegate-stake.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Keypair in Python\nDESCRIPTION: Illustrates the generation of a new Solana keypair using the Solana Python library. This creates a new public key and its corresponding private key.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Customizing Compute Budget, Fee & Priority | ComputeBudgetProgram | Rust\nDESCRIPTION: Provides a Rust example for adjusting compute budgets and prioritization fees using Solana's ComputeBudgetProgram. Instructions for setting compute unit price and limit are created and added to the transaction, which is then signed and sent over RPC. Dependencies include Solana Rust SDK and proper program imports.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/basic-transactions/compute-budget/computeBudget.en.rs))\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/basic-transactions/compute-budget/computeBudget.preview.en.rs))\n```\n\n----------------------------------------\n\nTITLE: Defining the AccountInfo Struct for Account Handling in Solana (Rust)\nDESCRIPTION: Provides the definition for `AccountInfo`, a central struct in Solana representing on-chain account state inside a program's instruction processing logic. It contains pointers to public key, signer and writable status, lamports and data, owner program, executable flag, and rent epoch. This struct is clonable and passed to CPIs and instruction parsers.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n/// Account information\\n#[derive(Clone)]\\npub struct AccountInfo<'a> {\\n    /// Public key of the account\\n    pub key: &'a Pubkey,\\n    /// Was the transaction signed by this account's public key?\\n    pub is_signer: bool,\\n    /// Is the account writable?\\n    pub is_writable: bool,\\n    /// The lamports in the account.  Modifiable by programs.\\n    pub lamports: Rc<RefCell<&'a mut u64>>,\\n    /// The data held in this account.  Modifiable by programs.\\n    pub data: Rc<RefCell<&'a mut [u8]>>,\\n    /// Program that owns this account\\n    pub owner: &'a Pubkey,\\n    /// This account's data contains a loaded program (and is now read-only)\\n    pub executable: bool,\\n    /// The epoch at which this account will next owe rent\\n    pub rent_epoch: Epoch,\\n}\n```\n\n----------------------------------------\n\nTITLE: Preview: Deactivating Stake Delegation in TypeScript\nDESCRIPTION: Provides a preview or runnable example snippet for deactivating stake delegation using `@solana/web3.js`. This likely demonstrates the deactivation process with simplified setup.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/deactivate-stake/deactivate-stake.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Account Balance using Solana-Web3.js in TypeScript\nDESCRIPTION: Demonstrates how to get the SOL balance (in Lamports) of a Solana account using the `getBalance` method from the `@solana/web3.js` library. Requires an initialized `Connection` object and the `PublicKey` of the account.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Constructing AccountMeta Entries for Solana Instructions (Rust Example)\nDESCRIPTION: Shows how to construct a vector of `AccountMeta` instances representing the roles of involved accounts in a CPI. This includes assigning signers, determining writable status, and mixing use of `AccountMeta::new` and `AccountMeta::new_readonly` for correct access declarations. This construction pattern simplifies CPI account setup for both mutable and immutable access.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse solana_program::instruction::AccountMeta;\\n\\nlet account_metas = vec![\\n    AccountMeta::new(account1_pubkey, true),\\n    AccountMeta::new(account2_pubkey, false),\\n    AccountMeta::new_readonly(account3_pubkey, false),\\n    AccountMeta::new_readonly(account4_pubkey, true),\\n]\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Keypair in C++\nDESCRIPTION: Shows how to generate a new Solana keypair within a C++ environment, likely utilizing a C++ Solana SDK or library. This process creates a new public and private key.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.en.cpp)\n```\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.preview.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Customizing Compute Budget, Fee & Priority | ComputeBudgetProgram | TypeScript\nDESCRIPTION: This TypeScript/TSX example increases transaction priority and/or compute units by adding ComputeBudgetProgram instructions to a transaction. Functions like setComputeUnitPrice and setComputeUnitLimit are used to set prioritization fee and compute budget. Needs solana/web3.js and access to a transaction builder. Appropriate for complex transactions or those requiring expedited confirmation.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/compute-budget/computeBudget.en.tsx)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/compute-budget/computeBudget.preview.en.tsx))\n```\n\n----------------------------------------\n\nTITLE: Creating a Candy Machine v2 instance - TypeScript\nDESCRIPTION: This code outlines the initialization of a new Candy Machine v2 via the Metaplex JS SDK. It configures all required parameters such as authority, wallet, collection details, and on-chain settings. Inputs include wallet keypair, NFTs configuration, and output is the PDA or address for the newly created Candy Machine. Proper account and authority management are vital for successful setup.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/create-candy-machine.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Initializing Metaplex and PDA Addresses in Solana Client (JavaScript)\nDESCRIPTION: Initializes core dependencies by importing Solana SPL Token and Metaplex libraries, configures the Metaplex instance, and prepares Program Derived Addresses (PDAs) for token mint and player accounts. Requires Metaplex JS SDK, Solana web3, and SPL Token installed in the environment. Key parameters include program IDs, connection objects, and player wallet public keys; these are essential for all downstream client operations and transaction signing.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_7\n\nLANGUAGE: js\nCODE:\n```\nimport { Metaplex } from \"@metaplex-foundation/js\";\nimport { getMint, getAssociatedTokenAddressSync } from \"@solana/spl-token\";\n\n// metaplex token metadata program ID\nconst TOKEN_METADATA_PROGRAM_ID = new web3.PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n\n// metaplex setup\nconst metaplex = Metaplex.make(pg.connection);\n\n// token metadata\nconst metadata = {\n  uri: \"https://raw.githubusercontent.com/solana-developers/program-examples/new-examples/tokens/tokens/.assets/spl-token.json\",\n  name: \"Solana Gold\",\n  symbol: \"GOLDSOL\",\n};\n\n// reward token mint PDA\nconst [rewardTokenMintPda] = anchor.web3.PublicKey.findProgramAddressSync(\n  [Buffer.from(\"reward\")],\n  pg.PROGRAM_ID\n);\n\n// player data account PDA\nconst [playerPDA] = anchor.web3.PublicKey.findProgramAddressSync(\n  [Buffer.from(\"player\"), pg.wallet.publicKey.toBuffer()],\n  pg.PROGRAM_ID\n);\n\n// reward token mint metadata account address\nconst rewardTokenMintMetadataPDA = await metaplex\n  .nfts()\n  .pdas()\n  .metadata({ mint: rewardTokenMintPda });\n\n// player token account address\nconst playerTokenAccount = getAssociatedTokenAddressSync(\n  rewardTokenMintPda,\n  pg.wallet.publicKey\n);\n```\n\n----------------------------------------\n\nTITLE: Getting Program Accounts with Solana CLI\nDESCRIPTION: Provides the Solana CLI command to retrieve all accounts owned by a specific program. The `solana program accounts <PROGRAM_ID>` command queries the cluster and lists the public keys of the owned accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/get-program-accounts/basic/basic.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Cloning AccountInfo for Use in Invocations (Rust Example)\nDESCRIPTION: Demonstrates cloning `AccountInfo` structs for each required account, using the implemented `Clone` trait from the `solana_program` crate. This is necessary for preparing the account vector needed by `invoke` or `invoke_signed`. Ensures the program passes valid, independent account references to downstream instructions in a CPI context.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/core-concepts/cpi.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet accounts_infos = [\\n    account_one.clone(),\\n    account_two.clone(),\\n    account_three.clone(),\\n];\n```\n\n----------------------------------------\n\nTITLE: Connecting to Solana Wallet in Vue\nDESCRIPTION: Shows how to integrate Solana wallet connectivity into a Vue application using the `solana-wallets-vue` plugin. Initializes the wallet store, provides a global `$wallet` property, and uses the `WalletMultiButton` component for the user interface.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_39\n\nLANGUAGE: vue\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/connect-to-wallet/connect-to-wallet-vue.en.vue)\n```\n\nLANGUAGE: vue\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/connect-to-wallet/connect-to-wallet-vue.preview.en.vue)\n```\n\n----------------------------------------\n\nTITLE: Fetching Delegators for a Specific Validator in TypeScript\nDESCRIPTION: Shows how to find all stake accounts delegated to a specific validator using `connection.getParsedProgramAccounts`. It filters accounts belonging to the Stake Program (`STAKE_PROGRAM_ID`) based on their size (200 bytes for stake accounts) and a memory comparison (`memcmp`) to match the validator's vote public key (`VOTE_PUB_KEY`) at the correct offset (124 bytes). This example connects to mainnet-beta and logs the total number of delegators found and details of a sample delegator account.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/references/staking.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst STAKE_PROGRAM_ID = new PublicKey(\n  \"Stake11111111111111111111111111111111111111\"\n);\nconst VOTE_PUB_KEY = \"27MtjMSAQ2BGkXNuJEJkxFyCJT8dugGAaHJ9T7Gc6x4x\";\n\nconst connection = new Connection(clusterApiUrl(\"mainnet-beta\"), \"confirmed\");\nconst accounts = await connection.getParsedProgramAccounts(STAKE_PROGRAM_ID, {\n  filters: [\n    {\n      dataSize: 200, // number of bytes\n    },\n    {\n      memcmp: {\n        offset: 124, // number of bytes\n        bytes: VOTE_PUB_KEY, // base58 encoded string\n      },\n    },\n  ],\n});\n\nconsole.log(`Accounts for program ${STAKE_PROGRAM_ID}: `);\nconsole.log(\n  `Total number of delegators found for ${VOTE_PUB_KEY} is: ${accounts.length}`\n);\nif (accounts.length)\n  console.log(`Sample delegator:`, JSON.stringify(accounts[0]));\n\n/*\n// Output\n\n  Accounts for program Stake11111111111111111111111111111111111111: \n  Total number of delegators found for 27MtjMSAQ2BGkXNuJEJkxFyCJT8dugGAaHJ9T7Gc6x4x is: 184\n  Sample delegator: \n  {\n    \"account\": {\n      \"data\": {\n        \"parsed\": {\n          \"info\": {\n            \"meta\": {\n              \"authorized\": {\n                \"staker\": \"3VDVh3rHTLkNJp6FVYbuFcaihYBFCQX5VSBZk23ckDGV\",\n                \"withdrawer\": \"EhYXq3ANp5nAerUpbSgd7VK2RRcxK1zNuSQ755G5Mtxx\"\n              },\n              \"lockup\": {\n                \"custodian\": \"3XdBZcURF5nKg3oTZAcfQZg8XEc5eKsx6vK8r3BdGGxg\",\n                \"epoch\": 0,\n                \"unixTimestamp\": 1822867200\n              },\n              \"rentExemptReserve\": \"2282880\"\n            },\n            \"stake\": {\n              \"creditsObserved\": 58685367,\n              \"delegation\": {\n                \"activationEpoch\": \"208\",\n                \"deactivationEpoch\": \"18446744073709551615\",\n                \"stake\": \"433005300621\",\n                \"voter\": \"27MtjMSAQ2BGkXNuJEJkxFyCJT8dugGAaHJ9T7Gc6x4x\",\n                \"warmupCooldownRate\": 0.25\n              }\n            }\n          },\n          \"type\": \"delegated\"\n        },\n        \"program\": \"stake\",\n        \"space\": 200\n      },\n      \"executable\": false,\n      \"lamports\": 433012149261,\n      \"owner\": {\n        \"_bn\": \"06a1d8179137542a983437bdfe2a7ab2557f535c8a78722b68a49dc000000000\"\n      },\n      \"rentEpoch\": 264\n    },\n    \"pubkey\": {\n      \"_bn\": \"0dc8b506f95e52c9ac725e714c7078799dd3268df562161411fe0916a4dc0a43\"\n    }\n  }\n  \n*/\n```\n\n----------------------------------------\n\nTITLE: Checking Solana Public Key Validity in TypeScript\nDESCRIPTION: Demonstrates checking if a Solana public key lies on the ed25519 curve using the Solana Web3.js library. This is used to determine if a public key can have an associated private key (unlike PDAs).\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.preview.ts)\n```\n\n----------------------------------------\n\nTITLE: Resizing a Program-Owned Account Using realloc in Solana (Rust)\nDESCRIPTION: Shows use of the realloc method in a Rust Solana program to change an account's size, up to 10KB. After increasing size, additional lamports must be transferred to maintain rent-exemption. Requires mutable program-owned account, and potentially the system program for lamport transfer. Input: account info and desired new size. Output: resized account and updated lamport balance.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/programs/realloc/realloc.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Calculating Rent Exemption Cost in TypeScript\nDESCRIPTION: Provides a TypeScript function to calculate the minimum lamports required for an account to be rent-exempt on Solana. It uses the `connection.getMinimumBalanceForRentExemption` method from `@solana/web3.js`, taking the desired account data size in bytes as input.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/rent-exemption/rent-exemption.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Preview: Retrieving Account Balance using Solana-Py in Python\nDESCRIPTION: A concise preview showing the core `get_balance` call using the `solana-py` library's RPC client in Python to get an account's SOL balance. Assumes `client` and `pubkey` are defined.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Searching for Candy Machines by Authority - TypeScript\nDESCRIPTION: This code leverages the findAllBy function from Metaplex JS to enumerate all Candy Machine v2 programs under a specific authority's control. You must specify the authority public key; outputs are a list of Candy Machine objects. Its important to select the correct search type and handle pagination as required by large authority accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/find-via-authority.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Public Solana Clusters using C++\nDESCRIPTION: Illustrates connecting to Solana's public RPC endpoints (mainnet-beta, devnet, testnet) in C++. This likely involves using a C++ library or direct HTTP/WebSocket calls to interact with the RPC API, specifying the cluster URL.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/local-development/connecting-cluster/connecting-cluster.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Airdropping SOL via Solana CLI Command Shell Script\nDESCRIPTION: This shell script snippet shows how to use the Solana CLI to airdrop SOL to a specified wallet address. Dependencies include the Solana CLI being installed and properly configured with the right cluster. Inputs are usually the recipient public key and desired SOL amount, and the script outputs transaction signature or CLI status. This approach is helpful for quick local tests or automation within development environments.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.preview.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Checking Solana Public Key Validity in Python\nDESCRIPTION: Illustrates how to check if a Solana public key is on the ed25519 curve using the Solana Python library. Keys on the curve can have associated private keys, distinguishing them from PDAs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/check-valid-publickey/check-valid-publickey.preview.py)\n```\n\n----------------------------------------\n\nTITLE: Adding Memo to Transaction | Memo Program | TSX\nDESCRIPTION: Adds a memo to a Solana transaction using the Memo Program in a React environment with Solana Wallet-Adapter. The memo instruction is appended and the user approves via the connected wallet extension. Requires wallet context, memo text, and solana/web3.js. Suitable for dApps that require memo inclusion.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/memo/memo.adapter.en.tsx)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/memo/memo.adapter.preview.en.tsx)\n```\n\n----------------------------------------\n\nTITLE: Performing Reverse Lookup for Domain Name in TypeScript\nDESCRIPTION: This snippet shows how to find the .SOL domain name associated with a given Solana PublicKey using TypeScript. It involves querying the Solana Name Service. Dependencies include `@solana/web3.js` and `@solana/spl-name-service`. Expects a PublicKey as input and returns the associated domain name if found.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/name-service.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/reverse-look-up-domain/reverse-look-up-domain.en.ts)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/reverse-look-up-domain/reverse-look-up-domain.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Vanity Address using CLI\nDESCRIPTION: Uses the Solana CLI `solana-keygen grind` command to efficiently generate a vanity address (keypair with a specific public key prefix). This is the recommended method due to its speed.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_33\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Implementing Upgraded Processor Logic (v1) with Migration Handling in Rust\nDESCRIPTION: Implements the updated processor logic (`process_instruction`) for the upgraded version (v1) of the Solana program in Rust. It handles both old and new instructions. When processing an account, it checks the `data_version`. If it encounters an older version, it uses the `unpack` method (which incorporates the `conversion_logic` from the account state definition) to migrate the data to the v1 structure before proceeding with the instruction logic. It then uses `pack` to serialize the potentially upgraded state back to the account.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/zh/guides/data-migration.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.processor1.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Resolving Twitter Handle to Solana Address in TypeScript\nDESCRIPTION: This snippet shows how to resolve a Twitter handle that has been registered with the Solana Name Service (e.g., via Bonfida) to its associated Solana address using TypeScript. It requires libraries capable of interacting with the specific name service implementation used for Twitter handles.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/name-service.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/resolve-twitter/resolve-twitter.en.ts)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/resolve-twitter/resolve-twitter.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Implementing Player Movement Logic with Anchor (Rust)\nDESCRIPTION: This Rust code defines the entire Tiny Adventure Solana program using the Anchor framework, implementing stateful operations for moving a player left or right along a linear path on-chain. It includes account validation, PDA initialization, helper functions for outputting progress, and the account structure for tracking player position. Dependencies include anchor_lang, a Solana Playground environment (devnet), and a compatible Anchor workspace setup. Inputs are transaction instructions; outputs are both state updates and string messages viewable in the Solana logs. The code is limited to four positions (0-3), and relies on a specific PDA seed ('level1').\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse anchor_lang::prelude::*;\n\n// This is your program's public key and it will update\n// automatically when you build the project.\ndeclare_id!(\"BouPBVWkdVHbxsdzqeMwkjqd5X67RX5nwMEwxn8MDpor\");\n\n#[program]\nmod tiny_adventure {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {\n        ctx.accounts.new_game_data_account.player_position = 0;\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.......\");\n        Ok(())\n    }\n\n    pub fn move_left(ctx: Context<MoveLeft>) -> Result<()> {\n        let game_data_account = &mut ctx.accounts.game_data_account;\n        if game_data_account.player_position == 0 {\n            msg!(\"You are back at the start.\");\n        } else {\n            game_data_account.player_position -= 1;\n            print_player(game_data_account.player_position);\n        }\n        Ok(())\n    }\n\n    pub fn move_right(ctx: Context<MoveRight>) -> Result<()> {\n        let game_data_account = &mut ctx.accounts.game_data_account;\n        if game_data_account.player_position == 3 {\n            msg!(\"You have reached the end! Super!\");\n        } else {\n            game_data_account.player_position = game_data_account.player_position + 1;\n            print_player(game_data_account.player_position);\n        }\n        Ok(())\n    }\n}\n\nfn print_player(player_position: u8) {\n    if player_position == 0 {\n        msg!(\"A Journey Begins!\");\n        msg!(\"o.......\");\n    } else if player_position == 1 {\n        msg!(\"..o.....\");\n    } else if player_position == 2 {\n        msg!(\"....o...\");\n    } else if player_position == 3 {\n        msg!(\"........\\\\o/\");\n        msg!(\"You have reached the end! Super!\");\n    }\n}\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    #[account(\n        init_if_needed,\n        seeds = [b\"level1\"],\n        bump,\n        payer = signer,\n        space = 8 + 1\n    )]\n    pub new_game_data_account: Account<'info, GameDataAccount>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[derive(Accounts)]\npub struct MoveLeft<'info> {\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n}\n\n#[derive(Accounts)]\npub struct MoveRight<'info> {\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n}\n\n#[account]\npub struct GameDataAccount {\n    player_position: u8,\n}\n\n```\n\n----------------------------------------\n\nTITLE: Getting Account Balance using Rust\nDESCRIPTION: This Rust snippet shows how to use the `solana-client` crate to get an account's balance. It establishes an RPC connection and calls the `get_balance` method, passing the public key of the target account.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Wallet-Adapter Core Packages via Yarn\nDESCRIPTION: Installs the base Solana wallet-adapter packages (@solana/wallet-adapter-wallets, @solana/wallet-adapter-base) using Yarn. These are foundational for integrating various Solana wallets into dApps across frameworks like React, Vue, Angular, and Svelte.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @solana/wallet-adapter-wallets \\\n    @solana/wallet-adapter-base\n```\n\n----------------------------------------\n\nTITLE: Scaffolding a Solana dApp with create-solana-dapp (JavaScript)\nDESCRIPTION: This command uses npx to run `create-solana-dapp`, generating a starter Solana decentralized application template named 'your-app'. It's presented as the fastest way to set up Next.js/React projects with built-in wallet-adapter support, suitable for web-based Solana interactions. Requires Node.js and npm/npx.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/game-sdks.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nnpx create-solana-dapp your-app\n```\n\n----------------------------------------\n\nTITLE: Building and Running Solana Cookbook Documentation (Shell)\nDESCRIPTION: Lists the shell commands required to install dependencies (`yarn install`) and start the development server (`yarn start`) for the Solana Cookbook documentation. These commands are intended to be run within the project's development environment, potentially a dev container, to view the documentation locally.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nyarn install\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Defining Move Right Instruction with Reward Logic in Rust (Anchor)\nDESCRIPTION: This Rust snippet defines the `move_right` instruction within an Anchor program (`tiny_adventure_two`). It takes a `password` string as input. If the player is at position 2, it checks if the password is \"gib\". If correct, it increments the position to 3, logs a message, and directly transfers `CHEST_REWARD` lamports from the `chest_vault` PDA to the `player` account by modifying their lamport balances using `try_borrow_mut_lamports`. If the password is wrong, it returns a custom `MyError::WrongPassword` error. If the player is already at position 3, it logs a message. Otherwise, it increments the player position. The `MoveRight` struct defines the required accounts (chest vault PDA, game data, player signer), and `MyError` defines the custom error.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod tiny_adventure_two {\n    use super::*;\n    ...\n\n    // Instruction to move right\n    pub fn move_right(ctx: Context<MoveRight>, password: String) -> Result<()> {\n        let game_data_account = &mut ctx.accounts.game_data_account;\n        if game_data_account.player_position == 3 {\n            msg!(\"You have reached the end! Super!\");\n        } else if game_data_account.player_position == 2 {\n            if password != \"gib\" {\n                return err!(MyError::WrongPassword);\n            }\n\n            game_data_account.player_position = game_data_account.player_position + 1;\n\n            msg!(\n                \"You made it! Here is your reward {0} lamports\",\n                CHEST_REWARD\n            );\n\n            **ctx\n                .accounts\n                .chest_vault\n                .to_account_info()\n                .try_borrow_mut_lamports()? -= CHEST_REWARD;\n            **ctx\n                .accounts\n                .player\n                .to_account_info()\n                .try_borrow_mut_lamports()? += CHEST_REWARD;\n        } else {\n            game_data_account.player_position = game_data_account.player_position + 1;\n            print_player(game_data_account.player_position);\n        }\n        Ok(())\n    }\n\n    ...\n}\n\n// Specify the accounts required by the move_right instruction\n#[derive(Accounts)]\npub struct MoveRight<'info> {\n    #[account(mut, seeds = [b\"chestVault\"], bump)]\n    pub chest_vault: Account<'info, ChestVaultAccount>,\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n    #[account(mut)]\n    pub player: Signer<'info>,\n}\n\n// Custom Anchor Error\n#[error_code]\npub enum MyError {\n    #[msg(\"Password was wrong\")]\n    WrongPassword,\n}\n\n...\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Vanity Address in Python\nDESCRIPTION: Creates a Solana keypair with a public key matching a desired prefix (vanity address) using Python. Note that this approach is primarily illustrative and significantly slower than the CLI.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Setting PATH for Solana CLI Binaries on Windows\nDESCRIPTION: Commands run in Command Prompt after extracting Solana binaries manually on Windows. Navigates into the release directory and updates the PATH environment variable for the current session to include the `bin` directory.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_22\n\nLANGUAGE: batch\nCODE:\n```\ncd solana-release/\n```\n\nLANGUAGE: batch\nCODE:\n```\nset PATH=%cd%/bin;%PATH%\n```\n\n----------------------------------------\n\nTITLE: Verifying Solana Keypair in TypeScript\nDESCRIPTION: Shows how to verify if a given secret key corresponds to a specific public key using the Solana Web3.js library. This typically involves reconstructing the keypair from the secret and comparing its public key.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Editing System Profile for PATH Update on Linux\nDESCRIPTION: Opens the system-wide profile configuration file (`/etc/profile`) using the nano text editor with superuser privileges. This file is edited to add the Solana CLI binary directory to the system's PATH variable for all users.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nsudo nano /etc/profile\n```\n\n----------------------------------------\n\nTITLE: Initializing Solana Connection for Game Client - JavaScript\nDESCRIPTION: Establishes a connection to Solana's devnet cluster using the web3.js Connection class in JavaScript. The confirmation parameter is set to 'confirmed' for speed and reliability, balancing performance with safety in game settings. Prerequisites: @solana/web3.js package, network URL. Input is the devnet endpoint, output is a usable connection object for transactions and subscriptions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/energy-system.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nexport const connection = new Connection(\n    \"https://api.devnet.solana.com\",\n    \"confirmed\"\n);\n```\n\n----------------------------------------\n\nTITLE: Connecting to Public Solana Clusters using Rust\nDESCRIPTION: Provides an example of connecting to Solana's public RPC endpoints (mainnet-beta, devnet, testnet) using Rust, typically utilizing the `solana-client` crate. This involves creating an RPC client instance configured with the cluster URL.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/local-development/connecting-cluster/connecting-cluster.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Token Gating Access with Metaplex SDK in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use the Metaplex SDK to check asset ownership for token gating in Solana-based games. It loads a wallet keypair from a JSON file, initializes the Metaplex client with the keypair, queries all NFTs owned by the player, and filters them based on a collection address. Dependencies include @metaplex-foundation/js and Solana Web3 libraries. Key inputs are the path to the keypair and the collectionAddress, and the output is a filtered array of NFTs belonging to a given collection.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/nfts-in-games.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nJSON.parse(\n  // For example '.config/solana/devnet.json'\n  fs.readFileSync(\"yourKeyPair.json\").toString())\n);\nlet keyPair = Keypair.fromSecretKey(decodedKey);\n\nconst metaplex = Metaplex.make(connection).use(keypairIdentity(keyPair));\n\nconst nfts = await metaplex\n  .nfts()\n  .findAllByOwner({ owner: wallet.publicKey })\n\nlet collectionNfts = []\nfor (let i = 0; i < nfts.length; i++) {\n  if (nfts[i].collection?.address.toString() == collectionAddress.toString()) {\n    collectionNfts.push(nfts[i])\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Blog and Post Account PDAs (TypeScript)\nDESCRIPTION: Client-side TypeScript code demonstrating how to compute PDAs for Blog and Post accounts using PublicKey.findProgramAddress(), and how to retrieve account information with connection.getAccountInfo(). It is used to interact with on-chain programs from a Node.js or browser client, requiring @solana/web3.js and program ID as dependencies. Inputs include user's public key and post slug; outputs are fetched or derived account data from the blockchain. This snippet is for clients interfacing with Solana programs using account mapping via PDAs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/account-maps.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/account-maps/deriving-pda/client.ts)\n```\n\n----------------------------------------\n\nTITLE: Preview: Retrieving Account Balance using Solana-CPP SDK in C++\nDESCRIPTION: A brief preview snippet showing the essential `getBalance` call in C++ using a Solana C++ SDK to retrieve an account's SOL balance. Assumes client and public key variables are set up.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Defining and Initializing Player Data Account in Rust (Anchor)\nDESCRIPTION: This Rust code defines the structure `PlayerData` for storing game player information and the `InitPlayer` accounts context for initializing this data. The `init_player` function sets initial values for energy, health, and last login time. The `PlayerData` account is defined as a Program Derived Address (PDA) seeded by the string \"player\" and the signer's public key, ensuring each player wallet can have one unique data account. It uses the Anchor framework attributes for account initialization and definition.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/saving-game-state.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn init_player(ctx: Context<InitPlayer>) -> Result<()> {\n    ctx.accounts.player.energy = MAX_ENERGY;\n    ctx.accounts.player.health = MAX_HEALTH;\n    ctx.accounts.player.last_login = Clock::get()?.unix_timestamp;\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct InitPlayer <'info> {\n    #[account( \n        init, \n        payer = signer,\n        space = 1000,\n        seeds = [b\"player\".as_ref(), signer.key().as_ref()],\n        bump,\n    )]\n    pub player: Account<'info, PlayerData>,\n    #[account(mut)]\n    pub signer: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct PlayerData {\n    pub name: String,\n    pub level: u8,\n    pub xp: u64,\n    pub health: u64,\n    pub log: u64,\n    pub energy: u64,\n    pub last_login: i64\n}\n\n```\n\n----------------------------------------\n\nTITLE: Moving Player and Collecting Chest Reward - Game Loop with Anchor - JavaScript\nDESCRIPTION: This loop repeatedly calls the `moveRight` instruction to progress the player's position toward the chest and collects the reward when the end is reached. After each move, it confirms the transaction, displays SOL balance, fetches updated game data, and prints the player's current state on the level using ASCII graphics. The code expects the correct password; otherwise, an error is thrown. Dependencies: previous PDA setup, Anchor client, sufficient funds, and compatible game program. Inputs: instruction parameter (password); outputs: updated balances, position, and on-chain status logs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\n\n// Here we move to the right three times and collect the chest at the end of the level\nfor (let i = 0; i < 3; i++) {\n  txHash = await pg.program.methods\n    .moveRight(\"gib\")\n    .accounts({\n      chestVault: chestVaultAccount,\n      gameDataAccount: globalLevel1GameDataAccount,\n      player: pg.wallet.publicKey,\n    })\n    .signers([pg.wallet.keypair])\n    .rpc();\n\n  console.log(`Use 'solana confirm -v ${txHash}' to see the logs`);\n  await pg.connection.confirmTransaction(txHash);\n  let balance = await pg.connection.getBalance(pg.wallet.publicKey);\n  console.log(`My balance: ${balance / web3.LAMPORTS_PER_SOL} SOL`);\n\n  let gameDateAccount = await pg.program.account.gameDataAccount.fetch(\n    globalLevel1GameDataAccount\n  );\n\n  console.log(\"Player position is:\", gameDateAccount.playerPosition.toString());\n\n  switch (gameDateAccount.playerPosition) {\n    case 0:\n      console.log(\"A journey begins...\");\n      console.log(\"o........\");\n      break;\n    case 1:\n      console.log(\"....o....\");\n      break;\n    case 2:\n      console.log(\"......o..\");\n      break;\n    case 3:\n      console.log(\".........\\\\o/\");\n      console.log(\"...........\\\\o/\");\n      break;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Preview: Creating a Solana Stake Account in TypeScript\nDESCRIPTION: Provides a preview or runnable example snippet for creating a Solana stake account using `@solana/web3.js`. This likely simplifies setup for quick testing.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/create-stake-account/create-stake-account.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Serializing/Deserializing COption in Solana Programs - Rust\nDESCRIPTION: Provides Rust-side demonstration of handling COption types, both serializing and deserializing, to remain compatible with TypeScript client-side logic and Borsh encoding. Relies on borsh-derive and Solana's COption implementation.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/coption/src/main.rs)\n```\n\n----------------------------------------\n\nTITLE: Defining Python Dependencies for Solana Projects - Plaintext\nDESCRIPTION: This snippet lists required Python packages for working with Solana and Borsh serialization in a project. The dependencies include 'borsh-construct' and 'solana', each with specific version constraints, typically used in a 'requirements.txt' file. No code is present, only package specifications for automated dependency management; expected usage is through a package installer like pip.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/code/serialization/setup/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nborsh-construct==0.1.0\nsolana==0.20.0\n```\n\n----------------------------------------\n\nTITLE: Defining Reset and Spawn Chest Instruction in Rust (Anchor)\nDESCRIPTION: This Rust snippet defines the `reset_level_and_spawn_chest` instruction within an Anchor program (`tiny_adventure_two`). It resets the `player_position` in the `GameDataAccount` to 0. It then performs a Cross-Program Invocation (CPI) to the Solana `system_program` to transfer `CHEST_REWARD` lamports from the `payer` account to the `chest_vault` PDA. The required accounts are defined in the `SpawnChest` struct, including mutable references to the payer, chest vault, game data, and the system program itself.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[program]\npub mod tiny_adventure_two {\n    use super::*;\n    ...\n\n    pub fn reset_level_and_spawn_chest(ctx: Context<SpawnChest>) -> Result<()> {\n        ctx.accounts.game_data_account.player_position = 0;\n\n        let cpi_context = CpiContext::new(\n            ctx.accounts.system_program.to_account_info(),\n            system_program::Transfer {\n                from: ctx.accounts.payer.to_account_info().clone(),\n                to: ctx.accounts.chest_vault.to_account_info().clone(),\n            },\n        );\n        system_program::transfer(cpi_context, CHEST_REWARD)?;\n\n        msg!(\"Level Reset and Chest Spawned at position 3\");\n\n        Ok(())\n    }\n\n    ...\n}\n\n// Specify the accounts required by the reset_level_and_spawn_chest instruction\n#[derive(Accounts)]\npub struct SpawnChest<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    #[account(mut, seeds = [b\"chestVault\"], bump)]\n    pub chest_vault: Account<'info, ChestVaultAccount>,\n    #[account(mut)]\n    pub game_data_account: Account<'info, GameDataAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n...\n```\n\n----------------------------------------\n\nTITLE: Serializing Instruction Data on Solana Client - Python\nDESCRIPTION: Shows how to serialize instruction data from a Python client for submission to a Solana program. Utilizes borsh-construct and a matching borsh schema to align with program expectations. Inputs are instruction parameters and outputs are the serialized bytes.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/serialization/instruction/python.client.py)\n```\n\n----------------------------------------\n\nTITLE: Chopping Trees and Awarding Resources - Anchor Solana Program - Rust\nDESCRIPTION: Implements the chop_tree instruction for a lumberjack game mechanic on Solana. The code checks for sufficient energy, rewards one wood per successful chop, and decrements energy accordingly. If not enough energy is available, a custom error (NotEnoughEnergy) is thrown. The update_energy function ensures the player's energy is current before proceeding. This logic requires prior setup of player data and consistency with energy constraints. Inputs are player account context, outputs are updated player state and logging to chain.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/energy-system.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n    #[error_code]\n    pub enum ErrorCode {\n        #[msg(\"Not enough energy\")]\n        NotEnoughEnergy,\n    }\n\n    pub fn chop_tree(mut ctx: Context<ChopTree>) -> Result<()> {\n        let account = &mut ctx.accounts;\n        update_energy(account)?;\n\n        if ctx.accounts.player.energy == 0 {\n            return err!(ErrorCode::NotEnoughEnergy);\n        }\n\n        ctx.accounts.player.wood = ctx.accounts.player.wood + 1;\n        ctx.accounts.player.energy = ctx.accounts.player.energy - 1;\n        msg!(\"You chopped a tree and got 1 wood. You have {} wood and {} energy left.\", ctx.accounts.player.wood, ctx.accounts.player.energy);\n        Ok(())\n    }\n```\n\n----------------------------------------\n\nTITLE: Preview: Getting Account Balance using Rust\nDESCRIPTION: This preview Rust snippet provides the surrounding code or a runnable example for the main Rust balance retrieval logic. It includes necessary imports and potentially error handling for the `get_balance` call.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Adding Memo to Transaction | Memo Program | TypeScript\nDESCRIPTION: Attaches a memo to any Solana transaction using the Memo Program in solana/web3.js. The instruction is added to the transaction specifying the memo as a string. Input: memo text, transaction instance. Output: transaction with memo included. Manual setup of Memo Program ID is required.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/memo/memo.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/memo/memo.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Private Solana Cluster using TypeScript\nDESCRIPTION: Demonstrates how to establish a connection to a private Solana RPC endpoint (local or remote) using the `@solana/web3.js` library in TypeScript. It requires specifying the custom URL of the private cluster when creating the `Connection` object.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/local-development/connecting-private-cluster/connecting-private-cluster.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Creating a Solana Stake Account in TypeScript\nDESCRIPTION: Demonstrates how to create a new Solana stake account using the `@solana/web3.js` library and interacting with the Stake Program. This involves initializing the account and setting its Stake Authority and Withdrawal Authority.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/create-stake-account/create-stake-account.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Performing Reverse Lookup for Twitter Handle in TypeScript\nDESCRIPTION: This snippet demonstrates how to find the registered Twitter handle associated with a given Solana address using TypeScript. This involves performing a reverse lookup query against the Solana Name Service or the specific service used for Twitter handle registration.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/name-service.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/reverse-look-up-twitter/reverse-look-up-twitter.en.ts)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/reverse-look-up-twitter/reverse-look-up-twitter.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Preview: Getting Account Balance using C++\nDESCRIPTION: This preview C++ snippet provides the necessary context or a complete example for running the main C++ balance retrieval code. It likely includes setup for the connection, handling includes, and calling the core balance function.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_29\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Finding All Domain Names Owned by a PublicKey in TypeScript\nDESCRIPTION: This snippet demonstrates how to retrieve all domain names registered under a specific Solana PublicKey using TypeScript. It utilizes the `getProgramAccounts` method with a `memcmp` filter to query the Name Service program accounts based on the owner field. Requires `@solana/web3.js` and the owner's PublicKey.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/name-service.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/find-for-owner/find-for-owner.en.ts)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/find-for-owner/find-for-owner.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Rust Test Case Disabling 'Transaction Wide Compute Cap' Feature\nDESCRIPTION: References a Rust test case (located in `@/code/feature-parity-testing/deactivate_two.rs`) that demonstrates programmatic feature parity testing. This test specifically configures the `solana-program-test` validator to run with the 'transaction wide compute cap' feature deactivated, using its public key, thus simulating older cluster behavior or specific testing requirements.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n// Referenced code from @/code/feature-parity-testing/deactivate_two.rs\n// This test likely calls the boilerplate setup function, providing the \n// public key of the 'transaction wide compute cap' feature to deactivate it.\n\n/* Example structure (conceptual based on context):\nuse solana_sdk::pubkey;\n\nconst FEATURE_ID_TRANSCTION_WIDE_COMPUTE_CAP: Pubkey = pubkey!(\"5ekBxc8itEnPv4NzGJtr8BVVQLNMQuLMNQQj7pHoLNZ9\");\n\n#[tokio::test]\nasync fn test_without_tx_compute_cap() {\n    // Uses the boilerplate helper, passing the specific feature ID\n    let (mut banks_client, payer, recent_blockhash) = run_test_with_features(\n        /* program_id */, \n        /* program_path */, \n        vec![FEATURE_ID_TRANSCTION_WIDE_COMPUTE_CAP] // Deactivate this feature\n    ).await;\n\n    // ... rest of the test logic ...\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Rust Test Case Achieving Devnet Feature Parity using `scfs`\nDESCRIPTION: References a Rust test case (located in `@/code/feature-parity-testing/deactivate_scfs.rs`) demonstrating how to achieve full feature parity with a specific cluster (like devnet) programmatically. It likely uses the `gadget-scfs` crate or a similar mechanism to fetch the list of features currently deactivated on devnet and then configures the `solana-program-test` validator to start with exactly those features disabled.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n// Referenced code from @/code/feature-parity-testing/deactivate_scfs.rs\n// This test likely uses the `gadget-scfs` crate or similar to get a list\n// of deactivated features for a target cluster (e.g., devnet) and then passes\n// this list to the test boilerplate setup function.\n\n/* Example structure (conceptual based on context):\nuse gadget_scfs::rpc_scfs::{RpcScfs, SolanaRpc}; // Assuming usage of this crate\n\n#[tokio::test]\nasync fn test_with_devnet_parity() {\n    // Fetch deactivated features for devnet\n    let scfs = RpcScfs::new(SolanaRpc::Devnet);\n    let devnet_deactivated_features = scfs.get_features(Some(false), None).await.unwrap();\n    let feature_pks: Vec<Pubkey> = devnet_deactivated_features.iter().map(|f| f.feature_id).collect();\n\n    // Uses the boilerplate helper, passing the fetched feature list\n    let (mut banks_client, payer, recent_blockhash) = run_test_with_features(\n        /* program_id */, \n        /* program_path */, \n        feature_pks // Deactivate features to match devnet\n    ).await;\n\n    // ... rest of the test logic ...\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Airdropping SOL Using Solana Rust Client\nDESCRIPTION: This Rust code demonstrates performing a test SOL airdrop via Rust client libraries, typically using solana-client or related crates. It connects to a Solana node, builds an airdrop request for a given public key and lamport amount, and awaits confirmation. The code expects the developer to have appropriate dependencies and network setup, and outputs transaction confirmation or error details. Suitable for developers building Solana tools or integrations in Rust.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Private Solana Cluster using Rust\nDESCRIPTION: Provides an example of connecting to a private Solana RPC endpoint (local or remote) using Rust, likely with the `solana-client` crate. The custom cluster URL is used when creating the RPC client instance.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/local-development/connecting-private-cluster/connecting-private-cluster.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Defining Upgraded Account State (v1) with Migration Logic in Rust\nDESCRIPTION: Defines the Rust structures for the upgraded Solana program account (v1). It preserves the old structure (`AccountContentOld`), defines the new structure (`AccountContentCurrent`) with an added `somestring` field, bumps the `DATA_VERSION` constant, and crucially, includes `conversion_logic` to upgrade from the old structure to the new one. It utilizes `try_from_slice_unchecked` for potentially reading partial data during migration.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/zh/guides/data-migration.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v1.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v1.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Creating Durable Nonce Accounts with Solana in TypeScript\nDESCRIPTION: This example shows how to create a durable nonce account in Solana with TypeScript, using the @solana/web3.js library. It initializes an account specifically for holding a durable nonce, allowing transactions to reference a never-expired blockhash. Key parameters include the fee payer, authorized public key, and rent exemption lamports. Returns a transaction instruction for account creation. Limitations include the requirement of sufficient lamports and proper account setup.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/offline-transactions.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/durable-nonce/create-nonce-account/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/offline-transactions/durable-nonce/create-nonce-account/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Configuring Solana CLI for Private Cluster\nDESCRIPTION: Shows how to configure the Solana CLI to connect to a private Solana cluster (local or remote) using the `solana config set --url` command with the custom endpoint URL.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/connecting-private-cluster/connecting-private-cluster.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Including @solana/web3.js via Browser Script (Development)\nDESCRIPTION: Includes the un-minified development version of the @solana/web3.js library directly in an HTML file using a script tag from unpkg CDN. This allows using the library in browser-based applications without a build step.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<!-- Development (un-minified) -->\n<script src=\"https://unpkg.com/@solana/web3.js@latest/lib/index.iife.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Implementing Initial Processor Logic (v0) in Rust\nDESCRIPTION: Implements the core processing logic (`process_instruction`) for the initial version (v0) of the Solana program in Rust. This function handles incoming instructions defined in `VersionProgramInstruction` (v0), deserializes account data matching `AccountContentCurrent` (v0), performs actions, and serializes the updated state back.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/zh/guides/data-migration.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.processor.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.processor.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Processor Usage Preview - Solana Program - Rust\nDESCRIPTION: Demonstrates how the processor logic is used or tested with sample data, typically showing call patterns for instruction handling. Provides context for how the processor operates on the version 0 account. Same dependencies as the main processor; inputs are serialized instruction/account data, outputs are processed states.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.processor.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Building Solana CLI from Source\nDESCRIPTION: Commands to build the Solana CLI from source code after downloading and extracting the source archive. It uses the provided cargo script to build all necessary components, updates the PATH for the current session, and initializes the Solana installation.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/cargo-install-all.sh .\n```\n\nLANGUAGE: bash\nCODE:\n```\nexport PATH=$PWD/bin:$PATH\n```\n\nLANGUAGE: bash\nCODE:\n```\nsolana-install init\n```\n\n----------------------------------------\n\nTITLE: Getting Account Balance using Python\nDESCRIPTION: This Python snippet demonstrates retrieving an account balance using the `solana-py` library. It involves creating a `Client` instance connected to a Solana cluster and calling the `get_balance` method with the account's public key.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.py)\n```\n\n----------------------------------------\n\nTITLE: Deserializing Account Data on Client - Python\nDESCRIPTION: Demonstrates using Python and borsh-construct to deserialize account data fetched from Solana. Parses serialized flags and reconstructs underlying account key/value states using a predefined mapping schema. Suitable for integration with Python-based analytics or bots interfacing with Solana.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/serialization/clientdata/python.client.data.py)\n```\n\n----------------------------------------\n\nTITLE: Calculating and Refilling Player Energy - Anchor Solana Program - Rust\nDESCRIPTION: Calculates the player's current energy based on elapsed time using lazy evaluation. If enough time has passed since last_login, energy increments towards MAX_ENERGY at intervals defined by TIME_TO_REFILL_ENERGY. Updates player's last_login based on how much energy was restored. Inputs are reference to the player account context, outputs are updated energy and timestamp state. Ensure constants are set appropriately and Clock sysvar is available.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/energy-system.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nconst TIME_TO_REFILL_ENERGY: i64 = 60;\nconst MAX_ENERGY: u64 = 10;\n\npub fn update_energy(ctx: &mut ChopTree) -> Result<()> {\n    let mut time_passed: i64 = &Clock::get()?.unix_timestamp - &ctx.player.last_login;\n    let mut time_spent: i64 = 0;\n    while time_passed > TIME_TO_REFILL_ENERGY {\n        ctx.player.energy = ctx.player.energy + 1;\n        time_passed -= TIME_TO_REFILL_ENERGY;\n        time_spent += TIME_TO_REFILL_ENERGY;\n        if ctx.player.energy == MAX_ENERGY {\n            break;\n        }\n    }\n\n    if ctx.player.energy >= MAX_ENERGY {\n        ctx.player.last_login = Clock::get()?.unix_timestamp;\n    } else {\n        ctx.player.last_login += time_spent;\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Sending a Solana Transaction in Unity C#\nDESCRIPTION: This C# method demonstrates how to interact with a Solana program from Unity using the generated Anchor client and the Solana Unity SDK. It finds the Program Derived Address (PDA) for game data, creates a 'MoveRight' instruction using the generated client (`TinyAdventureProgram`), fetches a recent blockhash, constructs a transaction, signs it with the player's wallet (`walletHolderService.BaseWallet`), and sends it to the Solana network via an RPC client.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/porting-anchor-to-unity.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic async void MoveRight()\n{\n    PublicKey.TryFindProgramAddress(new[]\n    {\n        Encoding.UTF8.GetBytes(\"level1\")\n    },\n    ProgramId, out gameDataAccount, out var bump);\n\n    MoveRightAccounts account = new MoveRightAccounts();\n    account.GameDataAccount = gameDataAccount;\n    TransactionInstruction moveRightInstruction = TinyAdventureProgram.MoveRight(account, ProgramId);\n\n    var walletHolderService = ServiceFactory.Resolve<WalletHolderService>();\n    var result = await walletHolderService.BaseWallet.ActiveRpcClient.GetRecentBlockHashAsync(Commitment.Confirmed);\n\n    Transaction transaction = new Transaction();\n    transaction.FeePayer = walletHolderService.BaseWallet.Account.PublicKey;\n    transaction.RecentBlockHash = result.Result.Value.Blockhash;\n    transaction.Signatures = new List<SignaturePubKeyPair>();\n    transaction.Instructions = new List<TransactionInstruction>();\n    transaction.Instructions.Add(moveRightInstruction);\n\n    Transaction signedTransaction = await walletHolderService.BaseWallet.SignTransaction(transaction);\n\n    RequestResult<string> signature = await walletHolderService.BaseWallet.ActiveRpcClient.SendTransactionAsync(\n        Convert.ToBase64String(signedTransaction.Serialize()),\n        true, Commitment.Confirmed);\n}\n```\n\n----------------------------------------\n\nTITLE: Transferring from Seeded Account in TypeScript\nDESCRIPTION: Shows how to transfer SOL from an account created with a seed using TypeScript. This requires creating a transfer instruction using `SystemProgram.transfer` where the `fromPubkey` is the derived address and the `basePubkey` is the original base key used to create the seeded account. The transaction must be signed by the base keypair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/transfer/main.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/create-account-with-seed/transfer/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Keypair in Rust\nDESCRIPTION: Provides an example of generating a new Solana keypair using the Rust Solana SDK. It utilizes the `solana_sdk` crate functions to create a keypair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/generate-keypair/generate-keypair.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Generating C# Client from Anchor IDL using .NET Tool\nDESCRIPTION: These shell commands first install the Solana.Unity.Anchor .NET tool and then use the `anchorgen` command to generate a C# client file (`src/ProgramCode.cs`) from a specified Anchor program IDL JSON file (`idl/file.json`). This generated client enables interaction with the Solana program from C# applications like Unity.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/porting-anchor-to-unity.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\ndotnet tool install Solana.Unity.Anchor.Tool\ndotnet anchorgen -i idl/file.json -o src/ProgramCode.cs\n```\n\n----------------------------------------\n\nTITLE: Downloading Solana Mainnet Programs Using CLI\nDESCRIPTION: This shell script utilizes the Solana CLI to fetch and save a mainnet program binary (such as Serum Dex v3) for use in local test environments. It requires the program address and a designated output file location. The output is a local program binary that can be loaded into a local validator. This method is necessary for thorough integration and compatibility testing with actual mainnet binaries.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_22\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/dump-programs.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/dump-programs.preview.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Loading Downloaded Accounts to Local Solana Validator via CLI\nDESCRIPTION: This shell snippet demonstrates how to load a previously downloaded mainnet account (e.g., an SRM mint) into a local Solana validator instance. It uses the Solana CLI and requires the account dump file and the destination public key. When running 'solana-test-validator', it registers the account under a given address, enabling testing against realistic data locally. Intended for integration and simulation workflows in private test environments.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_21\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/load-accounts.preview.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/load-accounts.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Serializing Solana Instruction Data on Client using TypeScript and Borsh\nDESCRIPTION: This TypeScript function `mintKV` demonstrates client-side instruction data serialization for a Solana program using the `borsh` library. It defines a `Payload` class and a corresponding `payloadSchema` for Borsh, serializes an instance containing an instruction variant ID and data (`mintKey`, `mintValue`), and constructs a `TransactionInstruction` with the serialized buffer. It depends on `@solana/web3.js` for Solana interactions and the `borsh` library.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/guides/serialization.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Include borsh functionality\n\nimport { serialize, deserialize, deserializeUnchecked } from \"borsh\";\nimport { Buffer } from \"buffer\";\n\n// Get Solana\nimport {\n  Keypair,\n  Connection,\n  PublicKey,\n  Transaction,\n  TransactionInstruction,\n  sendAndConfirmTransaction,\n} from \"@solana/web3.js\";\n\n// Flexible class that takes properties and imbues them\n// to the object instance\nclass Assignable {\n  constructor(properties) {\n    Object.keys(properties).map((key) => {\n      return (this[key] = properties[key]);\n    });\n  }\n}\n\n// Our instruction payload vocabulary\nclass Payload extends Assignable {}\n\n// Borsh needs a schema describing the payload\nconst payloadSchema = new Map([\n  [\n    Payload,\n    {\n      kind: \"struct\",\n      fields: [\n        [\"id\", \"u8\"],\n        [\"key\", \"string\"],\n        [\"value\", \"string\"],\n      ],\n    },\n  ],\n]);\n\n// Instruction variant indexes\nenum InstructionVariant {\n  InitializeAccount = 0,\n  MintKeypair,\n  TransferKeypair,\n  BurnKeypair,\n}\n\n/**\n * Mint a key value pair to account\n * @param {Connection} connection - Solana RPC connection\n * @param {PublicKey} progId - Sample Program public key\n * @param {PublicKey} account - Target program owned account for Mint\n * @param {Keypair} wallet - Wallet for signing and payment\n * @param {string} mintKey - The key being minted key\n * @param {string} mintValue - The value being minted\n * @return {Promise<Keypair>} - Keypair\n */\n\nexport async function mintKV(\n  connection: Connection,\n  progId: PublicKey,\n  account: PublicKey,\n  wallet: Keypair,\n  mintKey: string,\n  mintValue: string\n): Promise<string> {\n  // Construct the payload\n  const mint = new Payload({\n    id: InstructionVariant.MintKeypair,\n    key: mintKey, // 'ts key'\n    value: mintValue, // 'ts first value'\n  });\n\n  // Serialize the payload\n  const mintSerBuf = Buffer.from(serialize(payloadSchema, mint));\n  // console.log(mintSerBuf)\n  // => <Buffer 01 06 00 00 00 74 73 20 6b 65 79 0e 00 00 00 74 73 20 66 69 72 73 74 20 76 61 6c 75 65>\n  // let mintPayloadCopy = deserialize(schema, Payload, mintSerBuf)\n  // console.log(mintPayloadCopy)\n  // => Payload { id: 1, key: 'ts key', value: 'ts first value' }\n\n  // Create Solana Instruction\n  const instruction = new TransactionInstruction({\n    data: mintSerBuf,\n    keys: [\n      { pubkey: account, isSigner: false, isWritable: true },\n      { pubkey: wallet.publicKey, isSigner: false, isWritable: false },\n    ],\n    programId: progId,\n  });\n\n  // Send Solana Transaction\n  const transactionSignature = await sendAndConfirmTransaction(\n    connection,\n    new Transaction().add(instruction),\n    [wallet],\n    {\n      commitment: \"singleGossip\",\n      preflightCommitment: \"singleGossip\",\n    }\n  );\n  console.log(\"Signature = \", transactionSignature);\n  return transactionSignature;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Player Account from JavaScript Client (Anchor)\nDESCRIPTION: This JavaScript snippet shows how a client application interacts with the deployed Solana program to initialize a player's data account. It uses the Anchor library (`@project-serum/anchor` or `@coral-xyz/anchor`) and `@solana/web3.js`. The code sets up an `AnchorProvider`, creates a `Program` instance using the program's IDL and ID, calculates the player's PDA using `findProgramAddressSync` with the same seeds as the Rust program, builds a transaction calling the `initPlayer` instruction, sends it, and confirms the transaction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/saving-game-state.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst wallet = useAnchorWallet();\nconst provider = new AnchorProvider(connection, wallet, {});\nsetProvider(provider);\nconst program = new Program(IDL, PROGRAM_ID, provider);\n\nconst [pda] = PublicKey.findProgramAddressSync(\n  [Buffer.from(\"player\", \"utf8\"), \n  publicKey.toBuffer()],\n  new PublicKey(PROGRAM_ID)\n);\n\ntry {\n  const transaction = program.methods\n    .initPlayer()\n    .accounts({\n      player: pda,\n      signer: publicKey,\n      systemProgram: SystemProgram.programId,\n    })\n    .transaction();\n\n  const tx = await transaction;\n  const txSig = await sendTransaction(tx, connection);\n  await connection.confirmTransaction(txSig, \"confirmed\");\n\n```\n\n----------------------------------------\n\nTITLE: Installing Svelte Wallet Adapter Dependencies via npm\nDESCRIPTION: This command installs the core Svelte Wallet Adapter library, the UI components, the base adapter logic, specific wallet implementations, and the Solana web3.js library. These packages are required to enable wallet connections within a Svelte application.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @svelte-on-solana/wallet-adapter-core @svelte-on-solana/wallet-adapter-ui @solana/wallet-adapter-base @solana/wallet-adapter-wallets @solana/web3.js\n```\n\n----------------------------------------\n\nTITLE: Configuring Solana CLI for Public Clusters\nDESCRIPTION: Shows how to set the Solana CLI to connect to different public Solana clusters (mainnet-beta, devnet, testnet) using the `solana config set --url` command. This command updates the CLI configuration to point to the specified RPC endpoint.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/connecting-cluster/connecting-cluster.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Implementing Svelte Wallet Connection Component\nDESCRIPTION: This Svelte code snippet structure demonstrates the implementation of the wallet connection feature using the Svelte Wallet Adapter. It references the external file containing the detailed Svelte component code which likely utilizes the adapter's store (`$walletStore`) and UI components like `<WalletMultiButton />`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_41\n\nLANGUAGE: html\nCODE:\n```\n<template v-slot:default>\n\n@[code](@/code/keypairs-and-wallets/connect-to-wallet/connect-to-wallet-svelte.en.html)\n\n</template>\n```\n\n----------------------------------------\n\nTITLE: Fetching Current Validators via Solana CLI\nDESCRIPTION: Retrieves the list of current validators on the Solana network using the Solana Command Line Interface (CLI). Provides an alternative to the programmatic approach for identifying validators.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/staking/get-current-validators/get-current-validators.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Preview: Retrieving Account Balance using Solana-Client in Rust\nDESCRIPTION: A brief preview snippet demonstrating the essential `get_balance` call from the `solana-client` crate in Rust for fetching an account's SOL balance. Assumes `rpc_client` and `pubkey` are available.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Rust Test Boilerplate for Programmatic Feature Parity Testing\nDESCRIPTION: References boilerplate Rust code (located in `@/code/feature-parity-testing/preamble.rs`) intended for setting up programmatic tests using `solana-program-test`. This setup code likely includes helper functions to configure the `TestValidatorGenesis` for controlling activated/deactivated features, allowing tests to run under specific feature parity conditions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n// Referenced code from @/code/feature-parity-testing/preamble.rs and @/code/feature-parity-testing/preamble_short.rs\n// This boilerplate typically includes:\n// - Necessary imports (solana_program_test, solana_sdk, etc.)\n// - Helper functions to configure ProgramTest with specific feature activation/deactivation.\n// - Basic test module structure (`mod test { ... }`).\n\n/* Example structure (conceptual based on context):\nuse solana_program_test::*;\nuse solana_sdk::{feature::Feature, pubkey::Pubkey, transaction::Transaction};\n\nasync fn run_test_with_features(program_id: Pubkey, program_path: &str, deactivated_features: Vec<Pubkey>) -> BanksClient { \n    let mut pc = ProgramTest::new(\"my_program\", program_id, processor!(/* ... */));\n    for feature_pk in deactivated_features {\n        pc.deactivate_feature(feature_pk);\n    }\n    // ... start validator ...\n}\n\nmod test {\n    // Test functions go here\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Signing and Verifying Solana Messages in TypeScript\nDESCRIPTION: Demonstrates how to sign an arbitrary message using a Solana keypair's private key and then verify the signature using the corresponding public key in TypeScript. Uses the `tweetnacl` library for cryptographic operations.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/sign-verify-message/sign-verify-message.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/sign-verify-message/sign-verify-message.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Delegating Stake in TypeScript\nDESCRIPTION: Shows how to delegate SOL in a funded stake account to a specific validator using `@solana/web3.js`. Requires the Stake Authority's signature. Delegation takes several epochs to become active.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/delegate-stake/delegate-stake.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Rust Test Case with All Features Enabled (Default)\nDESCRIPTION: References a Rust test case (located in `@/code/feature-parity-testing/deactivate_one.rs`) that utilizes the test boilerplate. This specific test demonstrates running the program against a `solana-program-test` validator instance configured with the default behavior, meaning all available features are activated, similar to running `solana-test-validator` without deactivation flags.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n// Referenced code from @/code/feature-parity-testing/deactivate_one.rs\n// This test likely calls the boilerplate setup function without providing\n// any features to deactivate, thus running with the default (all features enabled) configuration.\n\n/* Example structure (conceptual based on context):\n#[tokio::test]\nasync fn test_with_all_features() {\n    // Uses the boilerplate helper, possibly passing an empty Vec for deactivated_features\n    let (mut banks_client, payer, recent_blockhash) = run_test_with_features(\n        /* program_id */, \n        /* program_path */, \n        vec![] // No features deactivated\n    ).await;\n\n    // ... rest of the test logic ...\n}\n*/\n```\n\n----------------------------------------\n\nTITLE: Determining NFT Owner with Largest Account - TypeScript\nDESCRIPTION: This code enables retrieval of the current owner of a Solana NFT by finding the largest token account for a given mint, assuming the NFT's supply is one. It uses Metaplex or Solana JS libraries to query accounts. The primary input is an NFT mint key; the output is the owner's public key. Limitations include assumption of the unique supply and correct parsing of on-chain account balances.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/get-owner/get-owner.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Finding NFTs Minted from a Candy Machine - TypeScript\nDESCRIPTION: This TypeScript code locates all NFTs minted from a given Candy Machine v2, useful for audit and monitoring purposes. Input is the Candy Machine address; output is a list of NFT mint addresses. This relies on Metaplex SDK functions for account filtering and parsing of relevant mint events.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/find-minted-nfts.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Preview: Calculating Total Staked Amount for a Wallet in TypeScript\nDESCRIPTION: Provides a preview or runnable example snippet for calculating the total staked amount for a wallet using `@solana/web3.js` and `getProgramAccounts`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/get-stake-amount/get-stake-amount.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Searching for Candy Machines by Wallet Address - TypeScript\nDESCRIPTION: This example demonstrates how to retrieve all Candy Machine v2 instances deployed with a specific wallet address using findAllBy from the Metaplex JS SDK. Requires the wallet public key as an input; returns an array of Candy Machine objects. The code presumes familiarity with Candy Machine program configurations and correct extraction of the wallet address field.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/find-via-wallet.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Creating a Token Mint with Metaplex in Solana Client (JavaScript)\nDESCRIPTION: Checks for the existence of a reward token mint and creates it using the program method if it doesn't already exist, then confirms the transaction. Required dependencies are the Metaplex SDK, SPL Token, and initialized PDAs. Key parameters include metadata URI, name, symbol, and the program/protocol-specific account addresses. Handles errors related to account absence and logs results for verification.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nlet txHash;\n\ntry {\n  const mintData = await getMint(pg.connection, rewardTokenMintPda);\n  console.log(\"Mint Already Exists\");\n} catch {\n  txHash = await pg.program.methods\n    .createMint(metadata.uri, metadata.name, metadata.symbol)\n    .accounts({\n      rewardTokenMint: rewardTokenMintPda,\n      metadataAccount: rewardTokenMintMetadataPDA,\n      tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n    })\n    .rpc();\n  await logTransaction(txHash);\n}\nconsole.log(\"Token Mint: \", rewardTokenMintPda.toString());\n```\n\n----------------------------------------\n\nTITLE: Setting Up Borsh in Rust Client - TOML\nDESCRIPTION: Shows how to configure a Rust client for Borsh support using Cargo.toml. This setup is required for client-side serialization/deserialization mirroring program data processes. Add both borsh and borsh-derive crates to dependencies.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n@[code](@/code/serialization/setup/Cargo.cli.en.toml)\n```\n\n----------------------------------------\n\nTITLE: Deserializing Account Data on Client - Rust\nDESCRIPTION: Implements the client-side deserialization logic in Rust for extracting custom program account data returned from Solana. Relies on borsh-derive and properly defined Rust structs for the account state. Receives a byte slice (from RPC) and outputs strongly typed Rust data structures.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/clientdata/rust.client.data.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Withdrawing SOL from a Stake Account in TypeScript\nDESCRIPTION: Demonstrates how the Withdrawal Authority can withdraw SOL from a deactivated stake account to a system account using `@solana/web3.js`. The stake account must be inactive (not delegated) before withdrawal.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/withdraw-stake/withdraw-stake.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Account Balance using Solana-Client in Rust\nDESCRIPTION: Shows how to retrieve the SOL balance of a Solana account in Rust using the `get_balance` method from the `solana-client` crate. Requires an `RpcClient` instance and the account's `Pubkey`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Instruction Set for Version 0 - Solana Program - Rust\nDESCRIPTION: Defines the initial set of instructions (operations) for interacting with the version 0 account in a Solana Rust program. Outlines enums or structs used for RPC and program logic, such as account creation or basic state changes. Depends on Solana's program SDK and custom account struct definitions. Inputs are expected to be deserialized instruction enums; outputs are usually processed events or account mutations.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.instruction.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Serializing Instruction Data on Solana Client - TypeScript\nDESCRIPTION: Implements the client-side serialization of instruction data in TypeScript for distributions to Solana programs, using borsh. Synchronizes output with program-deserialization expectations, handling variants such as Mint and Transfer. Requires borsh npm package and typed schema definitions. Takes instruction-specific parameters as input and outputs a Buffer containing the serialized transaction data.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/serialization/instruction/ts.client.mint.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Running Solana CLI Installer on Windows\nDESCRIPTION: Executes the downloaded Solana installer from the Windows Command Prompt. Replace `v1.9.16` with the corresponding version that was downloaded. Requires Administrator privileges.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nC:\\solana-install-tmp\\solana-install-init.exe v1.9.16\n```\n\n----------------------------------------\n\nTITLE: Listing Python Package Dependencies with requirements.txt - plaintext\nDESCRIPTION: This code snippet provides a comprehensive list of Python dependencies and their fixed versions required to install and run the Solana Developers Solana Cookbook project. Intended to be used as a requirements.txt file, it enables package installation via pip, ensuring consistent environments across installations. The file should be used with 'pip install -r requirements.txt' and includes libraries for Solana development, cryptography, testing, data parsing, and HTTP requests.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nanchorpy==0.20.1\\nanchorpy-core==0.2.0\\nanyio==4.4.0\\nasn1crypto==1.5.1\\nattrs==23.2.0\\nbase58==2.1.1\\nbased58==0.1.1\\nborsh-construct==0.1.0\\ncbor2==5.6.3\\ncertifi==2024.6.2\\ncffi==1.16.0\\ncharset-normalizer==3.3.2\\ncoincurve==20.0.0\\nconstruct==2.10.68\\nconstruct-typing==0.5.6\\ncrcmod==1.7\\necdsa==0.19.0\\ned25519==1.5\\ned25519-blake2b==1.4.1\\nexceptiongroup==1.2.1\\nfastecdsa==2.3.2\\nh11==0.14.0\\nhttpcore==1.0.5\\nhttpx==0.27.0\\nidna==3.7\\niniconfig==2.0.0\\njsonalias==0.1.1\\nmnemonic==0.21\\nmore-itertools==8.14.0\\nnumpy==1.26.4\\npackaging==24.0\\npluggy==1.5.0\\npy-sr25519-bindings==0.2.0\\npycparser==2.22\\npycryptodome==3.20.0\\npyheck==0.1.5\\nPyNaCl==1.5.0\\npytest==8.2.1\\npytest-asyncio==0.23.7\\nrequests==2.32.3\\nriemann-secpy256k1==0.2.8\\nsix==1.16.0\\nsniffio==1.3.1\\nsolana==0.34.0\\nsolders==0.21.0\\nSQLAlchemy==2.0.30\\nsumtypes==0.1a6\\ntoml==0.10.2\\ntomli==2.0.1\\ntoolz==0.11.2\\ntyping_extensions==4.12.1\\nurllib3==2.2.1\\nwebsockets==10.4\n```\n\n----------------------------------------\n\nTITLE: Loading 3D NFT Models in Unity with GLTFast (C#)\nDESCRIPTION: This C# snippet demonstrates using the GLTFast package in Unity to load a 3D NFT model from its animation URL metadata. By attaching a GltfAsset component to a GameObject and setting its URL to the NFT's animationUrl, developers can dynamically import and render 3D content defined in NFT metadata (compatible formats include .glb and .gltf). Dependencies include the GLTFast Unity package. The input is the NFT's metadata.animationUrl property; the output is the instantiation of the 3D model in the Unity scene.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/nfts-in-games.md#_snippet_2\n\nLANGUAGE: c#\nCODE:\n```\n  var gltf = gameObject.AddComponent<GLTFast.GltfAsset>();\n  gltf.url = nft.metadata.animationUrl;\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Secret Bytes in Rust\nDESCRIPTION: Provides an example of restoring a Solana keypair from its secret key (byte slice) using the Rust Solana SDK. The `Keypair::from_bytes` method is used for this.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/web3.js via NPM\nDESCRIPTION: Installs the @solana/web3.js library using the Node Package Manager (NPM). This library is essential for JavaScript/TypeScript development on Solana, enabling interaction with the blockchain.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @solana/web3.js\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/spl-token via Yarn\nDESCRIPTION: Installs the @solana/spl-token library using the Yarn package manager. This library provides JavaScript/TypeScript bindings for interacting with SPL tokens, enabling actions like minting and transferring tokens.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @solana/spl-token\n```\n\n----------------------------------------\n\nTITLE: Including @solana/spl-token via Browser Script (Development)\nDESCRIPTION: Includes the un-minified development version of the @solana/spl-token library directly in an HTML file using a script tag from unpkg CDN. Useful for browser-based SPL token interactions during development.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<!-- Development (un-minified) -->\n<script src=\"https://unpkg.com/@solana/spl-token@latest/lib/index.iife.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Wallet-Adapter Core Packages via NPM\nDESCRIPTION: Installs the base Solana wallet-adapter packages (@solana/wallet-adapter-wallets, @solana/wallet-adapter-base) using NPM. These packages enable easy wallet connection management in Solana dApps.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @solana/wallet-adapter-wallets \\\n    @solana/wallet-adapter-base\n```\n\n----------------------------------------\n\nTITLE: Installing Rust via rustup on macOS/Linux\nDESCRIPTION: Installs Rust using the recommended rustup tool on macOS and Linux systems. Rust is the primary language for writing Solana programs (smart contracts). This command downloads and executes the rustup installation script.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n```\n\n----------------------------------------\n\nTITLE: Example Solana CLI Installation Output\nDESCRIPTION: Shows example output indicating a successful installation or update of the Solana CLI using the installation script. It confirms the release version downloaded and the active release directory.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_12\n\nLANGUAGE: text\nCODE:\n```\ndownloading LATEST_RELEASE installer\nConfiguration: /home/solana/.config/solana/install/config.yml\nActive release directory: /home/solana/.local/share/solana/install/active_release\n* Release version: LATEST_RELEASE\n* Release URL: https://github.com/solana-labs/solana/releases/download/LATEST_RELEASE/solana-release-x86_64-unknown-linux-gnu.tar.bz2\nUpdate successful\n```\n\n----------------------------------------\n\nTITLE: Previewing Svelte Wallet Connection Component\nDESCRIPTION: This Svelte code snippet structure shows a preview version of the wallet connection component. It references an external file containing the preview code, likely a simplified or visual representation of the wallet button integration using the Svelte Wallet Adapter UI package.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_42\n\nLANGUAGE: html\nCODE:\n```\n<template v-slot:preview>\n\n@[code](@/code/keypairs-and-wallets/connect-to-wallet/connect-to-wallet-svelte.preview.en.html)\n\n</template>\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Base58 Secret in Rust\nDESCRIPTION: Provides an example of restoring a Solana keypair from a Base58 encoded secret string using the Rust Solana SDK. This typically involves decoding the string using `bs58` crate and then using `Keypair::from_bytes`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/from-bs58.en.rs)\n```\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/from-bs58.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Example Solana CLI PATH Update Prompt\nDESCRIPTION: Illustrates the message shown by the Solana installer if the PATH environment variable needs to be updated manually. The user should copy and execute the command provided by the installer following this message.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nPlease update your PATH environment variable to include the solana programs:\n```\n\n----------------------------------------\n\nTITLE: Retrieving Account Balance using Solana-Py in Python\nDESCRIPTION: Illustrates fetching a Solana account's SOL balance using the `get_balance` method from the `solana.rpc.api.Client` class in the `solana-py` library. Needs an initialized RPC client and the account's `Pubkey`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.py)\n```\n\n----------------------------------------\n\nTITLE: Verifying Solana CLI Installation\nDESCRIPTION: Command to check the installed version of the Solana CLI. Running this command confirms that the installation was successful and the `solana` executable is accessible in the system's PATH.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsolana --version\n```\n\n----------------------------------------\n\nTITLE: Adding Solana CLI to PATH in Linux Profile\nDESCRIPTION: This line should be added to the `/etc/profile` file (or user-specific profile like `~/.bashrc` or `~/.profile`) to permanently add the Solana CLI binary directory to the PATH environment variable. Replace `/home/coderina/solana-release/bin` with the actual path where the binaries were extracted.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nexport PATH=/home/coderina/solana-release/bin:$PATH\n```\n\n----------------------------------------\n\nTITLE: Deserializing Solana Instruction Data in Program using Rust and Borsh\nDESCRIPTION: This Rust code defines a `ProgramInstruction` enum and implements the `unpack` function to deserialize instruction data within a Solana program using Borsh. It uses `BorshDeserialize` to parse the input byte slice into a generic `Payload` struct and then matches on the `variant` field to construct the appropriate `ProgramInstruction` enum variant with its associated data (key, value). It requires the `borsh` and `solana-program` crates.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/guides/serialization.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n//! instruction Contains the main ProgramInstruction enum\n\nuse {\n    crate::error::SampleError, borsh::BorshDeserialize, solana_program::program_error::ProgramError,\n};\n\n#[derive(Debug, PartialEq)]\n/// All custom program instructions\npub enum ProgramInstruction {\n    InitializeAccount,\n    MintToAccount { key: String, value: String },\n    TransferBetweenAccounts { key: String },\n    BurnFromAccount { key: String },\n    MintToAccountWithFee { key: String, value: String },\n    TransferBetweenAccountsWithFee { key: String },\n    BurnFromAccountWithFee { key: String },\n}\n\n/// Generic Payload Deserialization\n#[derive(BorshDeserialize, Debug)]\nstruct Payload {\n    variant: u8,\n    arg1: String,\n    arg2: String,\n}\n\nimpl ProgramInstruction {\n    /// Unpack inbound buffer to associated Instruction\n    /// The expected format for input is a Borsh serialized vector\n    pub fn unpack(input: &[u8]) -> Result<Self, ProgramError> {\n        let payload = Payload::try_from_slice(input).unwrap();\n        match payload.variant {\n            0 => Ok(ProgramInstruction::InitializeAccount),\n            1 => Ok(Self::MintToAccount {\n                key: payload.arg1,\n                value: payload.arg2,\n            }),\n            2 => Ok(Self::TransferBetweenAccounts { key: payload.arg1 }),\n            3 => Ok(Self::BurnFromAccount { key: payload.arg1 }),\n            4 => Ok(Self::MintToAccountWithFee {\n                key: payload.arg1,\n                value: payload.arg2,\n            }),\n            5 => Ok(Self::TransferBetweenAccountsWithFee { key: payload.arg1 }),\n            6 => Ok(Self::BurnFromAccountWithFee { key: payload.arg1 }),\n            _ => Err(SampleError::DeserializationFailure.into()),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Preview: Creating a Solana Keypair from Secret Key (JavaScript)\nDESCRIPTION: Provides a concise code preview highlighting the core line of code needed to generate a `Keypair` from a secret: `Keypair.fromSecretKey(secret)`. This snippet is intended to be used within a `<SolanaCodeGroupItem>` as the preview part, complementing the full source code example.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst keypair = Keypair.fromSecretKey(secret);\n```\n\n----------------------------------------\n\nTITLE: Preview: Getting Account Balance using Python\nDESCRIPTION: This preview Python snippet shows how to set up and execute the main Python code for getting an account balance. It likely includes initializing the Solana client and handling the response from the `get_balance` call.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Testing BTreeMap-Based Mapping with a Client (TypeScript)\nDESCRIPTION: Provides TypeScript code to interact with and test a Solana program storing a BTreeMap in a single account. The snippet shows client-side logic for sending transactions to initialize accounts, insert entries, and fetch mapped data. Requires Solana connection setup and @solana/web3.js, along with the program and account addresses. Inputs are keys and values for mapping; outputs are the confirmed on-chain map and responses. Designed for client developers integrating with custom Rust mapping contracts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/account-maps.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/account-maps/trivial/client.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Game Data Account for Player Position in Rust\nDESCRIPTION: This snippet defines the `GameDataAccount` structure using the Anchor `#[account]` macro. This account is designed to store the state of the game, specifically the player's current position, represented by the `player_position` field of type `u8`. This account will be used to track the player's progress.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n\nuse anchor_lang::prelude::*;\nuse anchor_lang::solana_program::native_token::LAMPORTS_PER_SOL;\nuse anchor_lang::system_program;\n\ndeclare_id!(\"11111111111111111111111111111111\");\n\n#[program]\nmod tiny_adventure_two {\n    use super::*;\n    ...\n\n}\n\n...\n\n// Define the Game Data Account structure\n#[account]\npub struct GameDataAccount {\n    player_position: u8,\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Solana Account Changes using Python\nDESCRIPTION: Shows how to subscribe to account changes on Solana using Python, likely via the `solana-py` library's WebSocket functionalities. It involves establishing a WebSocket connection and setting up a listener for account update events.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/local-development/connecting-websocket/connecting-websocket.en.py)\n```\n\n----------------------------------------\n\nTITLE: Cloning and Opening Solana BPF Program Template in Bash\nDESCRIPTION: Clones the `solana-bpf-program-template` repository from GitHub using Git, navigates into the newly created directory, and opens the project in Visual Studio Code. This command sequence sets up the example project environment required for following the debugging steps described in the document.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/debugging-solana-programs.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:mvines/solana-bpf-program-template.git\ncd solana-bpf-program-template\ncode .\n```\n\n----------------------------------------\n\nTITLE: PDA-Based Account Mapping in Vanilla Rust (Rust)\nDESCRIPTION: Showcases native Rust code (not using Anchor) to implement PDA-based mapping for 1:1 and 1:N associations, similar to the Anchor example but with explicit handling of PDA derivation and Solana instruction implementation. The code includes methods for generating blog and post account addresses from public keys and unique slugs, and is intended to be run within the Solana runtime context. Inputs require seeds for PDA derivation and relevant account data, outputs are generated PDAs mapped to desired accounts. Dependencies include solana_program and std.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/account-maps.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/account-maps/deriving-pda/vanilla-pda-map.rs)\n```\n\n----------------------------------------\n\nTITLE: Structuring Code References in Solana Cookbook (Plain Text)\nDESCRIPTION: Defines the standard layout for code reference sections within the Solana Cookbook. It specifies that each reference should include a title, a short summary explaining the purpose or context, and the relevant code snippet.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nCode Reference Title\n\nShort Summary\n\nCode Snippet\n```\n\n----------------------------------------\n\nTITLE: Example Output of Local Runtime Test Execution\nDESCRIPTION: Displays the console output generated when running the `test_transaction` function using the `solana-program-test` local runtime, typically triggered by `Run Tests` in VS Code or `cargo test`. It shows program loading messages, invocation logs including `msg!` output from the program, success status, and final test results, demonstrating the feedback available during basic runtime testing.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/debugging-solana-programs.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrunning 1 test\n\"bpf_program_template\" program loaded as native code\nProgram 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM invoke [1]\nProgram log: process_instruction: 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM: 1 accounts, data=[1, 2, 3]\nProgram 4uQeVj5tqViQh7yWWGStvkEG1Zmhx6uasJtWCJziofM success\ntest test::test_transaction ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 33.41s\n```\n\n----------------------------------------\n\nTITLE: Finding a Candy Machine by Address - TypeScript\nDESCRIPTION: This snippet retrieves details of a specific Candy Machine v2 using its on-chain address (PDA) through the findByAddress method in Metaplex JS. Input is the Candy Machine address; output is the Candy Machine instance data. Requires Solana connection and permission to query the relevant program accounts.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/find-via-address.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Structuring Guides in Solana Cookbook (Plain Text)\nDESCRIPTION: Outlines the recommended structure for guide sections in the Solana Cookbook. Guides should start with a brief summary or TLDR, followed by a fact sheet, a detailed deep dive into the topic, and conclude with links to other relevant resources.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nBrief Summary/TLDR\n\nFact Sheet\n\nDeep Dive\n\nOther Resources\n```\n\n----------------------------------------\n\nTITLE: Starting Solana Test Validator with Default Settings via CLI\nDESCRIPTION: Illustrates the command to start the `solana-test-validator` locally with default settings (all features automatically enabled). It specifies a ledger path (`-l`), loads a BPF program (`--bpf-program`), and resets the ledger (`--reset`). The `solana config set -ul` command ensures subsequent CLI commands target the local cluster.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nsolana config set -ul\nsolana-test-validator -l ./ledger --bpf-program ADDRESS target/deploy/PROGNAME.so --reset`\n```\n\n----------------------------------------\n\nTITLE: Initializing Player Account in Solana Client (JavaScript)\nDESCRIPTION: Attempts to fetch and display the player account; if absent, invokes the program method to initialize it and confirms via transaction logging. Assumes the playerPDA and players wallet public key have been correctly computed. Outputs include player creation and health details, with error handling embedded in the asynchronous flow.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_10\n\nLANGUAGE: js\nCODE:\n```\ntry {\n  const playerData = await pg.program.account.playerData.fetch(playerPDA);\n  console.log(\"Player Already Exists\");\n  console.log(\"Player Health: \", playerData.health);\n} catch {\n  txHash = await pg.program.methods\n    .initPlayer()\n    .accounts({\n      playerData: playerPDA,\n      player: pg.wallet.publicKey,\n    })\n    .rpc();\n  await logTransaction(txHash);\n  console.log(\"Player Account Created\");\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Player Position Using Switch Statement (JavaScript/TypeScript)\nDESCRIPTION: This snippet provides a JavaScript switch statement for visually representing player position based on the value stored in the gameDataAccount. It is typically placed after fetching the account data and is used to give a user-friendly, text-based rendering of the character's movement in the game. Inputs are gameDataAccount.playerPosition; outputs are console logs depicting the player's progress. This requires no external dependencies except standard JS/TS and is suitable for quick terminal visual feedback.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/hello-world.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nswitch (gameDateAccount.playerPosition) {\n  case 0:\n    console.log(\"A journey begins...\");\n    console.log(\"o........\");\n    break;\n  case 1:\n    console.log(\"....o....\");\n    break;\n  case 2:\n    console.log(\"......o..\");\n    break;\n  case 3:\n    console.log(\".........\\\\o/\");\n    break;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Level and Vault Accounts with Anchor Instruction - JavaScript\nDESCRIPTION: This code initializes the `GameDataAccount` and `ChestVaultAccount` by calling the `initializeLevelOne` instruction using Anchor's client methods. It sets up the program accounts, signer, and system program dependencies, sending an on-chain transaction. After execution, the transaction is confirmed, and the player's SOL balance is fetched and displayed. Required: proper Anchor client setup, funded wallet, and deployed Solana program. Inputs are account addresses and wallet keypair; output is transaction hash and updated balances.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Initialize level\nlet txHash = await pg.program.methods\n  .initializeLevelOne()\n  .accounts({\n    chestVault: chestVaultAccount,\n    newGameDataAccount: globalLevel1GameDataAccount,\n    signer: pg.wallet.publicKey,\n    systemProgram: web3.SystemProgram.programId,\n  })\n  .signers([pg.wallet.keypair])\n  .rpc();\n\nconsole.log(`Use 'solana confirm -v ${txHash}' to see the logs`);\nawait pg.connection.confirmTransaction(txHash);\n\nlet balance = await pg.connection.getBalance(pg.wallet.publicKey);\nconsole.log(\n  `My balance before spawning a chest: ${balance / web3.LAMPORTS_PER_SOL} SOL`\n);\n```\n\n----------------------------------------\n\nTITLE: Resolving Subdomain Name in TypeScript\nDESCRIPTION: This snippet outlines the process of resolving a subdomain within the Solana Name Service using TypeScript. It requires obtaining the parent domain key, then the subdomain key, and finally retrieving the account information associated with the subdomain key. Dependencies include `@solana/web3.js` and `@solana/spl-name-service`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/name-service.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/resolve-sub-domain/resolve-sub-domain.en.ts)\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\n@[code](@/code/name-service/resolve-sub-domain/resolve-sub-domain.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Account Version 1 with Migration Logic - Solana Program - Rust\nDESCRIPTION: Introduces the optimized v1 account struct with new fields and explicit support for migrating legacy account states. Separates old and current content types, bumps the version constant, imports try_from_slice_unchecked for flexible deserialization, and provides a conversion function for upgrading account state in place. Inputs include old and new struct definitions; outputs are upgraded accounts. Dependencies: borsh, solana_program, appropriate serialization imports.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v1.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Resetting Level and Spawning Chest with Anchor Instruction - JavaScript\nDESCRIPTION: This snippet calls the `resetLevelAndSpawnChest` instruction, resetting the player's position to zero and depositing 0.1 SOL in the chest vault account. The method chain assembles the required accounts and signs the transaction, confirming it on-chain. The logs and visual output reflect the updated game state. Dependencies: previously derived PDA addresses, Anchor client, an account with sufficient SOL, and a deployed program. Expected output includes transaction confirmation and updated game state logs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/store-sol-in-pda.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Set the player position back to 0 and pay to fill up the chest with sol\ntxHash = await pg.program.methods\n  .resetLevelAndSpawnChest()\n  .accounts({\n    chestVault: chestVaultAccount,\n    gameDataAccount: globalLevel1GameDataAccount,\n    payer: pg.wallet.publicKey,\n    systemProgram: web3.SystemProgram.programId,\n  })\n  .signers([pg.wallet.keypair])\n  .rpc();\n\nconsole.log(`Use 'solana confirm -v ${txHash}' to see the logs`);\nawait pg.connection.confirmTransaction(txHash);\n\nconsole.log(\"Level reset and chest spawned \");\nconsole.log(\"o........\");\n```\n\n----------------------------------------\n\nTITLE: Inserting Items into a Candy Machine - TypeScript\nDESCRIPTION: This snippet details how to insert new NFT items into an existing Candy Machine v2 using the Metaplex JS SDK. Key inputs are the Candy Machine identifier and the items array; output is a transaction confirmation. There may be item count/size limits and atomicity concerns depending on Solana transaction size constraints.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/insert-items.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Uploading Assets to Arweave for NFT Minting - TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to upload image or metadata files to Arweave before minting an NFT. It uses the Metaplex SDK or platforms like Bundlr for decentralized storage. Required dependencies include the Metaplex JS library and necessary wallet/keypair setup. Inputs are asset file buffers (image, JSON metadata), the output is an Arweave URI. The process involves initializing storage with credentials and ensuring correct integration with uploading APIs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/upload-arweave/upload-arweave.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Calculating Energy and Showing Countdown Timer in React Client - JavaScript\nDESCRIPTION: Implements client-side logic to mimic the smart contract's energy refill algorithm, providing a real-time countdown for the next energy unit using React useEffect and setInterval. The game state is updated based on elapsed time and displays wood, energy, and time to next refill. Inputs: gameState, intervals. Output: UI updates and user feedback. Dependencies: React, TIME_TO_REFILL_ENERGY and MAX_ENERGY constants.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/energy-system.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nuseEffect(() => {\n    const interval = setInterval(async () => {\n        if (gameState == null || gameState.lastLogin == undefined || gameState.energy >= 10) {return;}\n        const lastLoginTime = gameState.lastLogin * 1000;\n        let timePassed = ((Date.now() - lastLoginTime) / 1000);\n        while (timePassed > TIME_TO_REFILL_ENERGY && gameState.energy < MAX_ENERGY) {\n            gameState.energy = (parseInt(gameState.energy) + 1);\n            gameState.lastLogin = parseInt(gameState.lastLogin) + TIME_TO_REFILL_ENERGY;\n            timePassed -= TIME_TO_REFILL_ENERGY;\n        }\n        setTimePassed(timePassed);\n        let nextEnergyIn = Math.floor(TIME_TO_REFILL_ENERGY - timePassed);\n        if (nextEnergyIn < TIME_TO_REFILL_ENERGY && nextEnergyIn > 0) {\n            setEnergyNextIn(nextEnergyIn);\n        } else {\n            setEnergyNextIn(0);\n        }\n\n    }, 1000);\n\n    return () => clearInterval(interval);\n}, [gameState, timePassed]);\n\n...\n\n{(gameState && <div className=\"flex flex-col items-center\">\n    {(\"Wood: \" + gameState.wood + \" Energy: \" + gameState.energy + \" Next energy in: \" + nextEnergyIn )}\n</div>)}\n\n```\n\n----------------------------------------\n\nTITLE: Executing 'Kill Enemy' Instruction in Solana Client (JavaScript)\nDESCRIPTION: Calls the custom on-chain killEnemy instruction, updating player and token accounts, logs the transaction, and fetches the players updated account and token state. Requires playerData, token account, and token mint PDAs to be initialized. No complex parameters neededaction is synchronous with transaction confirmation and state refresh.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_11\n\nLANGUAGE: js\nCODE:\n```\ntxHash = await pg.program.methods\n  .killEnemy()\n  .accounts({\n    playerData: playerPDA,\n    playerTokenAccount: playerTokenAccount,\n    rewardTokenMint: rewardTokenMintPda,\n  })\n  .rpc();\nawait logTransaction(txHash);\nconsole.log(\"Enemy Defeated\");\nawait fetchAccountData();\n```\n\n----------------------------------------\n\nTITLE: Installing and Starting Solana Cookbook Documentation (yarn, bash)\nDESCRIPTION: This snippet provides the necessary shell commands to install dependencies and start the documentation site using yarn. It must be executed within the repository root (or inside the dev container) and requires yarn to be installed. The sequence will first install necessary Node.js dependencies and then launch a development server. After successful start, the documentation is accessible at http://localhost:8080/.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn install\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Deleting an Existing Candy Machine v2 Instance - TypeScript\nDESCRIPTION: This snippet describes how to delete a Candy Machine v2 from Solana using the Metaplex JS SDK. It requires authority credentials and the address of the Candy Machine to be deleted. Inputs include the PDA of the Candy Machine; output is a confirmation (transaction signature). Constraints are authority access and irreversible deletion.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/nfts.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/nfts/candy-machine/delete-candy-machine.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Defining Upgraded Program Instructions (v1) in Rust\nDESCRIPTION: Defines the updated instruction enum (`VersionProgramInstruction`) for the upgraded version (v1) of the Solana program in Rust. It adds a new instruction variant, `SetString`, specifically for interacting with the new `somestring` field added in the v1 account state.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/zh/guides/data-migration.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.instruction1.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Fetching Solana Block with Versioned Tx Support using curl (Plaintext)\nDESCRIPTION: This snippet shows how to use `curl` to send a JSON-RPC request to a Solana node's `getBlock` method. It includes the `maxSupportedTransactionVersion: 0` parameter in the request payload to ensure the response correctly handles blocks potentially containing versioned transactions (v0). Without this parameter, the request might default to 'legacy' and could error if the requested block contains versioned transactions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/versioned-transactions.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\ncurl http://localhost:8899 -X POST -H \"Content-Type: application/json\" -d \\\n'{\"jsonrpc\": \"2.0\", \"id\":1, \"method\": \"getBlock\", \"params\": [430, {\n  \"encoding\":\"json\",\n  \"maxSupportedTransactionVersion\":0,\n  \"transactionDetails\":\"full\",\n  \"rewards\":false\n}]}'\n```\n\n----------------------------------------\n\nTITLE: Restoring Multiple Solana Keypairs (HD Wallets) from BIP44 Mnemonic in Python\nDESCRIPTION: Derives multiple Solana keypairs (Hierarchical Deterministic wallets) from a single mnemonic phrase according to the BIP44 standard using Python.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip44.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip44.preview.py)\n```\n\n----------------------------------------\n\nTITLE: Transaction Confirmation and Account Data Utilities (JavaScript)\nDESCRIPTION: Defines helper functions for confirming on-chain transactions and fetching player account state, ensuring reliable execution and state consistency. Dependencies include a connected Solana RPC endpoint (pg.connection) and access to account addresses. Inputs are transaction signatures and account PDAs; outputs are console logs indicating transaction status, player token balance, and health.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/gaming/interact-with-tokens.md#_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nasync function logTransaction(txHash) {\n  const { blockhash, lastValidBlockHeight } =\n    await pg.connection.getLatestBlockhash();\n\n  await pg.connection.confirmTransaction({\n    blockhash,\n    lastValidBlockHeight,\n    signature: txHash,\n  });\n\n  console.log(`Use 'solana confirm -v ${txHash}' to see the logs`);\n}\n\nasync function fetchAccountData() {\n  const [playerBalance, playerData] = await Promise.all([\n    pg.connection.getTokenAccountBalance(playerTokenAccount),\n    pg.program.account.playerData.fetch(playerPDA),\n  ]);\n\n  console.log(\"Player Token Balance: \", playerBalance.value.uiAmount);\n  console.log(\"Player Health: \", playerData.health);\n}\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Base58 Secret in Python\nDESCRIPTION: Illustrates restoring a Solana keypair from a Base58 encoded secret string using the Solana Python library. The library function handles the Base58 decoding and keypair reconstruction.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/from-bs58.en.py)\n```\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/from-bs58.preview.en.py)\n```\n\n----------------------------------------\n\nTITLE: Preview: Fetching Delegators by Validator in TypeScript\nDESCRIPTION: Provides a preview or runnable example snippet for fetching delegators for a given validator using `@solana/web3.js` and `getProgramAccounts`.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/staking.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/staking/get-delegators-by-validators/get-delegators-by-validators.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Creating a Solana Keypair from Secret Key (JavaScript)\nDESCRIPTION: Demonstrates how to generate a Solana `Keypair` object from a predefined secret key using the `@solana/web3.js` library. It shows the necessary import, the definition of the secret key as a `Uint8Array`, and the use of `Keypair.fromSecretKey` within an async IIFE. This serves as a full source example for code previews.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Keypair } from \"@solana/web3.js\";\n\nconst secret = Uint8Array.from([\n  174, 47, 154, 16, 202, 193, 206, 113, 199, 190, 53, 133, 169, 175, 31, 56,\n  222, 53, 138, 189, 224, 216, 117, 173, 10, 149, 53, 45, 73, 251, 237, 246, 15,\n  185, 186, 82, 177, 240, 148, 69, 241, 227, 167, 80, 141, 89, 240, 121, 121,\n  35, 172, 247, 68, 251, 226, 218, 48, 63, 176, 109, 168, 89, 238, 135,\n]);\n\n(async () => {\n  const keypair = Keypair.fromSecretKey(secret);\n})();\n```\n\n----------------------------------------\n\nTITLE: Preview: Getting Account Balance using TypeScript\nDESCRIPTION: This preview TypeScript snippet likely sets up the environment or provides a runnable context for the main `getBalance` example. It demonstrates how to execute the balance retrieval within a typical asynchronous TypeScript structure.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Sending SPL-Tokens | Solana Token Program | Shell\nDESCRIPTION: Uses Solana CLI to transfer SPL tokens between accounts. The command accepts token mint address, token account addresses, amount, and payer. The CLI automatically signs and submits the transaction, provided all CLIs and token accounts are set up correctly.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/basic-transactions/sending-spl-token/sending-spl-token.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/basic-transactions/sending-spl-token/sending-spl-token.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Requesting Block Data with maxSupportedTransactionVersion - Solana RPC - Plaintext\nDESCRIPTION: Sends a JSON-RPC request to a local Solana node to fetch block data for slot 430 including v0 transactions, setting 'maxSupportedTransactionVersion' to 0 for compatibility with versioned transactions. Requires a running Solana RPC endpoint (typically on localhost:8899) and a JSON-capable shell. Returns detailed block information or raises a version error if maxSupportedTransactionVersion is not set and a versioned transaction is present.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/ja/guides/versioned-transactions.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\ncurl http://localhost:8899 -X POST -H \"Content-Type: application/json\" -d \\\n'{\"jsonrpc\": \"2.0\", \"id\":1, \"method\": \"getBlock\", \"params\": [430, {\n  \"encoding\":\"json\",\n  \"maxSupportedTransactionVersion\":0,\n  \"transactionDetails\":\"full\",\n  \"rewards\":false\n}]}'\n```\n\n----------------------------------------\n\nTITLE: Starting Local Solana Validator using CLI\nDESCRIPTION: This command starts the Solana local test validator, providing a local development environment. It offers benefits like no RPC rate limits, no airdrop limits, direct program deployment, account cloning, configurable ledger size, configurable epoch length, and warping to specific slots. Requires the Solana tool suite to be installed.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nsolana-test-validator\n```\n\n----------------------------------------\n\nTITLE: Sending SOL | Solana CLI | Shell\nDESCRIPTION: Uses the Solana Command Line Interface to send SOL from one wallet to another. The CLI command handles signing, building, and submitting the transaction. Requires the solana CLI and wallets to be configured locally, with the input parameters being source, recipient, and amount.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/basic-transactions/sending-sol/sending-sol.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Public Solana Clusters using Python\nDESCRIPTION: Shows how to connect to Solana's public RPC endpoints (mainnet-beta, devnet, testnet) using the `solana-py` library in Python. This involves initializing a client object with the appropriate cluster URL.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/local-development/connecting-cluster/connecting-cluster.en.py)\n```\n\n----------------------------------------\n\nTITLE: Downloading Solana Mainnet Accounts Using CLI\nDESCRIPTION: This shell script provides a CLI command to download a specific Solana account from mainnet, such as the SRM token mint, and save it to a local file. It uses the Solana CLI and expects a valid account address and output filename as parameters. Outputs include the saved account data file, which can be later loaded into a local validator, and is essential for recreating mainnet scenarios locally without direct internet dependency.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/dump-accounts.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/dump-accounts.preview.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Getting Account Balance using C++\nDESCRIPTION: This C++ snippet illustrates how to fetch a Solana account balance, presumably using a Solana C++ SDK or library. It involves establishing a connection and calling a function akin to `getBalance` with the account's public key.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/accounts.md#_snippet_28\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Creating a Program Derived Address (PDA) using invoke_signed in Solana (Rust)\nDESCRIPTION: Rust code implementing PDA creation and initialization via invoke_signed, necessary since PDAs have no private key and must be created on-chain. Inputs: seeds, payer, target PDA account. Requires solana_program::pubkey and invoke_signed. Output: PDA is initialized and ready for state assignment.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/pprograms/create-pda/program/src/lib.rs)\n```\n\n----------------------------------------\n\nTITLE: Processor Logic for Version 0 - Solana Program - Rust\nDESCRIPTION: Implements the core processing logic by matching and executing on instructions for version 0, operating on the initial account struct. Handles deserialization, validation, and state updates using conversion logic. Depends on the account, instruction definitions, and Solana program SDK. Main inputs are account and instruction data; main outputs are modified accounts with state changes.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/rust.processor.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Accessing Clock Directly in a Solana Program using Rust\nDESCRIPTION: Demonstrates accessing the clock sysvar directly on-chain from within Rust, without the client passing SYSVAR_CLOCK_PUBKEY. Uses clock::Clock::get() or similar direct sysvar accessors. Inputs: only program state accounts needed. Output: can access current slot, epoch, or timestamp in logic.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/programs.md#_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/programs/get-clock/method-two/program/src/lib.rs)\n```\n\n----------------------------------------\n\nTITLE: Starting Local Validator and Streaming Logs in Bash\nDESCRIPTION: Provides the sequence of shell commands necessary for testing a Solana program using an external client application. First, it configures the Solana CLI to target the local cluster (`solana config set -ul`). Then, it starts the `solana-test-validator`, loading the specified BPF program and its keypair. Finally, it starts the log streaming service (`solana logs`) in a separate terminal to observe program output generated during transaction processing initiated by a client.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/debugging-solana-programs.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsolana config set -ul\nsolana-test-validator --bpf-program target/deploy/bpf_program_template-keypair.json target/deploy/bpf_program_template.so\nsolana logs\n```\n\n----------------------------------------\n\nTITLE: Calculating Transaction Cost | getEstimatedFee | TypeScript\nDESCRIPTION: Illustrates estimation of transaction fees using the Transaction.getEstimatedFee method in solana/web3.js. Requires a Transaction instance and an RPC connection, returning the predicted fee in lamports by evaluating required signatures. Does not account for account-creation fees; only for transfers.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/calc-tx-cost/calc-tx-est-fees.en.ts)\n```\n\nLANGUAGE: typescript\nCODE:\n```\n@[code](@/code/basic-transactions/calc-tx-cost/calc-tx-est-fees.preview.en.ts)\n```\n\n----------------------------------------\n\nTITLE: Restoring Multiple Solana Keypairs (HD Wallets) from BIP44 Mnemonic using CLI\nDESCRIPTION: Uses the Solana CLI to restore multiple keypairs following the BIP44 standard (HD Wallets) from a single mnemonic phrase. Allows specifying derivation paths.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_29\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip44.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/mnemonic-to-keypair/from-bip44.sh)\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Secret Bytes in C++\nDESCRIPTION: Demonstrates restoring a Solana keypair from its secret key (byte representation) in C++. This likely involves using a Solana C++ library function that accepts the secret bytes.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.en.cpp)\n```\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.preview.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Version 0 Account Usage Preview - Solana Program - Rust\nDESCRIPTION: Shows an example usage or preview of the version 0 account as defined in the Solana program's initial migration scenario. Typically includes instantiation and/or sample serialization to help visualize the default data layout. Requires the same struct and dependencies as the main account definition. No parameters required; main input/output is a sample serialized structure.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/data-migration.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/data-migration/account-v0.preview.en.rs)\n```\n\n----------------------------------------\n\nTITLE: Using Option<T> for Optional Data Serialization in Rust (Borsh)\nDESCRIPTION: Rust example using the `borsh` crate to serialize and deserialize a struct (`MyStruct`) containing an `Option<u8>` field. It utilizes derive macros (`BorshSerialize`, `BorshDeserialize`) to automatically handle serialization for both `Some(value)` and `None` variants.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/fil/guides/serialization.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n@[code](@/code/serialization/coption/src/main.rs)\n```\n\n----------------------------------------\n\nTITLE: Loading Downloaded Programs to Local Solana Validator via CLI\nDESCRIPTION: This shell snippet shows how to load a downloaded Solana program binary into a local validator using the Solana CLI. It requires passing the program file and destination program address to 'solana-test-validator'. This enables testing with the exact mainnet code, which is valuable for compatibility or end-to-end tests before mainnet deployment.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_23\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/load-programs.preview.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/local-development/using-mainnet-accounts/load-programs.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Connecting to Private Solana Cluster using C++\nDESCRIPTION: Illustrates connecting to a private Solana RPC endpoint (local or remote) in C++. This typically involves specifying the custom cluster URL when configuring the C++ client library or making direct API calls.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/local-development/connecting-private-cluster/connecting-private-cluster.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Restoring Solana Keypair from Secret File using CLI\nDESCRIPTION: Shows how to restore or use a Solana keypair stored in a file (typically containing the secret key as bytes) using the Solana CLI. The `solana-keygen recover` or specifying the keypair file path with commands often achieves this.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.en.sh)\n```\n\nLANGUAGE: shell\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/keypair-from-secret/keypair-from-secret.preview.en.sh)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Account Balance using Solana-CPP SDK in C++\nDESCRIPTION: Demonstrates how to get a Solana account's SOL balance in C++ using a Solana C++ SDK's `getBalance` function. Requires an RPC client connection and the account's public key string or object.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/kr/references/accounts.md#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/accounts/get-balance/main.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Streaming Logs from Local Solana Validator via CLI\nDESCRIPTION: Provides the command `solana logs` used to stream and view the logs generated by a running `solana-test-validator` instance. This is essential for observing program output and debugging during local testing.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\nsolana logs\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Solana Account Changes using C++\nDESCRIPTION: Illustrates how to subscribe to Solana account change events in C++. This requires establishing a WebSocket connection to the RPC endpoint and handling subscription messages according to the Solana RPC specification.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/local-development/connecting-websocket/connecting-websocket.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/web3.js via Yarn\nDESCRIPTION: Installs the @solana/web3.js library using the Yarn package manager. This library provides core functionalities for interacting with the Solana blockchain, sending transactions, and reading data in JavaScript/TypeScript projects.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @solana/web3.js\n```\n\n----------------------------------------\n\nTITLE: Installing @solana/spl-token via NPM\nDESCRIPTION: Installs the @solana/spl-token library using the Node Package Manager (NPM). This library is necessary for managing and interacting with SPL tokens within JavaScript/TypeScript applications.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @solana/spl-token\n```\n\n----------------------------------------\n\nTITLE: Deactivating Specific Features in Solana Test Validator via CLI\nDESCRIPTION: Shows how to start the local `solana-test-validator` while deactivating one or more specific features using the `--deactivate-feature` flag followed by the feature's public key. This allows developers to test their programs locally under conditions that mimic other clusters like devnet or mainnet-beta where certain features might not be active yet.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/feature-parity-testing.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nsolana-test-validator --deactivate-feature <FEATURE_PUBKEY> ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Project Dependencies with TOML for Solana Borsh Serialization\nDESCRIPTION: This TOML configuration file defines the metadata and dependencies for a Rust project (`cli-program-template`). It specifically includes the `borsh` crate (version 0.9.0) for data serialization/deserialization, along with Solana SDK crates (`solana-sdk`, `solana-client`, etc.), command-line argument parsing (`clap`), and other utilities required for building the Solana program and client components involved in the serialization examples.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/tr/guides/serialization.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"cli-program-template\"\nversion = \"0.1.5\"\nedition = \"2018\"\nlicense = \"WTFPL\"\npublish = false\n\n[dependencies]\nborsh = \"0.9.0\"\nclap = \"2.33.3\"\nlazy_static = \"1.4.0\"\nserde = { version = \"1.0.125\", features = [\"derive\"] }\nserde_yaml = \"0.8.17\"\nsol-template-shared = {path = \"shared\"}\nsolana-clap-utils = \"1.8.2\"\nsolana-cli-config = \"1.8.2\"\nsolana-client = \"1.8.2\"\nsolana-logger = \"1.8.2\"\nsolana-remote-wallet = \"1.8.2\"\nsolana-sdk = \"1.8.2\"\ntokio = { version = \"1\", features = [\"full\"] }\n\n[workspace]\nmembers = [\n    \"program\",\n    \"shared\",\n]\n[dev-dependencies]\nlazy_static = \"1.4.0\"\nsolana-validator = \"1.8.2\"\nsolana-streamer = \"1.8.2\"\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Wallet Adapter Dependencies for React\nDESCRIPTION: Command to install the necessary Solana Wallet Adapter libraries for integrating wallet connection functionality into a React application using Yarn.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @solana/wallet-adapter-base @solana/wallet-adapter-wallets\n```\n\n----------------------------------------\n\nTITLE: Installing Solana Wallet Adapter Dependencies for Vue\nDESCRIPTION: Command to install the necessary Solana wallet connection libraries (`solana-wallets-vue` and adapter wallets) for a Vue application using npm.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\nnpm install solana-wallets-vue @solana/wallet-adapter-wallets\n```\n\n----------------------------------------\n\nTITLE: Including @solana/web3.js via Browser Script (Production)\nDESCRIPTION: Includes the minified production version of the @solana/web3.js library directly in an HTML file using a script tag from unpkg CDN. This is optimized for performance in live browser-based applications.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!-- Production (minified) -->\n<script src=\"https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Including @solana/spl-token via Browser Script (Production)\nDESCRIPTION: Includes the minified production version of the @solana/spl-token library directly in an HTML file using a script tag from unpkg CDN for optimized browser-based SPL token interactions.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<!-- Production (minified) -->\n<script src=\"https://unpkg.com/@solana/spl-token@latest/lib/index.iife.min.js\"></script>\n```\n\n----------------------------------------\n\nTITLE: Airdropping SOL Programmatically in C++ Using Solana APIs\nDESCRIPTION: This C++ snippet illustrates how to request a SOL airdrop in a local/non-mainnet Solana environment using C++ with appropriate Solana RPC or REST client libraries. The code relies on setting up a network connection and interfacing with the Solana RPC endpoint. Parameters include the target address and amount, with the operation typically returning a result code or transaction signature. The snippet is intended for developers integrating Solana workflows into C++ projects.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/local-development.md#_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.en.cpp)\n```\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/local-development/airdropping-sol/airdropping-sol.preview.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Extracting and Setting PATH for Solana CLI Binaries on macOS\nDESCRIPTION: Commands to extract the downloaded Solana CLI binary archive for macOS, navigate into the extracted directory, and temporarily add the `bin` subdirectory to the current shell session's PATH variable. For permanent addition, update shell configuration files (e.g., ~/.zshrc, ~/.bash_profile).\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\ntar jxf solana-release-x86_64-apple-darwin.tar.bz2\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd solana-release/\n```\n\nLANGUAGE: bash\nCODE:\n```\nexport PATH=$PWD/bin:$PATH\n```\n\n----------------------------------------\n\nTITLE: Downloading Solana CLI Installer for Windows\nDESCRIPTION: Uses curl in Command Prompt (requires curl to be installed/available) to download the Solana installer executable for Windows to a temporary directory. Replace `v1.9.16` with the desired Solana version.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\ncurl https://release.solana.com/v1.9.16/solana-install-init-x86_64-pc-windows-msvc.exe --output C:\\solana-install-tmp\\solana-install-init.exe --create-dirs\n```\n\n----------------------------------------\n\nTITLE: Setting Up Borsh in Node Client - JSON\nDESCRIPTION: Presents the package.json configuration for enabling Borsh support in a Node.js TypeScript client. Lists borsh as a dependency for TS/JS, ensuring the client is able to serialize and deserialize data compatible with Solana programs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n@[code](@/code/serialization/setup/Node.package.en.json)\n```\n\n----------------------------------------\n\nTITLE: Program Logs Example | Solana Explorer | Text\nDESCRIPTION: Presents the program log output from a transaction with customized compute budget and priority fees. The log output details the sequence of program executions, fee calculations, and outcomes as seen in Solana Explorer. Useful for debugging and understanding transaction internals. No inputs or programmatic dependencies; purely sample log output.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/basic-transactions.md#_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n@[code](@/code/basic-transactions/compute-budget/log_output.txt)\n```\n\n----------------------------------------\n\nTITLE: Verifying Solana Keypair in C++\nDESCRIPTION: Demonstrates verifying a Solana keypair in C++, likely using a Solana C++ library. This involves checking if the provided secret key mathematically derives the provided public key.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.en.cpp)\n```\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/verify-keypair/verify-keypair.preview.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Borsh in Python Client - requirements.txt\nDESCRIPTION: Displays the required entry in requirements.txt to include the borsh-construct package for Python clients. This dependency facilitates Borsh serialization/deserialization in Python scripts interacting with Solana programs.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/guides/serialization.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@[code](@/code/serialization/setup/requirements.txt)\n```\n\n----------------------------------------\n\nTITLE: Generating Solana Vanity Address in C++\nDESCRIPTION: Demonstrates generating a Solana vanity address (a public key with a specific prefix) using C++. This illustrative example searches for a matching keypair.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/references/keypairs-and-wallets.md#_snippet_32\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.en.cpp)\n```\n\nLANGUAGE: cpp\nCODE:\n```\n@[code](@/code/keypairs-and-wallets/vanity-publickeys/vanity-publickeys.preview.en.cpp)\n```\n\n----------------------------------------\n\nTITLE: Verifying Solana CLI Installation on Windows\nDESCRIPTION: Command run in a new Command Prompt (as a normal user) to check the installed version of the Solana CLI on Windows. This confirms the installation was successful and the PATH was updated correctly by the installer.\nSOURCE: https://github.com/solana-developers/solana-cookbook/blob/master/docs/getting-started/installation.md#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nsolana --version\n```"
  }
]