[
  {
    "owner": "bytebot-ai",
    "repo": "bytebot",
    "content": "TITLE: Creating a Selenium-like Driver for Bytebot Automation in Python\nDESCRIPTION: This code defines a BytebotDriver class that provides a Selenium-like interface for automating desktop interactions through Bytebot's HTTP API. It includes methods for mouse control, keyboard input, browser navigation, and screenshot capture, along with an example usage pattern.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport time\nimport json\n\nclass BytebotDriver:\n    \"\"\"A Selenium-like driver for Bytebot\"\"\"\n\n    def __init__(self, base_url=\"http://localhost:9990\"):\n        self.base_url = base_url\n\n    def control_computer(self, action, **params):\n        url = f\"{self.base_url}/computer-use\"\n        data = {\"action\": action, **params}\n        response = requests.post(url, json=data)\n        return response.json()\n\n    def open_browser(self, browser_icon_coords):\n        \"\"\"Open a browser by clicking its icon\"\"\"\n        self.control_computer(\"move_mouse\", coordinates=browser_icon_coords)\n        self.control_computer(\"click_mouse\", button=\"left\")\n        time.sleep(3)  # Wait for browser to open\n\n    def navigate_to(self, url):\n        \"\"\"Navigate to a URL in the browser\"\"\"\n        self.control_computer(\"type_text\", text=url)\n        self.control_computer(\"press_keys\", key=\"enter\")\n        time.sleep(2)  # Wait for page to load\n\n    def click_element(self, coords):\n        \"\"\"Click an element at the specified coordinates\"\"\"\n        self.control_computer(\"move_mouse\", coordinates=coords)\n        self.control_computer(\"click_mouse\", button=\"left\")\n\n    def type_text(self, text):\n        \"\"\"Type text at the current cursor position\"\"\"\n        self.control_computer(\"type_text\", text=text)\n\n    def press_key(self, key, modifiers=None):\n        \"\"\"Press a keyboard key with optional modifiers\"\"\"\n        params = {\"key\": key}\n        if modifiers:\n            params[\"modifiers\"] = modifiers\n        self.control_computer(\"press_keys\", **params)\n\n    def take_screenshot(self):\n        \"\"\"Take a screenshot of the desktop\"\"\"\n        return self.control_computer(\"screenshot\")\n\n    def scroll(self, direction, amount):\n        \"\"\"Scroll in the specified direction\"\"\"\n        self.control_computer(\"scroll\", direction=direction, amount=amount)\n\n# Example usage\ndriver = BytebotDriver()\ndriver.open_browser({\"x\": 100, \"y\": 960})\ndriver.navigate_to(\"https://example.com\")\ndriver.click_element({\"x\": 300, \"y\": 400})\ndriver.type_text(\"Hello Bytebot!\")\ndriver.press_key(\"enter\")\nresult = driver.take_screenshot()\nprint(f\"Screenshot captured: {result['success']}\")\n```\n\n----------------------------------------\n\nTITLE: Computer Use API Examples in Multiple Languages\nDESCRIPTION: API usage examples for controlling the desktop environment, including mouse movement and screenshot capture.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/quickstart.mdx#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"move_mouse\", \"coordinates\": {\"x\": 100, \"y\": 200}}'\n\ncurl -X POST http://localhost:9990/computer-use \\\n -H \"Content-Type: application/json\" \\\n -d '{\"action\": \"screenshot\"}'\n```\n\nLANGUAGE: python\nCODE:\n```\nimport requests\n\ndef control_computer(action, **params):\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": action, **params}\n    response = requests.post(url, json=data)\n    return response.json()\n\n# Move the mouse\ncontrol_computer(\"move_mouse\", coordinates={\"x\": 100, \"y\": 100})\n\n# Take a screenshot\nscreenshot = control_computer(\"screenshot\")\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require(\"axios\");\n\nasync function controlComputer(action, params = {}) {\n  const url = \"http://localhost:9990/computer-use\";\n  const data = { action, ...params };\n  const response = await axios.post(url, data);\n  return response.data;\n}\n\n// Example usage\nasync function runExample() {\n  // Move mouse\n  await controlComputer(\"move_mouse\", { coordinates: { x: 100, y: 100 } });\n\n  // Take screenshot\n  const screenshot = await controlComputer(\"screenshot\");\n  console.log(\"Screenshot taken:\", screenshot);\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Unified Computer Action Request - JSON\nDESCRIPTION: Shows the general format for making requests to the Bytebot unified computer action endpoint. The 'action' property indicates the type of operation (e.g., 'move_mouse', 'click_mouse'), and additional properties provide required parameters specific to that action. Requests must be sent as JSON payloads in a POST request. This format underlies all further action-specific examples.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"action_name\",\n  ...action-specific parameters\n}\n```\n\n----------------------------------------\n\nTITLE: Form Filling Automation using JavaScript and Bytebot API\nDESCRIPTION: This JavaScript code demonstrates how to automate filling out a form in a web application using the Bytebot API, including mouse movements, typing, and keyboard navigation.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require(\"axios\");\n\nasync function controlComputer(action, params = {}) {\n  const url = \"http://localhost:9990/computer-use\";\n  const data = { action, ...params };\n  const response = await axios.post(url, data);\n  return response.data;\n}\n\nasync function fillForm() {\n  // Click first input field\n  await controlComputer(\"move_mouse\", { coordinates: { x: 400, y: 300 } });\n  await controlComputer(\"click_mouse\", { button: \"left\" });\n\n  // Type name\n  await controlComputer(\"type_text\", { text: \"John Doe\" });\n\n  // Tab to next field\n  await controlComputer(\"press_keys\", { key: \"tab\" });\n\n  // Type email\n  await controlComputer(\"type_text\", { text: \"john@example.com\" });\n\n  // Tab to next field\n  await controlComputer(\"press_keys\", { key: \"tab\" });\n\n  // Type message\n  await controlComputer(\"type_text\", {\n    text: \"This is an automated message sent using Bytebot's Computer Use API\",\n    delay: 30,\n  });\n\n  // Tab to submit button\n  await controlComputer(\"press_keys\", { key: \"tab\" });\n\n  // Press Enter to submit\n  await controlComputer(\"press_keys\", { key: \"enter\" });\n}\n\nfillForm().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Implementing ByteBot JavaScript Client for Computer Automation\nDESCRIPTION: A complete JavaScript client for interacting with ByteBot's local API. It provides methods for mouse movement, clicking, text typing, and taking screenshots. The client wraps API calls to the ByteBot server running on localhost port 9990 and includes error handling.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_17\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require('axios');\n\nconst bytebot = {\n  baseUrl: 'http://localhost:9990/computer-use/computer',\n  \n  async action(params) {\n    try {\n      const response = await axios.post(this.baseUrl, params);\n      return response.data;\n    } catch (error) {\n      console.error('Error:', error.response?.data || error.message);\n      throw error;\n    }\n  },\n  \n  // Convenience methods\n  async moveMouse(x, y) {\n    return this.action({\n      action: 'move_mouse',\n      coordinates: { x, y }\n    });\n  },\n  \n  async clickMouse(x, y, button = 'left') {\n    return this.action({\n      action: 'click_mouse',\n      coordinates: { x, y },\n      button\n    });\n  },\n  \n  async typeText(text) {\n    return this.action({\n      action: 'type_text',\n      text\n    });\n  },\n  \n  async screenshot() {\n    return this.action({ action: 'screenshot' });\n  }\n};\n\n// Example usage:\nasync function example() {\n  // Navigate to a website\n  await bytebot.moveMouse(100, 35);\n  await bytebot.clickMouse(100, 35);\n  await bytebot.typeText('https://example.com');\n  await bytebot.action({\n    action: 'press_keys',\n    keys: ['enter'],\n    press: 'down'\n  });\n  \n  // Wait for page to load\n  await bytebot.action({\n    action: 'wait',\n    duration: 2000\n  });\n  \n  // Take a screenshot\n  const result = await bytebot.screenshot();\n  console.log('Screenshot taken!');\n}\n\nexample().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Constructing JSON Requests for Keyboard and System Actions - JSON\nDESCRIPTION: These JSON code blocks represent request payloads for keyboard and system actions in the Bytebot API, including typing keys, pressing/releasing keys, inputting text, waiting, taking screenshots, and retrieving cursor position. Each block shows required and optional parameters for its action. Consumers must provide values according to the documented types and allowable values for correct API operation, and process the API response accordingly.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/computer-use.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"type_keys\\\",\\n  \\\"keys\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"enter\\\"],\\n  \\\"delay\\\": 50\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"press_keys\\\",\\n  \\\"keys\\\": [\\\"ctrl\\\", \\\"shift\\\", \\\"esc\\\"],\\n  \\\"press\\\": \\\"down\\\"\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"type_text\\\",\\n  \\\"text\\\": \\\"Hello, Bytebot!\\\",\\n  \\\"delay\\\": 50\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"wait\\\",\\n  \\\"duration\\\": 2000\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"screenshot\\\"\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"cursor_position\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Browser Automation using Python and Bytebot API\nDESCRIPTION: This Python script demonstrates how to automate browser interactions using the Bytebot API, including opening a browser, navigating to a website, taking screenshots, clicking links, and scrolling.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport time\n\ndef control_computer(action, **params):\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": action, **params}\n    response = requests.post(url, json=data)\n    return response.json()\n\ndef automate_browser():\n    # Open browser (assuming browser icon is at position x=100, y=960)\n    control_computer(\"move_mouse\", coordinates={\"x\": 100, \"y\": 960})\n    control_computer(\"click_mouse\", button=\"left\")\n    time.sleep(3)  # Wait for browser to open\n\n    # Type URL\n    control_computer(\"type_text\", text=\"https://example.com\")\n    control_computer(\"press_keys\", key=\"enter\")\n    time.sleep(2)  # Wait for page to load\n\n    # Take screenshot of the loaded page\n    screenshot = control_computer(\"screenshot\")\n\n    # Click on a link (coordinates would need to be adjusted for your target)\n    control_computer(\"move_mouse\", coordinates={\"x\": 300, \"y\": 400})\n    control_computer(\"click_mouse\", button=\"left\")\n    time.sleep(2)\n\n    # Scroll down\n    control_computer(\"scroll\", direction=\"down\", amount=500)\n\nautomate_browser()\n```\n\n----------------------------------------\n\nTITLE: Browser Workflow Automation with Python\nDESCRIPTION: Complete browser automation workflow implemented in Python. Demonstrates opening browser, navigation, searching, and scrolling using the Computer Use API.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport time\n\ndef control_computer(action, **params):\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": action, **params}\n    response = requests.post(url, json=data)\n    return response.json()\n\ndef browser_workflow():\n    # Open browser (assuming browser icon is at position x=100, y=960)\n    control_computer(\"move_mouse\", coordinates={\"x\": 100, \"y\": 960})\n    control_computer(\"click_mouse\", button=\"left\")\n    time.sleep(3)  # Wait for browser to open\n\n    # Type URL and navigate\n    control_computer(\"type_text\", text=\"https://example.com\")\n    control_computer(\"press_keys\", key=\"enter\")\n    time.sleep(2)  # Wait for page to load\n\n    # Take screenshot of the loaded page\n    screenshot = control_computer(\"screenshot\")\n\n    # Click on a link (coordinates would need to be adjusted for your target)\n    control_computer(\"move_mouse\", coordinates={\"x\": 300, \"y\": 400})\n    control_computer(\"click_mouse\", button=\"left\")\n    time.sleep(2)\n\n    # Scroll down\n    control_computer(\"scroll\", direction=\"down\", amount=500)\n\n    # Fill a search box\n    control_computer(\"move_mouse\", coordinates={\"x\": 600, \"y\": 200})\n    control_computer(\"click_mouse\", button=\"left\")\n    control_computer(\"type_text\", text=\"search query\")\n    control_computer(\"press_keys\", key=\"enter\")\n\nbrowser_workflow()\n```\n\n----------------------------------------\n\nTITLE: Controlling Bytebot Computer Actions via Requests Library - Python\nDESCRIPTION: This Python snippet showcases a function for automating Bytebot API calls using the 'requests' library. The function 'control_computer' constructs the request payload by merging the specified action with additional parameters, and posts it to the Bytebot /computer-use endpoint. The sample code illustrates moving the mouse and prints the server's response; 'requests' must be installed for this code to run, and an accessible Bytebot API server is assumed.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/computer-use.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport requests\\n\\ndef control_computer(action, **params):\\n    url = \\\"http://localhost:9990/computer-use\\\"\\n    data = {\\\"action\\\": action, **params}\\n    response = requests.post(url, json=data)\\n    return response.json()\\n\\n# Move the mouse\\nresult = control_computer(\\\"move_mouse\\\", coordinates={\\\"x\\\": 100, \\\"y\\\": 100})\\nprint(result)\n```\n\n----------------------------------------\n\nTITLE: Form Filling Workflow with JavaScript\nDESCRIPTION: Complete form filling automation including navigation, field input, and submission. Handles complex form interactions with tab navigation and confirmation screenshots.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require(\"axios\");\n\nasync function controlComputer(action, params = {}) {\n  const url = \"http://localhost:9990/computer-use\";\n  const data = { action, ...params };\n  const response = await axios.post(url, data);\n  return response.data;\n}\n\nasync function fillForm() {\n  // Navigate to form page\n  await controlComputer(\"move_mouse\", { coordinates: { x: 100, y: 960 } });\n  await controlComputer(\"click_mouse\", { button: \"left\" });\n  await controlComputer(\"wait\", { duration: 3000 });\n  await controlComputer(\"type_text\", { text: \"https://example.com/form\" });\n  await controlComputer(\"press_keys\", { key: \"enter\" });\n  await controlComputer(\"wait\", { duration: 2000 });\n\n  // Fill form\n  // Name field\n  await controlComputer(\"move_mouse\", { coordinates: { x: 400, y: 250 } });\n  await controlComputer(\"click_mouse\", { button: \"left\" });\n\n  // Type the value\n  await controlComputer(\"type_text\", { text: \"John Doe\" });\n\n  // Email field (tab to next field)\n  await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"down\" });\n  await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"up\" });\n  await controlComputer(\"type_text\", { text: \"john@example.com\" });\n\n  // Message field (tab to next field)\n  await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"down\" });\n  await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"up\" });\n  await controlComputer(\"type_text\", {\n    text: \"This is an automated message sent using Bytebot's Computer Use API\",\n    delay: 30,\n  });\n\n  // Submit form\n  await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"down\" });\n  await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"up\" });\n  await controlComputer(\"press_keys\", { key: \"enter\" });\n\n  // Take screenshot of confirmation page\n  await controlComputer(\"wait\", { duration: 2000 });\n  const screenshot = await controlComputer(\"screenshot\");\n\n  console.log(\"Form submitted successfully\");\n}\n\nfillForm().catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Implementing BytebotWebDriver for Web Testing in Python\nDESCRIPTION: This code snippet defines a BytebotWebDriver class that uses Bytebot's computer control API to perform web testing operations. It includes methods for opening a browser, navigating to URLs, clicking elements, typing text, pressing keys, and taking screenshots. The class interacts with a local Bytebot server running on port 9990.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport time\nimport json\n\nclass BytebotWebDriver:\n    def __init__(self, base_url=\"http://localhost:9990\"):\n        self.base_url = base_url\n\n    def control_computer(self, action, **params):\n        url = f\"{self.base_url}/computer-use\"\n        data = {\"action\": action, **params}\n        response = requests.post(url, json=data)\n        return response.json()\n\n    def open_browser(self, browser_icon_coords):\n        self.control_computer(\"move_mouse\", coordinates=browser_icon_coords)\n        self.control_computer(\"click_mouse\", button=\"left\")\n        time.sleep(3)  # Wait for browser to open\n\n    def navigate_to(self, url):\n        self.control_computer(\"type_text\", text=url)\n        self.control_computer(\"press_keys\", key=\"enter\")\n        time.sleep(2)  # Wait for page to load\n\n    def click_element(self, coords):\n        self.control_computer(\"move_mouse\", coordinates=coords)\n        self.control_computer(\"click_mouse\", button=\"left\")\n\n    def type_text(self, text):\n        self.control_computer(\"type_text\", text=text)\n\n    def press_keys(self, key, modifiers=None):\n        params = {\"key\": key}\n        if modifiers:\n            params[\"modifiers\"] = modifiers\n        self.control_computer(\"press_keys\", **params)\n\n    def take_screenshot(self):\n        return self.control_computer(\"screenshot\")\n\n# Usage example\ndriver = BytebotWebDriver()\ndriver.open_browser({\"x\": 100, \"y\": 960})\ndriver.navigate_to(\"https://example.com\")\ndriver.click_element({\"x\": 300, \"y\": 400})\ndriver.type_text(\"Hello Bytebot!\")\n```\n\n----------------------------------------\n\nTITLE: Advanced Screenshot Comparison using JavaScript and Bytebot API\nDESCRIPTION: This JavaScript code demonstrates how to take screenshots using the Bytebot API, save them, and prepare for comparison. It includes mouse movements and waiting between screenshots.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require('axios');\nconst fs = require('fs');\nconst { createCanvas, loadImage } = require('canvas');\nconst pixelmatch = require('pixelmatch');\n\nasync function controlComputer(action, params = {}) {\n  const url = \"http://localhost:9990/computer-use\";\n  const data = { action, ...params };\n\n  try {\n    const response = await axios.post(url, data);\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error.message);\n    return { success: false, error: error.message };\n  }\n}\n\nasync function compareScreenshots() {\n  try {\n    // Take first screenshot\n    const screenshot1 = await controlComputer(\"screenshot\");\n\n    // Do some actions\n    await controlComputer(\"move_mouse\", { coordinates: { x: 500, y: 500 } });\n    await controlComputer(\"click_mouse\", { button: \"left\" });\n    await controlComputer(\"wait\", { duration: 1000 });\n\n    // Take second screenshot\n    const screenshot2 = await controlComputer(\"screenshot\");\n\n    // Compare screenshots\n    if (screenshot1.success && screenshot2.success) {\n      const img1Data = Buffer.from(screenshot1.data.image, 'base64');\n      const img2Data = Buffer.from(screenshot2.data.image, 'base64');\n\n      fs.writeFileSync('screenshot1.png', img1Data);\n      fs.writeFileSync('screenshot2.png', img2Data);\n\n      // Now you could load and compare these images\n      // This requires additional image comparison libraries\n      console.log('Screenshots saved for comparison');\n    }\n  } catch (error) {\n    console.error(\"Screenshot comparison failed:\", error);\n  }\n}\n\ncompareScreenshots();\n```\n\n----------------------------------------\n\nTITLE: File Upload Dialog Automation using Python\nDESCRIPTION: This Python script demonstrates how to automate a file upload dialog using the Bytebot REST API. It includes functions for controlling the computer, clicking the upload button, typing the file path, confirming the upload, and taking a screenshot of the result.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport time\n\ndef control_computer(action, **params):\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": action, **params}\n    response = requests.post(url, json=data)\n    return response.json()\n\ndef upload_file(file_path=\"/path/to/file.txt\"):\n    # Click the upload button\n    control_computer(\"move_mouse\", coordinates={\"x\": 400, \"y\": 300})\n    control_computer(\"click_mouse\", button=\"left\")\n\n    # Wait for file dialog to appear\n    control_computer(\"wait\", duration=1000)\n\n    # Type the file path\n    control_computer(\"type_text\", text=file_path)\n\n    # Press Enter to confirm\n    control_computer(\"press_keys\", keys=[\"enter\"], press=\"down\")\n    control_computer(\"press_keys\", keys=[\"enter\"], press=\"up\")\n\n    # Wait for upload to complete\n    control_computer(\"wait\", duration=3000)\n\n    # Take screenshot of result\n    result = control_computer(\"screenshot\")\n    if result[\"success\"]:\n        print(\"File upload completed and screenshot taken\")\n\n# Run the automation\n# upload_file(\"/Users/username/Documents/example.pdf\")\n```\n\n----------------------------------------\n\nTITLE: Basic Automation using JavaScript and Bytebot API\nDESCRIPTION: This JavaScript code demonstrates basic automation using the Bytebot API, including opening an application, waiting, and typing text.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require('axios');\n\nasync function controlComputer(action, params = {}) {\n  const url = \"http://localhost:9990/computer-use\";\n  const data = { action, ...params };\n\n  try {\n    const response = await axios.post(url, data);\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error.message);\n    return { success: false, error: error.message };\n  }\n}\n\n// Example: Automate opening an application and typing\nasync function automateTextEditor() {\n  try {\n    // Open text editor by clicking its icon\n    await controlComputer(\"move_mouse\", { coordinates: { x: 150, y: 960 } });\n    await controlComputer(\"click_mouse\", { button: \"left\" });\n\n    // Wait for it to open\n    await controlComputer(\"wait\", { duration: 2000 });\n\n    // Type some text\n    await controlComputer(\"type_text\", {\n      text: \"This is an automated test using Node.js and Bytebot\",\n      delay: 30\n    });\n\n    console.log(\"Automation completed successfully\");\n\n  } catch (error) {\n    console.error(\"Automation failed:\", error);\n  }\n}\n\nautomateTextEditor();\n```\n\n----------------------------------------\n\nTITLE: Web Form Automation using Python and Bytebot API\nDESCRIPTION: This Python script demonstrates how to automate filling out a web form using the Bytebot API, including moving the mouse, typing text, and submitting the form.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport time\n\ndef control_computer(action, **params):\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": action, **params}\n    response = requests.post(url, json=data)\n    return response.json()\n\ndef fill_web_form(form_fields):\n    # Click on the first form field\n    control_computer(\"move_mouse\", coordinates=form_fields[0])\n    control_computer(\"click_mouse\", button=\"left\")\n\n    # Fill out each field\n    for i, field in enumerate(form_fields):\n        # Input the field value\n        control_computer(\"type_text\", text=field[\"value\"])\n\n        # If not the last field, press Tab to move to next field\n        if i < len(form_fields) - 1:\n            control_computer(\"press_keys\", key=\"tab\")\n            time.sleep(0.5)\n\n    # Submit the form by pressing Enter\n    control_computer(\"press_keys\", key=\"enter\")\n\n# Example form fields with coordinates and values\nform_fields = [\n    {\"x\": 500, \"y\": 300, \"value\": \"John Doe\"},\n    {\"x\": 500, \"y\": 350, \"value\": \"john@example.com\"},\n    {\"x\": 500, \"y\": 400, \"value\": \"Password123\"}\n]\n\nfill_web_form(form_fields)\n```\n\n----------------------------------------\n\nTITLE: Data Entry Form Automation with JavaScript\nDESCRIPTION: Automates filling out form fields with provided data. Handles mouse positioning, text input, and tab navigation between fields. Includes screenshot capture of results.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require('axios');\n\nasync function controlComputer(action, params = {}) {\n  const url = \"http://localhost:9990/computer-use\";\n  const data = { action, ...params };\n\n  try {\n    const response = await axios.post(url, data);\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error.message);\n    throw error;\n  }\n}\n\n// Function to fill a data entry form\nasync function fillDataEntryForm(formData) {\n  // Click on the first form field\n  await controlComputer(\"move_mouse\", { coordinates: { x: 400, y: 250 } });\n  await controlComputer(\"click_mouse\", { button: \"left\" });\n\n  // Fill each field and press Tab to move to the next\n  for (const [index, value] of formData.entries()) {\n    // Type the value\n    await controlComputer(\"type_text\", { text: value });\n\n    // If not the last field, press Tab to move to next field\n    if (index < formData.length - 1) {\n      await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"down\" });\n      await controlComputer(\"press_keys\", { keys: [\"tab\"], press: \"up\" });\n      await controlComputer(\"wait\", { duration: 300 });\n    }\n  }\n\n  // Find and click the submit button\n  await controlComputer(\"move_mouse\", { coordinates: { x: 400, y: 500 } });\n  await controlComputer(\"click_mouse\", { button: \"left\" });\n\n  // Take a screenshot of the result\n  const result = await controlComputer(\"screenshot\");\n  console.log(\"Form submitted successfully\");\n\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Taking and Saving a Screenshot using cURL and Bytebot API\nDESCRIPTION: This snippet shows how to capture a screenshot using the Bytebot API via cURL, and then save the resulting base64-encoded image data to a file.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Take a screenshot\nresponse=$(curl -s -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"screenshot\"}')\n\n# Extract the base64 image data and save to a file\necho $response | jq -r '.data.image' | base64 -d > screenshot.png\n```\n\n----------------------------------------\n\nTITLE: UI Testing Framework with JavaScript\nDESCRIPTION: Framework for automated UI testing with screenshot comparison. Tests UI elements by simulating clicks and capturing before/after screenshots. Includes file system operations for saving results.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require(\"axios\");\nconst fs = require(\"fs\");\n\nasync function controlComputer(action, params = {}) {\n  const url = \"http://localhost:9990/computer-use\";\n  const data = { action, ...params };\n\n  try {\n    const response = await axios.post(url, data);\n    return response.data;\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n    throw error;\n  }\n}\n\n// Simple UI testing framework\nasync function testUIElement(name, options) {\n  const { x, y, expectedResult } = options;\n\n  console.log(`Testing UI element: ${name}`);\n\n  // Take screenshot before interaction\n  const beforeShot = await controlComputer(\"screenshot\");\n  fs.writeFileSync(\n    `before_${name}.png`,\n    Buffer.from(beforeShot.data.image, \"base64\")\n  );\n\n  // Click the element\n  await controlComputer(\"move_mouse\", { coordinates: { x, y } });\n  await controlComputer(\"click_mouse\", { button: \"left\" });\n\n  // Wait for any UI changes\n  await controlComputer(\"wait\", { duration: 1000 });\n\n  // Take screenshot after interaction\n  const afterShot = await controlComputer(\"screenshot\");\n  fs.writeFileSync(\n    `after_${name}.png`,\n    Buffer.from(afterShot.data.image, \"base64\")\n  );\n\n  console.log(`Test for ${name} completed. Screenshots saved.`);\n\n  if (expectedResult && typeof expectedResult === \"function\") {\n    // Call custom verification function if provided\n    await expectedResult();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Automation using Python and Bytebot API\nDESCRIPTION: This Python script demonstrates basic automation tasks using the Bytebot API, including opening a web browser, typing a URL, and navigating to a website.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport json\nimport base64\nimport time\nfrom io import BytesIO\nfrom PIL import Image\n\ndef control_computer(action, **params):\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": action, **params}\n    response = requests.post(url, json=data)\n    return response.json()\n\n# Open a web browser by clicking an icon\ncontrol_computer(\"move_mouse\", coordinates={\"x\": 100, \"y\": 960})\ncontrol_computer(\"click_mouse\", button=\"left\")\n\n# Wait for the browser to open\ncontrol_computer(\"wait\", duration=2000)\n\n# Type a URL\ncontrol_computer(\"type_text\", text=\"https://example.com\")\ncontrol_computer(\"press_keys\", key=\"enter\")\n```\n\n----------------------------------------\n\nTITLE: Typing and Keyboard Shortcuts using cURL and Bytebot API\nDESCRIPTION: This example demonstrates how to simulate typing text and pressing keyboard shortcuts using the Bytebot API through cURL commands.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Type text in a text editor\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"type_text\", \"text\": \"Hello, this is an automated test!\", \"delay\": 30}'\n\n# Press Ctrl+S to save\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"press_keys\", \"key\": \"s\", \"modifiers\": [\"control\"]}'\n```\n\n----------------------------------------\n\nTITLE: Screenshot Monitoring using Python\nDESCRIPTION: This Python script demonstrates how to monitor the screen for changes using the Bytebot REST API. It includes functions for taking screenshots, saving them, and comparing them at regular intervals. The script can be used to monitor visual changes on the screen over a specified duration.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport base64\nimport time\nfrom io import BytesIO\nfrom PIL import Image\n\ndef take_screenshot():\n    url = \"http://localhost:9990/computer-use\"\n    response = requests.post(url, json={\"action\": \"screenshot\"})\n    if response.json()[\"success\"]:\n        img_data = base64.b64decode(response.json()[\"data\"][\"image\"])\n        return Image.open(BytesIO(img_data))\n    return None\n\ndef monitor_for_changes(interval=5, duration=60):\n    \"\"\"Monitor the screen for changes at regular intervals\"\"\"\n    first_screenshot = take_screenshot()\n    if not first_screenshot:\n        print(\"Failed to take initial screenshot\")\n        return\n\n    first_screenshot.save(\"baseline.png\")\n    print(\"Baseline screenshot saved\")\n\n    end_time = time.time() + duration\n    screenshot_count = 1\n\n    while time.time() < end_time:\n        time.sleep(interval)\n\n        current = take_screenshot()\n        if current:\n            filename = f\"screenshot_{screenshot_count}.png\"\n            current.save(filename)\n            print(f\"Saved {filename}\")\n            screenshot_count += 1\n\n    print(f\"Monitoring completed. Saved {screenshot_count} screenshots.\")\n\n# Run the monitoring for 30 seconds, taking a screenshot every 5 seconds\n# monitor_for_changes(interval=5, duration=30)\n```\n\n----------------------------------------\n\nTITLE: Taking and Saving Screenshot using cURL\nDESCRIPTION: This snippet shows how to take a screenshot using the Bytebot REST API and save it to a file using cURL. It captures the screenshot, extracts the base64 image data from the response, and saves it as a PNG file.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Take a screenshot\nresponse=$(curl -s -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"screenshot\"}')\n\n# Extract the base64 image data and save to a file\necho $response | jq -r '.data.image' | base64 -d > screenshot.png\necho \"Screenshot saved to screenshot.png\"\n```\n\n----------------------------------------\n\nTITLE: Opening a Web Browser using cURL and Bytebot API\nDESCRIPTION: This snippet demonstrates how to use cURL to interact with the Bytebot API for moving the mouse to a specific location and clicking to open a web browser.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Move to Firefox/Chrome icon in the dock and click it\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"move_mouse\", \"coordinates\": {\"x\": 100, \"y\": 960}}'\n\ncurl -X POST http://localhost:9990/computer-use \\\n -H \"Content-Type: application/json\" \\\n -d '{\"action\": \"click_mouse\", \"button\": \"left\", \"numClicks\": 1}'\n```\n\n----------------------------------------\n\nTITLE: Parsing Bytebot API Responses - JSON\nDESCRIPTION: These JSON code blocks illustrate expected responses from the Bytebot API for various actions: generic success, screenshot data, cursor position, and error handling. They provide sample output structures for consumers to use in client programs, showing fields such as 'success', 'data', and 'error'. These examples help client developers build logic for success evaluation, error detection, and extraction of pertinent information from the API.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/computer-use.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"success\\\": true\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"success\\\": true,\\n  \\\"data\\\": {\\n    \\\"image\\\": \\\"base64_encoded_image_data\\\"\\n  }\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"success\\\": true,\\n  \\\"data\\\": {\\n    \\\"x\\\": 123,\\n    \\\"y\\\": 456\\n  }\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"success\\\": false,\\n  \\\"error\\\": \\\"Error message\\\"\\n}\n```\n\n----------------------------------------\n\nTITLE: Pressing or Releasing Mouse Button - JSON\nDESCRIPTION: Shows a JSON request for the 'press_mouse' action, which presses or releases a mouse button at specified coordinates. 'coordinates' is optional, 'button' is required ('left', 'right', 'middle'), and 'press' must be 'up' or 'down'. The result is a confirmation of the action.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"press_mouse\",\n  \"coordinates\": {\n    \"x\": 150,\n    \"y\": 250\n  },\n  \"button\": \"left\",\n  \"press\": \"down\"\n}\n```\n\n----------------------------------------\n\nTITLE: Tracing Mouse Path - JSON\nDESCRIPTION: Shows a JSON request for the 'trace_mouse' action, which smoothly moves the mouse along a user-defined array of coordinate points. Optionally includes a 'holdKeys' array for modifier keys (e.g., 'shift'). Requires the 'path' array with coordinate objects. Result is a success confirmation.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"trace_mouse\",\n  \"path\": [\n    { \"x\": 100, \"y\": 100 },\n    { \"x\": 150, \"y\": 150 },\n    { \"x\": 200, \"y\": 200 }\n  ],\n  \"holdKeys\": [\"shift\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Screenshot and Analysis using Python and Bytebot API\nDESCRIPTION: This Python script captures a screenshot using the Bytebot API, saves it, and performs basic image analysis using OpenCV, including edge detection.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/examples.mdx#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport json\nimport base64\nimport cv2\nimport numpy as np\nfrom PIL import Image\nfrom io import BytesIO\n\ndef take_screenshot():\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": \"screenshot\"}\n    response = requests.post(url, json=data)\n\n    if response.json()[\"success\"]:\n        img_data = base64.b64decode(response.json()[\"data\"][\"image\"])\n        image = Image.open(BytesIO(img_data))\n        return np.array(image)\n    return None\n\n# Take a screenshot\nimg = take_screenshot()\n\n# Convert to grayscale for analysis\nif img is not None:\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\n    # Save the screenshot\n    cv2.imwrite(\"screenshot.png\", img)\n\n    # Perform image analysis (example: find edges)\n    edges = cv2.Canny(gray, 100, 200)\n    cv2.imwrite(\"edges.png\", edges)\n```\n\n----------------------------------------\n\nTITLE: Calling Bytebot API for Desktop Actions with Axios - JavaScript\nDESCRIPTION: This JavaScript snippet uses the 'axios' library to perform asynchronous requests to the Bytebot API endpoint for computer actions. The 'controlComputer' function accepts an action string and optional parameters object, sends a POST request, and returns the server's response. The sample invocation demonstrates a mouse move operation; the snippet requires 'axios' to be installed and an accessible API endpoint. Promises are used for async result handling.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/computer-use.mdx#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require(\\\"axios\\\");\\n\\nasync function controlComputer(action, params = {}) {\\n  const url = \\\"http://localhost:9990/computer-use\\\";\\n  const data = { action, ...params };\\n  const response = await axios.post(url, data);\\n  return response.data;\\n}\\n\\n// Move mouse example\\ncontrolComputer(\\\"move_mouse\\\", { coordinates: { x: 100, y: 100 } })\\n  .then((result) => console.log(result))\\n  .catch((error) => console.error(\\\"Error:\\\", error));\n```\n\n----------------------------------------\n\nTITLE: Posting Computer Action Requests with cURL - Bash\nDESCRIPTION: This Bash (cURL) example demonstrates sending a POST request to the Bytebot API endpoint to move the mouse to specific coordinates. It sets the appropriate Content-Type header and sends a JSON payload in the request body. cURL must be installed on the client machine, and the Bytebot service must be accessible at the provided localhost address for the example to function.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/computer-use.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST http://localhost:9990/computer-use \\\\n  -H \\\"Content-Type: application/json\\\" \\\\n  -d '{\"action\": \"move_mouse\", \"coordinates\": {\"x\": 100, \"y\": 200}}'\n```\n\n----------------------------------------\n\nTITLE: Clicking Mouse Button - JSON\nDESCRIPTION: Provides a JSON request for 'click_mouse', enabling mouse button clicks at a target location. Accepts an optional 'coordinates' object, required 'button' string ('left', 'right', or 'middle'), and an optional 'numClicks' count. Supports optional 'holdKeys' for modifier keys. The service clicks as instructed and returns a success flag.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"click_mouse\",\n  \"coordinates\": {\n    \"x\": 150,\n    \"y\": 250\n  },\n  \"button\": \"left\",\n  \"numClicks\": 2\n}\n```\n\n----------------------------------------\n\nTITLE: Scrolling - JSON\nDESCRIPTION: Illustrates a JSON payload for the 'scroll' action, scrolling by a specified pixel 'amount' in a given 'direction' at optional coordinates. Main parameters are 'direction' ('up', 'down', 'left', 'right') and 'amount' (integer); modifier keys are optional. The service scrolls and returns success.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"scroll\",\n  \"direction\": \"down\",\n  \"amount\": 100\n}\n```\n\n----------------------------------------\n\nTITLE: Typing Sequence of Keys - JSON\nDESCRIPTION: Shows how to type a series of keys using the 'type_keys' action. Expects a 'keys' array (such as ['a', 'enter']) and optional 'delay' for inter-key timing in milliseconds. The endpoint types keys as instructed and returns a success message.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"type_keys\",\n  \"keys\": [\"a\", \"b\", \"c\", \"enter\"],\n  \"delay\": 50\n}\n```\n\n----------------------------------------\n\nTITLE: Typing Text String With Delay - JSON\nDESCRIPTION: Sends a 'type_text' command to type an arbitrary string. The required 'text' key gives the content to type; optional 'delay' sets the time between character inputs. The endpoint types the text and replies with a status result.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"type_text\",\n  \"text\": \"Hello, Bytebot!\",\n  \"delay\": 50\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing JSON Requests for Mouse Movement - JSON\nDESCRIPTION: These JSON code blocks demonstrate requests for performing mouse actions in the Bytebot desktop environment, such as moving, tracing, clicking, pressing, dragging, and scrolling the mouse. Inputs include action types and relevant parameters (coordinates, buttons, paths). The outputs are expected to be processed by the Bytebot API, and these JSON blobs serve as payloads for client applications or documentation. No code dependencies required, but consumers must ensure data structure validity and correct value usage.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/computer-use.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"move_mouse\\\",\\n  \\\"coordinates\\\": {\\n    \\\"x\\\": 100,\\n    \\\"y\\\": 200\\n  }\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"trace_mouse\\\",\\n  \\\"path\\\": [\\n    { \\\"x\\\": 100, \\\"y\\\": 100 },\\n    { \\\"x\\\": 150, \\\"y\\\": 150 },\\n    { \\\"x\\\": 200, \\\"y\\\": 200 }\\n  ],\\n  \\\"holdKeys\\\": [\\\"shift\\\"]\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"click_mouse\\\",\\n  \\\"coordinates\\\": {\\n    \\\"x\\\": 150,\\n    \\\"y\\\": 250\\n  },\\n  \\\"button\\\": \\\"left\\\",\\n  \\\"numClicks\\\": 2\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"press_mouse\\\",\\n  \\\"coordinates\\\": {\\n    \\\"x\\\": 150,\\n    \\\"y\\\": 250\\n  },\\n  \\\"button\\\": \\\"left\\\",\\n  \\\"press\\\": \\\"down\\\"\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"drag_mouse\\\",\\n  \\\"path\\\": [\\n    { \\\"x\\\": 100, \\\"y\\\": 100 },\\n    { \\\"x\\\": 200, \\\"y\\\": 200 }\\n  ],\\n  \\\"button\\\": \\\"left\\\"\\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"action\\\": \\\"scroll\\\",\\n  \\\"direction\\\": \\\"down\\\",\\n  \\\"amount\\\": 100\\n}\n```\n\n----------------------------------------\n\nTITLE: Web Form Automation using Python\nDESCRIPTION: This Python script demonstrates how to automate filling out a web form using the Bytebot REST API. It includes functions for controlling the computer, navigating to a form, typing text, pressing keys, and submitting the form.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport requests\nimport time\n\ndef control_computer(action, **params):\n    url = \"http://localhost:9990/computer-use\"\n    data = {\"action\": action, **params}\n    response = requests.post(url, json=data)\n    return response.json()\n\ndef fill_web_form():\n    # Navigate to a form (e.g., login form)\n    control_computer(\"move_mouse\", coordinates={\"x\": 500, \"y\": 300})\n    control_computer(\"click_mouse\", button=\"left\")\n\n    # Type username\n    control_computer(\"type_text\", text=\"user@example.com\")\n\n    # Tab to password field\n    control_computer(\"type_keys\", keys=[\"tab\"])\n\n    # Type password\n    control_computer(\"type_text\", text=\"secure_password\")\n\n    # Tab to login button\n    control_computer(\"type_keys\", keys=[\"tab\"])\n\n    # Press Enter to submit\n    control_computer(\"type_keys\", keys=[\"enter\"])\n\n    # Wait for page to load\n    control_computer(\"wait\", duration=2000)\n\n    print(\"Form submitted successfully\")\n\n# Run the automation\n# fill_web_form()\n```\n\n----------------------------------------\n\nTITLE: Copying and Pasting Text using cURL\nDESCRIPTION: This snippet demonstrates how to copy and paste text using the Bytebot REST API with cURL commands. It includes selecting text with a triple click, copying with Ctrl+C, moving the mouse to a new location, and pasting with Ctrl+V.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Select text with triple click (selects a paragraph)\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"move_mouse\", \"coordinates\": {\"x\": 400, \"y\": 300}}'\n\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"click_mouse\", \"button\": \"left\", \"numClicks\": 3}'\n\n# Copy with Ctrl+C\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"press_keys\", \"keys\": [\"ctrl\", \"c\"], \"press\": \"down\"}'\n\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"press_keys\", \"keys\": [\"ctrl\", \"c\"], \"press\": \"up\"}'\n\n# Click elsewhere to paste\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"move_mouse\", \"coordinates\": {\"x\": 400, \"y\": 500}}'\n\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"click_mouse\", \"button\": \"left\"}'\n\n# Paste with Ctrl+V\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"press_keys\", \"keys\": [\"ctrl\", \"v\"], \"press\": \"down\"}'\n\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"press_keys\", \"keys\": [\"ctrl\", \"v\"], \"press\": \"up\"}'\n```\n\n----------------------------------------\n\nTITLE: Opening Application and Navigating Web Page using cURL\nDESCRIPTION: This snippet demonstrates how to use cURL commands to open an application, navigate to a web page, and interact with the browser using the Bytebot REST API. It includes mouse movements, clicks, typing text, and key presses.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Open an application (like Firefox)\ncurl -X POST http://localhost:9990/computer-use \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"action\": \"move_mouse\", \"coordinates\": {\"x\": 100, \"y\": 950}}'\n\ncurl -X POST http://localhost:9990/computer-use \\\n -H \"Content-Type: application/json\" \\\n -d '{\"action\": \"click_mouse\", \"button\": \"left\", \"numClicks\": 2}'\n\n# Wait for application to open\n\ncurl -X POST http://localhost:9990/computer-use \\\n -H \"Content-Type: application/json\" \\\n -d '{\"action\": \"wait\", \"duration\": 150}'\n\n# Type URL in address bar\n\ncurl -X POST http://localhost:9990/computer-use \\\n -H \"Content-Type: application/json\" \\\n -d '{\"action\": \"type_text\", \"text\": \"https://example.com\"}'\n\n# Press Enter to navigate\n\ncurl -X POST http://localhost:9990/computer-use \\\n -H \"Content-Type: application/json\" \\\n -d '{\"action\": \"typ_keys\", \"keys\": [\"enter\"]}'\n```\n\n----------------------------------------\n\nTITLE: Running Bytebot in Docker Container - Bash\nDESCRIPTION: This Bash snippet demonstrates how to launch the Bytebot desktop agent using Docker. It creates a privileged detached container, maps essential service ports (9990: noVNC, 5900: VNC, 6080/6081: auxiliary), assigns a hostname, and names the container. The only dependency is Docker (>=20.10); the command pulls the latest 'edge' image from GitHub Container Registry. Key parameters are port-mappings, container name, and image tag; inputs are container runtime options, and it outputs a running Bytebot instance.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --privileged -d \\\n  -p 9990:9990 -p 5900:5900 -p 6080:6080 -p 6081:6081 \\\n  -h computer \\\n  --name bytebot \\\n  ghcr.io/bytebot-ai/bytebot:edge\n```\n\n----------------------------------------\n\nTITLE: Setting Up Environment and Launching Full Agent Stack with Docker Compose - Bash\nDESCRIPTION: This snippet initializes a .env file with the required Anthropic API key and launches the complete Bytebot agent stack using docker-compose. It creates the environment file in 'infrastructure/docker', then runs docker-compose with the specified YAML and .env file, starting containers in detached mode. Dependencies are docker-compose and a valid Anthropic API key. Key parameters are file paths and environment variables; input is the API key, and output is the full stack running in containers.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\necho \"ANTHROPIC_API_KEY=your_api_key_here\" > infrastructure/docker/.env\n\ndocker-compose -f infrastructure/docker/docker-compose.yml \\\n  --env-file infrastructure/docker/.env up -d     #  start everything\n```\n\n----------------------------------------\n\nTITLE: Moving Mouse Cursor - JSON\nDESCRIPTION: Demonstrates a JSON request to move the mouse cursor to a specific screen position using the 'move_mouse' action. Requires the 'coordinates' object with mandatory integer 'x' and 'y'. No special dependencies beyond endpoint access. Responds with a success status upon completion.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"move_mouse\",\n  \"coordinates\": {\n    \"x\": 100,\n    \"y\": 200\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running Bytebot Locally - Bash\nDESCRIPTION: This snippet shows how to build and run the Bytebot project using local shell scripts. The './scripts/build.sh' script builds the Docker image, while './scripts/run.sh' starts the container. Prerequisites include Docker installed and project-specific scripts accessible and executable. Inputs are commands only; outputs include a built image and a live container.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/build.sh   #  build\n./scripts/run.sh     #  run\n```\n\n----------------------------------------\n\nTITLE: Dragging Mouse Along Path - JSON\nDESCRIPTION: Example request for initiating a mouse drag operation using the 'drag_mouse' action. Requires a 'path' array of coordinate objects and a 'button' to hold. Optional 'holdKeys' can modify the drag. The endpoint drags the mouse and signals success upon completion.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"drag_mouse\",\n  \"path\": [\n    { \"x\": 100, \"y\": 100 },\n    { \"x\": 200, \"y\": 200 }\n  ],\n  \"button\": \"left\"\n}\n```\n\n----------------------------------------\n\nTITLE: Task API Usage Example - Python (requests)\nDESCRIPTION: This Python example illustrates interacting with the Bytebot Tasks API using the requests library, including functions to create a new task and get the current in-progress task. It prints the results and assumes the 'requests' package is installed and the API server is running on localhost.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nimport requests\n\ndef create_task(description):\n    response = requests.post(\n        \"http://localhost:9991/tasks\",\n        json={\n            \"description\": description\n        }\n    )\n    return response.json()\n\ndef find_in_progress_task():\n    response = requests.get(\"http://localhost:9991/tasks/in-progress\")\n    return response.json()\n\n# Example usage\ndef main():\n    # Create a new task\n    task = create_task(\"Compare React, Vue, and Angular for a new project\")\n    print(f\"Created task: {task}\")\n    \n    # Get current in-progress task\n    in_progress_task = find_in_progress_task()\n    print(f\"In progress task: {in_progress_task}\")\n```\n\n----------------------------------------\n\nTITLE: Pressing or Releasing Keyboard Keys - JSON\nDESCRIPTION: Example for the 'press_keys' action, which presses or releases keyboard keys. Takes a 'keys' array and a 'press' property ('down' or 'up'). Used for keyboard shortcut actions or modifier holds. Responds with action confirmation.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"press_keys\",\n  \"keys\": [\"ctrl\", \"shift\", \"esc\"],\n  \"press\": \"down\"\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Cursor Position - JSON\nDESCRIPTION: Uses the 'cursor_position' action to query and return the current mouse cursor screen location. No parameters required. The service replies with an object holding integer 'x' and 'y' in the data field.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"cursor_position\"\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Full Agent System with Docker Compose\nDESCRIPTION: Commands for starting and stopping the full Bytebot system including desktop container, databases, agent service, and chat UI.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/quickstart.mdx#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose -f infrastructure/docker/docker-compose.yml --env-file infrastructure/docker/.env up -d\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose -f infrastructure/docker/docker-compose.yml --env-file infrastructure/docker/.env down\n```\n\n----------------------------------------\n\nTITLE: Defining Task Model - TypeScript\nDESCRIPTION: This TypeScript snippet models the structure of a task used by the API, specifying the required fields and value constraints for status and priority. It can be used in frontend or backend TypeScript applications interfacing with the Bytebot Tasks API. No external dependencies are needed, but integration assumes compatibility with the documented REST API.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n{\n  id: string;\n  description: string; \n  status: 'PENDING' | 'IN_PROGRESS' | 'NEEDS_HELP' | 'NEEDS_REVIEW' | 'COMPLETED' | 'CANCELLED' | 'FAILED';\n  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'URGENT';\n  createdAt: string; \n  updatedAt: string; \n}\n```\n\n----------------------------------------\n\nTITLE: Screenshot Action Response - JSON\nDESCRIPTION: Response to a screenshot request. Contains a 'success' property and a 'data' object with a base64-encoded 'image' property. The 'image' value contains the raw binary image data encoded as a base64 string.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": true,\n  \"data\": {\n    \"image\": \"base64_encoded_image_data\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Task Creation/Fetch/Update/Detail Response - JSON\nDESCRIPTION: This JSON structure represents the full task object as returned by the API after creation, fetching by ID, or updating. Key properties include 'id', 'description', 'status', 'priority', 'createdAt', and 'updatedAt'. For 'GET /tasks/:id', a 'messages' array is also included containing message objects related to the task.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"id\": \"task-123\",\n  \"description\": \"This is a description of the task\",\n  \"status\": \"PENDING\",\n  \"priority\": \"MEDIUM\",\n  \"createdAt\": \"2025-04-14T12:00:00Z\",\n  \"updatedAt\": \"2025-04-14T12:00:00Z\"\n}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n[\n  {\n    \"id\": \"task-123\",\n    \"description\": \"This is a description of the task\",\n    \"status\": \"PENDING\",\n    \"priority\": \"MEDIUM\",\n    \"createdAt\": \"2025-04-14T12:00:00Z\",\n    \"updatedAt\": \"2025-04-14T12:00:00Z\"\n  },\n  // ...more tasks\n]\n```\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"id\": \"task-123\",\n  \"description\": \"This is a description of the task\",\n  \"status\": \"IN_PROGRESS\",\n  \"priority\": \"MEDIUM\",\n  \"createdAt\": \"2025-04-14T12:00:00Z\",\n  \"updatedAt\": \"2025-04-14T12:00:00Z\"\n}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"id\": \"task-123\",\n  \"description\": \"This is a description of the task\",\n  \"status\": \"PENDING\",\n  \"priority\": \"MEDIUM\",\n  \"createdAt\": \"2025-04-14T12:00:00Z\",\n  \"updatedAt\": \"2025-04-14T12:00:00Z\",\n  \"messages\": [\n    {\n      \"id\": \"msg-456\",\n      \"content\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"This is a message\"\n        }\n      ],\n      \"role\": \"USER\",\n      \"taskId\": \"task-123\",\n      \"createdAt\": \"2025-04-14T12:05:00Z\",\n      \"updatedAt\": \"2025-04-14T12:05:00Z\"\n    }\n    // ...more messages\n  ]\n}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"status\": \"COMPLETED\", \n  \"priority\": \"HIGH\" \n}\n```\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"id\": \"task-123\",\n  \"description\": \"This is a description of the task\",\n  \"status\": \"COMPLETED\",\n  \"priority\": \"HIGH\",\n  \"createdAt\": \"2025-04-14T12:00:00Z\",\n  \"updatedAt\": \"2025-04-14T12:01:00Z\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Base URL for Bytebot API\nDESCRIPTION: Specifies the base URL for all Bytebot API endpoints. The port can be configured when running the container.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/introduction.mdx#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhttp://localhost:9990\n```\n\n----------------------------------------\n\nTITLE: Configuring Bytebot API Base URL\nDESCRIPTION: The base URL for all Bytebot API endpoints. The API runs on localhost with port 9990 by default, which can be configured when running the container.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/introduction.mdx#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhttp://localhost:9990\n```\n\n----------------------------------------\n\nTITLE: Standard Action Response - JSON\nDESCRIPTION: Shows the typical response to a successful action execution, containing a single 'success' boolean property. Structure is consistent across most actions that do not return data.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Task Creation Request Body - JSON\nDESCRIPTION: This JSON object represents the required payload for creating a new task via POST /tasks. Only the 'description' field is required, providing details about the new task. The response to this request is a full task object populated by the server.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"description\": \"This is a description of the task\"\n}\n```\n\n----------------------------------------\n\nTITLE: Waiting for Duration - JSON\nDESCRIPTION: Shows a 'wait' action example, pausing further actions for the supplied 'duration' in milliseconds. Essential for timing control in automation scripts. No dependencies beyond access to the Bytebot endpoint.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"wait\",\n  \"duration\": 2000\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Environment Variables\nDESCRIPTION: Creates environment file with Anthropic API key for the agent system.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/quickstart.mdx#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\necho \"ANTHROPIC_API_KEY=your_api_key_here\" > infrastructure/docker/.env\n```\n\n----------------------------------------\n\nTITLE: Cursor Position Action Response - JSON\nDESCRIPTION: Reply to a 'cursor_position' request, providing the current X and Y coordinates in the 'data' object. Both values are integers indicating screen position. Returned with 'success: true'.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": true,\n  \"data\": {\n    \"x\": 123,\n    \"y\": 456\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Errors in Bytebot API Responses\nDESCRIPTION: Demonstrates the JSON structure returned when an error occurs in the API, including a false success status and detailed error message.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/introduction.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": false,\n  \"data\": null,\n  \"error\": \"Detailed error message\"\n}\n```\n\n----------------------------------------\n\nTITLE: Capturing Screenshot - JSON\nDESCRIPTION: Performs a desktop screenshot with the 'screenshot' action. No parameters required. The endpoint returns a success flag and a 'data' object holding the screenshot as base64 image data in the response.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"action\": \"screenshot\"\n}\n```\n\n----------------------------------------\n\nTITLE: Standard Error Response - JSON\nDESCRIPTION: Response to any failed action attempt, providing 'success: false' and an 'error' string explaining the cause. This helps clients detect and handle error conditions.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/computer-use/unified-endpoint.mdx#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": false,\n  \"error\": \"Error message\"\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Error Responses in JSON Format\nDESCRIPTION: Standard JSON response format for API calls that result in errors. The response includes a false success flag, null data, and a detailed error message.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/introduction.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": false,\n  \"data\": null,\n  \"error\": \"Detailed error message\"\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping Bytebot Agent Stack via Docker Compose - Bash\nDESCRIPTION: This Bash snippet stops and removes all containers and resources defined in the Bytebot agent stack using docker-compose. It uses the same YAML and .env file as during setup, ensuring a clean shutdown. It requires docker-compose and target files present; output is all services stopped and cleaned up.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker-compose -f infrastructure/docker/docker-compose.yml \\\n  --env-file infrastructure/docker/.env down\n```\n\n----------------------------------------\n\nTITLE: Task API Usage Example - JavaScript (axios)\nDESCRIPTION: This JavaScript example demonstrates how to create a new task and fetch the current in-progress task using the axios HTTP client. It defines asynchronous functions for each operation and a 'main' function to run the full workflow. Requires Node.js with the 'axios' package installed.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst axios = require('axios');\n\nasync function createTask(description) {\n  const response = await axios.post('http://localhost:9991/tasks', {\n    description\n  });\n  return response.data;\n}\n\nasync function findInProgressTask() {\n  const response = await axios.get('http://localhost:9991/tasks/in-progress');\n  return response.data;\n}\n\n// Example usage\nasync function main() {\n  // Create a new task\n  const task = await createTask('Compare React, Vue, and Angular for a new project');\n  console.log('Created task:', task);\n  \n  // Get current in-progress task\n  const inProgressTask = await findInProgressTask();\n  console.log('In progress task:', inProgressTask);\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Successful API Responses in JSON Format\nDESCRIPTION: Standard JSON response format for successful API calls. The response includes a success flag, data specific to the action, and a null error field.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/introduction.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": true,\n  \"data\": { ... },  // Response data specific to the action\n  \"error\": null     // Error message if success is false\n}\n```\n\n----------------------------------------\n\nTITLE: Error Response Structure - JSON\nDESCRIPTION: This JSON snippet shows the structure of error responses returned by the Task API, including 'statusCode', 'message', and 'error' fields. The snippet helps clients parse and handle error situations, such as missing resources or invalid parameters.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"statusCode\": 404,\n  \"message\": \"Task with ID task-123 not found\",\n  \"error\": \"Not Found\"\n}\n```\n\n----------------------------------------\n\nTITLE: Message Content Block Structure - TypeScript\nDESCRIPTION: This TypeScript snippet defines the message block structure compatible with Anthropic's Claude API, including interfaces for generic content blocks and specific types such as text and image. It highlights how messages can be constructed with polymorphic content and describes the layout of image data using base64-encoded sources.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\ntype MessageContent = MessageContentBlock[];\n\ninterface MessageContentBlock {\n  type: string;  \n  [key: string]: any;  \n}\n\ninterface TextContentBlock {\n  type: \"text\";\n  text: string;\n}\n\ninterface ImageContentBlock {\n  type: \"image\";\n  source: {\n    type: \"base64\";\n    media_type: string;  \n    data: string;  \n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing the Bytebot Chat UI URL\nDESCRIPTION: The URL where the Bytebot Chat UI can be accessed when running the full Bytebot agent system. This local URL exposes the web interface on port 9992.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/ui.mdx#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nhttp://localhost:9992\n```\n\n----------------------------------------\n\nTITLE: Task API Example Requests - cURL\nDESCRIPTION: These cURL command examples demonstrate how to create a new task and retrieve the current in-progress task using Bytebot's API. The POST request sends JSON data to create a task, and the GET request fetches the in-progress task. Requires a shell environment with cURL installed and the API accessible at localhost.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/tasks.mdx#_snippet_7\n\nLANGUAGE: cURL\nCODE:\n```\n# Create a new task\ncurl -X POST http://localhost:9991/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"description\": \"Compare React, Vue, and Angular for a new project\"\n  }'\n\n# Get current in-progress task\ncurl -X GET http://localhost:9991/tasks/in-progress\n```\n\n----------------------------------------\n\nTITLE: Defining GET /plants OpenAPI Endpoint\nDESCRIPTION: This YAML snippet specifies the OpenAPI structure for a GET endpoint to retrieve plant data. It includes the endpoint path and HTTP method.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/endpoint/get.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: 'Get Plants'\nopenapi: 'GET /plants'\n---\n```\n\n----------------------------------------\n\nTITLE: Defining Task and TaskStatus Interfaces in TypeScript\nDESCRIPTION: This snippet defines the core data structures for task management in the Bytebot agent system. It includes the Task interface with properties like id, description, and status, as well as enums for TaskStatus and TaskPriority.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/core-concepts/agent-system.mdx#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Task {\n  id: string;\n  description: string;\n  status: TaskStatus;\n  priority: TaskPriority;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nenum TaskStatus {\n  PENDING,\n  IN_PROGRESS,\n  NEEDS_HELP,\n  NEEDS_REVIEW,\n  COMPLETED,\n  CANCELLED,\n  FAILED,\n}\n\nenum TaskPriority {\n  LOW,\n  MEDIUM,\n  HIGH,\n  URGENT,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Message and ContentBlock Interfaces in TypeScript\nDESCRIPTION: This snippet outlines the structure for the message system in Bytebot, using Anthropic's content block format. It defines interfaces for Message, MessageContentBlock, and specific content block types like TextContentBlock and ImageContentBlock.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/core-concepts/agent-system.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Message {\n  id: string;\n  content: MessageContentBlock[];\n  role: MessageRole;\n  taskId: string;\n  summaryId?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nenum MessageRole {\n  USER,\n  ASSISTANT,\n}\n\ninterface MessageContentBlock {\n  type: string;\n  [key: string]: any;\n}\n\ninterface TextContentBlock extends MessageContentBlock {\n  type: \"text\";\n  text: string;\n}\n\ninterface ImageContentBlock extends MessageContentBlock {\n  type: \"image\";\n  source: {\n    type: \"base64\";\n    media_type: string;\n    data: string;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Message Structure Interface in TypeScript\nDESCRIPTION: TypeScript interfaces defining the message structure used by the Bytebot Chat UI. It includes the main Message interface and different types of MessageContentBlock interfaces that represent text, images, and other content types.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/agent/ui.mdx#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Message {\n  id: string;\n  content: MessageContentBlock[];\n  role: MessageRole; // \"USER\" or \"ASSISTANT\"\n  createdAt?: string;\n}\n\ninterface MessageContentBlock {\n  type: string;\n  [key: string]: any;\n}\n\ninterface TextContentBlock extends MessageContentBlock {\n  type: \"text\";\n  text: string;\n}\n\ninterface ImageContentBlock extends MessageContentBlock {\n  type: \"image\";\n  source: {\n    type: \"base64\";\n    media_type: string;\n    data: string;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Building Custom Bytebot Docker Image\nDESCRIPTION: Commands for building and running a custom Bytebot Docker image using build scripts with optional parameters.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/quickstart.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/build.sh\n```\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/build.sh --tag custom-tag --no-cache\n```\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/run.sh\n```\n\n----------------------------------------\n\nTITLE: Running Standalone Bytebot Container\nDESCRIPTION: Launches the pre-built Bytebot Docker container with exposed ports for API access (9990), VNC (5900), and noVNC (6080, 6081).\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/quickstart.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --privileged -d \\\n  -p 9990:9990 -p 5900:5900 -p 6080:6080 -p 6081:6081 \\\n  --name \"bytebot\" \\\n  ghcr.io/bytebot-ai/bytebot:edge\n```\n\n----------------------------------------\n\nTITLE: Displaying Bytebot Logo in HTML\nDESCRIPTION: This HTML snippet displays the Bytebot logo, with different versions for light and dark modes. It uses conditional classes to show/hide the appropriate logo based on the color scheme.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/introduction.mdx#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<p align=\"center\">\n  <img\n    className=\"block dark:hidden\"\n    src=\"/logo/bytebot_transparent_logo_dark.svg\"\n    alt=\"Bytebot Logo\"\n    width=\"500\"\n  />\n  <img\n    className=\"hidden dark:block\"\n    src=\"/logo/bytebot_transparent_logo_white.svg\"\n    alt=\"Bytebot Logo\"\n    width=\"500\"\n  />\n</p>\n```\n\n----------------------------------------\n\nTITLE: Browser Navigation Automation with JavaScript\nDESCRIPTION: Demonstrates automated browser control including opening the browser, navigating to URLs, and interacting with the address bar. Uses axios for API calls and includes mouse movement, clicking, and keyboard control.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/rest-api/examples.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst axios = require('axios');\n\nasync function controlComputer(action, params = {}) {\nconst url = \"http://localhost:9990/computer-use\";\nconst data = { action, ...params };\n\ntry {\nconst response = await axios.post(url, data);\nreturn response.data;\n} catch (error) {\nconsole.error('Error:', error.message);\nthrow error;\n}\n}\n\nasync function navigateToWebsite(url) {\nconsole.log(`Navigating to ${url}...`);\n\n// Open Firefox/Chrome by clicking on dock icon\nawait controlComputer(\"move_mouse\", { coordinates: { x: 100, y: 950 } });\nawait controlComputer(\"click_mouse\", { button: \"left\" });\n\n// Wait for browser to open\nawait controlComputer(\"wait\", { duration: 2000 });\n\n// Click in URL bar (usually near the top)\nawait controlComputer(\"move_mouse\", { coordinates: { x: 400, y: 60 } });\nawait controlComputer(\"click_mouse\", { button: \"left\" });\n\n// Select all existing text (Cmd+A on Mac, Ctrl+A elsewhere)\nawait controlComputer(\"press_keys\", { keys: [\"ctrl\"], press: \"down\" });\nawait controlComputer(\"press_keys\", { keys: [\"a\"], press: \"down\" });\nawait controlComputer(\"press_keys\", { keys: [\"a\"], press: \"up\" });\nawait controlComputer(\"press_keys\", { keys: [\"ctrl\"], press: \"up\" });\n\n// Type the URL\nawait controlComputer(\"type_text\", { text: url });\n\n// Press Enter to navigate\nawait controlComputer(\"press_keys\", { keys: [\"enter\"], press: \"down\" });\nawait controlComputer(\"press_keys\", { keys: [\"enter\"], press: \"up\" });\n\n// Wait for page to load\nawait controlComputer(\"wait\", { duration: 3000 });\n\nconsole.log(\"Navigation completed\");\n}\n```\n\n----------------------------------------\n\nTITLE: Structuring Standard JSON Response for Bytebot API\nDESCRIPTION: Defines the standard JSON format for all API responses, including success status, data payload, and error information.\nSOURCE: https://github.com/bytebot-ai/bytebot/blob/main/docs/api-reference/introduction.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"success\": true,\n  \"data\": { ... },  // Response data specific to the action\n  \"error\": null     // Error message if success is false\n}\n```"
  }
]