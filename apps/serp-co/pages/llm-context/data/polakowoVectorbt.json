[
  {
    "owner": "polakowo",
    "repo": "vectorbt",
    "content": "TITLE: Optimizing Dual SMA Crossover Strategy with vectorbt in Python\nDESCRIPTION: This code tests 10,000 window combinations of a dual SMA crossover strategy on BTC, ETH, and LTC. It generates a heatmap to visualize the total return for each combination of fast and slow moving average windows.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"BTC-USD\", \"ETH-USD\", \"LTC-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nwindows = np.arange(2, 101)\nfast_ma, slow_ma = vbt.MA.run_combs(price, window=windows, r=2, short_names=['fast', 'slow'])\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf_kwargs = dict(size=np.inf, fees=0.001, freq='1D')\npf = vbt.Portfolio.from_signals(price, entries, exits, **pf_kwargs)\n\nfig = pf.total_return().vbt.heatmap(\n    x_level='fast_window', y_level='slow_window', slider_level='symbol', symmetric=True,\n    trace_kwargs=dict(colorbar=dict(title='Total return', tickformat='%')))\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Backtesting a Golden Cross Strategy with vectorbt Portfolio\nDESCRIPTION: Demonstrates how to implement and backtest a Golden Cross strategy using vectorbt. The example downloads BTC-USD price data, calculates moving averages, generates entry/exit signals, and visualizes the backtest results.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> price = vbt.YFData.download('BTC-USD', start='2018-01-01').get('Close')\n>>> fast_ma = vbt.MA.run(price, 50, short_name='fast_ma')\n>>> slow_ma = vbt.MA.run(price, 200, short_name='slow_ma')\n>>> entries = fast_ma.ma_crossed_above(slow_ma)\n>>> exits = fast_ma.ma_crossed_below(slow_ma)\n>>> pf = vbt.Portfolio.from_signals(price, entries, exits, fees=0.005)\n\n>>> pf.orders.records_readable\n   Order Id  Column                 Timestamp      Size         Price  \\\\\n0         0       0 2019-04-24 00:00:00+00:00  0.018208   5464.866699   \n1         1       0 2019-10-26 00:00:00+00:00  0.018208   9244.972656   \n2         2       0 2020-02-19 00:00:00+00:00  0.017300   9633.386719   \n3         3       0 2020-03-25 00:00:00+00:00  0.017300   6681.062988   \n4         4       0 2020-05-21 00:00:00+00:00  0.012600   9081.761719   \n5         5       0 2021-06-19 00:00:00+00:00  0.012600  35615.871094   \n6         6       0 2021-09-15 00:00:00+00:00  0.009222  48176.347656   \n\n       Fees  Side  \n0  0.497512   Buy  \n1  0.841647  Sell  \n2  0.833272   Buy  \n3  0.577901  Sell  \n4  0.572151   Buy  \n5  2.243800  Sell  \n6  2.221473   Buy  \n\n>>> fig = price.vbt.plot(trace_kwargs=dict(name='Close'))\n>>> fast_ma.ma.vbt.plot(trace_kwargs=dict(name='Fast MA'), fig=fig)\n>>> slow_ma.ma.vbt.plot(trace_kwargs=dict(name='Slow MA'), fig=fig)\n>>> pf.positions.plot(close_trace_kwargs=dict(visible=False), fig=fig)\n```\n\n----------------------------------------\n\nTITLE: Implementing SMA Crossover Strategy with vectorbt in Python\nDESCRIPTION: This code implements a simple moving average (SMA) crossover strategy using vectorbt. It buys when the 10-day SMA crosses above the 50-day SMA and sells when the opposite occurs, then calculates the total profit.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfast_ma = vbt.MA.run(price, 10)\nslow_ma = vbt.MA.run(price, 50)\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf = vbt.Portfolio.from_signals(price, entries, exits, init_cash=100)\npf.total_profit()\n```\n\n----------------------------------------\n\nTITLE: Implementing Moving Average Crossover Strategy with vectorbt in Python\nDESCRIPTION: This code implements a simple moving average crossover strategy using vectorbt. It buys when the 10-day SMA crosses above the 50-day SMA and sells when the opposite occurs. The strategy is then backtested on Bitcoin price data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/usage.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfast_ma = vbt.MA.run(price, 10)\nslow_ma = vbt.MA.run(price, 50)\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf = vbt.Portfolio.from_signals(price, entries, exits, init_cash=100)\npf.total_profit()\n```\n\n----------------------------------------\n\nTITLE: Testing Multiple DMAC Strategy Instances with vectorbt\nDESCRIPTION: This snippet demonstrates how to test multiple instances of the DMAC strategy simultaneously using vectorbt. It calculates moving averages with different window sizes and compares their performance.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/index.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> # Multiple strategy instances: (10, 30) and (20, 30)\n>>> fast_ma = vbt.MA.run(btc_price, [10, 20], short_name='fast')\n>>> slow_ma = vbt.MA.run(btc_price, [30, 30], short_name='slow')\n\n>>> entries = fast_ma.ma_crossed_above(slow_ma)\n>>> entries\nfast_window                   10     20\nslow_window                   30     30\nDate\n2019-01-01 00:00:00+00:00  False  False\n2019-01-02 00:00:00+00:00  False  False\n2019-01-03 00:00:00+00:00  False  False\n...                          ...    ...\n2019-12-30 00:00:00+00:00  False  False\n2019-12-31 00:00:00+00:00  False  False\n2020-01-01 00:00:00+00:00  False  False\n\n[366 rows x 2 columns]\n\n>>> exits = fast_ma.ma_crossed_below(slow_ma)\n>>> exits\nfast_window                   10     20\nslow_window                   30     30\nDate\n2019-01-01 00:00:00+00:00  False  False\n2019-01-02 00:00:00+00:00  False  False\n2019-01-03 00:00:00+00:00  False  False\n...                          ...    ...\n2019-12-30 00:00:00+00:00  False  False\n2019-12-31 00:00:00+00:00  False  False\n2020-01-01 00:00:00+00:00  False  False\n\n[366 rows x 2 columns]\n\n>>> pf = vbt.Portfolio.from_signals(btc_price, entries, exits)\n>>> pf.total_return()\nfast_window  slow_window\n10           30             0.848840\n20           30             0.543411\nName: total_return, dtype: float64\n```\n\n----------------------------------------\n\nTITLE: Calculating Profit from Bitcoin Investment using vectorbt in Python\nDESCRIPTION: This snippet demonstrates how to use vectorbt to calculate the profit from a $100 investment in Bitcoin since 2014. It downloads Bitcoin price data and uses the Portfolio class to simulate holding the asset.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n\nprice = vbt.YFData.download('BTC-USD').get('Close')\n\npf = vbt.Portfolio.from_holding(price, init_cash=100)\npf.total_profit()\n```\n\n----------------------------------------\n\nTITLE: Analyzing Specific Strategy Configuration with vectorbt in Python\nDESCRIPTION: This snippet demonstrates how to analyze a specific strategy configuration (10-day and 20-day SMAs for ETH-USD) by indexing the portfolio object and displaying its statistics.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/README.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npf[(10, 20, 'ETH-USD')].stats()\n```\n\n----------------------------------------\n\nTITLE: Backtesting DMAC Strategy Across Multiple Time Periods with vectorbt\nDESCRIPTION: This snippet shows how to backtest the DMAC strategy across multiple time periods using vectorbt. It splits the original time period into two equal parts and performs backtesting on both simultaneously, allowing for comparison of strategy performance across different time frames.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/index.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> # Multiple strategy instances, instruments, and time periods\n>>> mult_comb_price, _ = comb_price.vbt.range_split(n=2)\n>>> mult_comb_price\nsplit_idx                         0                         1\nsymbol              BTC         ETH           BTC         ETH\n0           3843.520020  140.819412  11961.269531  303.099976\n1           3943.409424  155.047684  11215.437500  284.523224\n2           3836.741211  149.135010  10978.459961  287.997528\n...                 ...         ...           ...         ...\n180        10817.155273  290.695984   7292.995117  132.633484\n181        10583.134766  293.641113   7193.599121  129.610855\n182        10801.677734  291.596436   7200.174316  130.802002\n\n[183 rows x 4 columns]\n\n>>> fast_ma = vbt.MA.run(mult_comb_price, [10, 20], short_name='fast')\n>>> slow_ma = vbt.MA.run(mult_comb_price, [30, 30], short_name='slow')\n\n>>> entries = fast_ma.ma_crossed_above(slow_ma)\n>>> exits = fast_ma.ma_crossed_below(slow_ma)\n\n>>> pf = vbt.Portfolio.from_signals(mult_comb_price, entries, exits, freq='1D')\n>>> pf.total_return()\nfast_window  slow_window  split_idx  symbol\n10           30           0          BTC       1.632259\n                                     ETH       0.946786\n                          1          BTC      -0.288720\n                                     ETH      -0.308387\n20           30           0          BTC       1.721449\n                                     ETH       0.343274\n                          1          BTC      -0.418280\n                                     ETH      -0.257947\nName: total_return, dtype: float64\n```\n\n----------------------------------------\n\nTITLE: Calculating Profit from Holding Bitcoin using vectorbt in Python\nDESCRIPTION: This snippet demonstrates how to calculate the profit from holding $100 worth of Bitcoin since 2014 using vectorbt. It downloads historical price data and uses the Portfolio module to simulate holding.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/usage.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n\nprice = vbt.YFData.download('BTC-USD').get('Close')\n\npf = vbt.Portfolio.from_holding(price, init_cash=100)\npf.total_profit()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Signal Patterns with SignalFactory in vectorbt\nDESCRIPTION: Demonstrates creating a custom signal factory that places entries and exits using user-defined functions. The example utilizes Numba-compiled functions to specify precise entry and exit positions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> @njit\n... def entry_choice_func(from_i, to_i, col):\n...     return np.array([col])\n\n>>> @njit\n... def exit_choice_func(from_i, to_i, col):\n...     return np.array([to_i - 1])\n\n>>> MySignals = vbt.SignalFactory().from_choice_func(\n...     entry_choice_func=entry_choice_func,\n...     exit_choice_func=exit_choice_func,\n...     entry_kwargs=dict(wait=1),\n...     exit_kwargs=dict(wait=0)\n... )\n\n>>> my_sig = MySignals.run(input_shape=(3, 3))\n>>> my_sig.entries\n       0      1      2\n0   True  False  False\n1  False   True  False\n2  False  False   True\n>>> my_sig.exits\n       0      1      2\n0  False  False  False\n1  False  False  False\n2   True   True   True\n```\n\n----------------------------------------\n\nTITLE: Generating and Testing Random Trading Strategies with vectorbt in Python\nDESCRIPTION: This snippet generates 1,000 random trading strategies and tests them on Bitcoin and Ethereum price data. It then calculates the mean expectancy for each strategy and visualizes the results using a scatter plot.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nsymbols = [\"BTC-USD\", \"ETH-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nn = np.random.randint(10, 101, size=1000).tolist()\npf = vbt.Portfolio.from_random_signals(price, n=n, init_cash=100, seed=42)\n\nmean_expectancy = pf.trades.expectancy().groupby(['randnx_n', 'symbol']).mean()\nfig = mean_expectancy.unstack().vbt.scatterplot(xaxis_title='randnx_n', yaxis_title='mean_expectancy')\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Finding Highest Slippage Values from Portfolio Logs with vectorbt\nDESCRIPTION: Shows how to use vectorbt's records and mapped arrays to analyze complex transaction data. This example simulates random trades with slippage, then identifies and extracts the top 5 highest slippage values from the logs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> price = vbt.YFData.download('BTC-USD').get('Close')\n>>> slippage = np.random.uniform(0, 0.005, size=price.shape[0])\n>>> logs = vbt.Portfolio.from_random_signals(price, n=5, slippage=slippage, log=True).logs\n\n>>> req_price_ma = logs.map_field('req_price')\n>>> res_price_ma = logs.map_field('res_price')\n>>> slippage_ma = (res_price_ma - req_price_ma) / req_price_ma\n>>> slippage_ma = slippage_ma.replace(arr=np.abs(slippage_ma.values))\n>>> top_slippage_pd = slippage_ma.top_n(5).to_pd()\n>>> top_slippage_pd[~top_slippage_pd.isnull()]\nDate\n2017-12-25 00:00:00+00:00    0.001534\n2018-06-03 00:00:00+00:00    0.004354\n2018-12-03 00:00:00+00:00    0.004663\n2019-09-20 00:00:00+00:00    0.004217\n2020-11-28 00:00:00+00:00    0.000775\ndtype: float64\n```\n\n----------------------------------------\n\nTITLE: Hyperparameter Optimization for Dual SMA Crossover Strategy using vectorbt in Python\nDESCRIPTION: This code performs hyperparameter optimization for a dual SMA crossover strategy on Bitcoin, Ethereum, and Litecoin. It tests 10,000 window combinations and visualizes the results using a heatmap with an interactive slider for different symbols.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/usage.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"BTC-USD\", \"ETH-USD\", \"LTC-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nwindows = np.arange(2, 101)\nfast_ma, slow_ma = vbt.MA.run_combs(price, window=windows, r=2, short_names=['fast', 'slow'])\nentries = fast_ma.ma_crossed_above(slow_ma)\nexits = fast_ma.ma_crossed_below(slow_ma)\n\npf_kwargs = dict(size=np.inf, fees=0.001, freq='1D')\npf = vbt.Portfolio.from_signals(price, entries, exits, **pf_kwargs)\n\nfig = pf.total_return().vbt.heatmap(\n    x_level='fast_window', y_level='slow_window', slider_level='symbol', symmetric=True,\n    trace_kwargs=dict(colorbar=dict(title='Total return', tickformat='%')))\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-parameter Backtesting with vectorbt in Python\nDESCRIPTION: Function that simulates multiple parameter combinations using vectorbt's Portfolio.from_order_func. It creates a parameter grid, tiles price data across all combinations, and runs the simulation with custom order functions and preprocessing.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef simulate_mult_from_order_func(periods, uppers, lowers):\n    \"\"\"Simulate multiple parameter combinations using `Portfolio.from_order_func`.\"\"\"\n    # Build param grid\n    param_product = vbt.utils.params.create_param_product([periods, uppers, lowers])\n    param_tuples = list(zip(*param_product))\n    param_columns = pd.MultiIndex.from_tuples(param_tuples, names=['period', 'upper', 'lower'])\n    \n    # We need two price columns per param combination\n    vbt_close_price_mult = vbt_close_price.vbt.tile(len(param_columns), keys=param_columns)\n    vbt_open_price_mult = vbt_open_price.vbt.tile(len(param_columns), keys=param_columns)\n    \n    return vbt.Portfolio.from_order_func(\n        vbt_close_price_mult,\n        order_func_nb, \n        vbt_open_price_mult.values, COMMPERC,  # *args for order_func_nb\n        pre_group_func_nb=pre_group_func_nb, \n        pre_group_args=(\n            np.array(param_product[0]), \n            np.array(param_product[1]), \n            np.array(param_product[2]), \n            ORDER_PCT1, \n            ORDER_PCT2\n        ),\n        pre_segment_func_nb=pre_segment_func_nb, \n        pre_segment_args=(MODE,),\n        fill_pos_record=False,\n        init_cash=CASH,\n        cash_sharing=True, \n        group_by=param_columns.names,\n        freq='d'\n    )\n\nvbt_pf_mult = simulate_mult_from_order_func(periods, uppers, lowers)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic DMAC Strategy with vectorbt\nDESCRIPTION: This code implements a basic Dual Moving Average Crossover strategy using vectorbt. It calculates 10-day and 20-day moving averages, generates entry and exit signals, and computes the total return of the strategy.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/index.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> fast_ma = vbt.MA.run(btc_price, 10, short_name='fast')\n>>> slow_ma = vbt.MA.run(btc_price, 20, short_name='slow')\n\n>>> entries = fast_ma.ma_crossed_above(slow_ma)\n>>> entries\nDate\n2019-01-01 00:00:00+00:00    False\n2019-01-02 00:00:00+00:00    False\n2019-01-03 00:00:00+00:00    False\n...                            ...\n2019-12-30 00:00:00+00:00    False\n2019-12-31 00:00:00+00:00    False\n2020-01-01 00:00:00+00:00    False\nFreq: D, Length: 366, dtype: bool\n\n>>> exits = fast_ma.ma_crossed_below(slow_ma)\n>>> exits\nDate\n2019-01-01 00:00:00+00:00    False\n2019-01-02 00:00:00+00:00    False\n2019-01-03 00:00:00+00:00    False\n...                            ...\n2019-12-30 00:00:00+00:00    False\n2019-12-31 00:00:00+00:00    False\n2020-01-01 00:00:00+00:00    False\nFreq: D, Length: 366, dtype: bool\n\n>>> pf = vbt.Portfolio.from_signals(btc_price, entries, exits)\n>>> pf.total_return()\n0.636680693047752\n```\n\n----------------------------------------\n\nTITLE: Computing Multiple Moving Averages with Different Libraries\nDESCRIPTION: Shows how to compute moving averages using various technical analysis libraries integrated with vectorbt, including built-in, TA, pandas-ta, and TA-Lib implementations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> price = pd.Series([1, 2, 3, 4, 5], dtype=float)\n\n# built-in\n>>> vbt.MA.run(price, [2, 3]).ma\nma_window    2    3\n0          NaN  NaN\n1          1.5  NaN\n2          2.5  2.0\n3          3.5  3.0\n4          4.5  4.0\n\n# ta support\n>>> vbt.ta('SMAIndicator').run(price, [2, 3]).sma_indicator\nsmaindicator_window    2    3\n0                    NaN  NaN\n1                    1.5  NaN\n2                    2.5  2.0\n3                    3.5  3.0\n4                    4.5  4.0\n\n# pandas-ta support\n>>> vbt.pandas_ta('SMA').run(price, [2, 3]).sma\nsma_length    2    3\n0           NaN  NaN\n1           1.5  NaN\n2           2.5  2.0\n3           3.5  3.0\n4           4.5  4.0\n\n# TA-Lib support\n>>> vbt.talib('SMA').run(price, [2, 3]).real\nsma_timeperiod    2    3\n0               NaN  NaN\n1               1.5  NaN\n2               2.5  2.0\n3               3.5  3.0\n4               4.5  4.0\n```\n\n----------------------------------------\n\nTITLE: Generating and Testing Random Trading Strategies with vectorbt in Python\nDESCRIPTION: This snippet generates 1,000 random trading strategies and tests them on Bitcoin and Ethereum price data. It then calculates the mean expectancy for each strategy and visualizes the results using a scatter plot.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/usage.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nsymbols = [\"BTC-USD\", \"ETH-USD\"]\nprice = vbt.YFData.download(symbols, missing_index='drop').get('Close')\n\nn = np.random.randint(10, 101, size=1000).tolist()\npf = vbt.Portfolio.from_random_signals(price, n=n, init_cash=100, seed=42)\n\nmean_expectancy = pf.trades.expectancy().groupby(['randnx_n', 'symbol']).mean()\nfig = mean_expectancy.unstack().vbt.scatterplot(xaxis_title='randnx_n', yaxis_title='mean_expectancy')\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Analyzing Specific Strategy Configuration with vectorbt in Python\nDESCRIPTION: This snippet demonstrates how to analyze a specific strategy configuration (10-day and 20-day SMA crossover for Ethereum) by indexing the portfolio object and displaying its statistics.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/usage.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npf[(10, 20, 'ETH-USD')].stats()\n```\n\n----------------------------------------\n\nTITLE: Generating Performance Statistics with vectorbt\nDESCRIPTION: Demonstrates how to generate comprehensive performance statistics using vectorbt with custom settings for benchmark returns, Levy alpha, risk-free rate, and required return. Includes performance benchmarking for large return series.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nprint(returns['b'].vbt.returns.stats(\n    settings=dict(benchmark_rets=benchmark_rets, levy_alpha=3., risk_free=0.01, required_return=0.1)))\n%timeit big_returns[0].vbt.returns.stats(\\\n    silence_warnings=True,\\\n    settings=dict(benchmark_rets=big_benchmark_rets, levy_alpha=3., risk_free=0.01, required_return=0.1))\n\nprint(returns.vbt.returns.stats(\n    settings=dict(benchmark_rets=benchmark_rets, levy_alpha=3., risk_free=0.01, required_return=0.1)))\n%timeit big_returns.vbt.returns.stats(\\\n    silence_warnings=True,\\\n    settings=dict(benchmark_rets=big_benchmark_rets, levy_alpha=3., risk_free=0.01, required_return=0.1))\n```\n\n----------------------------------------\n\nTITLE: Low-Level Numba Simulation for Maximum Performance in Python\nDESCRIPTION: Implements a direct Numba-based simulation using vectorbt's simulate_nb function for maximum performance. This approach skips higher-level abstractions for faster execution but requires more detailed configuration.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef simulate_nb_from_order_func():\n    \"\"\"Simulate using `simulate_nb`.\"\"\"\n    # iterate over 502 rows and 2 columns, each element is a potential order\n    target_shape = vbt_close_price.shape\n    \n    # number of columns in the group - exactly two\n    group_lens = np.array([2])\n    \n    # build default call sequence (orders are executed from the left to the right column)\n    call_seq = portfolio_nb.build_call_seq(target_shape, group_lens)\n    \n    # initial cash per group\n    init_cash = np.array([CASH], dtype=np.float64)\n    \n    order_records, log_records = portfolio_nb.simulate_nb(\n        target_shape=target_shape, \n        group_lens=group_lens,\n        init_cash=init_cash,\n        cash_sharing=True,\n        call_seq=call_seq,  \n        segment_mask=np.full(target_shape, True),  # used for disabling some segments\n        pre_group_func_nb=pre_group_func_nb, \n        pre_group_args=(PERIOD, UPPER, LOWER, ORDER_PCT1, ORDER_PCT2),\n        pre_segment_func_nb=pre_segment_func_nb, \n        pre_segment_args=(MODE,),\n        order_func_nb=order_func_nb, \n        order_args=(vbt_open_price.values, COMMPERC),\n        close=vbt_close_price.values,  # used for target percentage, but we override the valuation price\n        fill_pos_record=False\n    )\n    \n    return target_shape, group_lens, call_seq, init_cash, order_records, log_records\n\ntarget_shape, group_lens, call_seq, init_cash, order_records, log_records = simulate_nb_from_order_func()\n```\n\n----------------------------------------\n\nTITLE: Setting Up Periodic Data Updates\nDESCRIPTION: Initializes the data updater with the Telegram bot and configures it to update data at regular intervals based on the specified timeframe.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndata_updater = MyDataUpdater(data, telegram_bot)\ndata_updater.update_every(UPDATE_EVERY)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Performance Metrics with QuantStats in vectorbt\nDESCRIPTION: Shows how to integrate QuantStats for performance visualization with vectorbt. The example downloads cryptocurrency data, calculates returns, and generates a performance snapshot of key metrics.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> price = vbt.YFData.download('BTC-USD').get('Close')\n>>> returns = price.vbt.to_returns()\n>>> returns.vbt.returns.qs.plot_snapshot()\n```\n\n----------------------------------------\n\nTITLE: Generating Animated Bollinger Bands Visualization with vectorbt in Python\nDESCRIPTION: This code creates an animated GIF that shows the %B and bandwidth of Bollinger Bands for different cryptocurrencies over time. It uses vectorbt's plotting capabilities and animation features.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/README.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"BTC-USD\", \"ETH-USD\", \"ADA-USD\"]\nprice = vbt.YFData.download(symbols, period='6mo', missing_index='drop').get('Close')\nbbands = vbt.BBANDS.run(price)\n\ndef plot(index, bbands):\n    bbands = bbands.loc[index]\n    fig = vbt.make_subplots(\n        rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.15,\n        subplot_titles=('%B', 'Bandwidth'))\n    fig.update_layout(template='vbt_dark', showlegend=False, width=750, height=400)\n    bbands.percent_b.vbt.ts_heatmap(\n        trace_kwargs=dict(zmin=0, zmid=0.5, zmax=1, colorscale='Spectral', colorbar=dict(\n            y=(fig.layout.yaxis.domain[0] + fig.layout.yaxis.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=1, col=1), fig=fig)\n    bbands.bandwidth.vbt.ts_heatmap(\n        trace_kwargs=dict(colorbar=dict(\n            y=(fig.layout.yaxis2.domain[0] + fig.layout.yaxis2.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=2, col=1), fig=fig)\n    return fig\n\nvbt.save_animation('bbands.gif', bbands.wrapper.index, plot, bbands, delta=90, step=3, fps=3)\n```\n\n----------------------------------------\n\nTITLE: Creating a Portfolio Object in vectorbt for Complex Metrics Calculation\nDESCRIPTION: Example of constructing a vectorbt Portfolio object from simulation outputs. This approach is recommended for producing more complex metrics such as performance statistics, taking various parameters like price data, order records, and cash settings.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# To produce more complex metrics such as stats, it's advisable to use Portfolio,\n# which can be easily constructed from the arguments and outputs of simulate_nb\nvbt_pf3 = vbt.Portfolio(\n    wrapper=vbt_close_price.vbt(freq='d', group_by=True).wrapper, \n    close=vbt_close_price, \n    order_records=order_records, \n    log_records=log_records, \n    init_cash=init_cash,\n    cash_sharing=True, \n    call_seq=call_seq\n)\n\nprint(vbt_pf3.stats())\n```\n\n----------------------------------------\n\nTITLE: Generating Entry-Exit Signal Pairs with vectorbt\nDESCRIPTION: Demonstrates generating pairs of entry and exit signals using custom Numba-compiled functions. Explores different waiting periods between entries and exits, with performance benchmarks for large-scale signal generation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@njit\ndef entry_func_nb(from_i, to_i, col, temp_int):\n    temp_int[0] = from_i\n    return temp_int[:1]\n\n@njit\ndef exit_func_nb(from_i, to_i, col, temp_int):\n    temp_int[0] = from_i\n    return temp_int[:1]\n\ntemp_int = np.empty((1000,), dtype=np.int64)\nen, ex = pd.Series.vbt.signals.generate_both(\n    a.shape[0], entry_func_nb, (temp_int,), exit_func_nb, (temp_int,), \n    index=index)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_both(\n    a.shape, entry_func_nb, (temp_int,), exit_func_nb, (temp_int,), \n    index=index, columns=columns)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_both(\n    a.shape, entry_func_nb, (temp_int,), exit_func_nb, (temp_int,), \n    index=index, columns=columns, entry_wait=1, exit_wait=0)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_both(\n    a.shape, entry_func_nb, (temp_int,), exit_func_nb, (temp_int,), \n    index=index, columns=columns, entry_wait=0, exit_wait=1)\nprint(en)\nprint(ex)\n\n%timeit pd.DataFrame.vbt.signals.generate_both(\\\n    big_a.shape, entry_func_nb, (temp_int,), exit_func_nb, (temp_int,))\n```\n\n----------------------------------------\n\nTITLE: Generating Stop-Loss Exits from Price Data in vectorbt\nDESCRIPTION: Creates exit signals based on price movements reaching stop-loss thresholds. Demonstrates standard and trailing stop-loss configurations with various options for handling multiple conditions and waiting periods.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ne = pd.Series([True, False, False, False, False, False])\nt = pd.Series([2, 3, 4, 3, 2, 1]).astype(np.float64)\n\nprint(e.vbt.signals.generate_stop_exits(t, -0.1))\nprint(e.vbt.signals.generate_stop_exits(t, -0.1, trailing=True))\nprint(e.vbt.signals.generate_stop_exits(t, -0.1, trailing=True, pick_first=False))\nprint(e.vbt.signals.generate_stop_exits(t.vbt.tile(3), [np.nan, -0.5, -1.], trailing=True, pick_first=False))\nprint(e.vbt.signals.generate_stop_exits(t, -0.1, trailing=True, exit_wait=3))\n\nprint(e.vbt.signals.generate_stop_exits(4 - t, 0.1))\nprint(e.vbt.signals.generate_stop_exits(4 - t, 0.1, trailing=True))\nprint(e.vbt.signals.generate_stop_exits(4 - t, 0.1, trailing=True, pick_first=False))\nprint(e.vbt.signals.generate_stop_exits((4 - t).vbt.tile(3), [np.nan, 0.5, 1.], trailing=True, pick_first=False))\nprint(e.vbt.signals.generate_stop_exits(4 - t, 0.1, trailing=True, exit_wait=3))\n\n%timeit big_entries.vbt.signals.generate_stop_exits(big_ts, -0.1)\n%timeit big_entries.vbt.signals.generate_stop_exits(big_ts, -0.1, trailing=True)\n%timeit big_entries.vbt.signals.generate_stop_exits(big_ts, -0.1, trailing=True, pick_first=False)\n```\n\n----------------------------------------\n\nTITLE: Saving and Loading Portfolio Objects in vectorbt\nDESCRIPTION: Shows how to use vectorbt's persistence capabilities to save and load Portfolio objects. The example creates a portfolio from cryptocurrency price data with random signals, saves it to a file, then loads it back and calculates the total return.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> price = vbt.YFData.download('BTC-USD').get('Close')\n>>> pf = vbt.Portfolio.from_random_signals(price, n=5)\n>>> pf.save('my_pf.pkl')\n\n>>> pf = vbt.Portfolio.load('my_pf.pkl')\n>>> pf.total_return()\n5.96813681074424\n```\n\n----------------------------------------\n\nTITLE: Running Simulation with Portfolio.from_order_func Method in Python\nDESCRIPTION: Defines and executes a function to simulate pair trading using the Portfolio.from_order_func method with pre-defined parameters. The simulation leverages event-driven order processing for flexibility and performance.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef simulate_from_order_func():\n    \"\"\"Simulate using `Portfolio.from_order_func`.\"\"\"\n    return vbt.Portfolio.from_order_func(\n        vbt_close_price,\n        order_func_nb, \n        vbt_open_price.values, COMMPERC,  # *args for order_func_nb\n        pre_group_func_nb=pre_group_func_nb, \n        pre_group_args=(PERIOD, UPPER, LOWER, ORDER_PCT1, ORDER_PCT2),\n        pre_segment_func_nb=pre_segment_func_nb, \n        pre_segment_args=(MODE,),\n        fill_pos_record=False,  # a bit faster\n        init_cash=CASH,\n        cash_sharing=True, \n        group_by=True,\n        freq='d'\n    )\n\nvbt_pf2 = simulate_from_order_func()\n```\n\n----------------------------------------\n\nTITLE: Implementing a Random Trading Strategy with VectorBT in Python\nDESCRIPTION: Generates random entry and exit signals for the price data and creates a portfolio simulation using VectorBT. The strategy generates 2 random signals per trading session and calculates the total return of the portfolio.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Run your strategy (here using random signals)\nentries, exits = pd.DataFrame.vbt.signals.generate_random_both(price_per_session.shape, n=2, seed=42)\npf = vbt.Portfolio.from_signals(price_per_session, entries, exits, freq='1H')\nprint(pf.total_return())\n```\n\n----------------------------------------\n\nTITLE: Grouping DMAC Strategy Performance by Time Period and Symbol\nDESCRIPTION: This code snippet demonstrates how to group the performance results of the DMAC strategy by time period and cryptocurrency symbol using vectorbt. It calculates the mean return for each group.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/index.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> mean_return = pf.total_return().groupby(['split_idx', 'symbol']).mean()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Deepest Drawdowns with vectorbt\nDESCRIPTION: Demonstrates drawdown analysis capabilities by plotting the top 3 deepest price drops in a cryptocurrency time series. This helps identify and analyze major market corrections.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> price = vbt.YFData.download('BTC-USD').get('Close')\n>>> price.vbt.drawdowns.plot(top_n=3)\n```\n\n----------------------------------------\n\nTITLE: Analyzing and Visualizing Backtesting Results in vectorbt\nDESCRIPTION: Code for displaying and visualizing the results of multi-parameter backtesting. It prints the sorted total returns and creates a histogram plot of the return distribution across all parameter combinations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt_pf_mult.total_return().sort_values())\n\nvbt_pf_mult.total_return().vbt.histplot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Chain Mode Signal Factory with Wait Parameter in VectorBT (Python)\nDESCRIPTION: Shows how to use the chain mode signal factory with a wait parameter to control the timing between signals. This example demonstrates how to create a chain of entry and exit signals with delays.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\ne = np.array([True, True, True, True, True, True])\nmy_sig = MySignals.run(e, np.arange(6), [1, 0], 100, wait=2)\nprint(my_sig.entries)\nprint(my_sig.new_entries)\nprint(my_sig.exits)\nprint(my_sig.in_out2)\n```\n\n----------------------------------------\n\nTITLE: Comparing Value at Risk (VaR) Calculations between empyrical and vectorbt\nDESCRIPTION: Demonstrates Value at Risk calculations in both empyrical and vectorbt libraries with performance benchmarks. Shows implementations for single series, multiple series, and rolling window calculations with custom cutoff.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.value_at_risk(returns.iloc[1:]['a'], cutoff=0.05))\n%timeit empyrical.value_at_risk(big_returns[0], cutoff=0.05)\n\nprint(returns['a'].vbt.returns.value_at_risk(cutoff=0.05))\n%timeit big_returns[0].vbt.returns.value_at_risk(cutoff=0.05)\n\nprint(returns.vbt.returns.value_at_risk(cutoff=0.05))\n%timeit big_returns.vbt.returns.value_at_risk(cutoff=0.05)\n\nprint(returns.vbt.returns.rolling_value_at_risk(3, minp=1, cutoff=0.05))\n%timeit big_returns.vbt.returns.rolling_value_at_risk(3, minp=1, cutoff=0.05)\n```\n\n----------------------------------------\n\nTITLE: Implementing Pair Trading Strategy and Custom Indicators in Backtrader\nDESCRIPTION: This code defines custom commission handling, indicators for OLS regression, log transformations, and a complete pair trading strategy implementation. The strategy monitors the z-score of spreads between two assets and executes trades when the spread deviates beyond defined thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport backtrader as bt\nimport backtrader.feeds as btfeeds\nimport backtrader.indicators as btind\n\nclass CommInfoFloat(bt.CommInfoBase):\n    \"\"\"Commission schema that keeps size as float.\"\"\"\n    params = (\n        ('stocklike', True),\n        ('commtype', bt.CommInfoBase.COMM_PERC),\n        ('percabs', True),\n      )\n    \n    def getsize(self, price, cash):\n        if not self._stocklike:\n            return self.p.leverage * (cash / self.get_margin(price))\n\n        return self.p.leverage * (cash / price)\n    \nclass OLSSlopeIntercept(btind.PeriodN):\n    \"\"\"Calculates a linear regression using OLS.\"\"\"\n    _mindatas = 2  # ensure at least 2 data feeds are passed\n\n    packages = (\n        ('pandas', 'pd'),\n        ('statsmodels.api', 'sm'),\n    )\n    lines = ('slope', 'intercept',)\n    params = (\n        ('period', 10),\n    )\n\n    def next(self):\n        p0 = pd.Series(self.data0.get(size=self.p.period))\n        p1 = pd.Series(self.data1.get(size=self.p.period))\n        p1 = sm.add_constant(p1)\n        intercept, slope = sm.OLS(p0, p1).fit().params\n\n        self.lines.slope[0] = slope\n        self.lines.intercept[0] = intercept\n        \n        \nclass Log(btind.Indicator):\n    \"\"\"Calculates log.\"\"\"\n    lines = ('log',)\n    \n    def next(self):\n        self.l.log[0] = math.log(self.data[0])\n\n\nclass OLSSpread(btind.PeriodN):\n    \"\"\"Calculates the z-score of the OLS spread.\"\"\"\n    _mindatas = 2  # ensure at least 2 data feeds are passed\n    lines = ('spread', 'spread_mean', 'spread_std', 'zscore',)\n    params = (('period', 10),)\n\n    def __init__(self):\n        data0_log = Log(self.data0)\n        data1_log = Log(self.data1)\n        slint = OLSSlopeIntercept(data0_log, data1_log, period=self.p.period)\n\n        spread = data0_log - (slint.slope * data1_log + slint.intercept)\n        self.l.spread = spread\n\n        self.l.spread_mean = bt.ind.SMA(spread, period=self.p.period)\n        self.l.spread_std = bt.ind.StdDev(spread, period=self.p.period)\n        self.l.zscore = (spread - self.l.spread_mean) / self.l.spread_std\n    \nclass LogReturns(btind.PeriodN):\n    \"\"\"Calculates the log returns.\"\"\"\n    lines = ('logret',)\n    params = (('period', 1),)\n    \n    def __init__(self):\n        self.addminperiod(self.p.period + 1)\n    \n    def next(self):\n        self.l.logret[0] = math.log(self.data[0] / self.data[-self.p.period])\n    \nclass LogReturnSpread(btind.PeriodN):\n    \"\"\"Calculates the spread of the log returns.\"\"\"\n    _mindatas = 2  # ensure at least 2 data feeds are passed\n    lines = ('logret0', 'logret1', 'spread', 'spread_mean', 'spread_std', 'zscore',)\n    params = (('period', 10),)\n\n    def __init__(self):\n        self.l.logret0 = LogReturns(self.data0, period=1)\n        self.l.logret1 = LogReturns(self.data1, period=1)\n        self.l.spread = self.l.logret0 - self.l.logret1\n        self.l.spread_mean = bt.ind.SMA(self.l.spread, period=self.p.period)\n        self.l.spread_std = bt.ind.StdDev(self.l.spread, period=self.p.period)\n        self.l.zscore = (self.l.spread - self.l.spread_mean) / self.l.spread_std\n\nclass PairTradingStrategy(bt.Strategy):\n    \"\"\"Basic pair trading strategy.\"\"\"\n    params = dict(\n        period=PERIOD,\n        order_pct1=ORDER_PCT1,\n        order_pct2=ORDER_PCT2,\n        printout=True,\n        upper=UPPER,\n        lower=LOWER,\n        mode=MODE\n    )\n\n    def log(self, txt, dt=None):\n        if self.p.printout:\n            dt = dt or self.data.datetime[0]\n            dt = bt.num2date(dt)\n            print('%s, %s' % (dt.isoformat(), txt))\n\n    def notify_order(self, order):\n        if order.status in [bt.Order.Submitted, bt.Order.Accepted]:\n            return  # Await further notifications\n\n        if order.status == order.Completed:\n            if order.isbuy():\n                buytxt = 'BUY COMPLETE {}, size = {:.2f}, price = {:.2f}'.format(\n                    order.data._name, order.executed.size, order.executed.price)\n                self.log(buytxt, order.executed.dt)\n            else:\n                selltxt = 'SELL COMPLETE {}, size = {:.2f}, price = {:.2f}'.format(\n                    order.data._name, order.executed.size, order.executed.price)\n                self.log(selltxt, order.executed.dt)\n\n        elif order.status in [order.Expired, order.Canceled, order.Margin]:\n            self.log('%s ,' % order.Status[order.status])\n            pass  # Simply log\n\n        # Allow new orders\n        self.orderid = None\n\n    def __init__(self):\n        # To control operation entries\n        self.orderid = None\n        self.order_pct1 = self.p.order_pct1\n        self.order_pct2 = self.p.order_pct2\n        self.upper = self.p.upper\n        self.lower = self.p.lower\n        self.status = 0\n        \n        # Signals performed with PD.OLS :\n        if self.p.mode == 'log_return':\n            self.transform = LogReturnSpread(self.data0, self.data1, period=self.p.period)\n        elif self.p.mode == 'OLS':\n            self.transform = OLSSpread(self.data0, self.data1, period=self.p.period)\n        else:\n            raise ValueError(\"Unknown mode\")\n        self.spread = self.transform.spread\n        self.zscore = self.transform.zscore\n        \n        # For tracking\n        self.spread_sr = pd.Series(dtype=float, name='spread')\n        self.zscore_sr = pd.Series(dtype=float, name='zscore')\n        self.short_signal_sr = pd.Series(dtype=bool, name='short_signals')\n        self.long_signal_sr = pd.Series(dtype=bool, name='long_signals')\n\n    def next(self):\n        if self.orderid:\n            return  # if an order is active, no new orders are allowed\n        \n        self.spread_sr[self.data0.datetime.datetime()] = self.spread[0]\n        self.zscore_sr[self.data0.datetime.datetime()] = self.zscore[0]\n        self.short_signal_sr[self.data0.datetime.datetime()] = False\n        self.long_signal_sr[self.data0.datetime.datetime()] = False\n\n        if self.zscore[0] > self.upper and self.status != 1:\n            # Check conditions for shorting the spread & place the order\n            self.short_signal_sr[self.data0.datetime.datetime()] = True\n\n            # Placing the order\n            self.log('SELL CREATE {}, price = {:.2f}, target pct = {:.2%}'.format(\n                self.data0._name, self.data0.close[0], -self.order_pct1))\n            self.order_target_percent(data=self.data0, target=-self.order_pct1)\n            self.log('BUY CREATE {}, price = {:.2f}, target pct = {:.2%}'.format(\n                self.data1._name, self.data1.close[0], self.order_pct2))\n            self.order_target_percent(data=self.data1, target=self.order_pct2)\n\n            self.status = 1\n\n        elif self.zscore[0] < self.lower and self.status != 2:\n            # Check conditions for longing the spread & place the order\n            self.long_signal_sr[self.data0.datetime.datetime()] = True\n\n            # Place the order\n            self.log('SELL CREATE {}, price = {:.2f}, target pct = {:.2%}'.format(\n                self.data1._name, self.data1.close[0], -self.order_pct2))\n            self.order_target_percent(data=self.data1, target=-self.order_pct2)\n            self.log('BUY CREATE {}, price = {:.2f}, target pct = {:.2%}'.format(\n                self.data0._name, self.data0.close[0], self.order_pct1))\n            self.order_target_percent(data=self.data0, target=self.order_pct1)\n                     \n            self.status = 2\n\n    def stop(self):\n        if self.p.printout:\n            print('==================================================')\n            print('Starting Value - %.2f' % self.broker.startingcash)\n            print('Ending   Value - %.2f' % self.broker.getvalue())\n            print('==================================================')\n```\n\n----------------------------------------\n\nTITLE: Comparing Portfolio Value Calculation between Backtesting Methods in Python\nDESCRIPTION: Code verifying that both traditional backtesting (bt) and vectorbt (vbt) produce the same portfolio value. It calculates asset flow, assets, asset value, and total portfolio value using portfolio_nb functions and compares the results.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# Proof that both bt and vbt produce the same value\nasset_flow = portfolio_nb.asset_flow_nb(target_shape, order_records, col_map, Direction.Both)\nassets = portfolio_nb.assets_nb(asset_flow)\nasset_value = portfolio_nb.asset_value_nb(vbt_close_price.values, assets)\nasset_value_grouped = portfolio_nb.asset_value_grouped_nb(asset_value, group_lens)\nvalue = portfolio_nb.value_nb(cash_grouped, asset_value_grouped)\n\npd.testing.assert_series_equal(bt_value, bt_value.vbt.wrapper.wrap(value))\n```\n\n----------------------------------------\n\nTITLE: Accessing Drawdowns in vectorbt\nDESCRIPTION: Shows how to access and analyze drawdowns using vectorbt's Drawdowns accessor. Demonstrates accessing the drawdowns property and calculating maximum drawdown directly from the drawdowns object.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nprint(returns.vbt.returns.drawdowns)\n%timeit big_returns.vbt.returns.drawdowns\n\nprint(returns.vbt.returns.drawdowns.max_drawdown())\n```\n\n----------------------------------------\n\nTITLE: Backtesting DMAC Strategy on Multiple Cryptocurrencies with vectorbt\nDESCRIPTION: This code demonstrates how to backtest the DMAC strategy on multiple cryptocurrencies (Bitcoin and Ethereum) simultaneously using vectorbt. It combines price data, generates signals, and compares performance across different instruments.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/index.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> # Multiple strategy instances and instruments\n>>> eth_price = vbt.YFData.download('ETH-USD', start=start, end=end).get('Close')\n>>> comb_price = btc_price.vbt.concat(eth_price,\n...     keys=pd.Index(['BTC', 'ETH'], name='symbol'))\n>>> comb_price.vbt.drop_levels(-1, inplace=True)\n>>> comb_price\nsymbol                             BTC         ETH\nDate\n2019-01-01 00:00:00+00:00  3843.520020  140.819412\n2019-01-02 00:00:00+00:00  3943.409424  155.047684\n2019-01-03 00:00:00+00:00  3836.741211  149.135010\n...                                ...         ...\n2019-12-30 00:00:00+00:00  7292.995117  132.633484\n2019-12-31 00:00:00+00:00  7193.599121  129.610855\n2020-01-01 00:00:00+00:00  7200.174316  130.802002\n\n[366 rows x 2 columns]\n\n>>> fast_ma = vbt.MA.run(comb_price, [10, 20], short_name='fast')\n>>> slow_ma = vbt.MA.run(comb_price, [30, 30], short_name='slow')\n\n>>> entries = fast_ma.ma_crossed_above(slow_ma)\n>>> entries\nfast_window                          10            20\nslow_window                          30            30\nsymbol                       BTC    ETH    BTC    ETH\nDate\n2019-01-01 00:00:00+00:00  False  False  False  False\n2019-01-02 00:00:00+00:00  False  False  False  False\n2019-01-03 00:00:00+00:00  False  False  False  False\n...                          ...    ...    ...    ...\n2019-12-30 00:00:00+00:00  False  False  False  False\n2019-12-31 00:00:00+00:00  False  False  False  False\n2020-01-01 00:00:00+00:00  False  False  False  False\n\n[366 rows x 4 columns]\n\n>>> exits = fast_ma.ma_crossed_below(slow_ma)\n>>> exits\nfast_window                          10            20\nslow_window                          30            30\nsymbol                       BTC    ETH    BTC    ETH\nDate\n2019-01-01 00:00:00+00:00  False  False  False  False\n2019-01-02 00:00:00+00:00  False  False  False  False\n2019-01-03 00:00:00+00:00  False  False  False  False\n...                          ...    ...    ...    ...\n2019-12-30 00:00:00+00:00  False  False  False  False\n2019-12-31 00:00:00+00:00  False  False  False  False\n2020-01-01 00:00:00+00:00  False  False  False  False\n\n[366 rows x 4 columns]\n\n>>> pf = vbt.Portfolio.from_signals(comb_price, entries, exits)\n>>> pf.total_return()\nfast_window  slow_window  symbol\n10           30           BTC       0.848840\n                          ETH       0.244204\n20           30           BTC       0.543411\n                          ETH      -0.319102\nName: total_return, dtype: float64\n\n>>> mean_return = pf.total_return().groupby('symbol').mean()\n>>> mean_return.vbt.barplot(xaxis_title='Symbol', yaxis_title='Mean total return')\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Telegram Bot Class\nDESCRIPTION: Extends vectorbt's TelegramBot class to create a custom bot that handles user commands for cryptocurrency information, formats responses, and provides help documentation for users.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom telegram.ext import CommandHandler\n\nclass MyTelegramBot(vbt.TelegramBot):\n    def __init__(self, data, *args, **kwargs):\n        super().__init__(data=data, *args, **kwargs)\n        \n        self.data = data\n        self.update_ts = data.wrapper.index[-1]\n        \n    @property\n    def custom_handlers(self):\n        return (CommandHandler('info', self.info_callback),)\n    \n    def info_callback(self, update, context):\n        chat_id = update.effective_chat.id\n        if len(context.args) != 1:\n            self.send_message(chat_id, \"Please provide one symbol.\")\n            return\n        symbol = context.args[0]\n        if symbol not in SYMBOLS:\n            self.send_message(chat_id, f\"There is no such symbol as \\\"{symbol}\\\".\")\n            return\n            \n        bbands = get_bbands(self.data)\n        info = get_info(bbands)\n        messages = [format_symbol_info(symbol, info)]\n        message = '\\n'.join([\"{}\".format(self.update_ts.strftime(DT_FORMAT))] + messages)\n        self.send_message(chat_id, message)\n        \n    @property\n    def start_message(self):\n        index = self.data.wrapper.index\n        return f\"\"\"Hello! \n\nStarting with {len(index)} rows from {index[0].strftime(DT_FORMAT)} to {index[-1].strftime(DT_FORMAT)}.\"\"\"\n        \n    @property\n    def help_message(self):\n        return \"\"\"Message format:\n[event] [symbol] ([price change], [new price], [bandwidth z-score])\n    \nEvent legend:\n - Price went above upper band\n - Price retraced below upper band\n - Price went below lower band\n - Price retraced above lower band\n\nGIF is sent once a band is crossed and the price change is 2 stds from the mean.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Updater for Real-time Monitoring\nDESCRIPTION: Creates a custom DataUpdater class that periodically fetches new cryptocurrency data, analyzes Bollinger Band crossings, and sends notifications with relevant market information and GIFs for significant movements.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass MyDataUpdater(vbt.DataUpdater):\n    def __init__(self, data, telegram_bot, **kwargs):\n        super().__init__(data, telegram_bot=telegram_bot, **kwargs)\n        \n        self.telegram_bot = telegram_bot\n        self.update_ts = data.wrapper.index[-1]\n        \n    def update(self):\n        super().update()\n        self.update_ts = pd.Timestamp.now(tz=TZ_CONVERT)\n        self.telegram_bot.data = self.data\n        self.telegram_bot.update_ts = self.update_ts\n        \n        bbands = get_bbands(self.data)\n        info = get_info(bbands)\n        \n        messages = []\n        if info['last_crossed_above_upper'].any():\n            messages.append(format_signals_info('', info['last_crossed_above_upper'], info))\n        if info['last_crossed_below_upper'].any():\n            messages.append(format_signals_info('', info['last_crossed_below_upper'], info))\n        if info['last_crossed_below_lower'].any():\n            messages.append(format_signals_info('', info['last_crossed_below_lower'], info))\n        if info['last_crossed_above_lower'].any():\n            messages.append(format_signals_info('', info['last_crossed_above_lower'], info))\n            \n        if len(messages) > 0:\n            message = '\\n'.join([\"{}\".format(self.update_ts.strftime(DT_FORMAT))] + messages)\n            self.telegram_bot.send_message_to_all(message)\n        if (info['last_crossed_above_upper'] & info['last_change_pos']).any():\n            self.telegram_bot.send_giphy_to_all(\"launch\")\n        if (info['last_crossed_below_lower'] & info['last_change_neg']).any():\n            self.telegram_bot.send_giphy_to_all(\"fall\")\n```\n\n----------------------------------------\n\nTITLE: Using Apply Functions with IndicatorFactory\nDESCRIPTION: Shows how to use IndicatorFactory with apply functions, which are simpler to write than custom functions but less customizable. Includes examples for both regular Python and Numba-optimized versions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Apply function is performed on each parameter individually, and each output is then stacked for you\n# Apply functions are less customizable than custom functions, but are simpler to write\ndef apply_func(ts, p, a, b=100):\n    return ts * p + a + b\n\n@njit\ndef apply_func_nb(ts, p, a, b):\n    return ts * p + a + b  # numba doesn't support **kwargs\n     \nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(apply_func, var_args=True)\n      .run(close, [0, 1], 10, b=100).out)\nprint(F.from_apply_func(apply_func_nb, var_args=True)\n      .run(close, [0, 1], 10, 100).out)\n```\n\n----------------------------------------\n\nTITLE: Comparing Conditional Value at Risk (CVaR) Calculations between empyrical and vectorbt\nDESCRIPTION: Shows Conditional Value at Risk calculations using both empyrical and vectorbt libraries with performance benchmarks. Includes single series, multiple series, and rolling window implementations with custom cutoff.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.conditional_value_at_risk(returns.iloc[1:]['a'], cutoff=0.05))\n%timeit empyrical.conditional_value_at_risk(big_returns[0], cutoff=0.05)\n\nprint(returns['a'].vbt.returns.cond_value_at_risk(cutoff=0.05))\n%timeit big_returns[0].vbt.returns.cond_value_at_risk(cutoff=0.05)\n\nprint(returns.vbt.returns.cond_value_at_risk(cutoff=0.05))\n%timeit big_returns.vbt.returns.cond_value_at_risk(cutoff=0.05)\n\nprint(returns.vbt.returns.rolling_cond_value_at_risk(3, minp=1, cutoff=0.05))\n%timeit big_returns.vbt.returns.rolling_cond_value_at_risk(3, minp=1, cutoff=0.05)\n```\n\n----------------------------------------\n\nTITLE: Numba-optimized Spread Calculation Functions\nDESCRIPTION: JIT-compiled functions using Numba for calculating rolling log returns and OLS-based spreads and z-scores for pairs trading\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@njit\ndef rolling_logret_zscore_nb(a, b, period):\n    \"\"\"Calculate the log return spread.\"\"\"\n    spread = np.full_like(a, np.nan, dtype=np.float64)\n    spread[1:] = np.log(a[1:] / a[:-1]) - np.log(b[1:] / b[:-1])\n    zscore = np.full_like(a, np.nan, dtype=np.float64)\n    for i in range(a.shape[0]):\n        from_i = max(0, i + 1 - period)\n        to_i = i + 1\n        if i < period - 1:\n            continue\n        spread_mean = np.mean(spread[from_i:to_i])\n        spread_std = np.std(spread[from_i:to_i])\n        zscore[i] = (spread[i] - spread_mean) / spread_std\n    return spread, zscore\n\n@njit\ndef ols_spread_nb(a, b):\n    \"\"\"Calculate the OLS spread.\"\"\"\n    a = np.log(a)\n    b = np.log(b)\n    _b = np.vstack((b, np.ones(len(b)))).T\n    slope, intercept = np.dot(np.linalg.inv(np.dot(_b.T, _b)), np.dot(_b.T, a))\n    spread = a - (slope * b + intercept)\n    return spread[-1]\n    \n@njit\ndef rolling_ols_zscore_nb(a, b, period):\n    \"\"\"Calculate the z-score of the rolling OLS spread.\"\"\"\n    spread = np.full_like(a, np.nan, dtype=np.float64)\n    zscore = np.full_like(a, np.nan, dtype=np.float64)\n    for i in range(a.shape[0]):\n        from_i = max(0, i + 1 - period)\n        to_i = i + 1\n        if i < period - 1:\n            continue\n        spread[i] = ols_spread_nb(a[from_i:to_i], b[from_i:to_i])\n        spread_mean = np.mean(spread[from_i:to_i])\n        spread_std = np.std(spread[from_i:to_i])\n        zscore[i] = (spread[i] - spread_mean) / spread_std\n    return spread, zscore\n```\n\n----------------------------------------\n\nTITLE: Creating a Telegram Bot for Binance Ticker Data with vectorbt\nDESCRIPTION: Demonstrates how to create a Telegram bot using vectorbt that returns the latest ticker price for a specified symbol on Binance. The implementation inherits from vbt.TelegramBot and uses the ccxt library to fetch cryptocurrency data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from telegram.ext import CommandHandler\n>>> import ccxt\n\n>>> class BinanceTickerBot(vbt.TelegramBot):\n...     @property\n...     def custom_handlers(self):\n...         return CommandHandler('get', self.get),\n...\n...     @property\n...     def help_message(self):\n...         return \"Type /get [symbol] to get the latest ticker on Binance.\"\n...\n...     def get(self, update, context):\n...         chat_id = update.effective_chat.id\n...         try:\n...             ticker = ccxt.binance().fetchTicker(context.args[0])\n...         except Exception as e:\n...             self.send_message(chat_id, str(e))\n...             return\n...         self.send_message(chat_id, str(ticker['last']))\n\n>>> bot = BinanceTickerBot(token='YOUR_TOKEN')\n>>> bot.start()\n```\n\n----------------------------------------\n\nTITLE: Plotting Cumulative Returns with Filled Area to Benchmark\nDESCRIPTION: Demonstrates how to create a cumulative returns plot with the area between portfolio and benchmark filled for better visualization of relative performance. Uses vectorbt's plot_cumulative method with fill_to_benchmark option.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nreturns['a'].vbt.returns.plot_cumulative(benchmark_rets, fill_to_benchmark=True).show_svg()\n```\n\n----------------------------------------\n\nTITLE: Validating Results Between Backtrader and Low-Level Numba Simulation in Python\nDESCRIPTION: Constructs cash flows and positions from the raw Numba simulation records and validates against backtrader results to ensure consistency across implementations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# Proof that both bt and vbt produce the same cash\nfrom vectorbt.records import nb as records_nb\n\ncol_map = records_nb.col_map_nb(order_records['col'], target_shape[1])\ncash_flow = portfolio_nb.cash_flow_nb(target_shape, order_records, col_map, False)\ncash_flow_grouped = portfolio_nb.cash_flow_grouped_nb(cash_flow, group_lens)\ncash_grouped = portfolio_nb.cash_grouped_nb(target_shape, cash_flow_grouped, group_lens, init_cash)\n\npd.testing.assert_series_equal(bt_cash, bt_cash.vbt.wrapper.wrap(cash_grouped))\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Analyzers for Backtrader Pair Trading\nDESCRIPTION: This code defines three analyzer classes for the Backtrader framework to extract and track various aspects of trading performance. It includes analyzers for OHLCV data, cash and portfolio value tracking, and order execution details including prices, sizes, and commissions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass DataAnalyzer(bt.analyzers.Analyzer):\n    \"\"\"Analyzer to extract OHLCV.\"\"\"\n    def create_analysis(self):\n        self.rets0 = {}\n        self.rets1 = {}\n\n    def next(self):\n        self.rets0[self.strategy.datetime.datetime()] = [\n            self.data0.open[0],\n            self.data0.high[0],\n            self.data0.low[0],\n            self.data0.close[0],\n            self.data0.volume[0]\n        ]\n        self.rets1[self.strategy.datetime.datetime()] = [\n            self.data1.open[0],\n            self.data1.high[0],\n            self.data1.low[0],\n            self.data1.close[0],\n            self.data1.volume[0]\n        ]\n\n    def get_analysis(self):\n        return self.rets0, self.rets1\n\nclass CashValueAnalyzer(bt.analyzers.Analyzer):\n    \"\"\"Analyzer to extract cash and value.\"\"\"\n    def create_analysis(self):\n        self.rets = {}\n\n    def notify_cashvalue(self, cash, value):\n        self.rets[self.strategy.datetime.datetime()] = (cash, value)\n\n    def get_analysis(self):\n        return self.rets\n    \nclass OrderAnalyzer(bt.analyzers.Analyzer):\n    \"\"\"Analyzer to extract order price, size, value, and paid commission.\"\"\"\n    def create_analysis(self):\n        self.rets0 = {}\n        self.rets1 = {}\n\n    def notify_order(self, order):\n        if order.status == order.Completed:\n            if order.data._name == SYMBOL1:\n                rets = self.rets0\n            else:\n                rets = self.rets1\n            rets[self.strategy.datetime.datetime()] = (\n                order.executed.price,\n                order.executed.size,\n                -order.executed.size * order.executed.price,\n                order.executed.comm\n            )\n\n    def get_analysis(self):\n        return self.rets0, self.rets1\n```\n\n----------------------------------------\n\nTITLE: Generating Chained Stop-Loss Exit Signals in vectorbt\nDESCRIPTION: Creates sequences of entry-exit pairs based on stop-loss conditions, where each exit can trigger a new entry. Demonstrates different waiting periods between entries and exits with performance benchmarks.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ne = pd.Series([True, True, True, True, True, True])\nt = pd.Series([2, 3, 4, 3, 2, 1]).astype(np.float64)\n\nen, ex = e.vbt.signals.generate_stop_exits(t, -0.1, trailing=True, chain=True)\nprint(en)\nprint(ex)\nen, ex = e.vbt.signals.generate_stop_exits(t, -0.1, trailing=True, entry_wait=2, chain=True)\nprint(en)\nprint(ex)\nen, ex = e.vbt.signals.generate_stop_exits(t, -0.1, trailing=True, exit_wait=2, chain=True)\nprint(en)\nprint(ex)\n\n%timeit big_entries.vbt.signals.generate_stop_exits(big_ts, -0.1, chain=True)\n%timeit big_entries.vbt.signals.generate_stop_exits(big_ts, -0.1, trailing=True, chain=True)\n%timeit big_entries.vbt.signals.generate_stop_exits(big_ts, -0.1, trailing=True, pick_first=False, chain=True)\n```\n\n----------------------------------------\n\nTITLE: Generating Signals with Custom Function in vectorbt\nDESCRIPTION: Uses vectorbt's generate method with a Numba-compiled function to produce signals at randomly chosen positions. Shows both Series and DataFrame signal generation with a performance benchmark for large datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@njit\ndef choice_func_nb(from_i, to_i, col):\n    return np.random.choice(np.arange(from_i, to_i), size=1, replace=False)\n\nprint(pd.Series.vbt.signals.generate(5, choice_func_nb, index=index))\nprint(pd.DataFrame.vbt.signals.generate((5, 3), choice_func_nb, index=index, columns=columns))\n\n%timeit pd.DataFrame.vbt.signals.generate((1000, 1000), choice_func_nb)\n```\n\n----------------------------------------\n\nTITLE: Comparing Alpha Calculations between empyrical and vectorbt\nDESCRIPTION: Compares Alpha calculation implementations in empyrical and vectorbt libraries, with performance benchmarks. Demonstrates single series, multiple series, and rolling window calculations with risk-free rate.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.alpha(returns['a'], benchmark_rets, risk_free=0.01))\n%timeit empyrical.alpha(big_returns[0], benchmark_rets, risk_free=0.01)\n\nprint(returns['a'].vbt.returns.alpha(benchmark_rets, risk_free=0.01))\n%timeit big_returns[0].vbt.returns.alpha(big_benchmark_rets, risk_free=0.01)\n\nprint(returns.vbt.returns.alpha(benchmark_rets, risk_free=0.01))\n%timeit big_returns.vbt.returns.alpha(big_benchmark_rets, risk_free=0.01)\n\nprint(returns.vbt.returns.rolling_alpha(benchmark_rets, 3, minp=1, risk_free=0.01))\n%timeit big_returns.vbt.returns.rolling_alpha(big_benchmark_rets, 3, minp=1, risk_free=0.01)\n```\n\n----------------------------------------\n\nTITLE: Running OHLCSTX with Stop-Loss\nDESCRIPTION: Demonstrates the OHLCSTX (OHLC-based Stop Exit) indicator using price Open-High-Low-Close data with a stop-loss parameter. This indicator is more realistic as it uses full OHLC data to trigger exits based on price movement.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nohlcstx = vbt.OHLCSTX.run(\n    entries, price['open'], price['high'], price['low'], price['close'], \n    sl_stop=0.1\n)\n\nprint(ohlcstx.exits)\nprint(ohlcstx.stop_price)\nprint(ohlcstx.stop_type_readable)\nohlcstx[(0.1, 'b')].plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Setting Up Trading Environment and Strategy Implementation\nDESCRIPTION: Sets up the initial trading environment with data preparation, custom commission handling, and strategy implementation. Includes custom analyzers for tracking cash and portfolio value.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/shortcash.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nimport backtrader as bt\nimport pandas as pd\nimport numpy as np\nimport vectorbt as vbt\n\ndf = pd.DataFrame(index=[datetime(2020, 1, i + 1) for i in range(9)])\ndf['open'] = [1, 1, 2, 3, 4, 5, 6, 7, 8]\ndf['high'] = df['open'] + 0.5\ndf['low'] = df['open'] - 0.5\ndf['close'] = df['open']\ndata = bt.feeds.PandasData(dataname=df)\nsize = np.array([5, 5, -5, -5, -5, -5, 5, 5, 0])\n\n\nclass CommInfoFloat(bt.CommInfoBase):\n    \"\"\"Commission schema that keeps size as float.\"\"\"\n    params = (\n        ('stocklike', True),\n        ('commtype', bt.CommInfoBase.COMM_PERC),\n        ('percabs', True),\n      )\n    \n    def getsize(self, price, cash):\n        if not self._stocklike:\n            return self.p.leverage * (cash / self.get_margin(price))\n\n        return self.p.leverage * (cash / price)\n\n\nclass CashValueAnalyzer(bt.analyzers.Analyzer):\n    \"\"\"Analyzer to extract cash and value.\"\"\"\n    def create_analysis(self):\n        self.rets = {}\n\n    def notify_cashvalue(self, cash, value):\n        self.rets[self.strategy.datetime.datetime()] = (cash, value)\n\n    def get_analysis(self):\n        return self.rets\n\n\nclass TestStrategy(bt.Strategy):\n    def __init__(self):\n        self.i = 0\n        \n    def log(self, txt, dt=None):\n        dt = dt or self.data.datetime[0]\n        dt = bt.num2date(dt)\n        print('%s, %s' % (dt.isoformat(), txt))\n        \n    def notify_order(self, order):\n        if order.status in [bt.Order.Submitted, bt.Order.Accepted]:\n            return  # Await further notifications\n\n        if order.status == order.Completed:\n            if order.isbuy():\n                buytxt = 'BUY COMPLETE {}, size = {:.2f}, price = {:.2f}'.format(\n                    order.data._name, order.executed.size, order.executed.price)\n                self.log(buytxt, order.executed.dt)\n            else:\n                selltxt = 'SELL COMPLETE {}, size = {:.2f}, price = {:.2f}'.format(\n                    order.data._name, order.executed.size, order.executed.price)\n                self.log(selltxt, order.executed.dt)\n\n        elif order.status in [order.Expired, order.Canceled, order.Margin]:\n            self.log('%s ,' % order.Status[order.status])\n            pass  # Simply log\n\n        # Allow new orders\n        self.orderid = None\n        \n    def next(self):\n        if size[self.i] > 0:\n            self.buy(size=size[self.i])\n        elif size[self.i] < 0:\n            self.sell(size=-size[self.i])\n        self.i += 1\n\ndef bt_simulate(shortcash):\n    cerebro = bt.Cerebro()\n    comminfo = CommInfoFloat(commission=0.01)\n    cerebro.broker.addcommissioninfo(comminfo)\n    cerebro.addstrategy(TestStrategy)\n    cerebro.addanalyzer(CashValueAnalyzer)\n    cerebro.broker.setcash(100.)\n    cerebro.broker.set_checksubmit(False)\n    cerebro.broker.set_shortcash(shortcash)\n    cerebro.adddata(data)\n    return cerebro.run()[0]\n```\n\n----------------------------------------\n\nTITLE: Plotting Cumulative Returns with Benchmark in vectorbt\nDESCRIPTION: Shows how to plot cumulative returns against a benchmark using vectorbt's plot_cumulative method. The plot displays the performance comparison between a portfolio and its benchmark over time.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nreturns['a'].vbt.returns.plot_cumulative(benchmark_rets).show_svg()\n```\n\n----------------------------------------\n\nTITLE: Comparing Sortino Ratio Calculations between empyrical and vectorbt\nDESCRIPTION: Shows Sortino ratio calculations using both empyrical and vectorbt libraries with performance benchmarks. Includes examples for single series, multiple series, and rolling window calculations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.sortino_ratio(returns['b'], required_return=0.1))\n%timeit empyrical.sortino_ratio(big_returns[0], required_return=0.1)\n\nprint(returns['b'].vbt.returns.sortino_ratio(required_return=0.1))\n%timeit big_returns[0].vbt.returns.sortino_ratio(required_return=0.1)\n\nprint(returns.vbt.returns.sortino_ratio(required_return=0.1))\n%timeit big_returns.vbt.returns.sortino_ratio(required_return=0.1)\n\nprint(returns.vbt.returns.rolling_sortino_ratio(3, minp=1, required_return=0.1))\n%timeit big_returns.vbt.returns.rolling_sortino_ratio(3, minp=1, required_return=0.1)\n```\n\n----------------------------------------\n\nTITLE: Fetching Bitcoin Price Data with vectorbt\nDESCRIPTION: This snippet demonstrates how to fetch daily Bitcoin price data using vectorbt's YFData class. It downloads the closing price of BTC-USD for a specified date range.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/index.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import numpy as np\n>>> import pandas as pd\n>>> from datetime import datetime\n\n>>> import vectorbt as vbt\n\n>>> # Prepare data\n>>> start = '2019-01-01 UTC'  # crypto is in UTC\n>>> end = '2020-01-01 UTC'\n>>> btc_price = vbt.YFData.download('BTC-USD', start=start, end=end).get('Close')\n\n>>> btc_price\nDate\n2019-01-01 00:00:00+00:00    3843.520020\n2019-01-02 00:00:00+00:00    3943.409424\n2019-01-03 00:00:00+00:00    3836.741211\n...                                  ...\n2019-12-30 00:00:00+00:00    7292.995117\n2019-12-31 00:00:00+00:00    7193.599121\n2020-01-01 00:00:00+00:00    7200.174316\nFreq: D, Name: Close, Length: 366, dtype: float64\n```\n\n----------------------------------------\n\nTITLE: Generating Random Exit Signals from Entries in vectorbt\nDESCRIPTION: Creates random exit signals that correspond to existing entry signals. Demonstrates various waiting period configurations and includes a performance benchmark for large-scale datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.generate_random_exits(seed=42))\nprint(entries.vbt.signals.generate_random_exits(seed=42))\nprint(entries.vbt.signals.generate_random_exits(seed=42, wait=0))\n\n%timeit big_entries.vbt.signals.generate_random_exits(seed=42)\n```\n\n----------------------------------------\n\nTITLE: Validating Results Between Backtrader and VectorBT in Python\nDESCRIPTION: Validates that both backtrader (bt) and vectorbt (vbt) implementations produce the same cash and value results for the pair trading strategy, using pandas testing functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Proof that both bt and vbt produce the same result\npd.testing.assert_series_equal(bt_cash, vbt_pf2.cash().rename('cash'))\npd.testing.assert_series_equal(bt_value, vbt_pf2.value().rename('value'))\n```\n\n----------------------------------------\n\nTITLE: Creating Indicators with Multiple Outputs\nDESCRIPTION: Shows how to create indicators that return multiple output arrays (o1 and o2) from a single calculation, enabling more complex analysis and visualization capabilities.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n# test multiple outputs\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['o1', 'o2'])\nprint(F.from_apply_func(lambda ts, p: (ts * p, ts * p ** 2))\n      .run(close, [0, 1]).o1)\nprint(F.from_apply_func(lambda ts, p: (ts * p, ts * p ** 2))\n      .run(close, [0, 1]).o2)\nprint(F.from_apply_func(njit(lambda ts, p: (ts * p, ts * p ** 2)))\n      .run(close, [0, 1]).o1)\nprint(F.from_apply_func(njit(lambda ts, p: (ts * p, ts * p ** 2)))\n      .run(close, [0, 1]).o2)\n```\n\n----------------------------------------\n\nTITLE: Configuring Pairs Trading Strategy Parameters\nDESCRIPTION: Sets up the trading pair (PEP/KO), time period, trading parameters, and statistical thresholds for the pairs trading strategy. Includes configuration for cash allocation, commission percentage, and statistical boundaries for trade signals.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport scipy.stats as st\n\nSYMBOL1 = 'PEP'\nSYMBOL2 = 'KO'\nFROMDATE = datetime.datetime(2017, 1, 1, tzinfo=pytz.utc)\nTODATE = datetime.datetime(2019, 1, 1, tzinfo=pytz.utc)\nPERIOD = 100\nCASH = 100000\nCOMMPERC = 0.005  # 0.5%\nORDER_PCT1 = 0.1\nORDER_PCT2 = 0.1\nUPPER = st.norm.ppf(1 - 0.05 / 2)\nLOWER = -st.norm.ppf(1 - 0.05 / 2)\nMODE = 'OLS'  # OLS, log_return\n```\n\n----------------------------------------\n\nTITLE: Running STX with Fixed Stop Level\nDESCRIPTION: Executes the STX (Stop-based Exit) indicator with a fixed stop level of 0.1 on entry signals and time series data. This example demonstrates the basic usage of STX for implementing stop-loss or take-profit exits.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nstx = vbt.STX.run(entries, ts, 0.1)\n\nprint(stx.exits)\n```\n\n----------------------------------------\n\nTITLE: Creating Comparative Time Series Plots with vectorbt\nDESCRIPTION: Shows how to plot two time series against each other using vectorbt's visualization tools. This example generates random cumulative product series and compares them in a scatter plot format.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> sr1 = pd.Series(np.cumprod(np.random.normal(0, 0.01, 100) + 1))\n>>> sr2 = pd.Series(np.cumprod(np.random.normal(0, 0.01, 100) + 1))\n>>> sr1.vbt.plot_against(sr2)\n```\n\n----------------------------------------\n\nTITLE: Implementing Portfolio.from_order_func Method for Pair Trading in Python\nDESCRIPTION: Defines the necessary functions for a pair trading strategy using Portfolio.from_order_func method. Includes pre_group_func_nb for pair initialization, pre_segment_func_nb for z-score calculation and signal generation, and order_func_nb for order execution with target percentages.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom vectorbt.portfolio import nb as portfolio_nb\nfrom vectorbt.base.reshape_fns import flex_select_auto_nb\nfrom vectorbt.portfolio.enums import SizeType, Direction\nfrom collections import namedtuple\n\nMemory = namedtuple(\"Memory\", ('spread', 'zscore', 'status'))\nParams = namedtuple(\"Params\", ('period', 'upper', 'lower', 'order_pct1', 'order_pct2'))\n\n@njit\ndef pre_group_func_nb(c, _period, _upper, _lower, _order_pct1, _order_pct2):\n    \"\"\"Prepare the current group (= pair of columns).\"\"\"\n    assert c.group_len == 2\n    \n    # In contrast to bt, we don't have a class instance that we could use to store arrays,\n    # so let's create a namedtuple acting as a container for our arrays\n    # ( you could also pass each array as a standalone object, but a single object is more convenient)\n    spread = np.full(c.target_shape[0], np.nan, dtype=np.float64)\n    zscore = np.full(c.target_shape[0], np.nan, dtype=np.float64)\n    \n    # Note that namedtuples aren't mutable, you can't simply assign a value,\n    # thus make status variable an array of one element for an easy assignment\n    status = np.full(1, 0, dtype=np.int64)\n    memory = Memory(spread, zscore, status)\n    \n    # Treat each param as an array with value per group, and select the combination of params for this group\n    period = flex_select_auto_nb(np.asarray(_period), 0, c.group, True)\n    upper = flex_select_auto_nb(np.asarray(_upper), 0, c.group, True)\n    lower = flex_select_auto_nb(np.asarray(_lower), 0, c.group, True)\n    order_pct1 = flex_select_auto_nb(np.asarray(_order_pct1), 0, c.group, True)\n    order_pct2 = flex_select_auto_nb(np.asarray(_order_pct2), 0, c.group, True)\n    \n    # Put all params into a container (again, this is optional)\n    params = Params(period, upper, lower, order_pct1, order_pct2)\n    \n    # Create an array that will store our two target percentages used by order_func_nb\n    # we do it here instead of in pre_segment_func_nb to initialize the array once, instead of in each row\n    size = np.empty(c.group_len, dtype=np.float64)\n    \n    # The returned tuple is passed as arguments to the function below\n    return (memory, params, size)\n    \n\n@njit\ndef pre_segment_func_nb(c, memory, params, size, mode):\n    \"\"\"Prepare the current segment (= row within group).\"\"\"\n    \n    # We want to perform calculations once we reach full window size\n    if c.i < params.period - 1:\n        size[0] = np.nan  # size of nan means no order\n        size[1] = np.nan\n        return (size,)\n    \n    # z-core is calculated using a window (=period) of spread values\n    # This window can be specified as a slice\n    window_slice = slice(max(0, c.i + 1 - params.period), c.i + 1)\n    \n    # Here comes the same as in rolling_ols_zscore_nb\n    if mode == 'OLS':\n        a = c.close[window_slice, c.from_col]\n        b = c.close[window_slice, c.from_col + 1]\n        memory.spread[c.i] = ols_spread_nb(a, b)\n    elif mode == 'log_return':\n        logret_a = np.log(c.close[c.i, c.from_col] / c.close[c.i - 1, c.from_col])\n        logret_b = np.log(c.close[c.i, c.from_col + 1] / c.close[c.i - 1, c.from_col + 1])\n        memory.spread[c.i] = logret_a - logret_b\n    else:\n        raise ValueError(\"Unknown mode\")\n    spread_mean = np.mean(memory.spread[window_slice])\n    spread_std = np.std(memory.spread[window_slice])\n    memory.zscore[c.i] = (memory.spread[c.i] - spread_mean) / spread_std\n    \n    # Check if any bound is crossed\n    # Since zscore is calculated using close, use zscore of the previous step\n    # This way we are executing signals defined at the previous bar\n    # Same logic as in PairTradingStrategy\n    if memory.zscore[c.i - 1] > params.upper and memory.status[0] != 1:\n        size[0] = -params.order_pct1\n        size[1] = params.order_pct2\n        \n        # Here we specify the order of execution\n        # call_seq_now defines order for the current group (2 elements)\n        c.call_seq_now[0] = 0\n        c.call_seq_now[1] = 1\n        memory.status[0] = 1\n    elif memory.zscore[c.i - 1] < params.lower and memory.status[0] != 2:\n        size[0] = params.order_pct1\n        size[1] = -params.order_pct2\n        c.call_seq_now[0] = 1  # execute the second order first to release funds early\n        c.call_seq_now[1] = 0\n        memory.status[0] = 2\n    else:\n        size[0] = np.nan\n        size[1] = np.nan\n        \n    # Group value is converted to shares using previous close, just like in bt\n    # Note that last_val_price contains valuation price of all columns, not just the current pair\n    c.last_val_price[c.from_col] = c.close[c.i - 1, c.from_col]\n    c.last_val_price[c.from_col + 1] = c.close[c.i - 1, c.from_col + 1]\n        \n    return (size,)\n\n@njit\ndef order_func_nb(c, size, price, commperc):\n    \"\"\"Place an order (= element within group and row).\"\"\"\n    \n    # Get column index within group (if group starts at column 58 and current column is 59, \n    # the column within group is 1, which can be used to get size)\n    group_col = c.col - c.from_col\n    return portfolio_nb.order_nb(\n        size=size[group_col], \n        price=price[c.i, c.col],\n        size_type=SizeType.TargetPercent,\n        fees=commperc\n    )\n```\n\n----------------------------------------\n\nTITLE: RPROBNX with Multiple Probability Parameters in VectorBT (Python)\nDESCRIPTION: Demonstrates how to use RPROBNX with multiple probability parameters to generate different signal patterns across columns. Each parameter set creates a distinct column in the output.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nrprobnx = vbt.RPROBNX.run(entry_prob=[0.5, 1.], exit_prob=[1., 0.5], input_shape=(5,), seed=42)\n\nprint(rprobnx.entries)\nprint(rprobnx.exits)\n```\n\n----------------------------------------\n\nTITLE: Defining Parameter Ranges for Strategy Optimization in Python\nDESCRIPTION: Setting up arrays of parameter values for a hyperparameter optimization study. This creates ranges for period lengths and upper/lower thresholds that will be used in a parameter sweep.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nperiods = np.arange(10, 105, 5)\nuppers = np.arange(1.5, 2.2, 0.1)\nlowers = -1 * np.arange(1.5, 2.2, 0.1)\n```\n\n----------------------------------------\n\nTITLE: Generating Random Exits with Probability in vectorbt\nDESCRIPTION: Creates exit signals from entries based on specified probabilities. Shows examples with uniform probability and column-specific probabilities, with a performance benchmark for large datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.generate_random_exits(prob=1., seed=42))\nprint(entries.vbt.signals.generate_random_exits(prob=1., seed=42))\nprint(entries.vbt.signals.generate_random_exits(prob=[0., 0.5, 1], seed=42))\nprint(entries.vbt.signals.generate_random_exits(prob=1., seed=42, wait=0))\n\n%timeit big_entries.vbt.signals.generate_random_exits(prob=1., seed=42)\n```\n\n----------------------------------------\n\nTITLE: Calculating Sharpe Ratio\nDESCRIPTION: Compares implementations for calculating the Sharpe ratio with custom risk-free rate. Includes performance benchmarking for single-column, multi-column, and rolling window approaches.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.sharpe_ratio(returns['a'], risk_free=0.01))\n%timeit empyrical.sharpe_ratio(big_returns[0], risk_free=0.01)\n\nprint(returns['a'].vbt.returns.sharpe_ratio(risk_free=0.01))\n%timeit big_returns[0].vbt.returns.sharpe_ratio(risk_free=0.01)\n\nprint(returns.vbt.returns.sharpe_ratio(risk_free=0.01))\n%timeit big_returns.vbt.returns.sharpe_ratio(risk_free=0.01)\n\nprint(returns.vbt.returns.rolling_sharpe_ratio(3, minp=1, risk_free=0.01))\n%timeit big_returns.vbt.returns.rolling_sharpe_ratio(3, minp=1, risk_free=0.01)\n```\n\n----------------------------------------\n\nTITLE: Running OHLCSTCX with Stop-Loss\nDESCRIPTION: Demonstrates the OHLCSTCX (OHLC-based Stop Exit with Re-entry) indicator with stop-loss parameter. This extends OHLCSTX by allowing positions to be re-entered after being stopped out.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nohlcstcx = vbt.OHLCSTCX.run(\n    entries, price['open'], price['high'], price['low'], price['close'], \n    sl_stop=0.1\n)\n\nprint(ohlcstcx.new_entries)\nprint(ohlcstcx.exits)\nprint(ohlcstcx.stop_price)\nprint(ohlcstcx.stop_type_readable)\nohlcstcx[(0.1, 'b')].plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Creating Multi-subplot Portfolio Visualizations with vectorbt\nDESCRIPTION: Shows how to create multi-subplot visualizations of portfolio performance using the plots builder. This example displays cash balance, asset value, and total portfolio value in separate panels.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> price = vbt.YFData.download('BTC-USD').get('Close')\n>>> pf = vbt.Portfolio.from_random_signals(price, n=5)\n>>> pf.plot(subplots=['cash', 'assets', 'value']).show_svg()\n```\n\n----------------------------------------\n\nTITLE: Splitting Price Data into Trading Sessions with VectorBT in Python\nDESCRIPTION: Identifies the start (9 AM) and end (4 PM) of each trading session, then splits the price data into separate ranges for each session using VectorBT's range_split function.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Select first and last ticks of each trading session and split price into ranges between those ticks\nstart_idxs = session_price.index[session_price.index.hour == 9]\nend_idxs = session_price.index[session_price.index.hour == 16]\nprice_per_session, _ = session_price.vbt(freq='1H').range_split(start_idxs=start_idxs, end_idxs=end_idxs)\nprint(price_per_session)\n```\n\n----------------------------------------\n\nTITLE: Portfolio Simulation Functions\nDESCRIPTION: Collection of functions for simulating portfolio performance and calculating Sharpe ratios.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef simulate_holding(price, **kwargs):\n    pf = vbt.Portfolio.from_holding(price, **kwargs)\n    return pf.sharpe_ratio()\n\ndef simulate_all_params(price, windows, **kwargs):\n    fast_ma, slow_ma = vbt.MA.run_combs(price, windows, r=2, short_names=['fast', 'slow'])\n    entries = fast_ma.ma_crossed_above(slow_ma)\n    exits = fast_ma.ma_crossed_below(slow_ma)\n    pf = vbt.Portfolio.from_signals(price, entries, exits, **kwargs)\n    return pf.sharpe_ratio()\n\ndef get_best_index(performance, higher_better=True):\n    if higher_better:\n        return performance[performance.groupby('split_idx').idxmax()].index\n    return performance[performance.groupby('split_idx').idxmin()].index\n\ndef get_best_params(best_index, level_name):\n    return best_index.get_level_values(level_name).to_numpy()\n\ndef simulate_best_params(price, best_fast_windows, best_slow_windows, **kwargs):\n    fast_ma = vbt.MA.run(price, window=best_fast_windows, per_column=True)\n    slow_ma = vbt.MA.run(price, window=best_slow_windows, per_column=True)\n    entries = fast_ma.ma_crossed_above(slow_ma)\n    exits = fast_ma.ma_crossed_below(slow_ma)\n    pf = vbt.Portfolio.from_signals(price, entries, exits, **kwargs)\n    return pf.sharpe_ratio()\n```\n\n----------------------------------------\n\nTITLE: Analyzing Signal Distribution Statistics with vectorbt\nDESCRIPTION: Demonstrates the Stats Builder feature to analyze the distribution of signals in a boolean mask. The example creates a time series with True/False values and calculates various statistics about signal occurrences, partitions, and timing.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(7)]\n>>> mask = pd.Series([False, True, True, True, False, True, False])\n>>> mask.vbt.signals(freq='d').stats()\nStart                                               0\nEnd                                                 6\nPeriod                                7 days 00:00:00\nTotal                                               4\nRate [%]                                    57.142857\nFirst Index                                         1\nLast Index                                          5\nNorm Avg Index [-1, 1]                      -0.083333\nDistance: Min                         1 days 00:00:00\nDistance: Max                         2 days 00:00:00\nDistance: Mean                        1 days 08:00:00\nDistance: Std               0 days 13:51:23.063257983\nTotal Partitions                                    2\nPartition Rate [%]                               50.0\nPartition Length: Min                 1 days 00:00:00\nPartition Length: Max                 3 days 00:00:00\nPartition Length: Mean                2 days 00:00:00\nPartition Length: Std       1 days 09:56:28.051789035\nPartition Distance: Min               2 days 00:00:00\nPartition Distance: Max               2 days 00:00:00\nPartition Distance: Mean              2 days 00:00:00\nPartition Distance: Std                           NaT\ndtype: object\n```\n\n----------------------------------------\n\nTITLE: Comparing Capture Ratio Calculations between empyrical and vectorbt\nDESCRIPTION: Demonstrates Capture Ratio calculations in both empyrical and vectorbt libraries with performance benchmarks. Shows implementations for single series, multiple series, and rolling window calculations against benchmark returns.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.capture(returns['a'], benchmark_rets))\n%timeit empyrical.capture(big_returns[0], big_benchmark_rets)\n\nprint(returns['a'].vbt.returns.capture(benchmark_rets))\n%timeit big_returns[0].vbt.returns.capture(big_benchmark_rets)\n\nprint(returns.vbt.returns.capture(benchmark_rets))\n%timeit big_returns.vbt.returns.capture(big_benchmark_rets)\n\nprint(returns.vbt.returns.rolling_capture(benchmark_rets, 3, minp=1))\n%timeit big_returns.vbt.returns.rolling_capture(big_benchmark_rets, 3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Calculating Deflated Sharpe Ratio with vectorbt\nDESCRIPTION: Demonstrates how to calculate the deflated Sharpe ratio using vectorbt, which accounts for multiple testing bias. The function accepts parameters for risk-free rate, variance of Sharpe ratio, and number of trials.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# can specify var_sharpe and nb_trials expclicitly\nprint(big_returns[0].vbt.returns.deflated_sharpe_ratio(\n    risk_free=0.01, \n    var_sharpe=np.var(big_returns.vbt.returns.sharpe_ratio(risk_free=0.01)),\n    nb_trials=big_returns.shape[1]\n))\n```\n\n----------------------------------------\n\nTITLE: Calculating Total Returns\nDESCRIPTION: Compares empyrical's cum_returns_final with vectorbt's total() method for calculating total returns over the entire period. Also demonstrates rolling window total returns calculation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.cum_returns_final(returns['a']))\n%timeit empyrical.cum_returns_final(big_returns[0])\n\nprint(returns['a'].vbt.returns.total())\n%timeit big_returns[0].vbt.returns.total()\n\nprint(returns.vbt.returns.total())\n%timeit big_returns.vbt.returns.total()\n\nprint(returns.vbt.returns.rolling_total(3, minp=1))\n%timeit big_returns.vbt.returns.rolling_total(3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Analyzing Trade Returns with vectorbt Portfolio\nDESCRIPTION: Demonstrates how to analyze individual trade returns from a backtest. The example creates a portfolio with random entry signals, extracts entry trades, and displays the returns of each trade.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> price = vbt.YFData.download('BTC-USD').get('Close')\n>>> entry_trades = vbt.Portfolio.from_random_signals(price, n=5).entry_trades\n>>> returns_pd = entry_trades.returns.to_pd()\n>>> returns_pd[~returns_pd.isnull()]\nDate\n2017-11-12 00:00:00+00:00    0.742975\n2019-08-30 00:00:00+00:00   -0.081744\n2020-04-21 00:00:00+00:00    0.489072\n2020-09-13 00:00:00+00:00    0.262251\n2021-03-07 00:00:00+00:00   -0.382155\ndtype: float64\n```\n\n----------------------------------------\n\nTITLE: Running STX with Array of Stop Levels\nDESCRIPTION: Uses the STX indicator with multiple stop levels defined as a NumPy array. This approach allows testing different stop parameters simultaneously across columns of data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nstx = vbt.STX.run(entries, ts, np.asarray([0.1, 0.1, -0.1, -0.1, -0.1])[:, None])\n\nprint(stx.exits)\n```\n\n----------------------------------------\n\nTITLE: Generating OHLC-based Stop Exits in vectorbt\nDESCRIPTION: Creates exit signals based on OHLC price data with various stop-loss and take-profit configurations. Records the stop price and type that triggered each exit, with examples of standard and trailing stops.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndef test_ohlc_stop_exits(**kwargs):\n    out_dict = {}\n    result = entries.vbt.signals.generate_ohlc_stop_exits(\n        price['open'], price['high'], price['low'], price['close'],\n        out_dict=out_dict, **kwargs\n    )\n    if isinstance(result, tuple):\n        _, ex = result\n    else:\n        ex = result\n    out_dict['stop_price'][~ex] = np.nan\n    out_dict['stop_type'][~ex] = -1\n    return result, out_dict['stop_price'], out_dict['stop_type']\n\nex, stop_price, stop_type = test_ohlc_stop_exits()\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n\nex, stop_price, stop_type = test_ohlc_stop_exits(sl_stop=0.1)\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n\nex, stop_price, stop_type = test_ohlc_stop_exits(sl_stop=0.1, sl_trail=True)\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n\nex, stop_price, stop_type = test_ohlc_stop_exits(tp_stop=0.1)\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n\nex, stop_price, stop_type = test_ohlc_stop_exits(sl_stop=0.1, sl_trail=True, tp_stop=0.1)\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n\nex, stop_price, stop_type = test_ohlc_stop_exits(\n    sl_stop=[np.nan, 0.5, 1.], sl_trail=True, tp_stop=[np.nan, 0.5, 1.])\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n```\n\n----------------------------------------\n\nTITLE: Running OHLCSTX with Multiple Stop Types\nDESCRIPTION: Uses OHLCSTX with multiple stop configurations including stop-loss, trailing stop, and take-profit parameters. Shows how different columns can have different stop strategies applied simultaneously.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_68\n\nLANGUAGE: python\nCODE:\n```\nohlcstx = vbt.OHLCSTX.run(\n    entries, price['open'], price['high'], price['low'], price['close'], \n    sl_stop=[0.1, 0., 0.], ts_stop=[0., 0.1, 0.], tp_stop=[0., 0., 0.1]\n)\n\nprint(ohlcstx.exits)\nprint(ohlcstx.stop_price)\nprint(ohlcstx.stop_type_readable)\n```\n\n----------------------------------------\n\nTITLE: Configuring Backtrader Cerebro for Pair Trading\nDESCRIPTION: This function sets up a Backtrader cerebro instance for pair trading, adding data feeds and strategy with optional analyzers. It configures the necessary components to run a pair trading backtest with the provided data feeds and parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef prepare_cerebro(data0, data1, use_analyzers=True, **params):\n    # Create a cerebro\n    cerebro = bt.Cerebro()\n\n    # Add the 1st data to cerebro\n    cerebro.adddata(data0)\n\n    # Add the 2nd data to cerebro\n    cerebro.adddata(data1)\n\n    # Add the strategy\n    cerebro.addstrategy(PairTradingStrategy, **params)\n```\n\n----------------------------------------\n\nTITLE: Using apply_and_concat_multiple Functions in VectorBT\nDESCRIPTION: Demonstrates the apply_and_concat_multiple functions in VectorBT which apply a function returning multiple arrays and concatenate them. Examples show both regular and Numba-accelerated versions with Series and DataFrame inputs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nprint(combine_fns.apply_and_concat_multiple(3, lambda i, x, a: (x, x + a[i]), sr2.values, [10, 20, 30]))\nprint(combine_fns.apply_and_concat_multiple_nb(3, njit(lambda i, x, a: (x, x + a[i])), sr2.values, (10, 20, 30)))\n\nprint(combine_fns.apply_and_concat_multiple(3, lambda i, x, a: (x, x + a[i]), df4.values, [10, 20, 30]))\nprint(combine_fns.apply_and_concat_multiple_nb(3, njit(lambda i, x, a: (x, x + a[i])), df4.values, (10, 20, 30)))\n```\n\n----------------------------------------\n\nTITLE: Creating Indicators Without Input Time Series\nDESCRIPTION: Demonstrates creating indicators with no input time series, only parameters. Shows how to generate output arrays directly from parameters using both regular and Numba-optimized functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# test no inputs\nF = vbt.IndicatorFactory(param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(lambda p: np.full((3, 3), p))\n      .run([0, 1]).out)\nprint(F.from_apply_func(njit(lambda p: np.full((3, 3), p)))\n      .run([0, 1]).out)\n```\n\n----------------------------------------\n\nTITLE: Comparing Maximum Drawdown Calculations between empyrical and vectorbt\nDESCRIPTION: Demonstrates Maximum Drawdown calculations in both empyrical and vectorbt libraries with performance benchmarks. Shows implementations for single series, multiple series, and rolling window calculations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.max_drawdown(returns['b']))\n%timeit empyrical.max_drawdown(big_returns[0])\n\nprint(returns['b'].vbt.returns.max_drawdown())\n%timeit big_returns[0].vbt.returns.max_drawdown()\n\nprint(returns.vbt.returns.max_drawdown())\n%timeit big_returns.vbt.returns.max_drawdown()\n\nprint(returns.vbt.returns.rolling_max_drawdown(3, minp=1))\n%timeit big_returns.vbt.returns.rolling_max_drawdown(3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Calculating Calmar Ratio\nDESCRIPTION: Compares implementations for calculating the Calmar ratio (annualized return divided by maximum drawdown). Includes performance benchmarking and rolling window calculations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.calmar_ratio(returns['b']))\n%timeit empyrical.calmar_ratio(big_returns[0])\n\nprint(returns['b'].vbt.returns.calmar_ratio())\n%timeit big_returns[0].vbt.returns.calmar_ratio()\n\nprint(returns.vbt.returns.calmar_ratio())\n%timeit big_returns.vbt.returns.calmar_ratio()\n\nprint(returns.vbt.returns.rolling_calmar_ratio(3, minp=1))\n%timeit big_returns.vbt.returns.rolling_calmar_ratio(3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Downloading Bitcoin Price Data\nDESCRIPTION: Fetches Bitcoin price data from Yahoo Finance using VectorBT's data download functionality.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprice = vbt.YFData.download('BTC-USD').get('Close')\n```\n\n----------------------------------------\n\nTITLE: Generating OHLC Stop Exits in VectorBT (Python)\nDESCRIPTION: Demonstrates how to generate stop exits based on OHLC price data using trailing stop-loss and take-profit parameters. The code shows both the basic implementation and times the operation on a large dataset.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nex, stop_price, stop_type = test_ohlc_stop_exits(sl_stop=0.1, sl_trail=True, tp_stop=0.1, exit_wait=0)\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n\n%timeit big_entries.vbt.signals.generate_ohlc_stop_exits(\\\n    big_ts, big_ts + 1, big_ts - 1, big_ts, sl_stop=0.1, sl_trail=True, tp_stop=0.1)\n```\n\n----------------------------------------\n\nTITLE: Plotting OHLCV Data with Manual Column Name Specification\nDESCRIPTION: Demonstrates how to manually specify the column name mapping when plotting OHLCV data, allowing vectorbt to correctly identify which columns contain open, high, low, close, and volume data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Specify them manually\nohlcv_ts.vbt.ohlcv(column_names={\n    'open': 'open', \n    'high': 'high', \n    'low': 'low', \n    'close': 'close', \n    'volume': 'volume'\n}).plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Configuring API Settings and Constants\nDESCRIPTION: Sets up configurations for Telegram and Giphy APIs, along with constants for cryptocurrency symbols, timeframes, and Bollinger Band parameters for market analysis.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Telegram\nvbt.settings.messaging['telegram']['token'] = \"YOUR_TOKEN\"\n\n# Giphy\nvbt.settings.messaging['giphy']['api_key'] = \"YOUR_API_KEY\"\n\n# Data\nSYMBOLS = ['BTC/USDT', 'ETH/USDT', 'ADA/USDT']\nSTART = '1 hour ago UTC'\nTIMEFRAME = '1m'\nUPDATE_EVERY = vbt.utils.datetime.interval_to_ms(TIMEFRAME) // 1000  # in seconds\nDT_FORMAT = '%d %b %Y %H:%M:%S %z'\nIND_PARAMS = dict(\n    timeperiod=20, \n    nbdevup=2, \n    nbdevdn=2\n)\nCHANGE_NBDEV = 2\n```\n\n----------------------------------------\n\nTITLE: Using Look-ahead extrema (LEXLB) Label Generator\nDESCRIPTION: Demonstrates the Look-ahead Extrema label generator with various positive and negative thresholds. Includes performance testing and shows output shape.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.LEXLB.run(close, pos_th=pos_ths, neg_th=neg_ths).labels)\n\n%timeit vbt.LEXLB.run(big_close, pos_th=1, neg_th=0.5)\n\nprint(vbt.LEXLB.run(big_close, pos_th=1, neg_th=0.5).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Performing Logical Operations on Signals in VectorBT (Python)\nDESCRIPTION: Compares two methods for performing logical AND operations on signals: using the & operator directly and using the AND method from the signals accessor. The AND method supports smart broadcasting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nprint(entries & entries)\n%timeit big_entries & big_entries\n\nprint(entries.vbt.signals.AND(entries))\n%timeit big_entries.vbt.signals.AND(big_entries) # a bit slower but does smart broadcasting\n```\n\n----------------------------------------\n\nTITLE: Scheduling Bitcoin Price Updates with vectorbt\nDESCRIPTION: Shows how to use vectorbt's ScheduleManager to periodically display the latest Bitcoin trades from Binance. The example fetches trade data every 10 seconds, converts it to a time series, and visualizes it using vectorbt's plotting capabilities.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> from vectorbt.utils.datetime_ import datetime_to_ms, to_tzaware_datetime, get_utc_tz\n>>> from IPython.display import SVG, display, clear_output\n\n>>> exchange = ccxt.binance()\n\n>>> def job_func():\n...     since = datetime_to_ms(to_tzaware_datetime('10 seconds ago UTC', tz=get_utc_tz()))\n...     trades = exchange.fetch_trades('BTC/USDT', since)\n...     price = pd.Series({t['datetime']: t['price'] for t in trades})\n...     svg = price.vbt.plot().to_image(format=\"svg\")\n...     clear_output()\n...     display(SVG(svg))\n\n>>> scheduler = vbt.ScheduleManager()\n>>> scheduler.every(10, 'seconds').do(job_func)\n>>> scheduler.start()\n```\n\n----------------------------------------\n\nTITLE: Calculating Annualized Returns\nDESCRIPTION: Compares empyrical and vectorbt implementations for calculating annualized returns. Demonstrates both single-column and multi-column approaches with performance benchmarking.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.annual_return(returns['a']))\n%timeit empyrical.annual_return(big_returns[0])\n\nprint(returns['a'].vbt.returns.annualized())\n%timeit big_returns[0].vbt.returns.annualized()\n\nprint(returns.vbt.returns.annualized())\n%timeit big_returns.vbt.returns.annualized()\n\nprint(returns.vbt.returns.rolling_annualized(3, minp=1))\n%timeit big_returns.vbt.returns.rolling_annualized(3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Creating Indicators with Multiple Parameters\nDESCRIPTION: Demonstrates creating indicators that take multiple parameters (p1 and p2) and combine them in calculations, using both regular Python and Numba-optimized functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n# test multiple params\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2))\n      .run(close, np.asarray([0, 1]), np.asarray([2, 3])).out) \nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)))\n      .run(close, np.asarray([0, 1]), np.asarray([2, 3])).out)\n```\n\n----------------------------------------\n\nTITLE: Portfolio Simulation with VectorBT\nDESCRIPTION: Sets up and executes portfolio simulation using VectorBT's Portfolio.from_orders method with custom order sizing and price execution logic\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef simulate_from_orders():\n    \"\"\"Simulate using `Portfolio.from_orders`.\"\"\"\n    return vbt.Portfolio.from_orders(\n        vbt_close_price,  # current close as reference price\n        size=vbt_order_size,  \n        price=vbt_open_price,  # current open as execution price\n        size_type='targetpercent', \n        val_price=vbt_close_price.vbt.fshift(1),  # previous close as group valuation price\n        init_cash=CASH,\n        fees=COMMPERC,\n        cash_sharing=True,  # share capital between assets in the same group\n        group_by=True,  # all columns belong to the same group\n        call_seq='auto',  # sell before buying\n        freq='d'  # index frequency for annualization\n    )\n\nvbt_pf = simulate_from_orders()\n```\n\n----------------------------------------\n\nTITLE: Implementing Cached Methods with vectorbt\nDESCRIPTION: Demonstrates vectorbt's caching mechanism through a cached method decorator. The example creates a class with a cached method to measure elapsed time, then shows how to disable caching globally using vectorbt's cache condition functionality.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> import time\n>>> start = time.time()\n\n>>> class MyClass:\n...     @vbt.cached_method\n...     def get_elapsed(self):\n...         return time.time() - start\n\n>>> my_inst = MyClass()\n>>> my_inst.get_elapsed()\n0.00010895729064941406\n\n>>> my_inst.get_elapsed()\n0.00010895729064941406\n\n>>> get_elapsed_cond = vbt.CacheCondition(instance=my_inst, func='get_elapsed')\n>>> vbt.settings.caching['blacklist'].append(get_elapsed_cond)\n>>> my_inst.get_elapsed()\n0.01081395149230957\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Indicators with IndicatorFactory and Custom Functions\nDESCRIPTION: Demonstrates how to use IndicatorFactory with custom functions for creating indicators. Shows examples with both standard Python functions and Numba-optimized versions with variable arguments.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef apply_func(i, ts, p, a, b=100):\n    return ts * p[i] + a + b\n\n@njit\ndef apply_func_nb(i, ts, p, a, b):\n    return ts * p[i] + a + b # numba doesn't support **kwargs\n\n# Custom function can be anything that takes time series, params and other arguments, and returns outputs\ndef custom_func(ts, p, *args, **kwargs):\n    return vbt.base.combine_fns.apply_and_concat_one(len(p), apply_func, ts, p, *args, **kwargs)\n\n@njit\ndef custom_func_nb(ts, p, *args):\n    return vbt.base.combine_fns.apply_and_concat_one_nb(len(p), apply_func_nb, ts, p, *args)\n\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['out'])\nprint(F.from_custom_func(custom_func, var_args=True)\n      .run(close, [0, 1], 10, b=100).out)\nprint(F.from_custom_func(custom_func_nb, var_args=True)\n      .run(close, [0, 1], 10, 100).out)\n```\n\n----------------------------------------\n\nTITLE: Calculating Position Rank of Signals in VectorBT (Python)\nDESCRIPTION: Demonstrates various ways to calculate position ranks of signals with different parameters including after_false, allow_gaps, and reset_by. Position rank indicates the sequential number of each signal appearance.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.pos_rank())\nprint(entries.vbt.signals.pos_rank())\n\nprint(entries['a'].vbt.signals.pos_rank(after_false=True))\nprint(entries.vbt.signals.pos_rank(after_false=True))\n\nprint(entries['a'].vbt.signals.pos_rank(allow_gaps=True))\nprint(entries.vbt.signals.pos_rank(allow_gaps=True))\n\nprint(entries['a'].vbt.signals.pos_rank(allow_gaps=True, reset_by=~entries['a']))\nprint(entries.vbt.signals.pos_rank(allow_gaps=True, reset_by=~entries))\n\n%timeit big_entries.vbt.signals.pos_rank()\n```\n\n----------------------------------------\n\nTITLE: Comparing Beta Calculations between empyrical and vectorbt\nDESCRIPTION: Shows Beta calculation implementations in both empyrical and vectorbt libraries with performance benchmarks. Includes examples for single series, multiple series, and rolling window calculations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.beta(returns['a'], benchmark_rets))\n%timeit empyrical.beta(big_returns[0], benchmark_rets)\n\nprint(returns['a'].vbt.returns.beta(benchmark_rets))\n%timeit big_returns[0].vbt.returns.beta(big_benchmark_rets)\n\nprint(returns.vbt.returns.beta(benchmark_rets))\n%timeit big_returns.vbt.returns.beta(big_benchmark_rets)\n\nprint(returns.vbt.returns.rolling_beta(benchmark_rets, 3, minp=1))\n%timeit big_returns.vbt.returns.rolling_beta(big_benchmark_rets, 3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Unstacking Series to DataFrame with Different Level Arrangements\nDESCRIPTION: Demonstrates converting Series with MultiIndex to DataFrame using unstack_to_df. Shows examples with different index and column level configurations, including symmetric output option.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.unstack_to_df(df5.iloc[0]))\nprint(reshape_fns.unstack_to_df(sr, index_levels=0, column_levels=1))\nprint(reshape_fns.unstack_to_df(sr, index_levels=(0, 1), column_levels=2))\nprint(reshape_fns.unstack_to_df(sr, index_levels=0, column_levels=1, symmetric=True).columns)\n```\n\n----------------------------------------\n\nTITLE: Running STX with Trailing Stop Options\nDESCRIPTION: Demonstrates STX with both regular and trailing stops. The trailing parameter controls whether the stop level adjusts as the price moves favorably, providing dynamic protection of profits.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nstx = vbt.STX.run(entries, ts, [0.1, 0.1, -0.1, -0.1], trailing=[False, True, False, True])\n\nprint(stx.exits)\n```\n\n----------------------------------------\n\nTITLE: Calculating Omega Ratio\nDESCRIPTION: Compares implementations for calculating the Omega ratio with custom risk-free rate and required return parameters. Includes performance benchmarking for various approaches.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.omega_ratio(returns['c'], risk_free=0.01, required_return=0.1))\n%timeit empyrical.omega_ratio(big_returns[0], risk_free=0.01, required_return=0.1)\n\nprint(returns['c'].vbt.returns.omega_ratio(risk_free=0.01, required_return=0.1))\n%timeit big_returns[0].vbt.returns.omega_ratio(risk_free=0.01, required_return=0.1)\n\nprint(returns.vbt.returns.omega_ratio(risk_free=0.01, required_return=0.1))\n%timeit big_returns.vbt.returns.omega_ratio(risk_free=0.01, required_return=0.1)\n\nprint(returns.vbt.returns.rolling_omega_ratio(3, minp=1, risk_free=0.01, required_return=0.1))\n%timeit big_returns.vbt.returns.rolling_omega_ratio(3, minp=1, risk_free=0.01, required_return=0.1)\n```\n\n----------------------------------------\n\nTITLE: Generating Random Entries and Exits with RPROBNX in vectorbt\nDESCRIPTION: Shows how to generate entry and exit signals using different probabilities with the RPROBNX generator. This example demonstrates the parameterization capabilities for signal generation across multiple columns.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> rprobnx = vbt.RPROBNX.run(\n...     input_shape=(5,),\n...     entry_prob=[0.5, 1.],\n...     exit_prob=[0.5, 1.],\n...     param_product=True,\n...     seed=42)\n\n>>> rprobnx.entries\nrprobnx_entry_prob    0.5    0.5    1.0    0.5\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                    True   True   True   True\n1                   False  False  False  False\n2                   False  False  False   True\n3                   False  False  False  False\n4                   False  False   True   True\n\n>>> rprobnx.exits\nrprobnx_entry_prob    0.5    0.5    1.0    1.0\nrprobnx_exit_prob     0.5    1.0    0.5    1.0\n0                   False  False  False  False\n1                   False   True  False   True\n2                   False  False  False  False\n3                   False  False   True   True\n4                    True  False  False  False\n```\n\n----------------------------------------\n\nTITLE: Downloading Cryptocurrency Data\nDESCRIPTION: Downloads OHLCV data for the specified cryptocurrency pairs using the CCXT integration in vectorbt and prints the timestamp index of the data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndata = vbt.CCXTData.download(SYMBOLS, start=START, timeframe=TIMEFRAME)\n\nprint(data.wrapper.index)\n```\n\n----------------------------------------\n\nTITLE: Comparing Up Capture Ratio Calculations between empyrical and vectorbt\nDESCRIPTION: Shows Up Capture Ratio calculations using both empyrical and vectorbt libraries with performance benchmarks. Includes single series, multiple series, and rolling window implementations against benchmark returns.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.up_capture(returns['a'], benchmark_rets))\n%timeit empyrical.up_capture(big_returns[0], big_benchmark_rets)\n\nprint(returns['a'].vbt.returns.up_capture(benchmark_rets))\n%timeit big_returns[0].vbt.returns.up_capture(big_benchmark_rets)\n\nprint(returns.vbt.returns.up_capture(benchmark_rets))\n%timeit big_returns.vbt.returns.up_capture(big_benchmark_rets)\n\nprint(returns.vbt.returns.rolling_up_capture(benchmark_rets, 3, minp=1))\n%timeit big_returns.vbt.returns.rolling_up_capture(big_benchmark_rets, 3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Comparing Information Ratio Calculations between empyrical and vectorbt\nDESCRIPTION: Compares Information Ratio (excess Sharpe) calculations between empyrical and vectorbt libraries. Demonstrates single series, multiple series, and rolling window calculations with performance benchmarks.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.excess_sharpe(returns['a'], benchmark_rets))\n%timeit empyrical.excess_sharpe(big_returns[0], benchmark_rets)\n\nprint(returns['a'].vbt.returns.information_ratio(benchmark_rets)) # will broadcast\n%timeit big_returns[0].vbt.returns.information_ratio(big_benchmark_rets)\n\nprint(returns.vbt.returns.information_ratio(benchmark_rets))\n%timeit big_returns.vbt.returns.information_ratio(big_benchmark_rets)\n\nprint(returns.vbt.returns.rolling_information_ratio(benchmark_rets, 3, minp=1))\n%timeit big_returns.vbt.returns.rolling_information_ratio(big_benchmark_rets, 3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Performance of Multi-parameter Backtesting in vectorbt\nDESCRIPTION: Timing benchmark for the multi-parameter backtesting function using IPython's %timeit magic command. This demonstrates vectorbt's speed advantage when running thousands of parameter combinations compared to conventional backtesting libraries.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n# How fast is vbt?\n%timeit simulate_mult_from_order_func(periods, uppers, lowers)\n```\n\n----------------------------------------\n\nTITLE: Calculating Average Signal Distance in VectorBT (Python)\nDESCRIPTION: Demonstrates how to calculate the average distance between signals for both single columns and entire dataframes. This measures the typical spacing between True values in the signal array.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.avg_distance())\nprint(entries.vbt.signals.avg_distance())\n\n%timeit big_entries.vbt.signals.avg_distance()\n```\n\n----------------------------------------\n\nTITLE: Measuring Signal Partitions in Python with vectorbt\nDESCRIPTION: Demonstrates how to measure the duration of consecutive True values in a boolean Series using vectorbt's signals module. This function helps analyze the length of signal clusters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> mask_sr = pd.Series([True, True, True, False, True, True])\n>>> mask_sr.vbt.signals.partition_ranges().duration.values\narray([3, 2])\n```\n\n----------------------------------------\n\nTITLE: Creating Indicators with Multiple Inputs\nDESCRIPTION: Shows how to create indicators that take multiple input time series (ts1 and ts2) and process them together with parameters, using both regular Python and Numba-optimized functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n# test multiple inputs\nF = vbt.IndicatorFactory(input_names=['ts1', 'ts2'], param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(lambda ts1, ts2, p: ts1 * ts2 * p)\n      .run(close, high, [0, 1]).out)\nprint(F.from_apply_func(njit(lambda ts1, ts2, p: ts1 * ts2 * p))\n      .run(close, high, [0, 1]).out)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking RPROBCX Performance in VectorBT (Python)\nDESCRIPTION: Compares performance of RPROBCX with different parameter configurations on large datasets, showing the impact of using scalar versus list probability parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_60\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.RPROBCX.run(big_entries, prob=1., seed=42)\n%timeit vbt.RPROBCX.run(big_entries, prob=np.full(10, 1.).tolist(), seed=42)\n```\n\n----------------------------------------\n\nTITLE: Using RPROBCX Chain Mode Signal Generator in VectorBT (Python)\nDESCRIPTION: Demonstrates the RPROBCX generator which creates random chains of entry and exit signals based on probability. This returns both new entries and exits for chain mode operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nrprobcx = vbt.RPROBCX.run(entries, prob=[0., 0.5, 1.], seed=42)\n\nprint(rprobcx.new_entries)\nprint(rprobcx.exits)\n```\n\n----------------------------------------\n\nTITLE: Creating 3D Volume Visualizations with vectorbt\nDESCRIPTION: Demonstrates how to create interactive 3D volume visualizations using vectorbt's plotting module. This example creates a Volume widget with random data and custom axis labels.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> volume_widget = vbt.plotting.Volume(\n...     data=np.random.randint(1, 10, size=(3, 3, 3)),\n...     x_labels=['a', 'b', 'c'],\n...     y_labels=['d', 'e', 'f'],\n...     z_labels=['g', 'h', 'i']\n... )\n>>> volume_widget.fig\n```\n\n----------------------------------------\n\nTITLE: Testing In-Place Outputs with VectorBT IndicatorFactory\nDESCRIPTION: Demonstrates creating and running an indicator with in-place outputs using VectorBT's IndicatorFactory. Tests both regular and JIT-compiled functions with different output settings.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndef apply_func(ts, ts_out, p):\n    ts_out[:, 0] = p\n    return ts * p\n\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['out'], in_output_names=['ts_out'])\nprint(F.from_apply_func(apply_func)\n      .run(close, [0, 1]).ts_out)\n```\n\n----------------------------------------\n\nTITLE: Measuring Performance of vectorbt Backtesting in Python\nDESCRIPTION: Simple timing benchmark for vectorbt's simulation function using IPython's %timeit magic command. This demonstrates the execution speed of the vectorized backtesting approach.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# How fast is vbt?\n%timeit simulate_nb_from_order_func()\n```\n\n----------------------------------------\n\nTITLE: Multiple RANDNX Signal Parameters in VectorBT (Python)\nDESCRIPTION: Shows how to use RANDNX with multiple n parameters to generate different numbers of signals per column. The generator creates the specified number of entry-exit pairs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nrandnx = vbt.RANDNX.run(n=[1, 2, 3], input_shape=(6,), seed=42)\n\nprint(randnx.entries)\nprint(randnx.exits)\n```\n\n----------------------------------------\n\nTITLE: Creating Indicators Without Parameters\nDESCRIPTION: Demonstrates creating indicators that only take input time series without any parameters, effectively creating simple transformations of the input data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# test no params\nF = vbt.IndicatorFactory(input_names=['ts'], output_names=['out'])\nprint(F.from_apply_func(lambda ts: ts)\n      .run(close).out)\nprint(F.from_apply_func(njit(lambda ts: ts))\n      .run(close).out)\n```\n\n----------------------------------------\n\nTITLE: Combining and Concatenating Multiple Data Types with VectorBT\nDESCRIPTION: Demonstrates combining multiple data types and concatenating the results using VectorBT's combine method with concat=True, showing both regular and JIT-compiled functions and custom keys.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_78\n\nLANGUAGE: python\nCODE:\n```\n# Test concat=True\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], pd.Series([10, 20, 30])],\n    10, b=100,\n    combine_func=lambda x, y, a, b=1: x + y + a + b, \n    concat=True,\n    broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], [[10, 20, 30]], pd.Series([10, 20, 30]), df1, df3],\n    10, b=100,\n    combine_func=lambda x, y, a, b=1: x + y + a + b, \n    concat=True,\n    broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], [[10, 20, 30]], pd.Series([10, 20, 30]), df1, df3],\n    10,\n    combine_func=njit(lambda x, y, a, b=1: x + y + a + 100),\n    concat=True,\n    broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], [[10, 20, 30]], pd.Series([10, 20, 30]), df1, df3],\n    10,\n    combine_func=njit(lambda x, y, a, b=1: x + y + a + 100),\n    concat=True,\n    keys=['a', 'b', 'c', 'd', 'e', 'f'],\n    broadcast_kwargs=dict(index_from='stack')))\n```\n\n----------------------------------------\n\nTITLE: Benchmarking RPROBX Performance in VectorBT (Python)\nDESCRIPTION: Compares performance of RPROBX with different parameter configurations on large datasets, showing the impact of using scalar versus list probability parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_58\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.RPROBX.run(big_entries, prob=1., seed=42)\n%timeit vbt.RPROBX.run(big_entries, prob=np.full(10, 1.).tolist(), seed=42)\n```\n\n----------------------------------------\n\nTITLE: Plotting Portfolio Performance for Specific Strategy with vectorbt in Python\nDESCRIPTION: This code shows how to plot the performance of a specific strategy configuration (10-day and 20-day SMA crossover for Ethereum) using vectorbt's plotting capabilities.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/usage.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npf[(10, 20, 'ETH-USD')].plot().show()\n```\n\n----------------------------------------\n\nTITLE: Benchmarking OHLCSTX Performance\nDESCRIPTION: Compares execution times of OHLCSTX with scalar and vector parameters. Tests the performance impact when using multiple stop types (stop-loss, trailing stop, and take-profit) simultaneously.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_69\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.OHLCSTX.run(\\\n    big_entries, big_ts, big_ts + 1, big_ts - 1, big_ts,\\\n    sl_stop=0.1, ts_stop=0.1, tp_stop=0.1)\n%timeit vbt.OHLCSTX.run(\\\n    big_entries, big_ts, big_ts + 1, big_ts - 1, big_ts,\\\n    sl_stop=np.full(10, 0.1).tolist(), ts_stop=np.full(10, 0.1).tolist(), tp_stop=np.full(10, 0.1).tolist())\n```\n\n----------------------------------------\n\nTITLE: Plotting Trend Labels (TRENDLB) in PctChangeNorm Mode\nDESCRIPTION: Visualizes the Trend Labels in PctChangeNorm mode for a single column of the test data with specified positive and negative thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nvbt.TRENDLB.run(close['a'], pos_th=1, neg_th=0.5, mode='PctChangeNorm').plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Applying Functions to DataFrame Indices in VectorBT\nDESCRIPTION: Demonstrates how to apply a function to DataFrame indices along both axes using VectorBT's apply_on_index method, with both in-place and return value options.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nprint(df1.vbt.apply_on_index(lambda idx: idx + '_yo', axis=0))\nprint(df1.vbt.apply_on_index(lambda idx: idx + '_yo', axis=1))\ndf1_copy = df1.copy()\ndf1_copy.vbt.apply_on_index(lambda idx: idx + '_yo', axis=0, inplace=True)\nprint(df1_copy)\ndf1_copy.vbt.apply_on_index(lambda idx: idx + '_yo', axis=1, inplace=True)\nprint(df1_copy)\n```\n\n----------------------------------------\n\nTITLE: Portfolio Analysis using VectorBT\nDESCRIPTION: Analyzes the portfolio using VectorBT's Portfolio class with specified order sizes and fee structure.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/shortcash.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nportfolio = vbt.Portfolio.from_orders(df.close, [np.nan] + size[:-1].tolist(), fees=0.01)\nprint(portfolio.cash(free=False))\nprint(portfolio.value())\n```\n\n----------------------------------------\n\nTITLE: Parameter-Based Indexing with param1_loc\nDESCRIPTION: Demonstrates parameter-based indexing using the param1_loc accessor. Shows how to select data based on the first parameter value using different selection methods (single value, slice, list).\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nprint(h.param1_loc[0.1].a.columns)\nprint(h.param1_loc[0.1:0.1].a)\nprint(h.param1_loc[[0.1, 0.1]].a)\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple OHLCV Plots\nDESCRIPTION: Generates multiple visualization plots for the OHLCV data using vectorbt's plots() method, which creates a comprehensive dashboard of charts.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nohlcv_ts.vbt.ohlcv.plots().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Using Magic Methods with VectorBT Accessors\nDESCRIPTION: Demonstrates how to use magic methods with VectorBT accessors to perform operations with custom broadcasting behavior, enabling operations that would otherwise return NaN values.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_79\n\nLANGUAGE: python\nCODE:\n```\n# Use magic methods with .vbt to do operations with custom broadcasting\nprint(pd.Series([1, 2, 3]).vbt + [1, 2, 3])\nprint(df3.vbt + df4.vbt)  # regular df3 + df4 will return nans\n```\n\n----------------------------------------\n\nTITLE: Using RPROBX Exit Signal Generator in VectorBT (Python)\nDESCRIPTION: Shows how to use the RPROBX generator which creates random exit signals based on provided entry signals. This example demonstrates using different probability values.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nrprobx = vbt.RPROBX.run(entries, prob=[0., 0.5, 1.], seed=42)\n\nprint(rprobx.exits)\n```\n\n----------------------------------------\n\nTITLE: Generating Animated GIF of Bollinger Bands Indicators with vectorbt in Python\nDESCRIPTION: This snippet demonstrates how to create an animated GIF that shows the %B and bandwidth of Bollinger Bands for multiple cryptocurrencies over time using vectorbt and its visualization tools.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/usage.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"BTC-USD\", \"ETH-USD\", \"ADA-USD\"]\nprice = vbt.YFData.download(symbols, period='6mo', missing_index='drop').get('Close')\nbbands = vbt.BBANDS.run(price)\n\ndef plot(index, bbands):\n    bbands = bbands.loc[index]\n    fig = vbt.make_subplots(\n        rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.15,\n        subplot_titles=('%B', 'Bandwidth'))\n    fig.update_layout(template='vbt_dark', showlegend=False, width=750, height=400)\n    bbands.percent_b.vbt.ts_heatmap(\n        trace_kwargs=dict(zmin=0, zmid=0.5, zmax=1, colorscale='Spectral', colorbar=dict(\n            y=(fig.layout.yaxis.domain[0] + fig.layout.yaxis.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=1, col=1), fig=fig)\n    bbands.bandwidth.vbt.ts_heatmap(\n        trace_kwargs=dict(colorbar=dict(\n            y=(fig.layout.yaxis2.domain[0] + fig.layout.yaxis2.domain[1]) / 2, len=0.5\n        )), add_trace_kwargs=dict(row=2, col=1), fig=fig)\n    return fig\n\nvbt.save_animation('bbands.gif', bbands.wrapper.index, plot, bbands, delta=90, step=3, fps=3)\n```\n\n----------------------------------------\n\nTITLE: Installing vectorbt with full dependencies\nDESCRIPTION: Installation command for vectorbt including all optional dependencies.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/installation.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\npip install -U \"vectorbt[full]\"\n```\n\n----------------------------------------\n\nTITLE: Analyzing Distribution of Random Entry-Exit Pairs in vectorbt\nDESCRIPTION: Tests the distribution of randomly generated entry-exit signal pairs. Compares the average positions of signals generated with entry/exit constraints against unconstrained random positions over 10,000 iterations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nn = 10\na = np.full(n * 2, 0.)\nfor i in range(10000):\n    en, ex = pd.Series.vbt.signals.generate_random_both(1000, n, entry_wait=2, exit_wait=2)\n    _a = np.empty((n * 2,), dtype=np.int64)\n    _a[0::2] = np.flatnonzero(en)\n    _a[1::2] = np.flatnonzero(ex)\n    a += _a\nprint(a)\n\nb = np.full(n * 2, 0.)\nfor i in range(10000):\n    b += np.sort(np.random.choice(1000, size=n * 2, replace=False))\nprint(b)\n```\n\n----------------------------------------\n\nTITLE: Plotting Trend Labels (TRENDLB) in BinaryCont Mode\nDESCRIPTION: Visualizes the Trend Labels in BinaryCont mode for a single column of the test data with specified positive and negative thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nvbt.TRENDLB.run(close['a'], pos_th=1, neg_th=0.5, mode='BinaryCont').plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Calculating OHLCV Statistics\nDESCRIPTION: Computes various statistical metrics for the OHLCV data using vectorbt's built-in statistics functionality.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nohlcv_ts.vbt.ohlcv.stats()\n```\n\n----------------------------------------\n\nTITLE: Plotting Signals as Markers in VectorBT (Python)\nDESCRIPTION: Demonstrates how to plot signals as markers on a time series plot using the plot_as_markers method.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nentries['a'].vbt.signals.plot_as_markers(ts).show_svg()\n```\n\n----------------------------------------\n\nTITLE: Plotting Signals as Entry Markers in VectorBT (Python)\nDESCRIPTION: Shows how to plot signals specifically as entry markers on a time series using the plot_as_entry_markers method.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nentries['a'].vbt.signals.plot_as_entry_markers(ts).show_svg()\n```\n\n----------------------------------------\n\nTITLE: Using Breakout Label Generator (BOLB)\nDESCRIPTION: Demonstrates the Breakout Label generator with different window sizes and threshold settings. Includes performance testing for both single and multiple window configurations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.BOLB.run(close, window=1, pos_th=pos_ths, neg_th=neg_ths).labels)\nprint(vbt.BOLB.run(close, window=2, pos_th=pos_ths, neg_th=neg_ths).labels)\n\n%timeit vbt.BOLB.run(big_close, window=2, pos_th=1, neg_th=0.5)\n%timeit vbt.BOLB.run(big_close, window=np.arange(2, 10).tolist(), pos_th=1, neg_th=0.5)\n\nprint(vbt.BOLB.run(big_close, window=np.arange(2, 10).tolist(), pos_th=1, neg_th=0.5).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: RPROBNX with Position-Specific Probabilities in VectorBT (Python)\nDESCRIPTION: Shows how to use RPROBNX with different probability values for each position, allowing precise control over where signals can appear in the time series.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nrprobnx = vbt.RPROBNX.run(\n    entry_prob=np.asarray([1., 0., 1., 0., 1.]), \n    exit_prob=np.asarray([0., 1., 0., 1., 0.]), \n    input_shape=(5,), seed=42)\n\nprint(rprobnx.entries)\nprint(rprobnx.exits)\n```\n\n----------------------------------------\n\nTITLE: Converting Price Data to Percentage Returns\nDESCRIPTION: Uses vectorbt's pct_change method to convert the time series data into percentage returns, which is the standard format for financial analysis tools.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nreturns = ts.vbt.pct_change()\nprint(returns)\n\nbig_returns = big_ts.vbt.pct_change()\n```\n\n----------------------------------------\n\nTITLE: Generating Random Entry-Exit Pairs with Fixed Count in vectorbt\nDESCRIPTION: Creates pairs of entry and exit signals with a specified number of pairs. Demonstrates different configurations for entry and exit waiting periods, with performance benchmarks for various scenarios.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nen, ex = pd.Series.vbt.signals.generate_random_both(5, n=2, seed=42, index=index)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both((5, 3), n=2, seed=42, index=index, columns=columns)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both((5, 3), n=[0, 1, 2], seed=42, index=index, columns=columns)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both((2, 3), n=2, seed=42, entry_wait=1, exit_wait=0)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both((3, 3), n=2, seed=42, entry_wait=0, exit_wait=1)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both((7, 3), n=2, seed=42, entry_wait=2, exit_wait=2)\nprint(en)\nprint(ex)\n\n%timeit pd.DataFrame.vbt.signals.generate_random_both((1000, 1000), n=100)\n%timeit pd.DataFrame.vbt.signals.generate_random_both((1000, 1000), n=100, exit_wait=0)\n```\n\n----------------------------------------\n\nTITLE: Performance Testing on Large OHLCV Dataset\nDESCRIPTION: Creates a large OHLCV dataset with 10,000 rows and measures the time taken to calculate statistics, demonstrating vectorbt's performance on larger datasets using Jupyter's %timeit magic command.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nbig_ohlcv_ts = pd.DataFrame(np.random.uniform(1, 2, (10000, 5)), columns=ohlcv_ts.columns)\n\n%timeit big_ohlcv_ts.vbt.ohlcv.stats()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Random Indicator with IndicatorFactory\nDESCRIPTION: Demonstrates how to create a custom technical indicator using vectorbt's IndicatorFactory, including random data generation and parameter handling.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> @njit\n... def apply_func_nb(input_shape, start, mu, sigma):\n...     rand_returns = np.random.normal(mu, sigma, input_shape)\n...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)\n\n>>> RandomInd = vbt.IndicatorFactory(\n...     param_names=['start', 'mu', 'sigma'],\n...     output_names=['output']\n... ).from_apply_func(\n...     apply_func_nb,\n...     require_input_shape=True,\n...     seed=42\n... )\n\n>>> RandomInd.run(5, [100, 200], [-0.01, 0.01], 0.01).output\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Series and Dataframes in vectorbt\nDESCRIPTION: Shows the broadcasting operations between series and dataframes using the reshape_fns.broadcast function. Creates combinations of series and dataframe arguments and displays the results before and after broadcasting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n# Broadcasting series and dataframes\na_args = [\n    ('sr_none', sr_none),\n    ('sr1', sr1),\n    ('sr2', sr2)\n]\nsr_args = [\n    ('df_none', df_none),\n    ('df1', df1),\n    ('df2', df2),\n    ('df3', df3),\n    ('df4', df4)\n]\narg_combs = list(itertools.product(a_args, sr_args))\n\nfor (n1, arg1), (n2, arg2) in arg_combs:\n    print(n1 + '+' + n2)\n    print(arg1)\n    print(arg2)\n    print(\"================\")\n    arg1, arg2 = reshape_fns.broadcast(arg1, arg2)\n    print(arg1)\n    print(arg2)\n    print()\n```\n\n----------------------------------------\n\nTITLE: Plotting Breakout Labels (BOLB)\nDESCRIPTION: Visualizes the Breakout Labels for a single column of the test data with a window size of 2 and specified positive and negative thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nvbt.BOLB.run(close['a'], window=2, pos_th=1, neg_th=0.5).plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Using Fixed Look-ahead (FIXLB) Label Generator\nDESCRIPTION: Demonstrates the Fixed Look-ahead label generator with different window sizes. Includes performance testing and displays output shape information.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.FIXLB.run(close, n=(2, 3)).labels)\n\n%timeit vbt.FIXLB.run(big_close, n=2)\n%timeit vbt.FIXLB.run(big_close, n=np.arange(2, 10).tolist())\n\nprint(vbt.FIXLB.run(big_close, n=np.arange(2, 10).tolist()).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Results Visualization Setup\nDESCRIPTION: Creates a DataFrame with cross-validation results and configures visualization parameters for plotting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncv_results_df = pd.DataFrame({\n    'in_sample_hold': in_hold_sharpe.values,\n    'in_sample_median': in_sharpe.groupby('split_idx').median().values,\n    'in_sample_best': in_sharpe[in_best_index].values,\n    'out_sample_hold': out_hold_sharpe.values,\n    'out_sample_median': out_sharpe.groupby('split_idx').median().values,\n    'out_sample_test': out_test_sharpe.values\n})\n\ncolor_schema = vbt.settings['plotting']['color_schema']\n\ncv_results_df.vbt.plot(\n    trace_kwargs=[\n        dict(line_color=color_schema['blue']),\n        dict(line_color=color_schema['blue'], line_dash='dash'),\n        dict(line_color=color_schema['blue'], line_dash='dot'),\n        dict(line_color=color_schema['orange']),\n        dict(line_color=color_schema['orange'], line_dash='dash'),\n        dict(line_color=color_schema['orange'], line_dash='dot')\n    ]\n).show_svg()\n```\n\n----------------------------------------\n\nTITLE: Comparing Down Capture Ratio Calculations between empyrical and vectorbt\nDESCRIPTION: Demonstrates Down Capture Ratio calculations in both empyrical and vectorbt libraries with performance benchmarks. Shows implementations for single series, multiple series, and rolling window calculations against benchmark returns.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.down_capture(returns['a'], benchmark_rets))\n#%timeit empyrical.down_capture(big_returns[0], big_benchmark_rets)\n\nprint(returns['a'].vbt.returns.down_capture(benchmark_rets))\n%timeit big_returns[0].vbt.returns.down_capture(big_benchmark_rets)\n\nprint(returns.vbt.returns.down_capture(benchmark_rets))\n%timeit big_returns.vbt.returns.down_capture(big_benchmark_rets)\n\nprint(returns.vbt.returns.rolling_down_capture(benchmark_rets, 3, minp=1))\n%timeit big_returns.vbt.returns.rolling_down_capture(big_benchmark_rets, 3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Generating Random Signals with Probability in vectorbt\nDESCRIPTION: Creates random boolean signals based on a probability parameter rather than a fixed count. Shows both uniform probabilities across all elements and column-specific probabilities with performance benchmarking.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(pd.Series.vbt.signals.generate_random(5, prob=0.5, seed=42, index=index))\nprint(pd.DataFrame.vbt.signals.generate_random((5, 3), prob=0.5, seed=42, index=index, columns=columns))\nprint(pd.DataFrame.vbt.signals.generate_random((5, 3), prob=[0., 0.5, 1], seed=42, index=index, columns=columns))\n\n%timeit pd.DataFrame.vbt.signals.generate_random((1000, 1000), prob=0.5)\n```\n\n----------------------------------------\n\nTITLE: Downloading Historical Stock Data with VectorBT\nDESCRIPTION: Retrieves historical stock data for the trading pair (PEP and KO) from Yahoo Finance using vectorbt's YFData module. The data is filtered to match the specified date range.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n\nstart_date = FROMDATE.replace(tzinfo=pytz.utc)\nend_date = TODATE.replace(tzinfo=pytz.utc)\ndata = vbt.YFData.download([SYMBOL1, SYMBOL2], start=start_date, end=end_date)\ndata = data.loc[(data.wrapper.index >= start_date) & (data.wrapper.index < end_date)]\n```\n\n----------------------------------------\n\nTITLE: Comparing Downside Risk Calculations between empyrical and vectorbt\nDESCRIPTION: Demonstrates downside risk calculations using both empyrical and vectorbt libraries, with performance comparisons. Includes single-column, multiple-column, and rolling window implementations with timing benchmarks.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.downside_risk(returns['b'], required_return=0.1))\n%timeit empyrical.downside_risk(big_returns[0], required_return=0.1)\n\nprint(returns['b'].vbt.returns.downside_risk(required_return=0.1))\n%timeit big_returns[0].vbt.returns.downside_risk(required_return=0.1)\n\nprint(returns.vbt.returns.downside_risk(required_return=0.1))\n%timeit big_returns.vbt.returns.downside_risk(required_return=0.1)\n\nprint(returns.vbt.returns.rolling_downside_risk(3, minp=1, required_return=0.1))\n%timeit big_returns.vbt.returns.rolling_downside_risk(3, minp=1, required_return=0.1)\n```\n\n----------------------------------------\n\nTITLE: Finding First Signals in VectorBT (Python)\nDESCRIPTION: Demonstrates how to find the first signal in each column. Returns a boolean array with True only for the first True value in each column.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nprint(entries.vbt.signals.first())\n\n%timeit big_entries.vbt.signals.first()\n```\n\n----------------------------------------\n\nTITLE: Plotting Look-ahead Extrema (LEXLB) Labels\nDESCRIPTION: Visualizes the Look-ahead Extrema labels for a single column of the test data with specified positive and negative thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nvbt.LEXLB.run(close['a'], pos_th=1, neg_th=0.5).plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Heatmap Implementation\nDESCRIPTION: Shows various heatmap configurations including time series heatmaps\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nheatmap = pd.DataFrame(\n    [[1, 2], [3, 4], [5, 6]], \n    columns=['a', 'b'], \n    index=['x', 'y', 'z']\n).vbt.heatmap(return_fig=False)\nheatmap.fig\n```\n\n----------------------------------------\n\nTITLE: Viewing Order Records from Numba Simulation in Python\nDESCRIPTION: Displays the order records generated from the low-level Numba-based simulation in a readable format for verification.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Print order records in a readable format\nprint(vbt.Orders(vbt_close_price.vbt.wrapper, order_records, vbt_close_price).records_readable)\n```\n\n----------------------------------------\n\nTITLE: Using RANDNX Signal Generator in VectorBT (Python)\nDESCRIPTION: Demonstrates the RANDNX generator which creates random entry and exit signals with a fixed number per column. This example shows the basic usage with a single parameter.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nrandnx = vbt.RANDNX.run(n=1, input_shape=(6,), seed=42)\n\nprint(randnx.entries)\nprint(randnx.exits)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting with Index and Columns from Last Dataframe\nDESCRIPTION: Shows broadcasting of multiple data structures using the index and columns from the last dataframe (-1 parameter). This allows for consistent axis alignment across all broadcasted objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfor i in reshape_fns.broadcast(\n    v1, a1, a2, a3, a4, a5, sr_none, sr1, sr2, df_none, df1, df2, df3, df4,\n    index_from=-1, # take index from the last dataframe\n    columns_from=-1\n):\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Calculating Signal Statistics in VectorBT (Python)\nDESCRIPTION: Shows different ways to calculate and display signal statistics for single columns and entire dataframes. Demonstrates performance for large datasets and using custom settings.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.stats())\n%timeit big_entries[0].vbt.signals.stats(silence_warnings=True)\n\nprint(entries.vbt.signals.stats(column='a'))\n%timeit big_entries.vbt.signals.stats(column=0, silence_warnings=True)\n\nprint(entries.vbt.signals.stats())\n%timeit big_entries.vbt.signals.stats(silence_warnings=True)\n                                      \nprint(entries.vbt.signals.stats(settings=dict(other=~entries)))\n%timeit big_entries.vbt.signals.stats(settings=dict(other=~big_entries), silence_warnings=True)\n```\n\n----------------------------------------\n\nTITLE: Volume Plot Implementation\nDESCRIPTION: Creates 3D volume plots with multiple dimensions and slider controls\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nx, y, z, g = np.mgrid[0:15, 15:25, 25:30, :2]\nvolume_sr = pd.Series(\n    np.random.randint(1, 10, size=x.flatten().shape), \n    index=vbt.base.index_fns.stack_indexes([\n        pd.Index(x.flatten(), name='first'),\n        pd.Index(y.flatten(), name='second'),\n        pd.Index(z.flatten(), name='third'),\n        pd.Index(g.flatten(), name='fourth')\n    ])\n)\nvolume = volume_sr.vbt.volume(x_level='first', y_level='second', z_level='third', return_fig=False)\nvolume.fig\n```\n\n----------------------------------------\n\nTITLE: Creating Bar Plot of Mean Total Returns using vectorbt in Python\nDESCRIPTION: This code snippet uses vectorbt to create a bar plot of mean total returns. It unstacks the mean_return DataFrame and uses the vbt.barplot method to visualize the data. The plot includes customized axis titles and a legend.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/index.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> mean_return.unstack(level=-1).vbt.barplot(\n...     xaxis_title='Split index',\n...     yaxis_title='Mean total return',\n...     legend_title_text='Symbol')\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Group By Operations\nDESCRIPTION: Shows various ways to group columns using different group_by parameters and methods.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(column_grouper.group_by_to_index(some_columns, group_by=0))\nprint(column_grouper.group_by_to_index(some_columns, group_by='first'))\nprint(column_grouper.group_by_to_index(some_columns, group_by=[0, 1]))\nprint(column_grouper.group_by_to_index(some_columns, group_by=['first', 'second']))\nprint(column_grouper.group_by_to_index(some_columns, group_by=np.array([3, 2, 1, 1, 1, 0, 0, 0])))\nprint(column_grouper.group_by_to_index(some_columns, group_by=pd.Index([3, 2, 1, 1, 1, 0, 0, 0], name='fourth')))\n```\n\n----------------------------------------\n\nTITLE: Plotting OHLCV Data with Default Settings\nDESCRIPTION: Plots the OHLCV data using the previously configured default column name mappings, showing that now vectorbt can automatically identify the correct columns.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nohlcv_ts.vbt.ohlcv.plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Setting Default Parameter Values in IndicatorFactory\nDESCRIPTION: Demonstrates how to set default parameter values in IndicatorFactory to simplify function calls and maintain consistent behavior across indicator runs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# test default params\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2), p2=2)\n      .run(close, [0, 1]).out)\nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)), p2=2)\n      .run(close, [0, 1]).out)\n```\n\n----------------------------------------\n\nTITLE: Defining Bollinger Band Analysis Functions\nDESCRIPTION: Implements functions to calculate Bollinger Bands, extract market information, and format messages for Telegram notifications with detailed price and technical indicator data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef get_bbands(data):\n    return vbt.IndicatorFactory.from_talib('BBANDS').run(\n        data.get('Close'), **IND_PARAMS, hide_params=list(IND_PARAMS.keys()))\n\n\ndef get_info(bbands):\n    info = dict()\n    info['last_price'] = bbands.close.iloc[-1]\n    info['last_change'] = (bbands.close.iloc[-1] - bbands.close.iloc[-2]) / bbands.close.iloc[-1]\n    info['last_crossed_above_upper'] = bbands.close_crossed_above(bbands.upperband).iloc[-1]\n    info['last_crossed_below_upper'] = bbands.close_crossed_below(bbands.upperband).iloc[-1]\n    info['last_crossed_below_lower'] = bbands.close_crossed_below(bbands.lowerband).iloc[-1]\n    info['last_crossed_above_lower'] = bbands.close_crossed_above(bbands.lowerband).iloc[-1]\n    info['bw'] = (bbands.upperband - bbands.lowerband) / bbands.middleband\n    info['last_bw_zscore'] = info['bw'].vbt.zscore().iloc[-1]\n    info['last_change_zscore'] = bbands.close.vbt.pct_change().vbt.zscore().iloc[-1]\n    info['last_change_pos'] = info['last_change_zscore'] >= CHANGE_NBDEV\n    info['last_change_neg'] = info['last_change_zscore'] <= -CHANGE_NBDEV\n    return info\n\n\ndef format_symbol_info(symbol, info):\n    last_change = info['last_change'][symbol]\n    last_price = info['last_price'][symbol]\n    last_bw_zscore = info['last_bw_zscore'][symbol]\n    return \"{} ({:.2%}, {}, {:.2f})\".format(symbol, last_change, last_price, last_bw_zscore)\n\n\ndef format_signals_info(emoji, signals, info):\n    symbols = signals.index[signals]\n    symbol_msgs = []\n    for symbol in symbols:\n        symbol_msgs.append(format_symbol_info(symbol, info))\n    return \"{} {}\".format(emoji, ', '.join(symbol_msgs))\n```\n\n----------------------------------------\n\nTITLE: Applying Functions and Concatenating Results with VectorBT\nDESCRIPTION: Demonstrates the apply_and_concat method that applies a function multiple times with different parameters and concatenates the results, with examples of both regular and Numba-accelerated functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_75\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2.vbt.apply_and_concat(3, sr2.values, 10, apply_func=lambda i, x, y, c, d=1: x + y[i] + c + d, d=100))\nprint(sr2.vbt.apply_and_concat(3, sr2.values, 10, apply_func=njit(lambda i, x, y, c: x + y[i] + c + 100)))\nprint(sr2.vbt.apply_and_concat(3, df4.values, 10, apply_func=lambda i, x, y, c, d=1: x + y[:, i] + c + d, d=100))\nprint(sr2.vbt.apply_and_concat(3, df4.values, 10, apply_func=njit(lambda i, x, y, c: x + y[:, i] + c + 100)))\nprint(df4.vbt.apply_and_concat(3, df4.values, 10, apply_func=lambda i, x, y, c, d=1: x + y[:, i] + c + d, d=100))\nprint(df4.vbt.apply_and_concat(\n    3, \n    df4.values, \n    10, \n    apply_func=njit(lambda i, x, y, c: x + y[:, i] + c + 100), \n    keys=pd.Index(['a', 'b', 'c'], name='hello')))\n```\n\n----------------------------------------\n\nTITLE: Forward-Shifting Signals with vectorbt in Python\nDESCRIPTION: Shows how to use the fshift method to shift signals forward by a specified number of periods. Includes a performance benchmark on large-scale data to evaluate computational efficiency.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(entries.vbt.signals.fshift(2))\n\n%timeit big_entries.vbt.signals.fshift(2)\n```\n\n----------------------------------------\n\nTITLE: Calculating Annualized Volatility\nDESCRIPTION: Compares implementations for calculating annualized volatility with custom Levy alpha parameter. Includes performance benchmarking and rolling window volatility calculations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.annual_volatility(returns['a'], alpha=3.))\n%timeit empyrical.annual_volatility(big_returns[0], alpha=3.)\n\nprint(returns['a'].vbt.returns.annualized_volatility(levy_alpha=3.))\n%timeit big_returns[0].vbt.returns.annualized_volatility(levy_alpha=3.)\n\nprint(returns.vbt.returns.annualized_volatility(levy_alpha=3.))\n%timeit big_returns.vbt.returns.annualized_volatility(levy_alpha=3.)\n\nprint(returns.vbt.returns.rolling_annualized_volatility(3, minp=1, levy_alpha=3.))\n%timeit big_returns.vbt.returns.rolling_annualized_volatility(3, minp=1, levy_alpha=3.)\n```\n\n----------------------------------------\n\nTITLE: Plotting Signals in VectorBT (Python)\nDESCRIPTION: Demonstrates basic signal visualization using the plot method on signal data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nentries.vbt.signals.plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Broadcasting to Array of Series\nDESCRIPTION: Demonstrates broadcasting values to match the shape of a series. Shows examples with scalar, single-element list, and multi-element lists or arrays broadcasting to series dimensions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.broadcast_to_array_of(0.1, sr2))\nprint(reshape_fns.broadcast_to_array_of([0.1], sr2))\nprint(reshape_fns.broadcast_to_array_of([0.1, 0.2], sr2))\nprint(reshape_fns.broadcast_to_array_of([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], sr2))\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Updates with Custom Updater\nDESCRIPTION: Demonstrates how to create a custom data updater class for periodic data updates with vectorbt.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> class MyDataUpdater(vbt.DataUpdater):\n...     def update(self, count_limit=None):\n...         prev_index_len = len(self.data.wrapper.index)\n...         super().update()\n...         new_index_len = len(self.data.wrapper.index)\n...         print(f\"Data updated with {new_index_len - prev_index_len} data points\")\n\n>>> data = vbt.GBMData.download('SYMBOL', start='1 minute ago', freq='1s')\n>>> my_updater = MyDataUpdater(data)\n>>> my_updater.update_every(5, 'seconds')\n```\n\n----------------------------------------\n\nTITLE: Running Backtest with Short Cash Enabled\nDESCRIPTION: Executes the trading strategy simulation with short cash enabled and retrieves analysis results.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/shortcash.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nstrategy = bt_simulate(True)\nstrategy.analyzers.cashvalueanalyzer.get_analysis()\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Indexing Performance on Large DataFrames\nDESCRIPTION: Measures and compares the performance of different indexing operations across wrapper types. Uses IPython's %timeit magic to benchmark column selection versus full selection on different wrapper configurations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n%timeit big_df_wrapper.iloc[:, 0]\n%timeit big_df_wrapper.iloc[:, :]\n\n%timeit big_df_wrapper_co.iloc[0]\n%timeit big_df_wrapper_co.iloc[:]\n\n%timeit big_df_grouped_wrapper.iloc[:, 0]\n%timeit big_df_grouped_wrapper.iloc[:, :]\n\n%timeit big_df_grouped_wrapper_co.iloc[0]\n%timeit big_df_grouped_wrapper_co.iloc[:]\n```\n\n----------------------------------------\n\nTITLE: Benchmarking RANDNX Performance in VectorBT (Python)\nDESCRIPTION: Compares performance of RANDNX with different parameter configurations on large datasets, showing the impact of using array versus list parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_52\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.RANDNX.run(n=100, input_shape=(1000, 1000), seed=42)\n%timeit vbt.RANDNX.run(n=np.full(10, 100).tolist(), input_shape=(1000, 1000), seed=42)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Multiple Data Types with Stacked Indices\nDESCRIPTION: Shows broadcasting of various data types (vector, arrays, series, dataframes) with index and columns created by stacking from all the input objects. This demonstrates the flexibility of vectorbt's broadcasting function.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n# Broadcasting all at once\nfor i in reshape_fns.broadcast(\n    v1, a1, a2, a3, a4, a5, sr_none, sr1, sr2, df_none, df1, df2, df3, df4,\n    index_from='stack',\n    columns_from='stack'\n):\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Creating Chain Mode Signal Factory in VectorBT (Python)\nDESCRIPTION: Demonstrates creating a signal factory in 'chain' mode where entries and exits form a continuous chain. This mode is useful for strategies where each exit becomes a new entry point.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nMySignals = vbt.SignalFactory(\n    input_names=['ts2'],\n    in_output_names=['in_out2'],\n    param_names=['n2'],\n    mode='chain'\n).from_choice_func(\n    exit_choice_func=choice_nb,\n    exit_settings=dict(\n        pass_inputs=['ts2'],\n        pass_in_outputs=['in_out2'],\n        pass_params=['n2'],\n        pass_kwargs=['temp_idx_arr2', ('kw2', 1000)]\n    ),\n    in_output_settings=dict(\n        in_out2=dict(\n            dtype=np.float64\n        )\n    ),\n    in_out2=np.nan, \n    var_args=True\n)\ne = np.array([True, True, True, True, True])\nmy_sig = MySignals.run(e, np.arange(5), [1, 0], 100)\nprint(my_sig.entries)\nprint(my_sig.new_entries)\nprint(my_sig.exits)\nprint(my_sig.in_out2)\nmy_sig[0].plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Sample Rolling Function Definition\nDESCRIPTION: Defines a function to create rolling in-sample and out-of-sample data splits for backtesting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef roll_in_and_out_samples(price, **kwargs):\n    return price.vbt.rolling_split(**kwargs)\n```\n\n----------------------------------------\n\nTITLE: Creating Indicators Using Input Shape Information\nDESCRIPTION: Shows how to create indicators that use input shape, index, and columns information without actual input data, demonstrating shape-based array generation with custom dimensions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# test no inputs with input_shape, input_index and input_columns\nF = vbt.IndicatorFactory(param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(lambda input_shape, p: np.full(input_shape, p), require_input_shape=True)\n      .run((5,), 0).out)\nprint(F.from_apply_func(njit(lambda input_shape, p: np.full(input_shape, p)), require_input_shape=True)\n      .run((5,), 0).out)\n\nprint(F.from_apply_func(lambda input_shape, p: np.full(input_shape, p), require_input_shape=True)\n      .run((5,), [0, 1]).out)\nprint(F.from_apply_func(njit(lambda input_shape, p: np.full(input_shape, p)), require_input_shape=True)\n      .run((5,), [0, 1]).out)\n\nprint(F.from_apply_func(lambda input_shape, p: np.full(input_shape, p), require_input_shape=True)\n      .run((5, 3), [0, 1], input_index=close.index, input_columns=close.columns).out)\nprint(F.from_apply_func(njit(lambda input_shape, p: np.full(input_shape, p)), require_input_shape=True)\n      .run((5, 3), [0, 1], input_index=close.index, input_columns=close.columns).out)\n```\n\n----------------------------------------\n\nTITLE: Running Backtest without Short Cash\nDESCRIPTION: Executes the trading strategy simulation with short cash disabled and retrieves analysis results.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/shortcash.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nstrategy = bt_simulate(False)\nstrategy.analyzers.cashvalueanalyzer.get_analysis()\n```\n\n----------------------------------------\n\nTITLE: Viewing Order Records from Portfolio Simulation in Python\nDESCRIPTION: Displays the order records generated from the pair trading simulation in a readable format, showing entry/exit points for the strategy.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt_pf2.orders.records_readable)\n```\n\n----------------------------------------\n\nTITLE: Calculating Deflated Sharpe Ratio\nDESCRIPTION: Demonstrates vectorbt's implementation of the deflated Sharpe ratio with custom risk-free rate, a metric that adjusts the Sharpe ratio for multiple testing bias. Performance is benchmarked on large datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nprint(returns.vbt.returns.deflated_sharpe_ratio(risk_free=0.01))\n%timeit big_returns.vbt.returns.deflated_sharpe_ratio(risk_free=0.01)\n```\n\n----------------------------------------\n\nTITLE: Using Mean Look-ahead (MEANLB) Label Generator\nDESCRIPTION: Demonstrates the Mean Look-ahead label generator with various window sizes and EWM options. Includes performance testing and shows output shape.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.MEANLB.run(close, window=(2, 3), ewm=(False, True), param_product=True).labels)\n\n%timeit vbt.MEANLB.run(big_close, window=2)\n%timeit vbt.MEANLB.run(big_close, window=np.arange(2, 10).tolist())\n\nprint(vbt.MEANLB.run(big_close, window=np.arange(2, 10).tolist()).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Parameters to Input Size\nDESCRIPTION: Demonstrates how to use the bc_to_input parameter setting to broadcast parameter values to match input dimensions, useful for element-wise operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n# test param_settings bc_to_input\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2), \n                        param_settings={'p1': {'is_array_like': True, 'bc_to_input': True}})\n      .run(close, np.asarray([0, 1, 2]), np.asarray([2, 3])).out) \nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)), \n                        param_settings={'p1': {'is_array_like': True, 'bc_to_input': True}})\n      .run(close, np.asarray([0, 1, 2]), np.asarray([2, 3])).out)\n```\n\n----------------------------------------\n\nTITLE: Using Logical OR with Multiple Signals in VectorBT (Python)\nDESCRIPTION: Demonstrates the OR method for combining multiple signal arrays. Shows both basic usage and usage with concatenation to preserve individual signal identities.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nprint(entries.vbt.signals.OR([ts > 1, ts > 2, ts > 3])) # you can pass multiple arguments\nprint(entries.vbt.signals.OR([ts > 1, ts > 2, ts > 3], concat=True, keys=['>1', '>2', '>3']))\n```\n\n----------------------------------------\n\nTITLE: Creating Symmetric Data with VectorBT\nDESCRIPTION: Shows how to create symmetric Series and DataFrames (with equal row and column counts) using VectorBT's make_symmetric method.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2.vbt.make_symmetric())\nprint(df2.vbt.make_symmetric())\nprint(df3.vbt.make_symmetric())\nprint(df4.vbt.make_symmetric())\n```\n\n----------------------------------------\n\nTITLE: Filtering Time Series Data for Trading Hours in Python\nDESCRIPTION: Filters the price data to only include entries during trading hours (9:00 AM to 5:00 PM). This step removes any data points outside of standard trading sessions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Remove dates that are outside of trading sessions\nsession_price_idx = filled_price.between_time('9:00', '17:00', include_end=False).index\nsession_price = filled_price.loc[session_price_idx]\nprint(session_price)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking RPROBNX Performance in VectorBT (Python)\nDESCRIPTION: Compares performance of RPROBNX with different parameter configurations on large datasets, showing the impact of using scalar versus list parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_56\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.RPROBNX.run(entry_prob=1., exit_prob=1., input_shape=(1000, 1000), seed=42)\n%timeit vbt.RPROBNX.run(\\\n    entry_prob=np.full(10, 1.).tolist(), exit_prob=np.full(10, 1.).tolist(), \\\n    input_shape=(1000, 1000), seed=42)\n```\n\n----------------------------------------\n\nTITLE: Starting the Telegram Bot\nDESCRIPTION: Initializes the custom Telegram bot with the downloaded cryptocurrency data and starts it in the background to handle user interactions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntelegram_bot = MyTelegramBot(data)\ntelegram_bot.start(in_background=True)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Arrays and Dataframes in vectorbt\nDESCRIPTION: Demonstrates the broadcasting of arrays and dataframes using vectorbt's reshape_fns.broadcast function. The code creates various combinations of array and dataframe arguments and shows the before/after results of broadcasting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n# Broadcasting arrays and dataframes\na_args = [\n    ('v1', v1),\n    ('a1', a1),\n    ('a2', a2),\n    ('a3', a3),\n    ('a4', a4),\n    ('a5', a5)\n]\nsr_args = [\n    ('df_none', df_none),\n    ('df1', df1),\n    ('df2', df2),\n    ('df3', df3),\n    ('df4', df4)\n]\narg_combs = list(itertools.product(a_args, sr_args))\n\nfor (n1, arg1), (n2, arg2) in arg_combs:\n    print(n1 + '+' + n2)\n    print(arg1)\n    print(arg2)\n    print(\"================\")\n    arg1, arg2 = reshape_fns.broadcast(arg1, arg2)\n    print(arg1)\n    print(arg2)\n    print()\n```\n\n----------------------------------------\n\nTITLE: Plotting Signals as Exit Markers in VectorBT (Python)\nDESCRIPTION: Demonstrates how to plot signals as exit markers on a time series using the plot_as_exit_markers method.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nentries['a'].vbt.signals.plot_as_exit_markers(ts).show_svg()\n```\n\n----------------------------------------\n\nTITLE: Benchmarking STCX Performance\nDESCRIPTION: Compares execution times of STCX with different parameter formats. Similar to the STX benchmark, this measures the performance impact of using scalar versus vector parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_66\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.STCX.run(big_entries, big_ts, 0.1)\n%timeit vbt.STCX.run(big_entries, big_ts, np.full(10, 0.1).tolist())\n```\n\n----------------------------------------\n\nTITLE: Using Trend Label Generator (TRENDLB) in BinaryContSat Mode\nDESCRIPTION: Demonstrates the Trend Label generator with BinaryContSat mode, using various positive and negative thresholds. Includes performance testing and output shape information.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.TRENDLB.run(close, pos_th=pos_ths, neg_th=neg_ths, mode='BinaryContSat').labels)\n\n%timeit vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='BinaryContSat')\n\nprint(vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='BinaryContSat').wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Testing Year Frequency Configuration\nDESCRIPTION: Demonstrates how to access and configure the year frequency parameter in vectorbt, which is used for annualized calculations. Shows both the default and custom settings.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Test year frequency\nprint(returns.vbt.returns.year_freq)\nprint(returns['a'].vbt.returns.year_freq)\nprint(returns.vbt.returns(year_freq='252 days').year_freq)\nprint(returns['a'].vbt.returns(year_freq='252 days').year_freq)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Data with VectorBT\nDESCRIPTION: Demonstrates different ways to broadcast data using VectorBT's broadcast methods, including broadcasting a Series to a scalar, and a Series to a DataFrame.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_69\n\nLANGUAGE: python\nCODE:\n```\nprint(pd.DataFrame.vbt.broadcast(\n    sr2,\n    10\n))\nprint(sr2.vbt.broadcast(\n    10\n))\nprint(sr2.vbt.broadcast_to(\n    df2\n))\n```\n\n----------------------------------------\n\nTITLE: Generating Sample Price Data with Pandas in Python\nDESCRIPTION: Creates a sample hourly price series using random values with a fixed seed for reproducibility. The data spans 48 hours starting from January 1, 2018.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Generate sample price\nprice_idx = pd.date_range('2018-01-01 12:00:00', periods=48, freq='H')\nnp.random.seed(42)\nprice = pd.Series(np.random.uniform(size=price_idx.shape), index=price_idx)\nprint(price)\n```\n\n----------------------------------------\n\nTITLE: Generating Chained OHLC Stop Exits in VectorBT (Python)\nDESCRIPTION: Shows how to generate chained stop exits where entries and exits are paired in a chain. This approach returns both the entries and exits signals along with stop prices and types.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n(en, ex), stop_price, stop_type = test_ohlc_stop_exits(sl_stop=0.1, sl_trail=True, tp_stop=0.1, chain=True)\nprint(en)\nprint(ex)\nprint(stop_price)\nprint(stop_type)\n\n%timeit big_entries.vbt.signals.generate_ohlc_stop_exits(\\\n    big_ts, big_ts + 1, big_ts - 1, big_ts, sl_stop=0.1, sl_trail=True, tp_stop=0.1, chain=True)\n```\n\n----------------------------------------\n\nTITLE: Using combine_and_concat Functions in VectorBT\nDESCRIPTION: Demonstrates combine_and_concat functions that combine arrays element-wise with a function and concatenate the results. Examples show both regular and Numba JIT-compiled versions with Series and DataFrame inputs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nprint(combine_fns.combine_and_concat(sr2.values, (sr2.values*2, sr2.values*3), lambda x, y, a: x + y + a, 100))\nprint(combine_fns.combine_and_concat_nb(sr2.values, (sr2.values*2, sr2.values*3), njit(lambda x, y, a: x + y + a), 100))\n\nprint(combine_fns.combine_and_concat(df4.values, (df4.values*2, df4.values*3), lambda x, y, a: x + y + a, 100))\nprint(combine_fns.combine_and_concat_nb(df4.values, (df4.values*2, df4.values*3), njit(lambda x, y, a: x + y + a), 100))\n```\n\n----------------------------------------\n\nTITLE: Plotting Single Column Signals in VectorBT (Python)\nDESCRIPTION: Shows how to plot signals from a single column using the plot method.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nentries['a'].vbt.signals.plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Benchmarking OHLCSTCX Performance\nDESCRIPTION: Measures execution times of OHLCSTCX with different parameter formats. Similar to other benchmarks, this compares performance between scalar and vector parameters for all stop types.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_71\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.OHLCSTCX.run(\\\n    big_entries, big_ts, big_ts + 1, big_ts - 1, big_ts,\\\n    sl_stop=0.1, ts_stop=0.1, tp_stop=0.1)\n%timeit vbt.OHLCSTCX.run(\\\n    big_entries, big_ts, big_ts + 1, big_ts - 1, big_ts,\\\n    sl_stop=np.full(10, 0.1).tolist(), ts_stop=np.full(10, 0.1).tolist(), tp_stop=np.full(10, 0.1).tolist())\n```\n\n----------------------------------------\n\nTITLE: Configuring Default OHLCV Column Names in vectorbt Settings\nDESCRIPTION: Shows how to update the global vectorbt settings to define default column names for OHLCV data, which simplifies future operations on OHLCV DataFrames.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Or by changing the defaults\nvbt.settings.ohlcv['column_names'] = {\n    'open': 'open', \n    'high': 'high', \n    'low': 'low', \n    'close': 'close', \n    'volume': 'volume'\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Backtesting Parameters\nDESCRIPTION: Sets up configuration parameters for data splitting and portfolio analysis, including window sizes and trading direction.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsplit_kwargs = dict(\n    n=30, \n    window_len=365 * 2, \n    set_lens=(180,), \n    left_to_right=False\n)  # 30 windows, each 2 years long, reserve 180 days for test\npf_kwargs = dict(\n    direction='both',  # long and short\n    freq='d'\n)\nwindows = np.arange(10, 50)\n```\n\n----------------------------------------\n\nTITLE: Creating Large Dataset for Performance Testing\nDESCRIPTION: Generates a large random dataset (1000x1000) with price data for performance testing indicators at scale. Includes high, low, and volume data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbig_close = pd.DataFrame(np.random.randint(10, size=(1000, 1000)).astype(float))\nbig_close.index = [datetime(2018, 1, 1) + timedelta(days=i) for i in range(1000)]\nbig_high = big_close * np.random.uniform(1, 1.1, size=big_close.shape)\nbig_low = big_close * np.random.uniform(0.9, 1, size=big_close.shape)\nbig_volume = big_close * 0 + np.random.randint(10, 100, size=big_close.shape).astype(float)\n```\n\n----------------------------------------\n\nTITLE: Filling Missing Dates in Time Series Data with Python\nDESCRIPTION: Reindexes the price series to include all hourly data points between the first and last date, filling in any missing hours. This ensures a continuous time series for further processing.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Sessions must be equal - fill missing dates\n# Fill on first date before 12:00 and on last date after 11:00\nfirst_date = price.index[0].date()\nlast_date = price.index[-1].date()+timedelta(days=1)\nfilled_idx = pd.date_range(first_date, last_date, freq='H')\nfilled_price = price.reindex(filled_idx)\nprint(filled_price)\n```\n\n----------------------------------------\n\nTITLE: Combining Data with Custom Functions in VectorBT\nDESCRIPTION: Shows how to combine a Series with various other data types using VectorBT's combine method with custom combine functions and broadcasting options.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_76\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2.vbt.combine(10., combine_func=lambda x, y: x + y))\nprint(sr2.vbt.combine(10, 100, d=1000, combine_func=lambda x, y, c, d=1: x + y + c + d)) # test args and kwargs\nprint(sr2.vbt.combine(np.array([10, 20, 30]), combine_func=lambda x, y: x + y))\nprint(sr2.vbt.combine(np.array([[10, 20, 30]]), combine_func=lambda x, y: x + y))\nprint(sr2.vbt.combine(sr1, combine_func=lambda x, y: x + y, broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(sr2, combine_func=lambda x, y: x + y, broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(df2, combine_func=lambda x, y: x + y, broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(df3, combine_func=lambda x, y: x + y, broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(df4, combine_func=lambda x, y: x + y, broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(df5, combine_func=lambda x, y: x + y, broadcast_kwargs=dict(index_from='stack')))\n```\n\n----------------------------------------\n\nTITLE: Calculating Average Distance to Another Signal in VectorBT (Python)\nDESCRIPTION: Shows how to calculate the average distance to another signal using the avg_distance method with the 'to' parameter. This allows measuring distances between different signal sets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.avg_distance(to=entries['a'].vbt.signals.fshift(1)))\nprint(entries.vbt.signals.avg_distance(to=entries.vbt.signals.fshift(1)))\n\n%timeit big_entries.vbt.signals.avg_distance(to=big_entries.vbt.signals.fshift(1))\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Pandas Objects with vectorbt\nDESCRIPTION: Shows how vectorbt improves upon pandas' broadcasting capabilities when working with Series and DataFrames, providing more intuitive results for array operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> sr = pd.Series([1, 2, 3], index=['x', 'y', 'z'])\n>>> df = pd.DataFrame([[4, 5, 6]], index=['x', 'y', 'z'], columns=['a', 'b', 'c'])\n\n# pandas\n>>> sr + df\n    a   b   c   x   y   z\nx NaN NaN NaN NaN NaN NaN\ny NaN NaN NaN NaN NaN NaN\nz NaN NaN NaN NaN NaN NaN\n\n# vectorbt\n>>> sr.vbt + df\n   a  b  c\nx  5  6  7\ny  6  7  8\nz  7  8  9\n```\n\n----------------------------------------\n\nTITLE: Importing Core Python Libraries for Data Analysis and Financial Analysis\nDESCRIPTION: Imports essential Python libraries for data manipulation (numpy, pandas), datetime handling, collections management, and mathematical operations required for financial analysis.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nimport datetime\nimport collections\nimport math\nimport pytz\n```\n\n----------------------------------------\n\nTITLE: Creating NumPy Arrays for Signal Testing in Python\nDESCRIPTION: Initializes NumPy arrays with random integer values between -1 and 1. Creates both small example arrays and large arrays to test the performance of signal generation functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\na = np.random.randint(-1, 2, size=(5, 3))\nprint(a.shape)\n\nbig_a = np.random.randint(-1, 2, size=(1000, 1000))\nprint(big_a.shape)\n```\n\n----------------------------------------\n\nTITLE: Creating Benchmark Returns for Comparison\nDESCRIPTION: Generates benchmark return series by applying random multipliers to existing returns. This creates correlated but different return streams for comparative analysis.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnp.random.seed(42)\nbenchmark_rets = returns['a'] * np.random.uniform(0.8, 1.2, returns.shape[0])\nbig_benchmark_rets = big_returns[0] * np.random.uniform(0.8, 1.2, big_returns.shape[0])\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for VectorBT in Python\nDESCRIPTION: Imports necessary Python libraries for data manipulation (pandas, numpy), datetime handling, and the VectorBT library for backtesting trading strategies.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TradingSessions.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport numpy as np\nimport vectorbt as vbt\nfrom datetime import timedelta\n```\n\n----------------------------------------\n\nTITLE: Generating Random Entry-Exit Pairs with Probability in vectorbt\nDESCRIPTION: Creates entry-exit signal pairs based on probability rather than fixed count. Shows examples with uniform probabilities and column-specific probabilities, with performance benchmarks for large datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nen, ex = pd.Series.vbt.signals.generate_random_both(\n    5, entry_prob=0.5, exit_prob=1., seed=42, index=index)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both(\n    (5, 3), entry_prob=0.5, exit_prob=1., seed=42, index=index, columns=columns)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both(\n    (5, 3), entry_prob=[0., 0.5, 1.], exit_prob=[0., 0.5, 1.], seed=42, index=index, columns=columns)\nprint(en)\nprint(ex)\nen, ex = pd.DataFrame.vbt.signals.generate_random_both(\n    (5, 3), entry_prob=1., exit_prob=1., seed=42, index=index, columns=columns, exit_wait=0)\nprint(en)\nprint(ex)\n\n%timeit pd.DataFrame.vbt.signals.generate_random_both(\\\n    (1000, 1000), entry_prob=1., exit_prob=1.)\n```\n\n----------------------------------------\n\nTITLE: Portfolio Cash and Value Analysis\nDESCRIPTION: Prints the portfolio's free cash and total value calculations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/shortcash.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(portfolio.cash(free=True))\nprint(portfolio.value())\n```\n\n----------------------------------------\n\nTITLE: Calculating Signal Totals in VectorBT (Python)\nDESCRIPTION: Shows how to calculate the total number of signals in both a single column and across all columns. The example compares performance for a large dataset.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.total())\nprint(entries.vbt.signals.total())\n\n%timeit big_entries.vbt.signals.total()\n```\n\n----------------------------------------\n\nTITLE: Broadcasting with As-Is Index and Column Parameters\nDESCRIPTION: Demonstrates broadcasting various data types while preserving original index and column structures. Setting index_from and columns_from to None maintains the original axes when possible.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfor i in reshape_fns.broadcast(\n    v1, a1, a2, a3, a4, a5, sr_none, sr1, sr2, df_none, df1, df2, df3, df4,\n    index_from=None, # use as-is\n    columns_from=None\n):\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries\nDESCRIPTION: Imports necessary Python packages including numpy, pandas, and vectorbt for data analysis and backtesting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/WalkForwardOptimization.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nimport vectorbt as vbt\n```\n\n----------------------------------------\n\nTITLE: Creating Time Series Data for Testing\nDESCRIPTION: Creates a simple time series dataset for testing indicators with a single asset over seven days, including high, low, and volume data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclose_ts = pd.Series([1, 2, 3, 4, 3, 2, 1], index=pd.DatetimeIndex([\n    datetime(2018, 1, 1),\n    datetime(2018, 1, 2),\n    datetime(2018, 1, 3),\n    datetime(2018, 1, 4),\n    datetime(2018, 1, 5),\n    datetime(2018, 1, 6),\n    datetime(2018, 1, 7)\n]))\nhigh_ts = close_ts * 1.1\nlow_ts = close_ts * 0.9\nvolume_ts = pd.Series([4, 3, 2, 1, 2, 3, 4], index=close_ts.index)\n```\n\n----------------------------------------\n\nTITLE: Accessing Wrapper Properties in VectorBT\nDESCRIPTION: Shows how to access the wrapper object properties in VectorBT to get index and columns information from Series and DataFrames.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2.vbt.wrapper.index)\nprint(sr2.vbt.wrapper.columns)\nprint(df4.vbt.wrapper.index)\nprint(df4.vbt.wrapper.columns)\n```\n\n----------------------------------------\n\nTITLE: Stacking Multiple Indices\nDESCRIPTION: Examples of stacking different indices together with various options for handling duplicates.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ni23 = index_fns.stack_indexes((i2, i3))\ni32 = index_fns.stack_indexes((i3, i2))\n\nprint(i23)\nprint(i32)\n\nprint(index_fns.stack_indexes((multi_i, multi_i), drop_duplicates=False))\nprint(index_fns.stack_indexes((multi_i, multi_i), drop_duplicates=True))\nprint(index_fns.stack_indexes(([0, 1], ['a', 'b']), drop_redundant=False))\nprint(index_fns.stack_indexes(([0, 1], ['a', 'b']), drop_redundant=True))\nprint(index_fns.stack_indexes((pd.Index([0, 1], name='test_name'), ['a', 'b']), drop_redundant=True))\nprint(index_fns.stack_indexes((['a', 'a'], ['a', 'b']), drop_redundant=True))\nprint(index_fns.stack_indexes((pd.Index(['a', 'a'], name='test_name'), ['a', 'b']), drop_redundant=True))\n```\n\n----------------------------------------\n\nTITLE: Creating Parameter Products for Exhaustive Testing\nDESCRIPTION: Shows how to generate the Cartesian product of parameter values using param_product=True, allowing for exhaustive testing of parameter combinations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# test param product\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2))\n      .run(close, [0, 1], [2, 3], param_product=True).out) \nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)))\n      .run(close, [0, 1], [2, 3], param_product=True).out)\n```\n\n----------------------------------------\n\nTITLE: Aligning DataFrames with VectorBT\nDESCRIPTION: Shows how to align one DataFrame to another's structure using VectorBT's align_to method, particularly useful for multi-index columns.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_68\n\nLANGUAGE: python\nCODE:\n```\ndf10 = pd.DataFrame([[1, 2], [4, 5], [7, 8]], columns=multi_c1)\ndf20 = pd.DataFrame([[1, 2, 3, 4], [4, 5, 6, 7], [7, 8, 9, 10]], columns=multi_c2)\n\nprint(df10)\nprint(df20)\nprint(df10.vbt.align_to(df20))\n```\n\n----------------------------------------\n\nTITLE: Mapping Between Signals with Custom Targets in VectorBT (Python)\nDESCRIPTION: Shows how to use map_reduce_between with a custom target signal (shifted entries) to calculate distances between specific signal pairs. Similar to the basic version but with an explicitly specified 'other' parameter.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nprint(entries.vbt.signals.map_reduce_between(\n    other=entries.vbt.signals.fshift(1), \n    range_map_func_nb=distance_map_nb, \n    reduce_func_nb=avg_reduce_nb))\n\n%timeit big_entries.vbt.signals.map_reduce_between(\\\n    other=big_entries.vbt.signals.fshift(1),\\\n    range_map_func_nb=distance_map_nb,\\\n    reduce_func_nb=avg_reduce_nb)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting with Custom Column Cleaning Settings\nDESCRIPTION: Demonstrates broadcasting with modified column cleaning behavior by changing vectorbt settings. Disables dropping duplicates, redundant columns, and ignoring series names during the broadcast operation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n# Do not clean columns\nvbt.settings.broadcasting['drop_duplicates'] = False\nvbt.settings.broadcasting['drop_redundant'] = False\nvbt.settings.broadcasting['ignore_sr_names'] = False\n\nfor i in reshape_fns.broadcast(\n    v1, a1, a2, a3, a4, a5, sr_none, sr1, sr2, df_none, df1, df2, df3, df4,\n    index_from='stack', # stack but do not clean\n    columns_from='stack'\n):\n    print(i)\n    \nvbt.settings.broadcasting.reset()\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for Data Analysis\nDESCRIPTION: Imports necessary libraries for data analysis including NumPy, Pandas, datetime handling, Numba for performance optimization, and technical analysis libraries.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom numba import njit\nimport itertools\nimport talib\nimport ta\n```\n\n----------------------------------------\n\nTITLE: Bar Plot Implementation\nDESCRIPTION: Demonstrates creation and updating of bar plots with multiple series\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nbar = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=['a', 'b']).vbt.barplot(return_fig=False)\nbar.fig\n\nbar.update([[7, 8], [9, 10], [11, 12]])\n\nbar1 = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=['a', 'b']).vbt.barplot(return_fig=False)\nbar2 = pd.DataFrame([[7, 8], [9, 10], [11, 12]], columns=['c', 'd']).vbt.barplot(return_fig=False, fig=bar1.fig)\nbar2.fig\n```\n\n----------------------------------------\n\nTITLE: Running STCX with Mixed Stop Configurations\nDESCRIPTION: Executes the STCX (Stop-based Exit with Re-entry) indicator with various stop levels and trailing options. This indicator extends STX by allowing positions to be re-entered after an exit.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_65\n\nLANGUAGE: python\nCODE:\n```\nstcx = vbt.STCX.run(entries, ts, [0.1, 0.1, -0.1, -0.1], trailing=[False, True, False, True])\n\nprint(stcx.new_entries)\nprint(stcx.exits)\n```\n\n----------------------------------------\n\nTITLE: Unstacking to Array with VectorBT\nDESCRIPTION: Demonstrates how to unstack a DataFrame column to a NumPy array using VectorBT's unstack_to_array method, useful for multi-level index transformation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_71\n\nLANGUAGE: python\nCODE:\n```\nprint(df5.iloc[:, 0].vbt.unstack_to_array())\n```\n\n----------------------------------------\n\nTITLE: Broadcasting with NumPy vs Pandas Output Control\nDESCRIPTION: Demonstrates the difference between broadcasting with to_pd=False (NumPy output) and to_pd=True (pandas output). Shows how the to_pd parameter controls the type of returned objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.broadcast(v1, df4, to_pd=False))\nprint(reshape_fns.broadcast(v1, df4, to_pd=True))\n```\n\n----------------------------------------\n\nTITLE: Using Trend Label Generator (TRENDLB) in BinaryCont Mode\nDESCRIPTION: Demonstrates the Trend Label generator with BinaryCont mode, using various positive and negative thresholds. Includes performance testing and output shape information.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.TRENDLB.run(close, pos_th=pos_ths, neg_th=neg_ths, mode='BinaryCont').labels)\n\n%timeit vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='BinaryCont')\n\nprint(vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='BinaryCont').wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Signal Structures with vectorbt in Python\nDESCRIPTION: Demonstrates how to generate empty Series and DataFrame signals with specified shapes, indices, and columns. Includes a performance benchmark for creating large empty signal DataFrames.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nprint(pd.Series.vbt.signals.empty(5, index=index))\nprint(pd.DataFrame.vbt.signals.empty((5, 3), index=index, columns=columns))\n\n%timeit pd.DataFrame.vbt.signals.empty((1000, 1000))\n```\n\n----------------------------------------\n\nTITLE: Converting Returns to Annual Frequency\nDESCRIPTION: Shows how to annualize returns using the annual() method. Performance is benchmarked on large datasets using the Jupyter %timeit magic command.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nprint(returns['a'].vbt.returns.annual())\nprint(returns.vbt.returns.annual())\n\n%timeit big_returns.vbt.returns.annual()\n```\n\n----------------------------------------\n\nTITLE: Generating Exit Signals from Entry Points in vectorbt\nDESCRIPTION: Shows how to create exit signals from existing entry signals using a custom function. Demonstrates different waiting period configurations and includes a performance benchmark for large datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n@njit\ndef choice_func_nb(from_i, to_i, col, temp_int):\n    temp_int[0] = from_i\n    return temp_int[:1]\n\nprint(entries.vbt.signals.generate_exits(choice_func_nb, temp_int))\nprint(entries.vbt.signals.generate_exits(choice_func_nb, temp_int, wait=0))\n\n%timeit big_entries.vbt.signals.generate_exits(choice_func_nb, temp_int)\n```\n\n----------------------------------------\n\nTITLE: Box Plot Implementation\nDESCRIPTION: Demonstrates box plot creation and updating with different orientations\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nbox = pd.DataFrame([[1, 2], [3, 4], [2, 1]], columns=['a', 'b']).vbt.boxplot(return_fig=False)\nbox.fig\n\nbox.update([[4, 9], [4, 5], [3, 0]])\n```\n\n----------------------------------------\n\nTITLE: Parameter-Based Indexing with param2_loc\nDESCRIPTION: Shows parameter-based indexing using the param2_loc accessor, which selects data based on the second parameter value. Demonstrates selection using single value, slice, and list selection methods.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nprint(h.param2_loc[0.3].a)\nprint(h.param2_loc[0.3:0.3].a)\nprint(h.param2_loc[[0.3, 0.3]].a.columns)\n```\n\n----------------------------------------\n\nTITLE: Using ColumnGrouper with Series\nDESCRIPTION: Demonstrates ColumnGrouper functionality with Series data, including group operations and index management.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(column_grouper.ColumnGrouper(sr2.to_frame().columns, group_by=np.array([0])).group_by)\nprint(column_grouper.ColumnGrouper(sr2.to_frame().columns, group_by=np.array([0])).get_groups_and_columns())\nprint(column_grouper.ColumnGrouper(sr2.to_frame().columns, group_by=np.array([0])).get_groups())\nprint(column_grouper.ColumnGrouper(sr2.to_frame().columns, group_by=np.array([0])).get_columns())\nprint(column_grouper.ColumnGrouper(sr2.to_frame().columns, group_by=np.array([0])).get_group_lens())\nprint(column_grouper.ColumnGrouper(sr2.to_frame().columns, group_by=np.array([0])).get_group_start_idxs())\nprint(column_grouper.ColumnGrouper(sr2.to_frame().columns, group_by=np.array([0])).get_group_end_idxs())\n```\n\n----------------------------------------\n\nTITLE: Calculating Cumulative Returns\nDESCRIPTION: Compares empyrical and vectorbt implementations of cumulative returns calculation. Shows both single-column and multi-column approaches with performance benchmarking.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.cum_returns(returns['a']))\n%timeit empyrical.cum_returns(big_returns[0])\n\nprint(returns['a'].vbt.returns.cumulative())\n%timeit big_returns[0].vbt.returns.cumulative()\n\nprint(returns.vbt.returns.cumulative())\nprint(returns.vbt.returns.cumulative(start_value=1))\n%timeit big_returns.vbt.returns.cumulative()\n```\n\n----------------------------------------\n\nTITLE: Using Trend Label Generator (TRENDLB) in PctChange Mode\nDESCRIPTION: Demonstrates the Trend Label generator with PctChange mode, using various positive and negative thresholds. Includes performance testing and output shape information.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.TRENDLB.run(close, pos_th=pos_ths, neg_th=neg_ths, mode='PctChange').labels)\n\n%timeit vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='PctChange')\n\nprint(vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='PctChange').wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Shuffling Signal Data with vectorbt in Python\nDESCRIPTION: Demonstrates how to use vectorbt's signal shuffling functionality to randomly reorder signal entries. Includes a benchmark of the operation on a large DataFrame to evaluate performance.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(entries.vbt.signals.shuffle(seed=42))\n\n%timeit big_entries.vbt.signals.shuffle(seed=42)\n```\n\n----------------------------------------\n\nTITLE: One-sided Broadcasting with broadcast_to Function\nDESCRIPTION: Demonstrates the broadcast_to function which performs one-sided broadcasting where one object is reshaped to match another. By default, it copies the index/columns from the second argument.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n# One-side broadcasting, default behaviour is copying index/columns from the second argument\nprint(reshape_fns.broadcast_to(sr1, sr1))\nprint(reshape_fns.broadcast_to(sr1, sr2))\nprint(reshape_fns.broadcast_to(sr1, df1))\nprint(reshape_fns.broadcast_to(sr1, df2))\nprint(reshape_fns.broadcast_to(sr1, df3))\nprint(reshape_fns.broadcast_to(sr1, df4))\n```\n\n----------------------------------------\n\nTITLE: Generating Random Signals with Fixed Count in vectorbt\nDESCRIPTION: Demonstrates generating random boolean signals with a fixed number of True values per column. Shows different configurations including varying numbers of signals per column with performance benchmarks.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nprint(pd.Series.vbt.signals.generate_random(5, n=2, seed=42, index=index))\nprint(pd.DataFrame.vbt.signals.generate_random((5, 3), n=2, seed=42, index=index, columns=columns))\nprint(pd.DataFrame.vbt.signals.generate_random((5, 3), n=[0, 1, 2], seed=42, index=index, columns=columns))\n\n%timeit pd.DataFrame.vbt.signals.generate_random((1000, 1000), n=100)\n```\n\n----------------------------------------\n\nTITLE: Testing Grouped Column-Only Wrapper Indexing Functions\nDESCRIPTION: Examines how indexing_func_meta behaves on grouped column-only DataFrame wrappers. Shows the combination effects of both grouping and column-only mode on different types of row selection.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_grouped_wrapper_co.indexing_func_meta(lambda x: x.iloc[0])[1:])\nprint(df4_grouped_wrapper_co.indexing_func_meta(lambda x: x.iloc[1])[1:])\nprint(df4_grouped_wrapper_co.indexing_func_meta(lambda x: x.iloc[[1]])[1:])\nprint(df4_grouped_wrapper_co.indexing_func_meta(lambda x: x.iloc[:2])[1:])\n```\n\n----------------------------------------\n\nTITLE: Creating Symmetric Matrix with vectorbt\nDESCRIPTION: Demonstrates vectorbt's utility function for creating symmetric matrices from Series data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> pd.Series([1, 2, 3]).vbt.make_symmetric()\n     0    1    2\n0  1.0  2.0  3.0\n1  2.0  NaN  NaN\n2  3.0  NaN  NaN\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Performance Comparison with Different Memory Requirements\nDESCRIPTION: Evaluates the performance and memory flags of broadcasting operations with different requirements options (W, C, F). Shows how memory layout affects the performance of broadcasting large arrays.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.broadcast(np.empty((1,)), big_a)[0].flags)\n%timeit reshape_fns.broadcast(np.empty((1,)), big_a)\n\nprint(reshape_fns.broadcast(np.empty((1,)), big_a, require_kwargs={'requirements': 'W'})[0].flags)\n%timeit reshape_fns.broadcast(np.empty((1,)), big_a, require_kwargs={'requirements': 'W'})\n\nprint(reshape_fns.broadcast(np.empty((1,)), big_a, require_kwargs={'requirements': 'C'})[0].flags)\n%timeit reshape_fns.broadcast(np.empty((1,)), big_a, require_kwargs={'requirements': 'C'})\n\nprint(reshape_fns.broadcast(np.empty((1,)), big_a, require_kwargs={'requirements': 'F'})[0].flags)\n%timeit reshape_fns.broadcast(np.empty((1,)), big_a, require_kwargs={'requirements': 'F'})\n```\n\n----------------------------------------\n\nTITLE: Mapping and Reducing Signal Partitions in VectorBT (Python)\nDESCRIPTION: Demonstrates the map_reduce_partitions method which applies functions to partitions of signals. Similar to map_reduce_between but operates on partitions rather than pairs of signals.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nprint(entries.vbt.signals.map_reduce_partitions(\n    range_map_func_nb=distance_map_nb, reduce_func_nb=avg_reduce_nb))\n\n%timeit big_entries.vbt.signals.map_reduce_partitions(\\\n    range_map_func_nb=distance_map_nb, reduce_func_nb=avg_reduce_nb)\n```\n\n----------------------------------------\n\nTITLE: Testing kwargs_to_args in VectorBT\nDESCRIPTION: Shows how to use kwargs_to_args parameter in IndicatorFactory to convert keyword arguments to positional arguments.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p, a, kw: ts * p + a + kw, kwargs_to_args=['kw'], var_args=True)\n      .run(close, [0, 1, 2], 3, kw=10).out)\n```\n\n----------------------------------------\n\nTITLE: Testing run_combs Method in VectorBT\nDESCRIPTION: Shows how to use run_combs method to run combinations of parameters with IndicatorFactory.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2))\n      .run_combs(close, [0, 1, 2], [3, 4, 5], short_names=['i1', 'i2'])[0].out)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting to Array of DataFrame\nDESCRIPTION: Shows broadcasting values to match a DataFrame's shape. Demonstrates how scalar values and arrays of various dimensions are broadcast to conform to the DataFrame's dimensions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.broadcast_to_array_of(0.1, df2))\nprint(reshape_fns.broadcast_to_array_of([0.1], df2))\nprint(reshape_fns.broadcast_to_array_of([0.1, 0.2], df2))\nprint(reshape_fns.broadcast_to_array_of([[[0.1], [0.2], [0.3]], [[0.4], [0.5], [0.6]]], df2))\n```\n\n----------------------------------------\n\nTITLE: Mapping and Reducing Between Signals in VectorBT (Python)\nDESCRIPTION: Demonstrates using Numba-accelerated functions to map and reduce operations between signals. This example calculates the average distance between signal pairs using custom functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndistance_map_nb = njit(lambda prev_i, next_i, col: next_i - prev_i)\navg_reduce_nb = njit(lambda col, a: np.nanmean(a))\n\nprint(entries.vbt.signals.map_reduce_between(\n    range_map_func_nb=distance_map_nb, reduce_func_nb=avg_reduce_nb))\n\n%timeit big_entries.vbt.signals.map_reduce_between(\\\n    range_map_func_nb=distance_map_nb, reduce_func_nb=avg_reduce_nb)\n```\n\n----------------------------------------\n\nTITLE: Configuring VectorBT Broadcasting Settings in Python\nDESCRIPTION: Sets VectorBT broadcasting settings to use 'stack' behavior for both index and columns broadcasting operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nvbt.settings.broadcasting['index_from'] = 'stack'\nvbt.settings.broadcasting['columns_from'] = 'stack'\n```\n\n----------------------------------------\n\nTITLE: Testing Wrapper Structural Properties After Indexing\nDESCRIPTION: Examines the index, columns, and dimensionality properties of different wrapper types after performing iloc operations. This demonstrates how the structure of wrappers changes after slicing operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2_wrapper.iloc[:2].index)\nprint(sr2_wrapper.iloc[:2].columns)\nprint(sr2_wrapper.iloc[:2].ndim)\n\nprint(df4_wrapper.iloc[0, :2].index)\nprint(df4_wrapper.iloc[0, :2].columns)\nprint(df4_wrapper.iloc[0, :2].ndim)\n\nprint(df4_wrapper.iloc[:2, 0].index)\nprint(df4_wrapper.iloc[:2, 0].columns)\nprint(df4_wrapper.iloc[:2, 0].ndim)\n\nprint(df4_wrapper.iloc[:2, [0]].index)\nprint(df4_wrapper.iloc[:2, [0]].columns)\nprint(df4_wrapper.iloc[:2, [0]].ndim)\n\nprint(df4_wrapper.iloc[:2, :2].index)\nprint(df4_wrapper.iloc[:2, :2].columns)\nprint(df4_wrapper.iloc[:2, :2].ndim)\n```\n\n----------------------------------------\n\nTITLE: Creating Exit-Only Signal Factory in VectorBT (Python)\nDESCRIPTION: Demonstrates creating a signal factory in 'exits' mode that only processes exit signals based on predefined entries. This simplifies the factory when entry logic is handled elsewhere.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nMySignals = vbt.SignalFactory(\n    input_names=['ts2'],\n    in_output_names=['in_out2'],\n    param_names=['n2'],\n    mode='exits'\n).from_choice_func(\n    exit_choice_func=choice_nb,\n    exit_settings=dict(\n        pass_inputs=['ts2'],\n        pass_in_outputs=['in_out2'],\n        pass_params=['n2'],\n        pass_kwargs=['temp_idx_arr2', ('kw2', 1000)]\n    ),\n    in_output_settings=dict(\n        in_out2=dict(\n            dtype=np.float64\n        )\n    ),\n    in_out2=np.nan,\n    var_args=True\n)\ne = np.array([True, False, True, False, True])\nmy_sig = MySignals.run(e, np.arange(5), [1, 0], 100)\nprint(my_sig.entries)\nprint(my_sig.exits)\nprint(my_sig.in_out2)\nmy_sig[0].plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Plotting Trend Labels (TRENDLB) in PctChange Mode\nDESCRIPTION: Visualizes the Trend Labels in PctChange mode for a single column of the test data with specified positive and negative thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nvbt.TRENDLB.run(close['a'], pos_th=1, neg_th=0.5, mode='PctChange').plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Creating Time Series Data in Python\nDESCRIPTION: Generates time series data structures including a small example Series and a large random Series with 1000 elements. Demonstrates the shape of each time series for reference in subsequent operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nts = pd.Series([1., 2., 3., 2., 1.], index=index, name=columns[0])\nprint(ts.shape)\n\nbig_ts = pd.Series(np.random.uniform(10, 13, size=(1000,)), index=big_index)\nprint(big_ts.shape)\n```\n\n----------------------------------------\n\nTITLE: Testing Cache Function in VectorBT\nDESCRIPTION: Demonstrates using cache_func parameter in IndicatorFactory to cache computations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, param, c: ts * param + c, cache_func=lambda ts, params: 100)\n      .run(close, [0, 1]).out)\n```\n\n----------------------------------------\n\nTITLE: Controlling Default Parameter Visibility\nDESCRIPTION: Demonstrates how to control whether default parameter values are included in column labels using the hide_default option, providing flexibility in output representation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n# test hide_default\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2), p2=2)\n      .run(close, [0, 1], hide_default=False).out)\nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)), p2=2)\n      .run(close, [0, 1], hide_default=False).out)\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2), p2=2)\n      .run(close, [0, 1], hide_default=True).out)\nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)), p2=2)\n      .run(close, [0, 1], hide_default=True).out)\n```\n\n----------------------------------------\n\nTITLE: Testing Wrapping Methods on Indexed Grouped Column-Only Wrappers (Second Group Array)\nDESCRIPTION: Tests wrapping methods on the second indexed group (as an array) of a grouped column-only wrapper. Shows how array selection affects wrapping operations on different groups.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_grouped_wrapper_co.iloc[[1]].wrap(np.array([1, 2, 3])))\nprint(df4_grouped_wrapper_co.iloc[[1]].wrap_reduced(np.array([1])))\n\nprint(df4_grouped_wrapper_co.iloc[[1]].wrap(np.array([1, 2, 3]), group_by=False))\nprint(df4_grouped_wrapper_co.iloc[[1]].wrap_reduced(np.array([1]), group_by=False))\n```\n\n----------------------------------------\n\nTITLE: Broadcasting to Higher Dimensional Arrays\nDESCRIPTION: Demonstrates broadcasting a scalar value to match a 3D array shape. Shows that broadcast_to_array_of works with arrays of dimensions greater than 2.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.broadcast_to_array_of(0.1, np.empty((2, 2, 2)))) # works even for ndim > 2\n```\n\n----------------------------------------\n\nTITLE: Creating Large Empty NumPy Array\nDESCRIPTION: Creates a large empty NumPy array with dimensions 1000x1000. This serves as a test case for the performance evaluation of broadcasting operations in the next snippet.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nbig_a = np.empty((1000, 1000))\n```\n\n----------------------------------------\n\nTITLE: Creating Static Indicators Without Inputs or Parameters\nDESCRIPTION: Shows how to create indicators that generate static output without any inputs or parameters, useful for creating reference or constant arrays.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# test no inputs and no params\nF = vbt.IndicatorFactory(output_names=['out'])\nprint(F.from_apply_func(lambda: np.full((3, 3), 1))\n      .run().out)\nprint(F.from_apply_func(njit(lambda: np.full((3, 3), 1)))\n      .run().out)\n```\n\n----------------------------------------\n\nTITLE: Displaying First and Last Data Points for Both Stocks\nDESCRIPTION: Prints the first and last data points for each stock in the pair to verify data loading and provide a quick overview of the price range during the analysis period.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(data.data[SYMBOL1].iloc[[0, -1]])\nprint(data.data[SYMBOL2].iloc[[0, -1]])\n```\n\n----------------------------------------\n\nTITLE: Hiding Parameters in IndicatorFactory\nDESCRIPTION: Shows how to hide specific parameters using the hide_params option, making them function more like internal constants rather than exposed parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n# test hide_params\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2), hide_params=['p2'])\n      .run(close, [0, 1], 2).out)\nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)), hide_params=['p2'])\n      .run(close, [0, 1], 2).out)\n```\n\n----------------------------------------\n\nTITLE: Downloading Financial Data with Alpaca Integration\nDESCRIPTION: Shows how to download financial market data using vectorbt's Alpaca integration with time-based parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> alpaca_data = vbt.AlpacaData.download(\n...     \"AAPL\",\n...     start='2 hours ago UTC',\n...     end='15 minutes ago UTC',\n...     interval='1m'\n... )\n>>> alpaca_data.get()\n```\n\n----------------------------------------\n\nTITLE: Calculating Partition Position Rank in VectorBT (Python)\nDESCRIPTION: Shows how to calculate position ranks within partitions of signals with various parameters. Partition position rank counts the position within each continuous group of signals.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nprint(entries['a'].vbt.signals.partition_pos_rank())\nprint(entries.vbt.signals.partition_pos_rank())\n\nprint(entries['a'].vbt.signals.partition_pos_rank(after_false=True))\nprint(entries.vbt.signals.partition_pos_rank(after_false=True))\n\nprint(entries['a'].vbt.signals.partition_pos_rank(reset_by=~entries['a']))\nprint(entries.vbt.signals.partition_pos_rank(reset_by=~entries))\n\n%timeit big_entries.vbt.signals.partition_pos_rank()\n```\n\n----------------------------------------\n\nTITLE: Merging Dictionaries with VectorBT Config\nDESCRIPTION: Shows examples of merging dictionaries using VectorBT's config.merge_dicts function, demonstrating various scenarios of nested dictionary merging.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(config.merge_dicts({'a': 1}, {'b': 2}))\nprint(config.merge_dicts({'a': 1}, {'a': 2}))\nprint(config.merge_dicts({'a': {'b': 2}}, {'a': {'c': 3}}))\nprint(config.merge_dicts({'a': {'b': 2}}, {'a': {'b': 3}}))\n```\n\n----------------------------------------\n\nTITLE: Testing Wrapping Methods on Grouped Column-Only Wrappers\nDESCRIPTION: Tests the wrap and wrap_reduced methods on grouped column-only wrappers with different array inputs. Demonstrates wrapping functionality with and without applying grouping.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_grouped_wrapper_co.wrap(np.array([[1, 2], [3, 4], [5, 6]])))\nprint(df4_grouped_wrapper_co.wrap_reduced(np.array([1, 2])))\n\nprint(df4_grouped_wrapper_co.wrap(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), group_by=False))\nprint(df4_grouped_wrapper_co.wrap_reduced(np.array([1, 2, 3]), group_by=False))\n```\n\n----------------------------------------\n\nTITLE: Exit-Only Signal Factory with Wait Parameter in VectorBT (Python)\nDESCRIPTION: Shows the exit-only signal factory with a wait parameter that delays exit signals. This example demonstrates how exit timing can be controlled when using predefined entry signals.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\ne = np.array([True, False, False, True, False, False])\nmy_sig = MySignals.run(e, np.arange(6), [1, 0], 100, wait=2)\nprint(my_sig.entries)\nprint(my_sig.exits)\nprint(my_sig.in_out2)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Forward Standard Deviation (FSTD) Indicator\nDESCRIPTION: Demonstrates the Forward Standard Deviation indicator with various parameters. Includes performance benchmarking for single and multiple window sizes, displaying the output shape.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.FSTD.run(close, window=(2, 3), ewm=(False, True), param_product=True).fstd)\n\n%timeit vbt.FSTD.run(big_close, window=2)\n%timeit vbt.FSTD.run(big_close, window=np.arange(2, 10).tolist())\n\nprint(vbt.FSTD.run(big_close, window=np.arange(2, 10).tolist()).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Forward Maximum (FMAX) Indicator\nDESCRIPTION: Demonstrates the Forward Maximum indicator with different window sizes. Includes performance benchmarking and shows output dimensionality.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.FMAX.run(close, window=(2, 3)).fmax)\n\n%timeit vbt.FMAX.run(big_close, window=2)\n%timeit vbt.FMAX.run(big_close, window=np.arange(2, 10).tolist())\n\nprint(vbt.FMAX.run(big_close, window=np.arange(2, 10).tolist()).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Arrays to Specific Shape in NumPy\nDESCRIPTION: Uses NumPy's broadcast_to function to reshape various inputs (scalars, arrays, series) to a fixed 3x3 shape. This demonstrates the basic broadcasting capability that vectorbt builds upon.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n[np.broadcast_to(x, (3, 3)) for x in (0, a1, a2, sr_none, sr1, sr2)]\n```\n\n----------------------------------------\n\nTITLE: RANDNX with Multi-Dimensional Parameters in VectorBT (Python)\nDESCRIPTION: Demonstrates using RANDNX with multi-dimensional parameters to create a more complex set of random signals across multiple columns.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nrandnx = vbt.RANDNX.run(n=[np.array([1, 2]), np.array([3, 4])], input_shape=(8, 2), seed=42)\n\nprint(randnx.entries)\nprint(randnx.exits)\n```\n\n----------------------------------------\n\nTITLE: Creating Large DataFrames for Performance Testing\nDESCRIPTION: Creates large DataFrames and different wrapper types to benchmark performance. Sets up regular, column-only, grouped, and grouped column-only wrappers for a large 1000x1000 DataFrame.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nbig_df = pd.DataFrame(np.empty((1000, 1000)))\n\nbig_df_wrapper = array_wrapper.ArrayWrapper.from_obj(big_df)\nbig_df_wrapper_co = big_df_wrapper.copy(column_only_select=True)\nbig_df_grouped_wrapper = df4_wrapper.copy(group_by=np.array([0, 0, 1]))\nbig_df_grouped_wrapper_co = big_df_grouped_wrapper.copy(column_only_select=True)\n```\n\n----------------------------------------\n\nTITLE: Initializing Various Data Structures in Python\nDESCRIPTION: Creates and prints various NumPy arrays, Pandas Series, and DataFrames with different shapes and index/column configurations, including multi-index structures.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv1 = 0\na1 = np.array([1])\na2 = np.array([1, 2, 3])\na3 = np.array([[1, 2, 3]])\na4 = np.array([[1], [2], [3]])\na5 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nsr1 = pd.Series([1], index=pd.Index(['x1'], name='i1'))\nprint(sr1)\nsr2 = pd.Series([1, 2, 3], index=pd.Index(['x2', 'y2', 'z2'], name='i2'))\nprint(sr2)\ndf1 = pd.DataFrame(\n    [[1]], \n    index=pd.Index(['x3'], name='i3'), \n    columns=pd.Index(['a3'], name='c3'))\nprint(df1)\ndf2 = pd.DataFrame(\n    [[1], [2], [3]], \n    index=pd.Index(['x4', 'y4', 'z4'], name='i4'), \n    columns=pd.Index(['a4'], name='c4'))\nprint(df2)\ndf3 = pd.DataFrame(\n    [[1, 2, 3]], \n    index=pd.Index(['x5'], name='i5'), \n    columns=pd.Index(['a5', 'b5', 'c5'], name='c5'))\nprint(df3)\ndf4 = pd.DataFrame(\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]], \n    index=pd.Index(['x6', 'y6', 'z6'], name='i6'), \n    columns=pd.Index(['a6', 'b6', 'c6'], name='c6'))\nprint(df4)\n\nmulti_i = pd.MultiIndex.from_arrays([['x7', 'y7', 'z7'], ['x8', 'y8', 'z8']], names=['i7', 'i8']) \nmulti_c = pd.MultiIndex.from_arrays([['a7', 'b7', 'c7'], ['a8', 'b8', 'c8']], names=['c7', 'c8'])\ndf5 = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=multi_i, columns=multi_c)\nprint(df5)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting with Manually Specified Index and Columns\nDESCRIPTION: Demonstrates broadcasting with explicitly provided index and column objects (multi_i and multi_c). This gives complete control over the resulting axes of the broadcasted objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfor i in reshape_fns.broadcast(\n    v1, a1, a2, a3, a4, a5, sr_none, sr1, sr2, df_none, df1, df2, df3, df4,\n    index_from=multi_i, # specify manually\n    columns_from=multi_c\n):\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Using Trend Label Generator (TRENDLB) in PctChangeNorm Mode\nDESCRIPTION: Demonstrates the Trend Label generator with PctChangeNorm mode, using various positive and negative thresholds. Includes performance testing and output shape information.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.TRENDLB.run(close, pos_th=pos_ths, neg_th=neg_ths, mode='PctChangeNorm').labels)\n\n%timeit vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='PctChangeNorm')\n\nprint(vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='PctChangeNorm').wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Histogram Plot Implementation\nDESCRIPTION: Creates and updates histogram plots with various configurations\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nhist = pd.DataFrame([[1, 2], [3, 4], [2, 1]], columns=['a', 'b']).vbt.histplot(return_fig=False)\nhist.fig\n\nhist.update([[4, 9], [4, 5], [3, 0]])\n```\n\n----------------------------------------\n\nTITLE: Creating Large Time Series Dataset for Performance Testing\nDESCRIPTION: Generates a large DataFrame (1000x1000) with random values and daily timestamps to use for performance benchmarking between vectorbt and empyrical libraries.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbig_ts = pd.DataFrame(np.random.randint(1, 10, size=(1000, 1000)).astype(float))\nbig_ts.index = [datetime(2018, 1, 1) + timedelta(days=i) for i in range(1000)]\nbig_ts.shape\n```\n\n----------------------------------------\n\nTITLE: Generating Random OHLCV Time Series Data\nDESCRIPTION: Creates a more realistic OHLCV dataset with random price data over a 10-day period, including proper datetime index and realistic price relationships between open, high, low, and close values.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nohlcv_ts = pd.DataFrame(\n    columns=['open', 'high', 'low', 'close', 'volume'],\n    index=[datetime(2018, 1, 1) + timedelta(days=i) for i in range(10)]\n)\nohlcv_ts['open'] = np.cumsum(np.random.uniform(-0.8, 1, size=(10,)))\nohlcv_ts['close'] = ohlcv_ts['open'] + np.random.uniform(-1, 1, size=(10,))\nohlcv_ts['high'] = ohlcv_ts['open'] + np.random.uniform(0, 1, size=(10,))\nohlcv_ts['low'] = ohlcv_ts['open'] - np.random.uniform(0, 1, size=(10,))\nohlcv_ts['volume'] = np.cumsum(np.random.uniform(-1, 1, size=(10,)))\n\nprint(ohlcv_ts)\n```\n\n----------------------------------------\n\nTITLE: Custom PandasData Class Definition for Backtrader\nDESCRIPTION: Defines a custom PandasData class that inherits from btfeeds.PandasData to handle OHLCV data from pandas DataFrame for Backtrader\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass PandasData(btfeeds.PandasData):\n    params = (\n        ('datetime', None),\n        ('open', 'Open'),\n        ('high', 'High'),\n        ('low', 'Low'),\n        ('close', 'Close'),\n        ('volume', 'Volume'),\n        ('openinterest', None),\n    )\n```\n\n----------------------------------------\n\nTITLE: Installing vectorbt using pip\nDESCRIPTION: Basic installation command for vectorbt using pip package manager.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/installation.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npip install -U vectorbt\n```\n\n----------------------------------------\n\nTITLE: Testing Wrapping Methods on Indexed Grouped Column-Only Wrappers (Second Group)\nDESCRIPTION: Tests wrap and wrap_reduced methods on the second indexed element of a grouped column-only wrapper. Shows how wrapping operations behave when applied to a different group.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_grouped_wrapper_co.iloc[1].wrap(np.array([1, 2, 3])))\nprint(df4_grouped_wrapper_co.iloc[1].wrap_reduced(np.array([1])))\n\nprint(df4_grouped_wrapper_co.iloc[1].wrap(np.array([1, 2, 3]), group_by=False))\nprint(df4_grouped_wrapper_co.iloc[1].wrap_reduced(np.array([1]), group_by=False))\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Multiple Arrays at Once with Stack Parameters\nDESCRIPTION: Demonstrates broadcasting multiple arrays simultaneously to a specified shape of (3,3) using reshape_fns.broadcast. The index and columns are created by stacking the indices of the input objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n# Broadcasting all at once\nfor i in reshape_fns.broadcast(\n    0, a1, a2, sr_none, sr1, sr2,\n    to_shape=(3, 3),\n    index_from='stack',\n    columns_from='stack'\n):\n    print(i)\n```\n\n----------------------------------------\n\nTITLE: Comparing Tail Ratio Calculations between empyrical and vectorbt\nDESCRIPTION: Shows Tail Ratio calculations using both empyrical and vectorbt libraries with performance benchmarks. Includes implementations for single series, multiple series, and rolling window calculations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nprint(empyrical.tail_ratio(returns['a']))\n%timeit empyrical.tail_ratio(big_returns[0])\n\nprint(returns['a'].vbt.returns.tail_ratio())\n%timeit big_returns[0].vbt.returns.tail_ratio()\n\nprint(returns.vbt.returns.tail_ratio())\n%timeit big_returns.vbt.returns.tail_ratio()\n\nprint(returns.vbt.returns.rolling_tail_ratio(3, minp=1))\n%timeit big_returns.vbt.returns.rolling_tail_ratio(3, minp=1)\n```\n\n----------------------------------------\n\nTITLE: Testing Column-Only Wrapper Properties After Indexing\nDESCRIPTION: Examines the index, columns, and dimensionality properties of column-only wrappers after various iloc operations. Shows how column-only selection mode affects the properties of the resulting wrappers.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_wrapper_co.iloc[0].index)\nprint(df4_wrapper_co.iloc[0].columns)\nprint(df4_wrapper_co.iloc[0].ndim)\n\nprint(df4_wrapper_co.iloc[[0]].index)\nprint(df4_wrapper_co.iloc[[0]].columns)\nprint(df4_wrapper_co.iloc[[0]].ndim)\n\nprint(df4_wrapper_co.iloc[:2].index)\nprint(df4_wrapper_co.iloc[:2].columns)\nprint(df4_wrapper_co.iloc[:2].ndim)\n```\n\n----------------------------------------\n\nTITLE: Configuring Array-Like Parameters in IndicatorFactory\nDESCRIPTION: Shows how to configure specific parameters as array-like in the param_settings to control how they are broadcast and processed across multiple runs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# test param_settings array_like\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p1', 'p2'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p1, p2: ts * (p1 + p2), \n                        param_settings={'p1': {'is_array_like': True}})\n      .run(close, np.asarray([0, 1, 2]), np.asarray([2, 3])).out) \nprint(F.from_apply_func(njit(lambda ts, p1, p2: ts * (p1 + p2)), \n                        param_settings={'p1': {'is_array_like': True}})\n      .run(close, np.asarray([0, 1, 2]), np.asarray([2, 3])).out)\n```\n\n----------------------------------------\n\nTITLE: Importing Supporting Libraries for Financial Analysis\nDESCRIPTION: Imports necessary libraries for financial data manipulation and analysis including numpy, pandas, datetime tools, numba for performance optimization, and empyrical for financial metrics comparison.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom numba import njit\nimport empyrical\n```\n\n----------------------------------------\n\nTITLE: Testing Variable Arguments with IndicatorFactory\nDESCRIPTION: Tests IndicatorFactory with variable positional arguments (*args) using both standard lambda functions and Numba-optimized versions for performance comparison.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# test *args\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p, a: ts * p + a, var_args=True)\n      .run(close, [0, 1, 2], 3).out) \nprint(F.from_apply_func(njit(lambda ts, p, a: ts * p + a), var_args=True)\n      .run(close, [0, 1, 2], 3).out)\n```\n\n----------------------------------------\n\nTITLE: Running vectorbt with Docker\nDESCRIPTION: Docker command to pull and run vectorbt image with Jupyter Notebook server on port 8888.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/installation.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ndocker run --rm -p 8888:8888 -v \"$PWD\":/home/jovyan/work polakowo/vectorbt\n```\n\n----------------------------------------\n\nTITLE: Getting Groups and Indices\nDESCRIPTION: Demonstrates how to retrieve group information and corresponding indices using different grouping methods.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(column_grouper.get_groups_and_index(some_columns, 0))\nprint(column_grouper.get_groups_and_index(some_columns, [0, 1]))\nprint(column_grouper.get_groups_and_index(some_columns, np.array([3, 2, 1, 1, 1, 0, 0, 0])))\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Wrapper Indexing Functions in Python\nDESCRIPTION: Tests the behavior of indexing_func_meta on different wrapper types with various iloc slicing patterns. This demonstrates how indexing affects the metadata of different DataFrame and Series wrappers.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# test indexing\nprint(sr2_wrapper.indexing_func_meta(lambda x: x.iloc[:2])[1:])\nprint(df4_wrapper.indexing_func_meta(lambda x: x.iloc[0, :2])[1:])\nprint(df4_wrapper.indexing_func_meta(lambda x: x.iloc[:2, 0])[1:])\nprint(df4_wrapper.indexing_func_meta(lambda x: x.iloc[:2, [0]])[1:])\nprint(df4_wrapper.indexing_func_meta(lambda x: x.iloc[:2, :2])[1:])\n```\n\n----------------------------------------\n\nTITLE: Using RPROBNX Probability-Based Signal Generator in VectorBT (Python)\nDESCRIPTION: Demonstrates the RPROBNX generator which creates random entry and exit signals based on probability. This example shows basic usage with 100% probability for both entry and exit.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nrprobnx = vbt.RPROBNX.run(entry_prob=1., exit_prob=1., input_shape=(5,), seed=42)\n\nprint(rprobnx.entries)\nprint(rprobnx.exits)\n```\n\n----------------------------------------\n\nTITLE: Testing Grouped Wrapper Properties After Indexing\nDESCRIPTION: Examines the properties of grouped wrappers after iloc operations, including group-specific attributes. This shows how grouping affects the structural properties and grouping information after slicing.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2_grouped_wrapper.iloc[:2].index)\nprint(sr2_grouped_wrapper.iloc[:2].columns)\nprint(sr2_grouped_wrapper.iloc[:2].ndim)\nprint(sr2_grouped_wrapper.iloc[:2].grouped_ndim)\nprint(sr2_grouped_wrapper.iloc[:2].grouper.group_by)\n\nprint(df4_grouped_wrapper.iloc[:2, 0].index)\nprint(df4_grouped_wrapper.iloc[:2, 0].columns)\nprint(df4_grouped_wrapper.iloc[:2, 0].ndim)\nprint(df4_grouped_wrapper.iloc[:2, 0].grouped_ndim)\nprint(df4_grouped_wrapper.iloc[:2, 0].grouper.group_by)\n\nprint(df4_grouped_wrapper.iloc[:2, 1].index)\nprint(df4_grouped_wrapper.iloc[:2, 1].columns)\nprint(df4_grouped_wrapper.iloc[:2, 1].ndim)\nprint(df4_grouped_wrapper.iloc[:2, 1].grouped_ndim)\nprint(df4_grouped_wrapper.iloc[:2, 1].grouper.group_by)\n\nprint(df4_grouped_wrapper.iloc[:2, [1]].index)\nprint(df4_grouped_wrapper.iloc[:2, [1]].columns)\nprint(df4_grouped_wrapper.iloc[:2, [1]].ndim)\nprint(df4_grouped_wrapper.iloc[:2, [1]].grouped_ndim)\nprint(df4_grouped_wrapper.iloc[:2, [1]].grouper.group_by)\n\nprint(df4_grouped_wrapper.iloc[:2, :2].index)\nprint(df4_grouped_wrapper.iloc[:2, :2].columns)\nprint(df4_grouped_wrapper.iloc[:2, :2].ndim)\nprint(df4_grouped_wrapper.iloc[:2, :2].grouped_ndim)\nprint(df4_grouped_wrapper.iloc[:2, :2].grouper.group_by)\n```\n\n----------------------------------------\n\nTITLE: Custom Signal Factory with Wait Parameter in VectorBT (Python)\nDESCRIPTION: Extends the custom signal factory example to include a wait parameter for both entry and exit signals. Shows how to pass additional parameters through kwargs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nmy_sig = MySignals.run(\n    np.arange(7), np.arange(7), [0, 1], [1, 0], \n    entry_args=(100,), exit_args=(100,), \n    entry_kwargs=dict(wait=2), exit_kwargs=dict(wait=2)\n)\nprint(my_sig.entries)\nprint(my_sig.exits)\nprint(my_sig.in_out1)\nprint(my_sig.in_out2)\n```\n\n----------------------------------------\n\nTITLE: Creating Sample Time Series Data\nDESCRIPTION: Creates a sample DataFrame with three columns and five daily timestamps for testing financial calculations. The data represents price values that will be converted to returns later.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nindex = pd.DatetimeIndex([\n    datetime(2018, 1, 1),\n    datetime(2018, 1, 2),\n    datetime(2018, 1, 3),\n    datetime(2018, 1, 4),\n    datetime(2018, 1, 5)\n], freq='D')\ncolumns = ['a', 'b', 'c']\nts = pd.DataFrame({\n    'a': [1, 2, 3, 4, 5], \n    'b': [5, 4, 3, 2, 1],\n    'c': [1, 2, 3, 2, 1]\n}, index=index).astype(np.float32)\n\nprint(ts)\n```\n\n----------------------------------------\n\nTITLE: Converting Series to Arrays with VectorBT\nDESCRIPTION: Shows how to convert pandas Series to 1D and 2D NumPy arrays using VectorBT's to_1d_array and to_2d_array accessor methods.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2.vbt.to_1d_array())\nprint(sr2.vbt.to_2d_array())\n```\n\n----------------------------------------\n\nTITLE: Cloning vectorbt from GitHub\nDESCRIPTION: Command to clone the vectorbt repository from GitHub.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/installation.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngit clone git@github.com:polakowo/vectorbt.git vectorbt\n```\n\n----------------------------------------\n\nTITLE: Verifying DataFrame Type in Python with VectorBT\nDESCRIPTION: This code uses checks.is_frame() to check if various objects are pandas DataFrames. It tests scalar, numpy array, pandas Series, and DataFrame objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(checks.is_frame(v1))\nprint(checks.is_frame(a1))\nprint(checks.is_frame(sr1))\nprint(checks.is_frame(df1))\n```\n\n----------------------------------------\n\nTITLE: Building and Running Docker Container for Candlestick Patterns App\nDESCRIPTION: Commands to build a Docker image and run a container for the candlestick patterns application. The container exposes port 8050 and sets the HOST environment variable to '0.0.0.0'.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/apps/candlestick-patterns/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t candlestick-patterns . \ndocker run -p 8050:8050 -e HOST='0.0.0.0' candlestick-patterns\n```\n\n----------------------------------------\n\nTITLE: Wrapping Arrays into DataFrames with VectorBT\nDESCRIPTION: Examples of wrapping NumPy arrays into pandas DataFrames using VectorBT's wrapper.wrap method from a DataFrame accessor, showing different behaviors based on input dimensions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_66\n\nLANGUAGE: python\nCODE:\n```\n# It will try to return pd.DataFrame\nprint(df2.vbt.wrapper.wrap(a2)) # returns df\nprint(df2.vbt.wrapper.wrap(sr2.values)) # returns df\nprint(df2.vbt.wrapper.wrap(df4.values, columns=df4.columns)) # returns df\nprint(df2.vbt.wrapper.wrap(df4.values, index=df4.index, columns=df4.columns)) # returns df\n```\n\n----------------------------------------\n\nTITLE: Plotting Mean Look-ahead (MEANLB) Labels\nDESCRIPTION: Visualizes the Mean Look-ahead labels for a single column of the test data with a window size of 2.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nvbt.MEANLB.run(close['a'], window=2).plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Data Types with VectorBT\nDESCRIPTION: Demonstrates combining a Series with multiple data types (scalars, lists, arrays, Series, DataFrames) using VectorBT's combine method with both regular and JIT-compiled functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_77\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], pd.Series([10, 20, 30])],\n    10, b=100,\n    combine_func=lambda x, y, a, b=1: x + y + a + b, \n    broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], [[10, 20, 30]], pd.Series([10, 20, 30]), df1, df3],\n    10, b=100,\n    combine_func=lambda x, y, a, b=1: x + y + a + b, \n    broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], [[10, 20, 30]], pd.Series([10, 20, 30]), df1, df3],\n    10,\n    combine_func=njit(lambda x, y, a, b=1: x + y + a + 100), \n    broadcast_kwargs=dict(index_from='stack')))\nprint(sr2.vbt.combine(\n    [10, [10, 20, 30], [[10, 20, 30]], pd.Series([10, 20, 30]), df1, df3],\n    10,\n    combine_func=njit(lambda x, y, a, b=1: x + y + a + 100), \n    broadcast_kwargs=dict(index_from='stack')))\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating Indices\nDESCRIPTION: Examples of creating indices from values using index_fns and performing operations like repeat, tile, and stack.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\ni1 = index_fns.index_from_values([0.1, 0.2], name='a')\ni2 = index_fns.index_from_values(np.tile(np.arange(1, 4)[:, None][:, None], (1, 3, 3)), name='b')\ni3 = index_fns.index_from_values(np.random.uniform(size=(3, 3, 3)), name='c')\n\nprint(i1)\nprint(i2)\nprint(i3)\n```\n\n----------------------------------------\n\nTITLE: Wrapping Arrays into Series with VectorBT\nDESCRIPTION: Examples of wrapping NumPy arrays into pandas Series using VectorBT's wrapper.wrap method, showing different behaviors based on input dimensions and metadata.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_65\n\nLANGUAGE: python\nCODE:\n```\n# It will try to return pd.Series\nprint(sr2.vbt.wrapper.wrap(a2)) # returns sr\nprint(sr2.vbt.wrapper.wrap(df2.values)) # returns sr\nprint(sr2.vbt.wrapper.wrap(df2.values, index=df2.index, columns=df2.columns)) # returns sr\nprint(sr2.vbt.wrapper.wrap(df4.values, columns=df4.columns)) # returns df\nprint(sr2.vbt.wrapper.wrap(df4.values, index=df4.index, columns=df4.columns)) # returns df\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries\nDESCRIPTION: Imports the necessary Python libraries: pandas for data manipulation, vectorbt for trading analysis, and logging for tracking application events.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport vectorbt as vbt\nimport logging\n```\n\n----------------------------------------\n\nTITLE: Plotting Fixed Look-ahead (FIXLB) Labels\nDESCRIPTION: Visualizes the Fixed Look-ahead labels for a single column of the test data with a look-ahead period of 2.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nvbt.FIXLB.run(close['a'], n=2).plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple OHLCV DataFrame\nDESCRIPTION: Creates a basic pandas DataFrame with the standard OHLCV columns (open, high, low, close, volume) and simple numeric values.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nohlcv_ts = pd.DataFrame({\n    'open': [1, 2, 3], \n    'high': [1, 2, 3], \n    'low': [1, 2, 3], \n    'close': [1, 2, 3], \n    'volume': [1, 2, 3]\n})\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Forward Minimum (FMIN) Indicator\nDESCRIPTION: Demonstrates the Forward Minimum indicator with different window sizes. Includes performance testing and shows output shapes for vectorized operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.FMIN.run(close, window=(2, 3)).fmin)\n\n%timeit vbt.FMIN.run(big_close, window=2)\n%timeit vbt.FMIN.run(big_close, window=np.arange(2, 10).tolist())\n\nprint(vbt.FMIN.run(big_close, window=np.arange(2, 10).tolist()).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pandas-Style Indexing Operations in Custom Class\nDESCRIPTION: Shows standard pandas-style indexing operations (direct indexing, loc, iloc, xs) working on the custom H class. The indexing operations are delegated to the underlying dataframes.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\n# Indexing operations are delegated to the underlying dataframes\nprint(h[(0.1, 0.3, 'a6')].a)\nprint(h.loc[:, (0.1, 0.3, 'a6'):(0.1, 0.3, 'c6')].a)\nprint(h.iloc[-2:, -2:].a)\nprint(h.xs((0.1, 0.3), level=('p1', 'p2'), axis=1).a.columns)\n```\n\n----------------------------------------\n\nTITLE: Applying Functions to Data with VectorBT\nDESCRIPTION: Demonstrates how to apply functions to Series and DataFrames using VectorBT's apply method, with options for controlling dimensionality of inputs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_73\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2.vbt.apply(apply_func=lambda x: x ** 2))\nprint(sr2.vbt.apply(apply_func=lambda x: x ** 2, to_2d=True))\nprint(df2.vbt.apply(apply_func=lambda x: x ** 2))\n```\n\n----------------------------------------\n\nTITLE: Importing VectorBT and Utility Modules\nDESCRIPTION: Imports the main VectorBT library and its utility modules for checks, configuration, decorators, and attributes.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n\nfrom vectorbt.utils import checks, config, decorators, attr\n```\n\n----------------------------------------\n\nTITLE: Broadcasting to Array from Scalar or Vector\nDESCRIPTION: Shows how broadcast_to_array_of creates an array matching the shape of another object. Demonstrates broadcasting scalars and arrays of different dimensions to match a vector's shape.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\n# Broadcasting first element to be an array out of the second argument\nprint(reshape_fns.broadcast_to_array_of(0.1, v1))\nprint(reshape_fns.broadcast_to_array_of([0.1], v1))\nprint(reshape_fns.broadcast_to_array_of([0.1, 0.2], v1))\n```\n\n----------------------------------------\n\nTITLE: Importing Supporting Libraries for Data Processing\nDESCRIPTION: Imports additional libraries needed for data manipulation, including numpy for numerical operations, pandas for data structures, datetime for time handling, and numba for performance optimization.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom numba import njit\n```\n\n----------------------------------------\n\nTITLE: Configuring vectorbt Settings\nDESCRIPTION: Disables caching for performance testing and sets the year frequency to 252 days (trading days in a year) to match empyrical library defaults.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Disable caching for performance testing\nvbt.settings.caching['enabled'] = False\nvbt.settings.returns['year_freq'] = '252 days' # same as empyrical\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error when OHLCV Columns Not Found\nDESCRIPTION: Attempts to plot a DataFrame without proper OHLCV column names, which results in an error. This illustrates that vectorbt expects specific column names for OHLCV data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pd.DataFrame([1, 2, 3]).vbt.ohlcv.plot()\nexcept Exception as e:\n    print(e) # couldn't find default column names\n```\n\n----------------------------------------\n\nTITLE: Calculating Drawdowns with vectorbt\nDESCRIPTION: Shows how to calculate drawdowns using vectorbt library with performance benchmarking. Demonstrates drawdown calculation and timeit performance measurement for large return series.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nprint(returns.vbt.returns.drawdown())\n\n%timeit big_returns.vbt.returns.drawdown()\n```\n\n----------------------------------------\n\nTITLE: Creating Test Data for Label Generation\nDESCRIPTION: Prepares sample data frames and threshold arrays used in subsequent examples. Creates a small time-indexed data frame 'close' for basic testing and threshold arrays for trend detection.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclose = pd.DataFrame({\n    'a': [1, 2, 1, 2, 3, 2],\n    'b': [3, 2, 3, 2, 1, 2]\n}, index=pd.Index([\n    datetime(2020, 1, 1),\n    datetime(2020, 1, 2),\n    datetime(2020, 1, 3),\n    datetime(2020, 1, 4),\n    datetime(2020, 1, 5),\n    datetime(2020, 1, 6)\n]))\n\npos_ths = [np.array([1, 1 / 2]), np.array([2, 1 / 2]), np.array([3, 1 / 2])]\nneg_ths = [np.array([1 / 2, 1 / 3]), np.array([1 / 2, 2 / 3]), np.array([1 / 2, 3 / 4])]\n```\n\n----------------------------------------\n\nTITLE: Concatenating Data with VectorBT\nDESCRIPTION: Shows how to concatenate different data types (Series, scalars, DataFrames) using VectorBT's concat method with custom keys for identification.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_74\n\nLANGUAGE: python\nCODE:\n```\nprint(pd.DataFrame.vbt.concat(sr2, 10, df4, keys=['a', 'b', 'c']))\nprint(sr2.vbt.concat(10, df4, keys=['a', 'b', 'c']))\n```\n\n----------------------------------------\n\nTITLE: Importing VectorBT Base Components\nDESCRIPTION: Imports the main VectorBT package and its base module components including column grouper, array wrapper, and various utility functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n\nfrom vectorbt.base import column_grouper, array_wrapper, combine_fns, index_fns, indexing, reshape_fns\n```\n\n----------------------------------------\n\nTITLE: Creating OHLC Price Data in Python\nDESCRIPTION: Sets up a DataFrame containing Open-High-Low-Close price data for 5 periods. This simulates typical price candles used in financial analysis and will be used for stop-loss and take-profit examples.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprice = pd.DataFrame({\n    'open': [10, 11, 12, 11, 10],\n    'high': [11, 12, 13, 12, 11],\n    'low': [9, 10, 11, 10, 9],\n    'close': [10, 11, 12, 11, 10]\n})\n```\n\n----------------------------------------\n\nTITLE: Importing VectorBT Library in Python\nDESCRIPTION: This snippet imports the VectorBT library, which is essential for quantitative analysis and signal processing in Python.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n```\n\n----------------------------------------\n\nTITLE: Index Repeat Operations\nDESCRIPTION: Demonstrates repeating indices using the repeat_index function.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nprint(index_fns.repeat_index(i2, 3))\nprint(index_fns.repeat_index(multi_i, 3))\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Continued Error with Standard Column Names\nDESCRIPTION: Attempts to plot the OHLCV DataFrame and still encounters an error, showing that even with standard column names, vectorbt requires explicit configuration.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    ohlcv_ts.vbt.ohlcv.plot()\nexcept Exception as e:\n    print(e) # still couldn't find default column names\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Signal Factory with Choice Functions in VectorBT (Python)\nDESCRIPTION: Shows how to create a custom SignalFactory using Numba-accelerated choice functions. This example sets up a factory that processes both entry and exit signals with multiple parameters.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\n@njit\ndef choice_nb(from_i, to_i, col, ts, in_out, n, arg, temp_idx_arr, kw):\n    in_out[from_i, col] = ts[from_i, col] * n + arg + kw\n    temp_idx_arr[0] = from_i\n    return temp_idx_arr[:1]\n\nMySignals = vbt.SignalFactory(\n    input_names=['ts1', 'ts2'],\n    in_output_names=['in_out1', 'in_out2'],\n    param_names=['n1', 'n2']\n).from_choice_func(\n    entry_choice_func=choice_nb,\n    entry_settings=dict(\n        pass_inputs=['ts1'],\n        pass_in_outputs=['in_out1'],\n        pass_params=['n1'],\n        pass_kwargs=['temp_idx_arr1', ('kw1', 1000)]\n    ),\n    exit_choice_func=choice_nb,\n    exit_settings=dict(\n        pass_inputs=['ts2'],\n        pass_in_outputs=['in_out2'],\n        pass_params=['n2'],\n        pass_kwargs=['temp_idx_arr2', ('kw2', 1000)]\n    ),\n    in_output_settings=dict(\n        in_out1=dict(\n            dtype=np.float64\n        ),\n        in_out2=dict(\n            dtype=np.float64\n        )\n    ),\n    in_out1=np.nan,\n    in_out2=np.nan,\n    var_args=True,\n    require_input_shape=False\n)\nmy_sig = MySignals.run(np.arange(5), np.arange(5), [0, 1], [1, 0], entry_args=(100,), exit_args=(100,))\nprint(my_sig.entries)\nprint(my_sig.exits)\nprint(my_sig.in_out1)\nprint(my_sig.in_out2)\nmy_sig[(0, 1)].plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Creating Empty Series and DataFrames with VectorBT\nDESCRIPTION: Shows how to create empty Series and DataFrames with specified dimensions and fill values using VectorBT's empty and empty_like methods.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nprint(pd.Series.vbt.empty(5, index=np.arange(10, 15), name='a', fill_value=5))\nprint(pd.DataFrame.vbt.empty((5, 3), index=np.arange(10, 15), columns=['a', 'b', 'c'], fill_value=5))\n\nprint(pd.Series.vbt.empty_like(sr2, fill_value=5))\nprint(pd.DataFrame.vbt.empty_like(df4, fill_value=5))\n```\n\n----------------------------------------\n\nTITLE: Using apply_and_concat_one Functions in VectorBT\nDESCRIPTION: Demonstrates the use of apply_and_concat_one and its Numba-accelerated version to apply a function to each item in a collection and concatenate results. Examples show usage with both Series and DataFrame values.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nprint(combine_fns.apply_and_concat_one(3, lambda i, x, a: x + a[i], sr2.values, [10, 20, 30]))\nprint(combine_fns.apply_and_concat_one_nb(3, njit(lambda i, x, a: x + a[i]), sr2.values, (10, 20, 30)))\n\nprint(combine_fns.apply_and_concat_one(3, lambda i, x, a: x + a[i], df4.values, [10, 20, 30]))\nprint(combine_fns.apply_and_concat_one_nb(3, njit(lambda i, x, a: x + a[i]), df4.values, (10, 20, 30)))\n```\n\n----------------------------------------\n\nTITLE: Cached Property Implementation\nDESCRIPTION: Shows implementation of cached property decorator with custom flags for caching behavior.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass G():\n    @decorators.cached_property(hello=\"world\", hello2=\"world2\")\n    def cache_me(self): return np.random.uniform(size=(10000, 10000))\n    \nG.cache_me.flags\n```\n\n----------------------------------------\n\nTITLE: Creating Signal Entry DataFrames in Python\nDESCRIPTION: Initializes boolean DataFrames to represent entry signals for trading strategies. Creates both small example DataFrames and large-scale (1000x1000) matrices to demonstrate performance characteristics.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nentries = pd.DataFrame({\n    'a': [True, False, False, False, False],\n    'b': [True, False, True, False, True],\n    'c': [True, True, True, False, False],\n}, index=index)\nprint(entries.shape)\n\nbig_entries = pd.DataFrame(np.full((1000, 1000), False), index=big_index)\nbig_entries.iloc[::10] = True\nprint(big_entries.shape)\n```\n\n----------------------------------------\n\nTITLE: Running Tests for vectorbt Project\nDESCRIPTION: Command to run pytest and ensure that no functionality has been broken after making changes to the project.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/contributing.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npytest\n```\n\n----------------------------------------\n\nTITLE: Exploring VectorBT Config Readonly Mode\nDESCRIPTION: Demonstrates the behavior of VectorBT's Config class in readonly mode, showing various attempted modifications and their resulting exceptions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nconf = config.Config({'a': 0, 'b': {'c': 1}}, readonly=True)\n\ntry:\n    conf['a'] = 2\nexcept Exception as e:\n    print(e)\n    \ntry:\n    del conf['a']\nexcept Exception as e:\n    print(e)\n    \ntry:\n    conf.pop('a')\nexcept Exception as e:\n    print(e)\n    \ntry:\n    conf.popitem()\nexcept Exception as e:\n    print(e)\n    \ntry:\n    conf.clear()\nexcept Exception as e:\n    print(e)\n    \ntry:\n    conf.update(a=2)\nexcept Exception as e:\n    print(e)\n    \nprint(conf.merge_with(dict(b=dict(d=2))))\n```\n\n----------------------------------------\n\nTITLE: Converting Returns to Daily Frequency\nDESCRIPTION: Demonstrates the daily() method which converts returns to daily frequency. When data is already daily, it performs no transformation. Performance is measured on large datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nprint(returns['a'].vbt.returns.daily()) # already daily, do nothing\nprint(returns.vbt.returns.daily())\n\n%timeit big_returns.vbt.returns.daily()\n```\n\n----------------------------------------\n\nTITLE: Testing Keyword Arguments with IndicatorFactory\nDESCRIPTION: Tests IndicatorFactory with keyword arguments (**kwargs) using lambda functions. Note that Numba doesn't support keyword arguments out of the box.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# test **kwargs\n# Numba doesn't support kwargs out of the box\nF = vbt.IndicatorFactory(input_names=['ts'], param_names=['p'], output_names=['out'])\nprint(F.from_apply_func(lambda ts, p, a=1: ts * p + a)\n      .run(close, [0, 1, 2], a=3).out) \n```\n\n----------------------------------------\n\nTITLE: Checking Object Types with VectorBT Accessors\nDESCRIPTION: Demonstrates how to check if pandas objects are Series or DataFrames using VectorBT's is_series and is_frame accessor methods.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nprint(sr1.vbt.is_series())\nprint(sr1.vbt.is_frame())\nprint(df1.vbt.is_series())\nprint(df2.vbt.is_frame())\n```\n\n----------------------------------------\n\nTITLE: Tuple-Based Parameter Indexing with tuple_loc\nDESCRIPTION: Demonstrates tuple-based parameter indexing using the tuple_loc accessor, which selects data based on parameter combinations. Shows selection using tuple value, tuple slice, and list of tuples.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nprint(h.tuple_loc[(0.1, 0.3)].a)\nprint(h.tuple_loc[(0.1, 0.3):(0.1, 0.3)].a.columns)\nprint(h.tuple_loc[[(0.1, 0.3), (0.1, 0.3)]].a.columns)\n```\n\n----------------------------------------\n\nTITLE: Cache Control Examples\nDESCRIPTION: Various examples of controlling cache behavior through blacklists, whitelists, and cache conditions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nG.cache_me.clear_cache(g)\nvbt.settings.caching['blacklist'].append(vbt.CacheCondition(instance=g, func='cache_me'))\n%time _ = g.cache_me(2)\n%time _ = g.cache_me(2)\nvbt.settings.caching.reset()\n```\n\n----------------------------------------\n\nTITLE: Initializing Index and Column Data in Python\nDESCRIPTION: Creates sample data structures including time indexes, column labels, and large index arrays for demonstration purposes. Sets up the foundational data structures for subsequent signal generation examples.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nindex = pd.Index([\n    datetime(2018, 1, 1),\n    datetime(2018, 1, 2),\n    datetime(2018, 1, 3),\n    datetime(2018, 1, 4),\n    datetime(2018, 1, 5)\n])\ncolumns = ['a', 'b', 'c']\nbig_index = [datetime(2018, 1, 1) + timedelta(days=i) for i in range(1000)]\n```\n\n----------------------------------------\n\nTITLE: Accessing Annual Factor for Returns Calculations\nDESCRIPTION: Shows how to retrieve the annualization factor used in calculations. This factor converts daily returns to annual metrics based on the specified year frequency.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(returns.vbt.returns.ann_factor) # default\nprint(returns.vbt.returns(year_freq='252 days').ann_factor)\n```\n\n----------------------------------------\n\nTITLE: Identifying Numba Functions in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.is_numba_func() to determine if a function is a Numba-compiled function. It checks both a regular lambda function and a Numba-compiled function.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(checks.is_numba_func(lambda x: x))\nprint(checks.is_numba_func(njit(lambda x: x)))\n```\n\n----------------------------------------\n\nTITLE: Timing Performance of VectorBT's from_order_func Method in Python\nDESCRIPTION: Measures the execution time of the from_order_func simulation method to evaluate its performance for pair trading strategy backtesting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/PairsTrading.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# How fast is vbt?\n%timeit simulate_from_order_func()\n```\n\n----------------------------------------\n\nTITLE: Using Trend Label Generator (TRENDLB) in Binary Mode\nDESCRIPTION: Demonstrates the Trend Label generator with Binary mode, using various positive and negative thresholds. Includes performance testing and shows output shape.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.TRENDLB.run(close, pos_th=pos_ths, neg_th=neg_ths, mode='Binary').labels)\n\n%timeit vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='Binary')\n\nprint(vbt.TRENDLB.run(big_close, pos_th=1, neg_th=0.5, mode='Binary').wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Class or Instance Method Decorator Example\nDESCRIPTION: Demonstrates the use of @class_or_instancemethod decorator to create methods that can be called on both class and instance.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass G():\n    @decorators.class_or_instancemethod\n    def g(self_or_cls):\n        if isinstance(self_or_cls, type):\n            print(\"class\")\n        else:\n            print(\"instance\")\n            \nG.g()\nG().g()\n```\n\n----------------------------------------\n\nTITLE: Creating Parameter-based Indexer Class in vectorbt\nDESCRIPTION: Defines a custom class H that combines PandasIndexer and ParamIndexer functionalities. Includes implementation of indexing_func for handling indexing operations and a run method that creates parameter hierarchies and mappers.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nPandasIndexer = indexing.PandasIndexer\nParamIndexer = indexing.build_param_indexer(['param1', 'param2', 'tuple'])\n\nclass H(PandasIndexer, ParamIndexer):\n    def __init__(self, a, param1_mapper, param2_mapper, tuple_mapper):\n        self.a = a\n        \n        self._param1_mapper = param1_mapper\n        self._param2_mapper = param2_mapper\n        self._tuple_mapper = tuple_mapper\n        \n        PandasIndexer.__init__(self, my_kw='PandasIndexer')\n        ParamIndexer.__init__(self, [param1_mapper, param2_mapper, tuple_mapper], my_kw='ParamIndexer')\n        \n    def indexing_func(self, pd_indexing_func, my_kw=None): \n        # As soon as you call iloc etc., performs it on each dataframe and mapper and returns a new class instance\n        print(my_kw)\n        param1_mapper = indexing.indexing_on_mapper(self._param1_mapper, self.a, pd_indexing_func)\n        param2_mapper = indexing.indexing_on_mapper(self._param2_mapper, self.a, pd_indexing_func)\n        tuple_mapper = indexing.indexing_on_mapper(self._tuple_mapper, self.a, pd_indexing_func)\n        return H(pd_indexing_func(self.a), param1_mapper, param2_mapper, tuple_mapper)\n        \n    @classmethod\n    def run(cls, a, params1, params2, level_names=('p1', 'p2')):\n        a = reshape_fns.to_2d(a)\n        # Build column hierarchy\n        params1_idx = pd.Index(params1, name=level_names[0])\n        params2_idx = pd.Index(params2, name=level_names[1])\n        params_idx = index_fns.stack_indexes((params1_idx, params2_idx))\n        new_columns = index_fns.combine_indexes((params_idx, a.columns))\n        \n        # Build mappers\n        param1_mapper = np.repeat(params1, len(a.columns))\n        param1_mapper = pd.Series(param1_mapper, index=new_columns, name=params1_idx.name)\n        \n        param2_mapper = np.repeat(params2, len(a.columns))\n        param2_mapper = pd.Series(param2_mapper, index=new_columns, name=params2_idx.name)\n        \n        tuple_mapper = list(zip(*list(map(lambda x: x.values, [param1_mapper, param2_mapper]))))\n        tuple_mapper = pd.Series(tuple_mapper, index=new_columns, name=(params1_idx.name, params2_idx.name))\n        \n        # Tile a to match the length of new_columns\n        a = array_wrapper.ArrayWrapper(a.index, new_columns, 2).wrap(reshape_fns.tile(a.values, 4, axis=1))\n        return cls(a, param1_mapper, param2_mapper, tuple_mapper)\n        \n\n# Similate an indicator with two params\nh = H.run(df4, [0.1, 0.1, 0.2, 0.2], [0.3, 0.4, 0.5, 0.6])\n\nprint(df4)\nprint(h.a)\nprint(h._param1_mapper)\nprint(h._param2_mapper)\nprint(h._tuple_mapper)\n```\n\n----------------------------------------\n\nTITLE: Identifying Pandas Objects in Python using VectorBT\nDESCRIPTION: This snippet uses checks.is_pandas() to determine if objects are pandas data structures. It checks scalar, numpy array, pandas Series, and DataFrame objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nprint(checks.is_pandas(v1))\nprint(checks.is_pandas(a1))\nprint(checks.is_pandas(sr1))\nprint(checks.is_pandas(df1))\n```\n\n----------------------------------------\n\nTITLE: Creating Large Test Dataset for Performance Testing\nDESCRIPTION: Generates a large DataFrame (10001000) with random integer values for performance benchmarking. Each row is associated with a consecutive date starting from January 1, 2018.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nbig_close = pd.DataFrame(np.random.randint(1, 10, size=(1000, 1000)).astype(float))\nbig_close.index = [datetime(2018, 1, 1) + timedelta(days=i) for i in range(1000)]\nbig_close.shape\n```\n\n----------------------------------------\n\nTITLE: Asserting Numba Function in Python with VectorBT\nDESCRIPTION: This code uses checks.assert_numba_func() to ensure that a given function is a Numba-compiled function.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_numba_func(njit(lambda x: x))\n```\n\n----------------------------------------\n\nTITLE: Cached Method Implementation\nDESCRIPTION: Demonstrates implementation of cached method decorator with arguments and custom flags.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass G():\n    @decorators.cached_method(hello=\"world\", hello2=\"world2\")\n    def cache_me(self, a): return np.random.uniform(size=(10000, 10000)) * a\n\nG.cache_me.flags\n```\n\n----------------------------------------\n\nTITLE: Plotting Trend Labels (TRENDLB) in Binary Mode\nDESCRIPTION: Visualizes the Trend Labels in Binary mode for a single column of the test data with specified positive and negative thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nvbt.TRENDLB.run(close['a'], pos_th=1, neg_th=0.5, mode='Binary').plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Creating a Configured Class in VectorBT\nDESCRIPTION: Defines a class H that inherits from config.Configured, demonstrating initialization and copying of configuration settings.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass H(config.Configured):\n    def __init__(self, a, b=2, **kwargs):\n        super().__init__(a=a, b=b, **kwargs)\n        \nprint(H(1).config)\nprint(H(1).copy(b=3).config)\nprint(H(1).copy(c=4).config)\n```\n\n----------------------------------------\n\nTITLE: Creating Symmetric DataFrames and Series\nDESCRIPTION: Shows how to create symmetric data structures using make_symmetric. This function ensures that data structures have matching index and columns, which is useful for operations requiring symmetric matrices.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.make_symmetric(sr1))\nprint(reshape_fns.make_symmetric(sr2))\nprint(reshape_fns.make_symmetric(df1))\nprint(reshape_fns.make_symmetric(df2))\nprint(reshape_fns.make_symmetric(df3))\nprint(reshape_fns.make_symmetric(df4))\nprint(reshape_fns.make_symmetric(df5))\nprint(reshape_fns.make_symmetric(pd.Series([1, 2, 3], name='yo'), sort=False))\n```\n\n----------------------------------------\n\nTITLE: Detecting Array-like Objects in Python with VectorBT\nDESCRIPTION: This code uses checks.is_any_array() to identify if objects are array-like. It checks scalar, numpy array, pandas Series, and DataFrame objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nprint(checks.is_any_array(v1))\nprint(checks.is_any_array(a1))\nprint(checks.is_any_array(sr1))\nprint(checks.is_any_array(df1))\n```\n\n----------------------------------------\n\nTITLE: Testing Column-Only Wrapper Indexing Functions\nDESCRIPTION: Examines the metadata returned by indexing_func_meta on column-only DataFrame wrappers. This shows how column-only selection mode affects the behavior of different types of row selection.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_wrapper_co.indexing_func_meta(lambda x: x.iloc[0])[1:])\nprint(df4_wrapper_co.indexing_func_meta(lambda x: x.iloc[[0]])[1:])\nprint(df4_wrapper_co.indexing_func_meta(lambda x: x.iloc[:2])[1:])\n```\n\n----------------------------------------\n\nTITLE: Asserting Object Types in Python with VectorBT\nDESCRIPTION: This code uses checks.assert_type() to verify the types of various objects, including integer, numpy array, and pandas Series.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_type(v1, int)\nchecks.assert_type(a1, np.ndarray)\nchecks.assert_type(sr1, (np.ndarray, pd.Series))\n```\n\n----------------------------------------\n\nTITLE: Asserting Metadata Equality in Python with VectorBT\nDESCRIPTION: This code uses checks.assert_meta_equal() to verify that two pandas DataFrames have the same metadata.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_meta_equal(df3, df3)\n```\n\n----------------------------------------\n\nTITLE: Using combine_multiple Functions in VectorBT\nDESCRIPTION: Demonstrates combine_multiple functions that combine multiple arrays with a single function call. Examples show both regular and Numba-accelerated versions with Series and DataFrame inputs.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nprint(combine_fns.combine_multiple((sr2.values, sr2.values*2, sr2.values*3), lambda x, y, a: x + y + a, 100))\nprint(combine_fns.combine_multiple_nb((sr2.values, sr2.values*2, sr2.values*3), njit(lambda x, y, a: x + y + a), 100))\n\nprint(combine_fns.combine_multiple((df4.values, df4.values*2, df4.values*3), lambda x, y, a: x + y + a, 100))\nprint(combine_fns.combine_multiple_nb((df4.values, df4.values*2, df4.values*3), njit(lambda x, y, a: x + y + a), 100))\n```\n\n----------------------------------------\n\nTITLE: Asserting Array Equality in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.assert_array_equal() to ensure that two arrays (or array-like objects) are equal.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_array_equal(df3, df3)\n```\n\n----------------------------------------\n\nTITLE: Broadcasting to Specific Axis of Array\nDESCRIPTION: Shows how broadcast_to_axis_of creates arrays that match specific axes of another array. Demonstrates broadcasting to different axes with examples for 1D and 2D arrays.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nprint(reshape_fns.broadcast_to_axis_of(10, np.empty((2,)), 0))\nprint(reshape_fns.broadcast_to_axis_of(10, np.empty((2,)), 1))\nprint(reshape_fns.broadcast_to_axis_of(10, np.empty((2, 3)), 0))\nprint(reshape_fns.broadcast_to_axis_of(10, np.empty((2, 3)), 1))\nprint(reshape_fns.broadcast_to_axis_of(10, np.empty((2, 3)), 2))\n```\n\n----------------------------------------\n\nTITLE: Checking Hashability in Python with VectorBT\nDESCRIPTION: This code uses checks.is_hashable() to verify if objects are hashable. It tests an integer and a numpy array containing a single integer.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nprint(checks.is_hashable(2))\nprint(checks.is_hashable(np.asarray(2)))\n```\n\n----------------------------------------\n\nTITLE: Defining Column Groups\nDESCRIPTION: Creates a MultiIndex structure for column grouping with three levels of hierarchy.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsome_columns = pd.MultiIndex.from_arrays([\n    [1, 1, 1, 1, 0, 0, 0, 0],\n    [3, 3, 2, 2, 1, 1, 0, 0],\n    [7, 6, 5, 4, 3, 2, 1, 0]\n], names=['first', 'second', 'third'])\n```\n\n----------------------------------------\n\nTITLE: Asserting Equal Length in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.assert_len_equal() to ensure that two lists have the same length.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_len_equal([[1]], [[2]])\n```\n\n----------------------------------------\n\nTITLE: Asserting Membership in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.assert_in() to verify that a value is present in a given sequence.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_in(0, (0, 1))\n```\n\n----------------------------------------\n\nTITLE: Plotting Trend Labels (TRENDLB) in BinaryContSat Mode\nDESCRIPTION: Visualizes the Trend Labels in BinaryContSat mode for a single column of the test data with specified positive and negative thresholds.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nvbt.TRENDLB.run(close['a'], pos_th=1, neg_th=0.5, mode='BinaryContSat').plot().show_svg()\n```\n\n----------------------------------------\n\nTITLE: Importing vectorbt Library\nDESCRIPTION: Imports the vectorbt library for data analysis and visualization of financial data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n```\n\n----------------------------------------\n\nTITLE: Unstacking to DataFrame with VectorBT\nDESCRIPTION: Shows how to unstack a DataFrame column to a new DataFrame using VectorBT's unstack_to_df method, transforming multi-level index data.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_72\n\nLANGUAGE: python\nCODE:\n```\nprint(df5.iloc[:, 0].vbt.unstack_to_df())\n```\n\n----------------------------------------\n\nTITLE: Asserting Number of Dimensions in Python with VectorBT\nDESCRIPTION: This code uses checks.assert_ndim() to verify the number of dimensions of various objects.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_ndim(v1, 0)\nchecks.assert_ndim(a1, 1)\nchecks.assert_ndim(df1, 2)\n```\n\n----------------------------------------\n\nTITLE: Installing vectorbt from GitHub Repository\nDESCRIPTION: Commands to uninstall any existing vectorbt installation, clone the repository, and install it in editable mode for development.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/contributing.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip uninstall vectorbt\ngit clone https://github.com/polakowo/vectorbt.git\ncd vectorbt\npip install -e .\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries\nDESCRIPTION: Imports vectorbt and other necessary Python libraries for data manipulation and visualization\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime\nfrom numba import njit\nimport itertools\nimport ipywidgets\n```\n\n----------------------------------------\n\nTITLE: Asserting Index Equality in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.assert_index_equal() to ensure that two pandas DataFrame indices are equal.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_index_equal(df3.index, df3.index)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Forward Mean (FMEAN) Indicator\nDESCRIPTION: Demonstrates the Forward Mean indicator with parameter combinations. Includes performance testing on both single window and multiple window sizes, showing the output shape for vectorized operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.FMEAN.run(close, window=(2, 3), ewm=(False, True), param_product=True).fmean)\n\n%timeit vbt.FMEAN.run(big_close, window=2)\n%timeit vbt.FMEAN.run(big_close, window=np.arange(2, 10).tolist())\n\nprint(vbt.FMEAN.run(big_close, window=np.arange(2, 10).tolist()).wrapper.shape)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Dependencies\nDESCRIPTION: Imports necessary Python libraries including NumPy for numerical operations, Pandas for data manipulation, datetime for time operations, and Numba for performance optimization.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime\nfrom numba import njit\nimport itertools\n```\n\n----------------------------------------\n\nTITLE: Index Tile Operations\nDESCRIPTION: Shows how to tile indices using the tile_index function.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nprint(index_fns.tile_index(i2, 3))\nprint(index_fns.tile_index(multi_i, 3))\n```\n\n----------------------------------------\n\nTITLE: Asserting Shape Equality in Python with VectorBT\nDESCRIPTION: This code uses checks.assert_shape_equal() to verify that objects have the same shape, with options to check specific axes.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_shape_equal(a1, sr1)\nchecks.assert_shape_equal(df2, df4, axis=0)\nchecks.assert_shape_equal(df3, df4, axis=1)\nchecks.assert_shape_equal(df2, df3, axis=(0, 1))\n```\n\n----------------------------------------\n\nTITLE: Running the Candlestick Patterns Application\nDESCRIPTION: Command to launch the candlestick patterns application using Python, which will start a Dash server on port 8050.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/apps/candlestick-patterns/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npython app.py\n```\n\n----------------------------------------\n\nTITLE: Importing VectorBT Library\nDESCRIPTION: Imports the main VectorBT library, which is required for all subsequent operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n```\n\n----------------------------------------\n\nTITLE: Using tile and repeat Methods in VectorBT\nDESCRIPTION: Demonstrates how to tile (repeat column-wise) and repeat (repeat row-wise) DataFrames using VectorBT's tile and repeat accessor methods with custom keys.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nprint(df4.vbt.tile(2, keys=['a', 'b']))\nprint(df4.vbt.repeat(2, keys=['a', 'b']))\n```\n\n----------------------------------------\n\nTITLE: Asserting Type Equality in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.assert_type_equal() to ensure that pairs of objects have the same type.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_type_equal(v1, v1)\nchecks.assert_type_equal(a1, a2)\nchecks.assert_type_equal(sr1, sr1)\nchecks.assert_type_equal(df1, df2)\n```\n\n----------------------------------------\n\nTITLE: Initializing Array Wrappers\nDESCRIPTION: Creates and configures ArrayWrapper instances for Series and DataFrame objects with various options.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsr2_wrapper = array_wrapper.ArrayWrapper.from_obj(sr2)\ndf4_wrapper = array_wrapper.ArrayWrapper.from_obj(df4)\n\nsr2_wrapper_co = sr2_wrapper.copy(column_only_select=True)\ndf4_wrapper_co = df4_wrapper.copy(column_only_select=True)\n\nsr2_grouped_wrapper = sr2_wrapper.copy(group_by=np.array([0]))\ndf4_grouped_wrapper = df4_wrapper.copy(group_by=np.array([0, 0, 1]))\n\nsr2_grouped_wrapper_co = sr2_grouped_wrapper.copy(column_only_select=True)\ndf4_grouped_wrapper_co = df4_grouped_wrapper.copy(column_only_select=True)\n```\n\n----------------------------------------\n\nTITLE: Testing Grouped Wrapper Indexing Functions\nDESCRIPTION: Tests the behavior of indexing_func_meta on grouped wrappers for both Series and DataFrames. Demonstrates how grouping affects the metadata when performing various types of slicing operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprint(sr2_grouped_wrapper.indexing_func_meta(lambda x: x.iloc[:2])[1:])\nprint(df4_grouped_wrapper.indexing_func_meta(lambda x: x.iloc[:2, 0])[1:])\nprint(df4_grouped_wrapper.indexing_func_meta(lambda x: x.iloc[:2, 1])[1:])\nprint(df4_grouped_wrapper.indexing_func_meta(lambda x: x.iloc[:2, [1]])[1:])\nprint(df4_grouped_wrapper.indexing_func_meta(lambda x: x.iloc[:2, :2])[1:])\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment for the App\nDESCRIPTION: Commands to create and activate a Python virtual environment (venv) for both Unix and Windows systems. Requires Python 3.6 or newer.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/apps/candlestick-patterns/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv venv\nsource venv/bin/activate  # Unix\nvenv\\Scripts\\activate  # Windows\n```\n\n----------------------------------------\n\nTITLE: Installing vectorbt from local source\nDESCRIPTION: Command to install vectorbt package from local source in editable mode.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/installation.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\npip install -e vectorbt\n```\n\n----------------------------------------\n\nTITLE: Benchmarking STX Performance\nDESCRIPTION: Measures the execution time of STX with different parameter formats using IPython's timeit. Compares performance between using a single value and a list of values for stop levels on larger datasets.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_64\n\nLANGUAGE: python\nCODE:\n```\n%timeit vbt.STX.run(big_entries, big_ts, 0.1)\n%timeit vbt.STX.run(big_entries, big_ts, np.full(10, 0.1).tolist())\n```\n\n----------------------------------------\n\nTITLE: Asserting Data Type Equality in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.assert_dtype_equal() to ensure that pairs of objects have the same data type.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_dtype_equal(v1, a1)\nchecks.assert_dtype_equal(a1, df1)\nchecks.assert_dtype_equal(df1, df2)\nchecks.assert_dtype_equal(df2, df3)\n```\n\n----------------------------------------\n\nTITLE: Using ColumnGrouper with DataFrame\nDESCRIPTION: Shows ColumnGrouper operations with DataFrame columns, including group management and index operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nprint(column_grouper.ColumnGrouper(df4.columns, group_by=np.array([0, 0, 1])).group_by)\nprint(column_grouper.ColumnGrouper(df4.columns, group_by=np.array([0, 0, 1])).get_groups_and_columns())\nprint(column_grouper.ColumnGrouper(df4.columns, group_by=np.array([0, 0, 1])).get_groups())\nprint(column_grouper.ColumnGrouper(df4.columns, group_by=np.array([0, 0, 1])).get_columns())\nprint(column_grouper.ColumnGrouper(df4.columns, group_by=np.array([0, 0, 1])).get_group_lens())\nprint(column_grouper.ColumnGrouper(df4.columns, group_by=np.array([0, 0, 1])).get_group_start_idxs())\nprint(column_grouper.ColumnGrouper(df4.columns, group_by=np.array([0, 0, 1])).get_group_end_idxs())\n```\n\n----------------------------------------\n\nTITLE: Cloning the Project Repository for Local Setup\nDESCRIPTION: Git commands to clone the vectorbt repository and navigate to the candlestick-patterns app directory for local development.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/apps/candlestick-patterns/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/polakowo/vectorbt.git\ncd vectorbt/apps/candlestick-patterns\n```\n\n----------------------------------------\n\nTITLE: Importing vectorbt Library\nDESCRIPTION: Imports the vectorbt library which is used for financial data analysis and backtesting.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/returns.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n```\n\n----------------------------------------\n\nTITLE: Asserting Data Type in Python with VectorBT\nDESCRIPTION: This code uses checks.assert_dtype() to verify the data type of a numpy array.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_dtype(a1, np.integer)\n```\n\n----------------------------------------\n\nTITLE: Disabling VectorBT Caching for Performance Testing in Python\nDESCRIPTION: This snippet disables the caching feature of VectorBT by setting the 'enabled' option to False. This configuration is specifically done for performance testing purposes.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Disable caching for performance testing\nvbt.settings.caching['enabled'] = False\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for the Candlestick Patterns App\nDESCRIPTION: Command to install all the required packages listed in requirements.txt for the candlestick patterns application.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/apps/candlestick-patterns/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Creating Sample Price Data for Testing\nDESCRIPTION: Generates sample price data (close, high, low, volume) for three assets over five days for testing indicator functionality.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclose = pd.DataFrame({\n    'a': [1., 2., 3., 4., 5.],\n    'b': [5., 4., 3., 2., 1.],\n    'c': [1., 2., 3., 2., 1.]\n}, index=pd.DatetimeIndex([\n    datetime(2018, 1, 1),\n    datetime(2018, 1, 2),\n    datetime(2018, 1, 3),\n    datetime(2018, 1, 4),\n    datetime(2018, 1, 5)\n]))\nnp.random.seed(42)\nhigh = close * np.random.uniform(1, 1.1, size=close.shape)\nlow = close * np.random.uniform(0.9, 1, size=close.shape)\nvolume = close * 0 + np.random.randint(1, 10, size=close.shape).astype(float)\n```\n\n----------------------------------------\n\nTITLE: Asserting Non-None Value in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.assert_not_none() to ensure that a value is not None.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_not_none(v1)\n```\n\n----------------------------------------\n\nTITLE: Stopping the Telegram Bot\nDESCRIPTION: Stops the running Telegram bot, closing connections and ending the monitoring process.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ntelegram_bot.stop()\n```\n\n----------------------------------------\n\nTITLE: Creating Test Data Structures\nDESCRIPTION: Creates various test data structures using NumPy arrays and Pandas Series/DataFrames with different shapes and index configurations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv1 = 0\na1 = np.array([1])\na2 = np.array([1, 2, 3])\na3 = np.array([[1, 2, 3]])\na4 = np.array([[1], [2], [3]])\na5 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nsr_none = pd.Series([1])\nprint(sr_none)\nsr1 = pd.Series([1], index=pd.Index(['x1'], name='i1'), name='a1')\nprint(sr1)\nsr2 = pd.Series([1, 2, 3], index=pd.Index(['x2', 'y2', 'z2'], name='i2'), name='a2')\nprint(sr2)\ndf_none = pd.DataFrame([[1]])\nprint(df_none)\ndf1 = pd.DataFrame(\n    [[1]], \n    index=pd.Index(['x3'], name='i3'), \n    columns=pd.Index(['a3'], name='c3'))\nprint(df1)\ndf2 = pd.DataFrame(\n    [[1], [2], [3]], \n    index=pd.Index(['x4', 'y4', 'z4'], name='i4'), \n    columns=pd.Index(['a4'], name='c4'))\nprint(df2)\ndf3 = pd.DataFrame(\n    [[1, 2, 3]], \n    index=pd.Index(['x5'], name='i5'), \n    columns=pd.Index(['a5', 'b5', 'c5'], name='c5'))\nprint(df3)\ndf4 = pd.DataFrame(\n    [[1, 2, 3], [4, 5, 6], [7, 8, 9]], \n    index=pd.Index(['x6', 'y6', 'z6'], name='i6'), \n    columns=pd.Index(['a6', 'b6', 'c6'], name='c6'))\nprint(df4)\n\nmulti_i = pd.MultiIndex.from_arrays([['x7', 'y7', 'z7'], ['x8', 'y8', 'z8']], names=['i7', 'i8']) \nmulti_c = pd.MultiIndex.from_arrays([['a7', 'b7', 'c7'], ['a8', 'b8', 'c8']], names=['c7', 'c8'])\ndf5 = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]], index=multi_i, columns=multi_c)\nprint(df5)\n```\n\n----------------------------------------\n\nTITLE: Asserting Level Non-Existence in Python with VectorBT\nDESCRIPTION: This code uses checks.assert_level_not_exists() to verify that a specific level does not exist in a pandas DataFrame's column multi-index.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nchecks.assert_level_not_exists(df3.columns, 'a')\n```\n\n----------------------------------------\n\nTITLE: Setting Up Conda Environment for Candlestick Patterns App\nDESCRIPTION: Commands to create and activate a conda environment with Python 3.7.6 for running the candlestick patterns application.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/apps/candlestick-patterns/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nconda create -n candlestick-patterns python=3.7.6\nconda activate candlestick-patterns\n```\n\n----------------------------------------\n\nTITLE: Unstacking Multi-Index Series to Array\nDESCRIPTION: Demonstrates converting a Series with MultiIndex into a multi-dimensional array using unstack_to_array. The method transforms hierarchical indexed series into structured arrays.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\ni = pd.MultiIndex.from_arrays([[1, 1, 2, 2], [3, 4, 3, 4], ['a', 'b', 'c', 'd']])\nsr = pd.Series([1, 2, 3, 4], index=i)\nprint(reshape_fns.unstack_to_array(sr))\n```\n\n----------------------------------------\n\nTITLE: Getting Group Lengths\nDESCRIPTION: Shows how to calculate group lengths for different array configurations using Numba-optimized functions.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nprint(column_grouper.get_group_lens_nb(np.array([0, 0, 0, 0, 1, 1, 1, 1])))\nprint(column_grouper.get_group_lens_nb(np.array([0, 1])))\nprint(column_grouper.get_group_lens_nb(np.array([0, 0])))\nprint(column_grouper.get_group_lens_nb(np.array([0])))\nprint(column_grouper.get_group_lens_nb(np.array([])))\n```\n\n----------------------------------------\n\nTITLE: Scatter Plot Implementation\nDESCRIPTION: Shows how to create and manipulate scatter plots with multiple data series\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nscatter = pd.DataFrame([[1, 2], [3, 4], [5, 6]], columns=['a', 'b']).vbt.plot(return_fig=False)\nscatter.fig\n\nscatter.update([[6, 5], [4, 3], [2, 1]])\n```\n\n----------------------------------------\n\nTITLE: Checking Series Type in Python using VectorBT\nDESCRIPTION: This snippet demonstrates the use of checks.is_series() function to determine if various objects are pandas Series. It checks different types of objects including scalar, numpy array, pandas Series, and DataFrame.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nprint(checks.is_series(v1))\nprint(checks.is_series(a1))\nprint(checks.is_series(sr1))\nprint(checks.is_series(df1))\n```\n\n----------------------------------------\n\nTITLE: Testing Wrapping Methods on Indexed Grouped Column-Only Wrappers (First Group Array)\nDESCRIPTION: Tests wrapping methods on the first indexed group (as an array) of a grouped column-only wrapper. Demonstrates how array-based selection affects the wrapping behavior.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_grouped_wrapper_co.iloc[[0]].wrap(np.array([1, 2, 3])))\nprint(df4_grouped_wrapper_co.iloc[[0]].wrap_reduced(np.array([1])))\n\nprint(df4_grouped_wrapper_co.iloc[[0]].wrap(np.array([[1, 2], [3, 4], [5, 6]]), group_by=False))\nprint(df4_grouped_wrapper_co.iloc[[0]].wrap_reduced(np.array([1, 2]), group_by=False))\n```\n\n----------------------------------------\n\nTITLE: Displaying Default OHLCV Column Names in vectorbt\nDESCRIPTION: Prints the default column names configuration for OHLCV data in vectorbt settings.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/ohlcv.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint(vbt.settings.ohlcv['column_names'])\n```\n\n----------------------------------------\n\nTITLE: Gauge Plot Implementation\nDESCRIPTION: Creates and updates a gauge plot with value range from -1 to 1\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ngauge = vbt.plotting.Gauge(value=0, value_range=(-1, 1))\ngauge.fig\n\ngauge.update(1)\n\n%timeit vbt.plotting.Gauge(value=0)\n\nbig_gauge = vbt.plotting.Gauge(value=0)\n%timeit big_gauge.update(0)\n\nipywidgets.Widget.close_all()\n```\n\n----------------------------------------\n\nTITLE: Testing Wrapping Methods on Indexed Grouped Column-Only Wrappers (First Group)\nDESCRIPTION: Tests wrap and wrap_reduced methods on the first indexed element of a grouped column-only wrapper. Shows how wrapping operations behave when applied to a specific group.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_grouped_wrapper_co.iloc[0].wrap(np.array([1, 2, 3])))\nprint(df4_grouped_wrapper_co.iloc[0].wrap_reduced(np.array([1])))\n\nprint(df4_grouped_wrapper_co.iloc[0].wrap(np.array([[1, 2], [3, 4], [5, 6]]), group_by=False))\nprint(df4_grouped_wrapper_co.iloc[0].wrap_reduced(np.array([1, 2]), group_by=False))\n```\n\n----------------------------------------\n\nTITLE: Testing Grouped Column-Only Wrapper Properties After Indexing\nDESCRIPTION: Examines the properties of grouped column-only wrappers after iloc operations. Demonstrates how the combination of grouping and column-only selection affects the structural properties.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/base.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nprint(df4_grouped_wrapper_co.iloc[0].index)\nprint(df4_grouped_wrapper_co.iloc[0].columns)\nprint(df4_grouped_wrapper_co.iloc[0].ndim)\nprint(df4_grouped_wrapper_co.iloc[0].grouped_ndim)\nprint(df4_grouped_wrapper_co.iloc[0].grouper.group_by)\n\nprint(df4_grouped_wrapper_co.iloc[1].index)\nprint(df4_grouped_wrapper_co.iloc[1].columns)\nprint(df4_grouped_wrapper_co.iloc[1].ndim)\nprint(df4_grouped_wrapper_co.iloc[1].grouped_ndim)\nprint(df4_grouped_wrapper_co.iloc[1].grouper.group_by)\n\nprint(df4_grouped_wrapper_co.iloc[[1]].index)\nprint(df4_grouped_wrapper_co.iloc[[1]].columns)\nprint(df4_grouped_wrapper_co.iloc[[1]].ndim)\nprint(df4_grouped_wrapper_co.iloc[[1]].grouped_ndim)\nprint(df4_grouped_wrapper_co.iloc[[1]].grouper.group_by)\n\nprint(df4_grouped_wrapper_co.iloc[:2].index)\nprint(df4_grouped_wrapper_co.iloc[:2].columns)\nprint(df4_grouped_wrapper_co.iloc[:2].ndim)\nprint(df4_grouped_wrapper_co.iloc[:2].grouped_ndim)\nprint(df4_grouped_wrapper_co.iloc[:2].grouper.group_by)\n```\n\n----------------------------------------\n\nTITLE: Disabling VectorBT Cache for Performance Testing\nDESCRIPTION: Disables the caching functionality in VectorBT to allow for accurate performance testing without cached results affecting measurements.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Disable caching for performance testing\nvbt.settings.caching['enabled'] = False\n```\n\n----------------------------------------\n\nTITLE: Creating Sample DataFrame\nDESCRIPTION: Generates a 100x100 DataFrame with random uniform values for testing\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/plotting.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbig_df = pd.DataFrame(np.random.uniform(size=(100, 100)).astype(float))\nbig_df.columns = list(map(str, big_df.columns))\nprint(big_df.shape)\n```\n\n----------------------------------------\n\nTITLE: Disabling VectorBT Caching\nDESCRIPTION: Disables the caching feature in VectorBT for performance testing purposes to ensure each operation is executed fresh.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Disable caching for performance testing\nvbt.settings.caching['enabled'] = False\n```\n\n----------------------------------------\n\nTITLE: Computing Rolling Z-Score with Pandas vs vectorbt\nDESCRIPTION: Demonstrates performance comparison between pandas and vectorbt for computing rolling z-scores on large datasets. Shows significant performance improvement using vectorbt's implementation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/docs/docs/getting-started/features.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> import vectorbt as vbt\n>>> import pandas as pd\n>>> import numpy as np\n>>> from numba import njit\n\n>>> big_ts = pd.DataFrame(np.random.uniform(size=(1000, 1000)))\n\n# pandas\n>>> @njit\n... def zscore_nb(x):\n...     return (x[-1] - np.mean(x)) / np.std(x)\n\n>>> %timeit big_ts.rolling(2).apply(zscore_nb, raw=True)\n482 ms  393 s per loop (mean  std. dev. of 7 runs, 1 loop each)\n\n# vectorbt\n>>> @njit\n... def vbt_zscore_nb(i, col, x):\n...     return zscore_nb(x)\n\n>>> %timeit big_ts.vbt.rolling_apply(2, vbt_zscore_nb)\n33.1 ms  1.17 ms per loop (mean  std. dev. of 7 runs, 1 loop each)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Dependencies\nDESCRIPTION: Imports necessary libraries including NumPy for numerical operations, pandas for data manipulation, datetime for date handling, and Numba for JIT compilation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/labels.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom numba import njit\n```\n\n----------------------------------------\n\nTITLE: Importing NumPy, Pandas, and DateTime Libraries in Python\nDESCRIPTION: This snippet imports NumPy for numerical operations, Pandas for data manipulation, and datetime modules for time-related functions. It also imports the njit decorator from Numba for just-in-time compilation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/signals.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom numba import njit\n```\n\n----------------------------------------\n\nTITLE: Importing VectorBT Library\nDESCRIPTION: Imports the main VectorBT library which is used for vectorized backtesting and analytics.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/indicators.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport vectorbt as vbt\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging\nDESCRIPTION: Sets up basic logging configuration with timestamp, name, level, and message format for tracking application events.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/TelegramSignals.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nlogging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)\nlogger = logging.getLogger(__name__)\n```\n\n----------------------------------------\n\nTITLE: Installing Backtrader with Matplotlib Fix\nDESCRIPTION: Installs backtrader from a specific Git commit (0fa63ef) that includes a patch to fix matplotlib compatibility issues. Uses the Git protocol to fetch the package directly from the mementum/backtrader repository.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/examples/requirements-backtrader.txt#2025-04-22_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\ngit+https://github.com/mementum/backtrader.git@0fa63ef4a35dc53cc7320813f8b15480c8f85517#egg=backtrader\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies for vectorbt Project\nDESCRIPTION: A requirements file listing all Python packages needed for the vectorbt project. It includes data manipulation libraries (numpy, pandas), dashboard components (dash, dash_bootstrap_components), server tools (gunicorn, Flask-Caching), financial analysis libraries (TA-Lib, vectorbt itself), and visualization tools (ipywidgets, matplotlib, yfinance).\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/apps/candlestick-patterns/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nnumpy>=1.21.0\npandas>=1.3.0\ndash>=1.21.0\ndash_bootstrap_components>=0.13.0\ngunicorn>=20.1.0\nFlask-Caching>=1.10.1\nTA-Lib>=0.4.21\nipywidgets>=7.6.3\nmatplotlib>=3.4.2\nvectorbt>=0.21.0\nyfinance>=0.1.62\n```\n\n----------------------------------------\n\nTITLE: Demonstrating VectorBT Config Class Usage\nDESCRIPTION: Illustrates the usage of VectorBT's Config class, including key freezing, readonly mode, and various update and modification operations.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nconf = config.Config({'a': 0, 'b': {'c': 1}}, frozen_keys=False)\nconf['b']['d'] = 2\n\nconf = config.Config({'a': 0, 'b': {'c': 1}}, frozen_keys=True)\nconf['a'] = 2\n\ntry:\n    conf['d'] = 2\nexcept Exception as e:\n    print(e)\n\ntry:\n    conf.update(d=2)\nexcept Exception as e:\n    print(e)\n    \nconf.update(d=2, force=True)\n```\n\n----------------------------------------\n\nTITLE: Importing NumPy, Pandas, and Numba\nDESCRIPTION: Imports essential data processing libraries NumPy and Pandas, along with Numba for just-in-time compilation.\nSOURCE: https://github.com/polakowo/vectorbt/blob/master/tests/notebooks/utils.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom numba import njit\n```"
  }
]