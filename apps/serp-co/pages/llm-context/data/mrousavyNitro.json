[
  {
    "owner": "mrousavy",
    "repo": "nitro",
    "content": "TITLE: Object-Oriented Hybrid Objects for Image Processing\nDESCRIPTION: Demonstration of Nitro's object-oriented approach using Image and ImageEditor interfaces. Shows how objects can be created, passed between methods, and have their own properties and methods.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Image extends HybridObject {\n  readonly width: number\n  readonly height: number\n  saveToFile(path: string): Promise<void>\n}\n\ninterface ImageEditor extends HybridObject {\n  loadImage(path: string): Promise<Image>\n  crop(image: Image, size: Size): Image\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Hybrid Object in JavaScript\nDESCRIPTION: Shows how to create and use a Hybrid Object from JavaScript using the createHybridObject method. The Math object is instantiated and its add method is called.\n\nLANGUAGE: typescript\nCODE:\n```\nconst math = NitroModules.createHybridObject<Math>(\"Math\")\nconst result = math.add(5, 7)\n```\n\n----------------------------------------\n\nTITLE: Creating Nitro Configuration\nDESCRIPTION: JSON configuration for Nitro that specifies the C++ namespace, iOS module name, Android namespace, and autolinking settings. This file should be placed in the app's root directory.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://nitro.margelo.com/nitro.schema.json\",\n  \"cxxNamespace\": [\"example\"],\n  \"ios\": {\n    \"iosModuleName\": \"NitroExample\"\n  },\n  \"android\": {\n    \"androidNamespace\": [\"example\"],\n    \"androidCxxLibName\": \"NitroExample\"\n  },\n  \"autolinking\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Hybrid Object Interface in TypeScript\nDESCRIPTION: Defines a Math interface that extends HybridObject with a property (pi) and a method (add). This TypeScript interface will be used to generate native specifications.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  readonly pi: number\n  add(a: number, b: number): number\n}\n```\n\n----------------------------------------\n\nTITLE: Type-Safety Example with Error Detection\nDESCRIPTION: Demonstration of Nitro's type safety where a Swift implementation with incorrect return type (String instead of Double) causes a compile-time error. This ensures type consistency between TypeScript interfaces and native implementations.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  add(a: number, b: number): number\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  func add(a: Double, b: Double) -> String {\n// code-error\n//  Compile-error: Expected Double! ^\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nitro Modules in TypeScript\nDESCRIPTION: This TypeScript code demonstrates how to instantiate and use a Nitro module. It creates a Math hybrid object and calls its add method, which executes the native C++ implementation.\n\nLANGUAGE: typescript\nCODE:\n```\nconst math = NitroModules.createHybridObject<Math>('Math')\nconst result = math.add(5, 3)\n```\n\n----------------------------------------\n\nTITLE: Defining Hybrid Object Interface in TypeScript\nDESCRIPTION: Example of defining a Math interface for a Hybrid Object in TypeScript using the Nitro framework. This interface declares a read-only pi property and an add method that takes two numbers and returns their sum.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  readonly pi: number\n  add(a: number, b: number): number\n}\n```\n\n----------------------------------------\n\nTITLE: Type Safety Issues in Expo Modules Due to No Code Generation\nDESCRIPTION: Demonstration of a potential type mismatch issue in Expo Modules due to lack of code generation. The TypeScript interface allows undefined values for parameter 'b' while the Swift implementation doesn't support it.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math {\n  add(a: number, b: number | undefined): number\n//  b can be undefined here: ^\n}\n\nconst math = ...\nmath.add(5, undefined)\n// code-error\n//          ^ will throw at runtime!\n```\n\nLANGUAGE: swift\nCODE:\n```\npublic class MathModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"Math\")\n\n    Function(\"add\") { (a: Double,\n                       b: Double) -> Double in\n// b CANNOT be undefined here: ^\n      return a + b\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with pnpm\nDESCRIPTION: Commands to install the Nitro Modules core package using pnpm and set up the iOS dependencies with CocoaPods.\n\nLANGUAGE: sh\nCODE:\n```\npnpm add react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hybrid Object in Swift\nDESCRIPTION: Implements the Math Hybrid Object in Swift by conforming to the auto-generated HybridMathSpec protocol. It provides the pi property and add method functionality.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  var pi: Double {\n    return Double.pi\n  }\n  func add(a: Double, b: Double) -> Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Hybrid Objects that Create Other Hybrid Objects\nDESCRIPTION: Shows how to define interfaces for Hybrid Objects that can create other Hybrid Objects, using Image and ImageFactory as examples.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Image extends HybridObject {\n  readonly width: number\n  readonly height: number\n  saveToFile(path: string): Promise<void>\n}\n\ninterface ImageFactory extends HybridObject {\n  loadImageFromWeb(path: string): Promise<Image>\n  loadImageFromFile(path: string): Image\n  loadImageFromResources(name: string): Image\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Promise<T> in TypeScript\nDESCRIPTION: This code demonstrates how to define a hybrid object interface with a Promise-returning method in TypeScript, and how to await the result. The fibonacci method returns a Promise<number> which can be awaited in JavaScript.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  fibonacci(n: number): Promise<number>\n}\n\nconst math = // ...\nawait math.fibonacci(13)\n```\n\n----------------------------------------\n\nTITLE: Defining Hybrid Object Inheritance in TypeScript\nDESCRIPTION: Shows how to define Hybrid Objects that inherit from other Hybrid Objects in TypeScript, creating a prototype chain with Media and Image objects.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Media extends HybridObject {\n  readonly width: number\n  readonly height: number\n  saveToFile(): Promise<void>\n}\n\ntype ImageFormat = 'jpg' | 'png'\ninterface Image extends HybridObject, Media {\n  readonly format: ImageFormat\n}\n\nconst image1 = NitroModules.createHybridObject<Image>('Image')\nconst image2 = NitroModules.createHybridObject<Image>('Image')\n```\n\n----------------------------------------\n\nTITLE: Defining a Math Interface in TypeScript for Nitro\nDESCRIPTION: A TypeScript interface definition for a Math object with an add method that takes two numbers and returns a number. This demonstrates Nitro's type-safe API definition.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  add(a: number, b: number): number\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hybrid Object Implementation in C++ Manually\nDESCRIPTION: Shows how to manually implement a Hybrid Object in C++ by defining the method implementations and registering them in the loadHybridMethods method.\n\nLANGUAGE: cpp\nCODE:\n```\ndouble HybridMath::add(double a, double b) {\n  return a + b;\n}\n\nvoid HybridMath::loadHybridMethods() {\n  // register base methods (toString, ...)\n  HybridObject::loadHybridMethods();\n  // register custom methods (add)\n  registerHybrids(this, [](Prototype& proto) {\n    proto.registerHybridMethod(\n      \"add\",\n      &HybridMath::add\n    );\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hybrid Object in Swift with Nitrogen\nDESCRIPTION: Shows how to implement a Hybrid Object in Swift by conforming to the auto-generated HybridMathSpec protocol created by Nitrogen.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  public var pi: Double {\n    return Double.pi\n  }\n  public func add(a: Double, b: Double) throws -> Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Null-Safety Interface Definition in TypeScript\nDESCRIPTION: Example of null-safety in Nitro through TypeScript interface definitions. This interface shows methods that return either a guaranteed number or an optional number value.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  getValue(): number\n  getValueOrNull(): number | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hybrid Object Header in C++ Manually\nDESCRIPTION: Shows how to manually implement a Hybrid Object in C++ by creating a header file that inherits from the HybridObject base class and declares the required methods.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridObject {\npublic:\n  HybridMath(): HybridObject(NAME) { }\n\npublic:\n  double add(double a, double b);\n\nprotected:\n  void loadHybridMethods() override;\n\nprivate:\n  static constexpr auto NAME = \"Math\";\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Math.add() Function Across Multiple Languages\nDESCRIPTION: Example of a simple Math interface/class implementation with an add function that takes two number parameters and returns their sum. Shows how the same functionality is expressed in TypeScript, Swift, Kotlin, and C++, demonstrating type mapping between languages.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  add(a: number, b: number): number\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath: HybridMathSpec {\n  func add(a: Double, b: Double) -> Double\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath: HybridMathSpec() {\n  fun add(a: Double, b: Double): Double\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath : public HybridMathSpec {\n  double add(double a, double b);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Base Methods of Hybrid Objects\nDESCRIPTION: Demonstrates the base methods and properties that are available on all Hybrid Objects, such as name, toString(), and equals().\n\nLANGUAGE: typescript\nCODE:\n```\nconst math = NitroModules.createHybridObject<Math>(\"Math\")\nconst anotherMath = math\n\nconsole.log(math.name) // \"Math\"\nconsole.log(math.toString()) // \"[HybridObject Math]\"\nconsole.log(math.equals(anotherMath)) // true\n```\n\n----------------------------------------\n\nTITLE: Implementing Hybrid Object in Swift\nDESCRIPTION: Implementation of the Math Hybrid Object in Swift, conforming to the HybridMathSpec protocol generated by Nitrogen. This class provides the pi property and add method declared in the TypeScript interface.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  var pi: Double {\n    return Double.pi\n  }\n  func add(a: Double, b: Double) -> Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Untyped Maps in Nitro Interface Definitions\nDESCRIPTION: Demonstrates how to avoid inefficient untyped maps (AnyMap) by using properly typed interfaces. This improves performance by enabling compile-time type checking instead of runtime checks.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BadDatabase extends HybridObject {\n  getUser(): AnyMap\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface User {\n  name: string\n  age: number\n}\ninterface GoodDatabase extends HybridObject {\n  getUser(): User\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Hybrid Object with Nitrogen for Multiple Platforms\nDESCRIPTION: Shows how to define a Hybrid Object with platform-specific implementation targets using Nitrogen's TypeScript interface with platform specification.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject<{ ios: 'swift', android: 'kotlin' }> {\n  readonly pi: number\n  add(a: number, b: number): number\n}\n```\n\n----------------------------------------\n\nTITLE: Avoiding Variants in Nitro Interface Definitions\nDESCRIPTION: Shows how to replace variant types (A | B) with separate type-specific methods. This optimization reduces runtime type checking, making native calls more efficient.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BadDatabase extends HybridObject {\n  set(value: number | string): void\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface GoodDatabase extends HybridObject {\n  setNumber(value: number): void\n  setString(value: string): void\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hybrid Object in Kotlin with Nitrogen\nDESCRIPTION: Shows how to implement a Hybrid Object in Kotlin by extending the auto-generated HybridMathSpec class created by Nitrogen.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath : HybridMathSpec() {\n  override var pi: Double\n    get() = Double.PI\n\n  override fun add(a: Double, b: Double): Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Typed Map in Kotlin with Nitro\nDESCRIPTION: Example of implementing a typed map in Kotlin using Map<String, Double> to represent a map of users with their ages in the Nitro framework. This is implemented as a method in a HybridDatabase class that extends HybridDatabaseSpec.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridDatabase: HybridDatabaseSpec() {\n  fun getAllUsers(): Map<String, Double>\n}\n```\n\n----------------------------------------\n\nTITLE: Flattening Object Parameters in Nitro Interface Methods\nDESCRIPTION: Demonstrates how to flatten unnecessarily wrapped object parameters into individual function arguments. This reduces heap allocations, particularly important for Android performance.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SetPayload {\n  key: string\n  value: string\n  onCompleted: () => void\n}\ninterface BadDatabase extends HybridObject {\n  set(payload: SetPayload): void\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface GoodDatabase extends HybridObject {\n  set(key: string,\n      value: string,\n      onCompleted: () => void): void\n}\n```\n\n----------------------------------------\n\nTITLE: TypeScript Math Interface Definition for Code Generation\nDESCRIPTION: Example TypeScript file with HybridObject interface that specifies iOS and Android native language targets, which Nitrogen will process.\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type HybridObject } from 'react-native-nitro-modules'\n\ninterface Math extends HybridObject<{ ios: 'swift', android: 'kotlin' }> {\n  add(a: number, b: number): number\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Nitro View That Uses Custom Objects as Props\nDESCRIPTION: TypeScript definition for an ImageView component that takes a custom Image hybrid object as a prop, demonstrating complex prop types in Nitro views.\n\nLANGUAGE: typescript\nCODE:\n```\nimport { type Image } from './Image.nitro.ts'\nexport interface ImageProps extends HybridViewProps {\n  image: Image\n}\nexport type ImageView = HybridView<ImageProps>\n```\n\n----------------------------------------\n\nTITLE: Implementing Proxy Results with Hybrid Objects in Nitro\nDESCRIPTION: Shows how to use Hybrid Objects for lazy data access instead of returning large data structures. This approach only converts needed data to JS, improving performance for large datasets.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AllData {\n  rows: DataRow[]\n}\n\ninterface BadDatabase extends HybridObject {\n  getAllData(): AllData\n}\n\nconst database = // ...\nconst data = database.getAllData()\nconst row = data.rows\n  .find((r) => r.name === \"Marc\")\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AllData extends HybridObject {\n  findRowWithName(name: string): DataRow\n}\n\ninterface GoodDatabase extends HybridObject {\n  getAllData(): AllData\n}\n\nconst database = // ...\nconst data = database.getAllData()\nconst row = data.findRowWithName(\"Marc\")\n```\n\n----------------------------------------\n\nTITLE: Declaring a Nitro View Component in TypeScript\nDESCRIPTION: Defines the props and methods for a CameraView component using Nitro's HybridView type system. This creates the type definitions that will be used for code generation and type safety.\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { HybridView, HybridViewProps, HybridViewMethods } from 'react-native-nitro-modules'\n\nexport interface CameraProps extends HybridViewProps {\n  enableFlash: boolean\n}\nexport interface CameraMethods extends HybridViewMethods { }\n\n// highlight-next-line\nexport type CameraView = HybridView<CameraProps, CameraMethods>\n```\n\n----------------------------------------\n\nTITLE: Implementing Camera and Image HybridObjects in Swift\nDESCRIPTION: Implements Swift classes that conform to the HybridImage and HybridCamera specifications. These classes provide the native implementation for the interfaces defined in TypeScript.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridImage: HybridImageSpec {\n  var width: Double { get }\n  var height: Double { get }\n}\n\nclass HybridCamera: HybridCameraSpec {\n  func takePhoto() -> HybridImageSpec\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing TypeScript Interface Definitions for Nitro and Turbo Modules\nDESCRIPTION: Demonstrates the TypeScript interface definitions used by Nitrogen (Nitro) and Codegen (Turbo). Both generate native interfaces from TypeScript specs but with different API approaches and module registration patterns.\n\nLANGUAGE: ts\nCODE:\n```\nexport interface Math extends HybridObject {\n  add(a: number, b: number): Promise<number>\n}\n\nexport const Math =\n  NitroModules.createHybridObject<Math>(\"Math\")\n```\n\nLANGUAGE: ts\nCODE:\n```\nexport interface Spec extends TurboModule {\n  add(a: number, b: number): Promise<number>;\n}\n\nexport const Math =\n  TurboModuleRegistry.get<Spec>(\"RTNMath\")\n    as Spec | null;\n```\n\n----------------------------------------\n\nTITLE: Defining ArrayBuffer Interface in Multiple Languages\nDESCRIPTION: Example of a hybrid interface that returns an ArrayBuffer across different languages. This demonstrates the type signatures for ArrayBuffer operations across TypeScript, Swift, Kotlin, and C++.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Image extends HybridObject {\n  getData(): ArrayBuffer\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridImage: HybridImageSpec {\n  func getData() -> ArrayBufferHolder\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridImage: HybridImageSpec() {\n  fun getData(): ArrayBuffer\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridImage: public HybridImageSpec {\n  std::shared_ptr<ArrayBuffer> getData();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Camera and Image HybridObject Interfaces in TypeScript\nDESCRIPTION: Defines TypeScript interfaces for Camera and Image as HybridObjects. The Image interface includes width and height properties, while the Camera interface has a takePhoto method that returns an Image.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Image extends HybridObject {\n  readonly width: number\n  readonly height: number\n}\n\ninterface Camera extends HybridObject {\n  takePhoto(): Image\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Type in Swift with Nitrogen\nDESCRIPTION: Shows the Swift implementation of a HybridNitro class that returns a Person object. This demonstrates how Nitrogen automatically generates the necessary bindings from the TypeScript definition.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridNitro: HybridNitroSpec {\n  func getAuthor() -> Person {\n    return Person(name: \"Marc\", age: 24)\n  }\n}\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Method in Kotlin\nDESCRIPTION: Kotlin implementation of an asynchronous method using Nitro's Promise.async pattern. Shows how to perform initial argument checking synchronously before moving heavy computation to a background thread.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMiner : HybridMinerSpec() {\n  override fun mineOneBitcoin(): Promise<Double> {\n    // 1. synchronous in here, JS Thread is still blocked\n    //    useful e.g. for argument checking before starting async Thread\n    return Promise.async {\n      // 2. asynchronous in here, JS Thread is now free\n      return computeBitcoin()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Typed Map in TypeScript with Nitro\nDESCRIPTION: Example of defining a TypeScript interface that uses a Record<string, number> to represent a map of users with their ages in the Nitro framework. This is implemented as a method in a Database interface that extends HybridObject.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Database extends HybridObject {\n  getAllUsers(): Record<string, number>\n}\n```\n\n----------------------------------------\n\nTITLE: Including Android C++ Sources in CMake\nDESCRIPTION: CMake configuration to include the C++ sources generated by Nitrogen in an Android project by importing the autogenerated CMake file.\n\nLANGUAGE: cmake\nCODE:\n```\ninclude(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroImage+autolinking.cmake)\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Method in C++\nDESCRIPTION: C++ implementation of an asynchronous method using Nitro's Promise::async pattern. Demonstrates the same pattern as other languages where computation is moved to a background thread to avoid blocking the JS thread.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMiner: public HybridMinerSpec {\n  std::shared_ptr<Promise<double>> mineOneBitcoin() override {\n    // 1. synchronous in here, JS Thread is still blocked\n    //    useful e.g. for argument checking before starting async Thread\n    return Promise<double>::async([]() {\n      // 2. asynchronous in here, JS Thread is now free\n      return computeBitcoin();\n    });\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Using ArrayBuffer for Large Data in Nitro\nDESCRIPTION: Demonstrates using ArrayBuffer instead of conventional arrays for large datasets. ArrayBuffers enable zero-copy data sharing between native and JavaScript, significantly improving performance.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BadDatabase extends HybridObject {\n  getAsBlob(): number[]\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface GoodDatabase extends HybridObject {\n  getAsBlob(): ArrayBuffer\n}\n```\n\n----------------------------------------\n\nTITLE: Throwing Errors in Synchronous Hybrid Object Methods\nDESCRIPTION: Examples of throwing errors in synchronous methods of Hybrid Objects across different languages. Each implementation checks if parameters are negative and throws an appropriate error.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  public func add(a: Double, b: Double) throws -> Double {\n    if a < 0 || b < 0 {\n      throw RuntimeError.error(\"Value cannot be negative!\")\n    }\n    return a + b\n  }\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath : HybridMathSpec() {\n  override fun add(a: Double, b: Double): Double {\n    if (a < 0 || b < 0) {\n      throw Error(\"Value cannot be negative!\")\n    }\n    return a + b\n  }\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridMathSpec {\n  double add(double a, double b) override {\n    if (a < 0 || b < 0) {\n      throw std::runtime_error(\"Value cannot be negative!\");\n    }\n    return a + b;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Using Promises for Asynchronous Operations in Nitro\nDESCRIPTION: Shows how to make long-running operations asynchronous by returning Promises. This prevents blocking the JS thread during heavy processing by enabling execution on a different thread.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BadDatabase extends HybridObject {\n  writeLargeData(data: string): void\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\ninterface GoodDatabase extends HybridObject {\n  writeLargeData(data: string): Promise<void>\n}\n```\n\n----------------------------------------\n\nTITLE: Promise Rejections in Asynchronous Hybrid Object Methods\nDESCRIPTION: Examples of throwing errors in asynchronous Promise-returning methods of Hybrid Objects. These implementations show how to reject promises by throwing errors in async blocks.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  public func add(a: Double, b: Double) throws -> Promise<Double> {\n    return Promise.async {\n      if a < 0 || b < 0 {\n        throw RuntimeError.error(\"Value cannot be negative!\")\n      }\n      return a + b\n    }\n  }\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath : HybridMathSpec() {\n  override fun add(a: Double, b: Double): Promise<Double> {\n    return Promise.async {\n      if (a < 0 || b < 0) {\n        throw Error(\"Value cannot be negative!\")\n      }\n      return@async a + b\n    }\n  }\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridMathSpec {\n  std::shared_ptr<Promise<double>> add(double a, double b) override {\n    return Promise<double>::async([=]() -> double {\n      if (a < 0 || b < 0) {\n        throw std::runtime_error(\"Value cannot be negative!\");\n      }\n      return a + b;\n    });\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Module Architecture Comparison with Mermaid Diagrams\nDESCRIPTION: Comparison of the bridging architecture between Nitro Modules and Expo Modules using Mermaid diagrams. Nitro provides a more direct path from JS to Swift, while Expo involves an additional Objective-C layer.\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: \"Nitro Modules\"\n---\ngraph LR;\n    JS--> C++ --> Swift;\n```\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: \"Expo Modules\"\n---\ngraph LR;\n    JS--> C++ --> Objective-C --> Swift;\n```\n\n----------------------------------------\n\nTITLE: Efficient Tuple Pattern with Fixed Types in TypeScript\nDESCRIPTION: A more efficient pattern using a tuple with fixed length and known types at each position, providing better type safety and performance.\n\nLANGUAGE: typescript\nCODE:\n```\ntype Values = [number, string, Person]\ninterface Math extends HybridObject {\n  calculate(values: Values): void\n}\n```\n\n----------------------------------------\n\nTITLE: Catching Rejected Promises in JavaScript\nDESCRIPTION: Example of catching errors from Hybrid Object methods in JavaScript. Uses try/catch with async/await syntax to handle errors propagated from the native side.\n\nLANGUAGE: typescript\nCODE:\n```\nconst math = // ...\ntry {\n  await math.add(-5, -1)\n} catch (error) {\n  console.log(error)\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Nitro Module and Expo Module Implementation\nDESCRIPTION: Side-by-side comparison showing how to implement a math module in Nitro versus Expo Modules. Both implement an 'add' function, but Expo Modules uses a declarative syntax with a definition function.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  func add(a: Double, b: Double) -> Double {\n    return a + b\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\npublic class MathModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"Math\")\n\n    Function(\"add\") { (a: Double,\n                       b: Double) -> Double in\n      return a + b\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Interfaces with Variants in TypeScript\nDESCRIPTION: An example of declaring a TypeScript interface that uses a variant type (union type) for a method parameter. The distance method accepts either a number or a Point object.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  distance(value: number | Point): number\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Manipulating ArrayBuffers in JavaScript\nDESCRIPTION: Example of creating and accessing an ArrayBuffer in JavaScript using the built-in ArrayBuffer constructor and Uint8Array for typed access to the buffer memory.\n\nLANGUAGE: javascript\nCODE:\n```\nconst arrayBuffer = new ArrayBuffer(4096)\nconst view = new Uint8Array(arrayBuffer)\nview[0] = 64\nview[1] = 128\nview[2] = 255\n```\n\n----------------------------------------\n\nTITLE: Comparing Event Handling in Nitro vs Turbo Modules\nDESCRIPTION: Shows how event listening and callbacks are implemented differently between frameworks. Nitro allows storing JavaScript callbacks as first-class citizens, while Turbo uses a predefined event system with sendEventWithName.\n\nLANGUAGE: swift\nCODE:\n```\nclass Math: MathSpec {\n  var listeners: [(String) -> Void] = []\n  func addListener(listener: (String) -> Void) {\n    listeners.add(listener)\n  }\n\n  func onSomethingChanged() {\n    for listener in listeners {\n      listener(\"something changed!\")\n    }\n  }\n}\n```\n\nLANGUAGE: objc\nCODE:\n```\n@implementation RTNMath\nRCT_EXPORT_MODULE();\n\n- (NSArray<NSString *> *)supportedEvents {\n  return @[@\"onSomethingChanged\"];\n}\n\n- (void)onSomethingChanged {\n  NSString* message = @\"something changed!\";\n  [self sendEventWithName:@\"onSomethingChanged\"\n                     body:@{@\"msg\": message}];\n}\n@end\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of Person Struct Converter for JSI\nDESCRIPTION: Shows how to manually implement a JSIConverter for a custom Person struct. This converter handles the conversion between JavaScript objects and C++ structs with proper type checking.\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Person {\n  std::string name;\n  double age;\n};\n\ntemplate <>\nstruct JSIConverter<Person> {\n  static Person fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n    jsi::Object obj = arg.asObject(runtime);\n    return Person(\n      JSIConverter<std::string>::fromJSI(runtime, obj.getProperty(runtime, \"name\")),\n      JSIConverter<double>::fromJSI(runtime, obj.getProperty(runtime, \"age\"))\n    );\n  }\n  static jsi::Value toJSI(jsi::Runtime& runtime, const Person& arg) {\n    jsi::Object obj(runtime);\n    obj.setProperty(runtime, \"name\", JSIConverter<std::string>::toJSI(runtime, arg.name));\n    obj.setProperty(runtime, \"age\", JSIConverter<double>::toJSI(runtime, arg.age));\n    return obj;\n  }\n  static bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {\n    if (!value.isObject())\n      return false;\n    jsi::Object obj = value.getObject(runtime);\n    if (!JSIConverter<std::string>::canConvert(runtime, obj.getProperty(runtime, \"name\")))\n      return false;\n    if (!JSIConverter<double>::canConvert(runtime, obj.getProperty(runtime, \"age\")))\n      return false;\n    return true;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Copying Non-owning ArrayBuffers in Swift\nDESCRIPTION: Example of safely copying a non-owning ArrayBuffer to create an owning copy that can be safely used across async operations and threads.\n\nLANGUAGE: swift\nCODE:\n```\nfunc doSomething(buffer: ArrayBufferHolder) {\n  // diff-add\n  let copy = ArrayBufferHolder.copy(of: buffer)\n  let data = copy.data   // <-- ✅ safe now because we have a owning copy\n  DispatchQueue.global().async {\n    let data = copy.data // <-- ✅ still safe now because we have a owning copy\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Native Module Implementation in Swift (Nitro) vs Objective-C (Turbo)\nDESCRIPTION: Shows the implementation difference between a simple math addition function in Nitro Modules using Swift and Turbo Modules using Objective-C. Nitro's implementation is more concise and uses modern Swift syntax.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  func add(a: Double, b: Double) -> Double {\n    return a + b\n  }\n}\n```\n\nLANGUAGE: objc\nCODE:\n```\n@implementation RTNMath\nRCT_EXPORT_MODULE()\n\n- (NSNumber*)add:(NSNumber*)a b:(NSNumber*)b {\n  double added = a.doubleValue + b.doubleValue;\n  return [NSNumber numberWithDouble:added];\n}\n@end\n```\n\n----------------------------------------\n\nTITLE: Converting between Swift Data and ArrayBuffers\nDESCRIPTION: Example showing how to convert between Swift's native Data type and ArrayBuffers. Shows how to create a buffer from Data and how to convert back to Data.\n\nLANGUAGE: swift\nCODE:\n```\nlet data = Data(capacity: 1024)\nlet buffer = ArrayBufferHolder.copy(data: data)\nlet dataAgain = buffer.toData(copyIfNeeded: true)\n```\n\n----------------------------------------\n\nTITLE: Creating ArrayBuffers in Kotlin\nDESCRIPTION: Example showing how to create or wrap ArrayBuffers in Kotlin. Demonstrates wrapping existing ByteBuffer without copying, creating a copy, and allocating a new buffer.\n\nLANGUAGE: kotlin\nCODE:\n```\nval myData = ByteBuffer.allocateDirect(4096)\n\n// wrap (no copy)\nval wrappingArrayBuffer = ArrayBuffer.wrap(myData)\n\n\n// copy\nlet copiedArrayBuffer = ArrayBuffer.copy(myData)\n// new blank buffer\nval newArrayBuffer = ArrayBuffer.allocate(4096)\n```\n\n----------------------------------------\n\nTITLE: Running Nitro Code Generation via PNPM\nDESCRIPTION: Command to run the nitro-codegen tool with pnpm, which generates the C++ ShadowNode and native interfaces based on the Nitro type definitions.\n\nLANGUAGE: bash\nCODE:\n```\npnpm nitro-codegen\n```\n\n----------------------------------------\n\nTITLE: Using Owning ArrayBuffers in Swift\nDESCRIPTION: Example of creating and using an owning ArrayBuffer in Swift. Owning buffers can be safely accessed as long as the reference is alive and can be used across different threads.\n\nLANGUAGE: swift\nCODE:\n```\nfunc doSomething() -> ArrayBufferHolder {\n  // highlight-next-line\n  let buffer = ArrayBufferHolder.allocate(1024 * 10)\n  let data = buffer.data   // <-- ✅ safe to do because we own it!\n  self.buffer = buffer     // <-- ✅ safe to use it later!\n  DispatchQueue.global().async {\n    let data = buffer.data // <-- ✅ also safe because we own it!\n  }\n  return buffer\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ArrayBuffers in C++\nDESCRIPTION: Example showing how to create or wrap ArrayBuffers in C++. Demonstrates wrapping existing data with a cleanup lambda, creating a copy, and allocating a new buffer.\n\nLANGUAGE: cpp\nCODE:\n```\nauto myData = new uint8_t[4096];\n\n// wrap (no copy)\nauto wrappingArrayBuffer = ArrayBuffer::wrap(myData, 4096, [=]() {\n  delete[] myData;\n});\n// copy\nauto copiedArrayBuffer = ArrayBuffer::copy(myData, 4096);\n// new blank buffer\nauto newArrayBuffer = ArrayBuffer::allocate(4096);\n```\n\n----------------------------------------\n\nTITLE: Implementing Events with Callbacks\nDESCRIPTION: Examples of how to implement an event system using callbacks in different languages. Shows how to register listeners and trigger events when conditions change.\n\nLANGUAGE: typescript\nCODE:\n```\ntype Orientation = \"portrait\" | \"landscape\"\ninterface DeviceInfo extends HybridObject {\n  listenToOrientation(onChanged: (o: Orientation) => void): void\n}\n\nconst deviceInfo = // ...\ndeviceInfo.listenToOrientation((o) => {\n  console.log(`Orientation changed to ${o}!`)\n})\n```\n\nLANGUAGE: swift\nCODE:\n```\nfunc listenToOrientation(onChanged: (Orientation) -> Void) {\n  self.listeners.append(onChanged)\n}\n\nfunc onRotate() {\n  for listener in self.listeners {\n    listener(newOrientation)\n  }\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nfun listenToOrientation(onChanged: (Orientation) -> Unit) {\n  this.listeners.add(onChanged)\n}\n\nfun onRotate() {\n  for (listener in this.listeners) {\n    listener(newOrientation)\n  }\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nvoid listenToOrientation(std::function<void(Orientation)> onChanged) {\n  this->listeners.push_back(onChanged);\n}\n\nvoid onRotate() {\n  for (const auto& listener: this->listeners) {\n    listener(newOrientation);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating ArrayBuffers in Swift\nDESCRIPTION: Example showing how to create or wrap ArrayBuffers in Swift. Demonstrates wrapping existing data without copying, creating a copy, and allocating a new buffer.\n\nLANGUAGE: swift\nCODE:\n```\nlet myData = UnsafeMutablePointer<UInt8>.allocate(capacity: 4096)\n\n// wrap (no copy)\nlet wrappingArrayBuffer = ArrayBufferHolder.wrap(dataWithoutCopy: myData,\n                                                 size: 4096,\n                                                 onDelete: { myData.deallocate() })\n// copy\nlet copiedArrayBuffer = ArrayBufferHolder.copy(of: wrappingArrayBuffer)\n// new blank buffer\nlet newArrayBuffer = ArrayBufferHolder.allocate(size: 4096)\n```\n\n----------------------------------------\n\nTITLE: Implementing Callbacks with Return Values\nDESCRIPTION: Examples of how to implement callbacks that return values between TypeScript and Swift. Return values from callbacks are wrapped in Promises that need to be awaited.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  some(getValue: () => number): void\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nfunc some(getValue: () -> Promise<Double>) {\n  Task {\n    let promise = getValue()\n    let valueFromJs = try await promise.await()\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Promise<T> in Kotlin with Coroutines\nDESCRIPTION: This example demonstrates how to create a Promise<T> in Kotlin using Nitro's Promise type with coroutine syntax. The fibonacci function runs on a separate thread and can use suspending coroutine functions.\n\nLANGUAGE: kotlin\nCODE:\n```\nfun fibonacci(n: Double): Promise<Double> {\n  return Promise.async {\n    // This runs on a separate Thread, and can use suspending coroutine functions!\n    return calculateFibonacciSequence(n)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating C++ Header for Hybrid Object\nDESCRIPTION: C++ header file defining a HybridMath class that inherits from HybridObject, declaring the add method and necessary overrides.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridObject {\npublic:\n  HybridMath(): HybridObject(NAME) { }\n\npublic:\n  double add(double a, double b);\n\nprotected:\n  void loadHybridMethods() override;\n\nprivate:\n  static constexpr auto NAME = \"Math\";\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Interfaces with Nitrogen in TypeScript\nDESCRIPTION: Shows how to define a custom interface (Person) and integrate it with Nitro in TypeScript. This allows Nitrogen to automatically generate type-safe struct representations in native languages.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Person {\n  name: string\n  age: number\n}\n\ninterface Nitro extends HybridObject {\n  getAuthor(): Person\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Promise<T> in C++ with Thread Pool\nDESCRIPTION: This snippet shows how to create a Promise<T> in C++ using Nitro's Promise type with an asynchronous thread pool. The fibonacci function creates a lambda that runs on a separate thread.\n\nLANGUAGE: cpp\nCODE:\n```\nstd::shared_ptr<Promise<double>> fibonacci(double n) {\n  return Promise<double>::async([=]() -> double {\n    // This runs on a separate Thread!\n    return calculateFibonacciSequence(n);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Nitrogen Files to iOS Podspec\nDESCRIPTION: Ruby code for a local Podspec that includes the autolinking code generated by Nitrogen for iOS projects.\n\nLANGUAGE: ruby\nCODE:\n```\nload 'nitrogen/generated/ios/NitroExample+autolinking.rb'\nadd_nitrogen_files(s)\n```\n\n----------------------------------------\n\nTITLE: Defining Enum Types with TypeScript in Nitrogen\nDESCRIPTION: Demonstrates how to define and use a TypeScript enum (Gender) with Nitrogen. Enums are represented as integers in the native bridge for efficient conversion.\n\nLANGUAGE: typescript\nCODE:\n```\nenum Gender {\n  MALE,\n  FEMALE\n}\ninterface Person extends HybridObject {\n  getGender(): Gender\n}\n```\n\n----------------------------------------\n\nTITLE: Preventing Stale Promises in Swift with Static Enforcement\nDESCRIPTION: This example demonstrates Nitro's static enforcement to prevent stale promises in Swift. The code shows an error where a function incorrectly returns void instead of properly resolving or rejecting the promise.\n\nLANGUAGE: swift\nCODE:\n```\nfunc saveToFile(image: HybridImage) -> Promise<Void> {\n  guard let data = image.data else { return }\n  // code-error\n                                     ^ // Error: Cannot return void!\n  return Promise.async {\n    try await data.writeToFile(\"file://tmp/img.png\")\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Returns in Hybrid Objects Across Languages\nDESCRIPTION: Demonstrates how array return types are represented in different languages when implementing hybrid objects. Shows the equivalent syntax for arrays of User objects in TypeScript, Swift, Kotlin, and C++.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Contacts extends HybridObject {\n  getAllUsers(): User[]\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridContacts: HybridContactsSpec {\n  fun getAllUsers() -> Array<User>\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridContacts: HybridContactsSpec() {\n  fun getAllUsers(): Array<User>\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridContacts : public HybridContactsSpec {\n  std::vector<User> getAllUsers();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Callbacks in Different Languages\nDESCRIPTION: Examples of how callbacks are represented in TypeScript, Swift, Kotlin, and C++. Each language has its own syntax for defining and implementing callbacks.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Server extends HybridObject {\n  start(onNewUserJoined: (user: User) => void): void\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nfunc start(onNewUserJoined: (User) -> Void) {\n  onNewUserJoined(user)\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nfun start(onNewUserJoined: (User) -> Unit) {\n  onNewUserJoined(user)\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nvoid start(std::function<void(User)> onNewUserJoined) {\n  onNewUserJoined(user);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Fetch Interface with AnyMap Return Type in TypeScript\nDESCRIPTION: TypeScript interface definition for a Fetch object that extends HybridObject with a get method that returns an AnyMap.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Fetch extends HybridObject {\n  get(url: string): AnyMap\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous Callbacks\nDESCRIPTION: Examples of implementing synchronous callbacks between TypeScript and Swift by wrapping them in the Sync<T> type. This allows direct calling without Promise handling but requires thread safety.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  some(getValue: Sync<() => number>): void\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nfunc some(getValue: () -> Double) {\n  let valueFromJs = getValue()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fetch Class with AnyMap Return Type in Kotlin\nDESCRIPTION: Kotlin class implementation for HybridFetch that extends HybridFetchSpec with a get method returning an AnyMap.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridFetch: HybridFetchSpec() {\n  fun get(url: String): AnyMap\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fetch Class with AnyMap Return Type in Swift\nDESCRIPTION: Swift class implementation for HybridFetch that conforms to HybridFetchSpec with a get method returning an AnyMapHolder.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridFetch: HybridFetchSpec {\n  func get(url: String) -> AnyMapHolder\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Values Asynchronously with MMKV in React Native\nDESCRIPTION: Example showing how a synchronous method would look if implemented asynchronously, demonstrating the additional complexity of state management and useEffect to handle the Promise resolution.\n\nLANGUAGE: typescript\nCODE:\n```\nfunction App() {\n  const mmkv = new MMKV()\n  const [name, setName] = useState(undefined)\n\n  useEffect(() => {\n    (async () => {\n      const n = await mmkv.getString('username') // --> Marc\n      setName(n)\n    })()\n  }, [])\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitrogen with npm\nDESCRIPTION: Command to install the Nitrogen code generator (named nitro-codegen) using npm as a development dependency.\n\nLANGUAGE: sh\nCODE:\n```\nnpm i nitro-codegen --save-dev\n```\n\n----------------------------------------\n\nTITLE: Implementing a Typed Map in C++ with Nitro\nDESCRIPTION: Example of implementing a typed map in C++ using std::unordered_map<std::string, double> to represent a map of users with their ages in the Nitro framework. This is implemented as a method in a HybridDatabase class that inherits from HybridDatabaseSpec.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridDatabase: public HybridDatabaseSpec {\n  std::unordered_map<std::string, double> getAllUsers();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Method in Swift\nDESCRIPTION: Swift implementation of an asynchronous method using Nitro's Promise.async pattern. The code demonstrates how to free the JS thread while performing a computationally intensive operation.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMiner : HybridMinerSpec {\n  public func mineOneBitcoin() throws -> Promise<Double> {\n    // 1. synchronous in here, JS Thread is still blocked\n    //    useful e.g. for argument checking before starting async Thread\n    return Promise.async {\n      // 2. asynchronous in here, JS Thread is now free\n      return computeBitcoin()\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional Values in TypeScript with Nitro\nDESCRIPTION: Demonstrates how to declare optional properties in TypeScript interfaces using either the question mark operator or union with undefined. This is used in hybrid objects within the Nitro framework.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  a?: number\n  b: number | undefined\n}\n```\n\n----------------------------------------\n\nTITLE: Using Non-owning ArrayBuffers in Swift\nDESCRIPTION: Example of safely handling a non-owning ArrayBuffer received from JavaScript. Non-owning buffers can only be safely accessed within the synchronous function call.\n\nLANGUAGE: swift\nCODE:\n```\nfunc doSomething(buffer: ArrayBufferHolder) {\n  let data = buffer.data   // <-- ✅ safe to do because we're still sync\n  DispatchQueue.global().async {\n    // code-error\n    let data = buffer.data // <-- ❌ NOT safe\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Values in Swift with Nitro\nDESCRIPTION: Shows how to implement optional properties in Swift classes using the optional type syntax. Both properties are marked as optional using the question mark operator for Double values.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath: HybridMathSpec {\n  var a: Double?\n  var b: Double?\n}\n```\n\n----------------------------------------\n\nTITLE: Converting between Kotlin ByteBuffer and ArrayBuffers\nDESCRIPTION: Example showing how to convert between Kotlin's native ByteBuffer type and ArrayBuffers. Shows how to create a buffer from ByteBuffer and how to convert back to ByteBuffer.\n\nLANGUAGE: kotlin\nCODE:\n```\nval data = ByteBuffer.allocateDirect(1024)\nval buffer = ArrayBuffer.copy(data)\nval dataAgain = buffer.getBuffer(copyIfNeeded = true)\n```\n\n----------------------------------------\n\nTITLE: Using Variants with Good Naming Convention in TypeScript\nDESCRIPTION: A better approach to defining variant types by creating a named type alias. This improves readability in the generated code for Swift and Kotlin.\n\nLANGUAGE: typescript\nCODE:\n```\nexport type MathOutput = string | number\nexport interface Math extends HybridObject {\n  calculate(): MathOutput\n}\n```\n\n----------------------------------------\n\nTITLE: Converting between C++ Vector and ArrayBuffers\nDESCRIPTION: Example showing how to convert between C++'s std::vector<uint8_t> and ArrayBuffers. Demonstrates creating a buffer from a vector with a note about conversion back requiring a copy.\n\nLANGUAGE: cpp\nCODE:\n```\nstd::vector<uint8_t> data;\nauto buffer = ArrayBuffer::copy(data);\n/* convert back to vector would be a copy. */\n```\n\n----------------------------------------\n\nTITLE: Creating Promise<T> in Swift with Async/Await\nDESCRIPTION: This snippet shows how to create a Promise<T> in Swift using Nitro's Promise type with async/await syntax. The fibonacci function runs on a separate thread and can use Swift's await syntax internally.\n\nLANGUAGE: swift\nCODE:\n```\nfunc fibonacci(n: Double) -> Promise<Double> {\n  return Promise.async {\n    // This runs on a separate Thread, and can use `await` syntax!\n    return try await calculateFibonacciSequence(n)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Autolinking in nitro.json\nDESCRIPTION: JSON configuration for autolinking the native view implementations to the JavaScript component. This maps the CameraView to its Swift and Kotlin implementations.\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"autolinking\": {\n    \"CameraView\": {\n      \"swift\": \"HybridCameraView\",\n      \"kotlin\": \"HybridCameraView\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nitro Hybrid Objects with Worklets Core\nDESCRIPTION: Demonstrates how to box a Nitro Hybrid Object and use it in a react-native-worklets-core context. The example creates a Math hybrid object, boxes it for transfer, and then unboxes it within a worklet context to call the add method.\n\nLANGUAGE: typescript\nCODE:\n```\nconst math = NitroModules.createHybridObject<Math>('Math')\nconst boxed = NitroModules.box(math)\n\nconst context = Worklets.createContext('DummyContext')\ncontext.runAsync(() => {\n  'worklet'\n  const unboxed = boxed.unbox()\n  console.log(unboxed.add(5, 3)) // --> 8\n})\n```\n\n----------------------------------------\n\nTITLE: Using Custom Object Props with Nitro Views\nDESCRIPTION: Example of loading an image and passing it to an ImageView component, demonstrating how to use complex prop types with Nitro views.\n\nLANGUAGE: jsx\nCODE:\n```\nfunction App() {\n  const image = await loadImage('https://...')\n  return <ImageView image={image} />\n}\n```\n\n----------------------------------------\n\nTITLE: Using Nitro Hybrid Objects with Reanimated\nDESCRIPTION: Shows how to use a Nitro Hybrid Object within a react-native-reanimated UI thread context. Similar to the Worklets Core example, it creates a Math hybrid object, boxes it, and then uses it within a runOnUI worklet.\n\nLANGUAGE: typescript\nCODE:\n```\nconst math = NitroModules.createHybridObject<Math>('Math')\nconst boxed = NitroModules.box(math)\n\nrunOnUI(() => {\n  'worklet'\n  const unboxed = boxed.unbox()\n  console.log(unboxed.add(5, 3)) // --> 8\n})()\n```\n\n----------------------------------------\n\nTITLE: Implementing Update Lifecycle Methods in Swift\nDESCRIPTION: Swift implementation showing how to override beforeUpdate and afterUpdate methods to batch prop changes in a Nitro view.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridCameraView : HybridCameraViewSpec {\n  // View\n  var view: UIView = UIView()\n\n  func beforeUpdate() { }\n  func afterUpdate() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Runtime Dispatcher for Nitro\nDESCRIPTION: Example of implementing a custom Dispatcher class for Nitro to support asynchronous operations in a custom JS runtime. The dispatcher must implement runSync and runAsync methods to execute callbacks in the runtime's thread.\n\nLANGUAGE: cpp\nCODE:\n```\n#include <NitroModules/Dispatcher.hpp>\nusing namespace margelo::nitro;\n\nclass MyRuntimeDispatcher: public Dispatcher {\npublic:\n  void runSync(std::function<void()>&& function) override;\n  void runAsync(std::function<void()>&& function) override;\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing a Nitro View Component for JavaScript\nDESCRIPTION: JavaScript code to initialize the Nitro view component for use in React Native apps. This uses getHostComponent to create a component that can be rendered in JSX.\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getHostComponent } from 'react-native-nitro-modules'\nimport CameraViewConfig from '../nitrogen/generated/shared/json/CameraViewConfig.json'\n\nexport const Camera = getHostComponent<CameraProps, CameraMethods>(\n  'Camera',\n  () => CameraViewConfig\n)\n```\n\n----------------------------------------\n\nTITLE: Installing a Custom Dispatcher into a Runtime\nDESCRIPTION: Shows how to install a custom dispatcher into a JavaScript runtime for Nitro to use. This must be done as soon as possible after creating the runtime to enable asynchronous operations.\n\nLANGUAGE: cpp\nCODE:\n```\nauto myDispatcher = std::make_shared<MyRuntimeDispatcher>();\nDispatcher::installRuntimeGlobalDispatcher(myRuntime, myDispatcher);\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Hybrid Object for Nitro View Props\nDESCRIPTION: TypeScript definition for a custom Image hybrid object that can be used as a prop in a Nitro view component.\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Image extends HybridObject {\n  readonly width: number\n  readonly height: number\n  save(): Promise<string>\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro with a Dispatcher in a Custom JSI Environment\nDESCRIPTION: This snippet demonstrates how to manually install Nitro in a custom JSI environment using a Dispatcher. The Dispatcher implementation must properly handle thread management for accessing the JSI runtime.\n\nLANGUAGE: cpp\nCODE:\n```\n#include <jsi/jsi.h>\n#include <NitroModules/InstallNitro.hpp>\n#include <NitroModules/Dispatcher.hpp>\n\njsi::Runtime& runtime = ...\nstd::shared_ptr<Dispatcher> dispatcher = ...\nmargelo::nitro::install(runtime, dispatcher);\n```\n\n----------------------------------------\n\nTITLE: Implementing Update Lifecycle Methods in Kotlin\nDESCRIPTION: Kotlin implementation showing how to override beforeUpdate and afterUpdate methods to batch prop changes in a Nitro view.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridCameraView : HybridCameraViewSpec() {\n  // View\n  override val view: View = View(NitroModules.applicationContext)\n\n  override fun beforeUpdate() { }\n  override fun afterUpdate() { }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro without a Dispatcher in a Custom JSI Environment\nDESCRIPTION: This snippet shows how to install Nitro without a Dispatcher. In this configuration, synchronous methods will work normally, but asynchronous methods or callbacks will throw an error since there's no Dispatcher to handle thread management.\n\nLANGUAGE: cpp\nCODE:\n```\n#include <jsi/jsi.h>\n#include <NitroModules/InstallNitro.hpp>\n\njsi::Runtime& runtime = ...\nmargelo::nitro::install(runtime);\n```\n\n----------------------------------------\n\nTITLE: Adding Method Definitions to a Nitro View\nDESCRIPTION: TypeScript definition showing how to add methods to a Nitro view component by extending the HybridViewMethods interface.\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface CameraProps extends HybridViewProps { ... }\nexport interface CameraMethods extends HybridViewMethods {\n  takePhoto(): Promise<Image>\n}\n\nexport type CameraView = HybridView<CameraProps, CameraMethods>\n```\n\n----------------------------------------\n\nTITLE: Basic Nitro Configuration Structure in JSON\nDESCRIPTION: The foundational structure of a nitro.json configuration file showing all major configuration sections including cxxNamespace, ios, android, autolinking, and other settings. This is the base template for setting up a Nitro module.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://nitro.margelo.com/nitro.schema.json\",\n  \"cxxNamespace\": [\"$$cxxNamespace$$\"],\n  \"ios\": {\n    \"iosModuleName\": \"$$iosModuleName$$\"\n  },\n  \"android\": {\n    \"androidNamespace\": [\"$$androidNamespace$$\"],\n    \"androidCxxLibName\": \"$$androidCxxLibName$$\"\n  },\n  \"autolinking\": {},\n  \"ignorePaths\": [\"**/node_modules\"],\n  \"createGitAttributes\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Methods on a Nitro View Component\nDESCRIPTION: Example of getting a reference to a Nitro view component and calling a method on it using the hybridRef prop and the wrapped function syntax.\n\nLANGUAGE: jsx\nCODE:\n```\nfunction App() {\n  return (\n    <Camera\n      hybridRef={{\n        f: (ref) => {\n          const image = ref.takePhoto()\n        }\n      }}\n    />\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring iOS Module Name in Nitro\nDESCRIPTION: Shows how to set the iOS module name in nitro.json for clang module naming and its relationship to CocoaPods podspec naming. The module name is used when the Nitro Module is distributed as a CocoaPod.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"ios\": {\n    \"iosModuleName\": \"NitroMath\"\n  }\n}\n```\n\nLANGUAGE: ruby\nCODE:\n```\nPod::Spec.new do |s|\n  s.name         = \"NitroMath\"\n  # ...\n```\n\n----------------------------------------\n\nTITLE: Running Nitro Code Generation via Bun\nDESCRIPTION: Command to run the nitro-codegen tool with bun, which generates the C++ ShadowNode and native interfaces based on the Nitro type definitions.\n\nLANGUAGE: bash\nCODE:\n```\nbun nitro-codegen\n```\n\n----------------------------------------\n\nTITLE: Configuring Android Namespace in Nitro\nDESCRIPTION: Shows how to configure androidNamespace in nitro.json for Java/Kotlin file generation. Similar to cxxNamespace, this sets the package structure for generated code and should align with the namespace in build.gradle.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"android\": {\n    \"androidNamespace\": [\"math\", \"extra\"]\n  }\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\npackage com.margelo.nitro.image\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Running Nitro Code Generation via NPM\nDESCRIPTION: Command to run the nitro-codegen tool with npm, which generates the C++ ShadowNode and native interfaces based on the Nitro type definitions.\n\nLANGUAGE: bash\nCODE:\n```\nnpx nitro-codegen\n```\n\n----------------------------------------\n\nTITLE: Configuring Android C++ Library Name in Nitro\nDESCRIPTION: Demonstrates how to set the androidCxxLibName in nitro.json which specifies the native C++ library name for JNI. This name should match the library defined in CMakeLists.txt when using CMake for Android builds.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"android\": {\n    \"androidCxxLibName\": \"NitroMath\"\n  }\n}\n```\n\nLANGUAGE: cmake\nCODE:\n```\nproject(NitroMath)\nadd_library(NitroMath SHARED\n        src/main/cpp/cpp-adapter.cpp\n        ../cpp/HybridMath.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Rendering a Nitro View Component in React\nDESCRIPTION: Example of rendering the Camera component in a React component with the enableFlash prop set to true.\n\nLANGUAGE: jsx\nCODE:\n```\nfunction App() {\n  return <Camera enableFlash={true} />\n}\n```\n\n----------------------------------------\n\nTITLE: Using Variants with Poor Naming Convention in TypeScript\nDESCRIPTION: An example of a TypeScript interface that uses an inline variant type for a method return value. This approach is marked as a bad practice due to readability issues in generated code.\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Math extends HybridObject {\n  calculate(): string | number\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Autolinking for Hybrid Objects in Nitro\nDESCRIPTION: Shows how to configure autolinking for Hybrid Objects in nitro.json. This example demonstrates linking a 'Math' object to its C++ implementation 'HybridMath', which Nitrogen will use to generate appropriate registration code.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"autolinking\": {\n    \"Math\": {\n      \"cpp\": \"HybridMath\"\n    }\n  }\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nHybridObjectRegistry::registerHybridObjectConstructor(\n  \"Math\",\n  []() -> std::shared_ptr<HybridObject> {\n    return std::make_shared<HybridMath>();\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Registering Hybrid Object Constructor in C++\nDESCRIPTION: C++ code to register a constructor function for the HybridMath object with the HybridObjectRegistry, typically called during app startup.\n\nLANGUAGE: cpp\nCODE:\n```\nHybridObjectRegistry::registerHybridObjectConstructor(\n  \"Math\",\n  []() -> std::shared_ptr<HybridObject> {\n    return std::make_shared<HybridMath>();\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Accessing Values Synchronously with MMKV in React Native\nDESCRIPTION: Example of a synchronous method call to retrieve a value from MMKV storage. This demonstrates the simplicity of using synchronous methods when retrieving data that can be returned immediately without blocking the JS thread for too long.\n\nLANGUAGE: typescript\nCODE:\n```\nfunction App() {\n  const mmkv = new MMKV()\n  const name = mmkv.getString('username') // --> Marc\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing C++ Methods for Hybrid Object\nDESCRIPTION: C++ implementation file for the HybridMath class, defining the add method and registering it as a hybrid method in loadHybridMethods.\n\nLANGUAGE: cpp\nCODE:\n```\ndouble HybridMath::add(double a, double b) {\n  return a + b;\n}\n\nvoid HybridMath::loadHybridMethods() {\n  // register base methods (toString, ...)\n  HybridObject::loadHybridMethods();\n  // register custom methods (add)\n  registerHybrids(this, [](Prototype& proto) {\n    proto.registerHybridMethod(\n      \"add\",\n      &HybridMath::add\n    );\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous Method in Nitro Interface\nDESCRIPTION: TypeScript interface declaration for a Hybrid Object with an asynchronous method that returns a Promise. This pattern is used for heavy operations that would block the JS thread if executed synchronously.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Miner extends HybridObject {\n  mineOneBitcoin(): Promise<number>\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Swift/Kotlin Hybrid Objects in nitro.json\nDESCRIPTION: JSON configuration for registering the Swift and Kotlin implementations of a Hybrid Object in the autolinking section of nitro.json.\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...\n  \"autolinking\": {\n    \"Math\": {\n      \"swift\": \"HybridMath\",\n      \"kotlin\": \"HybridMath\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Nitro Code Generation via Yarn\nDESCRIPTION: Command to run the nitro-codegen tool with yarn, which generates the C++ ShadowNode and native interfaces based on the Nitro type definitions.\n\nLANGUAGE: bash\nCODE:\n```\nyarn nitro-codegen\n```\n\n----------------------------------------\n\nTITLE: Including Android Autolinking in Gradle\nDESCRIPTION: Gradle configuration to include the Java/Kotlin sources generated by Nitrogen in an Android project by applying the autogenerated gradle file.\n\nLANGUAGE: groovy\nCODE:\n```\napply from: '../nitrogen/generated/android/NitroExample+autolinking.gradle'\n```\n\n----------------------------------------\n\nTITLE: Implementing a Nitro View in Swift\nDESCRIPTION: Swift implementation of the CameraView that extends from the generated spec class. This class handles the native view implementation and manages the enableFlash property.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridCameraView : HybridCameraViewSpec {\n  // Props\n  var enableFlash: Bool = false\n\n  // View\n  var view: UIView = UIView()\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitrogen with pnpm\nDESCRIPTION: Command to install the Nitrogen code generator (named nitro-codegen) using pnpm as a development dependency.\n\nLANGUAGE: sh\nCODE:\n```\npnpm add nitro-codegen -D\n```\n\n----------------------------------------\n\nTITLE: Implementing a Nitro View in Kotlin\nDESCRIPTION: Kotlin implementation of the CameraView that extends from the generated spec class. This class handles the native view implementation and manages the enableFlash property.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridCameraView(val context: ThemedReactContext) : HybridCameraViewSpec() {\n  // Props\n  override var enableFlash: Boolean = false\n\n  // View\n  override val view: View = View(context)\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitrogen with yarn\nDESCRIPTION: Command to install the Nitrogen code generator (named nitro-codegen) using yarn as a development dependency.\n\nLANGUAGE: sh\nCODE:\n```\nyarn add nitro-codegen -D\n```\n\n----------------------------------------\n\nTITLE: Installing Nitrogen with bun\nDESCRIPTION: Command to install the Nitrogen code generator (named nitro-codegen) using bun as a development dependency.\n\nLANGUAGE: sh\nCODE:\n```\nbun i nitro-codegen -d\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with bun\nDESCRIPTION: Commands to install the Nitro Modules core package using bun and set up the iOS dependencies with CocoaPods.\n\nLANGUAGE: sh\nCODE:\n```\nbun i react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Creating TypeScript Nitro Specification\nDESCRIPTION: TypeScript interface defining a Math Hybrid Object with a pi property and an add method. This specification will be used by Nitrogen to generate native code for iOS and Android.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject<{ ios: 'swift', android: 'kotlin' }> {\n  readonly pi: number\n  add(a: number, b: number): number\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with yarn\nDESCRIPTION: Commands to install the Nitro Modules core package using yarn and set up the iOS dependencies with CocoaPods.\n\nLANGUAGE: sh\nCODE:\n```\nyarn add react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Running Nitrogen Code Generator\nDESCRIPTION: Command to execute the Nitrogen code generator, which will generate native Swift and Kotlin protocols based on the TypeScript specifications.\n\nLANGUAGE: sh\nCODE:\n```\nnpx nitro-codegen\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with npm\nDESCRIPTION: Commands to install the Nitro Modules core package using npm and set up the iOS dependencies with CocoaPods.\n\nLANGUAGE: sh\nCODE:\n```\nnpm i react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Adding Local Pod to Podfile\nDESCRIPTION: Ruby code for adding a local Pod to the Podfile, referencing the iOS module created with Nitrogen.\n\nLANGUAGE: ruby\nCODE:\n```\npod '$$iosModuleName$$', :path => '../'\n```\n\n----------------------------------------\n\nTITLE: C++ JNI OnLoad Implementation for Android Integration\nDESCRIPTION: Example of a C++ JNI_OnLoad implementation that initializes the native module for Android.\n\nLANGUAGE: cpp\nCODE:\n```\n#include <jni.h>\n#include \"NitroMathOnLoad.hpp\"\n\nJNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void*) {\n  return margelo::nitro::math::initialize(vm);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Local Android Library Dependency\nDESCRIPTION: Groovy code for adding a local Android library as a dependency in the app's build.gradle file.\n\nLANGUAGE: groovy\nCODE:\n```\n// ...\ndependencies {\n  // ...\n  implementation project(':your-local-library')\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Hybrid Objects in nitro.json\nDESCRIPTION: Configuration examples showing how to register Hybrid Objects for Swift/Kotlin or C++ implementation in the autolinking section of nitro.json.\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...\n  \"autolinking\": {\n    \"Math\": {\n      \"swift\": \"HybridMath\",\n      \"kotlin\": \"HybridMath\"\n    }\n  }\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...\n  \"autolinking\": {\n    \"Math\": {\n      \"cpp\": \"HybridMath\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Including Local Library in settings.gradle\nDESCRIPTION: Groovy code for including a local library in the Android app's settings.gradle file.\n\nLANGUAGE: groovy\nCODE:\n```\ninclude ':your-local-library'\n```\n\n----------------------------------------\n\nTITLE: C++ Declaration and Implementation of Math Hybrid Object\nDESCRIPTION: Example C++ header and implementation files for the HybridMath class that inherits from the generated HybridMathSpec.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridMathSpec {\npublic:\n  HybridMath(): HybridObject(TAG) {}\npublic:\n  double add(double a, double b) override;\n};\n```\n\nLANGUAGE: cpp\nCODE:\n```\ndouble HybridMath::add(double a, double b) {\n  return a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HybridMathSpec in Swift\nDESCRIPTION: Swift class that implements the HybridMathSpec protocol generated by Nitrogen, providing a pi property and an add method.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  public var pi: Double {\n    return Double.pi\n  }\n  public func add(a: Double, b: Double) throws -> Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Kotlin Implementation of Math Hybrid Object\nDESCRIPTION: Example Kotlin class that extends the generated HybridMathSpec base class, implementing the add method.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath : HybridMathSpec() {\n  override fun add(a: Double, b: Double): Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HybridMathSpec in Kotlin\nDESCRIPTION: Kotlin class that implements the HybridMathSpec class generated by Nitrogen, providing a pi property and an add method.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath : HybridMathSpec() {\n  override var pi: Double\n    get() = Double.PI\n\n  override fun add(a: Double, b: Double): Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitrogen with Package Managers\nDESCRIPTION: Commands for installing nitro-codegen (Nitrogen) as a development dependency using different package managers.\n\nLANGUAGE: sh\nCODE:\n```\nnpm i nitro-codegen --save-dev\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add nitro-codegen -D\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add nitro-codegen -D\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun i nitro-codegen -d\n```\n\n----------------------------------------\n\nTITLE: Registering C++ Hybrid Objects in nitro.json\nDESCRIPTION: JSON configuration for registering a C++ implementation of a Hybrid Object in the autolinking section of nitro.json.\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...\n  \"autolinking\": {\n    \"Math\": {\n      \"cpp\": \"HybridMath\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Swift Protocol Generated from TypeScript Interface\nDESCRIPTION: Example of how Nitrogen generates a Swift protocol from a TypeScript interface, ensuring type-safety across language boundaries.\n\nLANGUAGE: swift\nCODE:\n```\nprotocol HybridMathSpec: HybridObject {\n  var pi: Double { get }\n  func add(a: Double, b: Double) -> Double\n}\n```\n\n----------------------------------------\n\nTITLE: Using Hybrid Objects from JavaScript/TypeScript\nDESCRIPTION: TypeScript code to create and use a Hybrid Object from JavaScript. This initializes the MathModule and calls its add method.\n\nLANGUAGE: typescript\nCODE:\n```\nexport const MathModule = NitroModules.createHybridObject<Math>(\"Math\")\nconst result = MathModule.add(5, 7)\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Interface for Native Code Generation\nDESCRIPTION: Example showing how to create a TypeScript interface that extends HybridObject for cross-platform math operations, which Nitrogen will transform into native code.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  readonly pi: number\n  add(a: number, b: number): number\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Hybrid Objects in TypeScript\nDESCRIPTION: This code snippet demonstrates how to define a TypeScript interface for a Hybrid Object, create an instance of it using NitroModules, and invoke a method on it. It shows the Math hybrid object with an add method that accepts two numbers and returns their sum.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Math extends HybridObject {\n  add(a: number, b: number): number\n}\n\nconst math = NitroModules.createHybridObject<Math>(\"Math\")\nconst value = math.add(5, 7) // --> 12\n```\n\n----------------------------------------\n\nTITLE: Registering Raw JSI Methods in C++ Hybrid Objects\nDESCRIPTION: This snippet demonstrates how to create and register a raw JSI method in a C++ Hybrid Object using registerRawHybridMethod. This allows direct access to jsi::Runtime and jsi::Value types when Nitro's typing system is insufficient.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: HybridMathSpec {\npublic:\n  jsi::Value sayHello(jsi::Runtime& runtime,\n                      const jsi::Value& thisValue,\n                      const jsi::Value* args,\n                      size_t count);\n\n  void loadHybridMethods() override {\n    // register base protoype\n    HybridMathSpec::loadHybridMethods();\n    // register all methods we override here\n    registerHybrids(this, [](Prototype& prototype) {\n      prototype.registerRawHybridMethod(\"sayHello\", 0, &HybridMath::sayHello);\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nitro Module with nitro.json\nDESCRIPTION: Example configuration file for a Nitro Module specifying namespaces and module names for iOS and Android platforms.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$schema\": \"https://nitro.margelo.com/nitro.schema.json\",\n  \"cxxNamespace\": [\"math\"],\n  \"ios\": {\n    \"iosModuleName\": \"NitroMath\"\n  },\n  \"android\": {\n    \"androidNamespace\": [\"math\"],\n    \"androidCxxLibName\": \"NitroMath\"\n  },\n  \"autolinking\": {}\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Memory Size Tracking for Swift Hybrid Objects\nDESCRIPTION: This code shows how to implement the memorySize accessor in a Swift Hybrid Object to report its external memory usage to the JavaScript garbage collector. The example calculates image memory usage based on dimensions and bytes per pixel.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridImage : HybridImageSpec {\n  private var cgImage: CGImage\n  public var memorySize: Int {\n    let imageSize = cgImage.width * cgImage.height * cgImage.bytesPerPixel\n    return imageSize\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Nitrogen Code Generator\nDESCRIPTION: Commands to run nitro-codegen to parse TypeScript specs and generate native code interfaces.\n\nLANGUAGE: sh\nCODE:\n```\nnpx nitro-codegen\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn nitro-codegen\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm nitro-codegen\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun nitro-codegen\n```\n\n----------------------------------------\n\nTITLE: Overriding Base Methods in C++ Hybrid Objects\nDESCRIPTION: Shows how to override methods and properties from a parent Hybrid Object in C++, even with different types, by registering new implementations in loadHybridMethods.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridImage: public HybridMedia {\npublic:\n  // Image specific methods\n  std::string getSize();\n\n  void loadHybridMethods() override {\n    // register base protoype\n    HybridMedia::loadHybridMethods();\n    // HybridMedia already has .width, but it's a number.\n    // We override it to be a string in HybridImage.\n    registerHybrids(this, [](Prototype& prototype) {\n      prototype.registerHybridGetter(\"width\", &HybridImage::getSize);\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Swift Implementation of Math Hybrid Object\nDESCRIPTION: Example Swift class that implements the generated HybridMathSpec protocol, providing a concrete implementation of the add method.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  public func add(a: Double, b: Double) throws -> Double {\n    return a + b\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hybrid Object Inheritance in C++\nDESCRIPTION: Shows how to manually implement inheritance between Hybrid Objects in C++ by extending a base class and registering the prototype chain in loadHybridMethods.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridImage: public HybridMedia {\npublic:\n  // Image specific methods\n  ImageFormat getFormat();\n\n  void loadHybridMethods() override {\n    // register base prototype\n    HybridMedia::loadHybridMethods();\n    // register all methods we add here\n    registerHybrids(this, [](Prototype& prototype) {\n      prototype.registerHybridGetter(\"format\", &HybridImage::getFormat);\n    });\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Android Package Class with Native Initialization\nDESCRIPTION: Example Java class that initializes the native C++ module for a React Native package.\n\nLANGUAGE: java\nCODE:\n```\npublic class NitroMathPackage extends TurboReactPackage {\n  // ...\n  static {\n    NitroMathOnLoad.initializeNative();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using dispose() Method on Hybrid Objects\nDESCRIPTION: Shows how to manually dispose of Hybrid Objects using the dispose() method for performance-critical cases, using a Frame object from VisionCamera as an example.\n\nLANGUAGE: typescript\nCODE:\n```\nconst onFrameListener = (frame: Frame) => {\n  doSomeProcessing(frame)\n  frame.dispose()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Hybrid Objects in JavaScript\nDESCRIPTION: Example JavaScript/TypeScript code showing how to create and use a Hybrid Object with the NitroModules API.\n\nLANGUAGE: typescript\nCODE:\n```\nexport const MathModule = NitroModules.createHybridObject<Math>(\"Math\")\nconst result = MathModule.add(5, 7)\n```\n\n----------------------------------------\n\nTITLE: Using Constructor and instanceof with Hybrid Objects\nDESCRIPTION: Demonstrates how to enable the use of new and instanceof operators with Hybrid Objects by using the getHybridObjectConstructor helper method.\n\nLANGUAGE: typescript\nCODE:\n```\nconst HybridMath = getHybridObjectConstructor<Math>(\"Math\")\nconst math = new HybridMath()\nconst isMath = math instanceof HybridMath\n```\n\n----------------------------------------\n\nTITLE: Creating an Expo example app for testing a Nitro Module\nDESCRIPTION: Command to create a new Expo application that can be used to test a Nitro Module. This sets up an environment where you can import and test your Hybrid Objects.\n\nLANGUAGE: sh\nCODE:\n```\nnpx create-expo-app@latest\n```\n\n----------------------------------------\n\nTITLE: Generated Swift Code for Variants with Custom Type Alias\nDESCRIPTION: An example of Swift code that would be generated, showing the difference between using inline variants versus named type aliases. The custom type alias provides better readability.\n\nLANGUAGE: swift\nCODE:\n```\npublic protocol HybridMathSpec: HybridObject {\n  // diff-remove\n  func calculate() -> Variant_String_Double\n  // diff-add\n  func calculate() -> MathOutput\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a bare React Native example app for testing a Nitro Module\nDESCRIPTION: Command to initialize a bare React Native application using the React Native CLI. This provides an alternative to Expo for testing Nitro Modules in a more configurable environment.\n\nLANGUAGE: sh\nCODE:\n```\nnpx @react-native-community/cli@latest init NitroMathExample\n```\n\n----------------------------------------\n\nTITLE: Implementing Fetch Class with AnyMap Return Type in C++\nDESCRIPTION: C++ class implementation for HybridFetch that inherits from HybridFetchSpec with a get method returning a shared pointer to an AnyMap.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridFetch: public HybridFetchSpec {\n  std::shared_ptr<AnyMap> get(const std::string& url);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing External Memory Size for Hybrid Objects in C++\nDESCRIPTION: Shows how to override the getExternalMemorySize method to properly reflect the native memory usage of a Hybrid Object in C++.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridObject {\npublic:\n  // ...\n  size_t getExternalMemorySize() override {\n    return sizeOfSomeImageWeAllocated;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Inefficient Array of Union Types Pattern in TypeScript\nDESCRIPTION: An example showing a less efficient pattern using an array of union types, which lacks fixed length guarantees and requires variant allocation.\n\nLANGUAGE: typescript\nCODE:\n```\ntype Values = (number | string | Person)[]\ninterface Math extends HybridObject {\n  calculate(values: Values): void\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Module Architecture Flow in Mermaid Diagrams\nDESCRIPTION: Visualizes the architectural differences between Nitro Modules and Turbo Modules using Mermaid diagrams. Nitro provides a more direct path from JavaScript to Swift, while Turbo Modules require an additional Objective-C layer.\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: \"Nitro Modules\"\n---\ngraph LR;\n    JS--> C++ --> Swift;\n```\n\nLANGUAGE: mermaid\nCODE:\n```\n---\ntitle: \"Turbo Modules\"\n---\ngraph LR;\n    JS--> C++ --> Objective-C --> Swift;\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Tuple Type in TypeScript\nDESCRIPTION: A simple example showing how to define a Point tuple type with two number values and use it in a Math interface.\n\nLANGUAGE: typescript\nCODE:\n```\ntype Point = [number, number]\ninterface Math extends HybridObject {\n  distance(a: Point, b: Point): number\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Property Implementation in Nitro vs Turbo Modules\nDESCRIPTION: Demonstrates how properties are handled differently between Nitro and Turbo Modules. Nitro supports direct property declarations in Swift, while Turbo Modules require explicit getter/setter methods in Objective-C.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  var someValue: Double\n}\n```\n\nLANGUAGE: objc\nCODE:\n```\n@implementation RTNMath {\n  NSNumber* _someValue;\n}\nRCT_EXPORT_MODULE()\n\n- (NSNumber*)getSomeValue {\n  return _someValue;\n}\n- (void)setSomeValue:(NSNumber*)someValue {\n  _someValue = someValue;\n}\n@end\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Values in C++ with Nitro\nDESCRIPTION: Shows how to implement optional properties in C++ using the std::optional template. This approach wraps double values in optional containers to represent nullable values in the Nitro framework.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridMathSpec {\n  std::optional<double> a;\n  std::optional<double> b;\n};\n```\n\n----------------------------------------\n\nTITLE: Comparing Object-Oriented Approaches in Image Handling\nDESCRIPTION: Illustrates the difference in handling native objects like images between Nitro and Turbo Modules. Nitro supports passing native object instances directly, while Turbo Modules require workarounds like file writing and URI passing.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridImageEditor: HybridImageEditorSpec {\n  func crop(image: HybridImage,\n            size: Size) -> HybridImage {\n    let original = image.cgImage\n    let cropped = original.cropping(to: size)\n    return HybridImage(cgImage: cropped)\n  }\n}\n```\n\nLANGUAGE: objc\nCODE:\n```\n@implementation ImageEditor\n- (NSString*)crop:(NSString*)imageUri\n             size:(CGRect)size {\n  UIImage* image = [UIImage imageWithContentsOfFile:imageUri];\n  CGImageRef cropped = CGImageCreateWithImageInRect([image CGImage], size);\n  UIImage* croppedImage = [UIImage imageWithCGImage:cropped];\n  CGImageRelease(cropped);\n\n  NSString* fileName = [NSString stringWithFormat:@\"%@.png\", [[NSUUID UUID] UUIDString]];\n  NSString* filePath = [NSTemporaryDirectory() stringByAppendingPathComponent:fileName];\n  NSData* pngData = UIImagePNGRepresentation(croppedImage);\n  [pngData writeToFile:tempPath atomically:YES];\n  return tempPath;\n}\n@end\n```\n\n----------------------------------------\n\nTITLE: Implementing Optional Values in Kotlin with Nitro\nDESCRIPTION: Demonstrates how to implement optional properties in a Kotlin class that extends a specification class. Properties are declared as nullable using the question mark operator, requiring boxed object types rather than primitives.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath: HybridMathSpec() {\n  override var a: Double?\n  override var b: Double?\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Nitro Module and Legacy Native Module Implementation\nDESCRIPTION: Side-by-side comparison of a simple math function implementation using Nitro Modules in Swift and Legacy Native Modules in Objective-C. Both implement an 'add' function that takes two numeric parameters.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridMath : HybridMathSpec {\n  func add(a: Double, b: Double) -> Double {\n    return a + b\n  }\n}\n```\n\nLANGUAGE: objc\nCODE:\n```\n@implementation RTNMath\nRCT_EXPORT_MODULE()\n\n- (NSNumber*)add:(NSNumber*)a b:(NSNumber*)b {\n  double added = a.doubleValue + b.doubleValue;\n  return [NSNumber numberWithDouble:added];\n}\n@end\n```\n\n----------------------------------------\n\nTITLE: Implementing a Typed Map in Swift with Nitro\nDESCRIPTION: Example of implementing a typed map in Swift using Dictionary<String, Double> to represent a map of users with their ages in the Nitro framework. This is implemented as a method in a HybridDatabase class.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridDatabase: HybridDatabaseSpec {\n  func getAllUsers() -> Dictionary<String, Double>\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Function Implementation in Nitro and Expo Modules\nDESCRIPTION: Side-by-side comparison of implementing asynchronous functions in Nitro (using Promise.async) and Expo Modules (using Kotlin coroutines). Both implement a delayed operation that returns a string.\n\nLANGUAGE: kotlin\nCODE:\n```\nclass HybridMath: HybridMathSpec {\n  override fun doSomeWork(): Promise<String> {\n    return Promise.async {\n      delay(5000)\n      return@async \"done!\"\n    }\n  }\n}\n```\n\nLANGUAGE: kotlin\nCODE:\n```\nclass MathModule: Module {\n  override fun definition() = ModuleDefinition {\n    Name(\"Math\")\n\n    AsyncFunction(\"doSomeWork\") Coroutine {\n      delay(5000)\n      return@Coroutine \"done!\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing the Cropper HybridObject in Swift\nDESCRIPTION: Implements a Swift class that conforms to the HybridCropperSpec. This demonstrates how the crop method can work with any implementation of HybridImageSpec, showing the power of interface-level abstraction.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridCropper: HybridCropperSpec {\n  func crop(image: HybridImageSpec,\n            size: Size) -> HybridImageSpec {\n    let data = image.data\n    let croppedData = cropFunc(data, size)\n    return HybridCGImage(data: croppedData)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Event Handling Implementation in Nitro and Expo Modules\nDESCRIPTION: Comparison of event notification mechanisms in Nitro and Expo Modules. Nitro uses listeners and callbacks, while Expo uses a dedicated Events system with named event identifiers.\n\nLANGUAGE: swift\nCODE:\n```\nclass Math: MathSpec {\n  var listeners: [(String) -> Void] = []\n  func addListener(listener: (String) -> Void) {\n    listeners.add(listener)\n  }\n\n  func onSomethingChanged() {\n    for listener in listeners {\n      listener(\"something changed!\")\n    }\n  }\n}\n```\n\nLANGUAGE: swift\nCODE:\n```\nlet SOMETHING_CHANGED = \"onSomethingChanged\"\npublic class MathModule: Module {\n  public func definition() -> ModuleDefinition {\n    Name(\"Math\")\n    Events(SOMETHING_CHANGED)\n  }\n\n  private func onSomethingChanged() {\n    sendEvent(SOMETHING_CHANGED, [\n      \"message\": \"something changed!\"\n    ])\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Cropper HybridObject Interface in TypeScript\nDESCRIPTION: Defines a TypeScript interface for a Cropper as a HybridObject. The interface includes a crop method that takes an Image and Size parameter and returns an Image.\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Cropper extends HybridObject {\n  crop(image: Image, size: Size): Image\n}\n```\n\n----------------------------------------\n\nTITLE: Installing iOS Dependencies with CocoaPods\nDESCRIPTION: Commands to install iOS-specific dependencies using Ruby Bundler and CocoaPods through Bun.\n\nLANGUAGE: sh\nCODE:\n```\ncd example\nbundle install\nbun pods\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Image Implementations in Swift\nDESCRIPTION: Demonstrates how multiple Swift classes can implement the same HybridImageSpec interface with different underlying implementations (UIImage, CGImage, and CMSampleBuffer), while maintaining the same interface contract.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridUIImage: HybridImageSpec {\n  // ...\n  var uiImage: UIImage\n}\nclass HybridCGImage: HybridImageSpec {\n  // ...\n  var cgImage: CGImage\n}\nclass HybridBufferImage: HybridImageSpec {\n  // ...\n  var gpuBuffer: CMSampleBuffer\n}\n```\n\n----------------------------------------\n\nTITLE: Running Nitrogen Code Generation\nDESCRIPTION: Command to run the Nitrogen code generator for the Nitro Image module's specifications.\n\nLANGUAGE: sh\nCODE:\n```\nbun image specs\n```\n\n----------------------------------------\n\nTITLE: Using Custom Float Converter in a Hybrid Math Class\nDESCRIPTION: Shows how to use the custom float JSIConverter in a HybridMath class. This example demonstrates registering a hybrid method that works with the float type.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath : public HybridObject {\npublic:\n  float add(float a, float b) {\n    return a + b;\n  }\n\n  void loadHybridMethods() {\n    HybridObject::loadHybridMethods();\n    registerHybrids(this, [](Prototype& prototype) {\n      prototype.registerHybridMethod(\"add\", &HybridMath::add);\n    });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Documentation Dependencies\nDESCRIPTION: Commands to navigate to the documentation directory and install required dependencies using Bun.\n\nLANGUAGE: sh\nCODE:\n```\ncd docs\nbun install\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of Float Converter for JSI\nDESCRIPTION: Shows how to manually implement a JSIConverter template specialization for the float type. This allows direct conversion between JavaScript numbers and C++ floats in Nitro.\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <>\nstruct JSIConverter<float> final {\n  static inline float fromJSI(jsi::Runtime&, const jsi::Value& arg) {\n    return static_cast<float>(arg.asNumber());\n  }\n  static inline jsi::Value toJSI(jsi::Runtime&, float arg) {\n    return jsi::Value(arg);\n  }\n  static inline bool canConvert(jsi::Runtime&, const jsi::Value& value) {\n    return value.isNumber();\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Starting Nitro Documentation Development Server\nDESCRIPTION: Command to run the Docusaurus development server for the Nitro documentation.\n\nLANGUAGE: sh\nCODE:\n```\nbun start\n```\n\n----------------------------------------\n\nTITLE: Using TypeScript Union Types with Nitrogen\nDESCRIPTION: Shows how to define a TypeScript union type (Gender) that Nitrogen can efficiently convert between JS strings and native enums using compile-time hashing.\n\nLANGUAGE: typescript\nCODE:\n```\ntype Gender = 'male' | 'female'\ninterface Person extends HybridObject {\n  getGender(): Gender\n}\n```\n\n----------------------------------------\n\nTITLE: Linting JavaScript and TypeScript Code in Nitro\nDESCRIPTION: Command to run ESLint and Prettier on JavaScript and TypeScript files in the Nitro project.\n\nLANGUAGE: sh\nCODE:\n```\nbun lint\n```\n\n----------------------------------------\n\nTITLE: Implementing memorySize in Swift for Hybrid Objects\nDESCRIPTION: Demonstrates how to properly implement the memorySize property in Swift for Hybrid Objects. This helps the JavaScript garbage collector understand the native memory footprint, improving memory management.\n\nLANGUAGE: swift\nCODE:\n```\nclass HybridImage : HybridImageSpec {\n  private var cgImage: CGImage\n  public var memorySize: Int {\n    let imageSize = cgImage.width * cgImage.height * cgImage.bytesPerPixel\n    return imageSize\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Linting C++ Code in Nitro\nDESCRIPTION: Command to run clang-format for linting C++ code in the Nitro project.\n\nLANGUAGE: sh\nCODE:\n```\nbun lint-cpp\n```\n\n----------------------------------------\n\nTITLE: Initializing a Nitro Module with nitro-codegen\nDESCRIPTION: Command to create a new Nitro Module using the nitro-codegen CLI tool. This initializes the template structure for a new React Native library with Nitro capabilities.\n\nLANGUAGE: sh\nCODE:\n```\nnpx nitro-codegen@latest init react-native-math\n```\n\n----------------------------------------\n\nTITLE: Implementing Hybrid Objects in C++ for Nitro Modules\nDESCRIPTION: This C++ class implements the Math interface defined in TypeScript. It inherits from the auto-generated HybridMathSpec class and overrides the add method with native implementation.\n\nLANGUAGE: cpp\nCODE:\n```\nclass HybridMath: public HybridMathSpec {\npublic:\n  double add(double a, double b) override {\n    return a + b;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with bun\nDESCRIPTION: Installs the react-native-nitro-modules package using bun and runs pod install for iOS dependencies.\n\nLANGUAGE: sh\nCODE:\n```\nbun i react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules via npm\nDESCRIPTION: This shell command installs the react-native-nitro-modules package from npm and sets up the necessary iOS dependencies via CocoaPods.\n\nLANGUAGE: bash\nCODE:\n```\nnpm i react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with pnpm\nDESCRIPTION: Installs the react-native-nitro-modules package using pnpm and runs pod install for iOS dependencies.\n\nLANGUAGE: sh\nCODE:\n```\npnpm add react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Using Nitro Hybrid Objects in JavaScript\nDESCRIPTION: Example of accessing and using a Nitro Hybrid Object from JavaScript. This code creates a Math hybrid object and calls its add method with two numbers.\n\nLANGUAGE: typescript\nCODE:\n```\nconst math = NitroModules.createHybridObject<Math>('Math')\nconst result = math.add(5, 7)\n```\n\n----------------------------------------\n\nTITLE: Starting Metro Bundler for React Native in Bash\nDESCRIPTION: Commands to start the Metro JavaScript bundler for a React Native project using either npm or Yarn package managers. Metro is required for bundling JavaScript code in React Native applications.\n\nLANGUAGE: bash\nCODE:\n```\n# using npm\nnpm start\n\n# OR using Yarn\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Configuring C++ Namespace in Nitro\nDESCRIPTION: Demonstrates how to configure the cxxNamespace property in nitro.json and its corresponding output in C++. The example shows defining multiple sub-namespaces that will be generated relative to margelo::nitro.\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"cxxNamespace\": [\"math\", \"extra\"]\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace margelo::nitro::math::extra {\n  // ...generated classes\n}\n```\n\n----------------------------------------\n\nTITLE: Running React Native App on Android in Bash\nDESCRIPTION: Commands to start a React Native application on Android using either npm or Yarn package managers. This launches the app on a connected Android device or emulator.\n\nLANGUAGE: bash\nCODE:\n```\n# using npm\nnpm run android\n\n# OR using Yarn\nyarn android\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Dependencies with Bun\nDESCRIPTION: Commands to install project dependencies and build the Nitro codebase using Bun package manager.\n\nLANGUAGE: sh\nCODE:\n```\nbun install\nbun run build\n```\n\n----------------------------------------\n\nTITLE: Running React Native App on iOS in Bash\nDESCRIPTION: Commands to start a React Native application on iOS using either npm or Yarn package managers. This launches the app on an iOS simulator.\n\nLANGUAGE: bash\nCODE:\n```\n# using npm\nnpm run ios\n\n# OR using Yarn\nyarn ios\n```\n\n----------------------------------------\n\nTITLE: Configuring Android C++ Shared Library with CMake\nDESCRIPTION: This CMake script configures an Android C++ shared library. It sets the C++20 standard, adds the main cpp-adapter.cpp source file, includes Nitrogen-generated autolinking functionality, sets up include directories, and links against required system libraries including the Android core and logging libraries.\n\nLANGUAGE: cmake\nCODE:\n```\nproject($$androidCxxLibName$$)\ncmake_minimum_required(VERSION 3.9.0)\n\nset (PACKAGE_NAME $$androidCxxLibName$$)\nset (CMAKE_VERBOSE_MAKEFILE ON)\nset (CMAKE_CXX_STANDARD 20)\n\n# Define C++ library and add all sources\nadd_library(${PACKAGE_NAME} SHARED\n        src/main/cpp/cpp-adapter.cpp\n)\n\n# Add Nitrogen specs :)\ninclude(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/$$androidCxxLibName$$+autolinking.cmake)\n\n# Set up local includes\ninclude_directories(\n        \"src/main/cpp\"\n        \"../cpp\"\n)\n\nfind_library(LOG_LIB log)\n\n# Link all libraries together\ntarget_link_libraries(\n        ${PACKAGE_NAME}\n        ${LOG_LIB}\n        android                                   # <-- Android core\n)\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for Docusaurus Website\nDESCRIPTION: Command to install all required dependencies for the Nitro website using Yarn package manager.\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Using custom enum types in JavaScript\nDESCRIPTION: JavaScript code showing how to define and use a custom enum type that corresponds to a C++ enum implemented with JSIConverter.\n\nLANGUAGE: js\nCODE:\n```\nenum MyEnum {\n  FIRST = 0,\n  SECOND = 1\n}\nconst value = myHybridObject.getEnumValue() // <-- typed as `MyEnum` instead of `number`\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Website Using SSH\nDESCRIPTION: Command to deploy the website using SSH authentication, which builds the site and pushes it to the appropriate branch.\n\nLANGUAGE: bash\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Registering a Hybrid Object in the Registry\nDESCRIPTION: C++ code showing how to register a Hybrid Object in the HybridObjectRegistry at application startup to make it available to JavaScript.\n\nLANGUAGE: cpp\nCODE:\n```\n#include <NitroModules/HybridObjectRegistry.hpp>\n\n// Call this at app startup to register the HybridObjects\nvoid load() {\n  HybridObjectRegistry::registerHybridObjectConstructor(\n    \"MyHybrid\",\n    []() -> std::shared_ptr<HybridObject> {\n      return std::make_shared<MyHybridObject>();\n    }\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Website Without SSH\nDESCRIPTION: Command to deploy the website without SSH, requiring the GitHub username as an environment variable. Useful for deploying to GitHub Pages.\n\nLANGUAGE: bash\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Adding react-native-nitro-modules as a peerDependency in a library\nDESCRIPTION: JSON package configuration showing how to add react-native-nitro-modules as a peerDependency in a nitro module library's package.json.\n\nLANGUAGE: json\nCODE:\n```\n{\n  ...\n  \"peerDependencies\": {\n    ...\n    \"react-native-nitro-modules\": \"*\"\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with npm\nDESCRIPTION: Installs the react-native-nitro-modules package using npm and runs pod install for iOS dependencies.\n\nLANGUAGE: sh\nCODE:\n```\nnpm i react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Installing react-native-nitro-modules in a React Native app\nDESCRIPTION: Command line instructions for installing react-native-nitro-modules in a React Native application and running pod install for iOS.\n\nLANGUAGE: sh\nCODE:\n```\nnpm i react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Installing Nitro Modules with yarn\nDESCRIPTION: Installs the react-native-nitro-modules package using yarn and runs pod install for iOS dependencies.\n\nLANGUAGE: sh\nCODE:\n```\nyarn add react-native-nitro-modules\ncd ios && pod install\n```\n\n----------------------------------------\n\nTITLE: Running Nitro Code Generation for Modified HybridObjects\nDESCRIPTION: This snippet shows the command to regenerate Nitrogen files when any HybridObjects specifications (*.nitro.ts files) are changed. This step is necessary to update the generated code that bridges TypeScript with native implementations.\n\nLANGUAGE: typescript\nCODE:\n```\nnpx nitro-codegen\n```\n\n----------------------------------------\n\nTITLE: Loading Images from System Name in React Native Nitro Image\nDESCRIPTION: This snippet demonstrates how to use the ImageConstructors API from the react-native-nitro-image module to load an image from a system name. In this example, it loads an image with the system name 'heart.fill'.\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ImageConstructors } from 'react-native-nitro-image'\n\nconst image = ImageConstructors.loadImageFromSystemName('heart.fill')\n```\n\n----------------------------------------\n\nTITLE: Creating a Hybrid Object in C++\nDESCRIPTION: C++ implementation of a Hybrid Object that inherits from HybridObject, demonstrating how to expose properties and methods to JavaScript.\n\nLANGUAGE: cpp\nCODE:\n```\n#include <NitroModules/HybridObject.hpp>\n\nusing namespace margelo::nitro;\n\nclass MyHybridObject: public HybridObject {\npublic:\n  explicit MyHybridObject(): HybridObject(TAG) {}\n\npublic:\n  // Property (get)\n  double getNumber() { return 13; }\n  // Property (set)\n  void setNumber(double value) { }\n  // Method\n  double add(double left, double right) { return left + right; }\n\npublic:\n  void loadHybridMethods() override {\n    // Call base method to make sure we properly inherit `toString()` and `equals()`\n    HybridObject::loadHybridMethods();\n    // Register all methods that need to be exposed to JS\n    registerHybrids(this, [](Prototype& prototype) {\n      prototype.registerHybridGetter(\"number\", &MyHybridObject::getNumber);\n      prototype.registerHybridSetter(\"number\", &MyHybridObject::setNumber);\n      prototype.registerHybridMethod(\"add\", &MyHybridObject::add);\n    });\n  }\n\nprivate:\n  static constexpr auto TAG = \"MyHybrid\";\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Nitrogen Code Generator as a Development Dependency\nDESCRIPTION: Command to install the Nitrogen code generator (currently named nitro-codegen) as a development dependency in a React Native library project.\n\nLANGUAGE: shell\nCODE:\n```\nnpm i nitro-codegen -D\n```\n\n----------------------------------------\n\nTITLE: Creating a custom JSIConverter for an enum type\nDESCRIPTION: C++ implementation showing how to extend JSIConverter to support custom enum types, enabling seamless conversion between JavaScript and C++ enum values.\n\nLANGUAGE: cpp\nCODE:\n```\n#include <NitroModules/JSIConverter.hpp>\n\nenum class MyEnum {\n  FIRST = 0,\n  SECOND = 1\n};\n\nnamespace margelo::nitro {\n  template <>\n  struct JSIConverter<MyEnum> {\n    static inline MyEnum fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {\n      int intValue = JSIConverter<int>::fromJSI(runtime, arg);\n      return static_cast<MyEnum>(intValue);\n    }\n    static inline jsi::Value toJSI(jsi::Runtime& runtime, MyEnum arg) {\n      int intValue = static_cast<int>(arg);\n      return JSIConverter<int>::toJSI(runtime, intValue);\n    }\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Web Crawler Permissions in robots.txt\nDESCRIPTION: A simple robots.txt configuration that applies to all user agents, explicitly allowing access to the favicon.ico file without disallowing any specific paths.\n\nLANGUAGE: robots.txt\nCODE:\n```\nUser-agent: *\nAllow: /favicon.ico\nDisallow:\n```\n\n----------------------------------------\n\nTITLE: Configuring NitroImage C++ Library with CMake\nDESCRIPTION: This CMake configuration sets up a shared C++ library called NitroImage. It defines project settings like C++20 standard, adds source files from multiple directories, includes Nitrogen framework specifications, and links against Android system libraries.\n\nLANGUAGE: cmake\nCODE:\n```\nproject(NitroImage)\ncmake_minimum_required(VERSION 3.9.0)\n\nset (PACKAGE_NAME NitroImage)\nset (CMAKE_VERBOSE_MAKEFILE ON)\nset (CMAKE_CXX_STANDARD 20)\n\n# Define C++ library and add all sources\nadd_library(${PACKAGE_NAME} SHARED\n        src/main/cpp/cpp-adapter.cpp\n        ../cpp/HybridTestObjectCpp.cpp\n)\n\n# Add Nitrogen specs :)\ninclude(${CMAKE_SOURCE_DIR}/../nitrogen/generated/android/NitroImage+autolinking.cmake)\n\n# Set up local includes\ninclude_directories(\n        \"src/main/cpp\"\n        \"../cpp\"\n)\n\nfind_library(LOG_LIB log)\n\n# Link all libraries together\ntarget_link_libraries(\n        ${PACKAGE_NAME}\n        ${LOG_LIB}\n        android                                   # <-- Android core\n)\n```\n\n----------------------------------------\n\nTITLE: Building Static Content for Docusaurus Website\nDESCRIPTION: Command to generate static website content into the 'build' directory, which can then be served using any static content hosting service.\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server for Docusaurus Website\nDESCRIPTION: Command to start a local development server that opens a browser window and supports live reloading for most changes.\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Declaring Hybrid Objects in TypeScript for Nitro Modules\nDESCRIPTION: This TypeScript interface defines a Math object that extends HybridObject with an add method. This declaration serves as the contract between JavaScript and native code.\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface Math extends HybridObject {\n  add(a: number, b: number): number\n}\n```"
  }
]