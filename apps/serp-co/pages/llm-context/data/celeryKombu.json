[
  {
    "owner": "celery",
    "repo": "kombu",
    "content": "TITLE: Basic Kombu Usage with Connection Context Managers\nDESCRIPTION: This example demonstrates how to use Kombu to create a producer and consumer with a RabbitMQ connection. It shows how to declare exchanges and queues, publish messages, and consume them using a callback function within context managers.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/includes/introduction.txt#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Connection, Exchange, Queue\n\nmedia_exchange = Exchange('media', 'direct', durable=True)\nvideo_queue = Queue('video', exchange=media_exchange, routing_key='video')\n\ndef process_media(body, message):\n    print(body)\n    message.ack()\n\n# connections\nwith Connection('amqp://guest:guest@localhost//') as conn:\n\n    # produce\n    producer = conn.Producer(serializer='json')\n    producer.publish({'name': '/tmp/lolcat1.avi', 'size': 1301013},\n                      exchange=media_exchange, routing_key='video',\n                      declare=[video_queue])\n\n    # the declare above, makes sure the video queue is declared\n    # so that the messages can be delivered.\n    # It's a best practice in Kombu to have both publishers and\n    # consumers declare the queue. You can also declare the\n    # queue manually using:\n    #     video_queue(conn).declare()\n\n    # consume\n    with conn.Consumer(video_queue, callbacks=[process_media]) as consumer:\n        # Process messages and handle events on all channels\n        while True:\n            conn.drain_events()\n\n# Consume from several queues on the same channel:\nvideo_queue = Queue('video', exchange=media_exchange, key='video')\nimage_queue = Queue('image', exchange=media_exchange, key='image')\n\nwith connection.Consumer([video_queue, image_queue],\n                         callbacks=[process_media]) as consumer:\n    while True:\n        connection.drain_events()\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Connections in Python with Kombu\nDESCRIPTION: Demonstrates how to create, connect, check status, and close a connection using Kombu. It also shows best practices for releasing connections and using them as context managers.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/connections.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import Connection\n>>> connection = Connection('amqp://guest:guest@localhost:5672//')\n\n>>> connection.connect()\n\n>>> connection.connected\nTrue\n\n>>> connection.close()\n\n>>> connection.release()\n\nwith Connection() as connection:\n    # work with connection\n```\n\n----------------------------------------\n\nTITLE: Complete Consumer Example in Python\nDESCRIPTION: This is a full example of creating and using a consumer in Kombu. It sets up a connection, defines a callback, creates queues, and uses a consumer to process messages.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Connection, Consumer, Queue\n\ndef callback(body, message):\n    print('RECEIVED MESSAGE: {0!r}'.format(body))\n    message.ack()\n\nqueue1 = Queue('queue1', routing_key='queue1')\nqueue2 = Queue('queue2', routing_key='queue2')\n\nwith Connection('amqp://') as conn:\n    with conn.channel() as channel:\n        consumer = Consumer(conn, [queue1, queue2], accept=['json'])\n        consumer.register_callback(callback)\n        with consumer:\n            conn.drain_events(timeout=1)\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages with Exchange\nDESCRIPTION: Example of publishing a message to a direct exchange with a specific routing key. Shows how to declare exchanges during publishing.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import Exchange\n\n>>> exchange = Exchange('name', type='direct')\n\n>>> producer.publish(\n...      {'hello': 'world'},  # message to send\n...      exchange=exchange,   # destination exchange\n...      routing_key='rk',    # destination routing key,\n...      declare=[exchange],  # make sure exchange is declared,\n... )\n```\n\n----------------------------------------\n\nTITLE: Exchange Binding and Operations in Kombu\nDESCRIPTION: This snippet demonstrates how to bind Exchange objects to connections and perform operations on them. It highlights the difference between bound and unbound exchanges, showing how operations can only be performed on bound objects.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/includes/introduction.txt#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> exchange = Exchange('tasks', 'direct')\n\n>>> connection = Connection()\n>>> bound_exchange = exchange(connection)\n>>> bound_exchange.delete()\n\n# the original exchange is not affected, and stays unbound.\n>>> exchange.delete()\nraise NotBoundError: Can't call delete on Exchange not bound to\n    a channel.\n```\n\n----------------------------------------\n\nTITLE: ConsumerProducerMixin for RPC-style Messaging in Python\nDESCRIPTION: This example uses ConsumerProducerMixin to create a worker that can both consume messages and publish responses. It's suitable for RPC-style communication patterns.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Producer, Queue\nfrom kombu.mixins import ConsumerProducerMixin\n\nrpc_queue = Queue('rpc_queue')\n\nclass Worker(ConsumerProducerMixin):\n\n    def __init__(self, connection):\n        self.connection = connection\n\n    def get_consumers(self, Consumer, channel):\n        return [Consumer(\n            queues=[rpc_queue],\n            on_message=self.on_request,\n            accept={'application/json'},\n            prefetch_count=1,\n        )]\n\n    def on_request(self, message):\n        n = message.payload['n']\n        print(' [.] fib({0})'.format(n))\n        result = fib(n)\n\n        self.producer.publish(\n            {'result': result},\n            exchange='', routing_key=message.properties['reply_to'],\n            correlation_id=message.properties['correlation_id'],\n            serializer='json',\n            retry=True,\n        )\n        message.ack()\n```\n\n----------------------------------------\n\nTITLE: Configuring Consumer with Multiple Serialization Formats in Python\nDESCRIPTION: Shows how to explicitly enable multiple serialization formats (JSON, pickle, and msgpack) when creating a Consumer object in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nConsumer(conn, [queue], accept=['json', 'pickle', 'msgpack'])\n```\n\n----------------------------------------\n\nTITLE: Connecting to Multiple Brokers with Kombu Connection\nDESCRIPTION: Demonstrates how to create a Connection object with multiple broker URLs for automatic failover. The healthy broker is automatically selected during connection.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> conn = Connection(\n...     'amqp://guest:guest@broken.example.com;guest:guest@healthy.example.com'\n... )\n>>> conn.connect()\n>>> conn\n<Connection: amqp://guest:**@healthy.example.com at 0x6fffff751710>\n```\n\n----------------------------------------\n\nTITLE: Instantiating Consumer Directly with Channel in Python\nDESCRIPTION: This snippet demonstrates how to create a Consumer instance directly, using a channel or connection. It also consumes from a single queue named 'queue'.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> queue = Queue('queue', routing_key='queue')\n>>> with Connection('amqp://') as conn:\n...     with conn.channel() as channel:\n...         consumer = Consumer(channel, queue)\n```\n\n----------------------------------------\n\nTITLE: Basic Kombu Usage Example in Python\nDESCRIPTION: This snippet demonstrates how to use Kombu to create a connection, declare exchanges and queues, publish messages, and consume messages. It shows the basic workflow of producing and consuming messages using Kombu's high-level API.\nSOURCE: https://github.com/celery/kombu/blob/main/README.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Connection, Exchange, Queue\n\nmedia_exchange = Exchange('media', 'direct', durable=True)\nvideo_queue = Queue('video', exchange=media_exchange, routing_key='video')\n\ndef process_media(body, message):\n    print(body)\n    message.ack()\n\n# connections\nwith Connection('amqp://guest:guest@localhost//') as conn:\n\n    # produce\n    producer = conn.Producer(serializer='json')\n    producer.publish({'name': '/tmp/lolcat1.avi', 'size': 1301013},\n                      exchange=media_exchange, routing_key='video',\n                      declare=[video_queue])\n\n    # the declare above, makes sure the video queue is declared\n    # so that the messages can be delivered.\n    # It's a best practice in Kombu to have both publishers and\n    # consumers declare the queue. You can also declare the\n    # queue manually using:\n    #     video_queue(conn).declare()\n\n    # consume\n    with conn.Consumer(video_queue, callbacks=[process_media]) as consumer:\n        # Process messages and handle events on all channels\n        while True:\n            conn.drain_events()\n\n# Consume from several queues on the same channel:\nvideo_queue = Queue('video', exchange=media_exchange, key='video')\nimage_queue = Queue('image', exchange=media_exchange, key='image')\n\nwith connection.Consumer([video_queue, image_queue],\n                         callbacks=[process_media]) as consumer:\n    while True:\n        connection.drain_events()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Exchange Declaration in Python\nDESCRIPTION: Demonstrates how to create an exchange declaration, bind it to a channel, and perform operations like declare, publish, and delete.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> news_exchange = Exchange('news', type='topic')\n\n>>> bound_exchange = news_exchange(channel)\n\n>>> # Declare exchange manually\n>>> bound_exchange.declare()\n\n>>> # Publish raw string message using low-level exchange API\n>>> bound_exchange.publish(\n...     'Cure for cancer found!',\n...     routing_key='news.science',\n... )\n\n>>> # Delete exchange.\n>>> bound_exchange.delete()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Queue Declaration in Python\nDESCRIPTION: Shows how to create a queue declaration, bind it to a channel, and perform operations like declare, purge, and delete.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> science_news = Queue('science_news',\n...                      exchange=news_exchange,\n...                      routing_key='news.science')\n\n>>> bound_science_news = science_news(channel)\n\n>>> bound_science_news.declare()\n>>> bound_science_news.purge()\n>>> bound_science_news.delete()\n```\n\n----------------------------------------\n\nTITLE: Creating a Consumer Using ConsumerMixin in Python\nDESCRIPTION: This snippet demonstrates how to create a consumer by subclassing the ConsumerMixin class. It overrides methods to define consumer behavior and message handling.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu.mixins import ConsumerMixin\n\nclass C(ConsumerMixin):\n\n    def __init__(self, connection):\n        self.connection = connection\n\n    def get_consumers(self, Consumer, channel):\n        return [\n            Consumer(channel, callbacks=[self.on_message], accept=['json']),\n        ]\n\n    def on_message(self, body, message):\n        print('RECEIVED MESSAGE: {0!r}'.format(body))\n        message.ack()\n\nC(connection).run()\n```\n\n----------------------------------------\n\nTITLE: Setting Serialization Method on Producer in Kombu\nDESCRIPTION: Shows how to set the default serialization method (YAML in this example) when creating a Producer object in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> producer = Producer(channel,\n...                     exchange=exchange,\n...                     serializer='yaml')\n```\n\n----------------------------------------\n\nTITLE: Specifying Broker Connection with URL\nDESCRIPTION: Example showing how to specify broker connection details using URL format. Transport, credentials, hostname, port and virtual host can all be included in the URL string.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_38\n\nLANGUAGE: python\nCODE:\n```\n>>> Connection('amqp://guest:guest@localhost:5672//')\n```\n\n----------------------------------------\n\nTITLE: Creating SimpleBuffer with Kombu Channel\nDESCRIPTION: Shows how to create a SimpleBuffer using a Kombu channel. This method provides more control over the channel lifecycle but requires manual channel management.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/simple.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu.simple import SimpleBuffer\n\n>>> channel = connection.channel()\n>>> queue = SimpleBuffer(channel, 'mybuffer')\n>>> # ... do something with queue\n>>> channel.close()\n>>> queue.close()\n```\n\n----------------------------------------\n\nTITLE: Multiple Channel Consumer Using ConsumerMixin in Python\nDESCRIPTION: This code shows how to create a consumer with multiple channels using ConsumerMixin. It handles different queues on separate channels and demonstrates proper channel management.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Consumer\nfrom kombu.mixins import ConsumerMixin\n\nclass C(ConsumerMixin):\n    channel2 = None\n\n    def __init__(self, connection):\n        self.connection = connection\n\n    def get_consumers(self, _, default_channel):\n        self.channel2 = default_channel.connection.channel()\n        return [Consumer(default_channel, queues1,\n                         callbacks=[self.on_message],\n                         accept=['json']),\n                Consumer(self.channel2, queues2,\n                         callbacks=[self.on_special_message],\n                         accept=['json'])]\n\n    def on_consume_end(self, connection, default_channel):\n        if self.channel2:\n            self.channel2.close()\n\nC(connection).run()\n```\n\n----------------------------------------\n\nTITLE: Implementing Consumer Failover with Kombu Connection.ensure()\nDESCRIPTION: Shows how to implement a consumer with failover functionality using a custom consume function and Connection.ensure(). It handles socket timeouts to avoid blocked connections.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import *\n>>> import socket\n\n>>> def callback(body, message):\n...     print(body)\n...     message.ack()\n\n\n>>> queue = Queue('queue', routing_key='queue')\n>>> with Connection('amqp://broker1:5672;amqp://broker2:5672') as conn:\n...     def consume():\n...         while True:\n...             try:\n...                 conn.drain_events(timeout=1)\n...             except socket.timeout:\n...                 pass\n...     with conn.channel() as channel:\n...         consumer = Consumer(channel, queue)\n...         consumer.register_callback(callback)\n...         with consumer:\n...             while True:\n...                 consume = conn.ensure(conn, consume)\n...                 consume()\n```\n\n----------------------------------------\n\nTITLE: Defining Queue Configuration for Simple Task Queue in Python\nDESCRIPTION: This code snippet defines the queue configuration for a simple task queue using pickle serialization and supporting primitive priorities through different queues.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/examples.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/simple_task_queue/queues.py\n    :language: python\n```\n\n----------------------------------------\n\nTITLE: Using Kombu Objects Without Context Managers\nDESCRIPTION: This example demonstrates how to use Kombu Connection and Consumer objects outside of with statements, manually managing their lifecycle by explicitly closing them after use.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/includes/introduction.txt#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Connection, Consumer\n\nconnection = Connection()\n    # ...\nconnection.release()\n\nconsumer = Consumer(channel_or_connection, ...)\nconsumer.register_callback(my_callback)\nconsumer.consume()\n    # ....\nconsumer.cancel()\n```\n\n----------------------------------------\n\nTITLE: Implementing Worker for Simple Task Queue in Python\nDESCRIPTION: This code snippet demonstrates how to implement a worker for the simple task queue, which processes tasks from the defined queues.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/examples.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/simple_task_queue/worker.py\n    :language: python\n```\n\n----------------------------------------\n\nTITLE: Defining Tasks for Simple Task Queue in Python\nDESCRIPTION: This code snippet shows how to define tasks that can be executed by the simple task queue worker.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/examples.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/simple_task_queue/tasks.py\n    :language: python\n```\n\n----------------------------------------\n\nTITLE: Creating Mailbox and Message Handlers in Python\nDESCRIPTION: Demonstrates how to create a mailbox instance and define message handlers for schedule reloading and connection info retrieval. The handlers are decorated with @mailbox.handler and can access a shared state object.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.pidbox.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> mailbox = pidbox.Mailbox('celerybeat', type='direct')\n\n>>> @mailbox.handler\n>>> def reload_schedule(state, **kwargs):\n...     state['beat'].reload_schedule()\n\n>>> @mailbox.handler\n>>> def connection_info(state, **kwargs):\n...     return {'connection': state['connection'].info()}\n```\n\n----------------------------------------\n\nTITLE: Registering a Callback Function for Consumer in Python\nDESCRIPTION: This code defines a callback function for handling received messages and demonstrates how to register it with a consumer. The callback acknowledges the message after processing.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> def callback(body, message):\n...     print(body)\n...     message.ack()\n\n>>> consumer.register_callback(callback)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Pidbox Node in Python\nDESCRIPTION: Shows how to set up a node that listens for messages using a Kombu connection. The node maintains a state dictionary and processes events in a continuous loop until cancelled.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.pidbox.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> connection = kombu.Connection()\n>>> state = {'beat': beat,\n                     'connection': connection}\n>>> consumer = mailbox(connection).Node(hostname).listen()\n>>> try:\n...     while True:\n...         connection.drain_events(timeout=1)\n... finally:\n...     consumer.cancel()\n```\n\n----------------------------------------\n\nTITLE: Implementing Logger with Kombu SimpleQueue\nDESCRIPTION: Demonstrates a complete implementation of a logging system using Kombu's SimpleQueue. This class handles message production, consumption, and processing with custom serialization and compression options.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/simple.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport socket\nimport datetime\nfrom time import time\nfrom kombu import Connection\n\n\nclass Logger:\n\n    def __init__(self, connection, queue_name='log_queue',\n            serializer='json', compression=None):\n        self.queue = connection.SimpleQueue(queue_name)\n        self.serializer = serializer\n        self.compression = compression\n\n    def log(self, message, level='INFO', context={}):\n        self.queue.put({'message': message,\n                        'level': level,\n                        'context': context,\n                        'hostname': socket.gethostname(),\n                        'timestamp': time()},\n                        serializer=self.serializer,\n                        compression=self.compression)\n\n    def process(self, callback, n=1, timeout=1):\n        for i in xrange(n):\n            log_message = self.queue.get(block=True, timeout=1)\n            entry = log_message.payload # deserialized data.\n            callback(entry)\n            log_message.ack() # remove message from queue\n\n    def close(self):\n        self.queue.close()\n\n\nif __name__ == '__main__':\n    from contextlib import closing\n\n    with Connection('amqp://guest:guest@localhost:5672//') as conn:\n        with closing(Logger(conn)) as logger:\n\n            # Send message\n            logger.log('Error happened while encoding video',\n                        level='ERROR',\n                        context={'filename': 'cutekitten.mpg'})\n\n            # Consume and process message\n\n            # This is the callback called when a log message is\n            # received.\n            def dump_entry(entry):\n                date = datetime.datetime.fromtimestamp(entry['timestamp'])\n                print('[%s %s %s] %s %r' % (date,\n                                            entry['hostname'],\n                                            entry['level'],\n                                            entry['message'],\n                                            entry['context']))\n\n            # Process a single message using the callback above.\n            logger.process(dump_entry, n=1)\n```\n\n----------------------------------------\n\nTITLE: Configuring Celery with SQS in Python\nDESCRIPTION: Shows how to configure Celery to work with SQS, including setting up a queue name prefix and creating a custom Task class with application context.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/connections.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom celery import Celery\ndef make_celery(app):\n    celery = Celery(\n        app.import_name,\n        broker=\"sqs://\",\n        broker_transport_options={\n            \"queue_name_prefix\": \"{SERVICE_ENV}-{SERVICE_NAME}-\"\n        },\n    )\n    task_base = celery.Task\n\n    class ContextTask(task_base):\n        abstract = True\n\n        def __call__(self, *args, **kwargs):\n            with app.app_context():\n                return task_base.__call__(self, *args, **kwargs)\n\n    celery.Task = ContextTask\n\n    return celery\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Long Polling in Kombu\nDESCRIPTION: Added support for long-polling on all supported queries when using the SQS transport in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Example of enabling SQS long-polling\nfrom kombu import Connection\n\nconn = Connection('sqs://')\nqueue = conn.SimpleQueue('my_queue', transport_options={'WaitTimeSeconds': 20})\n```\n\n----------------------------------------\n\nTITLE: Draining Events from Multiple Consumers in Python\nDESCRIPTION: This code demonstrates how to drain events from multiple consumers, each with its own list of queues. It uses nested context managers to handle multiple channels and consumers.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu.utils.compat import nested\n\n>>> queues1 = [Queue('queue11', routing_key='queue11'),\n...            Queue('queue12', routing_key='queue12')]\n>>> queues2 = [Queue('queue21', routing_key='queue21'),\n...            Queue('queue22', routing_key='queue22')]\n>>> with connection.channel(), connection.channel() as (channel1, channel2):\n...     with nested(Consumer(channel1, queues1, accept=['json']),\n...                 Consumer(channel2, queues2, accept=['json'])):\n...         connection.drain_events(timeout=1)\n```\n\n----------------------------------------\n\nTITLE: Configuring Retry Policy\nDESCRIPTION: Demonstrates how to configure detailed retry policies including intervals and maximum retry attempts when publishing messages.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> producer.publish(\n...     {'hello': 'world'}, ...,\n...     retry=True,\n...     retry_policy={\n...         'interval_start': 0, # First retry immediately,\n...         'interval_step': 2,  # then increase by 2s for every retry.\n...         'interval_max': 30,  # but don't exceed 30s between retries.\n...         'max_retries': 30,   # give up after 30 tries.\n...     },\n... )\n```\n\n----------------------------------------\n\nTITLE: Connecting to Redis Sentinel in Python\nDESCRIPTION: Demonstrates how to configure a connection to Redis Sentinel by specifying multiple sentinel URLs separated by semicolons.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsentinel://0.0.0.0:26379;sentinel://0.0.0.0:26380/...\n```\n\n----------------------------------------\n\nTITLE: Implementing Client for Simple Task Queue in Python\nDESCRIPTION: This code snippet demonstrates how to create a client that can submit tasks to the simple task queue for processing by workers.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/examples.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/simple_task_queue/client.py\n```\n\n----------------------------------------\n\nTITLE: Registering Serializer using Setuptools Entry-Points\nDESCRIPTION: Demonstrates how to register a custom serializer in Kombu using Setuptools entry-points by adding entries to setup.py.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup\n\nsetup(\n    entry_points={\n        'kombu.serializers': [\n            'my_serializer = my_module.serializer:register_args'\n        ]\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Queue with Back-off Policy in Python\nDESCRIPTION: Example configuration for setting up SQS queues with back-off policy and task retry delays. Demonstrates how to specify queue URL, credentials, and configure retry behavior for specific tasks.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.SQS.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nbroker_transport_options = {\n    'predefined_queues': {\n        'my-q': {\n            'url': 'https://ap-southeast-2.queue.amazonaws.com/123456/my-q',\n            'access_key_id': 'xxx',\n            'secret_access_key': 'xxx',\n            'backoff_policy': {1: 10, 2: 20, 3: 40, 4: 80, 5: 320, 6: 640},\n            'backoff_tasks': ['svc.tasks.tasks.task1']\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hello World Publisher in Python using Kombu\nDESCRIPTION: This code snippet demonstrates how to create a simple publisher using Kombu to send a 'Hello World' message through a message broker (RabbitMQ).\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/examples.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/hello_publisher.py\n    :language: python\n```\n\n----------------------------------------\n\nTITLE: Implementing Producer Failover with Kombu Producer.publish()\nDESCRIPTION: Demonstrates how to use the retry parameter in Producer.publish() for automatic failover when publishing messages.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import *\n>>> with Connection('amqp://broker1:5672;amqp://broker2:5672') as conn:\n...     with conn.channel() as channel:\n...         producer = conn.Producer()\n...         producer = Producer(channel)\n...         producer.publish(\n...             {'hello': 'world'}, routing_key='queue', retry=True\n...         )\n```\n\n----------------------------------------\n\nTITLE: Custom Serialization Publishing\nDESCRIPTION: Demonstrates how to specify a custom serializer when publishing messages instead of using the default JSON serializer.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> producer.publish({'hello': 'world'}, serializer='pickle')\n```\n\n----------------------------------------\n\nTITLE: Accessing Transport Aliases in Kombu\nDESCRIPTION: Retrieves the mapping of transport aliases to their corresponding class names in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.transport import TRANSPORT_ALIASES\n\ntransport_aliases = TRANSPORT_ALIASES\n```\n\n----------------------------------------\n\nTITLE: Setting Consumer Priority in RabbitMQ with Kombu in Python\nDESCRIPTION: This snippet demonstrates how to set consumer priority when using RabbitMQ with Kombu. It uses the 'x-priority' argument in the queue definition to set the priority.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nqueue = Queue('name', Exchange('exchange_name', type='direct'),\n              consumer_arguments={'x-priority': 10})\n```\n\n----------------------------------------\n\nTITLE: Acquiring and Releasing Connections from Default Pool in Python\nDESCRIPTION: Demonstrates how to acquire and release a connection from the default connection pool in Kombu. It uses a context manager to ensure proper resource management.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/pools.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Connection\nfrom kombu.pools import connections\n\nconnection = Connection('redis://localhost:6379')\n\nwith connections[connection].acquire(block=True) as conn:\n    print('Got connection: {0!r}'.format(connection.as_uri()))\n```\n\n----------------------------------------\n\nTITLE: Configuring Kombu Connection with Transport Options in Python\nDESCRIPTION: Demonstrates how to configure a Kombu connection with transport options for fanout exchanges in Redis.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> Connection(transport_options={\n    'fanout_prefix': True,\n    'fanout_patterns': True,\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Transport Key Separator in Python\nDESCRIPTION: Example of configuring a custom separator for Redis keys when using the Redis transport in Kombu. This allows customizing how queue attributes are stored in the key name.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwith Connection('redis://', transport_options={\n        'sep': ':',\n    }):\n    # ...\n    pass\n```\n\n----------------------------------------\n\nTITLE: Installing Kombu via pip in Python\nDESCRIPTION: This snippet shows how to install Kombu using pip, the Python package installer. It's a simple one-line command that downloads and installs Kombu from the Python Package Index (PyPI).\nSOURCE: https://github.com/celery/kombu/blob/main/README.rst#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ pip install kombu\n```\n\n----------------------------------------\n\nTITLE: Using Redis with Unix Socket Connection in Kombu\nDESCRIPTION: Example of how to connect to Redis using a UNIX socket in Kombu. This requires using the 'redis+socket' URL prefix followed by the path to the socket file.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nredis+socket:///tmp/redis.sock\n```\n\n----------------------------------------\n\nTITLE: Creating a Consumer with a Connection in Python\nDESCRIPTION: This code shows how to create a consumer using a Connection object. The consumer is set up to consume from a single queue named 'queue'.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> queue = Queue('queue', routing_key='queue')\n>>> consumer = connection.Consumer(queue)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating AMQP Connection URI Format in Python\nDESCRIPTION: Shows the format of AMQP connection URIs with different virtual hosts. The leading slash in the path component is always required to distinguish between empty and root virtual hosts.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_40\n\nLANGUAGE: text\nCODE:\n```\namqp://guest:guest@localhost:5672//\n\namqp://guest:guest@localhost:5672/\n```\n\n----------------------------------------\n\nTITLE: Using the Pidbox Client API in Python\nDESCRIPTION: Demonstrates how to use the client API to send messages. Shows both asynchronous casting with 'cast' and synchronous calls with timeout using 'call'.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.pidbox.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> mailbox.cast('reload_schedule')   # cast is async.\n>>> info = celerybeat.call('connection_info', timeout=1)\n```\n\n----------------------------------------\n\nTITLE: Setting Connection Pool Limit in Python\nDESCRIPTION: Demonstrates how to change the default limit of 100 connections per connection instance in the connection pool.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_43\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from kombu import pools\n>>> pools.set_limit(10)\n```\n\n----------------------------------------\n\nTITLE: Using Producer.publish with Retry Support\nDESCRIPTION: Example showing how to use Producer.publish with automatic retry functionality. The retry_policy parameter allows configuring retry behavior like intervals between attempts.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nexchange = Exchange('foo')\nproducer.publish(message, exchange=exchange, retry=True,\n                 declare=[exchange], retry_policy={\n                    'interval_start': 1.0})\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Transport Options for Unacked Message Handling\nDESCRIPTION: Example of configuring Redis transport options to control how unacknowledged messages are restored. The unacked_restore_limit sets the maximum number of messages to restore in a single pass.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nConnection('redis://', transport_options={\n    'unacked_restore_limit': 100,\n})\n```\n\n----------------------------------------\n\nTITLE: Accessing Negotiated Heartbeat Interval in Python\nDESCRIPTION: Demonstrates how to retrieve the negotiated heartbeat interval from a Kombu connection object.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nkombu.Connection.get_heartbeat_interval()\n```\n\n----------------------------------------\n\nTITLE: Installing Kombu from Source in Python\nDESCRIPTION: This snippet shows the process of installing Kombu from a source tarball. It involves building the package and then installing it, typically requiring root privileges for the installation step.\nSOURCE: https://github.com/celery/kombu/blob/main/README.rst#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ python setup.py build\n# python setup.py install # as root\n```\n\n----------------------------------------\n\nTITLE: Viewing Available Failover Strategies in Kombu\nDESCRIPTION: Displays the available failover strategies defined in the kombu.connection module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> import kombu\n>>> kombu.connection.failover_strategies\n{'round-robin': <class 'itertools.cycle'>, 'shuffle': <function shufflecycle at 0x6fffff8547a0>}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Producer with Channel\nDESCRIPTION: Demonstrates creating a producer by explicitly providing a channel from a connection. Shows the context manager pattern for proper resource management.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> with Connection('amqp://') as conn:\n...     with conn.channel() as channel:\n...          producer = Producer(channel)\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Kombu API Documentation in reStructuredText\nDESCRIPTION: This code snippet defines the structure of the Kombu API documentation using reStructuredText directives. It organizes the documentation into sections for core components, transports, asynchronous functionality, and utilities.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n===========================\n API Reference\n===========================\n\n:Release: |version|\n:Date: |today|\n\nKombu Core\n==========\n\n.. toctree::\n    :maxdepth: 1\n\n    kombu\n    kombu.common\n    kombu.matcher\n    kombu.mixins\n    kombu.simple\n    kombu.clocks\n    kombu.compat\n    kombu.pidbox\n    kombu.exceptions\n    kombu.log\n    kombu.connection\n    kombu.message\n    kombu.compression\n    kombu.pools\n    kombu.abstract\n    kombu.resource\n    kombu.serialization\n    kombu.native_delayed_delivery\n\nKombu Transports\n================\n\n.. toctree::\n    :maxdepth: 1\n\n    kombu.transport\n    kombu.transport.base\n    kombu.transport.virtual\n    kombu.transport.virtual.exchange\n    kombu.transport.azurestoragequeues\n    kombu.transport.azureservicebus\n    kombu.transport.pyamqp\n    kombu.transport.librabbitmq\n    kombu.transport.qpid\n    kombu.transport.memory\n    kombu.transport.redis\n    kombu.transport.mongodb\n    kombu.transport.consul\n    kombu.transport.etcd\n    kombu.transport.zookeeper\n    kombu.transport.filesystem\n    kombu.transport.sqlalchemy\n    kombu.transport.SQS\n    kombu.transport.SLMQ\n    kombu.transport.pyro\n\n\nKombu Asynchronous\n==================\n\n.. toctree::\n    :maxdepth: 1\n\n    kombu.asynchronous\n    kombu.asynchronous.hub\n    kombu.asynchronous.semaphore\n    kombu.asynchronous.timer\n    kombu.asynchronous.debug\n    kombu.asynchronous.http\n    kombu.asynchronous.http.base\n    kombu.asynchronous.http.urllib3_client\n    kombu.asynchronous.aws\n    kombu.asynchronous.aws.connection\n    kombu.asynchronous.aws.sqs\n    kombu.asynchronous.aws.sqs.connection\n    kombu.asynchronous.aws.sqs.message\n    kombu.asynchronous.aws.sqs.queue\n\nKombu utils\n===========\n\n.. toctree::\n    :maxdepth: 1\n\n    kombu.utils.amq_manager\n    kombu.utils.collections\n    kombu.utils.compat\n    kombu.utils.debug\n    kombu.utils.div\n    kombu.utils.encoding\n    kombu.utils.eventio\n    kombu.utils.functional\n    kombu.utils.imports\n    kombu.utils.json\n    kombu.utils.limits\n    kombu.utils.objects\n    kombu.utils.scheduling\n    kombu.utils.text\n    kombu.utils.time\n    kombu.utils.url\n    kombu.utils.uuid\n```\n\n----------------------------------------\n\nTITLE: Configuring RabbitMQ Queue Extensions in Python\nDESCRIPTION: Shows how to use new arguments in the kombu.Queue class to configure RabbitMQ queue extensions like expiry time, message TTL, and max length.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nQueue(expires=20.0)\nQueue(message_ttl=30.0)\nQueue(max_length=1000)\nQueue(max_length_bytes=1000)\nQueue(max_priority=10)\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies for Celery/Kombu\nDESCRIPTION: This code snippet defines the required Python packages and their versions for the Celery/Kombu project. It includes testing tools like pytest and hypothesis, as well as development tools like pre-commit. Some dependencies have version constraints based on the Python version being used.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/test.txt#2025-04-21_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\nhypothesis<7\nPyro4==4.82\npytest-freezer==0.4.9\npytest-sugar==1.0.0\npytest==8.3.5\npre-commit>=3.5.0,<3.8.0; python_version < '3.9'\npre-commit>=4.0.1; python_version >= '3.9'\n```\n\n----------------------------------------\n\nTITLE: Manual Channel Handling in Kombu (Python)\nDESCRIPTION: This snippet shows how to manually handle channels in Kombu. It demonstrates creating a producer and consumer using a manually managed channel, which provides more fine-grained control over the messaging process.\nSOURCE: https://github.com/celery/kombu/blob/main/README.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwith connection.channel() as channel:\n    producer = Producer(channel, ...)\n    consumer = Consumer(channel)\n```\n\n----------------------------------------\n\nTITLE: Implementing Operation Failover with Kombu Connection.ensure()\nDESCRIPTION: Demonstrates how to use the ensure() method to implement operation failover for a Producer's publish method. It retries the operation on failure with a custom error callback.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import Connection, Producer\n>>> conn = Connection('amqp://')\n>>> producer = Producer(conn)\n>>> def errback(exc, interval):\n...     logger.error('Error: %r', exc, exc_info=1)\n...     logger.info('Retry in %s seconds.', interval)\n>>> publish = conn.ensure(producer, producer.publish,\n...                       errback=errback, max_retries=3)\n>>> publish({'hello': 'world'}, routing_key='dest')\n```\n\n----------------------------------------\n\nTITLE: Publishing Raw Binary Data in Kombu\nDESCRIPTION: Shows how to publish raw binary data (a JPEG image) without serialization by specifying content_type and content_encoding explicitly in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> with open('~/my_picture.jpg', 'rb') as fh:\n...     producer.publish(fh.read(),\n                     content_type='image/jpeg',\n                     content_encoding='binary',\n                     routing_key=rkey)\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Priority Steps in Kombu Connection\nDESCRIPTION: Demonstrates how to configure custom priority steps when establishing a Redis connection in Kombu. The priority_steps transport option must be a list of numbers in sorted order.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> x = Connection('redis://', transport_options={\n...     'priority_steps': [0, 2, 4, 6, 8, 9],\n... })\n```\n\n----------------------------------------\n\nTITLE: Specifying Kombu Project Dependencies\nDESCRIPTION: This snippet lists the dependencies for the Kombu project, including version requirements and platform-specific conditions. It covers testing tools, database drivers, and various messaging-related libraries.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/test-ci.txt#2025-04-21_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\npytest-cov==5.0.0; python_version<\"3.9\"\npytest-cov==6.0.0; python_version>=\"3.9\"\ncodecov==2.1.13; sys_platform == 'win32'\nlibrabbitmq>=2.0.0; sys_platform == 'win32'\n-r extras/redis.txt\npymongo>=4.1.1; sys_platform != 'win32'\n-r extras/yaml.txt\n-r extras/msgpack.txt\n-r extras/azureservicebus.txt\n-r extras/azurestoragequeues.txt\nboto3>=1.26.143; sys_platform != 'win32'\nurllib3>=1.26.16; sys_platform != 'win32'\n-r extras/consul.txt\n-r extras/zookeeper.txt\n-r extras/brotli.txt\n-r extras/zstd.txt\n-r extras/sqlalchemy.txt\n-r extras/etcd.txt\n-r extras/gcpubsub.txt\n```\n\n----------------------------------------\n\nTITLE: Implementing JSON Serialization for Custom Types in Python\nDESCRIPTION: Shows how to define a __json__ method for custom types to enable JSON serialization in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Person:\n    first_name = None\n    last_name = None\n    address = None\n\n    def __json__(self):\n        return {\n            'first_name': self.first_name,\n            'last_name': self.last_name,\n            'address': self.address,\n        }\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for AWS Integration\nDESCRIPTION: Specifies minimum version requirements for boto3 (AWS SDK) and urllib3 (HTTP client library) needed for Kombu project functionality with AWS services.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/sqs.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nboto3>=1.26.143\nurllib3>=1.26.16\n```\n\n----------------------------------------\n\nTITLE: Configuring Native Delayed Delivery in Python using Kombu\nDESCRIPTION: This code snippet shows how to declare native delayed delivery queues and exchanges, and publish a message using the native delayed delivery mechanism in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/examples.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/delayed_infra.py\n    :language: python\n```\n\n----------------------------------------\n\nTITLE: Implementing Hello World Consumer in Python using Kombu\nDESCRIPTION: This code snippet shows how to create a consumer using Kombu to receive and print the 'Hello World' message sent by the publisher.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/examples.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/hello_consumer.py\n    :language: python\n```\n\n----------------------------------------\n\nTITLE: Specifying MsgPack Package Version\nDESCRIPTION: Specifies the required version of the MsgPack package to be installed as version 1.1.0. This is used for serialization/deserialization of messages in the Kombu messaging library.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/msgpack.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nmsgpack==1.1.0\n```\n\n----------------------------------------\n\nTITLE: Implementing Consumer Failover with Kombu ConsumerMixin\nDESCRIPTION: Demonstrates how to implement a consumer with failover functionality using the ConsumerMixin class. The consume method is wrapped with Connection.ensure() for automatic failover.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import *\n>>> from kombu.mixins import ConsumerMixin\n\n>>> class C(ConsumerMixin):\n...     def __init__(self, connection):\n...         self.connection = connection\n...     def get_consumers(self, Consumer, channel):\n...         return [\n...             Consumer(\n...                  [Queue('queue', routing_key='queue')],\n...                  callbacks=[self.on_message], accept=['json']\n...             ),\n...         ]\n...     def on_message(self, body, message):\n...         print('RECEIVED MESSAGE: {0!r}'.format(body))\n...         message.ack()\n...     def consume(self, *args, **kwargs):\n...         consume = conn.ensure(conn, super().consume)\n...         return consume(*args, **kwargs)\n\n\n>>> with Connection('amqp://broker1:5672;amqp://broker2:5672') as conn:\n...     C(conn).run()\n```\n\n----------------------------------------\n\nTITLE: Specifying Failover Strategy in Kombu Connection\nDESCRIPTION: Shows how to set a specific failover strategy when creating a Connection object. The 'round-robin' strategy is used in this example.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> Connection(\n...     'amqp://broker1.example.com;amqp://broker2.example.com',\n...     failover_strategy='round-robin'\n... )\n```\n\n----------------------------------------\n\nTITLE: Specifying Python-etcd Package Version Requirement\nDESCRIPTION: Defines minimum version requirement for the python-etcd package, which is used for interacting with etcd distributed key-value store. The package must be version 0.4.3 or higher.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/etcd.txt#2025-04-21_snippet_0\n\nLANGUAGE: plain\nCODE:\n```\npython-etcd>=0.4.3\n```\n\n----------------------------------------\n\nTITLE: Publishing to Task Queue\nDESCRIPTION: Example of publishing to a task queue with proper queue and exchange declarations for offline worker support.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import Exchange, Queue\n>>> task_queue = Queue('tasks', Exchange('tasks'), routing_key='tasks')\n\n>>> producer.publish(\n...     {'hello': 'world'}, ...,\n...     retry=True,\n...     exchange=task_queue.exchange,\n...     routing_key=task_queue.routing_key,\n...     declare=[task_queue],  # declares exchange, queue and binds.\n... )\n```\n\n----------------------------------------\n\nTITLE: Draining Events from a Single Consumer with Timeout in Python\nDESCRIPTION: This snippet shows how to drain events from a single consumer, setting a timeout of 1 second. It uses a context manager to ensure proper handling of the consumer.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> with consumer:\n...     connection.drain_events(timeout=1)\n```\n\n----------------------------------------\n\nTITLE: Defining SimpleBuffer Class for Non-Persistent Messaging in Python\nDESCRIPTION: The SimpleBuffer class provides a non-persistent messaging interface similar to SimpleQueue. It includes methods for getting, putting, and managing messages, as well as attributes for channel, producer, consumer, and queue configuration.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.simple.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass SimpleBuffer:\n    channel = None\n    producer = None\n    consumer = None\n    no_ack = None\n    queue = None\n    queue_opts = None\n    exchange_opts = None\n\n    def get(self):\n        pass\n\n    def get_nowait(self):\n        pass\n\n    def put(self):\n        pass\n\n    def clear(self):\n        pass\n\n    def __len__(self):\n        pass\n\n    def qsize(self):\n        pass\n\n    def close(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Specifying SoftLayer Messaging Package Requirements\nDESCRIPTION: Defines the minimum required version of the softlayer_messaging package as 1.0.3 or higher for Kombu messaging system integration\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/slmq.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsoftlayer_messaging>=1.0.3\n```\n\n----------------------------------------\n\nTITLE: Binding Exchanges to Connections in Kombu (Python)\nDESCRIPTION: This snippet demonstrates how to bind Exchange objects to connections in Kombu. It shows the difference between bound and unbound exchanges, and how binding allows for operations to be performed on the exchange.\nSOURCE: https://github.com/celery/kombu/blob/main/README.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> exchange = Exchange('tasks', 'direct')\n\n>>> connection = Connection()\n>>> bound_exchange = exchange(connection)\n>>> bound_exchange.delete()\n\n# the original exchange is not affected, and stays unbound.\n>>> exchange.delete()\nraise NotBoundError: Can't call delete on Exchange not bound to\n    a channel.\n```\n\n----------------------------------------\n\nTITLE: Specifying pycouchdb Dependency in Python Requirements File\nDESCRIPTION: This specification requires the pycouchdb library, version 1.16.0. The pycouchdb library is a Python client for working with CouchDB databases, and this exact version constraint ensures consistency across different environments.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/couchdb.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npycouchdb==1.16.0\n```\n\n----------------------------------------\n\nTITLE: Using Kombu Objects Outside 'with' Statements (Python)\nDESCRIPTION: This example illustrates how to use Kombu objects like Connection, Consumer, and Producer outside of 'with' statements. It emphasizes the importance of manually closing these objects after use to prevent resource leaks.\nSOURCE: https://github.com/celery/kombu/blob/main/README.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Connection, Consumer, Producer\n\nconnection = Connection()\n    # ...\nconnection.release()\n\nconsumer = Consumer(channel_or_connection, ...)\nconsumer.register_callback(my_callback)\nconsumer.consume()\n    # ....\nconsumer.cancel()\n```\n\n----------------------------------------\n\nTITLE: Acquiring Producers from Pool in Python\nDESCRIPTION: Shows how to acquire a producer from a producer pool using a Connection object's parameters. Uses a context manager to automatically release the producer and publish a message.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_42\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from kombu import Connection, producers\n>>> connection = Connection('amqp://guest:guest@localhost//')\n>>> with producers[connection].acquire(block=True):\n...     producer.publish({'hello': 'world'}, exchange='hello')\n```\n\n----------------------------------------\n\nTITLE: Specifying Azure Service Bus Version Requirement\nDESCRIPTION: Defines the minimum required version of the Azure Service Bus Python package (7.10.0 or higher) needed for integration with Celery Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/azureservicebus.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nazure-servicebus>=7.10.0\n```\n\n----------------------------------------\n\nTITLE: Configuring SQS Transport with Queue Prefix\nDESCRIPTION: Example of how to configure the SQS transport with a queue name prefix option. This allows grouping related queues in the SQS service.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nBrokerTransport('SQS://', transport_options={\n    'queue_name_prefix': 'myapp'})\n```\n\n----------------------------------------\n\nTITLE: Specifying Qpid Dependencies for Kombu\nDESCRIPTION: This snippet defines the minimum required versions for qpid-python and qpid-tools packages. Both packages must be version 0.26 or higher to ensure compatibility with the Kombu project.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/qpid.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nqpid-python>=0.26\nqpid-tools>=0.26\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Kombu Producer\nDESCRIPTION: Shows how to create a basic producer using a Kombu Connection object. The producer is used to publish messages to message brokers.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> producer = connection.Producer()\n```\n\n----------------------------------------\n\nTITLE: Acquiring Connections from Pool in Python\nDESCRIPTION: Demonstrates how to acquire a connection from a connection pool using a Connection object's parameters. Uses a context manager to automatically release the connection.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_41\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from kombu import Connection, connections\n>>> connection = Connection('amqp://guest:guest@localhost//')\n>>> with connections[connection].acquire(block=True):\n...     # do something with connection\n```\n\n----------------------------------------\n\nTITLE: Using Connection.autoretry in Python\nDESCRIPTION: Demonstrates using the autoretry method to automatically retry a function call on connection errors. It acquires a channel, calls a function, and ensures the channel is closed.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nchannel = connection.channel()\ntry:\n    ret, channel = connection.autoretry(send_messages, channel=channel)\nfinally:\n    channel.close()\n```\n\n----------------------------------------\n\nTITLE: Documenting DirectExchange Class in reStructuredText\nDESCRIPTION: Uses autoclass directive to generate documentation for the DirectExchange class, including all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.virtual.exchange.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: DirectExchange\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Using Exchange-to-Exchange Bindings in Kombu\nDESCRIPTION: Example of binding one exchange to another using the bind_to and unbind_from methods. This allows messages published to one exchange to be routed to another exchange.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ne1 = Exchange('A')(connection)\ne2 = Exchange('B')(connection)\n\ne2.bind_to(e1, routing_key='rkey', arguments=None)\ne2.unbind_from(e1, routing_key='rkey', arguments=None)\n```\n\n----------------------------------------\n\nTITLE: Documenting FanoutExchange Class in reStructuredText\nDESCRIPTION: Uses autoclass directive to generate documentation for the FanoutExchange class, including all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.virtual.exchange.rst#2025-04-21_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: FanoutExchange\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Publishing with Retry Support\nDESCRIPTION: Shows how to enable retry functionality when publishing messages to handle intermittent failures.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> producer.publish({'hello': 'world', ..., retry=True})\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Connection with Fanout Patterns in Python\nDESCRIPTION: Shows how to enable AMQP-style pattern matching for fanout exchanges when using the Redis transport. This allows for more flexible routing of messages.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> conn = kombu.Connection('redis://', transport_options={\n...     'fanout_patterns': True,\n... })\n```\n\n----------------------------------------\n\nTITLE: Documenting TopicExchange Class in reStructuredText\nDESCRIPTION: Uses autoclass directive to generate documentation for the TopicExchange class, including all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.virtual.exchange.rst#2025-04-21_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: TopicExchange\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Checking RabbitMQ QoS Behavior in Python\nDESCRIPTION: Demonstrates how to check if the connected RabbitMQ server is using new QoS behavior introduced in RabbitMQ 3.3. This can be used to adjust the apply_global flag when setting QoS prefetch count.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> Connection('amqp://').qos_behavior_matches_spec\nFalse\n```\n\nLANGUAGE: python\nCODE:\n```\ndef update_prefetch_count(channel, new_value):\n    channel.basic_qos(\n        0, new_value,\n        not channel.connection.client.qos_behavior_matches_spec,\n    )\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for GCP Pub/Sub Transport\nDESCRIPTION: Sphinx documentation structure defining the layout and organization of Google Cloud Pub/Sub transport documentation for Kombu. Includes section headers and autoclass directives for Transport and Channel classes.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.gcpubsub.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==============================================================\n Google Cloud Pub/Sub Transport - ``kombu.transport.gcpubsub``\n==============================================================\n\n.. currentmodule:: kombu.transport.gcpubsub\n\n.. automodule:: kombu.transport.gcpubsub\n\n    .. contents::\n        :local:\n\n    Transport\n    ---------\n\n    .. autoclass:: Transport\n        :members:\n        :undoc-members:\n\n    Channel\n    -------\n\n    .. autoclass:: Channel\n        :members:\n        :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages Using Producer Pool in Python\nDESCRIPTION: Shows how to use the producer pool to publish a message to an exchange. It demonstrates creating an exchange, preparing a message, and using a producer from the pool to publish the message.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/pools.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import Connection, Exchange\nfrom kombu.pools import producers\n\n# The exchange we send our news articles to.\nnews_exchange = Exchange('news')\n\n# The article we want to send\narticle = {'title': 'No cellular coverage on the tube for 2012',\n           'ingress': 'yadda yadda yadda'}\n\n# The broker where our exchange is.\nconnection = Connection('amqp://guest:guest@localhost:5672//')\n\nwith producers[connection].acquire(block=True) as producer:\n    producer.publish(\n        article,\n        exchange=news_exchange,\n        routing_key='domestic',\n        declare=[news_exchange],\n        serializer='json',\n        compression='zlib')\n```\n\n----------------------------------------\n\nTITLE: Using Kombu Connection.autoretry() for Method Calls with Channel Parameters\nDESCRIPTION: Shows how to use the autoretry() method for methods that accept a channel parameter, such as Queue.declare(). This ensures the channel is refreshed during failover.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/failover.rst#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import kombu\n>>> conn = kombu.Connection('amqp://broker1:5672;amqp://broker2:5672')\n>>> conn.connect()\n>>> q = kombu.Queue('test_queue')\n\n>>> declare = conn.autoretry(q.declare)\n>>> declare()\n```\n\n----------------------------------------\n\nTITLE: Disabling Content Types in Serializer Registry\nDESCRIPTION: Example showing how to disable specific content types in the serializer registry for security reasons. This can be used to prevent certain serialization formats like pickle.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu.serialization import registry\n# by name\n>>> registry.disable('pickle')\n# or by mime-type.\n>>> registry.disable('application/x-python-serialize')\n```\n\n----------------------------------------\n\nTITLE: Defining Confluent Kafka Transport Module in reStructuredText\nDESCRIPTION: This snippet defines the structure and content of the documentation for the confluent-kafka transport module. It includes section headers and directives for auto-generating class documentation.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.confluentkafka.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n=========================================================\n confluent-kafka Transport - ``kombu.transport.confluentkafka``\n=========================================================\n\n.. currentmodule:: kombu.transport.confluentkafka\n\n.. automodule:: kombu.transport.confluentkafka\n\n    .. contents::\n        :local:\n\n    Transport\n    ---------\n\n    .. autoclass:: Transport\n        :members:\n        :undoc-members:\n\n    Channel\n    -------\n\n    .. autoclass:: Channel\n        :members:\n        :undoc-members:\n\n    Message\n    -------\n\n    .. autoclass:: Message\n        :members:\n        :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Connection URLs for Failover in Kombu Connection\nDESCRIPTION: Example of configuring a Kombu Connection with multiple URLs for failover support. This feature allows specifying multiple broker connections that will be used in case the primary connection fails.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nConnection(['amqp://foo', 'amqp://bar'])\n```\n\n----------------------------------------\n\nTITLE: Importing Pyro Transport Module in Python\nDESCRIPTION: This snippet demonstrates how to import the Pyro transport module in Python. The module provides classes for implementing Pyro-based messaging transport in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.pyro.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.transport import pyro\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Pool Groups in Python\nDESCRIPTION: Demonstrates how to create custom connection and producer pool groups with specific limits. It also shows how to use these custom pools for acquiring connections.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/pools.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import pools\nfrom kombu import Connection\n\nconnections = pools.Connections(limit=100)\nproducers = pools.Producers(limit=connections.limit)\n\nconnection = Connection('amqp://guest:guest@localhost:5672//')\n\nwith connections[connection].acquire(block=True):\n    # ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Consumer with Content Type Whitelist in Kombu\nDESCRIPTION: Examples of creating a Consumer with the 'accept' parameter to specify a whitelist of content types to accept. This helps control which serialization formats are allowed.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nConsumer(accept=['application/json'])\nConsumer(accept=['pickle', 'json'])\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Kombu Mixins\nDESCRIPTION: ReStructuredText documentation setup for the kombu.mixins module, including table of contents and module autodoc directives.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.mixins.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n Mixin Classes - ``kombu.mixins``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.mixins\n\n.. automodule:: kombu.mixins\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Redis Unix Socket URL with Virtual Host Specification\nDESCRIPTION: Example URL syntax for connecting to Redis using a Unix socket while specifying a virtual host through database number as a query parameter.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nredis+socket:///tmp/redis.sock?virtual_host=3\n```\n\n----------------------------------------\n\nTITLE: RestructuredText Documentation Structure for URL Utils\nDESCRIPTION: Sphinx documentation structure defining the URL utilities module documentation, including table of contents and module reference.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.url.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n==============================================\n URL Utilities - ``kombu.utils.url``\n==============================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.utils.url\n\n.. automodule:: kombu.utils.url\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Creating SimpleQueue with Kombu Connection\nDESCRIPTION: Demonstrates how to create a SimpleQueue using a Kombu connection. This snippet shows the concise way to create and use a simple queue, automatically handling channel creation and closure.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/simple.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> queue = connection.SimpleQueue('myqueue')\n>>> # ... do something with queue\n>>> queue.close()\n```\n\n----------------------------------------\n\nTITLE: Configuring Consumer to Accept Specific Serialization Formats\nDESCRIPTION: Example showing how to explicitly configure a Consumer to accept specific content types/serialization formats rather than using the default (json-only) security setting.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> c = Consumer(conn, accept=['json', 'pickle', 'msgpack'])\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Kombu Project\nDESCRIPTION: This code snippet lists the required Python packages and their versions for the Kombu project. It includes dependencies for setup, testing, linting, documentation, and type checking. Some dependencies are version-specific or conditional based on the Python version.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/pkgutils.txt#2025-04-21_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nsetuptools>=47.0.0\nwheel>=0.29.0\nflake8==7.1.2\ntox>=4.4.8\nsphinx2rst>=1.0\nbumpversion==0.6.0\npydocstyle==6.3.0\nmypy==1.14.1\ntyping_extensions==4.12.2; python_version<\"3.10\"\n```\n\n----------------------------------------\n\nTITLE: RST Module Documentation Header\nDESCRIPTION: Sphinx documentation header and configuration for the kombu.utils.eventio module. Sets up the table of contents, current module context, and automodule documentation generation.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.eventio.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n Async I/O Selectors - ``kombu.utils.eventio``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.utils.eventio\n\n.. automodule:: kombu.utils.eventio\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Replacing deprecated Consumer.add_queue_from_dict method in Python\nDESCRIPTION: This code snippet demonstrates how to replace the deprecated Consumer.add_queue_from_dict method with the recommended alternative using Queue.from_dict.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nconsumer.add_queue(Queue.from_dict(queue_name, **options))\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Structure for Kombu Asynchronous Debug Module\nDESCRIPTION: A reStructuredText (RST) documentation file that sets up the documentation structure for the kombu.asynchronous.debug module. It uses Sphinx directives to define the content layout and automate API documentation generation.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.debug.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n Event Loop Debugging Utils - ``kombu.asynchronous.debug``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous.debug\n\n.. automodule:: kombu.asynchronous.debug\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Initializing Consumer with Specific Message Formats in Python\nDESCRIPTION: This snippet demonstrates how to create a Consumer that accepts specific message formats. It's important for specifying which serialization formats the consumer can handle.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/consumers.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> Consumer(conn, accept=['json', 'pickle', 'msgpack', 'yaml'])\n```\n\n----------------------------------------\n\nTITLE: Manual Channel Handling with Kombu\nDESCRIPTION: This snippet shows how to manually handle channels in Kombu instead of using the Consumer directly with the connection. This approach provides more control over the channel lifecycle.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/includes/introduction.txt#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwith connection.channel() as channel:\n    producer = Producer(channel, ...)\n    consumer = Consumer(channel)\n```\n\n----------------------------------------\n\nTITLE: Importing Object/Property Utilities from Kombu\nDESCRIPTION: This snippet demonstrates how to import the object and property utilities from the Kombu library. It uses the automodule directive to automatically generate documentation for all members and undocumented members in the module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.objects.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: kombu.utils.objects\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Setting Debug Environment Variables for Kombu\nDESCRIPTION: Example showing how to enable debug logging for Kombu channels using environment variables to trace method calls.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_46\n\nLANGUAGE: console\nCODE:\n```\n$ KOMBU_LOG_DEBUG=1 python\n>>> from kombu import Connection\n>>> conn = Connection()\n>>> channel = conn.channel()\nStart from server, version: 8.0, properties:\n    {u'product': 'RabbitMQ',..............  }\nOpen OK! known_hosts []\nusing channel_id: 1\nChannel open\n>>> channel.queue_declare('myq', passive=True)\n[Kombu channel:1] queue_declare('myq', passive=True)\n(u'myq', 0, 1)\n```\n\n----------------------------------------\n\nTITLE: Importing kombu.utils.imports Module in Python\nDESCRIPTION: This snippet demonstrates how to import the kombu.utils.imports module. It's a crucial step for accessing the module importing utilities provided by Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.imports.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.utils import imports\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Type for JSON Serialization in Kombu\nDESCRIPTION: Demonstrates how to register custom types (like Django models) for JSON serialization in Kombu using the register_type function with serialization and deserialization handlers.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu.utils.json import register_type\nfrom django.db.models import Model\nfrom django.apps import apps\n\n# Allow serialization of django models:\nregister_type(\n    Model,\n    \"model\",\n    lambda o: [o._meta.label, o.pk],\n    lambda o: apps.get_model(o[0]).objects.get(pk=o[1]),\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Consumer Priority in RabbitMQ with Python\nDESCRIPTION: Demonstrates how to set consumer priority using the x-priority argument when declaring a queue in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nQueue(\n    'qname',\n    exchange=Exchange('exchange'),\n    routing_key='qname',\n    consumer_arguments={'x-priority': 3},\n)\n```\n\n----------------------------------------\n\nTITLE: Enabling Insecure Serializers Globally\nDESCRIPTION: Code showing how to enable all serializers globally, including potentially insecure ones, for backward compatibility with earlier versions of Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import enable_insecure_serializers\n>>> enable_insecure_serializers()\n```\n\n----------------------------------------\n\nTITLE: Installing AMQP Library for pyamqp Transport\nDESCRIPTION: Command to install the amqp library required for using the pyamqp transport in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_28\n\nLANGUAGE: console\nCODE:\n```\n$ pip install amqp\n```\n\n----------------------------------------\n\nTITLE: Specifying Serialization Method Per Message in Kombu\nDESCRIPTION: Demonstrates how to override the default serialization method (using pickle in this example) for a specific message when publishing with a Producer in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> producer.publish(message, routing_key=rkey,\n...                  serializer='pickle')\n```\n\n----------------------------------------\n\nTITLE: Defining Serializer Registration Arguments in Module\nDESCRIPTION: Shows how to define the registration arguments tuple for a custom serializer to be used with Setuptools entry-points in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nregister_args = (my_encoder, my_decoder, 'application/x-mimetype', 'utf-8')\n```\n\n----------------------------------------\n\nTITLE: Defining Message Class in Kombu Transport Base (Python)\nDESCRIPTION: This snippet outlines the Message class from the kombu.transport.base module. It includes various attributes and methods for handling message properties, content, and actions like acknowledgment and rejection.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.base.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass Message:\n    payload\n    channel\n    delivery_tag\n    content_type\n    content_encoding\n    delivery_info\n    headers\n    properties\n    body\n    acknowledged\n\n    def ack(self):\n        pass\n\n    def reject(self):\n        pass\n\n    def requeue(self):\n        pass\n\n    def decode(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Specifying Platform-Specific Brotli Compression Dependencies for Kombu\nDESCRIPTION: This requirements specification sets up different Brotli compression libraries depending on the Python implementation. It uses brotlipy (version 0.7.0 or higher) for PyPy and the native brotli package (version 1.0.9 or higher) for CPython.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/brotli.txt#2025-04-21_snippet_0\n\nLANGUAGE: requirements.txt\nCODE:\n```\nbrotlipy>=0.7.0;platform_python_implementation==\"PyPy\"\nbrotli>=1.0.9;platform_python_implementation==\"CPython\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Dead-letter Queue in Virtual Transports\nDESCRIPTION: Example showing how to enable the dead-letter queue feature in virtual transports. This queue stores messages that couldn't be delivered to any destination.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n>>> x = Connection('redis://',\n...       transport_options={'deadletter_queue': 'ae.undeliver'})\n```\n\n----------------------------------------\n\nTITLE: Creating Connection with pyamqp Transport in Python\nDESCRIPTION: Example of establishing a connection using the pyamqp transport protocol with guest credentials to a localhost RabbitMQ server.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> conn = Connection('pyamqp://guest:guest@localhost//')\n```\n\n----------------------------------------\n\nTITLE: Importing MongoDB Transport Module in Python\nDESCRIPTION: This snippet shows how to import the MongoDB transport module in Kombu. It's typically used at the beginning of a file to access the MongoDB transport functionality.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.mongodb.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.transport.mongodb import Transport, Channel\n```\n\n----------------------------------------\n\nTITLE: Specifying Pyro4 Version Dependency for Kombu Project\nDESCRIPTION: This line specifies a requirement for Pyro4 version 4.82. Pyro4 is a library for Python Remote Objects that allows Python objects to communicate across process or network boundaries.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/pyro.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npyro4==4.82\n```\n\n----------------------------------------\n\nTITLE: Using Connection.Producer and Connection.Consumer\nDESCRIPTION: Example demonstrating how to use the Connection shortcuts for creating Producer and Consumer instances with the connection's default channel.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n>>> connection.Producer(exchange)\n>>> connection.Consumer(queues=..., callbacks=...)\n```\n\n----------------------------------------\n\nTITLE: Installing Kombu using easy_install\nDESCRIPTION: Command to install the Kombu package using easy_install, which is an older Python package installer.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/includes/installation.txt#2025-04-21_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ easy_install kombu\n```\n\n----------------------------------------\n\nTITLE: Creating Unique Broadcast Queue Names in Python\nDESCRIPTION: Example of creating a broadcast queue with a unique name by passing the 'unique' parameter. This generates a UUID-based unique name for the queue.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu.common import Broadcast\n>>> q = Broadcast(queue='foo', unique=True)\n>>> q.name\n'foo.7ee1ac20-cda3-4966-aaf8-e7a3bb548688'\n>>> q = Broadcast(queue='foo')\n>>> q.name\n'foo'\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents in reStructuredText for Kombu User Guide\nDESCRIPTION: This snippet defines the table of contents for the Kombu user guide using reStructuredText directives. It includes metadata like release version and date, and lists the main sections of the documentation.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n============\n User Guide\n============\n\n:Release: |version|\n:Date: |today|\n\n.. toctree::\n    :maxdepth: 2\n\n    introduction\n    connections\n    producers\n    consumers\n    examples\n    simple\n    pools\n    serialization\n    failover\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Etcd Transport\nDESCRIPTION: ReStructuredText documentation defining the structure and class documentation for Kombu's Etcd transport module, including autoclass directives for Transport and Channel classes.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.etcd.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n================================================\n Etcd Transport - ``kombu.transport.etcd``\n================================================\n\n.. currentmodule:: kombu.transport.etcd\n\n.. automodule:: kombu.transport.etcd\n\n    .. contents::\n        :local:\n\n    Transport\n    ---------\n\n    .. autoclass:: Transport\n        :members:\n        :undoc-members:\n\n    Channel\n    -------\n\n    .. autoclass:: Channel\n        :members:\n        :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Documenting SLMQ Transport Class in Python\nDESCRIPTION: Sphinx documentation for the Transport class in the SLMQ transport module. It uses autoclass to generate documentation for all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.SLMQ.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: Transport\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Queue with Multiple Bindings in Kombu\nDESCRIPTION: Example of defining a queue with multiple exchange bindings. This feature allows a single queue to receive messages from different exchanges with different routing keys.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom kombu import binding, Queue\n\nQueue('name', [\n    binding(Exchange('E1'), routing_key='foo'),\n    binding(Exchange('E1'), routing_key='bar'),\n    binding(Exchange('E2'), routing_key='baz'),\n])\n```\n\n----------------------------------------\n\nTITLE: Migrating Django database transport tables in Python\nDESCRIPTION: This code snippet shows how to run a fake initial migration for the kombu_transport_django tables when using Django 1.8 and have already created the tables.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n$ python manage.py migrate kombu_transport_django --fake-initial\n```\n\n----------------------------------------\n\nTITLE: Disabling Redis Acknowledgement Emulation in Kombu\nDESCRIPTION: Example of disabling acknowledgement emulation in the Redis transport by setting the 'ack_emulation' transport option to False, which reduces overhead but sacrifices data safety in case of unclean shutdown.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nConnection('redis://', transport_options={'ack_emulation': False})\n```\n\n----------------------------------------\n\nTITLE: Specifying Redis Version Constraints for Kombu\nDESCRIPTION: Defines the compatible Redis versions for the Kombu project using pip dependency syntax. It requires Redis 4.5.2 or higher, excludes problematic versions 4.5.5 and 5.0.2, and sets an upper version limit of 5.2.1.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/redis.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nredis>=4.5.2,!=4.5.5,!=5.0.2,<=5.2.1\n```\n\n----------------------------------------\n\nTITLE: Cleaning Up RabbitMQ Pidbox Exchanges with Bash and Python\nDESCRIPTION: Script to delete old pidbox exchanges from RabbitMQ. This combines bash commands with Python code to list and remove exchanges matching a pattern.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\n$ VHOST=/ URL=amqp:// python -c'import sys,kombu;[kombu.Connection(\n    sys.argv[-1]).channel().exchange_delete(x)\n        for x in sys.argv[1:-1]]' \\\n    $(sudo rabbitmqctl -q list_exchanges -p \"$VHOST\" \\\n    | grep \\.pidbox | awk '{print $1}') \"$URL\"\n```\n\n----------------------------------------\n\nTITLE: Importing MaybeChannelBound class from kombu.abstract\nDESCRIPTION: This snippet demonstrates how to import the MaybeChannelBound class from the kombu.abstract module. The MaybeChannelBound class is likely an abstract base class used in the Kombu messaging library.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.abstract.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.abstract import MaybeChannelBound\n```\n\n----------------------------------------\n\nTITLE: Direct Queue Publishing\nDESCRIPTION: Shows how to publish directly to a queue bypassing routing mechanisms using the anonymous exchange.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/producers.rst#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> producer.publish(\n...     {'hello': 'world'},\n...     exchange='',\n...     routing_key=task_queue.name,\n... )\n```\n\n----------------------------------------\n\nTITLE: Resolving Transport in Kombu\nDESCRIPTION: Uses the resolve_transport function to resolve a transport name or URL to its corresponding transport class.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.transport import resolve_transport\n\ntransport_class = resolve_transport('amqp://guest:guest@localhost:5672//')\n```\n\n----------------------------------------\n\nTITLE: Kombu Message Compression Module Structure (RST)\nDESCRIPTION: ReStructuredText documentation layout for the kombu.compression module, defining the structure for compression-related functions including compress/decompress operations and registry management.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.compression.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n=============================================\n Message Compression - ``kombu.compression``\n=============================================\n\n.. currentmodule:: kombu.compression\n\n.. automodule:: kombu.compression\n\n    .. contents::\n        :local:\n\n    Encoding/decoding\n    -----------------\n\n    .. autofunction:: compress\n    .. autofunction:: decompress\n\n    Registry\n    --------\n\n    .. autofunction:: encoders\n    .. autofunction:: get_encoder\n    .. autofunction:: get_decoder\n    .. autofunction:: register\n```\n\n----------------------------------------\n\nTITLE: Setting and Getting Pool Limits in Python\nDESCRIPTION: Illustrates how to set and get pool limits using Kombu's pool management functions. It shows the default limit and how to change it.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/pools.rst#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from kombu import pools\n>>> pools.get_limit()\n10\n>>> pools.set_limit(100)\n100\n>>> kombu.pools.get_limit()\n100\n```\n\n----------------------------------------\n\nTITLE: Accessing Default Transport in Kombu\nDESCRIPTION: Retrieves the default transport used when no specific transport is specified in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.transport import DEFAULT_TRANSPORT\n\ndefault_transport = DEFAULT_TRANSPORT\n```\n\n----------------------------------------\n\nTITLE: Including External RST File in RST Documentation\nDESCRIPTION: This directive imports content from the Changelog.rst file located in the parent directory. The include directive is a standard reStructuredText feature that allows content from other files to be inserted at the location of the directive.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/changelog.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. include:: ../Changelog.rst\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Kombu Clocks\nDESCRIPTION: Sphinx documentation structure defining the layout and automodule configuration for the kombu.clocks module documentation. Includes table of contents and module reference directives.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.clocks.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n Logical Clocks and Synchronization - ``kombu.clocks``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.clocks\n\n.. automodule:: kombu.clocks\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Defining SimpleQueue Class for Persistent Messaging in Python\nDESCRIPTION: The SimpleQueue class provides a persistent messaging interface with methods for getting, putting, and managing messages. It includes attributes for channel, producer, consumer, and queue configuration.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.simple.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass SimpleQueue:\n    channel = None\n    producer = None\n    consumer = None\n    no_ack = None\n    queue = None\n    queue_opts = None\n    exchange_opts = None\n\n    def get(self):\n        pass\n\n    def get_nowait(self):\n        pass\n\n    def put(self):\n        pass\n\n    def clear(self):\n        pass\n\n    def __len__(self):\n        pass\n\n    def qsize(self):\n        pass\n\n    def close(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Redis SentinelChannel Class Documentation Structure\nDESCRIPTION: RST documentation structure for the Redis SentinelChannel class used for Redis Sentinel support.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.redis.rst#2025-04-21_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: SentinelChannel\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: ReStructuredText Documentation Template for kombu.asynchronous.aws\nDESCRIPTION: This is a ReStructuredText documentation template that will generate API documentation for the kombu.asynchronous.aws module. It includes directives for table of contents and autodoc functionality.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.aws.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n==========================================================\n Async Amazon AWS Client - ``kombu.asynchronous.aws``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous.aws\n\n.. automodule:: kombu.asynchronous.aws\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Creating Buffer-Compatible Custom Serializer in Kombu\nDESCRIPTION: Demonstrates how to create a custom serializer that supports both strings and Python's buffer objects, wrapping pickle.loads to handle file objects in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/userguide/serialization.rst#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport pickle\nfrom io import BytesIO\nfrom kombu import serialization\n\n\ndef loads(s):\n    return pickle.load(BytesIO(s))\n\nserialization.register(\n    'my_pickle', pickle.dumps, loads,\n    content_type='application/x-pickle2',\n    content_encoding='binary',\n)\n```\n\n----------------------------------------\n\nTITLE: Redis Transport Class Documentation Structure\nDESCRIPTION: RST documentation structure for the Redis Transport class in Kombu's Redis transport module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.redis.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: Transport\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Defining Kombu Documentation Structure with reStructuredText\nDESCRIPTION: This snippet defines the structure of Kombu documentation using reStructuredText syntax for Sphinx documentation generator. It organizes documentation into two main sections and includes standard documentation indices.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/index.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. toctree::\n    :maxdepth: 2\n\n    introduction\n    userguide/index\n\n.. toctree::\n    :maxdepth: 1\n\n    faq\n    reference/index\n    changelog\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Structure for kombu.common Module\nDESCRIPTION: ReStructuredText markup for documenting the kombu.common module. The markup includes section headers, table of contents directive, currentmodule directive to set the context, and automodule directive to automatically generate documentation from the module's docstrings.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.common.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n==========================================================\n Common Utilities - ``kombu.common``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.common\n\n.. automodule:: kombu.common\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Specifying Kombu Dependencies with Version Constraints\nDESCRIPTION: This snippet defines the required packages and their version constraints for the Kombu project. It includes AMQP, Vine, and conditional dependencies for handling timezones based on the Python version.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/default.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\namqp>=5.1.1,<6.0.0\nvine==5.1.0\nbackports.zoneinfo[tzdata]>=0.2.1; python_version<\"3.9\"\ntzdata>=2025.2; python_version>=\"3.9\"\n```\n\n----------------------------------------\n\nTITLE: Importing Virtual Transport Module in Python\nDESCRIPTION: This snippet shows how to import the virtual transport module in Kombu. It uses the currentmodule directive to set the context for subsequent automodule and autoclass directives.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.virtual.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. currentmodule:: kombu.transport.virtual\n\n.. automodule:: kombu.transport.virtual\n```\n\n----------------------------------------\n\nTITLE: Documentation Structure for SQS Connection Module in Kombu\nDESCRIPTION: Sphinx documentation structure for the SQS connection module in Kombu's asynchronous AWS integration. The file sets up the table of contents, current module path, and automodule directive to generate documentation for all members of the module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.aws.sqs.connection.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n===========================================================\n SQS Connection - ``kombu.asynchronous.aws.sqs.connection``\n===========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous.aws.sqs.connection\n\n.. automodule:: kombu.asynchronous.aws.sqs.connection\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Queue.get to Accept Specific Serialization Formats\nDESCRIPTION: Example showing how to explicitly configure Queue.get to accept specific content types/serialization formats for synchronous message retrieval.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> msg = queue.get(accept=['json', 'pickle', 'msgpack'])\n```\n\n----------------------------------------\n\nTITLE: Documenting ExchangeType Interface in reStructuredText\nDESCRIPTION: Uses autoclass directive to generate documentation for the ExchangeType interface, including all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.virtual.exchange.rst#2025-04-21_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: ExchangeType\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Inserting Badges in reStructuredText for Kombu Project\nDESCRIPTION: This snippet defines image references for various badges used in the README, including build status, code coverage, license, wheel support, Python versions, and implementations. Each badge is linked to its respective source or information page.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/templates/readme.txt#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. |build-status| image:: https://github.com/celery/kombu/actions/workflows/ci.yaml/badge.svg\n    :alt: Build status\n    :target: https://github.com/celery/kombu/actions/workflows/ci.yml\n\n.. |coverage| image:: https://codecov.io/github/celery/kombu/coverage.svg?branch=main\n    :target: https://codecov.io/github/celery/kombu?branch=main\n\n.. |license| image:: https://img.shields.io/pypi/l/kombu.svg\n    :alt: BSD License\n    :target: https://opensource.org/licenses/BSD-3-Clause\n\n.. |wheel| image:: https://img.shields.io/pypi/wheel/kombu.svg\n    :alt: Kombu can be installed via wheel\n    :target: https://pypi.org/project/kombu/\n\n.. |pyversion| image:: https://img.shields.io/pypi/pyversions/kombu.svg\n    :alt: Supported Python versions.\n    :target: https://pypi.org/project/kombu/\n\n.. |pyimp| image:: https://img.shields.io/pypi/implementation/kombu.svg\n    :alt: Support Python implementations.\n    :target: https://pypi.org/project/kombu/\n```\n\n----------------------------------------\n\nTITLE: Initializing Redis Connection with Password from URL in Python\nDESCRIPTION: Added support for reading the Redis password from the transport URL when initializing a Redis connection in Kombu.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# Example Redis URL with password\nredis_url = \"redis://:password@localhost:6379/0\"\n\n# Kombu will now automatically extract the password from this URL\n```\n\n----------------------------------------\n\nTITLE: RestructuredText Documentation Structure for AMQP Transport\nDESCRIPTION: Sphinx documentation structure defining the module, classes, and their members for the pyamqp transport implementation. Includes sections for Transport, Connection, Channel, and Message classes with their respective member documentation directives.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.pyamqp.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n=========================================================\n Pure-python AMQP Transport - ``kombu.transport.pyamqp``\n=========================================================\n\n.. currentmodule:: kombu.transport.pyamqp\n\n.. automodule:: kombu.transport.pyamqp\n\n    .. contents::\n        :local:\n\n    Transport\n    ---------\n\n    .. autoclass:: Transport\n        :members:\n        :undoc-members:\n\n    Connection\n    ----------\n\n    .. autoclass:: Connection\n        :members:\n        :undoc-members:\n        :inherited-members:\n\n    Channel\n    -------\n\n    .. autoclass:: Channel\n        :members:\n        :undoc-members:\n\n    Message\n    -------\n\n    .. autoclass:: Message\n        :members:\n        :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Enabling Fanout Key Prefix in Redis Transport\nDESCRIPTION: Code example showing how to enable the fanout_keyprefix option for Redis transport, which ensures broadcast messages are only visible within the current virtual host.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nConnection('redis://', transport_options={'fanout_keyprefix': True})\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting Kombu Collections Module in RST\nDESCRIPTION: This RST (reStructuredText) snippet sets up autodocumentation for the kombu.utils.collections module. It uses the automodule directive to document all members and undocumented members in the module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.collections.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n Custom Collections - ``kombu.utils.collections``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.utils.collections\n\n.. automodule:: kombu.utils.collections\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Resetting Connection Pool in Python\nDESCRIPTION: Shows how to forcefully close and reset the connection pool.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_44\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from kombu import pools\n>>> pool.reset()\n```\n\n----------------------------------------\n\nTITLE: Importing JSON Utilities Module in Python\nDESCRIPTION: This snippet demonstrates how to import the JSON utilities module from Kombu. It's used to access JSON-related functionality within the Kombu library.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.json.rst#2025-04-21_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. currentmodule:: kombu.utils.json\n```\n\n----------------------------------------\n\nTITLE: Generating UUID Documentation for Kombu Utils\nDESCRIPTION: This code snippet uses Sphinx autodoc directives to automatically generate documentation for the kombu.utils.uuid module. It includes all members and undocumented members of the module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.uuid.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: kombu.utils.uuid\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Generating Object ID with UUID Fallback in Python\nDESCRIPTION: Added fallback to uuid.uuid5 in the generate_oid function if uuid.uuid3 fails, improving reliability of object ID generation.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nimport uuid\n\ndef generate_oid():\n    try:\n        return uuid.uuid3(...)\n    except ValueError:\n        return uuid.uuid5(...)\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency Versions for Celery Kombu Transports\nDESCRIPTION: This snippet lists the required versions of transport libraries for Celery Kombu. It includes Redis, MongoDB, Zookeeper, SQS (via boto3), and Qpid, with specific version constraints to ensure compatibility.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/funtest.txt#2025-04-21_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n# redis transport\nredis>=4.5.2,!=5.0.2,!=4.5.5\n\n# MongoDB transport\npymongo==4.10.1\n\n# Zookeeper transport\nkazoo==2.10.0\n\n# SQS transport\nboto3>=1.26.143\n\n# Qpid transport\nqpid-python>=0.26\nqpid-tools>=0.26\n```\n\n----------------------------------------\n\nTITLE: Specifying SQLAlchemy Version Requirements for Kombu\nDESCRIPTION: Defines the acceptable version range for SQLAlchemy dependency in the Kombu project. Sets minimum version to 1.4.48 and maximum version to anything below 2.1.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/sqlalchemy.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsqlalchemy>=1.4.48,<2.1\n```\n\n----------------------------------------\n\nTITLE: Retrieving Transport Class in Kombu\nDESCRIPTION: Uses the get_transport_cls function to retrieve a transport class based on the provided name or alias.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.rst#2025-04-21_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom kombu.transport import get_transport_cls\n\ntransport_class = get_transport_cls('redis')\n```\n\n----------------------------------------\n\nTITLE: Specifying Confluent Kafka Package Version in Python Dependencies\nDESCRIPTION: Defines a requirement for the confluent-kafka Python package, version 2.2.0 or higher. This is typically used in a requirements.txt file for pip installation of dependencies.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/confluentkafka.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nconfluent-kafka>=2.2.0\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies for Kombu Project\nDESCRIPTION: This requirements file specifies the dependencies needed for the Kombu project. It includes a direct GitHub reference for sphinx_celery documentation package and imports additional requirement files for various message broker integrations.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/docs.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ngit+https://github.com/celery/sphinx_celery.git\n-r extras/redis.txt\n-r extras/mongodb.txt\n-r extras/sqlalchemy.txt\n-r extras/azureservicebus.txt\n-r extras/sqs.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying PyMongo Dependency Version\nDESCRIPTION: Defines the minimum required version of the PyMongo package for MongoDB integration. Requires PyMongo version 4.1.1 or higher.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/mongodb.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npymongo>=4.1.1\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Celery and Kombu\nDESCRIPTION: This snippet lists two Python packages with their version requirements. pytest-xdist is pinned to version 3.6.1, while pytest-rerunfailures is specified with a minimum version of 11.1.2.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/test-integration.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npytest-xdist==3.6.1\npytest-rerunfailures>=11.1.2\n```\n\n----------------------------------------\n\nTITLE: Defining Version Requirements for Google Cloud Pub/Sub Integration in Kombu\nDESCRIPTION: This requirements file specifies the exact package versions needed for Google Cloud Pub/Sub integration in Kombu. It includes the minimum required version of Google Cloud Pub/Sub and Monitoring packages, while pinning exact versions for gRPC and Protocol Buffers to ensure compatibility.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/gcpubsub.txt#2025-04-21_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\ngoogle-cloud-pubsub>=2.18.4\ngoogle-cloud-monitoring>=2.16.0\ngrpcio==1.67.0\nprotobuf==4.25.5\n```\n\n----------------------------------------\n\nTITLE: Installing Kombu from source\nDESCRIPTION: Commands to build and install Kombu from a downloaded source tarball. This requires building the package first, then installing it with root privileges.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/includes/installation.txt#2025-04-21_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n$ python setup.py build\n# python setup.py install # as root\n```\n\n----------------------------------------\n\nTITLE: Specifying PyYAML Dependency for Kombu\nDESCRIPTION: This line specifies that the Kombu project requires PyYAML version 3.10 or higher. PyYAML is a YAML parser and emitter for Python, which is likely used for configuration or data serialization in the Kombu project.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/yaml.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nPyYAML>=3.10\n```\n\n----------------------------------------\n\nTITLE: Installing Kombu via easy_install in Python\nDESCRIPTION: This snippet demonstrates how to install Kombu using easy_install, an older Python package installation tool. It's a simple command that installs Kombu from PyPI.\nSOURCE: https://github.com/celery/kombu/blob/main/README.rst#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ easy_install kombu\n```\n\n----------------------------------------\n\nTITLE: Specifying Kazoo Dependency Version for Celery Kombu\nDESCRIPTION: This line specifies that the project requires kazoo version 2.8.0 or higher. Kazoo is a Python library for interacting with Apache ZooKeeper, suggesting that Celery Kombu may use ZooKeeper for distributed coordination or configuration management.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/zookeeper.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nkazoo>=2.8.0\n```\n\n----------------------------------------\n\nTITLE: Version Support Matrix in Markdown\nDESCRIPTION: A markdown table showing which versions of Kombu are currently supported for security updates. Only version 5.5.x is currently supported, with all older versions marked as unsupported.\nSOURCE: https://github.com/celery/kombu/blob/main/SECURITY.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Version | Supported          |\n| ------- | ------------------ |\n| 5.5.x   | :white_check_mark: |\n| 5.4.x   | :x:                |\n| 5.3.x   | :x:                |\n| 5.2.x   | :x:                |\n| 5.1.x   | :x:                |\n| < 5.0   | :x:                |\n```\n\n----------------------------------------\n\nTITLE: Installing Kombu using pip\nDESCRIPTION: Command to install the Kombu package using pip, which is the recommended Python package installer.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/includes/installation.txt#2025-04-21_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ pip install kombu\n```\n\n----------------------------------------\n\nTITLE: Configuring Django Transport in INSTALLED_APPS\nDESCRIPTION: Example configuration for adding the Django transport to INSTALLED_APPS. Required when using the 'django://' transport URL to enable the necessary database tables.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nINSTALLED_APPS = (\n    # …,\n    'kombu.transport.django',\n)\n```\n\n----------------------------------------\n\nTITLE: Including Sphinx Documentation Indices in reStructuredText\nDESCRIPTION: This snippet shows how to include standard Sphinx documentation indices (general index, module index, and search page) in a reStructuredText document.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/index.rst#2025-04-21_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n* :ref:`genindex`\n* :ref:`modindex`\n* :ref:`search`\n```\n\n----------------------------------------\n\nTITLE: Django Transport URL Format\nDESCRIPTION: Example showing the URL format for the Django transport. This transport uses Django's ORM for message storage.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_39\n\nLANGUAGE: text\nCODE:\n```\ndjango://\n```\n\n----------------------------------------\n\nTITLE: Defining Exception Classes in Kombu Python Package\nDESCRIPTION: Lists the core exception classes defined in the kombu.exceptions module. These exceptions handle various error conditions like binding errors, message state issues, timeouts, and resource limits.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.exceptions.rst#2025-04-21_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nNotBoundError\nMessageStateError\nTimeoutError\nLimitExceeded\nConnectionLimitExceeded\nChannelLimitExceeded\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Consul2 Dependency for Celery Kombu\nDESCRIPTION: This line specifies the python-consul2 package version 0.1.5 as a required dependency. It is likely part of a requirements file used for managing Python project dependencies.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/consul.txt#2025-04-21_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npython-consul2==0.1.5\n```\n\n----------------------------------------\n\nTITLE: Including FAQ Content in reStructuredText\nDESCRIPTION: This snippet uses the reStructuredText 'include' directive to incorporate the FAQ content from a file located in the parent directory. This is a common practice in documentation to maintain separate files for different sections and combine them in the final output.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/faq.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. include:: ../FAQ\n```\n\n----------------------------------------\n\nTITLE: Specifying zstandard Library Version for Celery/Kombu\nDESCRIPTION: This line specifies the exact version of the zstandard library required for the Celery/Kombu project. It indicates that version 0.23.0 of zstandard is needed.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/zstd.txt#2025-04-21_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\nzstandard==0.23.0\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for Kombu Semaphore Module\nDESCRIPTION: Sphinx documentation structure defining the contents and automodule directives for the kombu.asynchronous.semaphore module. Uses RST format to specify documentation hierarchy and module inclusion.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.semaphore.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n Semaphores - ``kombu.asynchronous.semaphore``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous.semaphore\n\n.. automodule:: kombu.asynchronous.semaphore\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Redis Channel Class Documentation Structure\nDESCRIPTION: RST documentation structure for the Redis Channel class used for message handling.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.redis.rst#2025-04-21_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: Channel\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Using Semicolon-Separated Connection URLs in Kombu\nDESCRIPTION: Alternative syntax for specifying multiple connection URLs using a semicolon-separated string instead of a list, which serves the same purpose for connection failover.\nSOURCE: https://github.com/celery/kombu/blob/main/Changelog.rst#2025-04-21_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nConnection('amqp://foo;amqp://bar')\n```\n\n----------------------------------------\n\nTITLE: Configuring ReStructuredText Documentation for native_delayed_delivery Module in Kombu\nDESCRIPTION: ReStructuredText directive setup for documenting the native_delayed_delivery module in Kombu. The configuration includes version information, table of contents, module reference, and automodule settings to display module members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.native_delayed_delivery.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n==========================================================\n Native Delayed Delivery - ``native_delayed_delivery``\n==========================================================\n\n.. versionadded:: 5.5\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.transport.native_delayed_delivery\n\n.. automodule:: kombu.transport.native_delayed_delivery\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Setting up Sphinx Documentation for Kombu's Asynchronous Event Loop Module\nDESCRIPTION: This snippet shows the Sphinx directives used to configure documentation for the kombu.asynchronous module. It sets up a table of contents, specifies the current module, and configures the automodule directive to include all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous\n\n.. automodule:: kombu.asynchronous\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Documenting SLMQ Channel Class in Python\nDESCRIPTION: Sphinx documentation for the Channel class in the SLMQ transport module. It uses autoclass to generate documentation for all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.SLMQ.rst#2025-04-21_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: Channel\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Documenting Azure Service Bus Transport Module in RST\nDESCRIPTION: This RST code defines the structure for documenting the Azure Service Bus Transport module in Kombu. It includes sections for the module itself, the Transport class, and the Channel class.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.azureservicebus.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n==================================================================\n Azure Service Bus Transport - ``kombu.transport.azureservicebus``\n==================================================================\n\n.. currentmodule:: kombu.transport.azureservicebus\n\n.. automodule:: kombu.transport.azureservicebus\n\n    .. contents::\n        :local:\n\n    Transport\n    ---------\n\n    .. autoclass:: Transport\n        :members:\n        :undoc-members:\n\n    Channel\n    -------\n\n    .. autoclass:: Channel\n        :members:\n        :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Structure for kombu.asynchronous.aws.sqs.queue Module\nDESCRIPTION: This RST (reStructuredText) snippet defines the structure of a Sphinx documentation page for the kombu.asynchronous.aws.sqs.queue module. It includes a title, table of contents, module reference, and directive to automatically document all members and undocumented members of the module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.aws.sqs.queue.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n SQS Queues - ``kombu.asynchronous.aws.sqs.queue``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous.aws.sqs.queue\n\n.. automodule:: kombu.asynchronous.aws.sqs.queue\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: RST Document Structure for Kombu HTTP Client Documentation\nDESCRIPTION: RST (reStructuredText) formatting for the Kombu asynchronous HTTP client documentation page. Includes table of contents, module reference, and member documentation directives.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.http.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n==========================================================\n Async HTTP Client - ``kombu.asynchronous.http``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous.http\n\n.. automodule:: kombu.asynchronous.http\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Autodocumenting JSON Utilities Module in Python\nDESCRIPTION: This snippet shows the Sphinx autodoc directive used to generate documentation for the 'kombu.utils.json' module. It includes all members and undocumented members of the module.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.json.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n.. automodule:: kombu.utils.json\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Setting up Sphinx Documentation for kombu.utils.amq_manager\nDESCRIPTION: Sphinx reStructuredText configuration for documenting the generic RabbitMQ manager module. It includes a table of contents, sets the current module, and configures the autodoc directive to include all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.utils.amq_manager.rst#2025-04-21_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n========================================================\n Generic RabbitMQ manager - ``kombu.utils.amq_manager``\n========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.utils.amq_manager\n\n.. automodule:: kombu.utils.amq_manager\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Configuring Extra Package Index for Windows Wheels in Pip\nDESCRIPTION: This configuration line adds an additional package index URL to pip for fetching Windows wheel packages. It points to a temporary repository hosted by nehaljwani on Anaconda.org's simple API endpoint.\nSOURCE: https://github.com/celery/kombu/blob/main/requirements/extras/lzma.txt#2025-04-21_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\n--extra-index-url https://pypi.anaconda.org/nehaljwani/simple # Temporary index for Windows wheels\n```\n\n----------------------------------------\n\nTITLE: Including Resources with reStructuredText Directive\nDESCRIPTION: Includes additional resources from an external file using the reStructuredText include directive.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/introduction.rst#2025-04-21_snippet_2\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. include:: includes/resources.txt\n```\n\n----------------------------------------\n\nTITLE: Defining Sphinx Documentation Structure for Kombu Timer Module\nDESCRIPTION: This snippet sets up the Sphinx documentation structure for the kombu.asynchronous.timer module. It includes a table of contents, sets the current module, and uses automodule directive to generate documentation for all members and undocumented members.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.asynchronous.timer.rst#2025-04-21_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n==========================================================\n Timer - ``kombu.asynchronous.timer``\n==========================================================\n\n.. contents::\n    :local:\n.. currentmodule:: kombu.asynchronous.timer\n\n.. automodule:: kombu.asynchronous.timer\n    :members:\n    :undoc-members:\n```\n\n----------------------------------------\n\nTITLE: Defining Transport Class in Kombu Transport Base (Python)\nDESCRIPTION: This snippet describes the Transport class from the kombu.transport.base module. It includes attributes and methods for managing connections, channels, and error handling in transport operations.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/reference/kombu.transport.base.rst#2025-04-21_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass Transport:\n    client\n    default_port\n\n    recoverable_connection_errors = None\n    recoverable_channel_errors = None\n\n    connection_errors\n    channel_errors\n\n    def establish_connection(self):\n        pass\n\n    def close_connection(self):\n        pass\n\n    def create_channel(self):\n        pass\n\n    def close_channel(self):\n        pass\n\n    def drain_events(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Including Installation Instructions with reStructuredText Directive\nDESCRIPTION: Includes the installation instructions from an external file using the reStructuredText include directive.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/introduction.rst#2025-04-21_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. include:: includes/installation.txt\n```\n\n----------------------------------------\n\nTITLE: Including Introduction Content with reStructuredText Directive\nDESCRIPTION: Includes the introduction content from an external file using the reStructuredText include directive.\nSOURCE: https://github.com/celery/kombu/blob/main/docs/introduction.rst#2025-04-21_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. include:: includes/introduction.txt\n```"
  }
]