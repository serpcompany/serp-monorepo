[
  {
    "owner": "go-fuego",
    "repo": "fuego",
    "content": "TITLE: Comprehensive Server Example with Middleware, Transformation, and OpenAPI (Go)\nDESCRIPTION: This complete example integrates multiple Fuego features: server setup with custom address, middleware (compression, CORS), a POST route with input and output transformation, standard handler integration, and route documentation. Implements 'InTransform' and 'OutTransform' for pre-validation and response shaping. Dependencies: Fuego, 'github.com/rs/cors', 'github.com/go-chi/chi/v5/middleware', Go standard library. Handles advanced error cases and demonstrates header mutation. Inputs: POST JSON '{\"name\": ...}', GET to '/std'. Outputs: JSON with transformed content or error; plain text for '/std'.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/README.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n\n\tchiMiddleware \"github.com/go-chi/chi/v5/middleware\"\n\t\"github.com/go-fuego/fuego\"\n\t\"github.com/rs/cors\"\n)\n\ntype Received struct {\n\tName string `json:\"name\" validate:\"required\"`\n}\n\ntype MyResponse struct {\n\tMessage       string `json:\"message\"`\n\tBestFramework string `json:\"best\"`\n}\n\nfunc main() {\n\ts := fuego.NewServer(\n\t\tfuego.WithAddr(\"localhost:8088\"),\n\t)\n\n\tfuego.Use(s, cors.Default().Handler)\n\tfuego.Use(s, chiMiddleware.Compress(5, \"text/html\", \"text/css\"))\n\n\t// Fuego ðŸ”¥ handler with automatic OpenAPI generation, validation, (de)serialization and error handling\n\tfuego.Post(s, \"/\", func(c fuego.ContextWithBody[Received]) (MyResponse, error) {\n\t\tdata, err := c.Body()\n\t\tif err != nil {\n\t\t\treturn MyResponse{}, err\n\t\t}\n\n\t\tc.Response().Header().Set(\"X-Hello\", \"World\")\n\n\t\treturn MyResponse{\n\t\t\tMessage:       \"Hello, \" + data.Name,\n\t\t\tBestFramework: \"Fuego!\",\n\t\t}, nil\n\t})\n\n\t// Standard net/http handler with automatic OpenAPI route declaration\n\tfuego.GetStd(s, \"/std\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello, World!\"))\n\t})\n\n\ts.Run()\n}\n\n// InTransform will be called when using c.Body().\n// It can be used to transform the entity and raise custom errors\nfunc (r *Received) InTransform(context.Context) error {\n\tr.Name = strings.ToLower(r.Name)\n\tif r.Name == \"fuego\" {\n\t\treturn errors.New(\"fuego is not a name\")\n\t}\n\treturn nil\n}\n\n// OutTransform will be called before sending data\nfunc (r *MyResponse) OutTransform(context.Context) error {\n\tr.Message = strings.ToUpper(r.Message)\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Fuego Hello World Server in Golang\nDESCRIPTION: This Go code snippet demonstrates creating and running a minimal web server using the Fuego framework. The code imports Fuego, initializes a new server, defines a single 'GET' endpoint at '/', and maps it to a handler that returns \"Hello, World!\". Dependencies include the 'github.com/go-fuego/fuego' package and Go v1.22+. The 'main' function starts the server; the handler function uses Fuego's context interface. Input is handled via HTTP, output is a plain text response, and the structure serves as a basic template for RESTful microservices.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/index.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\tfuego.Get(s, \"/\", helloWorld)\n\n\ts.Run()\n}\n\nfunc helloWorld(c fuego.ContextNoBody) (string, error) {\n\treturn \"Hello, World!\", nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Minimal Fuego HTTP Server Example - Go\nDESCRIPTION: This Go code defines a minimal HTTP server using the Fuego framework. It creates a server, registers a GET endpoint at '/', and returns 'Hello, World!' for incoming requests. Dependencies include the github.com/go-fuego/fuego package. The server listens for HTTP requests and can be run using Go tooling. The main parameter is a context (c fuego.ContextNoBody); the output is a plain text HTTP response.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/01-hello-world.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\tfuego.Get(s, \"/\", func(c fuego.ContextNoBody) (string, error) {\n\t\treturn \"Hello, World!\", nil\n\t})\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Request Body in a Fuego Controller using ContextWithBody in Go\nDESCRIPTION: This snippet shows a Fuego controller that processes a request body. It defines an input struct `MyInput` and uses `fuego.ContextWithBody[MyInput]` as the context type. The `c.Body()` method deserializes the request body into the `MyInput` struct based on the `Content-Type` header. The controller then uses the parsed body data to construct a response.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\n    Name string `json:\"name\"`\n}\n\nfunc MyController(c fuego.ContextWithBody[MyInput]) (*MyResponse, error) {\n    body, err := c.Body()\n    if err != nil {\n        return nil, err\n    }\n\n    return &MyResponse{\n        Name: body.Name,\n    }, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a POST Endpoint with Input Validation (Go)\nDESCRIPTION: This snippet defines typed input/output structs, sets up a Fuego POST endpoint with automatic OpenAPI documentation, and illustrates handler-level validation. The handler reads, deserializes, and validates the incoming JSON payload, then returns a personalized message. Fuego and Go's struct tags (with 'validate') are required. Input: JSON with 'name'; Output: JSON with 'message'. Limitation: Name is required and must be non-empty.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/README.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/go-fuego/fuego\"\n\ntype MyInput struct {\n\tName string `json:\"name\" validate:\"required\"`\n}\n\ntype MyOutput struct {\n\tMessage string `json:\"message\"`\n}\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\t// Automatically generates OpenAPI documentation for this route\n\tfuego.Post(s, \"/user/{user}\", myController)\n\n\ts.Run()\n}\n\nfunc myController(c fuego.ContextWithBody[MyInput]) (*MyOutput, error) {\n\tbody, err := c.Body()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &MyOutput{Message: \"Hello, \" + body.Name}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Interface in Generated Fuego Controller (Go)\nDESCRIPTION: Illustrates how to modify the generated `controller/books.go` file after using the Fuego generator. It shows defining a `BooksResources` struct to hold dependencies (like `BooksService`), defining the `BooksService` interface for CRUD operations, and creating a concrete implementation (`RealBooksService`). An example implementation for the `GetBooks` method is provided as a starting point. This uses a dependency injection pattern.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/02-crud.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage controller\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\ntype BooksResources struct {\n\t// Use a concrete struct that implements the service (BooksService -> RealBooksService)\n\tBooksService RealBooksService\n}\n\ntype Books struct {\n\tID   string `json:\"id\"`\n\n\n// ....\n// ....\n\ntype BooksService interface {\n\tGetBooks(id string) (Books, error)\n\tCreateBooks(BooksCreate) (Books, error)\n\tGetAllBooks() ([]Books, error)\n\tUpdateBooks(id string, input BooksUpdate) (Books, error)\n\tDeleteBooks(id string) (any, error)\n}\n\n\n// Implement the BooksService interface\ntype RealBooksService struct {\n\t// Embed the interface to satisfy it.\n\t// This pattern is just there to make the code compile but you should implement all methods.\n\tBooksService\n}\n\nfunc (s RealBooksService) GetBooks(id string) (Books, error) {\n\treturn Books{\n\t\tID:   id,\n\t\tName: \"Test book data\",\n\t}, nil\n}\n\n// TODO: Other BooksService interface implementations\n\n// END OF CODE BLOCK\n```\n\n----------------------------------------\n\nTITLE: Manually Defining Fuego CRUD Controller Stubs (Go)\nDESCRIPTION: Provides stub implementations for the CRUD controller functions referenced in the manual route definition example. Located in `controller/books.go`, it defines data structures (`Book`, `BookToCreate`) and handler functions (`GetBooks`, `CreateBook`, `GetBook`, `UpdateBook`, `DeleteBook`) with appropriate Fuego context types (`fuego.ContextNoBody`, `fuego.ContextWithBody`). These functions need to be filled with actual business logic.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/02-crud.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage controller\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\ntype Book struct {\n\tID    string `json:\"id\"`\n\tTitle string `json:\"title\"`\n}\n\ntype BookToCreate struct {\n\tTitle string `json:\"title\"`\n}\n\nfunc GetBooks(c fuego.ContextNoBody) ([]Book, error) {\n\t// Your code here\n\treturn nil, nil\n}\n\nfunc CreateBook(c fuego.ContextWithBody[BookToCreate]) (Book, error) {\n\t// Your code here\n\treturn Book{}, nil\n}\n\nfunc GetBook(c fuego.ContextNoBody) (Book, error) {\n\t// Your code here\n\treturn Book{}, nil\n}\n\nfunc UpdateBook(c fuego.ContextWithBody[Book]) (Book, error) {\n\t// Your code here\n\treturn Book{}, nil\n}\n\nfunc DeleteBook(c fuego.ContextNoBody) (any, error) {\n\t// Your code here\n\treturn nil, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing a Simple API Server with Fuego (Go)\nDESCRIPTION: This code initializes a Fuego server in Go, demonstrates registering a GET route, and starts the server. Dependencies include the Fuego Go module. The handler returns a static 'Hello, World!' response using a simplified API. Input: HTTP GET request to '/'. Output: Plain text response. There are no authentication or authorization constraints in this example.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport \"github.com/go-fuego/fuego\"\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\tfuego.Get(s, \"/\", func(c fuego.ContextNoBody) (string, error) {\n\t\treturn \"Hello, World!\", nil\n\t})\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Routes with Fuego in Go\nDESCRIPTION: This Go code snippet demonstrates how to create a Fuego server and define REST-style HTTP routes using 'fuego.Get' and 'fuego.Post'. It shows registering handlers for GET and POST requests on '/books', as well as a parameterized GET on '/books/{id}'. The example depends on the 'github.com/go-fuego/fuego' package. The 'helloWorld' handler should be implemented separately, and the server starts using 's.Run()'. Expected inputs are HTTP requests to the defined paths, with outputs determined by the route handlers.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/routing.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\\n\\nimport (\\n\\t\\\"github.com/go-fuego/fuego\\\"\\n)\\n\\nfunc main() {\\n\\ts := fuego.NewServer()\\n\\n\\tfuego.Get(s, \\\"/books\\\", helloWorld)\\n\\tfuego.Post(s, \\\"/books\\\", helloWorld)\\n\\tfuego.Get(s, \\\"/books/{id}\\\", helloWorld)\\n\\n\\ts.Run()\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Registering a GET Route with a Fuego Controller in Go\nDESCRIPTION: This snippet demonstrates how to register a GET route using `fuego.Get`. It associates the root path `/` with the `MyController` function on the Fuego server instance `s`. See the Routing documentation for more details.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfuego.Get(s, \"/\", MyController)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Configuring a Fuego Server in Go\nDESCRIPTION: This snippet shows how to create and configure a Fuego server with custom address, OpenAPI options, and a simple route handler. It illustrates dependency on the 'github.com/go-fuego/fuego' package and demonstrates the use of functional options for server setup. The handler returns a basic greeting string as the route response.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/options.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\\n\\nimport \\\"github.com/go-fuego/fuego\\\"\\n\\nfunc main() {\\n\\ts := fuego.NewServer(\\n\\t\\tfuego.WithAddr(\\\"localhost:8080\\\"),\\n\\t\\tfuego.WithEngineOptions(\\n\\t\\t\\tfuego.WithOpenAPIConfig(fuego.OpenAPIConfig{\\n\\t\\t\\t\\tDisableSwagger: true,\\n\\t\\t\\t}),\\n\\t\\t),\\n\\t)\\n\\n\\tfuego.Get(s, \\\"/\\\", func(c fuego.ContextNoBody) (string, error) {\\n\\t\\treturn \\\"Hello, World!\\\", nil\\n\\t})\\n\\n\\ts.Run()\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Standard net/http Middleware and Handlers (Go)\nDESCRIPTION: This code demonstrates Fuego's compatibility with Go's 'net/http' middleware and handlers. It registers a custom middleware that sets headers, connects standard HTTP handlers for OpenAPI documentation, and runs the server. Dependencies: Go standard library, Fuego package. Input: HTTP requests to '/std' and any route. Output: Responses with extra headers as set by middleware. No third-party frameworks needed.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/README.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\t// Standard net/http middleware\n\tfuego.Use(s, func(next http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Header().Set(\"X-Hello\", \"World\")\n\t\t\tnext.ServeHTTP(w, r)\n\t\t})\n\t})\n\n\t// Standard net/http handler with automatic OpenAPI route declaration\n\tfuego.GetStd(s, \"/std\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello, World!\"))\n\t})\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Table-Driven Testing of Fuego Controllers in Go\nDESCRIPTION: This snippet provides a full-fledged table-driven test harness for a Fuego controller in Go that utilizes request body validation, query parameters, and table-driven patterns. It defines test cases with varying inputs and expected results, sets up the mock context (including OpenAPI-based parameter docs and defaults), and verifies outcomes including error scenarios. Prerequisites are Fuego, testify/assert, and Go\\'s testing framework. Inputs vary by test case; outputs are controller responses or error asserts. This structure facilitates scalable and maintainable test coverage for application logic.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/testing.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// UserSearchRequest represents the search criteria\ntype UserSearchRequest struct {\n    MinAge    int    `json:\"minAge\" validate:\"gte=0,lte=150\"`\n    MaxAge    int    `json:\"maxAge\" validate:\"gte=0,lte=150\"`\n    NameQuery string `json:\"nameQuery\" validate:\"required\"`\n}\n\n// SearchUsersController is our controller to test\nfunc SearchUsersController(c fuego.ContextWithBody[UserSearchRequest]) (UserSearchResponse, error) {\n    body, err := c.Body()\n    if err != nil {\n        return UserSearchResponse{}, err\n    }\n\n    // Get pagination from query params\n    page := c.QueryParamInt(\"page\")\n    if page < 1 {\n        page = 1\n    }\n\n    // Business logic validation\n    if body.MinAge > body.MaxAge {\n        return UserSearchResponse{}, errors.New(\"minAge cannot be greater than maxAge\")\n    }\n\n    // ... rest of the controller logic\n}\n\nfunc TestSearchUsersController(t *testing.T) {\n    tests := []struct {\n        name          string\n        body          UserSearchRequest\n        setupContext  func(*fuego.MockContext[UserSearchRequest])\n        expectedError string\n        expected      UserSearchResponse\n    }{\n        {\n            name: \"successful search\",\n            body: UserSearchRequest{\n                MinAge:    20,\n                MaxAge:    35,\n                NameQuery: \"John\",\n            },\n            setupContext: func(ctx *fuego.MockContext[UserSearchRequest]) {\n                // Add query parameters with OpenAPI validation\n                ctx.WithQueryParamInt(\"page\", 1,\n                    fuego.ParamDescription(\"Page number\"),\n                    fuego.ParamDefault(1))\n                ctx.WithQueryParamInt(\"perPage\", 20,\n                    fuego.ParamDescription(\"Items per page\"),\n                    fuego.ParamDefault(20))\n            },\n            expected: UserSearchResponse{\n                // ... expected response\n            },\n        },\n    }\n\n    for _, tt := range tests {\n        t.Run(tt.name, func(t *testing.T) {\n            // Create mock context with the test body\n            ctx := fuego.NewMockContext[UserSearchRequest](tt.body)\n\n            // Set up context with query parameters\n            if tt.setupContext != nil {\n                tt.setupContext(ctx)\n            }\n\n            // Call the controller\n            response, err := SearchUsersController(ctx)\n\n            // Check error cases\n            if tt.expectedError != \"\" {\n                assert.EqualError(t, err, tt.expectedError)\n                return\n            }\n\n            // Check success cases\n            assert.NoError(t, err)\n            assert.Equal(t, tt.expected, response)\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Structured BadRequestError in Fuego Controller (Go)\nDESCRIPTION: Demonstrates returning a specific Fuego error type (`fuego.BadRequestError`) from a controller after a hypothetical function fails. This generates a structured 400 Bad Request response compliant with RFC 9457, including a title and the original error details, which is both logged and returned to the client.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/errors.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc MyController(c fuego.ContextNoBody) (string, error) {\n\t_, err := someFunction()\n\tif err != nil {\n\t\treturn \"\", fuego.BadRequestError{Title: \"You cannot do that\", Err: err} // Returns and logs a structured 400 error.\n\t}\n\n\treturn \"success\", nil\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Fuego ErrorWithStatus Interface (Go)\nDESCRIPTION: Presents the Go interface definition for `fuego.ErrorWithStatus`. Errors implementing this interface, specifically the `StatusCode()` method returning an HTTP status code, can be automatically converted by Fuego's default error handler into an `fuego.HTTPError` for structured HTTP responses compliant with RFC 9457.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/errors.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n```go\ntype ErrorWithStatus interface {\n\terror\n\tStatusCode() int\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Manually Defining Fuego CRUD Routes (Go)\nDESCRIPTION: Demonstrates how to manually define CRUD routes in `main.go` without using the generator. It uses `fuego.Get`, `fuego.Post`, `fuego.Put`, `fuego.Patch`, and `fuego.Delete` functions to map HTTP methods and URL paths (like `/books` and `/books/:id`) to specific handler functions defined in the `controller` package.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/02-crud.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n\n\t\"hello-fuego/controller\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\t// List all books\n\tfuego.Get(s, \"/books\", controller.GetBooks)\n\n\t// Create a new book\n\tfuego.Post(s, \"/books\", controller.CreateBook)\n\n\t// Get a book by id\n\tfuego.Get(s, \"/books/:id\", controller.GetBook)\n\n\t// Update a book by id\n\tfuego.Put(s, \"/books/:id\", controller.UpdateBook)\n\n\t// Update a book by id\n\tfuego.Patch(s, \"/books/:id\", controller.UpdateBook)\n\n\t// Delete a book by id\n\tfuego.Delete(s, \"/books/:id\", controller.DeleteBook)\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Input Transformation and Custom Validation (Go)\nDESCRIPTION: This snippet showcases a struct implementing Fuego's 'InTransform' interface for advanced input transformation and custom validation prior to handler execution. It lowercases the input name and rejects a specific value ('fuego'). The context parameter is available for deeper validation. Input: Struct instance via HTTP request. Output: Possible error from transformation, or proceeds if valid. Dependencies: Go's 'strings' and 'errors' packages.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/README.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\n\tName string `json:\"name\" validate:\"required\"`\n}\n\n// Will be called just before returning c.Body()\nfunc (r *MyInput) InTransform(context.Context) error {\n\tr.Name = strings.ToLower(r.Name)\n\n\tif r.Name == \"fuego\" {\n\t\treturn errors.New(\"fuego is not a valid name for this input\")\n\t}\n\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fuego Controller to Apply Input Transformation in Go\nDESCRIPTION: Provides an example of a Fuego controller function that utilizes the User struct with a custom transformation method. The function retrieves the transformed User from the request context, ensuring input normalization before any business logic executes. Input parameter c is of type fuego.ContextWithBody[User], and the output is a User struct with preprocessed fields and an error if applicable.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/transformation.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc echoCapitalized(c fuego.ContextWithBody[User]) (User, error) {\n\tuser, err := c.Body()\n\tif err != nil {\n\t\treturn User{}, err\n\t}\n\n\t// user.FirstName is in uppercase\n\n\treturn u, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Controllers Using Fuego\\'s MockContext in Go\nDESCRIPTION: This snippet demonstrates how to use Fuego\\'s MockContext type to test a controller function in Go. It shows creating a mock request context with a typed body, setting query parameters, calling a controller function, and asserting the results using the testify/assert package. Dependencies required include the Fuego library and testify/assert for test assertions. The inputs are a request struct and parameters; the output is an asserted controller response. The pattern enables testing business logic directly, separate from HTTP transport concerns.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/testing.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc TestMyController(t *testing.T) {\n    // Create a new mock context with the request body\n    ctx := fuego.NewMockContext(MyRequestType{\n        Name: \"John\",\n        Age:  30,\n    })\n\n    // Add query parameters\n    ctx.SetQueryParamInt(\"page\", 1)\n\n    // Call your controller\n    response, err := MyController(ctx)\n\n    // Assert the results\n    assert.NoError(t, err)\n    assert.Equal(t, expectedResponse, response)\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Struct Field Validation with go-playground/validator in Go\nDESCRIPTION: This snippet demonstrates using Go struct tags to enforce validation rules for incoming data using the go-playground/validator library. Each field in the User struct is decorated with validation constraints such as 'required', 'email', and numeric boundaries. Required dependencies include the 'github.com/go-playground/validator' package. The expected input is a struct instance, typically populated via unmarshaling user input like JSON; the output is a struct whose fields conform to the specified rules or a validation error if not. Main limitation: only basic rule-based validation as supported by tag syntax.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/validation.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype User struct {\n\tFirstName string `json:\"first_name\" validate:\"required\"`\n\tLastName  string `json:\"last_name\" validate:\"required\"`\n\tAge       int    `json:\"age\" validate:\"gte=0,lte=130\"`\n\tEmail     string `json:\"email\" validate:\"email\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing OpenAPI Documentation in Fuego (Go)\nDESCRIPTION: This example demonstrates advanced OpenAPI documentation customization by using Fuego's configurable options and third-party modules. It defines request/response types, sets HTTP headers, query parameters, deprecation, and tag info. Includes reusable option groups and custom route behaviors. Dependencies: Fuego framework, 'option' and 'param' modules. Inputs: POST request with specified parameters. Outputs: As defined in handler.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/README.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n\t\"github.com/go-fuego/fuego/option\"\n\t\"github.com/go-fuego/fuego/param\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\t// Custom OpenAPI options\n\tfuego.Post(s, \"/\", myController,\n\t\toption.Description(\"This route does something...\"),\n\t\toption.Summary(\"This is my summary\"),\n\t\toption.Tags(\"MyTag\"), // A tag is set by default according to the return type (can be deactivated)\n\t\toption.Deprecated(),  // Marks the route as deprecated in the OpenAPI spec\n\n\t\toption.Query(\"name\", \"Declares a query parameter with default value\", param.Default(\"Carmack\")),\n\t\toption.Header(\"Authorization\", \"Bearer token\", param.Required()),\n\t\toptionPagination,\n\t\toptionCustomBehavior,\n\t)\n\n\ts.Run()\n}\n\nvar optionPagination = option.Group(\n\toption.QueryInt(\"page\", \"Page number\", param.Default(1), param.Example(\"1st page\", 1), param.Example(\"42nd page\", 42)),\n\toption.QueryInt(\"perPage\", \"Number of items per page\"),\n)\n\nvar optionCustomBehavior = func(r *fuego.BaseRoute) {\n\tr.XXX = \"YYY\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Validation with Fuego Transformation Interface in Go\nDESCRIPTION: This snippet defines a User struct and implements the InTransform method from the Fuego framework's InTransformer interface to perform custom validation and transformation. It normalizes and trims user fields before checking business logic constraints (e.g., empty names). Dependencies include Fuego ('github.com/go-fuego/fuego'), Go's context, errors, and strings packages. The method can return custom errors for detailed validation feedback. A compile-time assertion ensures User implements the InTransformer interface, helping maintain type safety. Limitations: manual implementation required for each validation logic.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/validation.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"strings\"\n\n\t\"github.com/go-fuego/fuego\"\n)\n\ntype User struct {\n\tFirstName string `json:\"first_name\"`\n\tLastName  string `json:\"last_name\"`\n}\n\nfunc (u *User) InTransform(ctx context.Context) error {\n\tu.FirstName = strings.ToUpper(u.FirstName)\n\tu.LastName = strings.TrimSpace(u.LastName)\n\n\tif u.FirstName == \"\" {\n\t\treturn errors.New(\"first name is required\")\n\t}\n\treturn nil\n}\n\nvar _ fuego.InTransformer = (*User)(nil) // Ensure *User implements fuego.InTransformer\n// This check is a classic example of Go's interface implementation check and we highly recommend to use it\n```\n\n----------------------------------------\n\nTITLE: Defining Input Data Transformation in Fuego with Go\nDESCRIPTION: Demonstrates how to implement the InTransformer interface on a struct to preprocess fields of incoming JSON data. The example uses the User struct, transforming the first name to uppercase and trimming whitespace from the last name. The code also includes a compile-time interface compliance check, ensuring that User implements the fuego.InTransformer required by Fuego. Dependencies: github.com/go-fuego/fuego, context, and strings.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/transformation.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"strings\"\n\n\t\"github.com/go-fuego/fuego\"\n)\n\ntype User struct {\n\tFirstName string `json:\"first_name\"`\n\tLastName  string `json:\"last_name\"`\n}\n\nfunc (u *User) InTransform(ctx context.Context) error {\n\tu.FirstName = strings.ToUpper(u.FirstName)\n\tu.LastName = strings.TrimSpace(u.LastName)\n\treturn nil\n}\n\nvar _ fuego.InTransformer = (*User)(nil) // Ensure *User implements fuego.InTransformer\n// This check is a classic example of Go's interface implementation check and we highly recommend to use it\n```\n\n----------------------------------------\n\nTITLE: Customizing Route OpenAPI Options in Fuego Go\nDESCRIPTION: This Go snippet shows how to customize the OpenAPI specification details for a specific route in Fuego. After defining the GET route, it chains methods from the `option` package to add a summary, description, a required query parameter 'name' with a default value, assigns a tag ('Hello'), and marks the route as deprecated. Dependencies include `fuego`, `option`, and `param`.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/openapi.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n\t\"github.com/go-fuego/fuego/option\"\n\t\"github.com/go-fuego/fuego/param\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\tfuego.Get(s, \"/\", helloWorld,\n\t\toption.Summary(\"A simple hello world\"),\n\t\toption.Description(\"This is a simple hello world example\"),\n\t\toption.Query(\"name\", \"Name to greet\", param.Required(), param.Default(\"World\")),\n\t\toption.Tags(\"Hello\"),\n\t\toption.Deprecated(),\n\t)\n\n\ts.Run()\n}\n\nfunc helloWorld(c fuego.ContextNoBody) (string, error) {\n\treturn \"Hello, World!\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Go Data as Serialized HTTP Response (Fuego, Go)\nDESCRIPTION: Demonstrates creating a struct return type for controller functions in Fuego, automatically serialized to various formats based on the request's Accept header. Relies on Go's encoding/json and Fuego's built-in serialization. The function returns an instance of MyReturnType, and the framework determines the output content type. No explicit serialization logic or error handling is required; Fuego manages content-type responses automatically.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/serialization.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype MyReturnType struct {\n\tMessage string `json:\"message\"`\n}\n\nfunc helloWorld(c fuego.ContextNoBody) (MyReturnType, error) {\n\treturn MyReturnType{Message: \"Hello, World!\"}, nil\n}\n\n// curl request: curl -X GET http://localhost:8080/ -H \"Accept: application/json\"\n// response: {\"message\":\"Hello, World!\"}\n\n// curl request: curl -X GET http://localhost:8080/ -H \"Accept: application/xml\"\n// response: <MyReturnType><Message>Hello, World!</Message></MyReturnType>\n```\n\n----------------------------------------\n\nTITLE: Defining a Standard Fuego Controller Function Signature in Go\nDESCRIPTION: This snippet shows the basic function signature for a standard Fuego controller. The function accepts a `fuego.ContextWithBody[Body]` argument, where `Body` is the expected type of the deserialized request body, and returns a response type (`MyResponse`) and an error.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Standard fuego controller\nfunc MyController(c fuego.ContextWithBody[Body]) (MyResponse, error)\n```\n\n----------------------------------------\n\nTITLE: Registering Routes with Options and Custom Controllers in Fuego (Go)\nDESCRIPTION: This example demonstrates registering routes with complex options, including query parameters, documentation details, custom options, and a reusable options group, in a Fuego server. It defines custom input/output structs, uses the option.Group approach for reusability, and applies per-route metadata. Dependencies include 'github.com/go-fuego/fuego' and use of the option and param helper packages. The snippet shows parameter configuration and outputs a structured response based on query input.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/options.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\\n\\nimport (\\n\\t\\\"github.com/go-fuego/fuego\\\"\\n)\\n\\ntype MyInput struct {\\n\\tName string `json:\\\"name\\\"`\\n}\\n\\nfunc myController(c fuego.ContextWithBody[MyInput]) (*MyResponse, error) {\\n\\tname := c.QueryParam(\\\"name\\\")\\n\\treturn &MyResponse{\\n\\t\\tName: name,\\n\\t}, nil\\n}\\n\\nvar myReusableOption = option.Group(\\n\\toption.QueryInt(\\\"per_page\\\", \\\"Number of items per page\\\", param.Default(100), param.Example(\\\"100 per page\\\", 100)),\\n\\toption.QueryInt(\\\"page\\\", \\\"Page number\\\", param.Default(1), param.Example(\\\"page 9\\\", 9)),\\n)\\n\\nfunc myCustomOption(r *fuego.BaseRoute) {\\n\\tr.XXX = \\\"YYY\\\"\\n}\\n\\nfunc main() {\\n\\ts := fuego.NewServer()\\n\\n\\tfuego.Get(s, \\\"/\\\", myController,\\n\\t\\toption.Query(\\\"name\\\", \\\"Name of the user\\\", param.Required(), param.Example(\\\"example 1\\\", \\\"Napoleon\\\")),\\n\\n\\t\\toption.Summary(\\\"Name getting route\\\"),\\n\\t\\toption.Description(\\\"This is the longdescription of the route\\\"),\\n\\t\\toption.Tags(\\\"Name\\\", \\\"Getting\\\"),\\n\\t\\tmyCustomOption,\\n\\t\\tmyReusableOption,\\n\\t)\\n\\n\\ts.Run()\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Bypassing Automatic Serialization for Custom HTTP Response (Fuego, Go)\nDESCRIPTION: Shows how to manually write HTTP responses in a Fuego controller by accessing the response writer and setting headers. Demonstrates three methods: direct writes, using the standard json.NewEncoder, and leveraging Fuego's SendJSON helper. Useful for custom serialization requirements or handling special data formats. Requires importing encoding/json and assumes access to the fuego.ContextNoBody for acquiring the HTTP response writer.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/serialization.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc helloWorld(c fuego.ContextNoBody) (any, error) {\n\tw := c.Response()\n\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\tw.Write([]byte(\"Hello, World!\"))                                      // Write directly to the response writer.\n\t_ = json.NewEncoder(w).Encode(MyReturnType{Message: \"Hello, World!\"}) // You can also use json.NewEncoder(w).Encode to serialize data directly into JSON\n\tfuego.SendJSON(w, MyReturnType{Message: \"Hello, World!\"})             // Or use fuego.SendJSON to serialize data directly into JSON\n\n\treturn nil, nil // If you return nil, nil fuego will not try to serialize a response\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing and Registering Custom Fuego Error Handler (Go)\nDESCRIPTION: Demonstrates creating a custom error handler (`sqliteErrorHandler`) to map specific errors (like SQLite unique constraint violations) to standard Fuego HTTP errors (`fuego.ConflictError`, `fuego.InternalServerError`). It also shows how to chain handlers (`customErrorHandler` wraps `sqliteErrorHandler` and potentially others) and register the final handler with the Fuego server using `fuego.WithErrorHandler` during initialization in the `main` function. This allows for centralized and application-specific error translation logic.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/errors.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\n```go\nimport (\n\t\"errors\"\n\n\t\"modernc.org/sqlite\"\n\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc sqliteErrorHandler(err error) error {\n\tvar sqliteError *sqlite.Error\n\tif errors.As(err, &sqliteError) {\n\t\tsqliteErrorCode := sqliteError.Code()\n\t\tswitch sqliteErrorCode {\n\t\tcase 1555, 2067 /* UNIQUE constraint failed */ :\n\t\t\treturn fuego.ConflictError{Title: \"Duplicate\", Detail: sqliteError.Error(), Err: sqliteError}\n\t\tdefault:\n\t\t\treturn fuego.InternalServerError{Title: \"Internal Server Error\", Detail: sqliteError.Error(), Err: sqliteError}\n\t\t}\n\t}\n\n\treturn err\n}\n\n// apply all error handlers that we want, like a chain of middlewares\nfunc customErrorHandler(err error) error {\n\treturn fuego.ErrorHandler(sqliteErrorHandler(myOtherCustomErrorHandler(err)))\n}\n\nfunc main() {\n\ts := fuego.NewServer(\n\t\tfuego.WithEngineOptions(\n\t\t\tfuego.WithErrorHandler(customErrorHandler)),\n\t\t),\n\t)\n\n\tfuego.Get(s, \"/\", MyController)\n\n\ts.Run()\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Fuego Error Type (Go)\nDESCRIPTION: Provides an example of a custom error struct (`MyCustomError`) implementing `fuego.ErrorWithStatus` and `fuego.ErrorWithDetail`. This allows defining custom error structures and associated HTTP status codes (e.g., `http.StatusTeapot`) that integrate with Fuego's error handling, enabling structured error responses. The `var` block serves as a compile-time check to ensure the interfaces are correctly implemented.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/errors.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\n```go\ntype MyCustomError struct {\n\tErr     error  `json:\"error\"`\n\tMessage string `json:\"message\"`\n}\n\nvar (\n\t_ fuego.ErrorWithStatus = MyCustomError{}\n\t_ fuego.ErrorWithDetail = MyCustomError{}\n)\n\nfunc (e MyCustomError) Error() string { return e.Err.Error() }\n\nfunc (e MyCustomError) StatusCode() int { return http.StatusTeapot }\n\nfunc (e MyCustomError) DetailMsg() string {\n\treturn strings.Split(e.Error(), \" \")[1]\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Serving Content with Fuego Content Negotiation in Go\nDESCRIPTION: This snippet demonstrates how to set up a Fuego server that conditionally returns either JSON/XML data or a rendered HTML template based on the request's 'Accept' header. Dependencies include the 'github.com/go-fuego/fuego' package and any requisite template engines. The key handler uses 'fuego.DataOrHTML' to route between structured (JSON/XML) and rendered (HTML) outputs, accepting a data object and a templating function. Inputs include HTTP requests with varying 'Accept' headers; outputs are either structured data or HTML. Controller logic must provide both data and a compatible rendered template.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/rendering/index.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\\n\\nimport (\\n\\t\\\"github.com/go-fuego/fuego\\\"\\n)\\n\\nfunc main() {\\n\\ts := fuego.NewServer()\\n\\n\\tfuego.Get(s, \\\"/\\\", func(c fuego.ContextNoBody) (interface{}, error) {\\n\\t\\treturn fuego.DataOrHTML(\\n\\t\\t\\tdata,                             // When asking for JSON/XML, this data will be returned\\n\\t\\t\\tMyTemplateInjectedWithData(data), // When asking for HTML, this template will be rendered\\n\\t\\t), nil\\n\\t})\\n\\n\\ts.Run()\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Applying Group and Custom OpenAPI Options in Fuego Go\nDESCRIPTION: This Go code demonstrates applying OpenAPI options at the group level in Fuego. It defines a reusable option group `optionPagination` for pagination query parameters. It then creates a route group `/users` with default summary, description, and tags. A specific route within the group `/` uses the pagination options, a custom option function `customOption` (which allows direct manipulation of the route struct), and overrides the default summary. Dependencies include `fuego` and `option`.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/openapi.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n\t\"github.com/go-fuego/fuego/option\"\n)\n\n// Define a reusable group of options\nvar optionPagination = option.Group(\n\toption.QueryInt(\"page\", \"Page number\", param.Default(1)),\n\toption.QueryInt(\"limit\", \"Items per page\", param.Default(10)),\n)\n\n// Custom options for the group\nvar customOption = func(r *fuego.BaseRoute) {\n\tr.XXX = YYY // Direct access to the route struct to inject custom behavior\n}\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\tapi := fuego.Group(s, \"/users\",\n\t\toption.Summary(\"Users routes\"),\n\t\toption.Description(\"Default description for all Users routes\"),\n\t\toption.Tags(\"users\"),\n\t)\n\n\tfuego.Get(api, \"/\", helloWorld,\n\t\toptionPagination,\n\t\tcustomOption,\n\t\toption.Summary(\"A simple hello world\"), // Replace the default summary\n\t)\n\n\ts.Run()\n}\n\nfunc helloWorld(c fuego.ContextNoBody) (string, error) {\n\treturn \"Hello, World!\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Dynamic Query Parameters in a Fuego Controller in Go\nDESCRIPTION: This Go example demonstrates a complete Fuego application setup. It defines a controller `myController` that retrieves a query parameter named 'name' using `c.QueryParam(\"name\")`. The route is registered with `fuego.Get`, and route options (`option.Query`, `option.QueryInt`) are used to declare expected query parameters like 'name', 'per_page', and 'page' for OpenAPI documentation and validation.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n    \"github.com/go-fuego/fuego\"\n)\n\ntype MyInput struct {\n    Name string `json:\"name\"`\n}\n\nfunc myController(c fuego.ContextWithBody[MyInput]) (*MyResponse, error) {\n    name := c.QueryParam(\"name\")\n    return &MyResponse{\n        Name: name,\n    }, nil\n}\n\nvar myReusableOption = option.Group(\n    option.QueryInt(\"per_page\", \"Number of items per page\", param.Default(100), param.Example(\"100 per page\", 100)),\n    option.QueryInt(\"page\", \"Page number\", param.Default(1), param.Example(\"page 9\", 9)),\n)\n\nfunc main() {\n    s := fuego.NewServer()\n\n    fuego.Get(s, \"/\", myController,\n        option.Query(\"name\", \"Name of the user\", param.Required(), param.Example(\"example 1\", \"Napoleon\")),\n        myReusableOption,\n    )\n\n    s.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Fuego Controller without Request Body using ContextNoBody in Go\nDESCRIPTION: This snippet demonstrates a controller function that does not expect a request body. It uses the `fuego.ContextNoBody` interface, suitable for HTTP methods like GET, DELETE, HEAD, or OPTIONS. The controller simply returns a predefined response.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nfunc MyController(c fuego.ContextNoBody) (MyResponse, error) {\n    return MyResponse{Name: \"My name\"}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Route Options at Group Level with Fuego in Go\nDESCRIPTION: This snippet illustrates grouping routes under a common path with shared metadata and documentation options, such as summary, description, and tags, using Fuego's group feature. It requires the 'github.com/go-fuego/fuego' package and assumes option helpers are imported. All routes within the group inherit the specified options, supporting modular configuration for route collections.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/options.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\npackage main\\n\\nfunc main() {\\n\\ts := fuego.NewServer()\\n\\n\\tg := fuego.Group(s, \\\"/pets\\\",\\n\\t\\toption.Summary(\\\"Pets operations\\\"),\\n\\t\\toption.Description(\\\"Operations about pets\\\"),\\n\\t\\toption.Tags(\\\"pets\\\"),\\n\\t)\\n\\n\\tfuego.Get(g, \\\"/\\\", func(c fuego.ContextNoBody) (string, error) {\\n\\t\\treturn \\\"Hello, World!\\\", nil\\n\\t})\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Global OpenAPI Settings in Fuego Go Server\nDESCRIPTION: This Go snippet shows how to configure global OpenAPI generation settings when initializing a Fuego server. It uses `fuego.WithEngineOptions` and `fuego.WithOpenAPIConfig` to customize options within the `fuego.OpenAPIConfig` struct, such as disabling Swagger UI or local spec saving, setting custom URLs for the UI and spec, defining the local file path, and providing a custom UI handler. An example route is included to show the server setup context.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/openapi.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc main() {\n\tfuego.NewServer(\n\t\tfuego.WithEngineOptions(\n\t\t\tfuego.WithOpenAPIConfig(fuego.OpenAPIConfig{\n\t\t\t\tDisableSwaggerUI: false,                   // If true, the server will not serve the swagger ui nor the openapi json spec\n\t\t\t\tDisableLocalSave: false,                   // If true, the server will not save the openapi json spec locally\n\t\t\t\tSwaggerURL:       \"/swagger\",              // URL to serve the swagger ui\n\t\t\t\tSpecURL:          \"/swagger/openapi.json\", // URL to serve the openapi json spec\n\t\t\t\tJSONFilePath:     \"doc/openapi.json\",      // Local path to save the openapi json spec\n\t\t\t\tUIHandler:        DefaultOpenAPIHandler,   // Custom UI handler\n\t\t\t}),\n\t\t),\n\t)\n\n\tfuego.Get(s, \"/\", func(c fuego.ContextNoBody) (string, error) {\n\t\treturn \"Hello, World!\", nil\n\t})\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Response Header in a Fuego Controller in Go\nDESCRIPTION: This snippet demonstrates how to set a custom header on the HTTP response within a Fuego controller. The `c.SetHeader(\"X-My-Header\", \"value\")` method is used on the `fuego.ContextNoBody` to add or modify the `X-My-Header` in the response.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_11\n\nLANGUAGE: go\nCODE:\n```\nfunc MyController(c fuego.ContextNoBody) (MyResponse, error) {\n\tc.SetHeader(\"X-My-Header\", \"value\")\n\treturn MyResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Fuego Server for OpenAPI Generation in Go\nDESCRIPTION: This snippet demonstrates the basic setup of a Fuego server in Go. It initializes a server, defines a simple GET route for '/' handled by `helloWorld`, and starts the server. Fuego automatically generates an OpenAPI specification for the defined routes, accessible via default endpoints.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/openapi.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\tfuego.Get(s, \"/\", helloWorld)\n\n\ts.Run()\n}\n\nfunc helloWorld(c fuego.ContextNoBody) (string, error) {\n\treturn \"Hello, World!\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Interacting with the Fuego API using cURL (Bash)\nDESCRIPTION: These Bash examples demonstrate how to make HTTP requests to a Fuego-powered API using 'curl', showing expected responses for GET and POST endpoints, including error handling. Prerequisites: 'curl' installed and the Fuego server running. Inputs: HTTP GET or POST with relevant headers and data. Outputs: Raw HTTP responses, error or JSON. Limitations: Server must be running and accessible at provided endpoints.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/README.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost:8088/std\n# Hello, World!\ncurl http://localhost:8088 -X POST -d '{\"name\": \"Your Name\"}' -H 'Content-Type: application/json'\n# {\"message\":\"HELLO, YOUR NAME\",\"best\":\"Fuego!\"}\ncurl http://localhost:8088 -X POST -d '{\"name\": \"Fuego\"}' -H 'Content-Type: application/json'\n# {\"error\":\"cannot transform request body: cannot transform request body: fuego is not a name\"}\n\n```\n\n----------------------------------------\n\nTITLE: Creating Fuego HTTPError Directly (Go)\nDESCRIPTION: Illustrates how to instantiate and return a `fuego.HTTPError` struct directly within application code. This offers explicit control over the error's title, detail, and HTTP status code (e.g., `http.StatusTeapot`) returned to the client, bypassing the need for custom types when a simple, direct HTTP error is sufficient.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/errors.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\n```go\nerr := fuego.HTTPError{\n\tTitle:  \"Custom error\",\n\tDetail: \"This is a custom error\",\n\tStatus: http.StatusTeapot,\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Injecting Generated Controller into Fuego Server (Go)\nDESCRIPTION: Shows modifications required in `main.go` to integrate the generated and modified controller. It involves importing the controller package, instantiating the `BooksResources` struct (providing the concrete `RealBooksService` implementation), and then registering the controller's routes with the main Fuego server instance using the `Routes` method.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/02-crud.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n\n\t// ADD NEXT LINE\n\t\"hello-fuego/controller\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\t// ....\n\n\t// Declare the resource\n\tbooksResources := controller.BooksResources{\n\t\tBooksService: controller.RealBooksService{},\n\t\t// Other services & dependencies, like a DB etc.\n\t}\n\n\t// Plug the controllers into the server\n\tbooksResources.Routes(s)\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Fuego Endpoint with Query Parameter using cURL\nDESCRIPTION: This cURL command sends a GET request to `http://localhost:9999/` with a query parameter `name=MyName`. This demonstrates how a client would interact with the Fuego endpoint defined in the previous Go example that uses `c.QueryParam(\"name\")`.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_8\n\nLANGUAGE: curl\nCODE:\n```\ncurl -X GET http://localhost:9999/?name=MyName\n# Response: {\"name\": \"MyName\"}\n```\n\n----------------------------------------\n\nTITLE: Configuring Engine-Level Options with Fuego in Go\nDESCRIPTION: This snippet configures engine-level settings for a Fuego server, particularly focusing on custom error handling and OpenAPI UI integration. It requires the 'github.com/go-fuego/fuego' package and definitions of OpenAPIConfig and supporting handler functions. It demonstrates use of composable options for reusable error and documentation UI setups.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/options.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ns := fuego.NewServer(\\n\\tfuego.WithEngineOptions(\\n\\t\\tfuego.WithErrorHandler(func(err error) error {\\n\\t\\t\\treturn fmt.Errorf(\\\"my wrapper: %w\\\", err)\\n\\t\\t}),\\n\\t\\tfuego.WithOpenAPIConfig(OpenAPIConfig{\\n\\t\\t\\tUIHandler: func(specURL string) http.Handler {\\n\\t\\t\\t\\treturn dummyMiddleware(DefaultOpenAPIHandler(specURL))\\n\\t\\t\\t},\\n\\t\\t}),\\n\\t),\\n)\\n\n```\n\n----------------------------------------\n\nTITLE: Returning a Templ Component from a Fuego Handler - Go\nDESCRIPTION: This Go code snippet demonstrates defining an HTTP handler in a Fuego web application that returns a Templ component. It queries for search parameters from the request context, fetches data from a store, and renders a template component using Templ. The handler requires the Fuego framework, the application's store package, and a Templ component compatible with Fuego's CtxRenderer interface. Key inputs include pagination and query keyword parameters, with outputs being the rendered HTML or an error if encountered.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/rendering/templ.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"github.com/go-fuego/fuego\"\n\t\"github.com/go-fuego/fuego/examples/full-app-gourmet/store\"\n)\n\n// highlight-next-line\nfunc (rs Resource) adminIngredients(c fuego.ContextNoBody) (fuego.Templ, error) {\n\tsearchParams := components.SearchParams{\n\t\tName:    c.QueryParam(\"name\"),\n\t\tPerPage: c.QueryParamInt(\"perPage\", 20),\n\t\tPage:    c.QueryParamInt(\"page\", 1),\n\t\tURL:     \"/admin/ingredients\",\n\t\tLang:    c.MainLang(),\n\t}\n\n\tingredients, err := rs.IngredientsQueries.SearchIngredients(c.Context(), store.SearchIngredientsParams{\n\t\tName:   \"%\" + searchParams.Name + \"%\",\n\t\tLimit:  int64(searchParams.PerPage),\n\t\tOffset: int64(searchParams.Page-1) * int64(searchParams.PerPage),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// highlight-next-line\n\treturn admin.IngredientList(ingredients, searchParams), nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Returning Basic Error in Fuego Controller (Go)\nDESCRIPTION: Shows a Fuego controller function returning a standard Go `error`. This triggers Fuego's default error handling, resulting in a 500 Internal Server Error response. The error is logged server-side but not serialized and sent to the client because it's a generic error type.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/errors.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n```go\nfunc MyController(c fuego.ContextNoBody) (string, error) {\n\treturn \"\", errors.New(\"an error occurred\") // Sends a 500. Will be logged but not returned to the client as it is not serializable.\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Applying Route Options at Server Level with Fuego in Go\nDESCRIPTION: This snippet demonstrates adding route-level options, such as summary, description, and tags, directly to the server so that all registered routes inherit these options. It relies on the 'github.com/go-fuego/fuego' package and the option helper package. This approach supports global documentation and behavioral defaults for all routes but may be less composable than per-group or per-route option configuration.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/options.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage main\\n\\nfunc main() {\\n\\ts := fuego.NewServer(\\n\\t\\tfuego.WithRouteOptions(\\n\\t\\t\\toption.Summary(\\\"Pets operations\\\"),\\n\\t\\t\\toption.Description(\\\"Operations about pets\\\"),\\n\\t\\t\\toption.Tags(\\\"pets\\\"),\\n\\t\\t),\\n\\t)\\n\\n\\tfuego.Get(g, \\\"/\\\", func(c fuego.ContextNoBody) (string, error) {\\n\\t\\treturn \\\"Hello, World!\\\", nil\\n\\t})\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Integrating Custom Swagger UI Handler in Fuego Go\nDESCRIPTION: This Go example demonstrates how to replace Fuego's default OpenAPI UI with a custom implementation. It defines an `openApiHandler` function using `github.com/swaggo/http-swagger` which returns an `http.Handler`. This handler is then passed to the Fuego server configuration via `fuego.WithOpenAPIConfig` and its `UIHandler` field, specifying the URL where the JSON spec will be served. Requires `net/http`, `fuego`, and `http-swagger`.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/openapi.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-fuego/fuego\"\n\thttpSwagger \"github.com/swaggo/http-swagger\"\n)\n\nfunc openApiHandler(specURL string) http.Handler {\n\treturn httpSwagger.Handler(\n\t\thttpSwagger.Layout(httpSwagger.BaseLayout),\n\t\thttpSwagger.PersistAuthorization(true),\n\t\thttpSwagger.URL(specURL), // The url pointing to API definition\n\t)\n}\n\nfunc main() {\n\ts := fuego.NewServer(\n\t\tfuego.WithOpenAPIConfig(fuego.OpenAPIConfig{\n\t\t\tUIHandler: openApiHandler(\"/swagger.json\"),\n\t\t}),\n\t)\n\n\tfuego.Get(s, \"/\", helloWorld)\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Excluding Fuego Routes from OpenAPI Specification in Go\nDESCRIPTION: This Go example demonstrates how to hide specific routes or groups of routes from the automatically generated OpenAPI specification in Fuego. It creates a route group `web` using `s.Group` and then calls the `Hide()` method on this group. Any routes defined within the `web` group (like the `/` route) will not be included in the OpenAPI spec. Another group `api` is defined without `Hide()`, so its routes (like `/api/hello`) will still appear in the spec.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/openapi.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\t// Create a group of routes to be hidden\n\tweb := s.Group(s, \"/\")\n\tweb.Hide()\n\n\tfuego.Get(web, \"/\", func(c fuego.ContextNoBody) (string, error) {\n\t\treturn \"Hello, World!\", nil\n\t})\n\n\t// These routes will still be added to the spec\n\tapi := s.Group(s, \"/api\")\n\tfuego.Get(api, \"/hello\", func(c fuego.ContextNoBody) (string, error) {\n\t\treturn \"Hello, World!\", nil\n\t})\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-Recursive Nested Struct Transformation in Fuego (Go)\nDESCRIPTION: Shows how to independently implement transformation logic for nested structs in Go using Fuego's interface. The Address struct has its own InTransform method for field normalization. The User struct includes an Address field and its InTransform method explicitly calls the nested Address transformation using Address.InTransform. This pattern ensures transformations are not performed recursively or implicitly, thus promoting explicit transformation of each nested structure.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/transformation.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ntype Address struct {\n\tStreet string `json:\"street\"`\n\tCity   string `json:\"city\"`\n}\n\nfunc (a *Address) InTransform(ctx context.Context) error {\n\ta.Street = strings.TrimSpace(a.Street)\n\ta.City = strings.ToUpper(a.City)\n\treturn nil\n}\n\ntype User struct {\n\tFirstName string `json:\"first_name\"`\n\tLastName  string `json:\"last_name\"`\n\t// highlight-next-line\n\tAddress Address `json:\"address\"` // Nested struct\n}\n\nfunc (u *User) InTransform(ctx context.Context) error {\n\tu.FirstName = strings.ToUpper(u.FirstName)\n\tu.LastName = strings.TrimSpace(u.LastName)\n\n\t// highlight-next-line\n\terr := u.Address.InTransform(ctx) // Transform the nested struct\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Serialization with json-iterator (Fuego, Go)\nDESCRIPTION: Illustrates manually overriding the Fuego server's Serialize function to use the json-iterator library instead of encoding/json for serialization. The example sets the response content-type, encodes any data type using jsoniter, and integrates a custom serialization workflow in the main server setup. Requires importing github.com/go-fuego/fuego and github.com/json-iterator/go. Input parameters are passed through the controller and serialized via the overridden Serialize function, supporting specialized JSON compatibility or performance tuning.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/serialization.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/go-fuego/fuego\"\n\tjsoniter \"github.com/json-iterator/go\"\n)\n\nvar json = jsoniter.ConfigCompatibleWithStandardLibrary\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\ts.Serialize = func(w http.ResponseWriter, ans any) {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n\t\tjson.NewEncoder(w).Encode(ans)\n\t}\n\n\tfuego.Get(s, \"/\", helloWorld)\n\n\ts.Run()\n}\n\nfunc helloWorld(c fuego.ContextNoBody) (string, error) {\n\treturn \"Hello, World!\", nil\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Fuego CRUD Generator (Bash)\nDESCRIPTION: Installs the Fuego command-line tool using `go install` and demonstrates how to generate controller boilerplate for a 'books' resource using the `fuego controller books` command. An alternative one-line command using `go run` is also shown. This tool creates initial controller files and service interfaces.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/02-crud.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo install github.com/go-fuego/fuego/cmd/fuego@latest\nfuego controller books\n\n# or in one line:\ngo run github.com/go-fuego/fuego/cmd/fuego@latest controller books\n```\n\n----------------------------------------\n\nTITLE: Rendering HTML Template Partial with fuego in Go Handler\nDESCRIPTION: This Go code defines a HTTP handler method for a fuego resource that retrieves an ingredient by ID, then renders an HTML template using the html/template package. It demonstrates dependency injection by importing types, uses fuego.ContextNoBody for request context, and accesses query parameters to select data. The handler returns either a rendered template with a provided data map (via c.Render) or an error. Dependencies include the fuego web framework and any custom types referenced in the data passed to the template. Input includes HTTP query parameters; output is an HTTP response consisting of the rendered template.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/rendering/std.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"github.com/go-fuego/fuego\"\n\t\"github.com/go-fuego/fuego/examples/full-app-gourmet/store/types\"\n)\n\n// highlight-next-line\nfunc (rs Resource) unitPreselected(c fuego.ContextNoBody) (fuego.CtxRenderer, error) {\n\tid := c.QueryParam(\"IngredientID\")\n\n\tingredient, err := rs.IngredientsQueries.GetIngredient(c.Context(), id)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// highlight-start\n\treturn c.Render(\"preselected-unit.partial.html\", fuego.H{\n\t\t\"Units\":        types.UnitValues,\n\t\t\"SelectedUnit\": ingredient.DefaultUnit,\n\t})\n\t// highlight-end\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Fuego Handler Returning a Gomponent in Go\nDESCRIPTION: This Go function `adminIngredients` serves as a Fuego HTTP handler. It extracts search parameters (`name`, `perPage`, `page`) from the request context (`fuego.ContextNoBody`), queries a data store for ingredients using these parameters (`rs.IngredientsQueries.SearchIngredients`), and returns a `fuego.Gomponent` (`admin.IngredientList`) to render an HTML list of ingredients. The `fuego.Gomponent` return type signals Fuego to use the component's `Render` method to generate the HTTP response.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/rendering/gomponents.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"github.com/go-fuego/fuego\"\n\t\"github.com/go-fuego/fuego/examples/full-app-gourmet/store\"\n)\n\n// highlight-next-line\nfunc (rs Resource) adminIngredients(c fuego.ContextNoBody) (fuego.Gomponent, error) {\n\tsearchParams := components.SearchParams{\n\t\tName:    c.QueryParam(\"name\"),\n\t\tPerPage: c.QueryParamInt(\"perPage\", 20),\n\t\tPage:    c.QueryParamInt(\"page\", 1),\n\t\tURL:     \"/admin/ingredients\",\n\t\tLang:    c.MainLang(),\n\t}\n\n\tingredients, err := rs.IngredientsQueries.SearchIngredients(c.Context(), store.SearchIngredientsParams{\n\t\tName:   \"%\" + searchParams.Name + \"%\",\n\t\tLimit:  int64(searchParams.PerPage),\n\t\tOffset: int64(searchParams.Page-1) * int64(searchParams.PerPage),\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// highlight-next-line\n\treturn admin.IngredientList(ingredients, searchParams), nil\n}\n```\n\n----------------------------------------\n\nTITLE: Getting a Request Header in a Fuego Controller in Go\nDESCRIPTION: This snippet shows how to retrieve the value of a specific request header within a Fuego controller. The `c.Header(\"X-My-Header\")` method is used on the `fuego.ContextNoBody` to get the value of the `X-My-Header`.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc MyController(c fuego.ContextNoBody) (MyResponse, error) {\n\tvalue := c.Header(\"X-My-Header\")\n\treturn MyResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Running Fuego Petstore Example Using Bash\nDESCRIPTION: This bash snippet provides step-by-step commands to clone the Fuego GitHub repository, navigate directly to the Petstore example subdirectory, and launch the demo application using Go. No prior setup is needed except for Git and Go v1.22+, as it pulls the full source and runs the example immediately. Useful for users who want hands-on access to executable source code beyond quickstart demos.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/index.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:go-fuego/fuego.git\ncd fuego/examples/petstore\ngo run .\n\n```\n\n----------------------------------------\n\nTITLE: Setting a Response Cookie in a Fuego Controller in Go\nDESCRIPTION: This snippet demonstrates how to set a cookie on the HTTP response within a Fuego controller. The `c.SetCookie(\"my-cookie\", \"value\")` method is used on the `fuego.ContextNoBody` to add a `Set-Cookie` header to the response for the cookie named `my-cookie` with the specified value.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_13\n\nLANGUAGE: go\nCODE:\n```\nfunc MyController(c fuego.ContextNoBody) (MyResponse, error) {\n\tc.SetCookie(\"my-cookie\", \"value\")\n\treturn MyResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Getting a Request Cookie in a Fuego Controller in Go\nDESCRIPTION: This snippet shows how to retrieve the value of a specific cookie from the incoming HTTP request within a Fuego controller. The `c.Cookie(\"my-cookie\")` method is used on the `fuego.ContextNoBody` to get the value of the cookie named `my-cookie`.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_12\n\nLANGUAGE: go\nCODE:\n```\nfunc MyController(c fuego.ContextNoBody) (MyResponse, error) {\n\tvalue := c.Cookie(\"my-cookie\")\n\treturn MyResponse{}, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Specifying Server Address with Fuego in Go\nDESCRIPTION: This code demonstrates setting a custom address for the Fuego server using the WithAddr option. It relies on importing the 'github.com/go-fuego/fuego' package. The server can be started on a specified host and port; this snippet only covers initialization, not starting or handling routes.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/options.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nimport \\\"github.com/go-fuego/fuego\\\"\\n\\nfunc main() {\\n\\ts := fuego.NewServer(\\n\\t\\tfuego.WithAddr(\\\"localhost:8080\\\"),\\n\\t)\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Generating Fuego OpenAPI Spec at Build Time in Go\nDESCRIPTION: This Go code snippet illustrates how to generate the OpenAPI specification using Fuego without running the full web server. After defining the server and routes as usual, it includes a conditional check (e.g., using a CLI flag or environment variable `justGenerateOpenAPI`). If the condition is true, it calls `s.OutputOpenAPISpec()` to generate and save the spec, then exits. Otherwise, it proceeds to run the server with `s.Run()`.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/openapi.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"github.com/go-fuego/fuego\"\n)\n\nfunc main() {\n\ts := fuego.NewServer()\n\n\tfuego.Get(s, \"/\", helloWorld)\n\n\tif justGenerateOpenAPI { // A CLI flag, an env variable, etc.\n\t\ts.OutputOpenAPISpec()\n\t\treturn\n\t}\n\n\ts.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Running Fuego Example via go run - Bash\nDESCRIPTION: This snippet shows how to run the official Fuego Hello World example directly from GitHub using the go run command. No prior project setup is required. Outputs helpful URLs (including OpenAPI spec and Swagger UI) to the terminal upon execution.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/01-hello-world.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run github.com/go-fuego/fuego/examples/hello-world@latest\n```\n\n----------------------------------------\n\nTITLE: Handling Binary Request Body in a Fuego Controller in Go\nDESCRIPTION: This snippet shows how to handle a raw binary request body. The controller uses `fuego.ContextWithBody[[]byte]` to specify that the body should be read as a byte slice. The `c.Body()` method provides the raw bytes. The `Content-Type` header should typically be set to `application/octet-stream` by the client.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfuego.Put(s, \"/blob\", func(c fuego.ContextWithBody[[]byte]) (any, error) {\n\tbody, err := c.Body()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn body, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Air Tool for Go Hot Reload (sh)\nDESCRIPTION: This command uses `go install` to download and install the latest version of the `air` tool, which is used for enabling hot reload in Go applications during development. Requires a working Go installation and internet access.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/03-hot-reload.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngo install github.com/air-verse/air@latest\n```\n\n----------------------------------------\n\nTITLE: Running Hello World Example from Fuego Using Bash\nDESCRIPTION: This bash snippet invokes Go to run the 'Hello World' example application directly from the Fuego GitHub repository. It requires Go to be installed and available via the command line. The command will download the latest example, execute it, and output a server URL for the user to open in a browser. Standard dependencies include Go v1.22 or newer, with no local project setup necessary as the code is run directly from the module proxy.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/index.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo run github.com/go-fuego/fuego/examples/hello-world@latest\n\n```\n\n----------------------------------------\n\nTITLE: Running Go Server with Air Hot Reload (sh)\nDESCRIPTION: This command executes the `air` tool, which builds and runs the Go application, monitoring source files for changes and automatically rebuilding/restarting to enable hot reload. Requires the `air` tool to be installed.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/03-hot-reload.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nair\n```\n\n----------------------------------------\n\nTITLE: Initializing Air Configuration for Go Hot Reload (sh)\nDESCRIPTION: This command runs `air init` to create a default `.air.toml` configuration file in the current directory. This file allows customization of the hot reload behavior. Requires the `air` tool to be installed.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/03-hot-reload.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nair init\n```\n\n----------------------------------------\n\nTITLE: Rendering FlowChart Component in JSX\nDESCRIPTION: Renders the imported `FlowChart` React component using JSX syntax. This tag instructs the React framework to instantiate and display the `FlowChart` component at this position in the document, which will visually depict the data flow discussed. This requires a React rendering environment.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/internals/01-data-flow.mdx#_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<FlowChart />\n```\n\n----------------------------------------\n\nTITLE: Testing Fuego Endpoint with JSON POST Request using cURL\nDESCRIPTION: This cURL command sends a POST request to `http://localhost:9999/` with a JSON payload `{\"name\": \"My name\"}` and sets the `Content-Type` header to `application/json`. It demonstrates how a client would interact with a Fuego endpoint expecting JSON.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_3\n\nLANGUAGE: curl\nCODE:\n```\ncurl -X POST http://localhost:9999/ -d '{\"name\": \"My name\"}' -H \"Content-Type: application/json\"\n# Response: {\"name\": \"My name\"}\n```\n\n----------------------------------------\n\nTITLE: Testing Fuego Endpoint with XML POST Request using cURL\nDESCRIPTION: This cURL command sends a POST request to `http://localhost:9999/` with an XML payload `<MyInput><Name>My name</Name></MyInput>` and sets the `Content-Type` header to `application/xml`. It shows Fuego's ability to handle different content types via content negotiation.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_4\n\nLANGUAGE: curl\nCODE:\n```\ncurl -X POST http://localhost:9999/ -d '<MyInput><Name>My name</Name></MyInput>' -H \"Content-Type: application/xml\"\n# Response: {\"name\": \"My name\"}\n```\n\n----------------------------------------\n\nTITLE: Accessing Type-Safe Query Parameters in a Fuego Controller (Future Syntax) in Go\nDESCRIPTION: This snippet illustrates a proposed future syntax for handling type-safe query and header parameters in Fuego. It defines a `Params` struct with tags (`query`, `header`) to map request data. The controller signature uses `fuego.Context[MyInput, Params]`, and parameters are accessed via `c.Params()`. Note: This syntax is not currently available.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/guides/controllers.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\ntype Params struct {\n    Limit int    `query:\"limit\"`\n    Group string `header:\"X-User-Group\"`\n}\nfunc myController(c fuego.Context[MyInput, Params]) (*MyResponse, error) {\n    params, err := c.Params()\n    if err != nil {\n        return nil, err\n    }\n\n    return &MyResponse{\n        Name: params.Group,\n    }, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Tidying and Running Go Project - Bash\nDESCRIPTION: Shows how to tidy project dependencies and launch the Go server. 'go mod tidy' adds or removes dependencies in go.mod/go.sum, and 'go run .' compiles and runs the main Go application in the current directory.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/01-hello-world.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngo mod tidy\ngo run .\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server with Yarn in Docusaurus - Shell\nDESCRIPTION: Launches the Docusaurus local development server, automatically opening a browser window and enabling hot-reload for most content changes. Depends on prior installation via 'yarn'. The command has no parameters by default and provides a dynamic, auto-refreshing web preview for developers.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Initializing Go Module - Bash\nDESCRIPTION: This command initializes a new Go module named 'hello-fuego' in the current directory. It generates a go.mod file which is required for managing dependencies in Go projects.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/01-hello-world.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo mod init hello-fuego\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Yarn - Shell\nDESCRIPTION: Installs all project dependencies listed in the package.json file using Yarn, the JavaScript package manager required for running or building the site. No parameters are required. Outputs all necessary modules into the node_modules directory, preparing the project for development or build processes.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Building Static Website with Docusaurus Using Yarn - Shell\nDESCRIPTION: Compiles the Docusaurus website into static files located in the build directory. Requires all dependencies installed. Produces optimized, ready-to-serve HTML, CSS, and JavaScript files for deployment on any static hosting service. No command-line parameters are necessary.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nyarn build\n```\n\n----------------------------------------\n\nTITLE: Creating and Navigating Project Directory - Bash\nDESCRIPTION: This sequence of bash commands sets up a new directory for a Go project and navigates into it. It is a prerequisite for further Go module initialization and development.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/tutorials/01-hello-world.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir hello-fuego\ncd hello-fuego\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Website via SSH with Yarn - Shell\nDESCRIPTION: Deploys the built static site using Yarn with SSH authentication enabled. Relies on the USE_SSH environment variable set to true, and requires SSH configuration. Deploys the generated content to a remote host or a GitHub Pages branch, depending on project settings.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nUSE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Website via GitHub User with Yarn - Shell\nDESCRIPTION: Deploys the website using Yarn and a specified GitHub username for authentication. Set the GIT_USER environment variable to your GitHub username in the command line. This approach is suitable when SSH is not used, and is optimized for continuous integration or human-triggered deployments to GitHub Pages.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nGIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Importing FlowChart Component in JavaScript/React\nDESCRIPTION: Imports the `FlowChart` React component from a relative path within the site's source directory (`@site/src/components/FlowChart`). This component is intended to render a visual representation of the Fuego application's data flow. This import statement is standard in JavaScript modules, particularly within React projects or documentation sites built with frameworks like Docusaurus.\nSOURCE: https://github.com/go-fuego/fuego/blob/main/documentation/docs/internals/01-data-flow.mdx#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport FlowChart from '@site/src/components/FlowChart';\n```"
  }
]