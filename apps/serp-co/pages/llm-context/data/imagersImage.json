[
  {
    "owner": "image-rs",
    "repo": "image",
    "content": "TITLE: Opening and Saving Images Example in Rust\nDESCRIPTION: Complete example demonstrating how to open an image file, display its metadata (dimensions and color type), and save it in PNG format. Uses the image crate's open function for automatic format detection.\nSOURCE: https://github.com/image-rs/image/blob/main/README.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse image::GenericImageView;\n\n// Use the open function to load an image from a Path.\n// `open` returns a `DynamicImage` on success.\nlet img = image::open(\"tests/images/jpg/progressive/cat.jpg\").unwrap();\n\n// The dimensions method returns the images width and height.\nprintln!(\"dimensions {:?}\", img.dimensions());\n\n// The color method returns the image's `ColorType`.\nprintln!(\"{:?}\", img.color());\n\n// Write the contents of this image to the Writer in PNG format.\nimg.save(\"test.png\").unwrap();\n```\n\n----------------------------------------\n\nTITLE: Loading Images with ImageReader in Rust\nDESCRIPTION: Demonstrates how to load images using the ImageReader API from the image crate. Shows two methods: loading from a file path and loading from a byte buffer with automatic format detection.\nSOURCE: https://github.com/image-rs/image/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::io::Cursor;\nuse image::ImageReader;\n\nlet img = ImageReader::open(\"myimage.png\")?.decode()?;\nlet img2 = ImageReader::new(Cursor::new(bytes)).with_guessed_format()?.decode()?;\n```\n\n----------------------------------------\n\nTITLE: Saving Images in Rust with the Image Crate\nDESCRIPTION: Shows two methods for saving images: directly to a file using the save method, and writing to a buffer with a specified format using the write_to method.\nSOURCE: https://github.com/image-rs/image/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimg.save(\"empty.jpg\")?;\n\nlet mut bytes: Vec<u8> = Vec::new();\nimg2.write_to(&mut Cursor::new(&mut bytes), image::ImageFormat::Png)?;\n```\n\n----------------------------------------\n\nTITLE: Saving Raw Image Buffer to File in Rust\nDESCRIPTION: Demonstrates how to save a raw image buffer to a PNG file using the image-rs library's save_buffer function. Takes a raw buffer of RGB8 pixel data and specifies dimensions of 800x600.\nSOURCE: https://github.com/image-rs/image/blob/main/README.md#2025-04-23_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet buffer: &[u8] = unimplemented!(); // Generate the image data\n\n// Save the buffer as \"image.png\"\nimage::save_buffer(\"image.png\", buffer, 800, 600, image::ExtendedColorType::Rgb8).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Generating Julia Fractal in Rust using image-rs\nDESCRIPTION: Creates a Julia set fractal by iterating over pixel coordinates and applying complex number calculations. The script generates an 800x800 pixel image with color gradients and saves it as a PNG file. Uses the num_complex crate for complex number operations.\nSOURCE: https://github.com/image-rs/image/blob/main/README.md#2025-04-23_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n//! An example of generating julia fractals.\nlet imgx = 800;\nlet imgy = 800;\n\nlet scalex = 3.0 / imgx as f32;\nlet scaley = 3.0 / imgy as f32;\n\n// Create a new ImgBuf with width: imgx and height: imgy\nlet mut imgbuf = image::ImageBuffer::new(imgx, imgy);\n\n// Iterate over the coordinates and pixels of the image\nfor (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\n    let r = (0.3 * x as f32) as u8;\n    let b = (0.3 * y as f32) as u8;\n    *pixel = image::Rgb([r, 0, b]);\n}\n\n// A redundant loop to demonstrate reading image data\nfor x in 0..imgx {\n    for y in 0..imgy {\n        let cx = y as f32 * scalex - 1.5;\n        let cy = x as f32 * scaley - 1.5;\n\n        let c = num_complex::Complex::new(-0.4, 0.6);\n        let mut z = num_complex::Complex::new(cx, cy);\n\n        let mut i = 0;\n        while i < 255 && z.norm() <= 2.0 {\n            z = z * z + c;\n            i += 1;\n        }\n\n        let pixel = imgbuf.get_pixel_mut(x, y);\n        let image::Rgb(data) = *pixel;\n        *pixel = image::Rgb([data[0], i as u8, data[2]]);\n    }\n}\n\n// Save the image as \"fractal.png\", the format is deduced from the path\nimgbuf.save(\"fractal.png\").unwrap();\n```\n\n----------------------------------------\n\nTITLE: Image Buffer Access Example\nDESCRIPTION: Shows the new panic-free pixel access methods added to ImageBuffer for safe pixel manipulation.\nSOURCE: https://github.com/image-rs/image/blob/main/CHANGES.md#2025-04-23_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nImageBuffer::get_pixel_checked(x, y) -> Option<&P>\nImageBuffer::get_pixel_mut_checked(x, y) -> Option<&mut P>\n```\n\n----------------------------------------\n\nTITLE: Dynamic Image Conversion\nDESCRIPTION: Demonstrates the new From trait implementations and Default trait for DynamicImage type.\nSOURCE: https://github.com/image-rs/image/blob/main/CHANGES.md#2025-04-23_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl From<ImageBuffer> for DynamicImage\nimpl Default for DynamicImage // Creates empty Rgba8 image\n```\n\n----------------------------------------\n\nTITLE: Quoting Vec::from_raw_parts Requirement in Markdown\nDESCRIPTION: This snippet quotes a critical requirement for using Vec::from_raw_parts, highlighting the importance of size and alignment consistency in memory allocation.\nSOURCE: https://github.com/image-rs/image/blob/main/docs/2019-04-23-memory-unsafety.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n> ptr's T needs to have the same size and alignment as it was allocated with.\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Cargo in image-rs/image Project\nDESCRIPTION: Command to run benchmarks using the nightly Rust toolchain with the benchmarks feature enabled. This requires having the nightly toolchain installed and uses cargo's bench command to execute the benchmarks.\nSOURCE: https://github.com/image-rs/image/blob/main/benches/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo +nightly bench --features=benchmarks\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Cargo-Fuzz for Image Library Testing\nDESCRIPTION: Commands to install cargo-fuzz and run fuzzing tests against different image format handlers in the image-rs/image library. Requires the nightly Rust toolchain to execute the fuzzing process.\nSOURCE: https://github.com/image-rs/image/blob/main/fuzz/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo install cargo-fuzz\n$ cargo +nightly fuzz run fuzzer_script_<format>\n```\n\n----------------------------------------\n\nTITLE: Running AFL Fuzzer on Image Format\nDESCRIPTION: Series of commands to set up output directory and run AFL fuzzer on a specific image format. The <format> placeholder should be replaced with the actual image format being tested.\nSOURCE: https://github.com/image-rs/image/blob/main/fuzz-afl/README.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ mkdir out/<format>\n$ cargo afl fuzz -i ./in/<format> -o ./out/<format> ./target/debug/fuzz_<format>\n```\n\n----------------------------------------\n\nTITLE: Reproducing Crash for Specific Image Format\nDESCRIPTION: Command to reproduce a crash found during fuzzing for a specific image format. The <format> placeholder should be replaced with the actual image format being tested.\nSOURCE: https://github.com/image-rs/image/blob/main/fuzz-afl/README.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo run --bin reproduce_<format>\n```\n\n----------------------------------------\n\nTITLE: Building Fuzz Target for Specific Image Format\nDESCRIPTION: Command to build a fuzz target for a specific image format using AFL and Cargo. The <format> placeholder should be replaced with the actual image format being tested.\nSOURCE: https://github.com/image-rs/image/blob/main/fuzz-afl/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo afl build --bin fuzz_<format>\n```\n\n----------------------------------------\n\nTITLE: Running AFL with LLVM Workaround\nDESCRIPTION: Command to run AFL with a workaround for LLVM version incompatibility in newer nightly Rust builds. This sets the RUSTFLAGS environment variable to use the old LLVM pass manager.\nSOURCE: https://github.com/image-rs/image/blob/main/fuzz-afl/README.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ RUSTFLAGS=\"-Znew-llvm-pass-manager=no\" cargo +nightly afl run â€¦\n```\n\n----------------------------------------\n\nTITLE: Installing AFL Fuzzer with Cargo\nDESCRIPTION: Command to install the AFL (American Fuzzy Lop) fuzzer using Cargo package manager.\nSOURCE: https://github.com/image-rs/image/blob/main/fuzz-afl/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ cargo install afl\n```\n\n----------------------------------------\n\nTITLE: Rust Version Requirement\nDESCRIPTION: Specifies the minimum Rust version requirement in Cargo.toml using the standard package.rust-version field.\nSOURCE: https://github.com/image-rs/image/blob/main/CHANGES.md#2025-04-23_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package.rust-version]\nrust-version = \"1.56\"\n```"
  }
]