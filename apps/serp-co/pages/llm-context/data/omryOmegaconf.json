[
  {
    "owner": "omry",
    "repo": "omegaconf",
    "content": "TITLE: Loading OmegaConf from YAML File\nDESCRIPTION: Loads an OmegaConf configuration from a YAML file.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.load('source/example.yaml')\n# Output is identical to the YAML file\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Loading OmegaConf Configuration from YAML File - Python\nDESCRIPTION: Shows how to initialize an OmegaConf object by loading a configuration from a YAML file. The example assumes a file path ('../source/example.yaml'). Printing the loaded configuration in YAML format helps inspect the contents. Requires the specified file to exist.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.load('../source/example.yaml')\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Static Type Checking with OmegaConf Structured Configs (Python)\nDESCRIPTION: Shows using static type hints for a structured OmegaConf config object, enabling Mypy or IDE-based static analysis. Demonstrates valid assignment, as well as detection (by both static checkers and runtime) of invalid assignments, with runtime raising ValidationError.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nconf: SimpleTypes = OmegaConf.structured(SimpleTypes)\n# Passes static type checking\nconf.description = \"text\"\n# Fails static type checking (but will also raise a Validation error)\nwith raises(ValidationError):\n    conf.num = \"foo\"\n```\n\n----------------------------------------\n\nTITLE: Merging Two Loaded Configurations - Python\nDESCRIPTION: Demonstrates explicitly merging two previously loaded OmegaConf configs into a combined configuration. This allows configuration overriding, aggregation of lists, and formation of a unified config object. Ideal for complex project setups.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import OmegaConf\nimport sys\n\n# Merge configs:\nconf = OmegaConf.merge(base_conf, second_conf)\n\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Configuration Merging Example with Command Line Arguments\nDESCRIPTION: Complete example demonstrating how to load configurations from YAML files and command line arguments, then merge them. Shows how values from later sources override earlier ones (e.g., port changes to 82).\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import OmegaConf\nimport sys\n\n# Simulate command line arguments\nsys.argv = ['program.py', 'server.port=82']\n\nbase_conf = OmegaConf.load('source/example2.yaml')\nsecond_conf = OmegaConf.load('source/example3.yaml')\ncli_conf = OmegaConf.from_cli()\n\n# merge them all\nconf = OmegaConf.merge(base_conf, second_conf, cli_conf)\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf with Various Key Types\nDESCRIPTION: Demonstrates creating an OmegaConf object with different key types including strings, integers, booleans, floats, enums, and bytes.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum\nclass Color(Enum):\n  RED = 1\n  BLUE = 2\n\nconf = OmegaConf.create(\n  {\"key\": \"str\", 123: \"int\", True: \"bool\", 3.14: \"float\", Color.RED: \"Color\", b\"123\": \"bytes\"}\n)\n\nprint(conf)\n```\n\n----------------------------------------\n\nTITLE: Merging Web Server Configurations with OmegaConf\nDESCRIPTION: Example of merging multiple configuration files for a web server setup using OmegaConf.merge(). This combines server configuration with plugin and site-specific configurations.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.merge(server_cfg, plugin1_cfg, site1_cfg, site2_cfg)\n```\n\n----------------------------------------\n\nTITLE: Parsing Command Line Arguments into OmegaConf - Python\nDESCRIPTION: Reads sys.argv for command-line arguments representing configuration overrides, parses them into an OmegaConf object, and prints the resulting configuration in YAML format. Demonstrates integrating OmegaConf with CLI tools. Arguments must be dot-list assignments.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Simulating command line arguments\nimport sys\nsys.argv = ['your-program.py', 'server.port=82', 'log.file=log2.txt']\nconf = OmegaConf.from_cli()\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple OmegaConf Configurations with merge() - Python\nDESCRIPTION: Shows how to merge multiple configuration objects (created from base configs, models, or plugins) into a single OmegaConf instance using OmegaConf.merge. This allows modular composition of configs. Requires configs to be predefined objects.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.merge(base_cfg, model_cfg, optimizer_cfg, dataset_cfg)\n```\n\n----------------------------------------\n\nTITLE: Selecting Config Values with OmegaConf.select\nDESCRIPTION: Shows how to use OmegaConf.select() to retrieve config values using both dot-notation and bracket notation. It also demonstrates handling of missing values and providing default values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create({\n    \"foo\" : {\n        \"missing\" : \"???\",\n        \"bar\": {\n            \"zonk\" : 10,\n        }\n    }\n})\nassert OmegaConf.select(cfg, \"foo\") == {\n    \"missing\" : \"???\",    \n    \"bar\":  {\n        \"zonk\" : 10, \n    }\n}\nassert OmegaConf.select(cfg, \"foo.bar\") == {\n    \"zonk\" : 10, \n}\nassert OmegaConf.select(cfg, \"foo.bar.zonk\") == 10    # dots\nassert OmegaConf.select(cfg, \"foo[bar][zonk]\") == 10  # brackets\nassert OmegaConf.select(cfg, \"no_such_key\", default=99) == 99\nassert OmegaConf.select(cfg, \"foo.missing\") is None\nassert OmegaConf.select(cfg, \"foo.missing\", default=99) == 99\nOmegaConf.select(cfg,\n    \"foo.missing\", \n    throw_on_missing=True\n)\n```\n\n----------------------------------------\n\nTITLE: Merging Configurations in Machine Learning Context with OmegaConf\nDESCRIPTION: Example of merging multiple configuration files for a machine learning experiment using OmegaConf.merge(). This combines base configuration with model, optimizer, and dataset configurations.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.merge(base_cfg, model_cfg, optimizer_cfg, dataset_cfg)\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf Configuration from Dot-List - Python\nDESCRIPTION: Constructs a configuration from a list of dot-notated assignment strings, which encode nested structures. This pattern is useful for building configurations from command-line arguments or environment settings. Output is printed in YAML.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndot_list = [\"a.aa.aaa=1\", \"a.aa.bbb=2\", \"a.bb.aaa=3\", \"a.bb.bbb=4\"]\nconf = OmegaConf.from_dotlist(dot_list)\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Validating and Merging Structured Configs with OmegaConf (Python)\nDESCRIPTION: Shows how to define a schema using structured dataclasses and validates input YAML files against this schema during config merging. A deliberate type error (users as List[int] instead of List[str]) demonstrates type enforcement by raising ValidationError. Requires OmegaConf, dataclasses, ValidationError, and presence of a YAML file (example.yaml). Inputs include config creation and merge; outputs are exceptions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> @dataclass\n... class Server:\n...     port: int = MISSING\n\n>>> @dataclass\n... class Log:\n...     file: str = MISSING\n...     rotation: int = MISSING\n\n>>> @dataclass\n... class MyConfig:\n...     server: Server = field(default_factory=Server)\n...     log: Log = field(default_factory=Log)\n...     users: List[int] = field(default_factory=list)\n\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> schema = OmegaConf.structured(MyConfig)\n>>> conf = OmegaConf.load(\"source/example.yaml\")\n>>> with raises(ValidationError):\n...     OmegaConf.merge(schema, conf)\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Displaying Nested OmegaConf Structured Configs (Python)\nDESCRIPTION: Illustrates constructing a nested config based on previously defined dataclasses and displaying its structure in YAML. All nested field values are handled as per the dataclass field defaults. The config is type hinted for static checks.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nconf: Group = OmegaConf.structured(Group)\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Testing for Missing Values with OmegaConf.is_missing\nDESCRIPTION: Demonstrates how to use OmegaConf.is_missing() to check if a value is missing (represented as \"???\") in the configuration.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create({\n        \"foo\" : 10, \n        \"bar\": \"???\"\n    })\nassert not OmegaConf.is_missing(cfg, \"foo\")\nassert OmegaConf.is_missing(cfg, \"bar\")\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration with Environment Variable Interpolation - Python\nDESCRIPTION: Loads a YAML configuration containing environment variable-based interpolations and prints the config. Requires relevant environment variables to be set; demonstrates use of ${oc.env:VAR} expressions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.load('../source/env_interpolation.yaml')\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Defining Dataclasses and Enums for OmegaConf Structured Configs (Python)\nDESCRIPTION: Demonstrates the creation of a Python enum and a dataclass covering all simple types supported by OmegaConf (int, float, bool, enum, str, bytes, pathlib.Path). No external dependencies are required except for standard Python modules and OmegaConf. Each field is initialized with a default value, and the enum is used as a field type.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Height(Enum):\n    SHORT = 0\n    TALL = 1\n\n@dataclass\nclass SimpleTypes:\n    num: int = 10\n    pi: float = 3.1415\n    is_awesome: bool = True\n    height: Height = Height.SHORT\n    description: str = \"text\"\n    data: bytes = b\"bin_data\"\n    path: pathlib.Path = pathlib.Path(\"hello.txt\")\n```\n\n----------------------------------------\n\nTITLE: Converting Configurations to Objects with OmegaConf.to_object()\nDESCRIPTION: Example of using OmegaConf.to_object() to convert configurations to Python objects, instantiating structured configs as their backing classes rather than dictionaries.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\ncontainer = OmegaConf.to_object(conf)\nshow(container)\nshow(container[\"structured_config\"])\n```\n\n----------------------------------------\n\nTITLE: Using Nested Interpolations for Dynamic Config Selection - Python\nDESCRIPTION: Builds a configuration with nested interpolation expressions to select a plan based on a key ('selected_plan'). Shows value changes after updating selection. Useful for conditionally controlling configuration sections.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create(\n    {\n        \"plans\": {\"A\": \"plan A\", \"B\": \"plan B\"},\n        \"selected_plan\": \"A\",\n        \"plan\": \"${plans[${selected_plan}]}\"\n    }\n)\nprint(f\"Default: cfg.plan = {cfg.plan}\")\ncfg.selected_plan = \"B\"\nprint(f\"After selecting plan B: cfg.plan = {cfg.plan}\")\n\n```\n\n----------------------------------------\n\nTITLE: Instantiating OmegaConf Structured Configs from Dataclasses (Python)\nDESCRIPTION: Illustrates initializing OmegaConf structured configs from both the class and an instance of a dataclass, showing equivalence and customization. Requires OmegaConf and the prior dataclass. Demonstrates assertion for equality and printing the YAML representation.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nconf1 = OmegaConf.structured(SimpleTypes)\nconf2 = OmegaConf.structured(SimpleTypes())\n# The two configs are identical in this case\nassert conf1 == conf2\n# But the second form allow for easy customization of the values:\nconf3 = OmegaConf.structured(\n  SimpleTypes(num=20,\n  height=Height.TALL))\nprint(OmegaConf.to_yaml(conf3))\n```\n\n----------------------------------------\n\nTITLE: Accessing a Configuration Field (Object Style) - Python\nDESCRIPTION: Accesses a nested configuration value using object-style (dot notation) access. This approach is convenient and Pythonic, but requires the keys to be valid identifiers. Demo shows how to retrieve the 'port' from the 'server' section.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nconf.server.port\n\n```\n\n----------------------------------------\n\nTITLE: Accessing a Configuration Field (Dictionary Style) - Python\nDESCRIPTION: Retrieves a nested configuration value using dictionary-style access, allowing access to keys with special characters or keywords. The example shows how to retrieve the 'rotation' field under the 'log' section.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nconf['log']['rotation']\n\n```\n\n----------------------------------------\n\nTITLE: Interpolating Entire Nodes in OmegaConf\nDESCRIPTION: Demonstrates how interpolation can reference entire configuration nodes, not just leaf values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create(\n    {\n        \"john\": {\"height\": 180, \"weight\": 75},\n        \"player\": \"${john}\",\n    }\n)\n(cfg.player.height, cfg.player.weight)\n```\n\n----------------------------------------\n\nTITLE: Using Nested Interpolation in OmegaConf\nDESCRIPTION: Shows how to use nested interpolation to dynamically select values based on other configuration values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create(\n   {\n       \"plans\": {\n           \"A\": \"plan A\",\n           \"B\": \"plan B\",\n       },\n       \"selected_plan\": \"A\",\n       \"plan\": \"${plans[${selected_plan}]}\",\n   }\n)\ncfg.plan # default plan\ncfg.selected_plan = \"B\"\ncfg.plan # new plan\n```\n\n----------------------------------------\n\nTITLE: Defining and Nesting Structured Configs Using Dataclasses (Python)\nDESCRIPTION: Shows how to define nested structured configs using dataclasses, including inheritance, default values via default_factory, and nesting multiple user-defined config classes. All dependencies are standard Python and OmegaConf.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass User:\n    # A simple user class with two missing fields\n    name: str = MISSING\n    height: Height = MISSING\n\n@dataclass\nclass DuperUser(User):\n    duper: bool = True\n\n# Group class contains two instances of User.\n@dataclass\nclass Group:\n    name: str = MISSING\n    # data classes can be nested\n    admin: User = field(default_factory=User)\n\n    # You can also specify different defaults for nested classes\n    manager: User = field(default_factory=lambda: User(name=\"manager\", height=Height.TALL))\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Resolvers in OmegaConf\nDESCRIPTION: Shows how to register custom resolvers that can be used in interpolations to perform calculations or transformations.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nOmegaConf.register_new_resolver(\n    \"add\", lambda *numbers: sum(numbers)\n)\nc = OmegaConf.create({'total': '${add:1,2,3}'})\nc.total\n```\n\n----------------------------------------\n\nTITLE: Defining Lists in Structured Configs Using Dataclasses (Python)\nDESCRIPTION: Illustrates the use of lists and tuples annotated with typing.List and typing.Tuple in dataclasses, including fields of primitive types and user-defined structured configs. Uses field(default_factory=...) for defaults, supporting runtime type validation of contents.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass, field\nfrom typing import List, Tuple\n@dataclass\nclass User:\n    name: str = MISSING\n\n@dataclass\nclass ListsExample:\n    # Typed list can hold Any, int, float, bool, str,\n    # bytes, pathlib.Path and Enums as well as arbitrary Structured configs.\n    ints: List[int] = field(default_factory=lambda: [10, 20, 30])\n    bools: Tuple[bool, bool] = field(default_factory=lambda: (True, False))\n    users: List[User] = field(default_factory=lambda: [User(name=\"omry\")])\n```\n\n----------------------------------------\n\nTITLE: Printing Environment Interpolations with Resolution - Python\nDESCRIPTION: Loads the same env-interpolated config and prints the resolved values with to_yaml(resolve=True). Demonstrates how environment lookups are expanded to their actual values within the exported YAML.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.load('../source/env_interpolation.yaml')\nprint(OmegaConf.to_yaml(conf, resolve=True))\n\n```\n\n----------------------------------------\n\nTITLE: Accessing an Element in a Configuration List - Python\nDESCRIPTION: Demonstrates accessing the first user entry from a 'users' list in the configuration. List indexing is supported in OmegaConf objects, similar to Python lists.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nconf.users[0]\n\n```\n\n----------------------------------------\n\nTITLE: Basic Custom Resolver Example\nDESCRIPTION: Demonstrates registering and using a simple custom resolver that adds 10 to a given value.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nOmegaConf.register_new_resolver(\"plus_10\", lambda x: x + 10)\nc = OmegaConf.create({'key': '${plus_10:990}'}) \n```\n\n----------------------------------------\n\nTITLE: Referencing Internal Nodes via Interpolation - Python\nDESCRIPTION: Demonstrates internal node referencing by interpolating an entire sub-tree (object) rather than just scalar values. The \"player\" config references the \"john\" node, copying its keys/values. Tuple unpacking accesses properties of the interpolated sub-tree.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create(\n    {\n        \"john\": {\"height\": 180, \"weight\": 75},\n        \"player\": \"${john}\",\n    }\n)\n(cfg.player.height, cfg.player.weight)\n\n```\n\n----------------------------------------\n\nTITLE: Registering and Using a Simple Custom Resolver - Python\nDESCRIPTION: Registers a custom OmegaConf resolver named 'plus_10' that adds 10 to its input. Demonstrates creating a config referencing the resolver and accessing the resolved value. Shows extensibility of OmegaConf interpolation.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nOmegaConf.register_new_resolver(\"plus_10\", lambda x: x + 10)\nconf = OmegaConf.create({'key': '${plus_10:990}'})\nconf.key\n\n```\n\n----------------------------------------\n\nTITLE: Using Nested Interpolation for Computation in Python-configured OmegaConf (Python)\nDESCRIPTION: Shows how to use eval and nested interpolation from a Python dictionary to compute the area of a rectangle using config values. Requires OmegaConf and an eval resolver. Highlights referencing other config values for computation.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/how_to_guides.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> cfg = OmegaConf.create({\\n...     \"side_1\": 5,\\n...     \"side_2\": 6,\\n...     \"rectangle_area\": \"${eval:'${side_1} * ${side_2}'}\",\\n... })\\n>>> assert cfg.rectangle_area == 30\n```\n\n----------------------------------------\n\nTITLE: Introspection: Checking Types of OmegaConf Structured Configs (Python)\nDESCRIPTION: Demonstrates differentiating between the runtime type (usually DictConfig) and the underlying dataclass type in a structured OmegaConf config, using OmegaConf.get_type(). Useful for runtime introspection or type-based logic.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntype(conf).__name__\n'DictConfig'\n\nOmegaConf.get_type(conf).__name__\n'SimpleTypes'\n```\n\n----------------------------------------\n\nTITLE: Using Interpolation and Static Type Checker Workarounds in OmegaConf Structured Configs (Python)\nDESCRIPTION: Provides examples of field value interpolation in structured configs and ways to suppress type checker complaints using OmegaConf.SI and OmegaConf.II. Validates that interpolated references are resolved and values match the annotated types. Dependencies: OmegaConf, SI, II, dataclasses. Inputs are field initializations and value assertions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n>>> from omegaconf import SI, II\n>>> @dataclass\n... class Interpolation:\n...     val: int = 100\n...     # This will work, but static type checkers will complain\n...     a: int = \"${val}\"\n...     # This is equivalent to the above, but static type checkers\n...     # will not complain\n...     b: int = SI(\"${val}\")\n...     # This is syntactic sugar; the input string is\n...     # wrapped with ${} automatically.\n...     c: int = II(\"val\")\n\n>>> conf: Interpolation = OmegaConf.structured(Interpolation)\n>>> assert conf.a == 100\n>>> assert conf.b == 100\n>>> assert conf.c == 100\n\n```\n\n----------------------------------------\n\nTITLE: Working with Mandatory Values in OmegaConf\nDESCRIPTION: Demonstrates how OmegaConf handles mandatory values marked with '???' that must be set before access.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nconf.log.file\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf from Structured Config Class\nDESCRIPTION: Creates a type-safe OmegaConf configuration from a structured dataclass with default values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n@dataclass\nclass MyConfig:\n    port: int = 80\n    host: str = \"localhost\"\n# For strict typing purposes, prefer OmegaConf.structured() when creating structured configs\nconf = OmegaConf.structured(MyConfig)\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Using Nested Interpolation for Computation in YAML-configured OmegaConf (Python/YAML)\nDESCRIPTION: Demonstrates nested resolver use where eval refers to other config values, enabling dynamic computation (rectangle area). Requires OmegaConf and eval resolver registered. Inputs are YAML strings with references; outputs are config objects with calculated values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/how_to_guides.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> yaml_data = \"\"\"\\n... side_1: 5\\n... side_2: 6\\n... rectangle_area: ${eval:'${side_1} * ${side_2}'}\\n... \"\"\"\\n>>> cfg = OmegaConf.create(yaml_data)\\n>>> assert cfg.rectangle_area == 30\n```\n\n----------------------------------------\n\nTITLE: Printing Base Configuration from File for Merging - Python\nDESCRIPTION: Loads a configuration file and prints it; sets up objects to be merged in subsequent steps. Used as a source for demonstrating the merge functionality. File must exist.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nbase_conf = OmegaConf.load('../source/example2.yaml')\nprint(OmegaConf.to_yaml(base_conf))\n\n```\n\n----------------------------------------\n\nTITLE: Evaluating Primitive and Composite Interpolations - Python\nDESCRIPTION: Demonstrates the typing and resolution of two types of interpolations: primitive types inherit the target's type while composite interpolations (cross-node, string) resolve to str. Shows resolved values and their types.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n# Primitive interpolation types are inherited from the referenced value\nprint(\"conf.client.server_port: \", conf.client.server_port, type(conf.client.server_port).__name__)\n# Composite interpolation types are always string\nprint(\"conf.client.url: \", conf.client.url, type(conf.client.url).__name__)\n\n```\n\n----------------------------------------\n\nTITLE: Finding Missing Keys with OmegaConf.missing_keys\nDESCRIPTION: Demonstrates using OmegaConf.missing_keys() to identify all missing mandatory fields in a configuration. Returns a set of missing keys represented as strings in dotlist style.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nmissings = OmegaConf.missing_keys({\n    \"foo\": {\"bar\": \"???\"},\n    \"missing\": \"???\",\n     \"list\": [\"a\", None, \"???\"]\n})\nassert missings == {'list[2]', 'foo.bar', 'missing'}\n```\n\n----------------------------------------\n\nTITLE: Using Variable Interpolation in OmegaConf\nDESCRIPTION: Demonstrates the use of variable interpolation in OmegaConf, where values can reference other nodes in the configuration.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.load('source/config_interpolation.yaml')\ndef show(x):\n    print(f\"type: {type(x).__name__}, value: {repr(x)}\")\n# Primitive interpolation types are inherited from the reference\nshow(conf.client.server_port)\n# String interpolations concatenate fragments into a string\nshow(conf.client.url)\n# Relative interpolation example\nshow(conf.client.description)\n```\n\n----------------------------------------\n\nTITLE: Registering and Composing a Multi-Parameter Custom Resolver - Python\nDESCRIPTION: Shows usage of a custom resolver named 'plus' that adds two arguments, used with nested interpolations to perform dynamic arithmetic within configuration. The resulting config field ('a_plus_b') resolves to the sum.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nOmegaConf.register_new_resolver(\"plus\", lambda x, y: x + y)\nconf = OmegaConf.create({\"a\": 1, \"b\": 2, \"a_plus_b\": \"${plus:${a},${b}}\"})\nconf.a_plus_b\n\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Resolver Signature in Python\nDESCRIPTION: Shows the function signature for registering new custom resolvers in OmegaConf. The function takes a name, resolver function, and optional parameters for replacement and caching behavior.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef register_new_resolver(\n    name: str,\n    resolver: Resolver,\n    *,\n    replace: bool = False,\n    use_cache: bool = False,\n) -> None\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty OmegaConf Object\nDESCRIPTION: Creates an empty OmegaConf configuration object using the create() method.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import OmegaConf\nconf = OmegaConf.create()\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Using Fast Unsafe Merge in OmegaConf\nDESCRIPTION: Example of using OmegaConf.unsafe_merge() for faster merging operations. This method destroys the input configs for better performance, so they should not be used after the merge.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.unsafe_merge(base_cfg, model_cfg, optimizer_cfg, dataset_cfg)\n```\n\n----------------------------------------\n\nTITLE: Decoding and Interpolating Strings from Environment Variables - Python\nDESCRIPTION: Shows advanced use of oc.decode to parse string environment variables into typed Python objects (int, list, None, or interpolation). Demonstrates dynamic dispatch and fallback for uninitialized variables, as well as resolving interpolated values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create(\n    {\n        \"database\": {\n            \"port\": \"${oc.decode:${oc.env:DB_PORT}}\",\n            \"nodes\": \"${oc.decode:${oc.env:DB_NODES}}\",\n            \"timeout\": \"${oc.decode:${oc.env:DB_TIMEOUT,null}}\",\n        }\n    }\n)\n\nos.environ[\"DB_PORT\"] = \"3308\"  # integer\nos.environ[\"DB_NODES\"] = \"[host1, host2, host3]\"  # list\nos.environ.pop(\"DB_TIMEOUT\", None)  # unset variable\n\nprint(\"port (int):\", repr(cfg.database.port))\nprint(\"nodes (list):\", repr(cfg.database.nodes))\nprint(\"timeout (missing variable):\", repr(cfg.database.timeout))\n\nos.environ[\"DB_TIMEOUT\"] = \"${.port}\"\nprint(\"timeout (interpolation):\", repr(cfg.database.timeout))\n\n```\n\n----------------------------------------\n\nTITLE: Merging Config Files with ListMergeMode.EXTEND_UNIQUE in OmegaConf (Python)\nDESCRIPTION: This code loads two YAML configurations using OmegaConf, then merges them using the EXTEND_UNIQUE list merge mode, ensuring only unique entries are added to lists (e.g., users). It demonstrates the use of OmegaConf.load, OmegaConf.merge, and ListMergeMode, printing the final YAML. Dependencies required include the omegaconf package and access to the YAML files. Inputs are file paths and merge mode; output is the merged YAML structure, with uniqueness preserved in list items.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import OmegaConf, ListMergeMode\\n\\ncfg_example2 = OmegaConf.load('../source/example2.yaml')\\ncfg_example4 = OmegaConf.load('../source/example4.yaml')\\n\\nconf = OmegaConf.merge(cfg_example2, cfg_example4, list_merge_mode=ListMergeMode.EXTEND_UNIQUE)\\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Merging Lists with Custom List Merge Mode in OmegaConf\nDESCRIPTION: Example demonstrating how to merge lists with different behaviors using list_merge_mode parameter. Shows how to use EXTEND_UNIQUE mode to combine lists while avoiding duplicates.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import OmegaConf, ListMergeMode\n\ncfg_1 = OmegaConf.load('source/example2.yaml')\ncfg_2 = OmegaConf.load('source/example4.yaml')\n\nmode = ListMergeMode.EXTEND_UNIQUE\nconf = OmegaConf.merge(cfg_1, cfg_2, list_merge_mode=mode)\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: YAML Output after EXTEND_UNIQUE List Merge\nDESCRIPTION: Shows the resultant YAML configuration after merging with OmegaConf using the EXTEND_UNIQUE mode. Demonstrates how user lists are combined without duplicates while preserving source values such as the server port. No dependencies other than YAML consumption; output demonstrates the final merged configuration format for downstream use.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_40\n\nLANGUAGE: yaml\nCODE:\n```\nserver:\\n  port: 80\\nusers:\\n- user1\\n- user2\\n- user3\n```\n\n----------------------------------------\n\nTITLE: Resolving Interpolations In-Place with OmegaConf.resolve()\nDESCRIPTION: Function signature for OmegaConf.resolve() which resolves all interpolations in a given config object in-place, modifying the original object.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ndef resolve(cfg: Container) -> None:\n    \"\"\"\n    Resolves all interpolations in the given config object in-place.\n    :param cfg: An OmegaConf container (DictConfig, ListConfig)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Config Elements in OmegaConf\nDESCRIPTION: Demonstrates different ways to access elements in an OmegaConf configuration using dot notation and dictionary style.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# object style access of dictionary elements\nconf.server.port\n\n# dictionary style access\nconf['log']['rotation']\n\n# items in list\nconf.users[0]\n```\n\n----------------------------------------\n\nTITLE: Providing Default Values for Missing Keys - Python\nDESCRIPTION: Accesses a key that may not be present in the configuration, providing a fallback default value. The 'get' method mimics Python dict behavior for missing entries. The example returns 'a default value' if 'missing_key' is not found.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nconf.get('missing_key', 'a default value')\n\n```\n\n----------------------------------------\n\nTITLE: Testing for Interpolations with OmegaConf.is_interpolation\nDESCRIPTION: Shows how to use OmegaConf.is_interpolation() to check if a value is an interpolation in the configuration.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create({\n        \"foo\" : 10, \n        \"bar\": \"${foo}\"\n    })\nassert not OmegaConf.is_interpolation(cfg, \"foo\")\nassert OmegaConf.is_interpolation(cfg, \"bar\")\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic with eval Resolver in Python-defined OmegaConf Config (Python)\nDESCRIPTION: Creates an OmegaConf config from a Python dictionary with a value interpolated using the eval resolver to compute 10 squared. Requires OmegaConf and eval registered as a resolver. Shows how to use Python dicts for configuration in place of YAML.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/how_to_guides.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> cfg = OmegaConf.create({\\n...     \"ten_squared\": \"${eval:'10 ** 2'}\",\\n... })\\n>>> assert cfg.ten_squared == 100\n```\n\n----------------------------------------\n\nTITLE: Using the New OmegaConf.resolve Method\nDESCRIPTION: OmegaConf 2.1 introduced the resolve method that resolves all interpolations in a config object in-place.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_4\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Error on Accessing Undefined Attributes in OmegaConf Structured Configs (Python)\nDESCRIPTION: Demonstrates runtime rejection of accessing or setting of fields not defined in the structured config class, resulting in AttributeError. This assures the config behaves similarly to Python dataclasses with type enforcement.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.structured(SimpleTypes)\nwith raises(AttributeError):\n   conf.does_not_exist\n```\n\n----------------------------------------\n\nTITLE: Using Defaults with Environment Variable Interpolation - Python\nDESCRIPTION: Creates a config where environment variable-based interpolations include defaults that are used when the variable is unset. Shows how different defaults (string, number, None) are handled. Outputs resolved values using Python repr() to show types.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create(\n    {\n        \"database\": {\n            \"password1\": \"${oc.env:DB_PASSWORD,password}\",\n            \"password2\": \"${oc.env:DB_PASSWORD,12345}\",\n            \"password3\": \"${oc.env:DB_PASSWORD,null}\",\n        },\n    }\n)\nprint(repr(cfg.database.password1))\nprint(repr(cfg.database.password2))\nprint(repr(cfg.database.password3))\n\n```\n\n----------------------------------------\n\nTITLE: Setting and Handling Read-only Flag in OmegaConf\nDESCRIPTION: Example showing how to make a configuration read-only and what happens when attempting to modify it. Also demonstrates temporarily removing read-only protection using the read_write context manager.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"a\": {\"b\": 10}})\nOmegaConf.set_readonly(conf, True)\nconf.a.b = 20\n```\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"a\": {\"b\": 10}})\nOmegaConf.set_readonly(conf, True)\nwith read_write(conf):\n  conf.a.b = 20\nconf.a.b\n```\n\n----------------------------------------\n\nTITLE: Runtime Type Validation and Conversion in OmegaConf (Python)\nDESCRIPTION: Shows how OmegaConf allows assignment of values that can be converted at runtime to the target type. Demonstrates conversion (\"100\" to int) and error handling for incompatible types, including config mutation via dot-list merging.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# This is okay, the string \"100\" can be converted to an int\n# Note that static type checkers will not like it and you should\n# avoid such explicit mistyped assignments.\nconf.num = \"100\"\nassert conf.num == 100\n\nwith raises(ValidationError):\n    # This will fail at runtime because num is an int\n    # and foo cannot be converted to an int\n    # Note that the static type checker can't help here.\n    conf.merge_with_dotlist([\"num=foo\"])\n```\n\n----------------------------------------\n\nTITLE: Demonstrating oc.select resolver with defaults in OmegaConf\nDESCRIPTION: Shows how to use oc.select to provide default values when a configuration key is missing, and how to access it once defined.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> cfg = OmegaConf.create({\n...  \"a\": \"Saving output to ${oc.select:output,/tmp}\"\n... })\n>>> print(cfg.a)\nSaving output to /tmp\n>>> cfg.output = \"/etc/config\"\n>>> print(cfg.a)\nSaving output to /etc/config\n```\n\n----------------------------------------\n\nTITLE: Setting and Handling Struct Flag in OmegaConf\nDESCRIPTION: Example showing how to use the struct flag to prevent creating new fields in a configuration. Also demonstrates temporarily allowing new fields using the open_dict context manager.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"a\": {\"aa\": 10, \"bb\": 20}})\nOmegaConf.set_struct(conf, True)\nconf.a.cc = 30\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import open_dict\nconf = OmegaConf.create({\"a\": {\"aa\": 10, \"bb\": 20}})\nOmegaConf.set_struct(conf, True)\nwith open_dict(conf):\n  conf.a.cc = 30\nconf.a.cc\n```\n\n----------------------------------------\n\nTITLE: Creating Masked Copies with OmegaConf.masked_copy\nDESCRIPTION: Shows how to create a copy of a DictConfig that contains only specific keys using OmegaConf.masked_copy().\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"a\": {\"b\": 10}, \"c\":20})\nprint(OmegaConf.to_yaml(conf))\nc = OmegaConf.masked_copy(conf, [\"a\"])\nprint(OmegaConf.to_yaml(c))\n```\n\n----------------------------------------\n\nTITLE: Defining and Assigning Nested Dict and List Annotations with OmegaConf (Python)\nDESCRIPTION: Provides examples of deeply-nested dict and list type annotations in structured configs using OmegaConf. Demonstrates field initialization, YAML serialization, and error handling when assigning wrong types. Dependencies: dataclasses, typing, OmegaConf, ValidationError. Inputs include assignments to nested structures; outputs are YAML strings or ValidationError.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> @dataclass\n... class NestedContainers:\n...     dict_of_dict: Dict[str, Dict[str, int]]\n...     list_of_list: List[List[int]] = field(default_factory=lambda: [[123]])\n...     dict_of_list: Dict[str, List[int]] = MISSING\n...     list_of_dict: List[Dict[str, int]] = MISSING\n... \n... \n>>> cfg = OmegaConf.structured(NestedContainers(dict_of_dict={\"foo\": {\"bar\": 123}}))\n>>> print(OmegaConf.to_yaml(cfg))\ndict_of_dict:\n  foo:\n    bar: 123\nlist_of_list:\n- - 123\ndict_of_list: ???\nlist_of_dict: ???\n<BLANKLINE>\n>>> with raises(ValidationError):\n...     cfg.list_of_dict = [[\"whoops\"]]  # not a list of dicts\n```\n\n----------------------------------------\n\nTITLE: Using OmegaConf.clear_resolver to remove specific resolvers\nDESCRIPTION: Demonstrates how to remove a single resolver by name using clear_resolver, which can remove both custom and built-in resolvers.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> OmegaConf.has_resolver(\"oc.env\")\nTrue\n>>> # This will remove the default resolver: oc.env\n>>> OmegaConf.clear_resolver(\"oc.env\")\nTrue\n>>> OmegaConf.has_resolver(\"oc.env\")\nFalse\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf Configuration from Dictionary - Python\nDESCRIPTION: Creates an OmegaConf object from a nested Python dictionary and prints the configuration in YAML format. This illustrates hierarchical config creation and serialization. omegaconf must be installed.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create(dict(k='v',list=[1,dict(a='1',b='2')]))\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Using OmegaConf.clear_resolvers to remove custom resolvers\nDESCRIPTION: Shows how to use the clear_resolvers method to remove all custom resolvers while preserving built-in ones.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> # register a new resolver: str.lower\n>>> OmegaConf.register_new_resolver(\n...     name='str.lower',\n...     resolver=lambda x: str(x).lower(),\n... )\n>>> # check if resolver exists (after adding, before removal)\n>>> OmegaConf.has_resolver(\"str.lower\")\nTrue\n>>> # clear all custom-resolvers\n>>> OmegaConf.clear_resolvers()\n>>> # check if resolver exists (after removal)\n>>> OmegaConf.has_resolver(\"str.lower\")\nFalse\n>>> # default resolvers are not affected\n>>> OmegaConf.has_resolver(\"oc.env\")\nTrue\n```\n\n----------------------------------------\n\nTITLE: Assigning Subclasses to Nested Config Fields in OmegaConf (Python)\nDESCRIPTION: Shows that OmegaConf allows assignment of subclass instances to nested structured config fields, permitting class extension and additional attributes. Here, DuperUser (subclass) is assigned to a field expecting User (base class).\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nconf.manager = DuperUser()\nassert conf.manager.duper == True\n```\n\n----------------------------------------\n\nTITLE: Using oc.dict.keys and oc.dict.values resolvers\nDESCRIPTION: Demonstrates how to convert DictConfig entries to list views using the oc.dict.keys and oc.dict.values resolvers, which work similarly to dict.keys() and dict.values() in Python.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> cfg = OmegaConf.create(\n...     {\n...         \"workers\": {\n...             \"node3\": \"10.0.0.2\",\n...             \"node7\": \"10.0.0.9\",\n...         },\n...         \"nodes\": \"${oc.dict.keys: workers}\",\n...         \"ips\": \"${oc.dict.values: workers}\",\n...     }\n... )\n>>> # Keys are copied from the DictConfig:\n>>> show(cfg.nodes)\ntype: ListConfig, value: ['node3', 'node7']\n>>> # Values are dynamically fetched through interpolations:\n>>> show(cfg.ips)\ntype: ListConfig, value: ['${workers.node3}', '${workers.node7}']\n>>> assert cfg.ips == [\"10.0.0.2\", \"10.0.0.9\"]\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional, Missing, and Container Fields in OmegaConf Structured Configs (Python)\nDESCRIPTION: Demonstrates fields with Optional and MISSING modifiers, plus lists containing optionals. Covers the effects of required fields (MISSING) and permitted None values for Optional fields. Requires OmegaConf, dataclasses, typing.Optional/Dict/List, and raises from pytest. Inputs include field accesses and assignments; outputs are exceptions or updated values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Optional\n>>> from omegaconf import MISSING\n\n>>> @dataclass\n... class Modifiers:\n...     num: int = 10\n...     optional_num: Optional[int] = 10\n...     another_num: int = MISSING\n...     optional_dict: Optional[Dict[str, int]] = None\n...     list_optional: List[Optional[int]] = field(default_factory=lambda: [10, MISSING, None])\n\n>>> conf: Modifiers = OmegaConf.structured(Modifiers)\n```\n\n----------------------------------------\n\nTITLE: Static Type Checking with Structured Config\nDESCRIPTION: Shows how to use structured configs for static type checking in function parameters.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef foo(conf: MyConfig):\n    print(conf.port) # passes static type checker\n    print(conf.pork) # fails static type checker\n```\n\n----------------------------------------\n\nTITLE: Saving and Loading OmegaConf as YAML\nDESCRIPTION: Demonstrates how to save an OmegaConf configuration to a YAML file and load it back.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"foo\": 10, \"bar\": 20, 123: 456})\nwith tempfile.NamedTemporaryFile() as fp:\n    OmegaConf.save(config=conf, f=fp.name)\n    loaded = OmegaConf.load(fp.name)\n    assert conf == loaded\n```\n\n----------------------------------------\n\nTITLE: Using Lists in OmegaConf Structured Configs with Runtime Type Enforcement (Python)\nDESCRIPTION: Demonstrates list operations on an OmegaConf structured config object, including valid and invalid type assignments with enforcement at runtime. Shows appending convertible and valid objects, and ValidationError on incompatible types.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nconf: ListsExample = OmegaConf.structured(ListsExample)\n\n# Okay, 10 is an int\nconf.ints.append(10)\n# Okay, \"20\" can be converted to an int\nconf.ints.append(\"20\")\n\nconf.bools.append(True)\nconf.users.append(User(name=\"Joe\"))\n# Not okay, 10 cannot be converted to a User\nwith raises(ValidationError):\n    conf.users.append(10)\n```\n\n----------------------------------------\n\nTITLE: Environment Variables Access Example\nDESCRIPTION: Demonstrates how to access environment variables using the oc.env resolver in a YAML configuration.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nuser:\n  name: ${oc.env:USER}\n  home: /home/${oc.env:USER}\n```\n\n----------------------------------------\n\nTITLE: Defining Dictionary Fields in Structured Configs Using Dataclasses (Python)\nDESCRIPTION: Shows how to declare dictionary fields in dataclasses for use with OmegaConf, specifying both key and value types with type hints. Includes various supported primitive and structured config value types. Default values are provided via field(default_factory=...).\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass, field\nfrom typing import Dict\n@dataclass\nclass DictExample:\n    ints: Dict[str, int] = field(default_factory=lambda: {\"a\": 10, \"b\": 20, \"c\": 30})\n    bools: Dict[str, bool] = field(default_factory=lambda: {\"Uno\": True, \"Zoro\": False})\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf from Command Line Arguments\nDESCRIPTION: Creates an OmegaConf configuration from command line arguments in the format key=value.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Simulating command line arguments\nsys.argv = ['your-program.py', 'server.port=82', 'log.file=log2.txt']\nconf = OmegaConf.from_cli()\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf Configuration from YAML String - Python\nDESCRIPTION: Illustrates creating a configuration from a multiline YAML string and printing it as YAML. Supports fields, lists, and nested structures. Useful for quick tests or dynamic configuration generation.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nyaml = \"\"\"\na: b\nb: c\nlist:\n- item1\n- item2\n\"\"\"\nconf = OmegaConf.create(yaml)\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Using oc.select with missing values in OmegaConf\nDESCRIPTION: Shows how oc.select handles missing values, providing None by default or allowing a custom default value to be specified.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> cfg = OmegaConf.create({\n...         \"missing\": \"???\",\n...         \"interpolation\": \"${missing}\",\n...         \"select\": \"${oc.select:missing}\",\n...         \"with_default\": \"${oc.select:missing,default value}\",\n...     }\n... )\n...\n>>> print(cfg.interpolation)\nTraceback (most recent call last):\n...\nInterpolationToMissingValueError: MissingMandatoryValue while ...\n>>> print(cfg.select)\nNone\n>>> print(cfg.with_default)\ndefault value\n```\n\n----------------------------------------\n\nTITLE: Variadic Arguments in Custom Resolvers\nDESCRIPTION: Shows how to use variadic arguments in custom resolvers with different string handling examples.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nOmegaConf.register_new_resolver(\"concat\", lambda x, y: x+y)\nc = OmegaConf.create({\n    'key1': '${concat:Hello,World}',\n    'key_trimmed': '${concat:Hello , World}',\n    'escape_whitespace': '${concat:Hello,\\ World}',\n    'quoted': '${concat:\"Hello,\", \" World\"}',\n})\n```\n\n----------------------------------------\n\nTITLE: Loading and Printing OmegaConf Configuration File - Python\nDESCRIPTION: Loads an OmegaConf configuration from a YAML file and prints it in YAML format. This is a basic operation used before accessing, updating, or merging configuration objects. Assumes the file exists.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.load('../source/example.yaml')\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Assigning None to Optional and Non-Optional Fields in OmegaConf (Python)\nDESCRIPTION: Illustrates the difference between assigning None to regular and optional fields in structured configs. Non-optional fields raise ValidationError. Requires OmegaConf, dataclasses, typing.Optional, pytest.raises. Inputs are assignments to fields; outputs are exceptions or confirmation via assertions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> with raises(ValidationError):\n...     # regular fields cannot be assigned None\n...     conf.num = None\n\n>>> conf.optional_num = None\n>>> assert conf.optional_num is None\n>>> assert conf.list_optional[2] is None\n\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf from YAML String\nDESCRIPTION: Creates an OmegaConf configuration from a YAML string.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ns = \"\"\"\na: b\nb: c\nlist:\n- item1\n- item2\n123: 456\n\"\"\"\nconf = OmegaConf.create(s)\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf from List\nDESCRIPTION: Creates an OmegaConf configuration from a Python list that contains nested structures.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create([1, {\"a\":10, \"b\": {\"a\":10, 123: \"int_key\"}}])\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Manipulating OmegaConf Configuration Values\nDESCRIPTION: Shows how to modify existing values, add new keys, and add new dictionaries to an OmegaConf configuration.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n# Changing existing keys\nconf.server.port = 81\n\n# Adding new keys\nconf.server.hostname = \"localhost\"\n\n# Adding a new dictionary\nconf.database = {'hostname': 'database01', 'port': 3306}\n```\n\n----------------------------------------\n\nTITLE: Using Default Values in OmegaConf\nDESCRIPTION: Shows how to provide default values when accessing potentially missing keys in an OmegaConf configuration.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nconf.get('missing_key', 'a default value')\n```\n\n----------------------------------------\n\nTITLE: Runtime Enum Assignment and Conversion in OmegaConf Structured Configs (Python)\nDESCRIPTION: Demonstrates multiple ways to assign enum values in OmegaConf structured configs, including by enum instance, name string, str with type prefix, and ordinal value. Each approach is validated and converted at runtime.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nconf.height = Height.TALL\nassert conf.height == Height.TALL\n\n# The name of Height.TALL is TALL\nconf.height = \"TALL\"\nassert conf.height == Height.TALL\n\n# This works too\nconf.height = \"Height.TALL\"\nassert conf.height == Height.TALL\n\n# The ordinal of Height.TALL is 1\nconf.height = 1\nassert conf.height == Height.TALL\n```\n\n----------------------------------------\n\nTITLE: String Multiplication and Quoting with eval Resolver in YAML OmegaConf (Python/YAML)\nDESCRIPTION: Shows how to multiply a string value using eval and references in a YAML-string configuration, with nested double quotes ensuring eval interprets the value as a string. Requires careful quoting and an eval resolver. Demonstrates output of repeated string concatenation.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/how_to_guides.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> yaml_data = \"\"\"\\n... cow_say: moo\\n... three_cows: ${eval:'3 * \"${cow_say}\"'}\\n... \"\"\"\\n>>> cfg = OmegaConf.create(yaml_data)\\n>>> assert cfg.three_cows == \"moomoomoo\"\n```\n\n----------------------------------------\n\nTITLE: String Multiplication and Quoting with eval Resolver in Python OmegaConf (Python)\nDESCRIPTION: Demonstrates string multiplication using eval, interpolation, and correct nesting of quotes from a Python dict config. Requires OmegaConf and eval resolver. Result is the repeated string as output, and highlights necessity for careful string quoting.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/how_to_guides.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> cfg = OmegaConf.create({\\n...   \"cow_say\": \"moo\",\\n...   \"three_cows\": \"\"\"${eval:'3 * \\\"${cow_say}\\\"'}\"\"\"\\n... })\\n>>> assert cfg.three_cows == \"moomoomoo\"\n```\n\n----------------------------------------\n\nTITLE: Adding a New Dictionary Node to Configuration - Python\nDESCRIPTION: Demonstrates inserting a new dictionary (mapping) as a sub-node in the configuration. Here, a 'database' section is added with 'hostname' and 'port' fields. Useful for dynamically expanding configuration structure.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nconf.database = {'hostname': 'database01', 'port': 3306}\n\n```\n\n----------------------------------------\n\nTITLE: Cached vs Uncached Resolver Example\nDESCRIPTION: Shows the difference between cached and uncached resolvers using random number generation.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport random\nrandom.seed(1234)\nOmegaConf.register_new_resolver(\n   \"cached\", random.randint, use_cache=True\n)\nOmegaConf.register_new_resolver(\"uncached\", random.randint)\nc = OmegaConf.create(\n    {\n        \"uncached\": \"${uncached:0,10000}\",\n        \"cached_1\": \"${cached:0,10000}\",\n        \"cached_2\": \"${cached:0, 10000}\",\n        \"cached_3\": \"${cached:0,${uncached}}\",\n    }\n)\n```\n\n----------------------------------------\n\nTITLE: Changing Existing Configuration Keys - Python\nDESCRIPTION: Illustrates updating a value of an existing key in the configuration. This example assigns a new port to the 'server' section. OmegaConf supports both simple and nested assignments.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nconf.server.port = 81\n\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Mandatory Values in OmegaConf Structured Configs (Python)\nDESCRIPTION: Demonstrates the behavior when accessing a field set to OmegaConf's MISSING constant, raising MissingMandatoryValue until assigned. Requires OmegaConf, dataclasses, raises from pytest. Inputs include field access and assignment; outputs are exceptions or updated fields.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> with raises(MissingMandatoryValue):\n...     x = conf.another_num\n>>> conf.another_num = 20\n>>> assert conf.another_num == 20\n\n```\n\n----------------------------------------\n\nTITLE: Using Union Types in Structured Configs\nDESCRIPTION: OmegaConf 2.2 added support for union types in structured configs, allowing field types to be specified as a union of multiple primitive types.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_2\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Ignoring Fields in Structured Configs Using Metadata and OmegaConf (Python)\nDESCRIPTION: Demonstrates how to use the field metadata key omegaconf_ignore to prevent certain fields from appearing in created config nodes. Only fields without omegaconf_ignore or with it set to False are included. Requires OmegaConf, dataclasses. Inputs are config creation; outputs are config dict representations.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> @dataclass\n... class HasIgnoreMetadata:\n...     normal_field: int = 1\n...     field_ignored: int = field(default=2, metadata={\"omegaconf_ignore\": True})\n...     field_not_ignored: int = field(default=3, metadata={\"omegaconf_ignore\": False})\n...\n>>> cfg = OmegaConf.create(HasIgnoreMetadata)\n>>> cfg\n{'normal_field': 1, 'field_not_ignored': 3}\n\n```\n\n----------------------------------------\n\nTITLE: Registering Cached and Uncached Custom Resolvers - Python\nDESCRIPTION: Demonstrates resolver caching behavior in OmegaConf. Registers two resolvers ('cached', 'uncached'), verifies repeat access returns same value for cached but not for uncached, and shows effect of key-literal caching. Uses random numbers for output.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nimport random\nrandom.seed(1234)\n\nOmegaConf.register_new_resolver(\"cached\", random.randint, use_cache=True)\nOmegaConf.register_new_resolver(\"uncached\", random.randint)\n\ncfg = OmegaConf.create(\n    {\n        \"uncached\": \"${uncached:0,10000}\",\n        \"cached_1\": \"${cached:0,10000}\",\n        \"cached_2\": \"${cached:0, 10000}\",\n        \"cached_3\": \"${cached:0,${uncached}}\",\n    }\n)\n\n# not the same since the cache is disabled by default\nprint(\"Without cache:\", cfg.uncached, \"!=\", cfg.uncached)\n\n# same value on repeated access thanks to the cache\nprint(\"With cache:\", cfg.cached_1, \"==\", cfg.cached_1)\n\n# same value as `cached_1` since the input is the same\nprint(\"With cache (same input):\", cfg.cached_2, \"==\", cfg.cached_1)\n\n# same value even if `uncached` changes, because the cache is based\n# on the string literal \"${uncached}\" that remains the same\nprint(\"With cache (interpolation):\", cfg.cached_3, \"==\", cfg.cached_3)\n\n```\n\n----------------------------------------\n\nTITLE: Using Nested Container Types in Structured Configs\nDESCRIPTION: OmegaConf 2.2 added support for nested container types in structured configs, allowing for complex nested data structures like lists of dictionaries.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_3\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Handling Missing Values in OmegaConf.to_container()\nDESCRIPTION: Example demonstrating how to control the behavior when missing values are encountered during conversion to native Python types using the throw_on_missing parameter.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"foo\": \"bar\", \"missing\": \"???\"})\nhas_missing = OmegaConf.to_container(conf, throw_on_missing=False)\nshow(has_missing)\nOmegaConf.to_container(conf, throw_on_missing=True)\n```\n\n----------------------------------------\n\nTITLE: Using oc.select to access keys with special characters\nDESCRIPTION: Demonstrates how oc.select can access keys that contain characters like colons which would otherwise conflict with resolver syntax.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/custom_resolvers.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> cfg = OmegaConf.create({\n...    # yes, there is a : in this key\n...    \"a:b\": 10,\n...    \"bad\": \"${a:b}\",\n...    \"good\": \"${oc.select:'a:b'}\",\n... })\n>>> print(cfg.bad)\nTraceback (most recent call last):\n...\nUnsupportedInterpolationType: Unsupported interpolation type a\n>>> print(cfg.good)\n10\n```\n\n----------------------------------------\n\nTITLE: Runtime Type Safety with Structured Config\nDESCRIPTION: Demonstrates the runtime type safety features of OmegaConf when using structured configs.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nconf.port = 42      # Ok, type matches\nconf.port = \"1080\"  # Ok! \"1080\" can be converted to an int\nconf.port = \"oops\"  # \"oops\" cannot be converted to an int\n```\n\n----------------------------------------\n\nTITLE: YAML Configuration Example for User List Extension\nDESCRIPTION: A sample YAML file featuring an alternative 'users' list. Intended for merging with other YAML configurations using OmegaConf, this snippet is used to demonstrate different merging behaviors when combining user lists. Inputs and outputs follow typical YAML conventions, with no direct dependencies beyond a YAML loader.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_38\n\nLANGUAGE: yaml\nCODE:\n```\nusers:\\n  - user3\\n  - user2\n```\n\n----------------------------------------\n\nTITLE: Type Testing with OmegaConf.is_config, is_dict, and is_list\nDESCRIPTION: Shows how to use OmegaConf's type testing functions (is_config, is_dict, is_list) to determine the type of OmegaConf containers.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\n# dict:\nd = OmegaConf.create({\"foo\": \"bar\"})\nassert OmegaConf.is_config(d)\nassert OmegaConf.is_dict(d)\nassert not OmegaConf.is_list(d)\n# list:\nl = OmegaConf.create([1,2,3])\nassert OmegaConf.is_config(l)\nassert OmegaConf.is_list(l)\nassert not OmegaConf.is_dict(l)\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf from Dot-list\nDESCRIPTION: Creates an OmegaConf configuration from a dot-list format, where paths are represented as dot-separated strings.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndot_list = [\"a.aa.aaa=1\", \"a.aa.bbb=2\", \"a.bb.aaa=3\", \"a.bb.bbb=4\"]\nconf = OmegaConf.from_dotlist(dot_list)\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration with Interpolations - Python\nDESCRIPTION: Loads a YAML configuration file containing interpolation expressions and prints the parsed config. Interpolations allow referencing other config nodes dynamically; this snippet sets up for further interpolation demonstration.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.load('../source/config_interpolation.yaml')\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Conda Environment (Bash)\nDESCRIPTION: These commands demonstrate creating and activating a new Conda environment named 'omegaconf38' with Python 3.8 for project isolation. No external dependencies beyond Conda are required. The first command sets up an environment, while the second command activates it for use.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nconda create -n omegaconf38 python=3.8 -qy\n```\n\nLANGUAGE: bash\nCODE:\n```\nconda activate omegaconf38\n```\n\n----------------------------------------\n\nTITLE: Using the New oc.resolve Interpolation Resolver\nDESCRIPTION: OmegaConf 2.1 added a new interpolation resolver system with support for nested interpolations and improved resolver functionality.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_6\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf Configuration from a List - Python\nDESCRIPTION: Demonstrates creating an OmegaConf configuration from a list containing integers and dictionaries. Prints the resulting configuration in YAML format. Useful for handling array-based configuration data.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create([1, dict(a=10, b=dict(a=10))])\nprint(OmegaConf.to_yaml(conf))\n\n```\n\n----------------------------------------\n\nTITLE: Saving and Loading OmegaConf with Pickle\nDESCRIPTION: Shows how to save and load an OmegaConf configuration using pickle to retain type information.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"foo\": 10, \"bar\": 20, 123: 456})\nwith tempfile.TemporaryFile() as fp:\n    pickle.dump(conf, fp)\n    fp.flush()\n    assert fp.seek(0) == 0\n    loaded = pickle.load(fp)\n    assert conf == loaded\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies with pip (Bash)\nDESCRIPTION: Installs all development dependencies for OmegaConf in the currently activated environment using pip, including those listed in 'requirements/dev.txt'. The '-e .' option installs the package in editable mode. Requires pip and an active environment.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements/dev.txt -e .\n```\n\n----------------------------------------\n\nTITLE: Using Path and Bytes Type Support\nDESCRIPTION: OmegaConf 2.2 added native support for pathlib.Path and bytes objects as value types.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_5\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf from Dictionary\nDESCRIPTION: Creates an OmegaConf configuration from a Python dictionary containing nested structures.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"k\" : \"v\", \"list\" : [1, {\"a\": \"1\", \"b\": \"2\", 3: \"c\"}]})\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Using Interpolation with Dash Characters in Keys\nDESCRIPTION: OmegaConf 2.3.0 added support for interpolation to keys that contain a non-leading dash character, which wasn't possible in earlier versions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_1\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Converting OmegaConf Objects to Native Python Containers\nDESCRIPTION: Example of using OmegaConf.to_container() to convert OmegaConf objects to regular Python dictionaries and lists. Shows how to control interpolation resolution during conversion.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.create({\"foo\": \"bar\", \"foo2\": \"${foo}\"})\nassert type(conf) == DictConfig\nprimitive = OmegaConf.to_container(conf)\nshow(primitive)\nresolved = OmegaConf.to_container(conf, resolve=True)\nshow(resolved)\n```\n\n----------------------------------------\n\nTITLE: Simulating Command Line Overrides with OmegaConf in Python\nDESCRIPTION: This snippet demonstrates how to simulate command-line arguments by setting sys.argv, then merges them into an existing OmegaConf configuration using merge_with_cli(). Finally, it outputs the resulting configuration in YAML format. Dependencies include Python, OmegaConf, and an initialized conf object; expected input is sys.argv command-line arguments, while the output is printed YAML. This approach is useful for testing or scripting configuration overrides without running from a shell.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n# Simulate command line arguments\\nsys.argv = ['program.py', 'server.port=82']\\n# Merge with cli arguments\\nconf.merge_with_cli()\\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Omitting Fields from Structured Configs with Metadata\nDESCRIPTION: In OmegaConf 2.3.0, a new feature was added to allow ignoring specific fields in structured configs by setting the 'omegaconf_ignore' metadata flag to True.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_0\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Formatting Code and Sorting Imports (Bash)\nDESCRIPTION: Applies automatic formatting to code using black and sorts imports with isort. Both commands require respective packages installed. Ensures code adheres to style guide and import order before submission or pushing changes.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nblack .\n```\n\nLANGUAGE: bash\nCODE:\n```\nisort .\n```\n\n----------------------------------------\n\nTITLE: Merging Server Plugin and Site Configs - Python\nDESCRIPTION: Illustrates merging multiple web server-related OmegaConf configs (server, plugins, sites) into a unified configuration object. Facilitates reusable or layered configuration patterns in application setups.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.merge(server_cfg, plugin1_cfg, site1_cfg, site2_cfg)\n```\n\n----------------------------------------\n\nTITLE: Updating Config Values with OmegaConf.update\nDESCRIPTION: Demonstrates how to update values in an OmegaConf config using OmegaConf.update(), with support for both dot-notation and brackets. Shows how to control dictionary merging behavior with the merge flag and how to force addition of new keys.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create({\"foo\" : {\"bar\": 10}})\nOmegaConf.update(cfg, \"foo.bar\", 20)\nassert cfg.foo.bar == 20\n# Set dictionary value (using dot notation)\nOmegaConf.update(cfg, \"foo.bar\", {\"zonk\" : 30}, merge=False)\nassert cfg.foo.bar == {\"zonk\" : 30}\n# Merge dictionary value (using bracket notation)\n# note that merge is True by default, so you don't really need it here.\nOmegaConf.update(cfg, \"foo[bar]\", {\"oompa\" : 40}, merge=True)\nassert cfg.foo.bar == {\"zonk\" : 30, \"oompa\" : 40}\n# force_add ignores nodes in struct mode or Structured Configs nodes \n# and updates anyway, inserting keys as needed.\nOmegaConf.set_struct(cfg, True)\nOmegaConf.update(cfg, \"a.b.c.d\", 10, force_add=True)\nassert cfg.a.b.c.d == 10\n```\n\n----------------------------------------\n\nTITLE: Modifying and Running a Jupyter Notebook (Bash)\nDESCRIPTION: Runs the Jupyter Notebook server to edit and execute cells in project-specific notebooks. The command requires Jupyter Notebook to be installed and the appropriate environment activated.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\njupyter notebook\n```\n\n----------------------------------------\n\nTITLE: Installing OmegaConf with pip - Bash\nDESCRIPTION: Demonstrates how to install or upgrade the OmegaConf package using pip, ensuring the latest stable version is obtained. Requires Python and pip to be available in the environment, and internet access for fetching the package. The expected input is the command entered in a terminal, and the output is the successful installation or upgrade of OmegaConf to its most recent stable release.\nSOURCE: https://github.com/omry/omegaconf/blob/master/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install --upgrade omegaconf\n```\n\n----------------------------------------\n\nTITLE: Assigning and Validating Dict Field Types with OmegaConf Structured Config (Python)\nDESCRIPTION: Shows creation of a structured config with dict fields and enforces runtime type checking using OmegaConf. Demonstrates valid and invalid assignments, raising a ValidationError upon type mismatch. Requires OmegaConf, pytest's raises, and custom User class definitions. Inputs include different key-value assignments; outputs are successful assignments or ValidationError exceptions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> conf: DictExample = OmegaConf.structured(DictExample)\n\n>>> # Okay, correct type is assigned\n>>> conf.ints[\"d\"] = 10\n>>> conf.bools[\"Dos\"] = True\n>>> conf.users[\"James\"] = User(name=\"Bond\")\n\n>>> # Not okay, 10 cannot be assigned to a User\n>>> with raises(ValidationError):\n...     conf.users[\"Joe\"] = 10\n```\n\n----------------------------------------\n\nTITLE: Printing Secondary Configuration from File for Merging - Python\nDESCRIPTION: Loads another configuration file and prints it, to be merged along with a base configuration. Useful in scenarios where multiple teams or modules contribute configs. File must be on disk.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nsecond_conf = OmegaConf.load('../source/example3.yaml')\nprint(OmegaConf.to_yaml(second_conf))\n\n```\n\n----------------------------------------\n\nTITLE: Adding New Keys to OmegaConf Configuration - Python\nDESCRIPTION: Shows how to add a new key-value pair to a configuration. The example adds 'hostname' to the 'server' section. OmegaConf will create sub-nodes as required.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nconf.server.hostname = \"localhost\"\n\n```\n\n----------------------------------------\n\nTITLE: Installing Specific OmegaConf Release with pip - Bash\nDESCRIPTION: Shows how to install a particular OmegaConf release (e.g., version 2.1 or 2.0.6) directly via pip, specifying a target version as a parameter. Users must have pip installed and access to the Python Package Index; outputs the installation of the explicit OmegaConf version indicated in the command. This is practical when matching a codebase or tutorial that relies on a specific version.\nSOURCE: https://github.com/omry/omegaconf/blob/master/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install omegaconf==2.1\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install omegaconf==2.0.6\n```\n\n----------------------------------------\n\nTITLE: Using Unions for Field Types in OmegaConf Structured Configs (Python)\nDESCRIPTION: Illustrates how Union type annotations allow fields to accept multiple types, with OmegaConf enforcing type-specific assignments at runtime. Shows valid and invalid assignments, triggering ValidationError on incompatible types. Dependencies: typing.Union, dataclasses, OmegaConf. Inputs are various type assignments; outputs are values or exceptions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> from typing import Union\n>>>\n>>> @dataclass\n... class HasUnion:\n...     u: Union[float, bool] = 10.1\n...\n>>> cfg = OmegaConf.structured(HasUnion)\n>>> assert cfg.u == 10.1\n>>> cfg.u = True  # ok\n>>> cfg.u = b\"binary\"  # bytes not compatible with union\nTraceback (most recent call last):\n...\nomegaconf.errors.ValidationError: Cannot assign 'b'binary'' of type 'bytes' to Union[float, bool]\n    full_key: u\n    object_type=HasUnion\n>>> OmegaConf.structured(HasUnion(\"abc\"))  # str not compatible\nTraceback (most recent call last):\n...\nomegaconf.errors.ValidationError: Cannot assign 'abc' of type 'str' to Union[float, bool]\n    full_key: u\n    object_type=None\n```\n\n----------------------------------------\n\nTITLE: Creating and Accessing OmegaConf Configuration in Python\nDESCRIPTION: Demonstrates how to create a configuration object using OmegaConf, and how to access nested values within the configuration. It shows both dot notation and dictionary-style access.\nSOURCE: https://github.com/omry/omegaconf/blob/master/build_helpers/test_files/a/b/file2.txt#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import OmegaConf\n\nconf = OmegaConf.create({\n    \"db\": {\n        \"driver\": \"mysql\",\n        \"user\": \"root\",\n        \"pass\": \"secret\"\n    }\n})\n\n# Access nested elements\ndriver = conf.db.driver\n# or\ndriver = conf['db']['driver']\n\nprint(f\"driver: {driver}\")\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Optional Handling and Type Coercion in OmegaConf Structured Configs (Python)\nDESCRIPTION: Shows how OmegaConf treats fields with Optional type hints as accepting None and how regular assignments coerce to field type, except for Union fields. Includes demonstration of coercing types for str fields, but not for unions, which require exact type matches. Dependencies: dataclasses, OmegaConf, typing.Union, ValidationError. Inputs are value assignments; outputs include coerced values or ValidationErrors.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> @dataclass\n... class HasStr:\n...     s: str\n...\n>>> cfg = OmegaConf.structured(HasStr)\n>>> cfg.s = 10.1\n>>> assert cfg.s == \"10.1\"  # The assigned value has been converted to a string\n\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> @dataclass\n... class StrOrInt:\n...     u: Union[str, float]\n...\n>>> cfg = OmegaConf.structured(StrOrInt)\n>>> cfg.u = 10.1\n>>> assert cfg.u == 10.1  # The assigned value remains a `float`.\n>>> cfg.u = \"10.1\"\n>>> assert cfg.u == \"10.1\"  # The assigned value remains a `str`.\n>>> cfg.u = 123  # Conversion from `int` to `float` does not occur.\nTraceback (most recent call last):\n...\nomegaconf.errors.ValidationError: Value '123' of type 'int' is incompatible with type hint 'Union[str, float]'\n    full_key: u\n    object_type=StrOrInt\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Mandatory Values and Handling Missing Value Exception - Python\nDESCRIPTION: Illustrates the behavior when accessing a required configuration value that is unset (marked as '???'). OmegaConf raises a MissingMandatoryValue exception, which can be caught and handled. Useful for enforcing required configs.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import MissingMandatoryValue\ntry:\n    conf.log.file\nexcept MissingMandatoryValue as exc:\n    print(exc)\n\n```\n\n----------------------------------------\n\nTITLE: Runtime Type Enforcement of Nested OmegaConf Structured Configs (Python)\nDESCRIPTION: Demonstrates that OmegaConf enforces type safety for nested config fields, rejecting invalid assignments (such as assigning an int to a field expecting a dataclass instance) with a ValidationError.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nwith raises(ValidationError):\n    conf.manager = 10\n```\n\n----------------------------------------\n\nTITLE: Resolving Interpolations in OmegaConf\nDESCRIPTION: Demonstrates how to eagerly resolve all interpolations in an OmegaConf container using OmegaConf.resolve(). By default, interpolations are resolved lazily at access time, but this function forces immediate resolution.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\ncfg = OmegaConf.create({\"a\": 10, \"b\": \"${a}\"})\nshow(cfg)\nassert cfg.a == cfg.b == 10 # lazily resolving interpolation\nOmegaConf.resolve(cfg)\nshow(cfg)\n```\n\n----------------------------------------\n\nTITLE: Defining Quoted Value Rule in ANTLR Grammar\nDESCRIPTION: Grammar rule for parsing quoted strings that may contain nested interpolations\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/grammar.rst#_snippet_4\n\nLANGUAGE: antlr\nCODE:\n```\nquotedValue:\n    (QUOTE_OPEN_SINGLE | QUOTE_OPEN_DOUBLE)\n    text?\n    MATCHING_QUOTE_CLOSE;\n```\n\n----------------------------------------\n\nTITLE: Validation and Type Conversion of Interpolated Values in OmegaConf Structured Configs (Python)\nDESCRIPTION: Highlights validation and type conversion of interpolated values when fields reference each other with incompatible types, raising InterpolationValidationError except when conversion is possible. Also notes limitations for container node interpolations where validation is bypassed. Requires OmegaConf, II, dataclasses, ValidationError. Inputs are field setting and lookup; outputs are exceptions or automatic type conversion.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> from omegaconf import II\n>>> @dataclass\n... class Interpolation:\n...     str_key: str = \"string\"\n...     int_key: int = II(\"str_key\")\n\n>>> cfg = OmegaConf.structured(Interpolation)\n>>> cfg.int_key  # fails due to type mismatch\nTraceback (most recent call last):\n  ...\nomegaconf.errors.InterpolationValidationError: Value 'string' could not be converted to Integer\n    full_key: int_key\n    object_type=Interpolation\n>>> cfg.str_key = \"1234\"  # string value\n>>> assert cfg.int_key == 1234  # automatically convert str to int\n\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> @dataclass\n... class NotValidated:\n...     some_int: int = 0\n...     some_dict: Dict[str, str] = II(\"some_int\")\n\n>>> cfg = OmegaConf.structured(NotValidated)\n>>> assert cfg.some_dict == 0  # type mismatch, but no error\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Conditional Dependencies for Python Packages - requirements\nDESCRIPTION: This snippet demonstrates how to list required packages and apply version/environment markers for Python projects using requirements.txt syntax. It includes unconditional and conditional dependencies (PyYAML for all, dataclasses for Python 3.6, typing-extensions for Python < 3.10) and leverages inline comments for documentation. The snippet requires pip to process; dependencies are referenced by name and version, and markers use PEP 508 syntax for precise targeting. Inputs are package requirements with version specifiers; outputs are used by pip to install the correct package set. Limitations include the necessity for pip compatibility with environment markers and the absence of cross-dependency resolution logic.\nSOURCE: https://github.com/omry/omegaconf/blob/master/requirements/base.txt#_snippet_0\n\nLANGUAGE: requirements\nCODE:\n```\nPyYAML>=5.1.0\n# Use dataclasses backport for Python 3.6.\ndataclasses;python_version=='3.6'\n# Use typing extensions for Python < 3.10\ntyping-extensions;python_version<=\"3.9\"\n```\n\n----------------------------------------\n\nTITLE: Using Structured Config Mode with OmegaConf.to_container()\nDESCRIPTION: Example showing how to customize the handling of structured config nodes during conversion to containers using the structured_config_mode parameter with various SCMode options.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom omegaconf import SCMode\nconf = OmegaConf.create({\"structured_config\": MyConfig})\ncontainer = OmegaConf.to_container(conf,\n    structured_config_mode=SCMode.DICT_CONFIG)\nshow(container)\nshow(container[\"structured_config\"])\n```\n\n----------------------------------------\n\nTITLE: Working with Frozen Dataclasses Using OmegaConf Read-Only Flag (Python)\nDESCRIPTION: Shows how OmegaConf represents frozen dataclasses, propagating their read-only status and raising ReadonlyConfigError upon attempted modification of any field (including nested items). Requires OmegaConf, dataclasses, typing.List, pytest.raises. Inputs are assignments to frozen fields; outputs are exceptions.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/structured_config.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n>>> from dataclasses import dataclass, field\n>>> from typing import List\n>>> @dataclass(frozen=True)\n... class FrozenClass:\n...     x: int = 10\n...     list: List = field(default_factory=lambda: [1, 2, 3])\n\n>>> conf = OmegaConf.structured(FrozenClass)\n>>> with raises(ReadonlyConfigError):\n...    conf.x = 20\n\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> with raises(ReadonlyConfigError):\n...    conf.list[0] = 20\n\n```\n\n----------------------------------------\n\nTITLE: Defining and Including Python Development Dependencies - Python\nDESCRIPTION: Lists required Python development dependencies, including references to base requirements (\\\"-r base.txt\\\") and documentation requirements (\\\"-r docs.txt\\\"), along with development and testing tools like mypy, pytest, flake8, and black. The file can be used with pip or tools like pip-tools to install all listed dependencies, ensuring a reproducible environment for code formatting, static analysis, and packaging. Comments indicate reasoning for particular dependencies, such as typing support for mypy.\nSOURCE: https://github.com/omry/omegaconf/blob/master/requirements/dev.txt#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n-r base.txt\n-r docs.txt\nattrs\nblack==24.2.0\nbuild\ncoveralls\nflake8==6.0.0\nisort==5.13.2\nmypy==1.8.0\nnox\npre-commit\npyflakes\npytest\npytest-benchmark\npytest-mock\ntowncrier\ntypes-setuptools  # makes mypy happy\ntwine\npydevd\n```\n\n----------------------------------------\n\nTITLE: Creating OmegaConf from Structured Config Object\nDESCRIPTION: Creates a type-safe OmegaConf configuration from an initialized dataclass object.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nconf = OmegaConf.structured(MyConfig(port=443))\nprint(OmegaConf.to_yaml(conf))\n```\n\n----------------------------------------\n\nTITLE: Iterating Sections and Categories in Jinja2\nDESCRIPTION: A nested template structure that processes sections and their categories, handling different content types and formatting. It includes logic for empty sections and special category handling for plugins and processes.\nSOURCE: https://github.com/omry/omegaconf/blob/master/news/_template.rst#_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% for section in sections %}\n{% if section %}\n{{section}}\n\n{% endif %}\n{% if sections[section] %}\n{% for category, val in definitions.items() if category in sections[section] and category != 'trivial' %}\n\n### {{ definitions[category]['name'] }}\n\n{% if definitions[category]['showcontent'] %}\n{% for text, values in sections[section][category]|dictsort(by='value') %}\n- {{ text }}{% if category != 'plugin' and category != 'process' %} ({{ values|sort|join(', ') }}){% endif %}\n\n{% endfor %}\n{% else %}\n- {{ sections[section][category]['']|sort|join(', ') }}\n\n\n{% endif %}\n{% if sections[section][category]|length == 0 %}\n\nNo significant changes.\n\n\n{% else %}\n{% endif %}\n{% endfor %}\n{% else %}\n\nNo significant changes.\n\n\n{% endif %}\n{% endfor %}\n```\n\n----------------------------------------\n\nTITLE: Using New Bracket Notation for Nested Keys\nDESCRIPTION: OmegaConf 2.1 added support for using bracket notation as an alternative to dot notation for accessing nested keys.\nSOURCE: https://github.com/omry/omegaconf/blob/master/NEWS.md#_snippet_7\n\nLANGUAGE: undefined\nCODE:\n```\nundefined\n```\n\n----------------------------------------\n\nTITLE: Building Documentation using nox or Make (Bash)\nDESCRIPTION: Enables building OmegaConf documentation using either a nox session or GNU Make inside the docs folder. 'nox -s docs' runs the documentation build session, while 'make' can build in various formats (e.g., HTML). After building, documentation can be viewed locally.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnox -s docs\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake html\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Interpolation - Python\nDESCRIPTION: Prepares the process environment for subsequent examples by setting an environment variable (USER). This is necessary for resolving ${oc.env:USER} interpolations in configuration files.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n# Let's set up the environment first (only needed for this demonstration)\nimport os\nos.environ['USER'] = 'omry'\n\n```\n\n----------------------------------------\n\nTITLE: YAML Configuration Example for Server and Users\nDESCRIPTION: Defines a YAML configuration with a server port and a user list. This snippet serves as an example source for OmegaConf YAML loading functions. There are no required dependencies other than a YAML parser; keys include 'server' with its 'port', and 'users', a list of usernames. The file is designed to illustrate hierarchical configuration structures.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_37\n\nLANGUAGE: yaml\nCODE:\n```\nserver:\\n  port: 80\\nusers:\\n  - user1\\n  - user2\n```\n\n----------------------------------------\n\nTITLE: Setting up Development Install with setup.py - Python\nDESCRIPTION: Shows how to install the current OmegaConf repository in development mode using setup.py. This is useful when making changes to OmegaConf or running notebooks/tests directly from the local clone. The command should be run from the repository root and requires setuptools.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npython setup.py develop\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty OmegaConf Configuration - Python\nDESCRIPTION: Initializes an empty OmegaConf object and prints its contents. Requires the omegaconf library to be installed and accessible on the Python path. Output is an empty configuration structure.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport os\nsys.path.insert(0, os.path.abspath(\"../../\"))\n\n\nfrom omegaconf import OmegaConf\nconf = OmegaConf.create()\nprint(conf)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Interpolation Rules in ANTLR Grammar\nDESCRIPTION: Grammar rules for parsing config node interpolations and resolver interpolations\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/grammar.rst#_snippet_1\n\nLANGUAGE: antlr\nCODE:\n```\ninterpolation: interpolationNode | interpolationResolver;\n\ninterpolationNode:\n    INTER_OPEN  // ${\n    DOT* \n    (configKey | BRACKET_OPEN configKey BRACKET_CLOSE)\n    (DOT configKey | BRACKET_OPEN configKey BRACKET_CLOSE)*\n    INTER_CLOSE;  // }\n\ninterpolationResolver:\n    INTER_OPEN  // ${\n    resolverName COLON sequence?\n    BRACE_CLOSE;  // }\n```\n\n----------------------------------------\n\nTITLE: Defining Text Rule in ANTLR Grammar\nDESCRIPTION: Base grammar rule for parsing interpolation strings containing ${} sequences and regular text\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/grammar.rst#_snippet_0\n\nLANGUAGE: antlr\nCODE:\n```\ntext: (interpolation | ANY_STR | ESC | ESC_INTER | TOP_ESC | QUOTED_ESC)+;\n```\n\n----------------------------------------\n\nTITLE: Preparing and Uploading a Release to PyPI (Bash)\nDESCRIPTION: Shows a standard workflow for cleaning previous build artifacts, packaging distributions using setuptools, and uploading to PyPI with twine. Requires Python, setuptools, wheel, and twine installed and configured. 'rm -rf' cleans old distributions; 'python setup.py sdist bdist_wheel' generates the package; 'twine upload dist/*' uploads it.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf dist/ omegaconf.egg-info/\n```\n\nLANGUAGE: bash\nCODE:\n```\npython setup.py sdist bdist_wheel\n```\n\nLANGUAGE: bash\nCODE:\n```\ntwine upload dist/*\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Development Dependencies for OmegaConf Project\nDESCRIPTION: This requirements file includes references to another requirements file named 'dev.txt' using the -r flag, which will incorporate all dependencies from that file. It also explicitly lists 'coveralls', a Python package used for test coverage reporting and integration with the Coveralls service.\nSOURCE: https://github.com/omry/omegaconf/blob/master/requirements/coverage.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r dev.txt\ncoveralls\n```\n\n----------------------------------------\n\nTITLE: Listing Documentation Dependencies for OmegaConf\nDESCRIPTION: This snippet enumerates the Python packages required to build the documentation for OmegaConf. It includes Sphinx as the main documentation generator and the sphinx-tabs extension for creating tabbed content in the documentation.\nSOURCE: https://github.com/omry/omegaconf/blob/master/requirements/docs.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsphinx\nsphinx-tabs\n```\n\n----------------------------------------\n\nTITLE: Registering eval as a Resolver in OmegaConf (Python)\nDESCRIPTION: Registers Python's built-in eval function as a new custom resolver within OmegaConf by calling OmegaConf.register_new_resolver. This enables later configuration parsing to dynamically compute values using eval. Requires OmegaConf and Python's built-in eval. No additional parameters; must be called before creating OmegaConf configs that reference the resolver.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/how_to_guides.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> from omegaconf import OmegaConf\\n>>> OmegaConf.register_new_resolver(\"eval\", eval)\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic with eval Resolver in YAML-defined OmegaConf Config (Python/YAML)\nDESCRIPTION: Creates an OmegaConf config from a YAML string that uses an eval resolver to compute 10 squared. Requires OmegaConf, the previously registered eval resolver, and a YAML-formatted config string. Verifies the result using an assertion. Input is a YAML string, output is a config with computed values.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/how_to_guides.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> yaml_data = \"\"\"\\n... ten_squared: ${eval:'10 ** 2'}\\n... \"\"\"\\n>>> cfg = OmegaConf.create(yaml_data)\\n>>> assert cfg.ten_squared == 100\n```\n\n----------------------------------------\n\nTITLE: Resolving Interpolations with to_yaml(resolve=True) - Python\nDESCRIPTION: Uses the 'resolve=True' flag to expand all interpolation expressions when serializing the configuration to YAML. This outputs the fully resolved config for further processing or inspection.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nprint(OmegaConf.to_yaml(conf, resolve=True))\n\n```\n\n----------------------------------------\n\nTITLE: Installing OmegaConf with pip\nDESCRIPTION: Instructions for installing OmegaConf using pip. OmegaConf requires Python 3.8 or newer.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/usage.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install omegaconf\n```\n\n----------------------------------------\n\nTITLE: Installing OmegaConf with pip - pip\nDESCRIPTION: Demonstrates installing the OmegaConf library using pip. This is required for all subsequent code snippets utilizing OmegaConf functionality. Simply run the command in your terminal; requires Python and pip to be installed.\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/notebook/Tutorial.ipynb#_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\npip install omegaconf\n```\n\n----------------------------------------\n\nTITLE: Installing OmegaConf via pip in Python\nDESCRIPTION: Shows how to install the OmegaConf library using pip, the Python package installer. This is typically the first step before using OmegaConf in a project.\nSOURCE: https://github.com/omry/omegaconf/blob/master/build_helpers/test_files/a/b/file2.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install omegaconf\n```\n\n----------------------------------------\n\nTITLE: Defining Sequence Rule in ANTLR Grammar\nDESCRIPTION: Grammar rule for parsing comma-separated sequences of elements\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/grammar.rst#_snippet_2\n\nLANGUAGE: antlr\nCODE:\n```\nsequence: (element (COMMA element?)*) | (COMMA element?)+;\n```\n\n----------------------------------------\n\nTITLE: Defining Element Types in ANTLR Grammar\nDESCRIPTION: Grammar rules for parsing different types of elements including quoted values, lists, dictionaries, and primitives\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/grammar.rst#_snippet_3\n\nLANGUAGE: antlr\nCODE:\n```\nelement:\n    quotedValue\n    | listContainer\n    | dictContainer\n    | primitive\n;\n```\n\n----------------------------------------\n\nTITLE: Defining Container Rules in ANTLR Grammar\nDESCRIPTION: Grammar rules for parsing list and dictionary containers\nSOURCE: https://github.com/omry/omegaconf/blob/master/docs/source/grammar.rst#_snippet_5\n\nLANGUAGE: antlr\nCODE:\n```\nlistContainer: BRACKET_OPEN sequence? BRACKET_CLOSE;\ndictContainer: BRACE_OPEN\n               (dictKeyValuePair (COMMA dictKeyValuePair)*)?\n               BRACE_CLOSE;\n```\n\n----------------------------------------\n\nTITLE: Listing and Running nox Sessions (Bash)\nDESCRIPTION: Lists all available nox sessions defined for OmegaConf, enabling users to run specific test, documentation, or linting sessions. The '-l' flag lists sessions, while '-s' allows running a session by name. Requires 'nox' installed and a valid noxfile.py.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnox -l\n```\n\nLANGUAGE: bash\nCODE:\n```\nnox -s lint\n```\n\n----------------------------------------\n\nTITLE: Running Tests with pytest (Bash)\nDESCRIPTION: Invokes test execution using pytest directly from the command line. Requires pytest to be installed and configured and a suitable Python environment.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npytest\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit Hooks (Bash)\nDESCRIPTION: Sets up pre-commit hooks for automatic code linting before commits. Requires 'pre-commit' to be installed. Helps prevent code style issues from being committed, but pre-commit checks can be skipped using the example provided.\nSOURCE: https://github.com/omry/omegaconf/blob/master/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -n\n```"
  }
]