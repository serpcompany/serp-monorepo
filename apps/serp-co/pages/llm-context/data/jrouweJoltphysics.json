[
  {
    "owner": "jrouwe",
    "repo": "joltphysics",
    "content": "TITLE: Physics System Update Method\nDESCRIPTION: Core method for advancing the physics simulation, which uses jobs to perform work across multiple CPUs. Implements a Sequential Impulse solver with warm starting.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nPhysicsSystem::Update\n```\n\n----------------------------------------\n\nTITLE: Accessing Bodies with Thread-Safe Locking in Jolt Physics (C++)\nDESCRIPTION: Demonstrates how to safely access a physics body using the locking body interface. This pattern prevents concurrent access to the same body from multiple threads by using a mutex array, ensuring thread safety when reading body data.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nJPH::BodyLockInterface lock_interface = physics_system.GetBodyLockInterface(); // Or GetBodyLockInterfaceNoLock\nJPH::BodyID body_id = ...; // Obtain ID to body\n\n// Scoped lock\n{\n\tJPH::BodyLockRead lock(lock_interface, body_id);\n\tif (lock.Succeeded()) // body_id may no longer be valid\n\t{\n\t\tconst JPH::Body &body = lock.GetBody();\n\n\t\t// Do something with body\n\t\t...\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Convex Hull Shape in C++\nDESCRIPTION: Example showing how to create a convex hull shape using ShapeSettings and handling the result. Demonstrates shape reference counting and error handling.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// Shapes are refcounted and can be shared between bodies\nJPH::Ref<Shape> shape;\n\n// The ShapeSettings object is only required for building the shape, all information is copied into the Shape class\n{\n    // Create an array of vertices\n    JPH::Array<JPH::Vec3> vertices = { ... };\n\n    // Create the settings object for a convex hull\n    JPH::ConvexHullShapeSettings settings(vertices, JPH::cDefaultConvexRadius);\n\n    // Create shape\n    JPH::Shape::ShapeResult result = settings.Create();\n    if (result.IsValid())\n        shape = result.Get();\n    else\n        ... // Error handling\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Gravity in Jolt Physics (C++)\nDESCRIPTION: Example of how to set gravity in Jolt Physics using the PhysicsSystem::SetGravity function. This allows changing the up axis of the simulation.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\nPhysicsSystem::SetGravity\n```\n\n----------------------------------------\n\nTITLE: Creating Soft Bodies in Jolt Physics\nDESCRIPTION: Process for creating soft bodies (deformable objects) using SoftBodySharedSettings and SoftBodyCreationSettings objects. The body is created and added to the world through BodyInterface::CreateAndAddSoftBody.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// 1. Allocate shared settings on heap\nSoftBodySharedSettings* shared_settings = new SoftBodySharedSettings();\n\n// 2. Create creation settings (e.g. on stack)\nSoftBodyCreationSettings creation_settings;\n\n// 3. Create and add body to world\nBody* soft_body = body_interface->CreateAndAddSoftBody(creation_settings);\n```\n\n----------------------------------------\n\nTITLE: Saving and Loading Shapes in Binary Format\nDESCRIPTION: Demonstrates how to save and load shapes in binary format using StreamOutWrapper and StreamInWrapper. Includes handling of shape and material mappings.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n// Create a sphere of radius 1\nJPH::Ref<Shape> sphere = new JPH::SphereShape(1.0f);\n\n// For this example we'll be saving the shape in a STL string stream\nstringstream data;\nJPH::StreamOutWrapper stream_out(data);\n\n// Save the shape\nJPH::Shape::ShapeToIDMap shape_to_id;\nJPH::Shape::MaterialToIDMap material_to_id;\nsphere->SaveWithChildren(stream_out, shape_to_id, material_to_id);\n\n// Wrap the STL stream in a StreamIn\nJPH::StreamInWrapper stream_in(data);\n\n// Load the shape\nJPH::Shape::IDToShapeMap id_to_shape;\nJPH::Shape::IDToMaterialMap id_to_material;\nJPH::Shape::ShapeResult result = JPH::Shape::sRestoreWithChildren(stream_in, id_to_shape, id_to_material);\n\nJPH::Ref<Shape> restored_shape;\nif (result.IsValid())\n    restored_shape = result.Get();\nelse\n    ... // Error handling\n```\n\n----------------------------------------\n\nTITLE: Safe Shape Scaling using ScaleShape Method\nDESCRIPTION: Demonstrates the safer way to scale shapes using the Shape::ScaleShape function, which validates the scale and produces the closest valid scale if the requested scale is invalid.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nJPH::Shape::ShapeResult my_scaled_shape = my_non_scaled_shape->ScaleShape(JPH::Vec3(x_scale, y_scale, z_scale));\n```\n\n----------------------------------------\n\nTITLE: Character-Rigid Body Hybrid Creation with CharacterVirtualSettings\nDESCRIPTION: Code reference showing how to create a hybrid between CharacterVirtual and rigid body by setting the mInnerBodyShape property. This creates an inner rigid body that follows the CharacterVirtual's movement and can be detected by sensors and collision tests.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nCharacterVirtualSettings::mInnerBodyShape\n```\n\n----------------------------------------\n\nTITLE: Saving and Restoring Physics State in Jolt (C++)\nDESCRIPTION: Functions for saving and restoring the physics state in Jolt, useful for implementing rollback in networked simulations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_26\n\nLANGUAGE: cpp\nCODE:\n```\nPhysicsSystem::SaveState\n```\n\nLANGUAGE: cpp\nCODE:\n```\nPhysicsSystem::RestoreState\n```\n\n----------------------------------------\n\nTITLE: CharacterVirtual Ray Casting with Collector\nDESCRIPTION: Pattern for performing ray casts that include CharacterVirtual objects, which requires combining the standard NarrowPhaseQuery ray cast with a direct ray cast against the character's transformed shape.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\nNarrowPhaseQuery::CastRay(..., collector)\nCharacterVirtual::GetTransformedShape().CastRay(..., collector)\n```\n\n----------------------------------------\n\nTITLE: Creating Bodies with Specific IDs in Jolt (C++)\nDESCRIPTION: Function to create bodies with specific IDs in Jolt Physics, ensuring consistent body IDs across client and server for deterministic rollbacks.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_27\n\nLANGUAGE: cpp\nCODE:\n```\nBodyInterface::CreateBodyWithID\n```\n\n----------------------------------------\n\nTITLE: Finding Collisions in Jolt Physics\nDESCRIPTION: This job performs broad and narrow phase collision checks. It processes active bodies, detects collision pairs, and sets up contact constraints. The job uses GJK and EPA algorithms for contact point determination and implements a lock-free contact cache.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_29\n\nLANGUAGE: C++\nCODE:\n```\n// Pseudo-code for Find Collisions job\nwhile (active_bodies_exist || collision_pairs_exist) {\n    if (active_bodies_exist) {\n        process_batch_of_active_bodies();\n        insert_collision_pairs_to_queue();\n    } else {\n        perform_narrow_phase_collision_detection();\n        setup_contact_constraints();\n    }\n    check_for_new_active_bodies();\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Character Linear Velocity\nDESCRIPTION: Methods to set linear velocity for Character and CharacterVirtual objects. These methods are used to kinematically drive characters through the physics world.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nCharacter::SetLinearVelocity\nCharacterVirtual::SetLinearVelocity\n```\n\n----------------------------------------\n\nTITLE: Solving Position Constraints in Jolt Physics\nDESCRIPTION: This job runs the position-based constraint solver to fix numerical drift. It also updates the broad phase with new body positions and handles body sleeping.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_33\n\nLANGUAGE: C++\nCODE:\n```\n// Pseudo-code for Solve Position Constraints job\nfor (auto& island : islands) {\n    for (int i = 0; i < max_iterations; i++) {\n        solve_position_constraints(island);\n        if (position_corrections_too_small()) break;\n    }\n    update_broadphase(island);\n    check_and_put_to_sleep(island);\n}\n```\n\n----------------------------------------\n\nTITLE: Extended Character Update with Stair Stepping\nDESCRIPTION: Method for CharacterVirtual that provides enhanced movement features such as stair stepping and sticking to the ground when walking down slopes.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nCharacterVirtual::ExtendedUpdate\n```\n\n----------------------------------------\n\nTITLE: Center of Mass Ray Casting Example\nDESCRIPTION: Shows how to properly handle center of mass when working with shapes, including ray casting and bounding box calculations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// Create box of 2x2x2 m (you specify half the side)\nJPH::BoxShapeSettings box(JPH::Vec3(1, 1, 1));\nJPH::Ref<Shape> box_shape = box.Create().Get();\n\n// Offset it by 10 m\nJPH::RotatedTranslatedShapeSettings translated_box(JPH::Vec3(10, 0, 0), JPH::Quat::sIdentity(), box_shape);\nJPH::Ref<Shape> translated_box_shape = translated_box.Create().Get();\n\n// Cast a ray against the offset box (WRONG!)\nJPH::RayCast ray;\nray.mOrigin = JPH::Vec3(10, 2, 0);\nray.mDirection = JPH::Vec3(0, -2, 0);\n\n// Cast ray\nJPH::RayCastResult hit;\nbool had_hit = translated_box_shape->CastRay(ray, JPH::SubShapeIDCreator(), hit);\nJPH_ASSERT(!had_hit); // There's no hit because we did not correct for COM!\n\n// Convert the ray to center of mass space for the shape (CORRECT!)\nray.mOrigin -= translated_box_shape->GetCenterOfMass();\n\n// Cast ray\nhad_hit = translated_box_shape->CastRay(ray, JPH::SubShapeIDCreator(), hit);\nJPH_ASSERT(had_hit); // Ray was in COM space, now there's a hit!\n```\n\n----------------------------------------\n\nTITLE: Setting Up Velocity Constraints in Jolt Physics\nDESCRIPTION: This job prepares non-contact constraints for execution by calculating Jacobians and effective masses for each constraint part.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_30\n\nLANGUAGE: C++\nCODE:\n```\n// Pseudo-code for Setup Velocity Constraints job\nfor (auto& constraint : non_contact_constraints) {\n    calculate_jacobians(constraint);\n    calculate_effective_masses(constraint);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Scaled Shape in Jolt Physics\nDESCRIPTION: Creates a scaled version of an existing shape using the ScaledShape class. The scale is specified as a 3D vector for x, y, and z dimensions.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nJPH::RefConst<Shape> my_scaled_shape = new JPH::ScaledShape(my_non_scaled_shape, JPH::Vec3(x_scale, y_scale, z_scale));\n```\n\n----------------------------------------\n\nTITLE: Solving Velocity Constraints in Jolt Physics\nDESCRIPTION: This job runs the iterative constraint solver for each island. It applies warm start impulses, iterates over constraints, and handles large islands using a parallel splitting algorithm.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_31\n\nLANGUAGE: C++\nCODE:\n```\n// Pseudo-code for Solve Velocity Constraints job\nfor (auto& island : islands) {\n    apply_warm_start_impulses(island);\n    for (int i = 0; i < max_iterations; i++) {\n        solve_constraints(island);\n        if (applied_impulses_too_small()) break;\n    }\n    store_applied_impulses(island);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing CharacterVirtual with Custom ID in C++\nDESCRIPTION: Sets up a CharacterVirtual instance with a custom CharacterID and inner rigid body ID for deterministic simulation in client/server setups.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/ReleaseNotes.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nCharacterVirtual character;\nCharacterID custom_id = /* ... */;\nBodyID custom_body_id = /* ... */;\ncharacter.SetCharacterID(custom_id);\ncharacter.SetInnerRigidBodyID(custom_body_id);\n```\n\n----------------------------------------\n\nTITLE: Integrating and Clamping Velocities in Jolt Physics\nDESCRIPTION: This job integrates velocity, updates position, clamps velocity to the max velocity, and schedules bodies for continuous collision detection if necessary.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_32\n\nLANGUAGE: C++\nCODE:\n```\n// Pseudo-code for Integrate & Clamp Velocities job\nfor (auto& body : active_bodies) {\n    integrate_velocity(body);\n    update_position(body);\n    clamp_velocity(body);\n    if (needs_ccd(body)) {\n        schedule_for_ccd(body);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Soft Bodies in Jolt Physics\nDESCRIPTION: This set of jobs handles soft body simulation, including collision detection with rigid bodies, XPBD simulation, and updating rigid body velocities.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_34\n\nLANGUAGE: C++\nCODE:\n```\n// Pseudo-code for Soft Body Simulate job\nfor (auto& soft_body : active_soft_bodies) {\n    collide_with_rigid_bodies(soft_body);\n    perform_xpbd_simulation(soft_body);\n    update_rigid_body_velocities(soft_body);\n}\n```\n\n----------------------------------------\n\nTITLE: Object Layer Enum Example\nDESCRIPTION: Example enumeration defining different object layers for collision filtering including static objects, dynamic bodies, debris, bullets, and weapon layers.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nenum ObjectLayer {\n    NON_MOVING,  // Layer for all static objects\n    MOVING,      // Layer for all regular dynamic bodies\n    DEBRIS,      // Layer for debris dynamic bodies\n    BULLET,      // Layer for high detail collision bodies\n    WEAPON       // Query layer for weapon system\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Soft Body Properties\nDESCRIPTION: Example showing how to check if a body is a soft body and access its motion properties through casting.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nif (body->IsSoftBody()) {\n    SoftBodyMotionProperties* properties = static_cast<SoftBodyMotionProperties*>(body->GetMotionProperties());\n    // Use properties API\n}\n```\n\n----------------------------------------\n\nTITLE: Moving Kinematic Bodies After Physics Update\nDESCRIPTION: Methods to update high-detail kinematic or static bodies after physics simulation. These are used when implementing level of detail with separate bodies for simulation and collision detection.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nBodyInterface::MoveKinematic\nBodyInterface::SetPositionAndRotation\n```\n\n----------------------------------------\n\nTITLE: Updating Character Status After Physics Simulation\nDESCRIPTION: Method call to update a Character's ground contacts after each physics system update. This must be called after PhysicsSystem::Update to ensure proper character behavior.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nCharacter::PostSimulation\n```\n\n----------------------------------------\n\nTITLE: Using Reference Counting with Ref Class in C++\nDESCRIPTION: Demonstrates how to use the Ref class for automatic reference counting of Shape objects in Jolt Physics. It shows creating a reference-counted SphereShape and releasing it.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_28\n\nLANGUAGE: C++\nCODE:\n```\n// Calls 'AddRef' to keep a reference the shape\nJPH::Ref<Shape> shape = new JPH::SphereShape(1.0f);\n\n// Calls 'Release' to release and delete the shape (note that this also happens if JPH::Ref goes out of scope)\nshape = nullptr;\n```\n\n----------------------------------------\n\nTITLE: Using STLLocalAllocator in C++\nDESCRIPTION: Demonstrates the use of STLLocalAllocator with the Array class, providing a fixed-size buffer before falling back to heap allocation.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/ReleaseNotes.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nArray<int, STLLocalAllocator<int, 10>> my_array;\n// First 10 elements use local buffer\nfor (int i = 0; i < 15; ++i) {\n    my_array.push_back(i);\n}\n// After 10 elements, falls back to heap allocation\n```\n\n----------------------------------------\n\nTITLE: Collision Detection Interface Methods\nDESCRIPTION: Core collision detection method signatures referenced in the documentation for various collision tests.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nBroadPhaseQuery::CastRay\nNarrowPhaseQuery::CastRay\nTransformedShape::CastRay\nShape::CastRay\nNarrowPhaseQuery::CollideShape\nTransformedShape::CollideShape\nCollisionDispatch::sCollideShapeVsShape\nNarrowPhaseQuery::CastShape\nTransformedShape::CastShape\nCollisionDispatch::sCastShapeVsShapeWorldSpace\nBroadPhaseQuery::CollidePoint\nNarrowPhaseQuery::CollidePoint\nTransformedShape::CollidePoint\nShape::CollidePoint\n```\n\n----------------------------------------\n\nTITLE: Broad Phase Layer Definition\nDESCRIPTION: Definition of broad phase layers that group multiple object layers together for optimization purposes.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nenum BroadPhaseLayer {\n    BP_NON_MOVING,  // For static objects\n    BP_MOVING,      // Default layer for dynamic objects\n    BP_DEBRIS       // Special layer for debris only\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Jolt Physics Engine with Disabled Instructions in CMake\nDESCRIPTION: This CMake command disables all special instructions for the Jolt Physics Engine. It's useful when the CPU doesn't support certain instructions, causing 'Illegal instruction' exceptions. The settings can be adjusted based on the CPU's capabilities.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./cmake_linux_clang_gcc.sh Release clang++ -DUSE_SSE4_1=OFF -DUSE_SSE4_2=OFF -DUSE_AVX=OFF -DUSE_AVX2=OFF -DUSE_AVX512=OFF -DUSE_LZCNT=OFF -DUSE_TZCNT=OFF -DUSE_F16C=OFF -DUSE_FMADD=OFF\n```\n\n----------------------------------------\n\nTITLE: Setting Shape Filters for Simulation\nDESCRIPTION: Method to filter out high-detail shapes during simulation when using a compound shape that contains both high and low detail collision shapes.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\nPhysicsSystem::SetSimShapeFilter\n```\n\n----------------------------------------\n\nTITLE: Resolving Undefined Symbol Link Error in C++\nDESCRIPTION: This error is caused by a mismatch in RTTI settings between the project and the Jolt library. It can be fixed by either turning off RTTI for the project or enabling it for Jolt using the CPP_RTTI_ENABLED cmake option.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nerror: undefined symbol: typeinfo for JPH::DebugRenderer\n```\n\n----------------------------------------\n\nTITLE: Setting Motor Parameters Example\nDESCRIPTION: Code references showing how to set motor parameters like target velocity, position, and state. These are referenced in the documentation but not explicitly shown.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nSliderConstraint::SetMotorState\nSliderConstraint::SetTargetVelocity\nHingeConstraint::SetTargetAngularVelocity\nSliderConstraint::SetTargetPosition\nHingeConstraint::SetTargetAngle\n```\n\n----------------------------------------\n\nTITLE: Defining Double Precision in Jolt Physics (C++)\nDESCRIPTION: Compile-time definition to enable double precision for positions in Jolt Physics, useful for simulating very large worlds.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_21\n\nLANGUAGE: cpp\nCODE:\n```\nJPH_DOUBLE_PRECISION\n```\n\n----------------------------------------\n\nTITLE: Compiling for Cross-Platform Determinism in Jolt Physics (CMake)\nDESCRIPTION: CMake option to enable cross-platform determinism in Jolt Physics, ensuring consistent results across different platforms and compilers.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_22\n\nLANGUAGE: cmake\nCODE:\n```\nCROSS_PLATFORM_DETERMINISTIC\n```\n\n----------------------------------------\n\nTITLE: Using Jolt's Trigonometric Functions (C++)\nDESCRIPTION: Examples of using Jolt's built-in trigonometric functions for consistent results across platforms in deterministic simulations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_23\n\nLANGUAGE: cpp\nCODE:\n```\nSin\n```\n\nLANGUAGE: cpp\nCODE:\n```\nCos\n```\n\n----------------------------------------\n\nTITLE: Using Jolt's Sorting and Heap Functions (C++)\nDESCRIPTION: Examples of Jolt's sorting and heap functions to ensure consistent behavior across platforms for deterministic simulations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\nQuickSort\n```\n\nLANGUAGE: cpp\nCODE:\n```\nBinaryHeapPush\n```\n\nLANGUAGE: cpp\nCODE:\n```\nBinaryHeapPop\n```\n\n----------------------------------------\n\nTITLE: Custom Collection Implementation\nDESCRIPTION: Replacement of std::unordered_map and std::unordered_set with custom UnorderedMap and UnorderedSet implementations. Used in public interfaces like Shape::ShapeToIDMap.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/APIChanges.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nShape::ShapeToIDMap // Now uses custom UnorderedMap implementation\n```\n\n----------------------------------------\n\nTITLE: Using Jolt's Hash Function (C++)\nDESCRIPTION: Example of using Jolt's hash function for consistent hashing across platforms in deterministic simulations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/Architecture.md#2025-04-22_snippet_25\n\nLANGUAGE: cpp\nCODE:\n```\nHash\n```\n\n----------------------------------------\n\nTITLE: Character Virtual Contact Changes\nDESCRIPTION: Updates to CharacterVirtual::Contact behavior where mHadCollision is now true for sensor contacts. Important when using GetActiveContacts to check for mWasDiscarded.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/APIChanges.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nCharacterVirtual::Contact::mHadCollision\n```\n\n----------------------------------------\n\nTITLE: RayCast Settings Update\nDESCRIPTION: RayCastSettings::mBackFaceMode split into mBackFaceModeTriangles and mBackFaceModeConvex. Requires using SetBackFaceMode() instead of direct assignment.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/APIChanges.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nRayCastSettings::SetBackFaceMode(...) // Instead of mBackFaceMode = ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Vehicle Friction Sample Code in C++\nDESCRIPTION: Code example showing how to restore old vehicle friction behavior using the max tire impulse callback in vehicle constraint test.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/APIChanges.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nmVehicleConstraint->SetMaxTireImpulseCallback([](const VehicleConstraint *inConstraint, uint inWheel) {\n\treturn PhysicsSettings::sMaxPhysicsSimulationSteps * inConstraint->GetSettings()->mWheels[inWheel].mMaxBrakeTorque / inConstraint->GetSettings()->mWheels[inWheel].mRadius;\n});\n```\n\n----------------------------------------\n\nTITLE: Member Variable Renaming - PhysicsSettings Change\nDESCRIPTION: PhysicsSettings member variable mManifoldToleranceSq renamed to mManifoldTolerance and no longer uses squared values. ManifoldBetweenTwoFaces now accepts inMaxContactDistance instead of inMaxContactDistanceSq.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/APIChanges.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nPhysicsSettings::mManifoldTolerance // Previously mManifoldToleranceSq\n```\n\n----------------------------------------\n\nTITLE: Setting Body Inertia Properties in C++\nDESCRIPTION: Legacy code for setting inverse inertia properties on a physics body, used to replicate old angular motion behavior.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/APIChanges.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nMotionProperties::SetInverseInertia(diagonal, rotation)\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Options for JoltPhysics\nDESCRIPTION: Comprehensive set of CMake options that control build configuration, including debug settings, optimization flags, platform-specific features, and compiler options.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\noption(USE_ASSERTS \"Enable asserts\" OFF)\noption(DOUBLE_PRECISION \"Use double precision math\" OFF)\noption(GENERATE_DEBUG_SYMBOLS \"Generate debug symbols\" ON)\nset(JPH_DEBUG_SYMBOL_FORMAT \"\" CACHE STRING \"Which type of debug symbols to generate\")\noption(OVERRIDE_CXX_FLAGS \"Override CMAKE_CXX_FLAGS_DEBUG/RELEASE\" ON)\noption(CROSS_PLATFORM_DETERMINISTIC \"Cross platform deterministic\" OFF)\noption(CROSS_COMPILE_ARM \"Cross compile to the CROSS_COMPILE_ARM_TARGET architecture\" OFF)\nset(CROSS_COMPILE_ARM_TARGET \"aarch64-linux-gnu\" CACHE STRING \"The target to use\")\noption(BUILD_SHARED_LIBS \"Compile Jolt as a shared library\" OFF)\noption(INTERPROCEDURAL_OPTIMIZATION \"Enable interprocedural optimizations\" ON)\n```\n\n----------------------------------------\n\nTITLE: Debug and Profiling Configuration\nDESCRIPTION: Options for enabling debug rendering, profiling features, and performance tracking in different build configurations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\noption(TRACK_BROADPHASE_STATS \"Track Broadphase Stats\" OFF)\noption(TRACK_NARROWPHASE_STATS \"Track Narrowphase Stats\" OFF)\noption(DEBUG_RENDERER_IN_DEBUG_AND_RELEASE \"Enable debug renderer in Debug and Release builds\" ON)\noption(DEBUG_RENDERER_IN_DISTRIBUTION \"Enable debug renderer in all builds\" OFF)\noption(PROFILER_IN_DEBUG_AND_RELEASE \"Enable the profiler in Debug and Release builds\" ON)\noption(PROFILER_IN_DISTRIBUTION \"Enable the profiler in all builds\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Processor Feature Configuration Options\nDESCRIPTION: Configuration options for X86 processor features and SIMD capabilities, allowing fine-grained control over which CPU instructions are used.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\noption(USE_SSE4_1 \"Enable SSE4.1\" ON)\noption(USE_SSE4_2 \"Enable SSE4.2\" ON)\noption(USE_AVX \"Enable AVX\" ON)\noption(USE_AVX2 \"Enable AVX2\" ON)\noption(USE_AVX512 \"Enable AVX512\" OFF)\noption(USE_LZCNT \"Enable LZCNT\" ON)\noption(USE_TZCNT \"Enable TZCNT\" ON)\noption(USE_F16C \"Enable F16C\" ON)\noption(USE_FMADD \"Enable FMADD\" ON)\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific and Dependent Options\nDESCRIPTION: Conditional CMake options that depend on specific platforms or build configurations, including MSVC runtime selection and Vulkan support.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_4\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_dependent_option(USE_STATIC_MSVC_RUNTIME_LIBRARY \"Use the static MSVC runtime library\" ON \"MSVC;NOT WINDOWS_STORE\" OFF)\ncmake_dependent_option(JPH_ENABLE_VULKAN \"Enable Vulkan\" ON \"LINUX\" OFF)\n```\n\n----------------------------------------\n\nTITLE: Configuration Types Setup for Different Compilers\nDESCRIPTION: Sets available build configuration types based on the compiler being used. MSVC and GNU get basic configs while Clang receives additional sanitizer configurations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_5\n\nLANGUAGE: cmake\nCODE:\n```\nif (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n\tif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"MSVC\" OR \"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"GNU\")\n\t\tset(CMAKE_CONFIGURATION_TYPES \"Debug;Release;Distribution\")\n\telseif (\"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"Clang\" OR \"${CMAKE_CXX_COMPILER_ID}\" STREQUAL \"AppleClang\")\n\t\tset(CMAKE_CONFIGURATION_TYPES \"Debug;Release;ReleaseASAN;ReleaseUBSAN;ReleaseTSAN;ReleaseCoverage;Distribution\")\n\tendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: MSVC Compiler Configuration\nDESCRIPTION: Configures compiler and linker flags specific to Microsoft Visual Studio Compiler including debug symbols, RTTI, exceptions, and optimization settings.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_6\n\nLANGUAGE: cmake\nCODE:\n```\nif (MSVC)\n\tset(CLANG_LIB_PATH \"\\\"$(VSInstallDir)\\\\VC\\\\Tools\\\\Llvm\\\\x64\\\\lib\\\\clang\\\\${CMAKE_CXX_COMPILER_VERSION}\\\\lib\\\\windows\\\"\")\n\tset(CMAKE_VS_PLATFORM_TOOLSET_HOST_ARCHITECTURE \"x64\")\n\tif (USE_STATIC_MSVC_RUNTIME_LIBRARY)\n\t\tset(CMAKE_MSVC_RUNTIME_LIBRARY \"MultiThreaded$<$<CONFIG:Debug>:Debug>\")\n\tendif()\n\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /Zc:__cplusplus /Gm- /MP /nologo /diagnostics:classic /FC /fp:except- /Zc:inline\")\n\t# ... [Additional MSVC settings]\nendif()\n```\n\n----------------------------------------\n\nTITLE: Non-MSVC Compiler Configuration\nDESCRIPTION: Sets up compiler flags for non-MSVC compilers (GCC, Clang) including warning levels, debug symbols, RTTI, and exception handling settings.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_7\n\nLANGUAGE: cmake\nCODE:\n```\nelse()\n\tif (ENABLE_ALL_WARNINGS)\n\t\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -Wall -Werror\")\n\tendif()\n\tif (GENERATE_DEBUG_SYMBOLS)\n\t\tset(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g${JPH_DEBUG_SYMBOL_FORMAT}\")\n\tendif()\n\t# ... [Additional non-MSVC settings]\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on Windows with MSVC CL\nDESCRIPTION: Steps for building Jolt Physics on Windows using Visual Studio 2022 with the default MSVC CL compiler. Requires Visual Studio 2022 and CMake 3.20+.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_0\n\nLANGUAGE: Batch\nCODE:\n```\ncmake_vs2022_cl.bat\n```\n\n----------------------------------------\n\nTITLE: Installing Jolt Library Components\nDESCRIPTION: Configures the installation of Jolt library files, headers, and CMake configuration files. Handles proper file placement using GNUInstallDirs standards and creates export configurations.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_9\n\nLANGUAGE: cmake\nCODE:\n```\nif (ENABLE_INSTALL)\n\tinclude(GNUInstallDirs)\n\tinstall(TARGETS Jolt\n\t\tEXPORT JoltExport\n\t\tINCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n\t\tLIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n\t\tARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n\t\tRUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})\n\tforeach(SRC_FILE ${JOLT_PHYSICS_SRC_FILES})\n\t\tstring(REPLACE ${PHYSICS_REPO_ROOT} \"\" RELATIVE_SRC_FILE ${SRC_FILE})\n\t\tget_filename_component(DESTINATION_PATH ${RELATIVE_SRC_FILE} DIRECTORY)\n\t\tif (NOT RELATIVE_SRC_FILE MATCHES \"\\.cpp\")\n\t\t\tcmake_path(SET DST_FILE NORMALIZE \"${CMAKE_INSTALL_INCLUDEDIR}/${DESTINATION_PATH}\")\n\t\t\tinstall(FILES ${SRC_FILE} DESTINATION ${DST_FILE})\n\t\tendif()\n\tendforeach()\n\n\texport(TARGETS Jolt\n\t\tNAMESPACE Jolt::\n\t\tFILE JoltConfig.cmake)\n\tinstall(EXPORT JoltExport\n\t\tDESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Jolt/\n\t\tNAMESPACE Jolt::\n\t\tFILE JoltConfig.cmake)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Resolving Unresolved External Symbol Link Error in C++\nDESCRIPTION: This error occurs when there's a mismatch in defines between user code and the Jolt library, particularly with JPH_DEBUG_RENDERER. It's typically defined in Jolt.lib but not in the user's project. The error can be resolved by ensuring consistent define usage across the project and library.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nerror LNK2001: unresolved external symbol \"public: virtual void __cdecl JPH::ConvexShape::GetSubmergedVolume(...) const\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Build Targets and Options\nDESCRIPTION: Sets up build options for various components including unit tests, samples, and viewer applications. Includes platform-specific configurations and dependency checks.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_10\n\nLANGUAGE: cmake\nCODE:\n```\nif (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)\n\toption(TARGET_UNIT_TESTS \"Build Unit Tests\" ON)\n\toption(TARGET_HELLO_WORLD \"Build Hello World\" ON)\n\toption(TARGET_PERFORMANCE_TEST \"Build Performance Test\" ON)\n\toption(TARGET_SAMPLES \"Build Samples\" ON)\n\toption(TARGET_VIEWER \"Build JoltViewer\" ON)\n\n\tif (TARGET_UNIT_TESTS)\n\t\tinclude(${PHYSICS_REPO_ROOT}/UnitTests/UnitTests.cmake)\n\t\tadd_executable(UnitTests ${UNIT_TESTS_SRC_FILES})\n\t\ttarget_include_directories(UnitTests PUBLIC ${UNIT_TESTS_ROOT})\n\t\ttarget_link_libraries(UnitTests LINK_PUBLIC Jolt)\n\n\t\tif (EMSCRIPTEN)\n\t\t\ttarget_link_options(UnitTests PUBLIC -sSTACK_SIZE=1048576 -sINITIAL_MEMORY=134217728)\n\t\tendif()\n\n\t\tif (CMAKE_GENERATOR STREQUAL \"Ninja Multi-Config\" AND MSVC)\n\t\t\ttarget_precompile_headers(UnitTests PRIVATE \"${JOLT_PHYSICS_ROOT}/Jolt.h\")\n\t\telse()\n\t\t\ttarget_precompile_headers(UnitTests PRIVATE \"$<$<NOT:$<CONFIG:ReleaseCoverage>>:${JOLT_PHYSICS_ROOT}/Jolt.h>\")\n\t\tendif()\n\n\t\tif (MSVC)\n\t\t\ttarget_link_options(UnitTests PUBLIC \"/SUBSYSTEM:CONSOLE\")\n\t\tendif()\n\n\t\tif (IOS)\n\t\t\tset_property(TARGET UnitTests PROPERTY MACOSX_BUNDLE_INFO_PLIST \"${CMAKE_CURRENT_SOURCE_DIR}/iOS/UnitTestsInfo.plist\")\n\t\t\tset_property(TARGET UnitTests PROPERTY XCODE_ATTRIBUTE_PRODUCT_BUNDLE_IDENTIFIER \"com.joltphysics.unittests\")\n\t\tendif()\n\n\t\tif (XCODE)\n\t\t\tset_property(TARGET UnitTests PROPERTY XCODE_ATTRIBUTE_OTHER_CPLUSPLUSFLAGS[arch=x86_64] \"$(inherited) -msse4.2 -mpopcnt\")\n\t\tendif()\n\n\t\tenable_testing()\n\t\tadd_test(UnitTests UnitTests)\n\tendif()\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on Linux with Clang/GCC\nDESCRIPTION: Steps for building Jolt Physics on Linux using Clang or GCC compiler. Requires Clang, CMake, and optionally Vulkan SDK for Samples or JoltViewer.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\n./cmake_linux_clang_gcc.sh\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on Windows with MSVC CL (32-bit)\nDESCRIPTION: Steps for building a 32-bit version of Jolt Physics on Windows using Visual Studio 2022. Requires Visual Studio 2022 and CMake 3.20+.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_1\n\nLANGUAGE: Batch\nCODE:\n```\ncmake_vs2022_cl_32bit.bat\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on Windows for UWP\nDESCRIPTION: Steps for building Jolt Physics for Universal Windows Platform using Visual Studio 2022. Requires Visual Studio 2022 with UWP components and CMake 3.20+.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_3\n\nLANGUAGE: Batch\nCODE:\n```\ncmake_vs2022_uwp.bat\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on Windows with MinGW\nDESCRIPTION: Steps for building Jolt Physics on Windows using MinGW through MSYS2. Requires MSYS2 with MinGW toolchain and CMake.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\n./cmake_windows_mingw.sh\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake Project Configuration for JoltPhysics\nDESCRIPTION: Core CMake configuration that sets up the project version and minimum CMake requirements. Defines project name, version (5.3.1) and specifies C++ as the programming language.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ncmake_minimum_required(VERSION 3.20 FATAL_ERROR)\n\nproject(JoltPhysics VERSION 5.3.1 LANGUAGES CXX)\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on macOS with XCode\nDESCRIPTION: Steps for building Jolt Physics on macOS using XCode. Requires XCode and CMake 3.23+.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n./cmake_xcode_macos.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring Platform-Specific Targets\nDESCRIPTION: Configures platform-specific targets for Windows, Linux, and macOS, including the TestFramework, Samples, and JoltViewer applications. Includes SDK availability checks.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_12\n\nLANGUAGE: cmake\nCODE:\n```\nif ((WIN32 OR LINUX OR (\"${CMAKE_SYSTEM_NAME}\" MATCHES \"Darwin\")) AND NOT (\"${CMAKE_VS_PLATFORM_NAME}\" STREQUAL \"ARM\"))\n\tif (TARGET_SAMPLES OR TARGET_VIEWER)\n\t\tinclude(${PHYSICS_REPO_ROOT}/TestFramework/TestFramework.cmake)\n\tendif()\n\tif (TARGET_SAMPLES)\n\t\tif (TEST_FRAMEWORK_AVAILABLE)\n\t\t\tinclude(${PHYSICS_REPO_ROOT}/Samples/Samples.cmake)\n\t\telse()\n\t\t\tmessage(\"Cannot build Samples because Vulkan/DirectX SDK is not available!\")\n\t\tendif()\n\tendif()\n\tif (TARGET_VIEWER)\n\t\tif (TEST_FRAMEWORK_AVAILABLE)\n\t\t\tinclude(${PHYSICS_REPO_ROOT}/JoltViewer/JoltViewer.cmake)\n\t\telse()\n\t\t\tmessage(\"Cannot build JoltViewer because Vulkan/DirectX SDK is not available!\")\n\t\tendif()\n\tendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on iOS with XCode\nDESCRIPTION: Steps for building Jolt Physics on iOS using XCode. Requires XCode and CMake 3.23+. Note that this will only work in the simulator as code signing information is not set up.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\n./cmake_xcode.ios.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring Additional Applications\nDESCRIPTION: Sets up build configurations for Hello World and Performance Test applications, including platform-specific settings and asset handling for Emscripten builds.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_11\n\nLANGUAGE: cmake\nCODE:\n```\nif (NOT \"${CMAKE_SYSTEM_NAME}\" STREQUAL \"WindowsStore\")\n\tif (TARGET_HELLO_WORLD)\n\t\tinclude(${PHYSICS_REPO_ROOT}/HelloWorld/HelloWorld.cmake)\n\t\tadd_executable(HelloWorld ${HELLO_WORLD_SRC_FILES})\n\t\ttarget_include_directories(HelloWorld PUBLIC ${HELLO_WORLD_ROOT})\n\t\ttarget_link_libraries(HelloWorld LINK_PUBLIC Jolt)\n\t\tif (MSVC)\n\t\t\ttarget_link_options(HelloWorld PUBLIC \"/SUBSYSTEM:CONSOLE\")\n\t\tendif()\n\t\tif (EMSCRIPTEN)\n\t\t\ttarget_link_options(HelloWorld PUBLIC -sSTACK_SIZE=1048576 -sINITIAL_MEMORY=134217728)\n\t\tendif()\n\tendif()\n\n\tif (TARGET_PERFORMANCE_TEST)\n\t\tinclude(${PHYSICS_REPO_ROOT}/PerformanceTest/PerformanceTest.cmake)\n\t\tadd_executable(PerformanceTest ${PERFORMANCE_TEST_SRC_FILES})\n\t\ttarget_include_directories(PerformanceTest PUBLIC ${PERFORMANCE_TEST_ROOT})\n\t\ttarget_link_libraries(PerformanceTest LINK_PUBLIC Jolt)\n\t\tif (MSVC)\n\t\t\ttarget_link_options(PerformanceTest PUBLIC \"/SUBSYSTEM:CONSOLE\")\n\t\tendif()\n\t\tif (EMSCRIPTEN)\n\t\t\ttarget_link_options(PerformanceTest PUBLIC \"SHELL:--preload-file ${PHYSICS_REPO_ROOT}/Assets/Human.tof@/Assets/Human.tof\")\n\t\t\ttarget_link_options(PerformanceTest PUBLIC \"SHELL:--preload-file ${PHYSICS_REPO_ROOT}/Assets/Human/dead_pose1.tof@/Assets/Human/dead_pose1.tof\")\n\t\t\ttarget_link_options(PerformanceTest PUBLIC \"SHELL:--preload-file ${PHYSICS_REPO_ROOT}/Assets/terrain2.bof@/Assets/terrain2.bof\")\n\t\t\ttarget_link_options(PerformanceTest PUBLIC -sSTACK_SIZE=1048576 -sINITIAL_MEMORY=134217728)\n\t\tendif()\n\t\tset_property(TARGET PerformanceTest PROPERTY VS_DEBUGGER_WORKING_DIRECTORY \"${PHYSICS_REPO_ROOT}\")\n\tendif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring JoltPhysics Unit Tests Project for Android using CMake\nDESCRIPTION: This CMake script sets up the JoltPhysics unit tests project for Android. It includes the Android NDK app glue, sets the repository root, includes necessary CMake files, and configures the shared library for the unit tests. The script also sets up include directories and links required libraries.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/Android/UnitTests/src/main/cpp/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10.2)\n\nproject(\"JoltPhysicsUnitTests\")\n\n# Make sure we include the app glue sources\nset(APP_GLUE_DIR ${ANDROID_NDK}/sources/android/native_app_glue)\ninclude_directories(${APP_GLUE_DIR})\n\n# Set repository root\nset(PHYSICS_REPO_ROOT \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../\")\n\n# Make targets\ninclude(${PHYSICS_REPO_ROOT}/Jolt/Jolt.cmake)\ninclude(${PHYSICS_REPO_ROOT}/UnitTests/UnitTests.cmake)\n\n# Link shared native library\nset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -u ANativeActivity_onCreate\")\nadd_library(UnitTests SHARED ${UNIT_TESTS_SRC_FILES} ${APP_GLUE_DIR}/android_native_app_glue.c)\ntarget_include_directories(UnitTests PUBLIC Jolt ${JOLT_PHYSICS_ROOT} ${UNIT_TESTS_ROOT})\ntarget_link_libraries(UnitTests Jolt android log)\n```\n\n----------------------------------------\n\nTITLE: Generating Doxygen Documentation for Jolt Physics Engine on Windows\nDESCRIPTION: This batch file runs Doxygen to generate documentation for the Jolt Physics Engine on Windows. It requires Doxygen to be installed on the system.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_12\n\nLANGUAGE: batch\nCODE:\n```\nrun_doxygen.bat\n```\n\n----------------------------------------\n\nTITLE: Interprocedural Optimization Setup Function\nDESCRIPTION: Defines a function to enable link-time optimization for Release and Distribution builds if supported by the compiler and platform.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/CMakeLists.txt#2025-04-22_snippet_8\n\nLANGUAGE: cmake\nCODE:\n```\nfunction(SET_INTERPROCEDURAL_OPTIMIZATION)\n\tset(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE OFF PARENT_SCOPE)\n\tset(CMAKE_INTERPROCEDURAL_OPTIMIZATION_DISTRIBUTION OFF PARENT_SCOPE)\n\tif (INTERPROCEDURAL_OPTIMIZATION\n\t\tAND NOT (\"${CMAKE_VS_PLATFORM_NAME}\" STREQUAL \"ARM64\")\n\t\tAND NOT (\"${CMAKE_VS_PLATFORM_NAME}\" STREQUAL \"ARM\")\n\t\tAND (NOT CROSS_COMPILE_ARM OR (\"${CROSS_COMPILE_ARM_TARGET}\" STREQUAL \"aarch64-linux-gnu\"))\n\t\tAND NOT (MINGW AND BUILD_SHARED_LIBS))\n\t\tinclude(CheckIPOSupported)\n\t\tcheck_ipo_supported(RESULT IS_IPO_SUPPORTED OUTPUT IPO_CHECK_OUTPUT)\n\t\tif (IS_IPO_SUPPORTED)\n\t\t\tmessage(\"Interprocedural optimizations are turned on\")\n\t\t\tset(CMAKE_INTERPROCEDURAL_OPTIMIZATION_RELEASE ON PARENT_SCOPE)\n\t\t\tset(CMAKE_INTERPROCEDURAL_OPTIMIZATION_DISTRIBUTION ON PARENT_SCOPE)\n\t\tendif()\n\tendif()\nendfunction()\n```\n\n----------------------------------------\n\nTITLE: Configuring JoltPhysicsPerformanceTest CMake Project for Android\nDESCRIPTION: Configures the JoltPhysicsPerformanceTest CMake project by setting up the Android NDK dependencies, including the Jolt Physics engine sources, and creating a shared library target. The configuration links against Android-specific libraries and incorporates the native app glue for Android integration.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/Android/PerformanceTest/src/main/cpp/CMakeLists.txt#2025-04-22_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.10.2)\n\nproject(\"JoltPhysicsPerformanceTest\")\n\n# Make sure we include the app glue sources\nset(APP_GLUE_DIR ${ANDROID_NDK}/sources/android/native_app_glue)\ninclude_directories(${APP_GLUE_DIR})\n\n# Set repository root\nset(PHYSICS_REPO_ROOT \"${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../\")\n\n# Make targets\ninclude(${PHYSICS_REPO_ROOT}/Jolt/Jolt.cmake)\ninclude(${PHYSICS_REPO_ROOT}/PerformanceTest/PerformanceTest.cmake)\n\n# Link shared native library\nset(CMAKE_SHARED_LINKER_FLAGS \"${CMAKE_SHARED_LINKER_FLAGS} -u ANativeActivity_onCreate\")\nadd_library(PerformanceTest SHARED ${PERFORMANCE_TEST_SRC_FILES} ${APP_GLUE_DIR}/android_native_app_glue.c)\ntarget_include_directories(PerformanceTest PUBLIC Jolt ${JOLT_PHYSICS_ROOT} ${PERFORMANCE_TEST_ROOT})\ntarget_link_libraries(PerformanceTest Jolt android log)\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics on Windows with MSVC Clang\nDESCRIPTION: Steps for building Jolt Physics on Windows using the Clang compiler through Visual Studio 2022. Requires Visual Studio 2022 with Clang components and CMake 3.20+.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_2\n\nLANGUAGE: Batch\nCODE:\n```\ncmake_vs2022_clang.bat\n```\n\n----------------------------------------\n\nTITLE: Building Jolt Physics with Emscripten\nDESCRIPTION: Steps for building Jolt Physics using Emscripten (tested only on Linux). Requires Emscripten, nodejs, and CMake 3.23+.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Build/README.md#2025-04-22_snippet_8\n\nLANGUAGE: Shell\nCODE:\n```\n./cmake_linux_emscripten.sh\n```\n\n----------------------------------------\n\nTITLE: Applying Buoyancy to a Body in C++\nDESCRIPTION: Calculates the submerged volume of a body and applies buoyancy impulse separately, allowing for custom use of the submerged volume.\nSOURCE: https://github.com/jrouwe/joltphysics/blob/master/Docs/ReleaseNotes.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nBody *body = /* ... */;\nfloat submerged_volume = body->GetSubmergedVolume(/* ... */);\n// Custom use of submerged_volume\nbody->ApplyBuoyancyImpulse(/* ... */);\n```"
  }
]