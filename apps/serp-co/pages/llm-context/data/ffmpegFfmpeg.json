[
  {
    "owner": "ffmpeg",
    "repo": "ffmpeg",
    "content": "TITLE: FFmpeg Library Components Documentation\nDESCRIPTION: List of core FFmpeg libraries and their primary functions for multimedia processing. Each library serves a specific purpose in the framework, from codec implementation to audio mixing.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/README.md#2025-04-05_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* `libavcodec` provides implementation of a wider range of codecs.\n* `libavformat` implements streaming protocols, container formats and basic I/O access.\n* `libavutil` includes hashers, decompressors and miscellaneous utility functions.\n* `libavfilter` provides means to alter decoded audio and video through a directed graph of connected filters.\n* `libavdevice` provides an abstraction to access capture and playback devices.\n* `libswresample` implements audio mixing and resampling routines.\n* `libswscale` implements color conversion and scaling routines.\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Tools Documentation\nDESCRIPTION: Description of main FFmpeg command-line tools and utilities, including the primary tools ffmpeg, ffplay, and ffprobe, along with additional utility tools.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/README.md#2025-04-05_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n* [ffmpeg](https://ffmpeg.org/ffmpeg.html) is a command line toolbox to\n  manipulate, convert and stream multimedia content.\n* [ffplay](https://ffmpeg.org/ffplay.html) is a minimalistic multimedia player.\n* [ffprobe](https://ffmpeg.org/ffprobe.html) is a simple analysis tool to inspect\n  multimedia content.\n* Additional small tools such as `aviocat`, `ismindex` and `qt-faststart`.\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Core Data Structure ASCII Diagram\nDESCRIPTION: Detailed ASCII diagram showing the relationships between FFmpeg's main components: InputFile array, InputStream array, OutputFile array, and OutputStream array. The diagram illustrates how stream indexes are mapped between inputs and outputs, and how they connect to AVStream structures.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/ffmpeg.txt#2025-04-05_snippet_0\n\nLANGUAGE: ascii\nCODE:\n```\n                                             ffmpeg.c                                                                                  :       libav*\n                                             ========                                                                                  :       ======\n                                                                                                                                       :\n                                                                                                                                       :\n                                                                                                       --------------------------------:---> AVStream...\n                                                                    InputStream input_streams[]      /                                 :\n                                                                                                    /                                  :\n                    InputFile input_files[]                         +==========================+   /   ^                               :\n                                                          ------> 0 |      : st ---:-----------:--/    :                               :\n                 ^  +------+-----------+-----+          /           +--------------------------+       :                               :\n                 :  |      :ist_index--:-----:---------/          1 |      : st    :           |       :                               :\n                 :  +------+-----------+-----+                      +==========================+       :                               :\n nb_input_files  :  |      :ist_index--:-----:------------------> 2 |      : st    :           |       :                               :\n                 :  +------+-----------+-----+                      +--------------------------+       :  nb_input_streams             :\n                 :  |      :ist_index  :     |                    3 |            ...           |       :                               :\n                 v  +------+-----------+-----+                      +--------------------------+       :                               :\n                                                              --> 4 |                          |       :                               :\n                                                             |      +--------------------------+       :                               :\n                                                             |    5 |                          |       :                               :\n                                                             |      +==========================+       v                               :\n                                                             |                                                                         :\n                                                             |                                                                         :\n                                                             |                                                                         :\n                                                             |                                                                         :\n                                                              ---------                                --------------------------------:---> AVStream...\n                                                                        \\                            /                                 :\n                                                                    OutputStream output_streams[]   /                                  :\n                                                                          \\                        /                                   :\n                                                                    +======\\======================/======+      ^                      :\n                                                          ------> 0 |   : source_index  : st-:---        |      :                      :\n                    OutputFile output_files[]           /           +------------------------------------+      :                      :\n                                                       /          1 |   :               :    :           |      :                      :\n                 ^  +------+------------+-----+       /             +------------------------------------+      :                      :\n                 :  |      : ost_index -:-----:------/            2 |   :               :    :           |      :                      :\n nb_output_files :  +------+------------+-----+                     +====================================+      :                      :\n                 :  |      : ost_index -:-----|-----------------> 3 |   :               :    :           |      :                      :\n                 :  +------+------------+-----+                     +------------------------------------+      : nb_output_streams    :\n                 :  |      :            :     |                   4 |                                    |      :                      :\n                 :  +------+------------+-----+                     +------------------------------------+      :                      :\n                 :  |      :            :     |                   5 |                                    |      :                      :\n                 v  +------+------------+-----+                     +------------------------------------+      :                      :\n                                                                  6 |                                    |      :                      :\n                                                                    +------------------------------------+      :                      :\n                                                                  7 |                                    |      :                      :\n                                                                    +====================================+      v                      :\n```\n\n----------------------------------------\n\nTITLE: Implementing request_frame Method in FFmpeg Filter\nDESCRIPTION: Example implementation of a request_frame method for FFmpeg filters with multiple inputs. Shows how to handle queued frames, request new frames from inputs, and process EOF conditions. Returns 0 for success, AVERROR(EAGAIN) for temporary failures, or AVERROR_EOF when no more frames are available.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/filter_design.txt#2025-04-05_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nif (frames_queued) {\n    push_one_frame();\n    return a0;\n}\ninput = input_where_a_frame_is_most_needed();\nret = ff_request_frame(input);\nif (ret == AVERROR_EOF) {\n    process_eof_on_input();\n} else if (ret < 0) {\n    return ret;\n}\nreturn 0;\n```\n\n----------------------------------------\n\nTITLE: Implementing activate() callback for FFmpeg filters\nDESCRIPTION: Example implementation of the activate() callback that handles frame scheduling in FFmpeg filters. This pattern checks output link status, processes available input frames, acknowledges status changes, and manages frame requests between filter links.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/filter_design.txt#2025-04-05_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nret = ff_outlink_get_status(outlink);\nif (ret) {\n    ff_inlink_set_status(inlink, ret);\n    return 0;\n}\nif (priv->next_frame) {\n    /* use it */\n    return 0;\n}\nret = ff_inlink_consume_frame(inlink, &frame);\nif (ret < 0)\n    return ret;\nif (ret) {\n    /* use it */\n    return 0;\n}\nret = ff_inlink_acknowledge_status(inlink, &status, &pts);\nif (ret) {\n    /* flush */\n    ff_outlink_set_status(outlink, status, pts);\n    return 0;\n}\nif (ff_outlink_frame_wanted(outlink)) {\n    ff_inlink_request_frame(inlink);\n    return 0;\n}\nreturn FFERROR_NOT_READY;\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Filter Status Forwarding Macros\nDESCRIPTION: Macros used to simplify common status forwarding operations in FFmpeg filters. These macros handle state propagation between input and output links, reducing the amount of boilerplate code needed in the activate() callback.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/filter_design.txt#2025-04-05_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nFF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\nFF_FILTER_FORWARD_STATUS_ALL(outlink, filter);\nFF_FILTER_FORWARD_STATUS(inlink, outlink);\nFF_FILTER_FORWARD_STATUS_ALL(inlink, filter);\nFF_FILTER_FORWARD_WANTED(outlink, inlink);\n```\n\n----------------------------------------\n\nTITLE: ASCII Diagram of SWScale Architecture\nDESCRIPTION: Visual representation of the SWScale processing pipeline showing the flow from input through special converter and main path options to output.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/swscale.txt#2025-04-05_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n                        Input\n                          v\n                   _______OR_________\n                 /                   \\\n               /                       \\\n       special converter     [Input to YUV converter]\n              |                         |\n              |         (8-bit YUV 4:4:4 / 4:2:2 / 4:2:0 / 4:0:0 )\n              |                         |\n              |                         v\n              |                  Horizontal scaler\n              |                         |\n              |     (15-bit YUV 4:4:4 / 4:2:2 / 4:2:0 / 4:1:1 / 4:0:0 )\n              |                         |\n              |                         v\n              |          Vertical scaler and output converter\n              |                         |\n              v                         v\n                         output\n```\n\n----------------------------------------\n\nTITLE: Slice Threading Implementation in Video Filters\nDESCRIPTION: Code examples showing how to implement slice-based threading in a filter. This pattern allows processing different portions of a frame in parallel for better performance on multi-core systems.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_8\n\nLANGUAGE: c\nCODE:\n```\ndst = out->data[0];\nsrc = in ->data[0];\n\nfor (y = 0; y < inlink->h; y++) {\n    for (x = 0; x < inlink->w; x++)\n        dst[x] = foobar(src[x]);\n    dst += out->linesize[0];\n    src += in ->linesize[0];\n}\n```\n\nLANGUAGE: c\nCODE:\n```\nfor (y = slice_start; y < slice_end; y++) {\n    for (x = 0; x < inlink->w; x++)\n        dst[x] = foobar(src[x]);\n    dst += out->linesize[0];\n    src += in ->linesize[0];\n}\n```\n\nLANGUAGE: c\nCODE:\n```\nconst int slice_start = (in->height *  jobnr   ) / nb_jobs;\nconst int slice_end   = (in->height * (jobnr+1)) / nb_jobs;\nuint8_t       *dst = out->data[0] + slice_start * out->linesize[0];\nconst uint8_t *src =  in->data[0] + slice_start *  in->linesize[0];\n```\n\nLANGUAGE: c\nCODE:\n```\nstatic int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs) { ... }\n```\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct ThreadData {\n    AVFrame *in, *out;\n} ThreadData;\n```\n\nLANGUAGE: c\nCODE:\n```\nconst ThreadData *td = arg;\n```\n\nLANGUAGE: c\nCODE:\n```\nThreadData td;\n\n// ...\n\ntd.in  = in;\ntd.out = out;\nctx->internal->execute(ctx, filter_slice, &td, NULL, FFMIN(outlink->h, ff_filter_get_nb_threads(ctx)));\n\n// ...\n\nreturn ff_filter_frame(outlink, out);\n```\n\n----------------------------------------\n\nTITLE: Implementing Frame Processing in C\nDESCRIPTION: Basic structure of the filter_frame function for processing video frames.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstatic int filter_frame(AVFilterLink *inlink, AVFrame *in) {\n    AVFilterContext *ctx = inlink->dst;\n    FoobarContext *foobar = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    // Frame processing logic\n    return ff_filter_frame(outlink, in);\n}\n```\n\n----------------------------------------\n\nTITLE: Allocating Output Frame in C\nDESCRIPTION: Code snippet for allocating a new output frame for filters that can't process in-place.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nAVFrame *out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\nif (!out) {\n    // Handle allocation failure\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Frames by Creating a New Output Frame\nDESCRIPTION: Code snippet showing how to process frames by allocating a new output frame rather than modifying the input frame directly. This pattern is useful when in-place processing isn't possible or desired.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nav_frame_free(&in);\nreturn AVERROR(ENOMEM);\n}\nav_frame_copy_props(out, in);\n\n// out->data[...] = foobar(in->data[...])\n\nav_frame_free(&in);\nreturn ff_filter_frame(outlink, out);\n```\n\n----------------------------------------\n\nTITLE: In-place Frame Processing with av_frame_make_writable\nDESCRIPTION: Demonstrates how to perform in-place processing by making the input frame writable before modifying it. This approach avoids unnecessary memory allocation when possible.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nav_frame_make_writable(in);\n// in->data[...] = foobar(in->data[...])\nreturn ff_filter_frame(outlink, in);\n```\n\n----------------------------------------\n\nTITLE: Optimized Frame Processing with Conditional In-place Operation\nDESCRIPTION: Pattern for efficient frame processing that checks if the input frame is writable first, avoiding unnecessary memory copies. This approach provides a balance between performance and correctness.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_7\n\nLANGUAGE: c\nCODE:\n```\nint direct = 0;\nAVFrame *out;\n\nif (av_frame_is_writable(in)) {\n    direct = 1;\n    out = in;\n} else {\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&in);\n        return AVERROR(ENOMEM);\n    }\n    av_frame_copy_props(out, in);\n}\n\n// out->data[...] = foobar(in->data[...])\n\nif (!direct)\n    av_frame_free(&in);\nreturn ff_filter_frame(outlink, out);\n```\n\n----------------------------------------\n\nTITLE: Calling ff_thread_finish_setup in Frame Threading Implementation\nDESCRIPTION: After moving context variable modifications and get_buffer() calls before the decode process, call ff_thread_finish_setup(). This function is part of the frame threading setup process in FFmpeg.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/multithreading.txt#2025-04-05_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nff_thread_finish_setup()\n```\n\n----------------------------------------\n\nTITLE: Using ff_thread_get_buffer for Frame Buffer Allocation in FFmpeg\nDESCRIPTION: When implementing frame threading, use ff_thread_get_buffer() to allocate frame buffers. For inter-frame dependencies using the ProgressFrame API, use ff_progress_frame_get_buffer() instead.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/multithreading.txt#2025-04-05_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nff_thread_get_buffer()\nff_progress_frame_get_buffer()\n```\n\n----------------------------------------\n\nTITLE: Reporting Frame Progress in FFmpeg Multithreading\nDESCRIPTION: Call ff_progress_frame_report() after a part of the current picture has been decoded. This function is typically called where draw_horiz_band() is invoked, and should be added if not present.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/multithreading.txt#2025-04-05_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nff_progress_frame_report()\n```\n\n----------------------------------------\n\nTITLE: Awaiting Frame Progress in FFmpeg Multithreading\nDESCRIPTION: Before accessing a reference frame or its MVs in frame threading, call ff_progress_frame_await(). This ensures that the required parts of the reference frame have been decoded.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/multithreading.txt#2025-04-05_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nff_progress_frame_await()\n```\n\n----------------------------------------\n\nTITLE: Using Assembly Loops in Optimization\nDESCRIPTION: Example showing the proper way to structure assembly loops in FFmpeg code. It demonstrates the recommended approach with direct assembly loops rather than C loops containing assembly code.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/optimization.txt#2025-04-05_snippet_0\n\nLANGUAGE: Assembly\nCODE:\n```\n__asm__(\n    \"1: ....\n    ...\n    \"jump_instruction ....\n```\n\n----------------------------------------\n\nTITLE: Declaring Clobbered Registers in Inline Assembly\nDESCRIPTION: Example showing how to properly declare clobbered registers in inline assembly code. This is particularly important for x86 architecture and Win64 compatibility.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/optimization.txt#2025-04-05_snippet_2\n\nLANGUAGE: C\nCODE:\n```\n__asm__(\"..\", ::: \"%eax\")\n```\n\n----------------------------------------\n\nTITLE: Using XMM_CLOBBERS Macro with Other Clobbers\nDESCRIPTION: Example showing how to use the XMM_CLOBBERS macro when there are other registers being clobbered. This approach handles compatibility with various compiler settings.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/optimization.txt#2025-04-05_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n__asm__(\"..\", ::: XMM_CLOBBERS(\"xmm0\",) \"eax\")\n```\n\n----------------------------------------\n\nTITLE: Using XMM_CLOBBERS_ONLY Macro\nDESCRIPTION: Example showing how to use the XMM_CLOBBERS_ONLY macro when only XMM registers are being clobbered in the assembly code.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/optimization.txt#2025-04-05_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n__asm__(\"..\", :: XMM_CLOBBERS_ONLY(\"xmm0\"))\n```\n\n----------------------------------------\n\nTITLE: Incorrect C Loop with Assembly\nDESCRIPTION: Example showing the discouraged practice of using C loops containing assembly code. This pattern should be avoided in FFmpeg optimizations.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/optimization.txt#2025-04-05_snippet_1\n\nLANGUAGE: C\nCODE:\n```\ndo{\n    __asm__(\n        ...\n}while()\n```\n\n----------------------------------------\n\nTITLE: Incorrect Register Preservation Between Assembly Blocks\nDESCRIPTION: Example showing incorrect code that assumes registers maintain values between separate assembly blocks. This approach should be avoided as it can lead to unpredictable behavior.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/optimization.txt#2025-04-05_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n__asm__(\"movdqa %0, %%xmm7\", : src);\n/* do something */\n__asm__(\"movdqa %%xmm7, %1\", : dst)\n```\n\n----------------------------------------\n\nTITLE: Generating Split-Radix Parity Reversal Table in C\nDESCRIPTION: Function to generate a parity-based permutation table for FFT transforms. It supports dual-stride operations for optimized performance on vector architectures.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid ff_tx_gen_split_radix_parity_revtab(int *revtab, int len, int inv,\n                                         int basis, int dual_stride);\n```\n\n----------------------------------------\n\nTITLE: Implementing 4-point FFT Transform in C\nDESCRIPTION: A 4-point FFT transform implementation in C. This function performs the transform in-place on an array of complex numbers, with optimizations for minimal operations.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nstatic void fft4(FFTComplex *z)\n{\n    FFTSample r1 = z[0].re - z[2].re;\n    FFTSample r2 = z[0].im - z[2].im;\n    FFTSample r3 = z[1].re - z[3].re;\n    FFTSample r4 = z[1].im - z[3].im;\n    /* r5-r8 second transform */\n\n    FFTSample t1 = z[0].re + z[2].re;\n    FFTSample t2 = z[0].im + z[2].im;\n    FFTSample t3 = z[1].re + z[3].re;\n    FFTSample t4 = z[1].im + z[3].im;\n    /* t5-t8 second transform */\n\n    /* 1sub + 1add = 2 instructions */\n\n    /* 2 shufs */\n    FFTSample a3 = t1 - t3;\n    FFTSample a4 = t2 - t4;\n    FFTSample b3 = r1 - r4;\n    FFTSample b2 = r2 - r3;\n\n    FFTSample a1 = t1 + t3;\n    FFTSample a2 = t2 + t4;\n    FFTSample b1 = r1 + r4;\n    FFTSample b4 = r2 + r3;\n    /* 1 add 1 sub 3 shufs */\n\n    z[0].re = a1;\n    z[0].im = a2;\n    z[2].re = a3;\n    z[2].im = a4;\n\n    z[1].re = b1;\n    z[1].im = b2;\n    z[3].re = b3;\n    z[3].im = b4;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 8-point AVX FFT Transform in C\nDESCRIPTION: An 8-point FFT transform implementation optimized for AVX architecture. The input must be pre-permuted using a parity lookup table. This function performs the transform in-place on an array of complex numbers.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nstatic void fft8(FFTComplex *z)\n{\n    FFTSample r1 = z[0].re - z[4].re;\n    FFTSample r2 = z[0].im - z[4].im;\n    FFTSample r3 = z[1].re - z[5].re;\n    FFTSample r4 = z[1].im - z[5].im;\n\n    FFTSample r5 = z[2].re - z[6].re;\n    FFTSample r6 = z[2].im - z[6].im;\n    FFTSample r7 = z[3].re - z[7].re;\n    FFTSample r8 = z[3].im - z[7].im;\n\n    FFTSample q1 = z[0].re + z[4].re;\n    FFTSample q2 = z[0].im + z[4].im;\n    FFTSample q3 = z[1].re + z[5].re;\n    FFTSample q4 = z[1].im + z[5].im;\n\n    FFTSample q5 = z[2].re + z[6].re;\n    FFTSample q6 = z[2].im + z[6].im;\n    FFTSample q7 = z[3].re + z[7].re;\n    FFTSample q8 = z[3].im + z[7].im;\n\n    FFTSample s3 = q1 - q3;\n    FFTSample s1 = q1 + q3;\n    FFTSample s4 = q2 - q4;\n    FFTSample s2 = q2 + q4;\n\n    FFTSample s7 = q5 - q7;\n    FFTSample s5 = q5 + q7;\n    FFTSample s8 = q6 - q8;\n    FFTSample s6 = q6 + q8;\n\n    FFTSample e1 = s1 * -1;\n    FFTSample e2 = s2 * -1;\n    FFTSample e3 = s3 * -1;\n    FFTSample e4 = s4 * -1;\n\n    FFTSample e5 = s5 *  1;\n    FFTSample e6 = s6 *  1;\n    FFTSample e7 = s7 * -1;\n    FFTSample e8 = s8 *  1;\n\n    FFTSample w1 =  e5 - e1;\n    FFTSample w2 =  e6 - e2;\n    FFTSample w3 =  e8 - e3;\n    FFTSample w4 =  e7 - e4;\n\n    FFTSample w5 =  s1 - e5;\n    FFTSample w6 =  s2 - e6;\n    FFTSample w7 =  s3 - e8;\n    FFTSample w8 =  s4 - e7;\n\n    z[0].re = w1;\n    z[0].im = w2;\n    z[2].re = w3;\n    z[2].im = w4;\n    z[4].re = w5;\n    z[4].im = w6;\n    z[6].re = w7;\n    z[6].im = w8;\n\n    FFTSample z1 = r1 - r4;\n    FFTSample z2 = r1 + r4;\n    FFTSample z3 = r3 - r2;\n    FFTSample z4 = r3 + r2;\n\n    FFTSample z5 = r5 - r6;\n    FFTSample z6 = r5 + r6;\n    FFTSample z7 = r7 - r8;\n    FFTSample z8 = r7 + r8;\n\n    z3 *= -1;\n    z5 *= -M_SQRT1_2;\n    z6 *= -M_SQRT1_2;\n    z7 *=  M_SQRT1_2;\n    z8 *=  M_SQRT1_2;\n\n    FFTSample t5 = z7 - z6;\n    FFTSample t6 = z8 + z5;\n    FFTSample t7 = z8 - z5;\n    FFTSample t8 = z7 + z6;\n\n    FFTSample u1 =  z2 + t5;\n    FFTSample u2 =  z3 + t6;\n    FFTSample u3 =  z1 - t7;\n    FFTSample u4 =  z4 + t8;\n\n    FFTSample u5 =  z2 - t5;\n    FFTSample u6 =  z3 - t6;\n    FFTSample u7 =  z1 + t7;\n    FFTSample u8 =  z4 - t8;\n\n    z[1].re = u1;\n    z[1].im = u2;\n    z[3].re = u3;\n    z[3].im = u4;\n    z[5].re = u5;\n    z[5].im = u6;\n    z[7].re = u7;\n    z[7].im = u8;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 8-point SSE/ARM64 FFT Transform in C\nDESCRIPTION: An 8-point FFT transform implementation optimized for SSE and ARM64 architectures. The input must be pre-permuted using a parity lookup table. This function performs the transform in-place on an array of complex numbers.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstatic void fft8(FFTComplex *z)\n{\n    FFTSample r1 = z[0].re - z[4].re;\n    FFTSample r2 = z[0].im - z[4].im;\n    FFTSample r3 = z[1].re - z[5].re;\n    FFTSample r4 = z[1].im - z[5].im;\n\n    FFTSample j1 = z[2].re - z[6].re;\n    FFTSample j2 = z[2].im - z[6].im;\n    FFTSample j3 = z[3].re - z[7].re;\n    FFTSample j4 = z[3].im - z[7].im;\n\n    FFTSample q1 = z[0].re + z[4].re;\n    FFTSample q2 = z[0].im + z[4].im;\n    FFTSample q3 = z[1].re + z[5].re;\n    FFTSample q4 = z[1].im + z[5].im;\n\n    FFTSample k1 = z[2].re + z[6].re;\n    FFTSample k2 = z[2].im + z[6].im;\n    FFTSample k3 = z[3].re + z[7].re;\n    FFTSample k4 = z[3].im + z[7].im;\n    /* 2 add 2 sub = 4 */\n\n    /* 2 shufs, 1 add 1 sub = 4 */\n    FFTSample s1 = q1 + q3;\n    FFTSample s2 = q2 + q4;\n    FFTSample g1 = k3 + k1;\n    FFTSample g2 = k2 + k4;\n\n    FFTSample s3 = q1 - q3;\n    FFTSample s4 = q2 - q4;\n    FFTSample g4 = k3 - k1;\n    FFTSample g3 = k2 - k4;\n\n    /* 1 unpack + 1 shuffle = 2 */\n\n    /* 1 add */\n    FFTSample w1 =  s1 + g1;\n    FFTSample w2 =  s2 + g2;\n    FFTSample w3 =  s3 + g3;\n    FFTSample w4 =  s4 + g4;\n\n    /* 1 sub */\n    FFTSample h1 =  s1 - g1;\n    FFTSample h2 =  s2 - g2;\n    FFTSample h3 =  s3 - g3;\n    FFTSample h4 =  s4 - g4;\n\n    z[0].re = w1;\n    z[0].im = w2;\n    z[2].re = w3;\n    z[2].im = w4;\n    z[4].re = h1;\n    z[4].im = h2;\n    z[6].re = h3;\n    z[6].im = h4;\n\n    /* 1 shuf + 1 shuf + 1 xor + 1 addsub */\n    FFTSample z1 = r1 + r4;\n    FFTSample z2 = r2 - r3;\n    FFTSample z3 = r1 - r4;\n    FFTSample z4 = r2 + r3;\n\n    /* 1 mult */\n    j1 *=  M_SQRT1_2;\n    j2 *= -M_SQRT1_2;\n    j3 *= -M_SQRT1_2;\n    j4 *=  M_SQRT1_2;\n\n    /* 1 shuf + 1 addsub */\n    FFTSample l2 = j1 - j2;\n    FFTSample l1 = j2 + j1;\n    FFTSample l4 = j3 - j4;\n    FFTSample l3 = j4 + j3;\n\n    /* 1 shuf + 1 addsub */\n    FFTSample t1 = l3 - l2;\n    FFTSample t2 = l4 + l1;\n    FFTSample t3 = l1 - l4;\n    FFTSample t4 = l2 + l3;\n\n    /* 1 add */\n    FFTSample u1 =  z1 - t1;\n    FFTSample u2 =  z2 - t2;\n    FFTSample u3 =  z3 - t3;\n    FFTSample u4 =  z4 - t4;\n\n    /* 1 sub */\n    FFTSample o1 =  z1 + t1;\n    FFTSample o2 =  z2 + t2;\n    FFTSample o3 =  z3 + t3;\n    FFTSample o4 =  z4 + t4;\n\n    z[1].re = u1;\n    z[1].im = u2;\n    z[3].re = u3;\n    z[3].im = u4;\n    z[5].re = o1;\n    z[5].im = o2;\n    z[7].re = o3;\n    z[7].im = o4;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 16-point FFT Transform with AVX Optimization\nDESCRIPTION: A C function that performs a 16-point FFT transform on complex numbers. The implementation expects 8 and 4-point transform outputs to follow even/odd conventions and includes AVX-specific optimizations through careful arrangement of operations. Uses cosine values and complex number arithmetic for the transform calculations.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nstatic void fft16(FFTComplex *z)\n{\n    FFTSample cos_16_1 = 0.92387950420379638671875f;\n    FFTSample cos_16_3 = 0.3826834261417388916015625f;\n\n    fft8(z);\n    fft4(z+8);\n    fft4(z+10);\n\n    FFTSample s[32];\n\n    /*\n        xorps m1, m1 - free\n        mulps m0\n        shufps m1, m1, m0\n        xorps\n        addsub\n        shufps\n        mulps\n        mulps\n        addps\n        or (fma3)\n        shufps\n        shufps\n        mulps\n        mulps\n        fma\n        fma\n     */\n\n    s[0]  =  z[8].re*( 1) - z[8].im*( 0);\n    s[1]  =  z[8].im*( 1) + z[8].re*( 0);\n    s[2]  =  z[9].re*( 1) - z[9].im*(-1);\n    s[3]  =  z[9].im*( 1) + z[9].re*(-1);\n\n    s[4]  = z[10].re*( 1) - z[10].im*( 0);\n    s[5]  = z[10].im*( 1) + z[10].re*( 0);\n    s[6]  = z[11].re*( 1) - z[11].im*( 1);\n    s[7]  = z[11].im*( 1) + z[11].re*( 1);\n\n    s[8]  = z[12].re*(  cos_16_1) - z[12].im*( -cos_16_3);\n    s[9]  = z[12].im*(  cos_16_1) + z[12].re*( -cos_16_3);\n    s[10] = z[13].re*(  cos_16_3) - z[13].im*( -cos_16_1);\n    s[11] = z[13].im*(  cos_16_3) + z[13].re*( -cos_16_1);\n\n    s[12] = z[14].re*(  cos_16_1) - z[14].im*(  cos_16_3);\n    s[13] = z[14].im*( -cos_16_1) + z[14].re*( -cos_16_3);\n    s[14] = z[15].re*(  cos_16_3) - z[15].im*(  cos_16_1);\n    s[15] = z[15].im*( -cos_16_3) + z[15].re*( -cos_16_1);\n\n    s[2] *=  M_SQRT1_2;\n    s[3] *=  M_SQRT1_2;\n    s[5] *= -1;\n    s[6] *=  M_SQRT1_2;\n    s[7] *= -M_SQRT1_2;\n\n    FFTSample w5 =  s[0] + s[4];\n    FFTSample w6 =  s[1] - s[5];\n    FFTSample x5 =  s[2] + s[6];\n    FFTSample x6 =  s[3] - s[7];\n\n    FFTSample w3 =  s[4] - s[0];\n    FFTSample w4 =  s[5] + s[1];\n    FFTSample x3 =  s[6] - s[2];\n    FFTSample x4 =  s[7] + s[3];\n\n    FFTSample y5 =  s[8] + s[12];\n    FFTSample y6 =  s[9] - s[13];\n    FFTSample u5 = s[10] + s[14];\n    FFTSample u6 = s[11] - s[15];\n\n    FFTSample y3 = s[12] - s[8];\n    FFTSample y4 = s[13] + s[9];\n    FFTSample u3 = s[14] - s[10];\n    FFTSample u4 = s[15] + s[11];\n\n    /* 2xorps, 2vperm2fs, 2 adds, 2 vpermilps = 8 */\n\n    FFTSample o1  = z[0].re + w5;\n    FFTSample o2  = z[0].im + w6;\n    FFTSample o5  = z[1].re + x5;\n    FFTSample o6  = z[1].im + x6;\n    FFTSample o9  = z[2].re + w4; //h\n    FFTSample o10 = z[2].im + w3;\n    FFTSample o13 = z[3].re + x4;\n    FFTSample o14 = z[3].im + x3;\n\n    FFTSample o17 = z[0].re - w5;\n    FFTSample o18 = z[0].im - w6;\n    FFTSample o21 = z[1].re - x5;\n    FFTSample o22 = z[1].im - x6;\n    FFTSample o25 = z[2].re - w4; //h\n    FFTSample o26 = z[2].im - w3;\n    FFTSample o29 = z[3].re - x4;\n    FFTSample o30 = z[3].im - x3;\n\n    FFTSample o3  = z[4].re + y5;\n    FFTSample o4  = z[4].im + y6;\n    FFTSample o7  = z[5].re + u5;\n    FFTSample o8  = z[5].im + u6;\n    FFTSample o11 = z[6].re + y4; //h\n    FFTSample o12 = z[6].im + y3;\n    FFTSample o15 = z[7].re + u4;\n    FFTSample o16 = z[7].im + u3;\n\n    FFTSample o19 = z[4].re - y5;\n    FFTSample o20 = z[4].im - y6;\n    FFTSample o23 = z[5].re - u5;\n    FFTSample o24 = z[5].im - u6;\n    FFTSample o27 = z[6].re - y4; //h\n    FFTSample o28 = z[6].im - y3;\n    FFTSample o31 = z[7].re - u4;\n    FFTSample o32 = z[7].im - u3;\n\n    /* This is just deinterleaving, happens separately */\n    z[0]  = (FFTComplex){  o1,  o2 };\n    z[1]  = (FFTComplex){  o3,  o4 };\n    z[2]  = (FFTComplex){  o5,  o6 };\n    z[3]  = (FFTComplex){  o7,  o8 };\n    z[4]  = (FFTComplex){  o9, o10 };\n    z[5]  = (FFTComplex){ o11, o12 };\n    z[6]  = (FFTComplex){ o13, o14 };\n    z[7]  = (FFTComplex){ o15, o16 };\n\n    z[8]  = (FFTComplex){ o17, o18 };\n    z[9]  = (FFTComplex){ o19, o20 };\n    z[10] = (FFTComplex){ o21, o22 };\n    z[11] = (FFTComplex){ o23, o24 };\n    z[12] = (FFTComplex){ o25, o26 };\n    z[13] = (FFTComplex){ o27, o28 };\n    z[14] = (FFTComplex){ o29, o30 };\n    z[15] = (FFTComplex){ o31, o32 };\n}\n```\n\n----------------------------------------\n\nTITLE: FFT Butterfly and Transform Macros in C\nDESCRIPTION: Core macro definitions for FFT operations including butterfly operations (BF), butterfly chains (BUTTERFLIES), complex multiplication (CMUL), and transform operations (TRANSFORM).\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_5\n\nLANGUAGE: C\nCODE:\n```\n#define BF(x, y, a, b) \\\n    do { \\\n        x = (a) - (b); \\\n        y = (a) + (b); \\\n    } while (0)\n\n#define BUTTERFLIES(a0,a1,a2,a3) \\\n    do { \\\n        r0=a0.re; \\\n        i0=a0.im; \\\n        r1=a1.re; \\\n        i1=a1.im; \\\n        BF(q3, q5, q5, q1); \\\n        BF(a2.re, a0.re, r0, q5); \\\n        BF(a3.im, a1.im, i1, q3); \\\n        BF(q4, q6, q2, q6); \\\n        BF(a3.re, a1.re, r1, q4); \\\n        BF(a2.im, a0.im, i0, q6); \\\n    } while (0)\n\n#undef TRANSFORM\n#define TRANSFORM(a0,a1,a2,a3,wre,wim) \\\n    do { \\\n        CMUL(q1, q2, a2.re, a2.im, wre, -wim); \\\n        CMUL(q5, q6, a3.re, a3.im, wre,  wim); \\\n        BUTTERFLIES(a0, a1, a2, a3); \\\n    } while (0)\n\n#define CMUL(dre, dim, are, aim, bre, bim) \\\n    do { \\\n        (dre) = (are) * (bre) - (aim) * (bim); \\\n        (dim) = (are) * (bim) + (aim) * (bre); \\\n    } while (0)\n```\n\n----------------------------------------\n\nTITLE: FFT Recombine Function Implementation\nDESCRIPTION: Main recombine function that implements the AVX-optimized split-radix FFT synthesis. Handles complex number operations and transforms using predefined macros and optimized memory access patterns.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_6\n\nLANGUAGE: C\nCODE:\n```\nstatic void recombine(FFTComplex *z, const FFTSample *cos, unsigned int n) {\n    const int o1 = 2*n;\n    const int o2 = 4*n;\n    const int o3 = 6*n;\n    const FFTSample *wim = cos + o1 - 7;\n    FFTSample q1, q2, q3, q4, q5, q6, r0, i0, r1, i1;\n    FFTSample h[8], j[8], r[8], w[8];\n    FFTSample t[8];\n    FFTComplex *m0 = &z[0];\n    FFTComplex *m1 = &z[4];\n    FFTComplex *m2 = &z[o2 + 0];\n    FFTComplex *m3 = &z[o2 + 4];\n    const FFTSample *t1  = &cos[0];\n    const FFTSample *t2  = &wim[0];\n    /* Rest of the implementation... */\n}\n```\n\n----------------------------------------\n\nTITLE: Input Permutation for 15-point FFT\nDESCRIPTION: Performs initial permutation of input data to separate AC from DC components. The algorithm reorders elements in groups of 3 and includes specific memory moves to optimize for subsequent transform operations.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_7\n\nLANGUAGE: C\nCODE:\n```\n    for (int k = 0; k < s->sub[0].len; k++) {\n        int cnt = 0;\n        int tmp[15];\n        memcpy(tmp, &s->map[k*15], 15*sizeof(*tmp));\n        for (int i = 1; i < 15; i += 3) {\n            s->map[k*15 + cnt] = tmp[i];\n            cnt++;\n        }\n        for (int i = 2; i < 15; i += 3) {\n            s->map[k*15 + cnt] = tmp[i];\n            cnt++;\n        }\n        for (int i = 0; i < 15; i += 3) {\n            s->map[k*15 + cnt] = tmp[i];\n            cnt++;\n        }\n        memmove(&s->map[k*15 + 7], &s->map[k*15 + 6], 4*sizeof(int));\n        memmove(&s->map[k*15 + 3], &s->map[k*15 + 1], 4*sizeof(int));\n        s->map[k*15 + 1] = tmp[2];\n        s->map[k*15 + 2] = tmp[0];\n    }\n```\n\n----------------------------------------\n\nTITLE: 15-point FFT Core Transform Implementation\nDESCRIPTION: Implements the main FFT algorithm that processes complex numbers using DC and AC components. The function performs the actual transform calculations including complex multiplication, addition, and phase rotations using pre-computed coefficients.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_8\n\nLANGUAGE: C\nCODE:\n```\nstatic av_always_inline void fft15(TXComplex *out, TXComplex *in,\n                                   ptrdiff_t stride)\n{\n    const TXSample *tab = TX_TAB(ff_tx_tab_53);\n    TXComplex q[20];\n    TXComplex dc[3], pc[32];\n    TXComplex y[32], k[32];\n    TXComplex t[32];\n    TXComplex r[32];\n    TXComplex z0[32];\n\n    /* DC */\n    pc[0].re = in[ 1].im - in[ 0].im;\n    pc[0].im = in[ 1].re - in[ 0].re;\n    pc[1].re = in[ 1].re + in[ 0].re;\n    pc[1].im = in[ 1].im + in[ 0].im;\n\n    dc[0].re = in[2].re + pc[1].re;\n    dc[0].im = in[2].im + pc[1].im;\n\n    pc[0].re = tab[ 8] * pc[0].re;\n    pc[0].im = tab[ 9] * pc[0].im;\n    pc[1].re = tab[10] * pc[1].re;\n    pc[1].im = tab[11] * pc[1].im;\n\n    dc[1].re = pc[0].re + pc[1].re;\n    dc[1].im = pc[0].im + pc[1].im;\n    dc[2].re = pc[1].re - pc[0].re;\n    dc[2].im = pc[1].im - pc[0].im;\n\n    dc[1].re = in[2].re - dc[1].re;\n    dc[1].im = in[2].im + dc[1].im;\n    dc[2].re = in[2].re - dc[2].re;\n    dc[2].im = in[2].im + dc[2].im;\n\n    /* ACs */\n    q[0].im = in[ 3].re - in[ 7].re; // NOTE THE ORDER\n    q[0].re = in[ 3].im - in[ 7].im;\n    q[1].im = in[ 4].re - in[ 8].re;\n    q[1].re = in[ 4].im - in[ 8].im;\n    q[2].im = in[ 5].re - in[ 9].re;\n    q[2].re = in[ 5].im - in[ 9].im;\n    q[3].re = in[ 6].im - in[10].im;\n    q[3].im = in[ 6].re - in[10].re;\n\n    q[4].re = in[ 3].re + in[ 7].re;\n    q[4].im = in[ 3].im + in[ 7].im;\n    q[5].re = in[ 4].re + in[ 8].re;\n    q[5].im = in[ 4].im + in[ 8].im;\n    q[6].re = in[ 5].re + in[ 9].re;\n    q[6].im = in[ 5].im + in[ 9].im;\n    q[7].re = in[ 6].re + in[10].re;\n    q[7].im = in[ 6].im + in[10].im;\n\n    y[0].re = in[11].re + q[4].re;\n    y[0].im = in[11].im + q[4].im;\n    y[1].re = in[12].re + q[5].re;\n    y[1].im = in[12].im + q[5].im;\n    y[2].re = in[13].re + q[6].re;\n    y[2].im = in[13].im + q[6].im;\n    y[3].re = in[14].re + q[7].re;\n    y[3].im = in[14].im + q[7].im;\n\n    q[0].re = tab[ 8] * q[0].re;\n    q[0].im = tab[ 9] * q[0].im;\n    q[1].re = tab[ 8] * q[1].re;\n    q[1].im = tab[ 9] * q[1].im;\n    q[2].re = tab[ 8] * q[2].re;\n    q[2].im = tab[ 9] * q[2].im;\n    q[3].re = tab[ 8] * q[3].re;\n    q[3].im = tab[ 9] * q[3].im;\n\n    q[4].re = tab[10] * q[4].re;\n    q[4].im = tab[11] * q[4].im;\n    q[5].re = tab[10] * q[5].re;\n    q[5].im = tab[11] * q[5].im;\n    q[6].re = tab[10] * q[6].re;\n    q[6].im = tab[11] * q[6].im;\n    q[7].re = tab[10] * q[7].re;\n    q[7].im = tab[11] * q[7].im;\n\n    k[0].re = q[4].re - q[0].re;\n    k[0].im = q[4].im - q[0].im;\n    k[1].re = q[5].re - q[1].re;\n    k[1].im = q[5].im - q[1].im;\n    k[2].re = q[6].re - q[2].re;\n    k[2].im = q[6].im - q[2].im;\n    k[3].re = q[7].re - q[3].re;\n    k[3].im = q[7].im - q[3].im;\n\n    k[4].re = q[4].re + q[0].re;\n    k[4].im = q[4].im + q[0].im;\n    k[5].re = q[5].re + q[1].re;\n    k[5].im = q[5].im + q[1].im;\n    k[6].re = q[6].re + q[2].re;\n    k[6].im = q[6].im + q[2].im;\n    k[7].re = q[7].re + q[3].re;\n    k[7].im = q[7].im + q[3].im;\n\n    k[0].re = in[11].re - k[0].re;\n    k[0].im = in[11].im + k[0].im;\n    k[1].re = in[12].re - k[1].re;\n    k[1].im = in[12].im + k[1].im;\n    k[2].re = in[13].re - k[2].re;\n    k[2].im = in[13].im + k[2].im;\n    k[3].re = in[14].re - k[3].re;\n    k[3].im = in[14].im + k[3].im;\n\n    k[4].re = in[11].re - k[4].re;\n    k[4].im = in[11].im + k[4].im;\n    k[5].re = in[12].re - k[5].re;\n    k[5].im = in[12].im + k[5].im;\n    k[6].re = in[13].re - k[6].re;\n    k[6].im = in[13].im + k[6].im;\n    k[7].re = in[14].re - k[7].re;\n    k[7].im = in[14].im + k[7].im;\n\n    /* 15pt start here */\n    t[0].re = y[3].re + y[0].re;\n    t[0].im = y[3].im + y[0].im;\n    t[1].re = y[2].re + y[1].re;\n    t[1].im = y[2].im + y[1].im;\n    t[2].re = y[1].re - y[2].re;\n    t[2].im = y[1].im - y[2].im;\n    t[3].re = y[0].re - y[3].re;\n    t[3].im = y[0].im - y[3].im;\n\n    t[4].re = k[3].re + k[0].re;\n    t[4].im = k[3].im + k[0].im;\n    t[5].re = k[2].re + k[1].re;\n    t[5].im = k[2].im + k[1].im;\n    t[6].re = k[1].re - k[2].re;\n    t[6].im = k[1].im - k[2].im;\n    t[7].re = k[0].re - k[3].re;\n    t[7].im = k[0].im - k[3].im;\n\n    t[ 8].re = k[7].re + k[4].re;\n    t[ 8].im = k[7].im + k[4].im;\n    t[ 9].re = k[6].re + k[5].re;\n    t[ 9].im = k[6].im + k[5].im;\n    t[10].re = k[5].re - k[6].re;\n    t[10].im = k[5].im - k[6].im;\n    t[11].re = k[4].re - k[7].re;\n    t[11].im = k[4].im - k[7].im;\n\n    out[ 0*stride].re = dc[0].re + t[0].re + t[ 1].re;\n    out[ 0*stride].im = dc[0].im + t[0].im + t[ 1].im;\n    out[10*stride].re = dc[1].re + t[4].re + t[ 5].re;\n    out[10*stride].im = dc[1].im + t[4].im + t[ 5].im;\n    out[ 5*stride].re = dc[2].re + t[8].re + t[ 9].re;\n    out[ 5*stride].im = dc[2].im + t[8].im + t[ 9].im;\n\n    r[0].re = t[0].re * tab[0];\n    r[0].im = t[0].im * tab[1];\n    r[1].re = t[1].re * tab[0];\n    r[1].im = t[1].im * tab[1];\n    r[2].re = t[2].re * tab[4];\n    r[2].im = t[2].im * tab[5];\n    r[3].re = t[3].re * tab[4];\n    r[3].im = t[3].im * tab[5];\n\n    r[4].re = t[4].re * tab[0];\n    r[4].im = t[4].im * tab[1];\n    r[5].re = t[5].re * tab[0];\n    r[5].im = t[5].im * tab[1];\n    r[6].re = t[6].re * tab[4];\n    r[6].im = t[6].im * tab[5];\n    r[7].re = t[7].re * tab[4];\n    r[7].im = t[7].im * tab[5];\n\n    r[ 8].re = t[ 8].re * tab[0];\n    r[ 8].im = t[ 8].im * tab[1];\n    r[ 9].re = t[ 9].re * tab[0];\n    r[ 9].im = t[ 9].im * tab[1];\n    r[10].re = t[10].re * tab[4];\n    r[10].im = t[10].im * tab[5];\n    r[11].re = t[11].re * tab[4];\n    r[11].im = t[11].im * tab[5];\n\n    t[0].re = t[0].re * tab[2];\n    t[0].im = t[0].im * tab[3];\n    t[1].re = t[1].re * tab[2];\n    t[1].im = t[1].im * tab[3];\n    t[2].re = t[2].re * tab[6];\n    t[2].im = t[2].im * tab[7];\n    t[3].re = t[3].re * tab[6];\n    t[3].im = t[3].im * tab[7];\n\n    t[4].re = t[4].re * tab[2];\n    t[4].im = t[4].im * tab[3];\n    t[5].re = t[5].re * tab[2];\n    t[5].im = t[5].im * tab[3];\n    t[6].re = t[6].re * tab[6];\n    t[6].im = t[6].im * tab[7];\n    t[7].re = t[7].re * tab[6];\n    t[7].im = t[7].im * tab[7];\n\n    t[ 8].re = t[ 8].re * tab[2];\n    t[ 8].im = t[ 8].im * tab[3];\n    t[ 9].re = t[ 9].re * tab[2];\n    t[ 9].im = t[ 9].im * tab[3];\n    t[10].re = t[10].re * tab[6];\n    t[10].im = t[10].im * tab[7];\n    t[11].re = t[11].re * tab[6];\n    t[11].im = t[11].im * tab[7];\n\n    r[0].re = r[0].re - t[1].re;\n    r[0].im = r[0].im - t[1].im;\n    r[1].re = r[1].re - t[0].re;\n    r[1].im = r[1].im - t[0].im;\n    r[2].re = r[2].re - t[3].re;\n    r[2].im = r[2].im - t[3].im;\n    r[3].re = r[3].re + t[2].re;\n    r[3].im = r[3].im + t[2].im;\n\n    r[4].re = r[4].re - t[5].re;\n    r[4].im = r[4].im - t[5].im;\n    r[5].re = r[5].re - t[4].re;\n    r[5].im = r[5].im - t[4].im;\n    r[6].re = r[6].re - t[7].re;\n    r[6].im = r[6].im - t[7].im;\n    r[7].re = r[7].re + t[6].re;\n    r[7].im = r[7].im + t[6].im;\n\n    r[ 8].re = r[ 8].re - t[ 9].re;\n    r[ 8].im = r[ 8].im - t[ 9].im;\n    r[ 9].re = r[ 9].re - t[ 8].re;\n    r[ 9].im = r[ 9].im - t[ 8].im;\n    r[10].re = r[10].re - t[11].re;\n    r[10].im = r[10].im - t[11].im;\n    r[11].re = r[11].re + t[10].re;\n    r[11].im = r[11].im + t[10].im;\n\n    z0[ 0].re = r[ 3].im + r[ 0].re;\n    z0[ 0].im = r[ 3].re + r[ 0].im;\n    z0[ 1].re = r[ 2].im + r[ 1].re;\n    z0[ 1].im = r[ 2].re + r[ 1].im;\n    z0[ 2].re = r[ 1].im - r[ 2].re;\n    z0[ 2].im = r[ 1].re - r[ 2].im;\n    z0[ 3].re = r[ 0].im - r[ 3].re;\n    z0[ 3].im = r[ 0].re - r[ 3].im;\n\n    z0[ 4].re = r[ 7].im + r[ 4].re;\n    z0[ 4].im = r[ 7].re + r[ 4].im;\n    z0[ 5].re = r[ 6].im + r[ 5].re;\n    z0[ 5].im = r[ 6].re + r[ 5].im;\n    z0[ 6].re = r[ 5].im - r[ 6].re;\n    z0[ 6].im = r[ 5].re - r[ 6].im;\n    z0[ 7].re = r[ 4].im - r[ 7].re;\n    z0[ 7].im = r[ 4].re - r[ 7].im;\n\n    z0[ 8].re = r[11].im + r[ 8].re;\n    z0[ 8].im = r[11].re + r[ 8].im;\n    z0[ 9].re = r[10].im + r[ 9].re;\n    z0[ 9].im = r[10].re + r[ 9].im;\n    z0[10].re = r[ 9].im - r[10].re;\n    z0[10].im = r[ 9].re - r[10].im;\n    z0[11].re = r[ 8].im - r[11].re;\n    z0[11].im = r[ 8].re - r[11].im;\n\n    out[ 6*stride].re = dc[0].re + z0[0].re;\n    out[ 6*stride].im = dc[0].im + z0[3].re;\n    out[12*stride].re = dc[0].re + z0[2].im;\n    out[12*stride].im = dc[0].im + z0[1].im;\n    out[ 3*stride].re = dc[0].re + z0[1].re;\n    out[ 3*stride].im = dc[0].im + z0[2].re;\n    out[ 9*stride].re = dc[0].re + z0[3].im;\n    out[ 9*stride].im = dc[0].im + z0[0].im;\n\n    out[ 1*stride].re = dc[1].re + z0[4].re;\n    out[ 1*stride].im = dc[1].im + z0[7].re;\n    out[ 7*stride].re = dc[1].re + z0[6].im;\n    out[ 7*stride].im = dc[1].im + z0[5].im;\n    out[13*stride].re = dc[1].re + z0[5].re;\n    out[13*stride].im = dc[1].im + z0[6].re;\n    out[ 4*stride].re = dc[1].re + z0[7].im;\n    out[ 4*stride].im = dc[1].im + z0[4].im;\n\n    out[11*stride].re = dc[2].re + z0[8].re;\n    out[11*stride].im = dc[2].im + z0[11].re;\n    out[ 2*stride].re = dc[2].re + z0[10].im;\n    out[ 2*stride].im = dc[2].im + z0[9].im;\n    out[ 8*stride].re = dc[2].re + z0[9].re;\n    out[ 8*stride].im = dc[2].im + z0[10].re;\n    out[14*stride].re = dc[2].re + z0[11].im;\n```\n\n----------------------------------------\n\nTITLE: Calculating Complex Audio Output in FFmpeg (C)\nDESCRIPTION: This code snippet calculates the imaginary part of an audio output sample. It combines a DC component with a processed signal component, likely part of a larger audio transformation algorithm in FFmpeg.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/transforms.md#2025-04-05_snippet_9\n\nLANGUAGE: C\nCODE:\n```\n    out[14*stride].im = dc[2].im + z0[8].im;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Snow Bitstream Syntax in Pseudo-code\nDESCRIPTION: Pseudo-code representation of the Snow bitstream syntax, including frame structure, header information, prediction, and residual coding. This snippet defines the overall structure and key elements of a Snow-encoded video frame.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/snow.txt#2025-04-05_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nframe:\n    header\n    prediction\n    residual\n\nheader:\n    keyframe                            b   MID_STATE\n    if(keyframe || always_reset)\n        reset_contexts\n    if(keyframe){\n        version                         u   header_state\n        always_reset                    b   header_state\n        temporal_decomposition_type     u   header_state\n        temporal_decomposition_count    u   header_state\n        spatial_decomposition_count     u   header_state\n        colorspace_type                 u   header_state\n        if (nb_planes > 2) {\n            chroma_h_shift              u   header_state\n            chroma_v_shift              u   header_state\n        }\n        spatial_scalability             b   header_state\n        max_ref_frames-1                u   header_state\n        qlogs\n    }\n    if(!keyframe){\n        update_mc                       b   header_state\n        if(update_mc){\n            for(plane=0; plane<nb_plane_types; plane++){\n                diag_mc                 b   header_state\n                htaps/2-1               u   header_state\n                for(i= p->htaps/2; i; i--)\n                    |hcoeff[i]|         u   header_state\n            }\n        }\n        update_qlogs                    b   header_state\n        if(update_qlogs){\n            spatial_decomposition_count u   header_state\n            qlogs\n        }\n    }\n\n    spatial_decomposition_type          s   header_state\n    qlog                                s   header_state\n    mv_scale                            s   header_state\n    qbias                               s   header_state\n    block_max_depth                     s   header_state\n```\n\n----------------------------------------\n\nTITLE: Defining Snow Prediction Block Structure in Pseudo-code\nDESCRIPTION: Pseudo-code representation of the prediction block structure in Snow. This snippet outlines the recursive block splitting process and the coding of intra and inter prediction information.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/snow.txt#2025-04-05_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nprediction:\n    for(y=0; y<block_count_vertical; y++)\n        for(x=0; x<block_count_horizontal; x++)\n            block(0)\n\nblock(level):\n    mvx_diff=mvy_diff=y_diff=cb_diff=cr_diff=0\n    if(keyframe){\n        intra=1\n    }else{\n        if(level!=max_block_depth){\n            s_context= 2*left->level + 2*top->level + topleft->level + topright->level\n            leaf                        b   block_state[4 + s_context]\n        }\n        if(level==max_block_depth || leaf){\n            intra                       b   block_state[1 + left->intra + top->intra]\n            if(intra){\n                y_diff                  s   block_state[32]\n                cb_diff                 s   block_state[64]\n                cr_diff                 s   block_state[96]\n            }else{\n                ref_context= ilog2(2*left->ref) + ilog2(2*top->ref)\n                if(ref_frames > 1)\n                    ref                 u   block_state[128 + 1024 + 32*ref_context]\n                mx_context= ilog2(2*abs(left->mx - top->mx))\n                my_context= ilog2(2*abs(left->my - top->my))\n                mvx_diff                s   block_state[128 + 32*(mx_context + 16*!!ref)]\n                mvy_diff                s   block_state[128 + 32*(my_context + 16*!!ref)]\n            }\n        }else{\n            block(level+1)\n            block(level+1)\n            block(level+1)\n            block(level+1)\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Snow Residual Coding Structure in Pseudo-code\nDESCRIPTION: Pseudo-code representation of the residual coding structure in Snow. This snippet outlines the organization of residual data for luma and chroma components across different subbands.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/snow.txt#2025-04-05_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nresidual:\n    residual2(luma)\n    if (nb_planes > 2) {\n        residual2(chroma_cr)\n        residual2(chroma_cb)\n    }\n\nresidual2:\n    for(level=0; level<spatial_decomposition_count; level++){\n        if(level==0)\n            subband(LL, 0)\n        subband(HL, level)\n        subband(LH, level)\n        subband(HH, level)\n    }\n\nsubband:\n    FIXME\n\nnb_plane_types = gray ? 1 : 2;\n```\n\n----------------------------------------\n\nTITLE: State Transition Table for Range Coding in Snow Codec\nDESCRIPTION: A lookup table used by the Snow binary range coder to adapt symbol probabilities based on previously seen bits. The table contains 256 values that determine state transitions when encoding 0 or 1 bits.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/snow.txt#2025-04-05_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nstate_transition_table = {\n  0,   0,   0,   0,   0,   0,   0,   0,  20,  21,  22,  23,  24,  25,  26,  27,\n 28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  37,  38,  39,  40,  41,  42,\n 43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  56,  57,\n 58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,\n 74,  75,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,\n 89,  90,  91,  92,  93,  94,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103,\n104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 114, 115, 116, 117, 118,\n119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 133,\n134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n150, 151, 152, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,\n165, 166, 167, 168, 169, 170, 171, 171, 172, 173, 174, 175, 176, 177, 178, 179,\n180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 190, 191, 192, 194, 194,\n195, 196, 197, 198, 199, 200, 201, 202, 202, 204, 205, 206, 207, 208, 209, 209,\n210, 211, 212, 213, 215, 215, 216, 217, 218, 219, 220, 220, 222, 223, 224, 225,\n226, 227, 227, 229, 229, 230, 231, 232, 234, 234, 235, 236, 237, 238, 239, 240,\n241, 242, 243, 244, 245, 246, 247, 248, 248,   0,   0,   0,   0,   0,   0,   0};\n```\n\n----------------------------------------\n\nTITLE: LL Band Prediction Algorithm in Snow Codec\nDESCRIPTION: Algorithm for predicting samples in the LL0 subband using the median of neighboring samples. Each sample is predicted from left, top, and a special diagonal predictor, with samples outside the subband considered to be 0.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/snow.txt#2025-04-05_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nfor(y=0; y<height; y++){\n    for(x=0; x<width; x++){\n        sample[y][x] += median(sample[y-1][x],\n                               sample[y][x-1],\n                               sample[y-1][x]+sample[y][x-1]-sample[y-1][x-1]);\n    }\n}\nsample[-1][*]=sample[*][-1]= 0;\n```\n\n----------------------------------------\n\nTITLE: Optimizing Bitwise Operations in C\nDESCRIPTION: These code snippets demonstrate optimized bitwise operations that are equivalent to more complex arithmetic operations. They can be used to improve performance in wavelet transform calculations.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/snow.txt#2025-04-05_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n(3a)>>1 == a + (a>>1)\n```\n\nLANGUAGE: c\nCODE:\n```\n(a + 4b + 8)>>4 == ((a>>2) + b + 2)>>2\n```\n\n----------------------------------------\n\nTITLE: 16-bit IDWT Implementation Notes in C\nDESCRIPTION: These code snippets show the minimum number of bits needed for various terms in a 16-bit Inverse Discrete Wavelet Transform (IDWT) implementation. They help prevent overflows when implementing the IDWT with 16-bit precision.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/snow.txt#2025-04-05_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nA= s[i-1] + s[i+1]                              16bit\n```\n\nLANGUAGE: c\nCODE:\n```\n3*A + 4                                         18bit\n```\n\nLANGUAGE: c\nCODE:\n```\nA + (A>>1) + 2                                  17bit\n```\n\nLANGUAGE: c\nCODE:\n```\ns[i-1] + s[i+1]                                 17bit\n```\n\nLANGUAGE: c\nCODE:\n```\n3*(s[i-1] + s[i+1])                             17bit\n```\n\n----------------------------------------\n\nTITLE: Configuring FFmpeg build environment\nDESCRIPTION: Command to generate the configuration for building FFmpeg. This creates the necessary build files based on your system environment and specified options.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/INSTALL.md#2025-04-05_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure\n```\n\n----------------------------------------\n\nTITLE: Viewing FFmpeg configuration options\nDESCRIPTION: Command to display all available configuration options for FFmpeg compilation. This helps users customize their build according to specific needs.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/INSTALL.md#2025-04-05_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nconfigure --help\n```\n\n----------------------------------------\n\nTITLE: Configuring FFmpeg from different directory\nDESCRIPTION: Example of configuring FFmpeg using an absolute path to build objects outside the source tree. This allows for cleaner source management and multiple build configurations.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/INSTALL.md#2025-04-05_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n/ffmpegdir/ffmpeg/configure\n```\n\n----------------------------------------\n\nTITLE: Building FFmpeg from source\nDESCRIPTION: Command to compile FFmpeg after configuration has completed. This requires GNU Make 3.81 or later.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/INSTALL.md#2025-04-05_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Installing FFmpeg binaries and libraries\nDESCRIPTION: Command to install the compiled FFmpeg binaries and libraries to the system. This typically requires administrator privileges.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/INSTALL.md#2025-04-05_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Configuring Makefile Variables for FFmpeg Build\nDESCRIPTION: Defines Makefile variables used to control various aspects of the FFmpeg build process. These variables include options for verbose output, debugging assembly files, setting install directories, and generating references.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/build_system.txt#2025-04-05_snippet_0\n\nLANGUAGE: Makefile\nCODE:\n```\nV\n    Disable the default terse mode, the full command issued by make and its\n    output will be shown on the screen.\n\nDBG\n    Preprocess x86 external assembler files to a .dbg.asm file in the object\n    directory, which then gets compiled. Helps in developing those assembler\n    files.\n\nDESTDIR\n    Destination directory for the install targets, useful to prepare packages\n    or install FFmpeg in cross-environments.\n\nGEN\n    Set to '1' to generate the missing or mismatched references.\n```\n\n----------------------------------------\n\nTITLE: Defining Makefile Targets for FFmpeg Build and Testing\nDESCRIPTION: Lists and describes various Makefile targets used in the FFmpeg build system. These targets cover building libraries and executables, running tests, installing components, and performing maintenance tasks.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/build_system.txt#2025-04-05_snippet_1\n\nLANGUAGE: Makefile\nCODE:\n```\nall\n    Default target, builds all the libraries and the executables.\n\nfate\n    Run the fate test suite, note that you must have installed it.\n\nfate-list\n    List all fate/regression test targets.\n\nfate-list-failing\n    List the fate tests that failed the last time they were executed.\n\nfate-clear-reports\n    Remove the test reports from previous test executions (getting rid of\n    potentially stale results from fate-list-failing).\n\ninstall\n    Install headers, libraries and programs.\n\nexamples\n    Build all examples located in doc/examples.\n\ncheckheaders\n    Check headers dependencies.\n\nalltools\n    Build all tools in tools directory.\n\nconfig\n    Reconfigure the project with the current configuration.\n\ntools/target_dec_<decoder>_fuzzer\n    Build fuzzer to fuzz the specified decoder.\n\ntools/target_bsf_<filter>_fuzzer\n    Build fuzzer to fuzz the specified bitstream filter.\n```\n\n----------------------------------------\n\nTITLE: Using Standard Make Commands with FFmpeg Build System\nDESCRIPTION: Provides examples of useful standard make commands that can be used with the FFmpeg build system. These commands offer options for optimizing the build process, such as touching files to reduce rebuilding and using multiple jobs for faster compilation.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/build_system.txt#2025-04-05_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\nmake -t <target>\n    Touch all files that otherwise would be built, this is useful to reduce\n    unneeded rebuilding when changing headers, but note that you must force rebuilds\n    of files that actually need it by hand then.\n\nmake -j<num>\n    Rebuild with multiple jobs at the same time. Faster on multi processor systems.\n\nmake -k\n    Continue build in case of errors, this is useful for the regression tests\n    sometimes but note that it will still not run all reg tests.\n```\n\n----------------------------------------\n\nTITLE: Printing Table Arrays in C for FFmpeg Table Generator\nDESCRIPTION: Demonstrates how to print table arrays in the .c file of an FFmpeg table generator. It shows both a generic form and a shorter form using helper macros.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/tablegen.txt#2025-04-05_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nwrite_fileheader();\nprintf(\"static const uint8_t my_array[100] = {\\n\");\nwrite_uint8_t_array(my_array, 100);\nprintf(\"};\");\n```\n\nLANGUAGE: C\nCODE:\n```\nwrite_fileheader();\nWRITE_ARRAY(\"static const\", uint8_t, my_array);\n```\n\n----------------------------------------\n\nTITLE: Including Generated Tables in FFmpeg .h File\nDESCRIPTION: Shows how to include the generated tables header file in the .h file of an FFmpeg table generator when CONFIG_HARDCODED_TABLES is set.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/tablegen.txt#2025-04-05_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n#include \"libavcodec/example_tables.h\"\n```\n\n----------------------------------------\n\nTITLE: Adding Table Dependency in FFmpeg Makefile\nDESCRIPTION: Demonstrates how to add a dependency for the generated tables in the FFmpeg Makefile to enable automatic table creation.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/tablegen.txt#2025-04-05_snippet_2\n\nLANGUAGE: Makefile\nCODE:\n```\n$(SUBDIR)example.o: $(SUBDIR)example_tables.h\n```\n\n----------------------------------------\n\nTITLE: Using Git Commands for FFmpeg Patch Submission\nDESCRIPTION: Git commands for preparing and submitting patches to the FFmpeg mailing list. Developers should use either git format-patch or git send-email to submit their contributions.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/CONTRIBUTING.md#2025-04-05_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit format-patch\n```\n\nLANGUAGE: shell\nCODE:\n```\ngit send-email\n```\n\n----------------------------------------\n\nTITLE: Generating Filter Files in C\nDESCRIPTION: Commands to create a new filter file by copying an existing one and updating relevant project files.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsed 's/edgedetect/foobar/g;s/EdgeDetect/Foobar/g' libavfilter/vf_edgedetect.c > libavfilter/vf_foobar.c\n```\n\n----------------------------------------\n\nTITLE: Testing New Filter in FFmpeg\nDESCRIPTION: Command to test the newly created filter using FFmpeg.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./ffmpeg -i http://samples.ffmpeg.org/image-samples/lena.pnm -vf foobar foobar.png\n```\n\n----------------------------------------\n\nTITLE: Defining Filter Context in C\nDESCRIPTION: Structure definition for the filter's context, storing user options and state information.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/writing_filters.txt#2025-04-05_snippet_2\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct FoobarContext {\n    const AVClass *class;\n    // Other context fields\n} FoobarContext;\n```\n\n----------------------------------------\n\nTITLE: Using unsigned types for signed integer operations in C\nDESCRIPTION: Example showing how using unsigned types for semantically signed values can create confusion in code. The computation a+b*c uses unsigned variables where b might semantically represent -5, but its unsigned nature is not visually apparent.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/undefined.txt#2025-04-05_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nunsigned a,b,c;\n...\na+b*c;\n```\n\n----------------------------------------\n\nTITLE: Using SUINT type for semantically signed values in C\nDESCRIPTION: Example demonstrating the SUINT type, which is technically an unsigned integer but semantically represents signed values. This approach avoids undefined behavior while making the intent clear that the variables represent signed values.\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/undefined.txt#2025-04-05_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nSUINT a,b,c;\n...\na+b*c;\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Merge Conflict Style\nDESCRIPTION: Git configuration command to set a different merge conflict style to reduce error risk during Libav merges\nSOURCE: https://github.com/FFmpeg/FFmpeg/blob/master/doc/libav-merge.txt#2025-04-05_snippet_0\n\nLANGUAGE: git\nCODE:\n```\ngit config --global merge.conflictstyle diff3\n```"
  }
]