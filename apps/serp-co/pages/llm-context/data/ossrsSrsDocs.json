[
  {
    "owner": "ossrs",
    "repo": "srs-docs",
    "content": "TITLE: Running SRS Docker Container for Live Streaming\nDESCRIPTION: This command runs the SRS Docker container, exposing necessary ports for RTMP, HTTP-FLV, and HLS streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for SRT Streaming\nDESCRIPTION: This command runs the SRS Docker container with SRT support and a specific configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 10080:10080/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS HTTP Hooks in srs.conf\nDESCRIPTION: This configuration snippet demonstrates how to enable and configure HTTP callbacks within an SRS virtual host (`vhost`). It shows directives like `enabled`, `on_publish`, `on_unpublish`, `on_play`, `on_stop`, `on_dvr`, `on_hls`, and `on_hls_notify`, specifying the backend HTTP(S) endpoints to be called for each event. The comments detail the expected JSON payload structure for each hook and the required response format (HTTP 200 with a '0' body for success). Multiple callback URLs can be specified, separated by spaces.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        # whether the http hooks enable.\n        # default off.\n        enabled         on;\n        # when client(encoder) publish to vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_publish\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_publish http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_publish https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        # when client(encoder) stop publish to vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_unpublish\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_unpublish http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_unpublish https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        # when client start to play vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_play\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"pageUrl\": \"http://www.test.com/live.html\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_play http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_play https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        # when client stop to play vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_stop\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_stop http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_stop https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        # when srs reap a dvr file, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_dvr\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"cwd\": \"/usr/local/srs\",\n        #           \"file\": \"./objs/nginx/html/live/livestream.1420254068776.flv\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;\n        # when srs reap a ts file of hls, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_hls\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"duration\": 9.36, // in seconds\n        #           \"cwd\": \"/usr/local/srs\",\n        #           \"file\": \"./objs/nginx/html/live/livestream/2015-04-23/01/476584165.ts\",\n        #           \"url\": \"live/livestream/2015-04-23/01/476584165.ts\",\n        #           \"m3u8\": \"./objs/nginx/html/live/livestream/live.m3u8\",\n        #           \"m3u8_url\": \"live/livestream/live.m3u8\",\n        #           \"seq_no\": 100\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;\n        # when srs reap a ts file of hls, call this hook,\n        # used to push file to cdn network, by get the ts file from cdn network.\n        # so we use HTTP GET and use the variable following:\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [param], replace with the param.\n        #       [ts_url], replace with the ts url.\n        # ignore any return data of server.\n        # @remark random select a url to report, not report all.\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Embedded HTTP Server - SRS Configuration - Bash\nDESCRIPTION: Defines the SRS embedded HTTP server block to enable static file serving, set listening port, and specify the web root directory. Required for HTTP streaming (e.g., HLS), the block should be added to the SRS config. The 'enabled' flag turns the server on, 'listen' sets the port, and 'dir' defines the file root. Each vhost must also be configured separately for HTTP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# embeded http server in srs.\n# the http streaming config, for HLS/HDS/DASH/HTTPProgressive\n# global config for http streaming, user must config the http section for each vhost.\n# the embed http server used to substitute nginx in ./objs/nginx,\n# for example, srs runing in arm, can provides RTMP and HTTP service, only with srs installed.\n# user can access the http server pages, generally:\n#       curl http://192.168.1.170:80/srs.html\n# which will show srs version and welcome to srs.\n# @remeark, the http embeded stream need to config the vhost, for instance, the __defaultVhost__\n# need to open the feature http of vhost.\nhttp_server {\n    # whether http streaming service is enabled.\n    # default: off\n    enabled         on;\n    # the http streaming port\n    # @remark, if use lower port, for instance 80, user must start srs by root.\n    # default: 8080\n    listen          8080;\n    # the default dir for http root.\n    # default: ./objs/nginx/html\n    dir             ./objs/nginx/html;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Low Latency Configuration for SRS\nDESCRIPTION: Recommended comprehensive configuration for achieving minimum latency in SRS, including TCP nodelay, minimum latency mode, GOP cache, and queue settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming RTMP via FFMPEG for HLS Generation - Bash\nDESCRIPTION: This Bash loop repeatedly streams a source FLV file to the SRS server via RTMP using ffmpeg in real-time mode. FFMPEG and SRS must be installed and built. The script takes a local source FLV file and streams it as 'livestream' to the SRS RTMP endpoint, sleeping 1 second between attempts. Output is continuous streaming for HLS segment creation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\\\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\\\\n    -c copy -f flv rtmp://192.168.1.170/live/livestream; \\\\\\n    sleep 1; \\\\\\ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP-MP3 Streaming Output with SRS (conf)\nDESCRIPTION: This setup enables HTTP streaming (on port 8080) and remuxes RTMP input to MP3-only audio over HTTP. The fast_cache parameter is set to optimize audio delivery for clients like Android. Output endpoint is [vhost]/[app]/[stream].mp3. Dependencies: SRS, RTMP with MP3 audio. Key parameters: http_server, http_remux.fast_cache (set to 30), and .mount (.mp3). Input: RTMP with audio; Output: HTTP-MP3 audio stream. Limitation: Drops video, audio stream must be MP3 codec.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-http-flv.md#2025-04-23_snippet_3\n\nLANGUAGE: conf\nCODE:\n```\nhttp_server {\n    enabled         on;\n    listen          8080;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        fast_cache  30;\n        mount       [vhost]/[app]/[stream].mp3;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Low-Latency HLS Settings in SRS\nDESCRIPTION: Configuration example showing how to reduce HLS latency by setting smaller fragment and window sizes. This setup reduces the default 30-second latency to approximately 6-8 seconds by configuring a fragment size of 2 seconds and a window of 10 seconds.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_fragment 2;\n        hls_window 10;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic RTMP in SRS\nDESCRIPTION: Minimal SRS configuration snippet to enable RTMP streaming. It specifies the port (1935) for RTMP connections, sets the maximum number of concurrent connections, and defines a default virtual host (__defaultVhost__). This is the basic setup needed for SRS to accept RTMP publishers and players.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling SRS HTTP RAW API in Configuration File - text\nDESCRIPTION: This configuration snippet enables HTTP RAW API functionality in the SRS configuration file. The 'raw_api' sub-section should be nested inside 'http_api', with 'enabled' and 'allow_reload' both set to 'on'. SRS must be restarted or reloaded for config changes to take effect. If misconfigured, SRS will return error code 1061 to API access attempts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nhttp_api {\n    enabled         on;\n    listen          1985;\n    raw_api {\n        enabled             on;\n        allow_reload        on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Settings in SRS Server\nDESCRIPTION: Complete HLS configuration block for SRS server including settings for fragments, windows, file paths, encryption, and advanced controls. Includes environment variable overrides and detailed explanations for each setting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether the hls is enabled.\n        # if off, do not write hls(ts and m3u8) when publish.\n        # Overwrite by env SRS_VHOST_HLS_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n\n        # the hls fragment in seconds, the duration of a piece of ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENT for all vhosts.\n        # default: 10\n        hls_fragment 10;\n        # the hls m3u8 target duration ratio,\n        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init\n        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts\n        # Overwrite by env SRS_VHOST_HLS_HLS_TD_RATIO for all vhosts.\n        # default: 1.0\n        hls_td_ratio 1.0;\n        # the audio overflow ratio.\n        # for pure audio, the duration to reap the segment.\n        # for example, the hls_fragment is 10s, hls_aof_ratio is 1.2,\n        # the segment will reap to 12s for pure audio.\n        # Overwrite by env SRS_VHOST_HLS_HLS_AOF_RATIO for all vhosts.\n        # default: 1.2\n        hls_aof_ratio 1.2;\n        # the hls window in seconds, the number of ts in m3u8.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WINDOW for all vhosts.\n        # default: 60\n        hls_window 60;\n        # the error strategy. can be:\n        #       ignore, disable the hls.\n        #       disconnect, require encoder republish.\n        #       continue, ignore failed try to continue output hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_ON_ERROR for all vhosts.\n        # default: continue\n        hls_on_error continue;\n        # the hls output path.\n        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream].m3u8\n        # the ts file is configured by hls_path/hls_ts_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream]-[seq].ts\n        # @remark the hls_path is compatible with srs v1 config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_PATH for all vhosts.\n        # default: ./objs/nginx/html\n        hls_path ./objs/nginx/html;\n        # the hls m3u8 file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        # Overwrite by env SRS_VHOST_HLS_HLS_M3U8_FILE for all vhosts.\n        # default: [app]/[stream].m3u8\n        hls_m3u8_file [app]/[stream].m3u8;\n        # the hls ts file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        #       [seq], the sequence number of ts.\n        #       [duration], replace this const to current ts duration.\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#hls-config\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FILE for all vhosts.\n        # default: [app]/[stream]-[seq].ts\n        hls_ts_file [app]/[stream]-[seq].ts;\n        # the hls entry prefix, which is base url of ts url.\n        # for example, the prefix is:\n        #         http://your-server/\n        # then, the ts path in m3u8 will be like:\n        #         http://your-server/live/livestream-0.ts\n        #         http://your-server/live/livestream-1.ts\n        #         ...\n        # Overwrite by env SRS_VHOST_HLS_HLS_ENTRY_PREFIX for all vhosts.\n        # optional, default to empty string.\n        hls_entry_prefix http://your-server;\n        # the default audio codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for mp3.\n        # the available audio codec:\n        #       aac, mp3, an\n        # Overwrite by env SRS_VHOST_HLS_HLS_ACODEC for all vhosts.\n        # default: aac\n        hls_acodec aac;\n        # the default video codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for pure audio(without video) to vn.\n        # the available video codec:\n        #       h264, vn\n        # Overwrite by env SRS_VHOST_HLS_HLS_VCODEC for all vhosts.\n        # default: h264\n        hls_vcodec h264;\n        # whether cleanup the old expired ts files.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CLEANUP for all vhosts.\n        # default: on\n        hls_cleanup on;\n        # If there is no incoming packets, dispose HLS in this timeout in seconds,\n        # which removes all HLS files including m3u8 and ts files.\n        # @remark 0 to disable dispose for publisher.\n        # @remark apply for publisher timeout only, while \"etc/init.d/srs stop\" always dispose hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DISPOSE for all vhosts.\n        # default: 120\n        hls_dispose 120;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WAIT_KEYFRAME for all vhosts.\n        # default: on\n        hls_wait_keyframe on;\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enhanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FLOOR for all vhosts.\n        # default: off\n        hls_ts_floor off;\n        # the max size to notify hls,\n        # to read max bytes from ts of specified cdn network,\n        # @remark only used when on_hls_notify is config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_NB_NOTIFY for all vhosts.\n        # default: 64\n        hls_nb_notify 64;\n\n        # Whether enable hls_ctx for HLS streaming, for which we create a \"fake\" connection for HTTP API and callback.\n        # For each HLS streaming session, we use a child m3u8 with a session identified by query \"hls_ctx\", it simply\n        # work as the session id.\n        # Once the HLS streaming session is created, we will cleanup it when timeout in 2*hls_window seconds. So it\n        # takes a long time period to identify the timeout.\n        # Now we got a HLS stremaing session, just like RTMP/WebRTC/HTTP-FLV streaming, we're able to stat the session\n        # as a \"fake\" connection, do HTTP callback when start playing the HLS streaming. You're able to do querying and\n        # authentication.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CTX for all vhosts.\n        # Default: on\n        hls_ctx on;\n        # For HLS pseudo streaming, whether enable the session for each TS segment.\n        # If enabled, SRS HTTP API will show the statistics about HLS streaming bandwidth, both m3u8 and ts file. Please\n        # note that it also consumes resource, because each ts file should be served by SRS, all NGINX cache will be\n        # missed because we add session id to each ts file.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_CTX for all vhosts.\n        # Default: on\n        hls_ts_ctx on;\n\n        # whether using AES encryption.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEYS for all vhosts.\n        # default: off\n        hls_keys on;\n        # the number of clear ts which one key can encrypt.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENTS_PER_KEY for all vhosts.\n        # default: 5\n        hls_fragments_per_key 5;\n        # the hls key file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [seq], the sequence number of key corresponding to the ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE for all vhosts.\n        hls_key_file [app]/[stream]-[seq].key;\n        # the key output path.\n        # the key file is configed by hls_path/hls_key_file, the default is:\n        # ./objs/nginx/html/[app]/[stream]-[seq].key\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE_PATH for all vhosts.\n        hls_key_file_path ./objs/nginx/html;\n        # the key root URL, use this can support https.\n        # @remark It's optional.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_URL for all vhosts.\n        hls_key_url https://localhost:8080;\n\n        # Special control controls.\n        ###########################################\n        # Whether calculate the DTS of audio frame directly.\n        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544\n        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.\n        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DTS_DIRECTLY for all vhosts.\n        # Default: on\n        hls_dts_directly on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting SRS Service External IP\nDESCRIPTION: Command to retrieve the external IP address of the SRS service LoadBalancer.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get svc/srs-service\n```\n\n----------------------------------------\n\nTITLE: Applying SRS Edge Deployment Configuration in Kubernetes using Bash\nDESCRIPTION: This Bash command applies a Kubernetes Deployment configuration for the SRS edge server using `kubectl apply --record -f -`. The Deployment `srs-edge-deploy` manages 2 replicas, uses the image `ossrs/srs:v4.0.5`, mounts the `srs-edge-config` ConfigMap for configuration, and defines container ports. Crucially, it includes a `lifecycle.preStop` hook that executes `/usr/local/srs/etc/init.d/srs grace` to trigger SRS graceful shutdown before the pod terminates. The `terminationGracePeriodSeconds` is set to 120 seconds to allow ample time for connections to drain. The `--record` flag saves the command for potential rollbacks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply --record -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:v4.0.5\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"/usr/local/srs/etc/init.d/srs\", \"grace\"]\n      terminationGracePeriodSeconds: 120\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP-FLV Output with SRS (conf)\nDESCRIPTION: This configuration enables the HTTP server in SRS on port 8080 and remuxes RTMP streams to HTTP-FLV endpoints, mounted at [vhost]/[app]/[stream].flv for every default vhost. Dependencies: SRS software, RTMP source streams. Key parameters: http_server.enabled ('on'), http_server.listen (port), vhost.__defaultVhost__.http_remux.enabled ('on'), and mount. Input: RTMP publish stream; Output: HTTP-FLV endpoint available at the configured mount. Limitation: This does not include HTTPS, caching, or non-FLV formats.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-http-flv.md#2025-04-23_snippet_0\n\nLANGUAGE: conf\nCODE:\n```\nhttp_server {\n    enabled         on;\n    listen          8080;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS for WebRTC to RTMP Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC to RTMP configuration. This setup accepts WebRTC inputs and converts them to RTMP for compatibility with RTMP players.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for HTTP-FLV\nDESCRIPTION: Docker command to run SRS server with HTTP-FLV configuration. Exposes ports 1935 for RTMP and 8080 for HTTP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/flv.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:5 \\\n  ./objs/srs -c conf/http.flv.live.conf\n```\n\n----------------------------------------\n\nTITLE: Example HTTP POST Request for SRS on_publish Callback\nDESCRIPTION: Illustrates the structure of an HTTP POST request sent by SRS to a configured callback endpoint when an `on_publish` event occurs. The request uses the POST method, includes a `Content-Type: application-json` header, and carries a JSON payload in the body. The JSON object contains details about the event, such as the SRS server ID, action type (`on_publish`), client ID, client IP address, vhost name, application name, RTMP tcUrl, stream name, and any URL parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nPOST /api/v1/streams HTTP/1.1\nContent-Type: application-json\n\nBody:\n{\n  \"server_id\": \"vid-0xk989d\",\n  \"action\": \"on_publish\",\n  \"client_id\": \"341w361a\",\n  \"ip\": \"127.0.0.1\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"tcUrl\": \"rtmp://127.0.0.1:1935/live?vhost=__defaultVhost__\",\n  \"stream\": \"livestream\",\n  \"param\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP Callback Configuration\nDESCRIPTION: Complete configuration example for HTTP callbacks in SRS including publish, unpublish, play, stop, DVR, and HLS events.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        enabled         on;\n        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;\n        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[server_id]/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Browser-to-Browser WebRTC Flows using Bash Pseudo-Diagram\nDESCRIPTION: This code snippet features an ASCII diagram using a bash code block to depict the connections between two browsers in a WebRTC session. The 'Signaling' and 'Media' flows between browsers are shown as labeled arrows, intended for visualization only. There are no dependencies since this is not executable code, and no input/output parameters are present. The snippet must be rendered in a monospace font to display correctly and is meant for descriptive, not functional, purposes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +----------------+\\n+    Browser     +----<--Signaling----->--+    Browser     +\\n+ (like Chrome)  +----<----Media----->----+ (like Chrome)  +\\n+----------------+                        +----------------+\n```\n\n----------------------------------------\n\nTITLE: Defining Kubernetes Deployment for SRS Edge with Graceful Shutdown (YAML)\nDESCRIPTION: This YAML snippet defines a Kubernetes Deployment named `srs-edge-deploy` for SRS edge servers. It specifies 2 replicas, uses the `ossrs/srs:v4.0.5` image, mounts the `srs-edge-config` ConfigMap to `/usr/local/srs/conf`, and exposes container ports 1935, 1985, and 8080. Crucially, it includes a `lifecycle.preStop` hook that executes `/usr/local/srs/etc/init.d/srs grace` to trigger SRS's graceful shutdown mechanism before the pod terminates, and sets `terminationGracePeriodSeconds` to 120 seconds to allow sufficient time for existing connections to drain gracefully during updates or scaling operations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:v4.0.5\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"/usr/local/srs/etc/init.d/srs\", \"grace\"]\n      terminationGracePeriodSeconds: 120\n```\n\n----------------------------------------\n\nTITLE: Enabling HTTPS API in SRS Configuration - SRS Config\nDESCRIPTION: This SRS config snippet enables the SRS HTTPS API by specifying a separate listen port, activating the HTTPS flag, and providing paths to the SSL private key and public certificate. Correct key and cert files must be generated using OpenSSL as described in comments. This config is required for secure API access over TLS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_8\n\nLANGUAGE: srs config\nCODE:\n```\n```\\nhttp_api {\\n    enabled         on;\\n    listen          1985;\\n    https {\\n        # Whether enable HTTPS API.\\n        # default: off\\n        enabled on;\\n        # The listen endpoint for HTTPS API.\\n        # default: 1990\\n        listen 1990;\\n        # The SSL private key file, generated by:\\n        #       openssl genrsa -out server.key 2048\\n        # default: ./conf/server.key\\n        key ./conf/server.key;\\n        # The SSL public cert file, generated by:\\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\\n        # default: ./conf/server.crt\\n        cert ./conf/server.crt;\\n    }\\n}\\n```\n```\n\n----------------------------------------\n\nTITLE: Looped FFMPEG Stream Publishing for SRS - Bash\nDESCRIPTION: This shell script uses a for-loop to continuously publish a local FLV file to the SRS RTMP endpoint using FFMPEG. It assumes FFMPEG is already built and present at the provided relative path, with a source video available. The loop ensures the stream restarts if it ends, introducing a one-second delay between iterations. Key parameters include the path to 'source.flv' and destination RTMP URL.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-dash.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Disabling iptables Firewall for SRS\nDESCRIPTION: Commands to disable the iptables firewall which might block SRS streaming connections. This turns off the firewall immediately and prevents it from starting on system boot.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/install.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# disable the firewall\nsudo /etc/init.d/iptables stop\nsudo /sbin/chkconfig iptables off\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for Live Streaming\nDESCRIPTION: Starts an SRS server instance using the `ossrs/srs:4` Docker image. It maps standard ports for RTMP (1935), HTTP API (1985), and HTTP streaming (8080). The server is configured using `conf/docker.conf` located inside the container.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    ossrs/srs:4 ./objs/srs -c conf/docker.conf\n```\n\n----------------------------------------\n\nTITLE: Deploying SRS Edge Servers on Kubernetes\nDESCRIPTION: This YAML configuration sets up a Kubernetes deployment for SRS edge servers. It creates a ConfigMap for the SRS edge configuration, deploys multiple replicas of SRS edge servers, and creates a LoadBalancer service for external access to the edge servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-service;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-edge-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-edge\n  ports:\n  - name: srs-edge-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-edge-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS HTTP API and Statistics\nDESCRIPTION: An example SRS configuration block showing how to enable and configure the HTTP API (`http_api`), system statistics (`stats`), raw API access (`raw_api`), authentication (`auth`), and HTTPS support (`https`). Key parameters include listen ports, cross-domain settings, network interface index for stats, disk names for I/O stats, raw API enablement flags, basic authentication credentials, and HTTPS key/certificate paths.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\n# system statistics section.\n# the main cycle will retrieve the system stat,\n# for example, the cpu/mem/network/disk-io data,\n# the http api, for instance, /api/v1/summaries will show these data.\n# @remark the heartbeat depends on the network,\n#       for example, the eth0 maybe the device which index is 0.\nstats {\n    # the index of device ip.\n    # we may retrieve more than one network device.\n    # default: 0\n    network         0;\n    # the device name to stat the disk iops.\n    # ignore the device of /proc/diskstats if not configed.\n    disk            sda sdb xvda xvdb;\n}\n# api of srs.\n# the http api config, export for external program to manage srs.\n# user can access http api of srs in browser directly, for instance, to access by:\n#       curl http://192.168.1.170:1985/api/v1/reload\n# which will reload srs, like cmd killall -1 srs, but the js can also invoke the http api,\n# where the cli can only be used in shell/terminate.\nhttp_api {\n    # whether http api is enabled.\n    # default: off\n    enabled         on;\n    # the http api listen entry is <[ip:]port>\n    # for example, 192.168.1.100:1985\n    # where the ip is optional, default to 0.0.0.0, that is 1985 equals to 0.0.0.0:1985\n    # default: 1985\n    listen          1985;\n    # whether enable crossdomain request.\n    # default: on\n    crossdomain     on;\n    # the HTTP RAW API is more powerful api to change srs state and reload.\n    raw_api {\n        # whether enable the HTTP RAW API.\n        # Overwrite by env SRS_HTTP_API_RAW_API_ENABLED\n        # default: off\n        enabled off;\n        # whether enable rpc reload.\n        # Overwrite by env SRS_HTTP_API_RAW_API_ALLOW_RELOAD\n        # default: off\n        allow_reload off;\n        # whether enable rpc query.\n        # Always off by https://github.com/ossrs/srs/issues/2653\n        #allow_query off;\n        # whether enable rpc update.\n        # Always off by https://github.com/ossrs/srs/issues/2653\n        #allow_update off;\n    }\n    # the auth is authentication for http api\n    auth {\n        # whether enable the HTTP AUTH.\n        # Overwrite by env SRS_HTTP_API_AUTH_ENABLED\n        # default: off\n        enabled         on;\n        # The username of Basic authentication:\n        # Overwrite by env SRS_HTTP_API_AUTH_USERNAME\n        username        admin;\n        # The password of Basic authentication:\n        # Overwrite by env SRS_HTTP_API_AUTH_PASSWORD\n        password        admin;\n    }\n    # For https_api or HTTPS API.\n    https {\n        # Whether enable HTTPS API.\n        # default: off\n        enabled on;\n        # The listen endpoint for HTTPS API.\n        # default: 1986\n        listen 1986;\n        # The SSL private key file, generated by:\n        #       openssl genrsa -out server.key 2048\n        # default: ./conf/server.key\n        key ./conf/server.key;\n        # The SSL public cert file, generated by:\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\n        # default: ./conf/server.crt\n        cert ./conf/server.crt;\n    }\n}\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Configure and build SRS from source code in the trunk directory\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS HTTPS API\nDESCRIPTION: A specific SRS configuration snippet detailing how to enable and configure the HTTPS API within the `http_api` block. It shows setting `enabled` to `on` within the `https` section, specifying the `listen` port (e.g., 1990), and providing paths to the SSL private key (`key`) and public certificate (`cert`) files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nhttp_api {\n    enabled         on;\n    listen          1985;\n    https {\n        # Whether enable HTTPS API.\n        # default: off\n        enabled on;\n        # The listen endpoint for HTTPS API.\n        # default: 1990\n        listen 1990;\n        # The SSL private key file, generated by:\n        #       openssl genrsa -out server.key 2048\n        # default: ./conf/server.key\n        key ./conf/server.key;\n        # The SSL public cert file, generated by:\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\n        # default: ./conf/server.crt\n        cert ./conf/server.crt;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server in SRS\nDESCRIPTION: Complete configuration template for SRT server in SRS, including network parameters, security settings, and latency controls. This snippet shows all available options with their default values and environment variable overrides.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    # whether SRT server is enabled.\n    # Overwrite by env SRS_SRT_SERVER_ENABLED\n    # default: off\n    enabled on;\n    # The UDP listen port for SRT.\n    # Overwrite by env SRS_SRT_SERVER_LISTEN\n    listen 10080;\n    # For detail parameters, please read wiki:\n    # @see https://ossrs.net/lts/zh-cn/docs/v5/doc/srt-params\n    # @see https://ossrs.io/lts/en-us/docs/v5/doc/srt-params\n    # The maxbw is the max bandwidth of the sender side.\n    # \t-1: Means the biggest bandwidth is infinity.\n    # \t 0: Means the bandwidth is determined by SRTO_INPUTBW.\n    # \t>0: Means the bandwidth is the configuration value.\n    # Overwrite by env SRS_SRT_SERVER_MAXBW\n    # default: -1\n    maxbw 1000000000;\n    # Maximum Segment Size. Used for buffer allocation and rate calculation using packet counter assuming fully\n    # filled packets. Each party can set its own MSS value independently. During a handshake the parties exchange\n    # MSS values, and the lowest is used.\n    # Overwrite by env SRS_SRT_SERVER_MSS\n    # default: 1500\n    mss 1500;\n    # The timeout time of the SRT connection on the sender side in ms. When SRT connects to a peer costs time \n    # more than this config, it will be close.\n    # Overwrite by env SRS_SRT_SERVER_CONNECT_TIMEOUT\n    # default: 3000\n    connect_timeout 4000;\n\t# The timeout time of SRT connection on the receiver side in ms. When the SRT connection is idle \n    # more than this config, it will be close.\n    # Overwrite by env SRS_SRT_SERVER_PEER_IDLE_TIMEOUT\n    # default: 10000\n    peer_idle_timeout 8000;\n    # Default app for vmix, see https://github.com/ossrs/srs/pull/1615\n    # Overwrite by env SRS_SRT_SERVER_DEFAULT_APP\n    # default: live\n    default_app live;\n\t# The peerlatency is set by the sender side and will notify the receiver side.\n    # Overwrite by env SRS_SRT_SERVER_PEERLATENCY\n    # default: 0\n    peerlatency 0;\n\t# The recvlatency means latency from sender to receiver.\n    # Overwrite by env SRS_SRT_SERVER_RECVLATENCY\n    # default: 120\n    recvlatency 0;\n\t# This latency configuration configures both recvlatency and peerlatency to the same value.\n    # Overwrite by env SRS_SRT_SERVER_LATENCY\n    # default: 120\n    latency 0;\n\t# The tsbpd mode means timestamp based packet delivery.\n\t# SRT sender side will pack timestamp in each packet. If this config is true,\n\t# the receiver will read the packet according to the timestamp in the head of the packet.\n    # Overwrite by env SRS_SRT_SERVER_TSBPDMODE\n    # default: on\n    tsbpdmode off;\n\t# The tlpkdrop means too-late Packet Drop\n\t# SRT sender side will pack timestamp in each packet, When the network is congested,\n\t# the packet will drop if latency is bigger than the configuration in both sender side and receiver side.\n\t# And on the sender side, it also will be dropped because latency is bigger than configuration.\n    # Overwrite by env SRS_SRT_SERVER_TLPKTDROP\n    # default: on\n    tlpktdrop off;\n\t# The send buffer size of SRT.\n    # Overwrite by env SRS_SRT_SERVER_SENDBUF\n    # default:  8192 * (1500-28)\n    sendbuf 2000000;\n\t# The recv buffer size of SRT.\n    # Overwrite by env SRS_SRT_SERVER_RECVBUF\n    # default:  8192 * (1500-28)\n    recvbuf 2000000;\n    # The passphrase of SRT.\n    # If passphrase is no empty, all the srt client must be using the correct passphrase to publish or play,\n    # or the srt connection will reject. The length of passphrase must be in range 10~79.\n    # @see https://github.com/Haivision/srt/blob/master/docs/API/API-socket-options.md#srto_passphrase.\n    # Overwrite by env SRS_SRT_SERVER_PASSPHRASE\n    # default: \"\"\n    passphrase xxxxxxxxxxxx;\n    # The pbkeylen of SRT.\n    # The pbkeylen determined the AES encrypt algorithm, this option only allow 4 values which is 0, 16, 24, 32\n    # @see https://github.com/Haivision/srt/blob/master/docs/API/API-socket-options.md#srto_pbkeylen.\n    # Overwrite by env SRS_SRT_SERVER_PBKEYLEN\n    # default: 0\n    pbkeylen 16;\n}\nvhost __defaultVhost__ {\n    srt {\n        # Whether enable SRT on this vhost.\n        # Overwrite by env SRS_VHOST_SRT_ENABLED for all vhosts.\n        # Default: off\n        enabled on;\n        # Whether covert SRT to RTMP stream.\n        # Overwrite by env SRS_VHOST_SRT_TO_RTMP for all vhosts.\n        # Default: on\n        srt_to_rtmp on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source - Bash\nDESCRIPTION: This sequence of commands changes directory to 'srs/trunk', configures the build environment, and then compiles the SRS server. The commands require a Unix-like shell, standard build tools (like make), and necessary dependencies for SRS compilation. Output artifacts (executables) are placed under the 'objs' directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP-FLV Server Configuration\nDESCRIPTION: Complete configuration for HTTP-FLV streaming including server settings and virtual host configuration with detailed parameters for stream handling\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/flv.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    enabled on;\n    listen 8080;\n    crossdomain on;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled on;\n        fast_cache 30;\n        drop_if_not_match on;\n        has_audio on;\n        has_video on;\n        guess_has_av on;\n        mount [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for Low Latency RTMP - SRS Config\nDESCRIPTION: This configuration file snippet sets up SRS for low-latency RTMP streaming. It listens on port 1935, allows up to 1000 connections, and defines default vhost settings for minimal latency and zero GOP cache. Parameters such as 'mw_latency', 'queue_length', and 'gop_cache' are set to optimize for latency. The config should be saved as 'conf/realtime.conf' and is referenced when launching SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-realtime.md#2025-04-23_snippet_3\n\nLANGUAGE: conf\nCODE:\n```\n# conf/realtime.conf\\nlisten              1935;\\nmax_connections     1000;\\nvhost __defaultVhost__ {\\n    tcp_nodelay     on;\\n    min_latency     on;\\n\\n    play {\\n        gop_cache       off;\\n        queue_length    10;\\n        mw_latency      100;\\n    }\\n\\n    publish {\\n        mr off;\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebRTC Server and Vhost Settings in SRS\nDESCRIPTION: This snippet shows the configuration options for the WebRTC server and vhost settings in SRS. It includes settings for UDP and TCP listening, candidate selection, and various WebRTC features like NACK and TWCC.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    enabled on;\n    listen 8000;\n    tcp {\n        enabled off;\n        listen 8000;\n    }\n    protocol udp;\n    candidate *;\n}\n\nvhost rtc.vhost.srs.com {\n    rtc {\n        enabled on;\n        nack on;\n        twcc on;\n        rtmp_to_rtc off;\n        rtc_to_rtmp off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Service with LoadBalancer for SRS and Nginx\nDESCRIPTION: YAML configuration to create a Kubernetes LoadBalancer Service that exposes SRS and Nginx ports to external traffic. Exposes RTMP (1935), HTTP API (1985), and HTTP-FLV (8080) served by SRS, and HLS (80) served by Nginx.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-origin-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-origin-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-origin-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Settings in SRS\nDESCRIPTION: This snippet demonstrates the configuration of HLS (HTTP Live Streaming) settings within an SRS vhost block. It includes options for enabling HLS, setting fragment durations, managing m3u8 and ts files, configuring codecs, and setting up encryption.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether the hls is enabled.\n        # if off, do not write hls(ts and m3u8) when publish.\n        # Overwrite by env SRS_VHOST_HLS_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n\n        # the hls fragment in seconds, the duration of a piece of ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENT for all vhosts.\n        # default: 10\n        hls_fragment 10;\n        # the hls m3u8 target duration ratio,\n        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init\n        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts\n        # Overwrite by env SRS_VHOST_HLS_HLS_TD_RATIO for all vhosts.\n        # default: 1.0\n        hls_td_ratio 1.0;\n        # the audio overflow ratio.\n        # for pure audio, the duration to reap the segment.\n        # for example, the hls_fragment is 10s, hls_aof_ratio is 1.2,\n        # the segment will reap to 12s for pure audio.\n        # Overwrite by env SRS_VHOST_HLS_HLS_AOF_RATIO for all vhosts.\n        # default: 1.2\n        hls_aof_ratio 1.2;\n        # the hls window in seconds, the number of ts in m3u8.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WINDOW for all vhosts.\n        # default: 60\n        hls_window 60;\n        # the error strategy. can be:\n        #       ignore, disable the hls.\n        #       disconnect, require encoder republish.\n        #       continue, ignore failed try to continue output hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_ON_ERROR for all vhosts.\n        # default: continue\n        hls_on_error continue;\n        # the hls output path.\n        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream].m3u8\n        # the ts file is configured by hls_path/hls_ts_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream]-[seq].ts\n        # @remark the hls_path is compatible with srs v1 config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_PATH for all vhosts.\n        # default: ./objs/nginx/html\n        hls_path ./objs/nginx/html;\n        # the hls m3u8 file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        # Overwrite by env SRS_VHOST_HLS_HLS_M3U8_FILE for all vhosts.\n        # default: [app]/[stream].m3u8\n        hls_m3u8_file [app]/[stream].m3u8;\n        # the hls ts file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        #       [seq], the sequence number of ts.\n        #       [duration], replace this const to current ts duration.\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#hls-config\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FILE for all vhosts.\n        # default: [app]/[stream]-[seq].ts\n        hls_ts_file [app]/[stream]-[seq].ts;\n        # the hls entry prefix, which is base url of ts url.\n        # for example, the prefix is:\n        #         http://your-server/\n        # then, the ts path in m3u8 will be like:\n        #         http://your-server/live/livestream-0.ts\n        #         http://your-server/live/livestream-1.ts\n        #         ...\n        # Overwrite by env SRS_VHOST_HLS_HLS_ENTRY_PREFIX for all vhosts.\n        # optional, default to empty string.\n        hls_entry_prefix http://your-server;\n        # the default audio codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for mp3.\n        # the available audio codec:\n        #       aac, mp3, an\n        # Overwrite by env SRS_VHOST_HLS_HLS_ACODEC for all vhosts.\n        # default: aac\n        hls_acodec aac;\n        # the default video codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for pure audio(without video) to vn.\n        # the available video codec:\n        #       h264, vn\n        # Overwrite by env SRS_VHOST_HLS_HLS_VCODEC for all vhosts.\n        # default: h264\n        hls_vcodec h264;\n        # whether cleanup the old expired ts files.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CLEANUP for all vhosts.\n        # default: on\n        hls_cleanup on;\n        # If there is no incoming packets, dispose HLS in this timeout in seconds,\n        # which removes all HLS files including m3u8 and ts files.\n        # @remark 0 to disable dispose for publisher.\n        # @remark apply for publisher timeout only, while \"etc/init.d/srs stop\" always dispose hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DISPOSE for all vhosts.\n        # default: 120\n        hls_dispose 120;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WAIT_KEYFRAME for all vhosts.\n        # default: on\n        hls_wait_keyframe on;\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enhanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FLOOR for all vhosts.\n        # default: off\n        hls_ts_floor off;\n        # the max size to notify hls,\n        # to read max bytes from ts of specified cdn network,\n        # @remark only used when on_hls_notify is config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_NB_NOTIFY for all vhosts.\n        # default: 64\n        hls_nb_notify 64;\n\n        # Whether enable hls_ctx for HLS streaming, for which we create a \"fake\" connection for HTTP API and callback.\n        # For each HLS streaming session, we use a child m3u8 with a session identified by query \"hls_ctx\", it simply\n        # work as the session id.\n        # Once the HLS streaming session is created, we will cleanup it when timeout in 2*hls_window seconds. So it\n        # takes a long time period to identify the timeout.\n        # Now we got a HLS stremaing session, just like RTMP/WebRTC/HTTP-FLV streaming, we're able to stat the session\n        # as a \"fake\" connection, do HTTP callback when start playing the HLS streaming. You're able to do querying and\n        # authentication.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CTX for all vhosts.\n        # Default: on\n        hls_ctx on;\n        # For HLS pseudo streaming, whether enable the session for each TS segment.\n        # If enabled, SRS HTTP API will show the statistics about HLS streaming bandwidth, both m3u8 and ts file. Please\n        # note that it also consumes resource, because each ts file should be served by SRS, all NGINX cache will be\n        # missed because we add session id to each ts file.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_CTX for all vhosts.\n        # Default: on\n        hls_ts_ctx on;\n\n        # whether using AES encryption.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEYS for all vhosts.\n        # default: off\n        hls_keys on;\n        # the number of clear ts which one key can encrypt.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENTS_PER_KEY for all vhosts.\n        # default: 5\n        hls_fragments_per_key 5;\n        # the hls key file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [seq], the sequence number of key corresponding to the ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE for all vhosts.\n        hls_key_file [app]/[stream]-[seq].key;\n        # the key output path.\n        # the key file is configed by hls_path/hls_key_file, the default is:\n        # ./objs/nginx/html/[app]/[stream]-[seq].key\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE_PATH for all vhosts.\n        hls_key_file_path ./objs/nginx/html;\n        # the key root URL, use this can support https.\n        # @remark It's optional.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_URL for all vhosts.\n        hls_key_url https://localhost:8080;\n\n        # Special control controls.\n        ###########################################\n        # Whether calculate the DTS of audio frame directly.\n        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544\n        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.\n        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DTS_DIRECTLY for all vhosts.\n        # Default: on\n        hls_dts_directly on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Slave SRS Instance (Bash)\nDESCRIPTION: Starts the slave SRS server process using the specified configuration file (`conf/forward.slave.conf`). Assumes the SRS binary is located at `./objs/srs` and the configuration file exists at the specified path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/forward.slave.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for FFMPEG Transcoding (Config)\nDESCRIPTION: Defines the SRS server configuration (`conf/ffmpeg.transcode.conf`) to enable live stream transcoding. It specifies the listening port, enables the `transcode` module within the default vhost, sets the path to the FFMPEG executable, and configures a transcoding engine named `ff` with specific video (libx264) and audio (libfdk_aac) codecs, bitrates, resolution, frame rate, and the output RTMP URL pattern for the transcoded stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: properties\nCODE:\n```\n# conf/ffmpeg.transcode.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Scalable Architecture with Edge Servers for Viewer Distribution\nDESCRIPTION: Comprehensive diagram showing a large-scale deployment with edge servers for viewer distribution, proxy servers for stream routing, and origin servers for stream hosting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n+------------------+                                               +--------------------+\n+ SRS Edge Server  +--+                                    +-------+ SRS Origin Server  +\n+------------------+  +                                    +       +--------------------+\n                      +                                    +\n+------------------+  +     +-----------------------+      +       +--------------------+\n+ SRS Edge Server  +--+-----+ SRS Proxy(Deployment) +------+-------+ SRS Origin Server  +\n+------------------+  +     +-----------------------+      +       +--------------------+\n                      +                                    +\n+------------------+  +                                    +       +--------------------+\n+ SRS Edge Server  +--+                                    +-------+ SRS Origin Server  +\n+------------------+                                               +--------------------+\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: Command to publish a stream to SRS using FFmpeg with FLV source file\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Master SRS for Stream Forwarding (SRS Conf)\nDESCRIPTION: Defines the configuration for the master SRS instance. It listens on port 1935, sets log file paths, and enables the forward feature within the default virtual host, specifying the destination slave server at `127.0.0.1:19350`. This content should be saved to a file, e.g., `conf/forward.master.conf`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n# conf/forward.master.conf\nlisten              1935;\nmax_connections     1000;\npid                 ./objs/srs.master.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.master.log;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebRTC Server and VHost in SRS\nDESCRIPTION: Example configuration for WebRTC server and vhost settings in SRS, including UDP/TCP listeners, candidate protocol, NACK, TWCC, and RTMP/RTC conversion options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    enabled on;\n    listen 8000;\n    tcp {\n        enabled off;\n        listen 8000;\n    }\n    protocol udp;\n    candidate *;\n}\n\nvhost rtc.vhost.srs.com {\n    rtc {\n        enabled on;\n        nack on;\n        twcc on;\n        stun_timeout 30;\n        dtls_role passive;\n        rtmp_to_rtc off;\n        rtc_to_rtmp off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying SRS Origin Server in Kubernetes\nDESCRIPTION: Creates a Kubernetes Deployment for running a single SRS origin server. This deployment uses the official SRS Docker image and exposes necessary ports for RTMP, HTTP, and API services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deploy\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n```\n\n----------------------------------------\n\nTITLE: FFmpeg HEVC RTMP Streaming to SRS\nDESCRIPTION: Commands to use FFmpeg for streaming HEVC content via RTMP to SRS, for both macOS and Linux environments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-03-07-Lets-Do-H265-Live-Streaming.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\ndocker run --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n\n# For linux\ndocker run --net=host --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx with Docker\nDESCRIPTION: Command to run Oryx in a Docker container with persistent data storage and port forwarding for HTTP, HTTPS, RTMP, WebRTC, and SRT protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: SRS RTMP to WebRTC Configuration\nDESCRIPTION: Docker command to run SRS with RTMP to WebRTC transcoding configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC over TCP\nDESCRIPTION: Docker command to run SRS with WebRTC over TCP enabled on port 8000. This configuration allows WebRTC to work in networks where UDP is not available.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080 -p 1985:1985 -p 8000:8000 \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8000 \\\n  ossrs/srs:v5\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for WebRTC\nDESCRIPTION: Starts an SRS server configured for WebRTC using `conf/docker.conf`. It sets the `CANDIDATE` environment variable to the server's public or reachable IP address, which is crucial for WebRTC NAT traversal. Additional ports for WebRTC API (1990), HTTPS (8088), and UDP (8000) are mapped alongside standard ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:4 ./objs/srs -c conf/docker.conf\n```\n\n----------------------------------------\n\nTITLE: Applying SRS Edge Configuration via Kubernetes ConfigMap (YAML/Bash)\nDESCRIPTION: This snippet uses a bash heredoc (`cat <<EOF | kubectl apply -f -`) to define and apply a Kubernetes ConfigMap named 'srs-edge-config'. The ConfigMap stores the SRS Edge configuration (`srs.conf`), including listener ports (1935, 1985 for API, 8080 for HTTP server), connection limits, disabling daemon mode, setting graceful shutdown wait times (`grace_start_wait`, `grace_final_wait`), enabling forced graceful quit (`force_grace_quit`), enabling HTTP API and server, and configuring the cluster mode to connect to origin servers (`srs-origin-0.socs`, etc.). The Chinese remarks emphasize enabling `force_grace_quit` for graceful updates and setting short grace periods in K8s.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    grace_start_wait    700;\n    grace_final_wait    800;\n    force_grace_quit    on;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-0.socs srs-origin-1.socs srs-origin-2.socs;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Mode in SRS vhost\nDESCRIPTION: This snippet shows how to configure a vhost in SRS as an edge server, specifying the origin server(s) and other edge-related settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/edge.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            remote;\n\n        # For edge(mode remote), user must specifies the origin server\n        # format as: <server_name|ip>[:port]\n        # @remark user can specifies multiple origin for error backup, by space,\n        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935\n        origin          127.0.0.1:1935 localhost:1935;\n\n        # For edge(mode remote), whether open the token traverse mode,\n        # if token traverse on, all connections of edge will forward to origin to check(auth),\n        # it's very important for the edge to do the token auth.\n        # the better way is use http callback to do the token auth by the edge,\n        # but if user prefer origin check(auth), the token_traverse if better solution.\n        # default: off\n        token_traverse  off;\n\n        # For edge(mode remote), the vhost to transform for edge,\n        # to fetch from the specified vhost at origin,\n        # if not specified, use the current vhost of edge in origin, the variable [vhost].\n        # default: [vhost]\n        vhost           same.edge.srs.com;\n\n        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,\n        # it's strongly recommend to open the debug_srs_upnode,\n        # when connect to upnode, it will take the debug info,\n        # for example, the id, source id, pid.\n        # please see https://ossrs.net/lts/zh-cn/docs/v4/doc/log\n        # default: on\n        debug_srs_upnode    on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Publishing Settings in SRS\nDESCRIPTION: This snippet demonstrates the configuration options for RTMP publishing in SRS, including merged-read settings, timeouts, and SPS parsing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npublish {\n    mr off;\n    mr_latency 350;\n    firstpkt_timeout 20000;\n    normal_timeout 7000;\n    parse_sps on;\n    try_annexb_first on;\n    kickoff_for_idle 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Proxy Cache in NGINX for HLS Streaming - NGINX\nDESCRIPTION: Configures NGINX to act as a reverse proxy cache for HLS streams, differentiating caching strategies for .m3u8 and .ts files. Requires NGINX with http_proxy_module and sufficient access to cache directories. Key directives: proxy_cache_path, proxy_temp_path, proxy_cache_key, proxy_cache_valid, and relevant location blocks for HLS segment and playlist extensions. Inputs: client HLS requests. Outputs: cached or proxied HLS content. Adjust cache sizes and timeouts as appropriate for deployment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\nhttp {\\n    # For Proxy Cache.\\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\\n    proxy_temp_path /tmp/nginx-cache/tmp; \\n\\n    server {\\n        listen       8081;\\n        # For Proxy Cache.\\n        proxy_cache_valid  404      10s;\\n        proxy_cache_lock on;\\n        proxy_cache_lock_age 300s;\\n        proxy_cache_lock_timeout 300s;\\n        proxy_cache_min_uses 1;\\n\\n        location ~ /.+/.*\\.(m3u8)$ {\\n            proxy_pass http://127.0.0.1:8080$request_uri;\\n            # For Proxy Cache.\\n            proxy_cache srs_cache;\\n            proxy_cache_key $scheme$proxy_host$uri$args;\\n            proxy_cache_valid  200 302  10s;\\n        }\\n        location ~ /.+/.*\\.(ts)$ {\\n            proxy_pass http://127.0.0.1:8080$request_uri;\\n            # For Proxy Cache.\\n            proxy_cache srs_cache;\\n            proxy_cache_key $scheme$proxy_host$uri;\\n            proxy_cache_valid  200 302  60m;\\n        }\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding and Publishing Stream with FFmpeg\nDESCRIPTION: Bash script to continuously encode a source video file and publish it as an RTMP stream to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-dash.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with WebRTC Candidate IP\nDESCRIPTION: Command to start SRS with the WebRTC candidate IP set via an environment variable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nenv CANDIDATE=\"192.168.3.10\" \\\n  ./objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Parameters for FMLE (Plaintext)\nDESCRIPTION: Provides the necessary parameters for configuring Adobe Flash Media Live Encoder (FMLE) to publish a stream to the SRS server. The 'FMS URL' specifies the RTMP endpoint, and 'Stream' defines the stream name. Replace '192.168.1.170' with the actual server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ffmpeg.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS with HTTP Callback Enabled - Bash\nDESCRIPTION: This snippet demonstrates how to start the SRS streaming server with a specific configuration file that enables HTTP callback hooks. The dependency is the SRS binary executable and the provided configuration file named 'http.hooks.callback.conf'. The command initializes SRS with hook support so that subsequent streaming events can trigger HTTP callbacks. The expected output is that SRS will begin listening for RTMP streams and responding to HTTP hook events as configured.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.hooks.callback.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for HLS with Audio Transcoding (SRS Conf)\nDESCRIPTION: Provides an example SRS configuration file (`conf/transcode2hls.audio.only.conf`). It configures SRS to listen for RTMP on port 1935, serve HTTP on port 8080 for HLS, enables HLS output in the default virtual host, and sets up a transcoding engine named 'ff'. This engine uses FFmpeg, copies the video codec (`vcodec copy`), transcodes audio to AAC (`acodec libfdk_aac`) with specified parameters (45kbps bitrate, 44.1kHz sample rate, stereo), and outputs the transcoded stream to RTMP with an `_ff` suffix.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: srs_conf\nCODE:\n```\n# conf/transcode2hls.audio.only.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Service for SRS with LoadBalancer\nDESCRIPTION: This YAML manifest creates a Kubernetes LoadBalancer service that exposes the SRS and Nginx ports to the external network. It maps ports for RTMP (1935), HTTP API (1985), HTTP-FLV (8080), and HLS via Nginx (80) to the corresponding container ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-origin-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-origin-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-origin-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: SRS HLS Vhost Configuration Block (Bash)\nDESCRIPTION: This configuration snippet defines settings for HLS within a specific SRS vhost (`__defaultVhost__`). It controls enabling/disabling HLS (`enabled`), segment duration (`hls_fragment`), playlist window size (`hls_window`), output paths (`hls_path`), M3U8 (`hls_m3u8_file`) and TS (`hls_ts_file`) naming patterns using variables like `[app]` and `[stream]`, codec defaults (`hls_acodec`, `hls_vcodec`), error handling (`hls_on_error`), cleanup policies (`hls_cleanup`), session contexts (`hls_ctx`, `hls_ts_ctx`), AES encryption (`hls_keys`), key management (`hls_key_file`, `hls_key_file_path`, `hls_key_url`), and other advanced options like keyframe waiting (`hls_wait_keyframe`) and DTS calculation (`hls_dts_directly`). Many options can be overridden by environment variables (e.g., `SRS_VHOST_HLS_ENABLED`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether the hls is enabled.\n        # if off, do not write hls(ts and m3u8) when publish.\n        # Overwrite by env SRS_VHOST_HLS_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n\n        # the hls fragment in seconds, the duration of a piece of ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENT for all vhosts.\n        # default: 10\n        hls_fragment 10;\n        # the hls m3u8 target duration ratio,\n        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init\n        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts\n        # Overwrite by env SRS_VHOST_HLS_HLS_TD_RATIO for all vhosts.\n        # default: 1.0\n        hls_td_ratio 1.0;\n        # the audio overflow ratio.\n        # for pure audio, the duration to reap the segment.\n        # for example, the hls_fragment is 10s, hls_aof_ratio is 1.2,\n        # the segment will reap to 12s for pure audio.\n        # Overwrite by env SRS_VHOST_HLS_HLS_AOF_RATIO for all vhosts.\n        # default: 1.2\n        hls_aof_ratio 1.2;\n        # the hls window in seconds, the number of ts in m3u8.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WINDOW for all vhosts.\n        # default: 60\n        hls_window 60;\n        # the error strategy. can be:\n        #       ignore, disable the hls.\n        #       disconnect, require encoder republish.\n        #       continue, ignore failed try to continue output hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_ON_ERROR for all vhosts.\n        # default: continue\n        hls_on_error continue;\n        # the hls output path.\n        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream].m3u8\n        # the ts file is configured by hls_path/hls_ts_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream]-[seq].ts\n        # @remark the hls_path is compatible with srs v1 config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_PATH for all vhosts.\n        # default: ./objs/nginx/html\n        hls_path ./objs/nginx/html;\n        # the hls m3u8 file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        # Overwrite by env SRS_VHOST_HLS_HLS_M3U8_FILE for all vhosts.\n        # default: [app]/[stream].m3u8\n        hls_m3u8_file [app]/[stream].m3u8;\n        # the hls ts file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        #       [seq], the sequence number of ts.\n        #       [duration], replace this const to current ts duration.\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#hls-config\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FILE for all vhosts.\n        # default: [app]/[stream]-[seq].ts\n        hls_ts_file [app]/[stream]-[seq].ts;\n        # the hls entry prefix, which is base url of ts url.\n        # for example, the prefix is:\n        #         http://your-server/\n        # then, the ts path in m3u8 will be like:\n        #         http://your-server/live/livestream-0.ts\n        #         http://your-server/live/livestream-1.ts\n        #         ...\n        # Overwrite by env SRS_VHOST_HLS_HLS_ENTRY_PREFIX for all vhosts.\n        # optional, default to empty string.\n        hls_entry_prefix http://your-server;\n        # the default audio codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for mp3.\n        # the available audio codec:\n        #       aac, mp3, an\n        # Overwrite by env SRS_VHOST_HLS_HLS_ACODEC for all vhosts.\n        # default: aac\n        hls_acodec aac;\n        # the default video codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for pure audio(without video) to vn.\n        # the available video codec:\n        #       h264, vn\n        # Overwrite by env SRS_VHOST_HLS_HLS_VCODEC for all vhosts.\n        # default: h264\n        hls_vcodec h264;\n        # whether cleanup the old expired ts files.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CLEANUP for all vhosts.\n        # default: on\n        hls_cleanup on;\n        # If there is no incoming packets, dispose HLS in this timeout in seconds,\n        # which removes all HLS files including m3u8 and ts files.\n        # @remark 0 to disable dispose for publisher.\n        # @remark apply for publisher timeout only, while \"etc/init.d/srs stop\" always dispose hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DISPOSE for all vhosts.\n        # default: 120\n        hls_dispose 120;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WAIT_KEYFRAME for all vhosts.\n        # default: on\n        hls_wait_keyframe on;\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enhanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FLOOR for all vhosts.\n        # default: off\n        hls_ts_floor off;\n        # the max size to notify hls,\n        # to read max bytes from ts of specified cdn network,\n        # @remark only used when on_hls_notify is config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_NB_NOTIFY for all vhosts.\n        # default: 64\n        hls_nb_notify 64;\n\n        # Whether enable hls_ctx for HLS streaming, for which we create a \"fake\" connection for HTTP API and callback.\n        # For each HLS streaming session, we use a child m3u8 with a session identified by query \"hls_ctx\", it simply\n        # work as the session id.\n        # Once the HLS streaming session is created, we will cleanup it when timeout in 2*hls_window seconds. So it\n        # takes a long time period to identify the timeout.\n        # Now we got a HLS stremaing session, just like RTMP/WebRTC/HTTP-FLV streaming, we're able to stat the session\n        # as a \"fake\" connection, do HTTP callback when start playing the HLS streaming. You're able to do querying and\n        # authentication.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CTX for all vhosts.\n        # Default: on\n        hls_ctx on;\n        # For HLS pseudo streaming, whether enable the session for each TS segment.\n        # If enabled, SRS HTTP API will show the statistics about HLS streaming bandwidth, both m3u8 and ts file. Please\n        # note that it also consumes resource, because each ts file should be served by SRS, all NGINX cache will be\n        # missed because we add session id to each ts file.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_CTX for all vhosts.\n        # Default: on\n        hls_ts_ctx on;\n\n        # whether using AES encryption.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEYS for all vhosts.\n        # default: off\n        hls_keys on;\n        # the number of clear ts which one key can encrypt.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENTS_PER_KEY for all vhosts.\n        # default: 5\n        hls_fragments_per_key 5;\n        # the hls key file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [seq], the sequence number of key corresponding to the ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE for all vhosts.\n        hls_key_file [app]/[stream]-[seq].key;\n        # the key output path.\n        # the key file is configed by hls_path/hls_key_file, the default is:\n        # ./objs/nginx/html/[app]/[stream]-[seq].key\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE_PATH for all vhosts.\n        hls_key_file_path ./objs/nginx/html;\n        # the key root URL, use this can support https.\n        # @remark It's optional.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_URL for all vhosts.\n        hls_key_url https://localhost:8080;\n\n        # Special control controls.\n        ###########################################\n        # Whether calculate the DTS of audio frame directly.\n        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544\n        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.\n        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DTS_DIRECTLY for all vhosts.\n        # Default: on\n        hls_dts_directly on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing RTMP Stream to SRS Origin using FFmpeg (Bash)\nDESCRIPTION: This bash script uses FFmpeg in an infinite loop to continuously re-stream a local FLV file (`./doc/source.flv`) to the first SRS origin server (listening on 192.168.1.170:19350) under the application `live` and stream key `livestream`. The `-re` flag simulates a live stream's native frame rate, `-c copy` prevents re-encoding, and `sleep 1` adds a delay between loops.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx with HELM Chart - Bash\nDESCRIPTION: This Bash snippet demonstrates deployment of Oryx using HELM (Helm chart) in a Kubernetes environment. It first adds the SRS Helm repository, then installs Oryx with custom settings for persistence and service port mappings for HTTP, HTTPS, RTMP, WebRTC (RTC), and SRT. Dependencies include Helm, Kubernetes, and the ability to pull from the specified repository. Key parameters like 'persistence.path' and service port assignments are configured for customization. The expected output is a running Oryx service in a Kubernetes cluster, accessible via configured ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhelm repo add srs http://helm.ossrs.io/stable\nhelm install srs srs/oryx --set persistence.path=$HOME/data \\\n  --set service.http=80 --set service.https=443 --set service.rtmp=1935 \\\n  --set service.rtc=8000 --set service.srt=10080\n```\n\n----------------------------------------\n\nTITLE: Configuring RTC Server and WebRTC in SRS\nDESCRIPTION: Configuration example for setting up WebRTC in SRS, including the global rtc_server settings and vhost-specific rtc options. Covers UDP/TCP settings, candidate configuration, NACK/TWCC support, and RTMP/RTC transmuxing options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    # Whether enable WebRTC server.\n    # Overwrite by env SRS_RTC_SERVER_ENABLED\n    # default: off\n    enabled on;\n    # The udp listen port, we will reuse it for connections.\n    # Overwrite by env SRS_RTC_SERVER_LISTEN\n    # default: 8000\n    listen 8000;\n    # For WebRTC over TCP directly, not TURN, see https://github.com/ossrs/srs/issues/2852\n    # Some network does not support UDP, or not very well, so we use TCP like HTTP/80 port for firewall traversing.\n    tcp {\n        # Whether enable WebRTC over TCP.\n        # Overwrite by env SRS_RTC_SERVER_TCP_ENABLED\n        # Default: off\n        enabled off;\n        # The TCP listen port for WebRTC. Highly recommend is some normally used ports, such as TCP/80, TCP/443,\n        # TCP/8000, TCP/8080 etc. However SRS default to TCP/8000 corresponding to UDP/8000.\n        # Overwrite by env SRS_RTC_SERVER_TCP_LISTEN\n        # Default: 8000\n        listen 8000;\n    }\n    # The protocol for candidate to use, it can be:\n    #       udp         Generate UDP candidates. Note that UDP server is always enabled for WebRTC.\n    #       tcp         Generate TCP candidates. Fail if rtc_server.tcp(WebRTC over TCP) is disabled.\n    #       all         Generate UDP+TCP candidates. Ignore if rtc_server.tcp(WebRTC over TCP) is disabled.\n    # Note that if both are connected, we will use the first connected(DTLS done) one.\n    # Overwrite by env SRS_RTC_SERVER_PROTOCOL\n    # Default: udp\n    protocol udp;\n    # The exposed candidate IPs, response in SDP candidate line. It can be:\n    #       *           Retrieve server IP automatically, from all network interfaces.\n    #       $CANDIDATE  Read the IP from ENV variable, use * if not set.\n    #       x.x.x.x     A specified IP address or DNS name, use * if 0.0.0.0.\n    # @remark For Firefox, the candidate MUST be IP, MUST NOT be DNS name, see https://bugzilla.mozilla.org/show_bug.cgi?id=1239006\n    # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/webrtc#config-candidate\n    # Overwrite by env SRS_RTC_SERVER_CANDIDATE\n    # default: *\n    candidate *;\n}\n\nvhost rtc.vhost.srs.com {\n    rtc {\n        # Whether enable WebRTC server.\n        # Overwrite by env SRS_VHOST_RTC_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n        # Whether support NACK.\n        # default: on\n        nack on;\n        # Whether support TWCC.\n        # default: on\n        twcc on;\n        # Whether enable transmuxing RTMP to RTC.\n        # If enabled, transcode aac to opus.\n        # Overwrite by env SRS_VHOST_RTC_RTMP_TO_RTC for all vhosts.\n        # default: off\n        rtmp_to_rtc off;\n        # Whether enable transmuxing RTC to RTMP.\n        # Overwrite by env SRS_VHOST_RTC_RTC_TO_RTMP for all vhosts.\n        # Default: off\n        rtc_to_rtmp off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Deployment in Kubernetes\nDESCRIPTION: YAML configuration to deploy SRS origin server as a Kubernetes deployment with 1 replica, exposing RTMP, HTTP, and API ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deployment\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP API Configuration\nDESCRIPTION: Complete configuration example for HTTP API including stats collection, authentication, and HTTPS setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nstats {\n    network         0;\n    disk            sda sdb xvda xvdb;\n}\nhttp_api {\n    enabled         on;\n    listen          1985;\n    crossdomain     on;\n    raw_api {\n        enabled off;\n        allow_reload off;\n    }\n    auth {\n        enabled         on;\n        username        admin;\n        password        admin;\n    }\n    https {\n        enabled on;\n        listen 1986;\n        key ./conf/server.key;\n        cert ./conf/server.crt;\n    }\n}\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Low Latency Configuration for SRS\nDESCRIPTION: This configuration combines various settings to achieve low latency in SRS, including disabling GOP cache, setting short queue length, and adjusting merged-write latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: This command uses FFmpeg to publish a stream to SRS. It takes a source file and publishes it as an RTMP stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring HDS Parameters in SRS (conf)\nDESCRIPTION: This configuration block, typically found within a `vhost` section in the SRS `srs.conf` file, defines the settings for HDS delivery. `enabled on` activates HDS for the vhost. `hds_fragment` sets the duration (in seconds) of each media segment. `hds_window` specifies the duration (in seconds) of the sliding window for live streams. `hds_path` defines the file system directory where SRS will store the generated HDS manifest and segment files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/delivery-hds.md#2025-04-23_snippet_2\n\nLANGUAGE: conf\nCODE:\n```\nvhost __defaultVhost__ {\n    hds {\n        # whether hds enabled\n        # default: off\n        enabled         on;\n        # the hds fragment in seconds.\n        # default: 10\n        hds_fragment    10;\n        # the hds window in seconds, erase the segment when exceed the window.\n        # default: 60\n        hds_window      60;\n        # the path to store the hds files.\n        # default: ./objs/nginx/html\n        hds_path        ./objs/nginx/html;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-realtime.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS WebRTC Server Settings (SRS Conf)\nDESCRIPTION: This configuration snippet shows the structure for enabling and configuring the global WebRTC server (`rtc_server`) and per-vhost settings (`vhost rtc.vhost.srs.com/rtc`) in SRS. Key parameters include enabling the server, setting listen ports (UDP and optional TCP), defining the crucial `candidate` IP, and toggling features like NACK, TWCC, RTMP/RTC conversion, and timeouts. This configuration is typically placed in `srs.conf` or a referenced file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: srs-conf\nCODE:\n```\nrtc_server {\n    # Whether enable WebRTC server.\n    # Overwrite by env SRS_RTC_SERVER_ENABLED\n    # default: off\n    enabled on;\n    # The udp listen port, we will reuse it for connections.\n    # Overwrite by env SRS_RTC_SERVER_LISTEN\n    # default: 8000\n    listen 8000;\n    # For WebRTC over TCP directly, not TURN, see https://github.com/ossrs/srs/issues/2852\n    # Some network does not support UDP, or not very well, so we use TCP like HTTP/80 port for firewall traversing.\n    tcp {\n        # Whether enable WebRTC over TCP.\n        # Overwrite by env SRS_RTC_SERVER_TCP_ENABLED\n        # Default: off\n        enabled off;\n        # The TCP listen port for WebRTC. Highly recommend is some normally used ports, such as TCP/80, TCP/443,\n        # TCP/8000, TCP/8080 etc. However SRS default to TCP/8000 corresponding to UDP/8000.\n        # Overwrite by env SRS_RTC_SERVER_TCP_LISTEN\n        # Default: 8000\n        listen 8000;\n    }\n    # The protocol for candidate to use, it can be:\n    #       udp         Generate UDP candidates. Note that UDP server is always enabled for WebRTC.\n    #       tcp         Generate TCP candidates. Fail if rtc_server.tcp(WebRTC over TCP) is disabled.\n    #       all         Generate UDP+TCP candidates. Ignore if rtc_server.tcp(WebRTC over TCP) is disabled.\n    # Note that if both are connected, we will use the first connected(DTLS done) one.\n    # Overwrite by env SRS_RTC_SERVER_PROTOCOL\n    # Default: udp\n    protocol udp;\n    # The exposed candidate IPs, response in SDP candidate line. It can be:\n    #       *           Retrieve server IP automatically, from all network interfaces.\n    #       $CANDIDATE  Read the IP from ENV variable, use * if not set.\n    #       x.x.x.x     A specified IP address or DNS name, use * if 0.0.0.0.\n    # @remark For Firefox, the candidate MUST be IP, MUST NOT be DNS name, see https://bugzilla.mozilla.org/show_bug.cgi?id=1239006\n    # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/webrtc#config-candidate\n    # Overwrite by env SRS_RTC_SERVER_CANDIDATE\n    # default: *\n    candidate *;\n}\n\nvhost rtc.vhost.srs.com {\n    rtc {\n        # Whether enable WebRTC server.\n        # Overwrite by env SRS_VHOST_RTC_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n        # Whether support NACK.\n        # default: on\n        nack on;\n        # Whether support TWCC.\n        # default: on\n        twcc on;\n        # The timeout in seconds for session timeout.\n        # Client will send ping(STUN binding request) to server, we use it as heartbeat.\n        # default: 30\n        stun_timeout 30;\n        # The role of dtls when peer is actpass: passive or active\n        # default: passive\n        dtls_role passive;\n        # Whether enable transmuxing RTMP to RTC.\n        # If enabled, transcode aac to opus.\n        # Overwrite by env SRS_VHOST_RTC_RTMP_TO_RTC for all vhosts.\n        # default: off\n        rtmp_to_rtc off;\n        # Whether enable transmuxing RTC to RTMP.\n        # Overwrite by env SRS_VHOST_RTC_RTC_TO_RTMP for all vhosts.\n        # Default: off\n        rtc_to_rtmp off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for WebRTC Live Streaming\nDESCRIPTION: This command runs the SRS Docker container with a specific configuration for converting RTMP to WebRTC.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Deployment on Kubernetes\nDESCRIPTION: Kubernetes manifest to deploy a single SRS origin server with three exposed ports (1935 for RTMP, 1985 for HTTP API, and 8080 for HTTP streaming).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deployment\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for DASH Streaming\nDESCRIPTION: Configuration file for enabling DASH streaming in SRS. It sets up the HTTP server, DASH parameters including fragment duration, update period, timeshift window, and MPD file location.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-dash.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/dash.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    dash {\n        enabled         on;\n        dash_fragment       30;\n        dash_update_period  150;\n        dash_timeshift      300;\n        dash_path           ./objs/nginx/html;\n        dash_mpd_file       [app]/[stream].mpd;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for HTTP-FLV\nDESCRIPTION: This command runs an SRS Docker container configured for HTTP-FLV live streaming, exposing ports 1935 and 8080.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/flv.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  ./objs/srs -c conf/http.flv.live.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing a Stream to SRS with FFmpeg - Bash\nDESCRIPTION: This snippet shows how to use FFmpeg to publish a video stream to an SRS server endpoint over RTMP. It reads the input FLV file in real time and forwards it with codec copy to the RTMP URL provided. It requires FFmpeg and an accessible SRS RTMP server (e.g., started with the Docker example). Main parameters: \\\"-re\\\" for real-time input, \\\"-i\\\" specifies the local source, and the target RTMP URL outputs the stream. The output on SRS will be available at the provided RTMP URL for playback or further distribution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server in vhost Section\nDESCRIPTION: This configuration snippet demonstrates how to set up an SRS server in edge mode. It includes settings for remote mode, origin server addresses, token traversal, vhost transformation, and debugging options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/edge.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            remote;\n\n        # For edge(mode remote), user must specifies the origin server\n        # format as: <server_name|ip>[:port]\n        # @remark user can specifies multiple origin for error backup, by space,\n        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935\n        origin          127.0.0.1:1935 localhost:1935;\n\n        # For edge(mode remote), whether open the token traverse mode,\n        # if token traverse on, all connections of edge will forward to origin to check(auth),\n        # it's very important for the edge to do the token auth.\n        # the better way is use http callback to do the token auth by the edge,\n        # but if user prefer origin check(auth), the token_traverse if better solution.\n        # default: off\n        token_traverse  off;\n\n        # For edge(mode remote), the vhost to transform for edge,\n        # to fetch from the specified vhost at origin,\n        # if not specified, use the current vhost of edge in origin, the variable [vhost].\n        # default: [vhost]\n        vhost           same.edge.srs.com;\n\n        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,\n        # it's strongly recommend to open the debug_srs_upnode,\n        # when connect to upnode, it will take the debug info,\n        # for example, the id, source id, pid.\n        # please see https://ossrs.net/lts/zh-cn/docs/v4/doc/log\n        # default: on\n        debug_srs_upnode    on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking HLS Cluster with srs-bench - Bash\nDESCRIPTION: This snippet runs the srs-bench container to benchmark HLS playback via the NGINX edge, emulating 100 clients retrieving an HLS stream from the edge endpoint. Dependencies include Docker installed on the test machine and network access to both SRS and NGINX edge servers. Inputs specify the number of clients (-c) and the HLS stream URL (-r); output is performance and load statistics.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\\\\n  ./objs/sb_hls_load -c 100 -r http://192.168.1.170:8081/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Callbacks in SRS\nDESCRIPTION: This configuration snippet demonstrates how to set up various HTTP callback events in SRS, including on_publish, on_unpublish, on_play, on_stop, on_dvr, on_hls, and on_hls_notify.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        enabled         on;\n        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;\n        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[server_id]/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Vhost Security Rules\nDESCRIPTION: This configuration snippet demonstrates how to enable and define security rules within an SRS vhost. The `security` block, when `enabled`, allows specification of `allow` or `deny` rules for `publish` or `play` actions, targeting clients by `all`, specific IP addresses (e.g., `127.0.0.1`), or CIDR blocks (e.g., `10.0.0.0/8`). If security is enabled, the default behavior is to deny all traffic unless explicitly allowed by a rule. This example configuration enables security and explicitly allows all clients to both play and publish streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/security.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost your_vhost {\n    # security for host to allow or deny clients.\n    # @see https://github.com/ossrs/srs/issues/211   \n    security {\n        # whether enable the security for vhost.\n        # default: off\n        enabled         on;\n        # the security list, each item format as:\n        #       allow|deny    publish|play    all|<ip or cidr>\n        # for example:\n        #       allow           publish     all;\n        #       deny            publish     all;\n        #       allow           publish     127.0.0.1;\n        #       deny            publish     127.0.0.1;\n        #       allow           publish     10.0.0.0/8;\n        #       deny            publish     10.0.0.0/8;\n        #       allow           play        all;\n        #       deny            play        all;\n        #       allow           play        127.0.0.1;\n        #       deny            play        127.0.0.1;\n        #       allow           play        10.0.0.0/8;\n        #       deny            play        10.0.0.0/8;\n        # SRS apply the following simple strategies one by one:\n        #       1. allow all if security disabled.\n        #       2. default to deny all when security enabled.\n        #       3. allow if matches allow strategy.\n        #       4. deny if matches deny strategy.\n        allow           play        all;\n        allow           publish     all;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Posting WebRTC Stream via WHIP - HTTP Request/SDP Exchange - text\nDESCRIPTION: This snippet shows the HTTP POST request format using the WHIP protocol to publish a stream to SRS over WebRTC. The HTTP body contains SDP in 'application/sdp' format. This method requires SRS to have WHIP enabled, and both the endpoint and credentials (if any) must be provisioned. The expected input is an SDPy payload for stream negotiation; the response will include an SDP answer from SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whip/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream using FFmpeg (Bash)\nDESCRIPTION: Uses FFmpeg in a loop to continuously publish the `source.flv` file (located in `./doc/`) as an RTMP stream to the SRS origin server at `rtmp://192.168.1.170/live/livestream`. The `-re` flag reads the input at its native frame rate, and `-c copy` copies the codecs without re-encoding. A 1-second pause occurs between publishes. The IP address (192.168.1.170) should be replaced with the actual server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Deploying SRS Origin with Nginx and Services in Kubernetes\nDESCRIPTION: This snippet creates a Kubernetes deployment for SRS Origin server with Nginx for HLS delivery, including a shared volume configuration. It also sets up two services: a ClusterIP service for internal access and a LoadBalancer service for external HTTP access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-origin-deploy\n  labels:\n    app: srs-origin\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs-origin\n  template:\n    metadata:\n      labels:\n        app: srs-origin\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: ClusterIP\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-http-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-http-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-http-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\nEOF\n```\n\n----------------------------------------\n\nTITLE: Publishing Live Stream with FFmpeg\nDESCRIPTION: Use FFmpeg to publish a live stream to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Docker Container for WebRTC\nDESCRIPTION: Launches SRS with WebRTC support, exposing additional ports and configuring CANDIDATE IP for WebRTC\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Snapshot Configuration\nDESCRIPTION: Command to start SRS using the snapshot configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/snapshot.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c snapshot.conf\n```\n\n----------------------------------------\n\nTITLE: SRS Build Configuration\nDESCRIPTION: Basic command to build SRS with HTTP API support enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Transcoder for Automated Snapshot Generation (SRS Config, Conf)\nDESCRIPTION: This full SRS configuration enables the Transcoder engine to take PNG snapshots from an RTMP stream using FFMPEG. It defines the transcoder engine, video filters, codecs, output format, and limits frame count. Dependencies: SRS, FFMPEG. Parameters: vframes, filter fps, output filename template. Inputs: FLV stream file; Outputs: Multiple PNG snapshot files. Limitations: SRS itself doesn't select the best thumbnail file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/snapshot.md#2025-04-23_snippet_4\n\nLANGUAGE: conf\nCODE:\n```\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    transcode {\n        enabled on;\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine snapshot {\n            enabled on;\n            iformat flv;\n            vfilter {\n                vf fps=1;\n            }\n            vcodec png;\n            vparams {\n                vframes 6;\n            }\n            acodec an;\n            oformat image2;\n            output ./objs/nginx/html/[app]/[stream]-%03d.png;\n        }\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Edge ConfigMap, Deployment, and Service in Kubernetes (YAML/Shell)\nDESCRIPTION: This snippet uses a shell heredoc (`cat <<EOF | kubectl apply -f -`) to apply Kubernetes YAML configurations for the SRS Edge cluster. It defines a ConfigMap `srs-edge-config` containing the SRS configuration, specifying the cluster mode as 'remote' and pointing to the internal Origin service `srs-origin-service`. It then defines a Deployment `srs-edge-deploy` with 3 replicas, mounting the ConfigMap as a volume for configuration. Finally, it defines a Service `srs-edge-service` (LoadBalancer type) to expose the SRS Edge servers externally on ports 1935 (RTMP) and 8080 (HTTP-FLV/HLS).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-service;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-edge-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-edge\n  ports:\n  - name: srs-edge-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-edge-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Filter SRS Logs by Session ID and Analyze Client Lifecycle - Bash\nDESCRIPTION: This shell snippet filters SRS logs by a specific session id using a regex pattern, then shows the sequence of events for that client, from connection to disconnection. It highlights usage of session ids for isolating log context per client, helpful for debugging stream, message, or connection issues. The command expects the SRS log file as input and the session id pattern as a key parameter.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log |grep -ina \"\\[104\\]\\[\"\n14:[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n15:[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n16:[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n17:[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n18:[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n19:[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n21:[2014-04-04 11:56:06.288][trace][104][11] set output chunk size to 60000\n22:[2014-04-04 11:56:06.288][trace][104][11] set chunk_size=60000 success\n23:[2014-04-04 11:56:07.397][trace][104][11] <- time=225273, obytes=4168, ibytes=7607, okbps=32, ikbps=59\n24:[2014-04-04 11:56:07.398][trace][104][11] dispatch metadata success.\n25:[2014-04-04 11:56:07.398][trace][104][11] process onMetaData message success.\n26:[2014-04-04 11:56:07.398][trace][104][11] update video sequence header success. size=67\n27:[2014-04-04 11:56:08.704][trace][104][11] <- time=226471, obytes=4168, ibytes=36842, okbps=13, ikbps=116\n28:[2014-04-04 11:56:09.901][trace][104][11] <- time=227671, obytes=4168, ibytes=67166, okbps=9, ikbps=152\n29:[2014-04-04 11:56:11.102][trace][104][11] <- time=228869, obytes=4168, ibytes=97481, okbps=6, ikbps=155\n30:[2014-04-04 11:56:11.219][trace][104][11] clear cache/metadata/sequence-headers when unpublish.\n31:[2014-04-04 11:56:11.219][trace][104][11] control message(unpublish) accept, retry stream service.\n32:[2014-04-04 11:56:11.219][trace][104][11] ignore AMF0/AMF3 command message.\n33:[2014-04-04 11:56:11.419][trace][104][11] drop the AMF0/AMF3 command message, command_name=deleteStream\n34:[2014-04-04 11:56:11.420][trace][104][11] ignore AMF0/AMF3 command message.\n35:[2014-04-04 11:56:12.620][error][104][104] recv client message failed. ret=207(Connection reset by peer)\n36:[2014-04-04 11:56:12.620][error][104][104] identify client failed. ret=207(Connection reset by peer)\n37:[2014-04-04 11:56:12.620][warn][104][104] client disconnect peer. ret=204\n[winlin@dev6 srs]$ \n```\n\n----------------------------------------\n\nTITLE: Pushing FLV Stream to SRS using FFmpeg over HTTP - Bash Command - Bash\nDESCRIPTION: This FFmpeg command streams a local FLV file to the SRS server by POSTing via HTTP to the specified endpoint (http://127.0.0.1:8936/live/livestream.flv). It is intended for pushing FLV from a file source in real time. Requires FFmpeg, an input file, and SRS running and listening on the specified TCP port with the proper FLV stream_caster configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/streamer.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy \\\n    -f flv http://127.0.0.1:8936/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for WebRTC\nDESCRIPTION: This command runs the SRS Docker container with additional ports and environment variables for WebRTC support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Docker Container for WebRTC SFU\nDESCRIPTION: Docker command to run SRS server with WebRTC configuration. Sets up ports for RTMP (1935), HTTP (8080), API (1985), and WebRTC (8000/udp). Requires CANDIDATE environment variable to be set with server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Applying Different Configurations per Vhost in SRS (Bash)\nDESCRIPTION: This configuration snippet showcases how different settings can be applied to individual virtual hosts within SRS. It configures the `show.cctv.cn` Vhost with a small `chunk_size` of 128 (often used for lower latency) and the `show.wasu.cn` Vhost with a larger `chunk_size` of 4906. This demonstrates the ability to tailor server behavior based on the specific Vhost being accessed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n    chunk_size 128;\n}\nvhost show.wasu.cn {\n    chunk_size 4906;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Server in SRS RTMP Cluster\nDESCRIPTION: This snippet shows how to configure an edge server in the SRS RTMP cluster. It includes settings for remote mode, origin server specification, token traversal, and debug options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/edge.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            remote;\n\n        # For edge(mode remote), user must specifies the origin server\n        # format as: <server_name|ip>[:port]\n        # @remark user can specifies multiple origin for error backup, by space,\n        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935\n        origin          127.0.0.1:1935 localhost:1935;\n\n        # For edge(mode remote), whether open the token traverse mode,\n        # if token traverse on, all connections of edge will forward to origin to check(auth),\n        # it's very important for the edge to do the token auth.\n        # the better way is use http callback to do the token auth by the edge,\n        # but if user prefer origin check(auth), the token_traverse if better solution.\n        # default: off\n        token_traverse  off;\n\n        # For edge(mode remote), the vhost to transform for edge,\n        # to fetch from the specified vhost at origin,\n        # if not specified, use the current vhost of edge in origin, the variable [vhost].\n        # default: [vhost]\n        vhost           same.edge.srs.com;\n\n        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,\n        # it's strongly recommend to open the debug_srs_upnode,\n        # when connect to upnode, it will take the debug info,\n        # for example, the id, source id, pid.\n        # please see https://ossrs.io/lts/en-us/docs/v4/doc/log\n        # default: on\n        debug_srs_upnode    on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTMP to RTC Configuration\nDESCRIPTION: This command runs SRS in a Docker container with RTMP to RTC configuration. It sets the candidate IP and uses the rtmp2rtc.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Referer Anti-suck in SRS\nDESCRIPTION: Configuration snippet for setting up referer-based hotlink protection in SRS. Allows specifying allowed domains for both play and publish operations. The config enables checking of PageUrl parameter in RTMP connections to prevent unauthorized access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/drm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the vhost for anti-suck.\nvhost refer.anti_suck.com {\n    # refer hotlink-denial.\n    refer {\n        # whether enable the refer hotlink-denial.\n        # default: off.\n        enabled         on;\n        # the common refer for play and publish.\n        # if the page url of client not in the refer, access denied.\n        # if not specified this field, allow all.\n        # default: not specified.\n        all           github.com github.io;\n        # refer for publish clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        publish   github.com github.io;\n        # refer for play clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        play      github.com github.io;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR in SRS\nDESCRIPTION: A comprehensive configuration example for enabling DVR in SRS, including options for stream filtering, recording plans, output paths with variables, duration settings, time jitter handling, and keyframe options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/dvr.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost yourvhost {\n    # DVR RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv/mp4 according by specified dvr_plan.\n    dvr {\n        # whether enabled dvr features\n        # default: off\n        enabled         on;\n        # the filter for dvr to apply to.\n        #       all, dvr all streams of all apps.\n        #       <app>/<stream>, apply to specified stream of app.\n        # for example, to dvr the following two streams:\n        #       live/stream1 live/stream2\n        # default: all\n        dvr_apply       all;\n        # the dvr plan. canbe:\n        #       session reap flv/mp4 when session end(unpublish).\n        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.\n        # @remark The plan append is removed in SRS3+, for it's no use.\n        # default: session\n        dvr_plan        session;\n        # the dvr output path, *.flv or *.mp4.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        # @remark we use golang time format \"2006-01-02 15:04:05.999\" as \"[2006]-[01]-[02]_[15].[04].[05]_[999]\"\n        # for example, for url rtmp://ossrs.net/live/livestream and time 2015-01-03 10:57:30.776\n        # 1. No variables, the rule of SRS1.0(auto add [stream].[timestamp].flv as filename):\n        #       dvr_path ./objs/nginx/html;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.flv;\n        # 2. Use stream and date as dir name, time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03/10.57.30.776.flv;\n        # 3. Use stream and year/month as dir name, date and time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03-10.57.30.776.flv;\n        # 4. Use vhost/app and year/month as dir name, stream/date/time as filename:\n        #       dvr_path /data/[vhost]/[app]/[2006]/[01]/[stream]-[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/2015/01/livestream-03-10.57.30.776.flv;\n        # 5. DVR to mp4:\n        #       dvr_path ./objs/nginx/html/[app]/[stream].[timestamp].mp4;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.mp4;\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#custom-path\n        #       segment,session apply it.\n        # default: ./objs/nginx/html/[app]/[stream].[timestamp].flv\n        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        # the duration for dvr file, reap if exceed, in seconds.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: 30\n        dvr_duration    30;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the dvr_duration,\n        # if on, reap segment when duration exceed and got keyframe.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: on\n        dvr_wait_keyframe       on;\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # apply for all dvr plan.\n        # default: full\n        time_jitter             full;\n\n        # on_dvr, never config in here, should config in http_hooks.\n        # for the dvr http callback, @see http_hooks.on_dvr of vhost hooks.callback.srs.com\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#http-callback\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#http-callback\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Transcoding Settings\nDESCRIPTION: Comprehensive configuration example for setting up FFMPEG transcoding in SRS. Includes settings for video/audio encoding, filters, output formats and common transcoding parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # the streaming transcode configs.\n    transcode {\n        # whether the transcode enabled.\n        # if off, donot transcode.\n        # default: off.\n        enabled     on;\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine for matched stream.\n        engine example {\n            enabled         on;\n            iformat         flv;\n            vfilter {\n                i               ./doc/ffmpeg-logo.png;\n                filter_complex  'overlay=10:10';\n            }\n            vcodec          libx264;\n            vbitrate        1500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n                t               100;\n                coder           1;\n                b_strategy      2;\n                bf              3;\n                refs            10;\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n                profile:a   aac_low;\n                bsf:a       aac_adtstoasc;\n            }\n            oformat         flv;\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server for HTTP-FLV (SRS Config)\nDESCRIPTION: Defines the configuration for an SRS origin server, typically saved as `conf/http.flv.live.conf`. It listens for RTMP connections on port 1935, enables an HTTP server on port 8080 for serving static files and HTTP-FLV streams, and configures the `http_remux` directive to enable live streaming via HTTP-FLV at `[vhost]/[app]/[stream].flv`. HSTRS (HTTP Stream Trigger Remux) is enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.flv.live.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Signaling Server in Docker (Bash)\nDESCRIPTION: This command starts a dedicated signaling server required for WebRTC session establishment. It uses the `ossrs/signaling:1` Docker image and maps port 1989 for signaling communication.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 1989:1989 ossrs/signaling:1\n```\n\n----------------------------------------\n\nTITLE: Configuring Security Rules in SRS Vhost\nDESCRIPTION: This snippet shows how to configure security settings for an SRS vhost to control which clients can publish or play streams. It includes options for enabling security, defining allow/deny rules with IP/CIDR patterns, and demonstrates the rule evaluation strategy.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/security.md#2025-04-23_snippet_0\n\nLANGUAGE: conf\nCODE:\n```\nvhost your_vhost {\n    # security for host to allow or deny clients.\n    # @see https://github.com/ossrs/srs/issues/211   \n    security {\n        # whether enable the security for vhost.\n        # default: off\n        enabled         on;\n        # the security list, each item format as:\n        #       allow|deny    publish|play    all|<ip or cidr>\n        # for example:\n        #       allow           publish     all;\n        #       deny            publish     all;\n        #       allow           publish     127.0.0.1;\n        #       deny            publish     127.0.0.1;\n        #       allow           publish     10.0.0.0/8;\n        #       deny            publish     10.0.0.0/8;\n        #       allow           play        all;\n        #       deny            play        all;\n        #       allow           play        127.0.0.1;\n        #       deny            play        127.0.0.1;\n        #       allow           play        10.0.0.0/8;\n        #       deny            play        10.0.0.0/8;\n        # SRS apply the following simple strategies one by one:\n        #       1. allow all if security disabled.\n        #       2. default to deny all when security enabled.\n        #       3. allow if matches allow strategy.\n        #       4. deny if matches deny strategy.\n        allow           play        all;\n        allow           publish     all;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive HTTP Streaming Remux Configuration for SRS (conf)\nDESCRIPTION: This extensive example documents all parameters and options for HTTP live streaming with SRS, including both HTTP and HTTPS. It details protocol activation, port selection, SSL configuration, per-vhost remux settings, fast_cache tuning for audio, and mount path variables for different output formats (.flv, .ts, .mp3, .aac). Dependencies: SRS, valid RTMP sources, optionally SSL certs. Key parameters: all http_server and http_remux fields. Input: RTMP stream; Output: various HTTP live output endpoints as configured. Limitation: Comments highlight default values, OS/root requirements for lower ports, and behavior of each parameter.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-http-flv.md#2025-04-23_snippet_5\n\nLANGUAGE: conf\nCODE:\n```\nhttp_server {\n    # whether http streaming service is enabled.\n    # default: off\n    enabled         on;\n    # the http streaming listen entry is <[ip:]port>\n    # for example, 192.168.1.100:8080\n    # where the ip is optional, default to 0.0.0.0, that is 8080 equals to 0.0.0.0:8080\n    # @remark, if use lower port, for instance 80, user must start srs by root.\n    # default: 8080\n    listen          8080;\n    # For https_server or HTTPS Streaming.\n    https {\n        # Whether enable HTTPS Streaming.\n        # default: off\n        enabled on;\n        # The listen endpoint for HTTPS Streaming.\n        # default: 8088\n        listen 8088;\n        # The SSL private key file, generated by:\n        #       openssl genrsa -out server.key 2048\n        # default: ./conf/server.key\n        key ./conf/server.key;\n        # The SSL public cert file, generated by:\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\n        # default: ./conf/server.crt\n        cert ./conf/server.crt;\n    }\n}\nvhost __defaultVhost__ {\n    # http flv/mp3/aac/ts stream vhost specified config\n    http_remux {\n        # whether enable the http live streaming service for vhost.\n        # default: off\n        enabled     on;\n        # the fast cache for audio stream(mp3/aac),\n        # to cache more audio and send to client in a time to make android(weixin) happy.\n        # @remark the flv/ts stream ignore it\n        # @remark 0 to disable fast cache for http audio stream.\n        # default: 0\n        fast_cache  30;\n        # the stream mout for rtmp to remux to live streaming.\n        # typical mount to [vhost]/[app]/[stream].flv\n        # the variables:\n        #       [vhost] current vhost for http live stream.\n        #       [app] current app for http live stream.\n        #       [stream] current stream for http live stream.\n        # @remark the [vhost] is optional, used to mount at specified vhost.\n        # the extension:\n        #       .flv mount http live flv stream, use default gop cache.\n        #       .ts mount http live ts stream, use default gop cache.\n        #       .mp3 mount http live mp3 stream, ignore video and audio mp3 codec required.\n        #       .aac mount http live aac stream, ignore video and audio aac codec required.\n        # for example:\n        #       mount to [vhost]/[app]/[stream].flv\n        #           access by http://ossrs.net:8080/live/livestream.flv\n        #       mount to /[app]/[stream].flv\n        #           access by http://ossrs.net:8080/live/livestream.flv\n        #           or by http://192.168.1.173:8080/live/livestream.flv\n        #       mount to [vhost]/[app]/[stream].mp3\n        #           access by http://ossrs.net:8080/live/livestream.mp3\n        #       mount to [vhost]/[app]/[stream].aac\n        #           access by http://ossrs.net:8080/live/livestream.aac\n        #       mount to [vhost]/[app]/[stream].ts\n        #           access by http://ossrs.net:8080/live/livestream.ts\n        # @remark the port of http is specified by http_server section.\n        # default: [vhost]/[app]/[stream].flv\n        mount       [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source - Bash\nDESCRIPTION: This Bash snippet builds SRS by running a configuration script and compiling the source code with make. The main dependencies are autotools and a suitable compiler. Input is the SRS source code; output is compiled SRS binaries located in the ./objs directory. The command must be run from the SRS trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: SRS Ingest Configuration Example - Bash\nDESCRIPTION: This configuration snippet (saved as a text file) provides settings for SRS to ingest a local media file and (optionally) transcode via ffmpeg before streaming with RTMP. The config defines listen port, max connections, and an ingest section specifying input type (file), path, ffmpeg binary, and publish target. Inputs include the ingest file and output RTMP URL; outputs are managed by SRS and exposed streams. Intended for use within SRS configuration files, not directly executable; save as conf/ingest.conf.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ingest.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ingest.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    ingest livestream {\n        enabled      on;\n        input {\n            type    file;\n            url     ./doc/source.flv;\n        }\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled          off;\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP-FLV Configuration\nDESCRIPTION: Sample configuration for enabling HTTP-FLV streaming in SRS. It includes settings for the HTTP server and the specific virtual host configuration for HTTP remuxing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/flv.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    enabled on;\n    listen 8080;\n    crossdomain on;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled on;\n        fast_cache 30;\n        drop_if_not_match on;\n        has_audio on;\n        has_video on;\n        guess_has_av on;\n        mount [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Performing Rolling Update of SRS Edge Deployment (Bash)\nDESCRIPTION: This command initiates a rolling update for the Kubernetes deployment named `srs-edge-deploy`. It uses `kubectl set image` to update the image of the container named `srs` to `ossrs/srs:v4.0.6`. Kubernetes will then manage the update process: it creates new pods with the updated image and terminates old pods, respecting the deployment's update strategy and the pod's `terminationGracePeriodSeconds` and `preStop` hook for graceful connection handling. The `--record` flag annotates the deployment revision with the command used, aiding in rollback procedures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nkubectl set image deploy/srs-edge-deploy srs=ossrs/srs:v4.0.6 --record\n```\n\n----------------------------------------\n\nTITLE: Using SRS Docker Image for HEVC RTMP Streaming\nDESCRIPTION: Commands to use the SRS Docker image with patched FFmpeg for HEVC RTMP streaming on macOS and Linux.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-03-07-Lets-Do-H265-Live-Streaming.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n\n# For linux\ndocker run --net=host --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running Oryx Container with Docker\nDESCRIPTION: Docker command to create and run an Oryx container instance for live streaming with appropriate port mappings and volume mounting. The container runs in detached mode with auto-restart enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-11-28-Oryx-Live-Streams-Transcription.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Running SRS for WebRTC to WebRTC Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC to WebRTC configuration. This setup allows for WebRTC ingestion and playback without transcoding to other protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with SRT Support\nDESCRIPTION: Command to run an SRS Docker container with SRT protocol enabled on port 10080/udp.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/srt.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n    ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Basic SRS HEVC Architecture Flow\nDESCRIPTION: Diagram showing the basic flow of HEVC video from FFmpeg through SRS to various output protocols and clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nFFmpeg --RTMP(h.265)---> SRS ----RTMP/FLV/TS/HLS/WebRTC(h.265)--> Chrome/Safari\n```\n\n----------------------------------------\n\nTITLE: WebRTC Publishing with WHIP Protocol\nDESCRIPTION: Example of WebRTC stream publishing using WHIP protocol showing the SDP request and response format. The request uses POST method with application/sdp content type.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whip/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\n----------------------------------------\n\nTITLE: Configuring Security Settings in SRS Vhost (NGINX-like syntax)\nDESCRIPTION: This snippet demonstrates how to configure security settings for an SRS vhost. It includes options to enable/disable security, and define allow/deny rules for publish and play actions based on IP addresses or CIDR ranges.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/security.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost your_vhost {\n    # security for host to allow or deny clients.\n    # @see https://github.com/ossrs/srs/issues/211   \n    security {\n        # whether enable the security for vhost.\n        # default: off\n        enabled         on;\n        # the security list, each item format as:\n        #       allow|deny    publish|play    all|<ip or cidr>\n        # for example:\n        #       allow           publish     all;\n        #       deny            publish     all;\n        #       allow           publish     127.0.0.1;\n        #       deny            publish     127.0.0.1;\n        #       allow           publish     10.0.0.0/8;\n        #       deny            publish     10.0.0.0/8;\n        #       allow           play        all;\n        #       deny            play        all;\n        #       allow           play        127.0.0.1;\n        #       deny            play        127.0.0.1;\n        #       allow           play        10.0.0.0/8;\n        #       deny            play        10.0.0.0/8;\n        # SRS apply the following simple strategies one by one:\n        #       1. allow all if security disabled.\n        #       2. default to deny all when security enabled.\n        #       3. allow if matches allow strategy.\n        #       4. deny if matches deny strategy.\n        allow           play        all;\n        allow           publish     all;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFmpeg\nDESCRIPTION: Command to publish a video stream to SRS using FFmpeg directly on the host machine.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: SRS Realtime Configuration\nDESCRIPTION: Configuration file for SRS in realtime mode. It enables TCP_NODELAY, minimum latency, disables GOP cache, sets queue length, and disables mr (merged-read) for publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-realtime.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/realtime.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG Transcoding in SRS\nDESCRIPTION: This snippet shows how to configure FFMPEG transcoding for a vhost in SRS. It includes settings for input/output formats, video/audio codecs, bitrates, and other parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # the streaming transcode configs.\n    transcode {\n        # whether the transcode enabled.\n        # if off, donot transcode.\n        # default: off.\n        enabled     on;\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine for matched stream.\n        # all matched stream will transcoded to the following stream.\n        # the transcode set name(ie. hd) is optional and not used.\n        engine example {\n            # whether the engine is enabled\n            # default: off.\n            enabled         on;\n            # pre-file options, before \"-i\"\n            perfile {\n                re;\n                rtsp_transport tcp;\n            }\n            # input format, can be:\n            # off, do not specifies the format, ffmpeg will guess it.\n            # flv, for flv or RTMP stream.\n            # other format, for example, mp4/aac whatever.\n            # default: flv\n            iformat         flv;\n            # ffmpeg filters, follows the main input.\n            vfilter {\n                # the logo input file.\n                i               ./doc/ffmpeg-logo.png;\n                # the ffmpeg complex filter.\n                # for filters, @see: http://ffmpeg.org/ffmpeg-filters.html\n                filter_complex  'overlay=10:10';\n            }\n            # video encoder name. can be:\n            #       libx264: use h.264(libx264) video encoder.\n            #       png: use png to snapshot thumbnail.\n            #       copy: donot encoder the video stream, copy it.\n            #       vn: disable video output.\n            vcodec          libx264;\n            # video bitrate, in kbps\n            # @remark 0 to use source video bitrate.\n            # default: 0\n            vbitrate        1500;\n            # video framerate.\n            # @remark 0 to use source video fps.\n            # default: 0\n            vfps            25;\n            # video width, must be even numbers.\n            # @remark 0 to use source video width.\n            # default: 0\n            vwidth          768;\n            # video height, must be even numbers.\n            # @remark 0 to use source video height.\n            # default: 0\n            vheight         320;\n            # the max threads for ffmpeg to used.\n            # default: 1\n            vthreads        12;\n            # x264 profile, @see x264 -help, can be:\n            # high,main,baseline\n            vprofile        main;\n            # x264 preset, @see x264 -help, can be: \n            #       ultrafast,superfast,veryfast,faster,fast\n            #       medium,slow,slower,veryslow,placebo\n            vpreset         medium;\n            # other x264 or ffmpeg video params\n            vparams {\n                # ffmpeg options, @see: http://ffmpeg.org/ffmpeg.html\n                t               100;\n                # 264 params, @see: http://ffmpeg.org/ffmpeg-codecs.html#libx264\n                coder           1;\n                b_strategy      2;\n                bf              3;\n                refs            10;\n            }\n            # audio encoder name. can be:\n            #       libfdk_aac: use aac(libfdk_aac) audio encoder.\n            #       copy: donot encoder the audio stream, copy it.\n            #       an: disable audio output.\n            acodec          libfdk_aac;\n            # audio bitrate, in kbps. [16, 72] for libfdk_aac.\n            # @remark 0 to use source audio bitrate.\n            # default: 0\n            abitrate        70;\n            # audio sample rate. for flv/rtmp, it must be:\n            #       44100,22050,11025,5512\n            # @remark 0 to use source audio sample rate.\n            # default: 0\n            asample_rate    44100;\n            # audio channel, 1 for mono, 2 for stereo.\n            # @remark 0 to use source audio channels.\n            # default: 0\n            achannels       2;\n            # other ffmpeg audio params\n            aparams {\n                # audio params, @see: http://ffmpeg.org/ffmpeg-codecs.html#Audio-Encoders\n                # @remark SRS supported aac profile for HLS is: aac_low, aac_he, aac_he_v2\n                profile:a   aac_low;\n                bsf:a       aac_adtstoasc;\n            }\n            # output format, can be:\n            #       off, do not specifies the format, ffmpeg will guess it.\n            #       flv, for flv or RTMP stream.\n            #       image2, for vcodec png to snapshot thumbnail.\n            #       other format, for example, mp4/aac whatever.\n            # default: flv\n            oformat         flv;\n            # output stream. variables:\n            #       [vhost] the input stream vhost.\n            #       [port] the intput stream port.\n            #       [app] the input stream app.\n            #       [stream] the input stream name.\n            #       [engine] the tanscode engine name.\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running httpx-static as HTTPS Proxy/API Gateway in Docker (Bash)\nDESCRIPTION: This command runs the `httpx-static` tool from the `ossrs/httpx:1` image to act as an HTTPS proxy and API gateway. It requires the `CANDIDATE` environment variable set to the server's IP. It maps HTTP (80) and HTTPS (443) ports, uses provided SSL certificate/key files (`server.key`, `server.crt`), and proxies requests to the signaling server (`/sig`), SRS RTC API (`/rtc`), and SRS HTTP API (`/`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm -p 80:80 -p 443:443 ossrs/httpx:1 \\\n    ./bin/httpx-static -http 80 -https 443 -ssk ./etc/server.key -ssc ./etc/server.crt \\\n          -proxy http://$CANDIDATE:1989/sig -proxy http://$CANDIDATE:1985/rtc \\\n          -proxy http://$CANDIDATE:8080/\n```\n\n----------------------------------------\n\nTITLE: Pushing Stream to SRS using FFmpeg\nDESCRIPTION: Docker command to use FFmpeg for pushing a live stream to SRS. It uses a sample video file and streams it to the RTMP endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -re -i doc/source.flv -c copy \\\n  -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: DVR Configuration Example\nDESCRIPTION: Complete configuration example for DVR in SRS, including options for enabling DVR, setting file paths, duration limits, and time jitter handling\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/dvr.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost yourvhost {\n    # DVR RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv/mp4 according by specified dvr_plan.\n    dvr {\n        # whether enabled dvr features\n        # default: off\n        enabled         on;\n        # the filter for dvr to apply to.\n        #       all, dvr all streams of all apps.\n        #       <app>/<stream>, apply to specified stream of app.\n        # for example, to dvr the following two streams:\n        #       live/stream1 live/stream2\n        # default: all\n        dvr_apply       all;\n        # the dvr plan. canbe:\n        #       session reap flv/mp4 when session end(unpublish).\n        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.\n        # @remark The plan append is removed in SRS3+, for it's no use.\n        # default: session\n        dvr_plan        session;\n        # the dvr output path, *.flv or *.mp4.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        # @remark we use golang time format \"2006-01-02 15:04:05.999\" as \"[2006]-[01]-[02]_[15].[04].[05]_[999]\"\n        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        # the duration for dvr file, reap if exceed, in seconds.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: 30\n        dvr_duration    30;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the dvr_duration,\n        # if on, reap segment when duration exceed and got keyframe.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: on\n        dvr_wait_keyframe       on;\n        # time jitter algorithm\n        # default: full\n        time_jitter             full;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Edge Deployment for New Version in Canary Release\nDESCRIPTION: This YAML configuration creates a new deployment for SRS edge servers with version 4.0.6, setting up 1 replica for canary testing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-r6-deploy\n  labels:\n    run: srs-edge-r6\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      run: srs-edge-r6\n  template:\n    metadata:\n      labels:\n        run: srs-edge-r6\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:v4.0.6\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"/usr/local/srs/etc/init.d/srs\", \"grace\"]\n      terminationGracePeriodSeconds: 120\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Security Rules\nDESCRIPTION: Configuration block for setting up security rules in SRS virtual hosts. Allows specifying allow/deny rules for publish and play actions based on IP addresses or CIDR ranges.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/security.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost your_vhost {\n    # security for host to allow or deny clients.\n    # @see https://github.com/ossrs/srs/issues/211   \n    security {\n        # whether enable the security for vhost.\n        # default: off\n        enabled         on;\n        # the security list, each item format as:\n        #       allow|deny    publish|play    all|<ip or cidr>\n        # for example:\n        #       allow           publish     all;\n        #       deny            publish     all;\n        #       allow           publish     127.0.0.1;\n        #       deny            publish     127.0.0.1;\n        #       allow           publish     10.0.0.0/8;\n        #       deny            publish     10.0.0.0/8;\n        #       allow           play        all;\n        #       deny            play        all;\n        #       allow           play        127.0.0.1;\n        #       deny            play        127.0.0.1;\n        #       allow           play        10.0.0.0/8;\n        #       deny            play        10.0.0.0/8;\n        # SRS apply the following simple strategies one by one:\n        #       1. allow all if security disabled.\n        #       2. default to deny all when security enabled.\n        #       3. allow if matches allow strategy.\n        #       4. deny if matches deny strategy.\n        allow           play        all;\n        allow           publish     all;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Low Latency Configuration for SRS\nDESCRIPTION: Recommended comprehensive configuration for low latency applications in SRS, combining all optimizations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Settings in SRS Media Server\nDESCRIPTION: Comprehensive RTMP configuration for SRS media server including settings for latency, timeout handling, caching, and performance optimization. The configuration includes options for both publishers and players with detailed parameters affecting stream behavior.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # whether enable min delay mode for vhost.\n    # for min latency mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off (for RTMP/HTTP-FLV)\n    # default: on (for WebRTC)\n    min_latency off;\n\n    # whether enable the TCP_NODELAY\n    # if on, set the nodelay of fd by setsockopt\n    # Overwrite by env SRS_VHOST_TCP_NODELAY for all vhosts.\n    # default: off\n    tcp_nodelay off;\n\n    # the default chunk size is 128, max is 65536,\n    # some client does not support chunk size change,\n    # vhost chunk size will override the global value.\n    # Overwrite by env SRS_VHOST_CHUNK_SIZE for all vhosts.\n    # default: global chunk size.\n    chunk_size 128;\n    \n    # The input ack size, 0 to not set.\n    # Generally, it's set by the message from peer,\n    # but for some peer(encoder), it never send message but use a different ack size.\n    # We can chnage the default ack size in server-side, to send acknowledge message,\n    # or the encoder maybe blocked after publishing for some time.\n    # Overwrite by env SRS_VHOST_IN_ACK_SIZE for all vhosts.\n    # Default: 0\n    in_ack_size 0;\n    \n    # The output ack size, 0 to not set.\n    # This is used to notify the peer(player) to send acknowledge to server.\n    # Overwrite by env SRS_VHOST_OUT_ACK_SIZE for all vhosts.\n    # Default: 2500000\n    out_ack_size 2500000;\n    \n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # about MR, read https://github.com/ossrs/srs/issues/241\n        # when enabled the mr, SRS will read as large as possible.\n        # Overwrite by env SRS_VHOST_PUBLISH_MR for all vhosts.\n        # default: off\n        mr off;\n        # the latency in ms for MR(merged-read),\n        # the performance+ when latency+, and memory+,\n        #       memory(buffer) = latency * kbps / 8\n        # for example, latency=500ms, kbps=3000kbps, each publish connection will consume\n        #       memory = 500 * 3000 / 8 = 187500B = 183KB\n        # when there are 2500 publisher, the total memory of SRS at least:\n        #       183KB * 2500 = 446MB\n        # the recommended value is [300, 2000]\n        # Overwrite by env SRS_VHOST_PUBLISH_MR_LATENCY for all vhosts.\n        # default: 350\n        mr_latency 350;\n\n        # the 1st packet timeout in ms for encoder.\n        # Overwrite by env SRS_VHOST_PUBLISH_FIRSTPKT_TIMEOUT for all vhosts.\n        # default: 20000\n        firstpkt_timeout 20000;\n        # the normal packet timeout in ms for encoder.\n        # Overwrite by env SRS_VHOST_PUBLISH_NORMAL_TIMEOUT for all vhosts.\n        # default: 5000\n        normal_timeout 7000;\n        # whether parse the sps when publish stream.\n        # we can got the resolution of video for stat api.\n        # but we may failed to cause publish failed.\n        # @remark If disabled, HLS might never update the sps/pps, it depends on this.\n        # Overwrite by env SRS_VHOST_PUBLISH_PARSE_SPS for all vhosts.\n        # default: on\n        parse_sps on;\n        # When parsing SPS/PPS, whether try ANNEXB first. If not, try IBMF first, then ANNEXB.\n        # Overwrite by env SRS_VHOST_PUBLISH_TRY_ANNEXB_FIRST for all vhosts.\n        # default: on\n        try_annexb_first on;\n        # The timeout in seconds to disconnect publisher when idle, which means no players.\n        # Note that 0 means no timeout or this feature is disabled.\n        # Note that this feature conflicts with forward, because it disconnect the publisher stream.\n        # Overwrite by env SRS_VHOST_PUBLISH_KICKOFF_FOR_IDLE for all vhosts.\n        # default: 0\n        kickoff_for_idle 0;\n    }\n    \n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether cache the last gop.\n        # if on, cache the last gop and dispatch to client,\n        #   to enabled fast startup for client, client play immediately.\n        # if off, send the latest media data to client,\n        #   client need to wait for the next Iframe to decode and show the video.\n        # set to off if requires min delay;\n        # set to on if requires client fast startup.\n        # Overwrite by env SRS_VHOST_PLAY_GOP_CACHE for all vhosts.\n        # default: on\n        gop_cache off;\n\n        # Limit the max frames in gop cache. It might cause OOM if video stream has no IDR frame, so we limit to N\n        # frames by default. Note that it's the size of gop cache, including videos, audios and other messages.\n        # Overwrite by env SRS_VHOST_PLAY_GOP_CACHE_MAX_FRAMES for all vhosts.\n        # default: 2500\n        gop_cache_max_frames 2500;\n\n        # the max live queue length in seconds.\n        # if the messages in the queue exceed the max length,\n        # drop the old whole gop.\n        # Overwrite by env SRS_VHOST_PLAY_QUEUE_LENGTH for all vhosts.\n        # default: 30\n        queue_length 10;\n\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # @remark for full, correct timestamp only when |delta| > 250ms.\n        # @remark disabled when atc is on.\n        # Overwrite by env SRS_VHOST_PLAY_TIME_JITTER for all vhosts.\n        # default: full\n        time_jitter full;\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        #\n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # @remark when atc is on, auto off the time_jitter\n        # Overwrite by env SRS_VHOST_PLAY_ATC for all vhosts.\n        # default: off\n        atc off;\n        # whether use the interleaved/mixed algorithm to correct the timestamp.\n        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.\n        # if off, use time_jitter to correct the timestamp if required.\n        # @remark to use mix_correct, atc should on(or time_jitter should off).\n        # Overwrite by env SRS_VHOST_PLAY_MIX_CORRECT for all vhosts.\n        # default: off\n        mix_correct off;\n\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # Overwrite by env SRS_VHOST_PLAY_ATC_AUTO for all vhosts.\n        # default: off\n        atc_auto off;\n\n        # set the MW(merged-write) latency in ms.\n        # SRS always set mw on, so we just set the latency value.\n        # the latency of stream >= mw_latency + mr_latency\n        # the value recomment is [300, 1800]\n        # @remark For WebRTC, we enable pass-by-timestamp mode, so we ignore this config.\n        # default: 350 (For RTMP/HTTP-FLV)\n        # Overwrite by env SRS_VHOST_PLAY_MW_LATENCY for all vhosts.\n        # default: 0 (For WebRTC)\n        mw_latency 350;\n\n        # Set the MW(merged-write) min messages.\n        # default: 0 (For Real-Time, min_latency on)\n        # default: 1 (For WebRTC, min_latency off)\n        # default: 8 (For RTMP/HTTP-FLV, min_latency off).\n        # Overwrite by env SRS_VHOST_PLAY_MW_MSGS for all vhosts.\n        mw_msgs 8;\n\n        # the minimal packets send interval in ms,\n        # used to control the ndiff of stream by srs_rtmp_dump,\n        # for example, some device can only accept some stream which\n        # delivery packets in constant interval(not cbr).\n        # @remark 0 to disable the minimal interval.\n        # @remark >0 to make the srs to send message one by one.\n        # @remark user can get the right packets interval in ms by srs_rtmp_dump.\n        # Overwrite by env SRS_VHOST_PLAY_SEND_MIN_INTERVAL for all vhosts.\n        # default: 0\n        send_min_interval 10.0;\n        # whether reduce the sequence header,\n        # for some client which cannot got duplicated sequence header,\n        # while the sequence header is not changed yet.\n        # Overwrite by env SRS_VHOST_PLAY_REDUCE_SEQUENCE_HEADER for all vhosts.\n        # default: off\n        reduce_sequence_header on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR Features in SRS - Bash Configuration\nDESCRIPTION: This configuration snippet shows how to enable and customize DVR (Digital Video Recorder) functionality in the SRS streaming server. It describes parameters such as DVR enablement, apply filters, plan options (session/segment), path rules with variable substitution, segment duration, keyframe waiting, and time jitter handling. This config is part of the SRS config file (e.g., srs.conf), and supports filename customization via bracketed template variables. Key inputs are the vhost, DVR plan, path, and timing options. There are no external dependencies, but DVR support must be enabled in the server build.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/dvr.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost yourvhost {\n    # DVR RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv/mp4 according by specified dvr_plan.\n    dvr {\n        # whether enabled dvr features\n        # default: off\n        enabled         on;\n        # the filter for dvr to apply to.\n        #       all, dvr all streams of all apps.\n        #       <app>/<stream>, apply to specified stream of app.\n        # for example, to dvr the following two streams:\n        #       live/stream1 live/stream2\n        # default: all\n        dvr_apply       all;\n        # the dvr plan. canbe:\n        #       session reap flv/mp4 when session end(unpublish).\n        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.\n        # @remark The plan append is removed in SRS3+, for it's no use.\n        # default: session\n        dvr_plan        session;\n        # the dvr output path, *.flv or *.mp4.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        # @remark we use golang time format \"2006-01-02 15:04:05.999\" as \"[2006]-[01]-[02]_[15].[04].[05]_[999]\"\n        # for example, for url rtmp://ossrs.net/live/livestream and time 2015-01-03 10:57:30.776\n        # 1. No variables, the rule of SRS1.0(auto add [stream].[timestamp].flv as filename):\n        #       dvr_path ./objs/nginx/html;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.flv;\n        # 2. Use stream and date as dir name, time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03/10.57.30.776.flv;\n        # 3. Use stream and year/month as dir name, date and time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03-10.57.30.776.flv;\n        # 4. Use vhost/app and year/month as dir name, stream/date/time as filename:\n        #       dvr_path /data/[vhost]/[app]/[2006]/[01]/[stream]-[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/2015/01/livestream-03-10.57.30.776.flv;\n        # 5. DVR to mp4:\n        #       dvr_path ./objs/nginx/html/[app]/[stream].[timestamp].mp4;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.mp4;\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#custom-path\n        #       segment,session apply it.\n        # default: ./objs/nginx/html/[app]/[stream].[timestamp].flv\n        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        # the duration for dvr file, reap if exceed, in seconds.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: 30\n        dvr_duration    30;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the dvr_duration,\n        # if on, reap segment when duration exceed and got keyframe.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: on\n        dvr_wait_keyframe       on;\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # apply for all dvr plan.\n        # default: full\n        time_jitter             full;\n\n        # on_dvr, never config in here, should config in http_hooks.\n        # for the dvr http callback, @see http_hooks.on_dvr of vhost hooks.callback.srs.com\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#http-callback\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#http-callback\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Command Template Used for SRS Transcoding - Bash Example\nDESCRIPTION: This template demonstrates the structure of the FFMPEG command as composed by SRS for a transcoding job. Placeholders such as {vfilter}, {vparams}, {aparams}, and variable paths are dynamically set based on the SRS config. This provides a guide when adjusting or debugging SRS's FFMPEG integration, and should be used with the correct runtime substitution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -f flv -i <input_rtmp> {vfilter} -vcodec ... {vparams} -acodec ... {aparams} -f flv -y {output}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Cluster Settings in YAML\nDESCRIPTION: Configuration block for setting up an SRS origin cluster. Includes settings for cluster mode, origin cluster enablement, and coworker configuration. The config specifically sets up local mode for origin servers and defines communication endpoints with other cluster members.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            local;\n\n        # For origin(mode local) cluster, turn on the cluster.\n        # @remark Origin cluster only supports RTMP, use Edge to transmux RTMP to FLV.\n        # default: off\n        # TODO: FIXME: Support reload.\n        origin_cluster      on;\n\n        # For origin (mode local) cluster, the co-worker's HTTP APIs.\n        # This origin will connect to co-workers and communicate with them.\n        # please read: https://ossrs.io/lts/en-us/docs/v4/doc/origin-cluster\n        # TODO: FIXME: Support reload.\n        coworkers           127.0.0.1:9091 127.0.0.1:9092;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration for Origin ServerA\nDESCRIPTION: Configuration file for the first origin server (ServerA) in the cluster. It defines the basic server settings, HTTP API, and origin cluster configuration with coworkers reference.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverA.conf\nlisten              19350;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverA.pid;\nhttp_api {\n    enabled         on;\n    listen          9090;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9091;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended Low Latency Configuration for SRS\nDESCRIPTION: A comprehensive SRS configuration snippet optimized for low latency applications, including settings for TCP_NODELAY, min_latency, GOP cache, queue length, and merged read/write.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/low-latency.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# the listen ports, split by space.\nlisten              1935;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Low Latency Configuration\nDESCRIPTION: Comprehensive configuration combining all settings for achieving minimum latency in live streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Cluster and Services\nDESCRIPTION: Deploys SRS Origin cluster with ConfigMap, Headless Service, StatefulSet and API Service configurations. Includes settings for cluster coordination and HLS streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-origin-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            origin_cluster  on;\n            coworkers       srs-origin-0.socs:1985 srs-origin-1.socs:1985 srs-origin-2.socs:1985;\n        }\n        http_remux {\n            enabled     on;\n        }\n        hls {\n            enabled         on;\n        }\n    }\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: socs\nspec:\n  clusterIP: None\n  selector:\n    app: srs-origin\n  ports:\n  - name: socs-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to fetch the SRS source code repository from GitHub. This is the first step in deploying SRS for Ingest functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Streaming to SRS using FFmpeg\nDESCRIPTION: This FFmpeg command streams a local FLV file to the SRS server using RTMP protocol. It copies the audio and video codecs without re-encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS for WebRTC (Bash)\nDESCRIPTION: Starts the SRS server using the default configuration file 'conf/srs.conf' but requires setting the 'CANDIDATE' environment variable. This variable must be set to the server's external IP address for WebRTC connectivity to work correctly.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: SRS 4.0 Local-Only HTTP API Configuration\nDESCRIPTION: Configuration for SRS 4.0 to restrict HTTP API access to localhost only, typically used with a proxy server setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nhttp_api {\n    enabled on;\n    listen 127.0.0.1:1985;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for FFMPEG Transcoding (Nginx-like Conf)\nDESCRIPTION: Example SRS configuration file (`conf/ffmpeg.transcode.conf`) enabling the transcoding feature. It specifies the path to the FFMPEG binary, defines a transcoding engine named 'ff', and sets various video/audio parameters (codec, bitrate, resolution, framerate, etc.) for the transcoded output stream. The output is directed to an RTMP URL incorporating the original stream details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\n# conf/ffmpeg.transcode.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx with Helm for Kubernetes\nDESCRIPTION: Commands to add the SRS Helm repository and install Oryx using Helm with configuration for persistent storage and port services for HTTP, HTTPS, RTMP, WebRTC, and SRT.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhelm repo add srs http://helm.ossrs.io/stable\nhelm install srs srs/oryx --set persistence.path=$HOME/data \\\n  --set service.http=80 --set service.https=443 --set service.rtmp=1935 \\\n  --set service.rtc=8000 --set service.srt=10080\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback JSON Request and Response for on_record_begin Event\nDESCRIPTION: This snippet demonstrates the JSON structure for the on_record_begin event HTTP callback request and response. It includes details like request_id, action, stream information, UUID, and the expected response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_8\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"80ad1ddf-1731-450c-83ec-735ea79dd6a3\",\n  \"action\": \"on_record_begin\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\"\n}\n\nResponse:\n{\n\"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server - Bash\nDESCRIPTION: Launches the SRS server with a specified configuration file using the compiled executable. Assumes SRS is built and the working directory is 'srs/trunk'. The core parameter is '-c conf/srs.conf', pointing to the configuration file for server operation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Compiling and Starting SRS with GB28181 Support\nDESCRIPTION: Commands to configure, compile and start SRS with GB28181 support, using version 5.0.74 or above.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gb28181.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --gb28181=on\nmake\n./objs/srs -c conf/gb28181.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS for Basic WebRTC (One-to-One) in Docker (Bash)\nDESCRIPTION: This command starts an SRS container configured for basic WebRTC functionalities using `conf/rtc.conf`. It requires the `CANDIDATE` environment variable to be set to the server's external IP address for WebRTC negotiation. Ports for RTMP (1935), HTTP API (8080), HTTPS API (1985), and WebRTC (8000/udp) are mapped.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: SRS RTC to RTC Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC to WebRTC configuration for low latency streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Server in SRS\nDESCRIPTION: Basic configuration for setting up an edge server in SRS vhost configuration. Includes settings for remote mode, origin server specification, token traversal, and debug options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/edge.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            remote;\n\n        # For edge(mode remote), user must specifies the origin server\n        # format as: <server_name|ip>[:port]\n        # @remark user can specifies multiple origin for error backup, by space,\n        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935\n        origin          127.0.0.1:1935 localhost:1935;\n\n        # For edge(mode remote), whether open the token traverse mode,\n        # if token traverse on, all connections of edge will forward to origin to check(auth),\n        # it's very important for the edge to do the token auth.\n        # the better way is use http callback to do the token auth by the edge,\n        # but if user prefer origin check(auth), the token_traverse if better solution.\n        # default: off\n        token_traverse  off;\n\n        # For edge(mode remote), the vhost to transform for edge,\n        # to fetch from the specified vhost at origin,\n        # if not specified, use the current vhost of edge in origin, the variable [vhost].\n        # default: [vhost]\n        vhost           same.edge.srs.com;\n\n        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,\n        # it's strongly recommend to open the debug_srs_upnode,\n        # when connect to upnode, it will take the debug info,\n        # for example, the id, source id, pid.\n        # please see https://ossrs.io/lts/en-us/docs/v4/doc/log\n        # default: on\n        debug_srs_upnode    on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS via SRT Using FFmpeg\nDESCRIPTION: This FFmpeg command publishes a local video file to SRS using the SRT protocol. It copies the original codecs and formats the stream as MPEG-TS with SRT streaming parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Enabling HTTP API and System Stats in SRS Configuration - SRS Config\nDESCRIPTION: This configuration snippet sets up SRS to enable HTTP API and collect system statistics. It configures network and disk stats collection, enables HTTP/HTTPS API entry points, sets crossdomain access, and allows raw API methods. Dependencies include a running SRS server with this configuration file. Parameters like listen ports, enabled flags, and keys/certs for TLS are critical for enabling secure API access and diagnostics.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_1\n\nLANGUAGE: srs config\nCODE:\n```\n```bash\\nlisten              1935;\\n# system statistics section.\\n# the main cycle will retrieve the system stat,\\n# for example, the cpu/mem/network/disk-io data,\\n# the http api, for instance, /api/v1/summaries will show these data.\\n# @remark the heartbeat depends on the network,\\n#       for example, the eth0 maybe the device which index is 0.\\nstats {\\n    # the index of device ip.\\n    # we may retrieve more than one network device.\\n    # default: 0\\n    network         0;\\n    # the device name to stat the disk iops.\\n    # ignore the device of /proc/diskstats if not configed.\\n    disk            sda sdb xvda xvdb;\\n}\\n# api of srs.\\n# the http api config, export for external program to manage srs.\\n# user can access http api of srs in browser directly, for instance, to access by:\\n#       curl http://192.168.1.170:1985/api/v1/reload\\n# which will reload srs, like cmd killall -1 srs, but the js can also invoke the http api,\\n# where the cli can only be used in shell/terminate.\\nhttp_api {\\n    # whether http api is enabled.\\n    # default: off\\n    enabled         on;\\n    # the http api listen entry is <[ip:]port>\\n    # for example, 192.168.1.100:1985\\n    # where the ip is optional, default to 0.0.0.0, that is 1985 equals to 0.0.0.0:1985\\n    # default: 1985\\n    listen          1985;\\n    # whether enable crossdomain request.\\n    # default: on\\n    crossdomain     on;\\n    # the HTTP RAW API is more powerful api to change srs state and reload.\\n    raw_api {\\n        # whether enable the HTTP RAW API.\\n        # default: off\\n        enabled             off;\\n        # whether enable rpc reload.\\n        # default: off\\n        allow_reload        off;\\n        # whether enable rpc query.\\n        # default: off\\n        allow_query         off;\\n        # whether enable rpc update.\\n        # default: off\\n        allow_update        off;\\n    }\\n    # For https_api or HTTPS API.\\n    https {\\n        # Whether enable HTTPS API.\\n        # default: off\\n        enabled on;\\n        # The listen endpoint for HTTPS API.\\n        # default: 1986\\n        listen 1986;\\n        # The SSL private key file, generated by:\\n        #       openssl genrsa -out server.key 2048\\n        # default: ./conf/server.key\\n        key ./conf/server.key;\\n        # The SSL public cert file, generated by:\\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\\n        # default: ./conf/server.crt\\n        cert ./conf/server.crt;\\n    }\\n}\\nvhost __defaultVhost__ {\\n}\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Hooks in SRS via vhost Block - Bash\nDESCRIPTION: This snippet demonstrates the configuration block for enabling HTTP callback hooks in SRS within the vhost section of the configuration file. The configuration enables hooks for various stream-related events (e.g., publish, play, dvr, hls) and specifies the endpoints that SRS should notify via POST. Each hook can call multiple URLs, supports both HTTP and HTTPS, and expects a JSON object in the POST body. A valid hook must return HTTP 200 and a JSON integer code of 0 for success. Replace URLs as required to fit deployment environments. No external dependencies needed, but SRS must be compiled with HTTP hooks enabled (default behavior).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        # whether the http hooks enable.\n        # default off.\n        enabled         on;\n        # when client(encoder) publish to vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_publish\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_publish http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_publish https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        # when client(encoder) stop publish to vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_unpublish\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_unpublish http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_unpublish https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        # when client start to play vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_play\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"pageUrl\": \"http://www.test.com/live.html\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_play http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_play https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        # when client stop to play vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_stop\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_stop http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_stop https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        # when srs reap a dvr file, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_dvr\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"cwd\": \"/usr/local/srs\",\n        #           \"file\": \"./objs/nginx/html/live/livestream.1420254068776.flv\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;\n        # when srs reap a ts file of hls, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_hls\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"duration\": 9.36, // in seconds\n        #           \"cwd\": \"/usr/local/srs\",\n        #           \"file\": \"./objs/nginx/html/live/livestream/2015-04-23/01/476584165.ts\",\n        #           \"url\": \"live/livestream/2015-04-23/01/476584165.ts\",\n        #           \"m3u8\": \"./objs/nginx/html/live/livestream/live.m3u8\",\n        #           \"m3u8_url\": \"live/livestream/live.m3u8\",\n        #           \"seq_no\": 100\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;\n        # when srs reap a ts file of hls, call this hook,\n        # used to push file to cdn network, by get the ts file from cdn network.\n        # so we use HTTP GET and use the variable following:\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [param], replace with the param.\n        #       [ts_url], replace with the ts url.\n        # ignore any return data of server.\n        # @remark random select a url to report, not report all.\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP Hooks Configuration Example - Bash\nDESCRIPTION: This configuration file snippet enables and defines HTTP hooks for an SRS vhost. It describes events such as on_publish, on_unpublish, on_play, on_stop, on_dvr, on_hls, and on_hls_notify, configuring each to trigger HTTP requests to one or more endpoints. The configuration includes comments that detail the structure of the event JSON POST data, required response codes, and how to define multiple endpoints. This file is intended to be included in the main SRS configuration and requires endpoints to be reachable by the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        # whether the http hooks enable.\n        # default off.\n        enabled         on;\n        # when client(encoder) publish to vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_publish\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\", \"server_id\": \"vid-werty\",\n        #           \"stream_url\": \"video.test.com/live/livestream\", \"stream_id\": \"vid-124q9y3\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_publish http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_publish https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        # when client(encoder) stop publish to vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_unpublish\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\", \"server_id\": \"vid-werty\",\n        #           \"stream_url\": \"video.test.com/live/livestream\", \"stream_id\": \"vid-124q9y3\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_unpublish http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_unpublish https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        # when client start to play vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_play\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"pageUrl\": \"http://www.test.com/live.html\", \"server_id\": \"vid-werty\",\n        #           \"stream_url\": \"video.test.com/live/livestream\", \"stream_id\": \"vid-124q9y3\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_play http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_play https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        # when client stop to play vhost/app/stream, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_stop\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\", \"server_id\": \"vid-werty\",\n        #           \"stream_url\": \"video.test.com/live/livestream\", \"stream_id\": \"vid-124q9y3\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        # support multiple api hooks, format:\n        #       on_stop http://xxx/api0 http://xxx/api1 http://xxx/apiN\n        # @remark For SRS4, the HTTPS url is supported, for example:\n        #       on_stop https://xxx/api0 https://xxx/api1 https://xxx/apiN\n        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        # when srs reap a dvr file, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_dvr\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"cwd\": \"/usr/local/srs\",\n        #           \"file\": \"./objs/nginx/html/live/livestream.1420254068776.flv\", \"server_id\": \"vid-werty\",\n        #           \"stream_url\": \"video.test.com/live/livestream\", \"stream_id\": \"vid-124q9y3\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;\n        # when srs reap a ts file of hls, call the hook,\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_hls\",\n        #           \"client_id\": \"9308h583\",\n        #           \"ip\": \"192.168.1.10\", \"vhost\": \"video.test.com\", \"app\": \"live\",\n        #           \"stream\": \"livestream\", \"param\":\"?token=xxx&salt=yyy\",\n        #           \"duration\": 9.36, // in seconds\n        #           \"cwd\": \"/usr/local/srs\",\n        #           \"file\": \"./objs/nginx/html/live/livestream/2015-04-23/01/476584165.ts\",\n        #           \"url\": \"live/livestream/2015-04-23/01/476584165.ts\",\n        #           \"m3u8\": \"./objs/nginx/html/live/livestream/live.m3u8\",\n        #           \"m3u8_url\": \"live/livestream/live.m3u8\",\n        #           \"seq_no\": 100, \"server_id\": \"vid-werty\",\n        #           \"stream_url\": \"video.test.com/live/livestream\", \"stream_id\": \"vid-124q9y3\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       0\n        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;\n        # when srs reap a ts file of hls, call this hook,\n        # used to push file to cdn network, by get the ts file from cdn network.\n        # so we use HTTP GET and use the variable following:\n        #       [server_id], replace with the server_id\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [param], replace with the param.\n        #       [ts_url], replace with the ts url.\n        # ignore any return data of server.\n        # @remark random select a url to report, not report all.\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[server_id]/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Looped RTMP Stream using FFmpeg in Docker\nDESCRIPTION: Runs FFmpeg inside an `ossrs/srs:encoder` Docker container to publish a stream. It reads `doc/source.flv` repeatedly (`-stream_loop -1`), maintains native frame rate (`-re`), copies codecs without transcoding (`-c copy`), and sends the stream via RTMP (`-f flv`) to the SRS server running on the Docker host (`rtmp://host.docker.internal/live/livestream`). This is useful for continuously testing the RTMP ingest.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Heartbeat in NGINX-style Config\nDESCRIPTION: Configuration block for SRS heartbeat feature with settings for enabling/disabling, interval timing, callback URL, device identification, and summary reporting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nheartbeat {\n    # whether heartbeat is enabled.\n    # Overwrite by env SRS_HEARTBEAT_ENABLED\n    # default: off\n    enabled off;\n    # the interval seconds for heartbeat,\n    # recommend 0.3,0.6,0.9,1.2,1.5,1.8,2.1,2.4,2.7,3,...,6,9,12,....\n    # Overwrite by env SRS_HEARTBEAT_INTERVAL\n    # default: 9.9\n    interval 9.3;\n    # when startup, srs will heartbeat to this api.\n    # @remark: must be a restful http api url, where SRS will POST with following data:\n    #   {\n    #       \"device_id\": \"my-srs-device\",\n    #       \"ip\": \"192.168.1.100\"\n    #   }\n    # Overwrite by env SRS_HEARTBEAT_URL\n    # default: http://127.0.0.1:8085/api/v1/servers\n    url http://127.0.0.1:8085/api/v1/servers;\n    # the id of device.\n    # Overwrite by env SRS_HEARTBEAT_DEVICE_ID\n    device_id       \"my-srs-device\";\n    # whether report with summaries\n    # if on, put /api/v1/summaries to the request data:\n    #   {\n    #       \"summaries\": summaries object.\n    #   }\n    # @remark: optional config.\n    # Overwrite by env SRS_HEARTBEAT_SUMMARIES\n    # default: off\n    summaries off;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Multi-threaded Application with State Threads in C\nDESCRIPTION: A complete example demonstrating how to create multiple state threads (coroutines) that can run concurrently. Each thread executes an infinite loop with different sleep intervals, showcasing how ST can handle thousands of concurrent connections with minimal resource usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-02-26-State-Threads-for-Internet-Applications.md#2025-04-23_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include \"st.h\"\n\nvoid* do_calc(void* arg){\n    int sleep_ms = (int)(long int)(char*)arg * 10;\n    \n    for(;;){\n        printf(\"in sthread #%dms\\n\", sleep_ms);\n        st_usleep(sleep_ms * 1000);\n    }\n    \n    return NULL;\n}\n\nint main(int argc, char** argv){\n    if(argc <= 1){\n        printf(\"Test the concurrence of state-threads!\\n\");\n        printf(\"Usage: %s <sthread_count>\\n\");\n        printf(\"eg. %s 10000\\n\", argv[0], argv[0]);\n        return -1;\n    }\n    \n    if(st_init() < 0){\n        printf(\"st_init error!\");\n        return -1;\n    }\n    \n    int i;\n    int count = atoi(argv[1]);\n    for(i = 1; i <= count; i++){\n        if(st_thread_create(do_calc, (void*)i, 0, 0) == NULL){\n            printf(\"st_thread_create error!\");\n            return -1;\n        }\n    }\n    \n    st_thread_exit(NULL);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with HTTPS\nDESCRIPTION: Docker command to run SRS with HTTPS configuration for secure WebRTC streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/https.docker.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Servers with Kubernetes Deployment\nDESCRIPTION: This snippet creates a ConfigMap containing the SRS Edge configuration, a Deployment for multiple Edge server replicas, and a LoadBalancer Service to expose the streaming endpoints externally. The Edge servers are configured to connect to the Origin server via internal service discovery.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-service;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-edge-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-edge\n  ports:\n  - name: srs-edge-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-edge-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for HTTP-FLV\nDESCRIPTION: Command to run an SRS Docker container configured for HTTP-FLV live streaming. It exposes ports 1935 and 8080, and uses the http.flv.live.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/flv.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:5 \\\n  ./objs/srs -c conf/http.flv.live.conf\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Edge Deployment for Canary Release in Kubernetes\nDESCRIPTION: This YAML configuration creates a deployment for SRS edge servers with version 4.0.5, setting up 3 replicas and necessary labels for canary release.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-r5-deploy\n  labels:\n    run: srs-edge-r5\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      run: srs-edge-r5\n  template:\n    metadata:\n      labels:\n        run: srs-edge-r5\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:v4.0.5\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"/usr/local/srs/etc/init.d/srs\", \"grace\"]\n      terminationGracePeriodSeconds: 120\n```\n\n----------------------------------------\n\nTITLE: Running RTMP to WebRTC Configuration in SRS with Docker\nDESCRIPTION: Docker command to run SRS with RTMP to WebRTC conversion configuration, exposing necessary ports and setting the CANDIDATE environment variable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:4 \\\n  objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Deploying Oryx Docker Container for Low Latency Streaming\nDESCRIPTION: Docker command to run Oryx streaming server with all necessary port mappings and volume configuration for persistent data storage. Exposes ports for HTTP(80), HTTPS(443), RTMP(1935), and UDP(8000, 10080).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-01-06-HLS-5s-Low-Latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for RTMP to WebRTC Conversion\nDESCRIPTION: Launches an SRS Docker container configured to convert RTMP streams to WebRTC, using a specific configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Running the SRS Server Binary with a Configuration File - Shell\nDESCRIPTION: This shell command executes the SRS server using a specified configuration file, typically after the server has been compiled. It assumes that the binary resides in the ./objs directory and the configuration file is at conf/console.conf. Inputs are the binary path and config file; output is a running SRS instance. The server must be built beforehand. No dependencies beyond the compiled binary and config file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n```\n./objs/srs -c conf/console.conf\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Origin Cluster in SRS YAML\nDESCRIPTION: This snippet shows how to configure the Origin Cluster feature in the SRS configuration file. It includes settings for cluster mode, enabling origin cluster, and specifying coworkers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            local;\n\n        # For origin(mode local) cluster, turn on the cluster.\n        # @remark Origin cluster only supports RTMP, use Edge to transmux RTMP to FLV.\n        # default: off\n        # TODO: FIXME: Support reload.\n        origin_cluster      on;\n\n        # For origin (mode local) cluster, the co-worker's HTTP APIs.\n        # This origin will connect to co-workers and communicate with them.\n        # please read: https://ossrs.io/lts/en-us/docs/v4/doc/origin-cluster\n        # TODO: FIXME: Support reload.\n        coworkers           127.0.0.1:9091 127.0.0.1:9092;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Real-time Configuration\nDESCRIPTION: Configuration file for SRS low latency mode with TCP nodelay enabled, minimum latency settings, and GOP cache disabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-realtime.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/realtime.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Origin ServerB Configuration\nDESCRIPTION: Configuration file for the second origin server (ServerB) with cluster settings, HTTP API, and basic server parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverB.conf\nlisten              19351;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverB.pid;\nhttp_api {\n    enabled         on;\n    listen          9091;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9090;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Parameters in SRS vhost (SRS Config)\nDESCRIPTION: This configuration snippet, specific to the SRS media server (though tagged as bash), defines HLS settings for the `__defaultVhost__`. It enables HLS (`enabled on`), sets the TS segment duration (`hls_fragment`), M3U8 playlist window size (`hls_window`), specifies paths and naming conventions for M3U8 and TS files using variables like `[app]` and `[stream]`. It also covers default codecs (`hls_acodec`, `hls_vcodec`), error handling (`hls_on_error`), segment cleanup (`hls_cleanup`), AES encryption (`hls_keys`), and session context management (`hls_ctx`). Many parameters can be overridden via environment variables, as indicated by the comments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether the hls is enabled.\n        # if off, do not write hls(ts and m3u8) when publish.\n        # Overwrite by env SRS_VHOST_HLS_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n\n        # the hls fragment in seconds, the duration of a piece of ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENT for all vhosts.\n        # default: 10\n        hls_fragment 10;\n        # the hls m3u8 target duration ratio,\n        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init\n        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts\n        # Overwrite by env SRS_VHOST_HLS_HLS_TD_RATIO for all vhosts.\n        # default: 1.0\n        hls_td_ratio 1.0;\n        # the audio overflow ratio.\n        # for pure audio, the duration to reap the segment.\n        # for example, the hls_fragment is 10s, hls_aof_ratio is 1.2,\n        # the segment will reap to 12s for pure audio.\n        # Overwrite by env SRS_VHOST_HLS_HLS_AOF_RATIO for all vhosts.\n        # default: 1.2\n        hls_aof_ratio 1.2;\n        # the hls window in seconds, the number of ts in m3u8.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WINDOW for all vhosts.\n        # default: 60\n        hls_window 60;\n        # the error strategy. can be:\n        #       ignore, disable the hls.\n        #       disconnect, require encoder republish.\n        #       continue, ignore failed try to continue output hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_ON_ERROR for all vhosts.\n        # default: continue\n        hls_on_error continue;\n        # the hls output path.\n        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream].m3u8\n        # the ts file is configured by hls_path/hls_ts_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream]-[seq].ts\n        # @remark the hls_path is compatible with srs v1 config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_PATH for all vhosts.\n        # default: ./objs/nginx/html\n        hls_path ./objs/nginx/html;\n        # the hls m3u8 file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        # Overwrite by env SRS_VHOST_HLS_HLS_M3U8_FILE for all vhosts.\n        # default: [app]/[stream].m3u8\n        hls_m3u8_file [app]/[stream].m3u8;\n        # the hls ts file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        #       [seq], the sequence number of ts.\n        #       [duration], replace this const to current ts duration.\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#hls-config\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FILE for all vhosts.\n        # default: [app]/[stream]-[seq].ts\n        hls_ts_file [app]/[stream]-[seq].ts;\n        # the hls entry prefix, which is base url of ts url.\n        # for example, the prefix is:\n        #         http://your-server/\n        # then, the ts path in m3u8 will be like:\n        #         http://your-server/live/livestream-0.ts\n        #         http://your-server/live/livestream-1.ts\n        #         ...\n        # Overwrite by env SRS_VHOST_HLS_HLS_ENTRY_PREFIX for all vhosts.\n        # optional, default to empty string.\n        hls_entry_prefix http://your-server;\n        # the default audio codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for mp3.\n        # the available audio codec:\n        #       aac, mp3, an\n        # Overwrite by env SRS_VHOST_HLS_HLS_ACODEC for all vhosts.\n        # default: aac\n        hls_acodec aac;\n        # the default video codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for pure audio(without video) to vn.\n        # the available video codec:\n        #       h264, vn\n        # Overwrite by env SRS_VHOST_HLS_HLS_VCODEC for all vhosts.\n        # default: h264\n        hls_vcodec h264;\n        # whether cleanup the old expired ts files.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CLEANUP for all vhosts.\n        # default: on\n        hls_cleanup on;\n        # If there is no incoming packets, dispose HLS in this timeout in seconds,\n        # which removes all HLS files including m3u8 and ts files.\n        # @remark 0 to disable dispose for publisher.\n        # @remark apply for publisher timeout only, while \"etc/init.d/srs stop\" always dispose hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DISPOSE for all vhosts.\n        # default: 120\n        hls_dispose 120;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WAIT_KEYFRAME for all vhosts.\n        # default: on\n        hls_wait_keyframe on;\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enhanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FLOOR for all vhosts.\n        # default: off\n        hls_ts_floor off;\n        # the max size to notify hls,\n        # to read max bytes from ts of specified cdn network,\n        # @remark only used when on_hls_notify is config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_NB_NOTIFY for all vhosts.\n        # default: 64\n        hls_nb_notify 64;\n\n        # Whether enable hls_ctx for HLS streaming, for which we create a \"fake\" connection for HTTP API and callback.\n        # For each HLS streaming session, we use a child m3u8 with a session identified by query \"hls_ctx\", it simply\n        # work as the session id.\n        # Once the HLS streaming session is created, we will cleanup it when timeout in 2*hls_window seconds. So it\n        # takes a long time period to identify the timeout.\n        # Now we got a HLS stremaing session, just like RTMP/WebRTC/HTTP-FLV streaming, we're able to stat the session\n        # as a \"fake\" connection, do HTTP callback when start playing the HLS streaming. You're able to do querying and\n        # authentication.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CTX for all vhosts.\n        # Default: on\n        hls_ctx on;\n        # For HLS pseudo streaming, whether enable the session for each TS segment.\n        # If enabled, SRS HTTP API will show the statistics about HLS streaming bandwidth, both m3u8 and ts file. Please\n        # note that it also consumes resource, because each ts file should be served by SRS, all NGINX cache will be\n        # missed because we add session id to each ts file.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_CTX for all vhosts.\n        # Default: on\n        hls_ts_ctx on;\n\n        # whether using AES encryption.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEYS for all vhosts.\n        # default: off\n        hls_keys on;\n        # the number of clear ts which one key can encrypt.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENTS_PER_KEY for all vhosts.\n        # default: 5\n        hls_fragments_per_key 5;\n        # the hls key file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [seq], the sequence number of key corresponding to the ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE for all vhosts.\n        hls_key_file [app]/[stream]-[seq].key;\n        # the key output path.\n        # the key file is configed by hls_path/hls_key_file, the default is:\n        # ./objs/nginx/html/[app]/[stream]-[seq].key\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE_PATH for all vhosts.\n        hls_key_file_path ./objs/nginx/html;\n        # the key root URL, use this can support https.\n        # @remark It's optional.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_URL for all vhosts.\n        hls_key_url https://localhost:8080;\n\n        # Special control controls.\n        ###########################################\n        # Whether calculate the DTS of audio frame directly.\n        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544\n        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.\n        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DTS_DIRECTLY for all vhosts.\n        # Default: on\n        hls_dts_directly on;\n\n        # on_hls, never config in here, should config in http_hooks.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP API Configuration\nDESCRIPTION: Complete configuration example for enabling HTTP/HTTPS API with statistics, authentication, and SSL support\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nstats {\n    network         0;\n    disk            sda sdb xvda xvdb;\n}\nhttp_api {\n    enabled         on;\n    listen          1985;\n    crossdomain     on;\n    raw_api {\n        enabled off;\n        allow_reload off;\n    }\n    auth {\n        enabled         on;\n        username        admin;\n        password        admin;\n    }\n    https {\n        enabled on;\n        listen 1986;\n        key ./conf/server.key;\n        cert ./conf/server.crt;\n    }\n}\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: SRS DVR Configuration Examples\nDESCRIPTION: Configuration example for DVR in SRS, showing all available options including enabled flag, apply filters, recording plans, output path formatting with variables, duration settings, and time jitter handling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/dvr.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # DVR RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv/mp4 according by specified dvr_plan.\n    dvr {\n        # whether enabled dvr features\n        # default: off\n        enabled         on;\n        # the filter for dvr to apply to.\n        #       all, dvr all streams of all apps.\n        #       <app>/<stream>, apply to specified stream of app.\n        # for example, to dvr the following two streams:\n        #       live/stream1 live/stream2\n        # default: all\n        dvr_apply       all;\n        # the dvr plan. canbe:\n        #       session reap flv/mp4 when session end(unpublish).\n        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.\n        # @remark The plan append is removed in SRS3+, for it's no use.\n        # default: session\n        dvr_plan        session;\n        # the dvr output path, *.flv or *.mp4.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        # @remark we use golang time format \"2006-01-02 15:04:05.999\" as \"[2006]-[01]-[02]_[15].[04].[05]_[999]\"\n        # for example, for url rtmp://ossrs.net/live/livestream and time 2015-01-03 10:57:30.776\n        # 1. No variables, the rule of SRS1.0(auto add [stream].[timestamp].flv as filename):\n        #       dvr_path ./objs/nginx/html;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.flv;\n        # 2. Use stream and date as dir name, time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03/10.57.30.776.flv;\n        # 3. Use stream and year/month as dir name, date and time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03-10.57.30.776.flv;\n        # 4. Use vhost/app and year/month as dir name, stream/date/time as filename:\n        #       dvr_path /data/[vhost]/[app]/[2006]/[01]/[stream]-[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/2015/01/livestream-03-10.57.30.776.flv;\n        # 5. DVR to mp4:\n        #       dvr_path ./objs/nginx/html/[app]/[stream].[timestamp].mp4;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.mp4;\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        #       segment,session apply it.\n        # default: ./objs/nginx/html/[app]/[stream].[timestamp].flv\n        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        # the duration for dvr file, reap if exceed, in seconds.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: 30\n        dvr_duration    30;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the dvr_duration,\n        # if on, reap segment when duration exceed and got keyframe.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: on\n        dvr_wait_keyframe       on;\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # apply for all dvr plan.\n        # default: full\n        time_jitter             full;\n\n        # on_dvr, never config in here, should config in http_hooks.\n        # for the dvr http callback, @see http_hooks.on_dvr of vhost hooks.callback.srs.com\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#http-callback\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#http-callback\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Playing HEVC Stream over RTMP via ffplay - Bash\nDESCRIPTION: This command line shows how to use ffplay, an FFmpeg component, to play back an HEVC stream from an RTMP endpoint. ffplay connects directly to the running SRS server and plays the live stream. Requires a pre-running SRS server and ffplay binary. Input: RTMP URL; Output: Playback window displaying the HEVC video in real-time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./ffplay rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Deployment for SRS and Nginx with Shared Volume\nDESCRIPTION: This YAML manifest creates a Kubernetes deployment that runs SRS and Nginx containers with a shared emptyDir volume. The SRS container writes HLS segments to the shared volume while Nginx serves these files. It also includes an initialization container to copy default SRS files to the volume.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deploy\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\nEOF\n```\n\n----------------------------------------\n\nTITLE: HTTP-FLV Server Configuration for SRS\nDESCRIPTION: Complete configuration for enabling HTTP-FLV streaming in SRS. Includes HTTP server settings and vhost configurations with options for stream handling, caching, and format specifications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/flv.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    # whether http streaming service is enabled.\n    # Overwrite by env SRS_HTTP_SERVER_ENABLED\n    # default: off\n    enabled on;\n    # the http streaming listen entry is <[ip:]port>\n    # for example, 192.168.1.100:8080\n    # where the ip is optional, default to 0.0.0.0, that is 8080 equals to 0.0.0.0:8080\n    # @remark, if use lower port, for instance 80, user must start srs by root.\n    # Overwrite by env SRS_HTTP_SERVER_LISTEN\n    # default: 8080\n    listen 8080;\n    # whether enable crossdomain request.\n    # for both http static and stream server and apply on all vhosts.\n    # Overwrite by env SRS_HTTP_SERVER_CROSSDOMAIN\n    # default: on\n    crossdomain on;\n}\nvhost __defaultVhost__ {\n    # http flv/mp3/aac/ts stream vhost specified config\n    http_remux {\n        # whether enable the http live streaming service for vhost.\n        # Overwrite by env SRS_VHOST_HTTP_REMUX_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n        # the fast cache for audio stream(mp3/aac),\n        # to cache more audio and send to client in a time to make android(weixin) happy.\n        # @remark the flv/ts stream ignore it\n        # @remark 0 to disable fast cache for http audio stream.\n        # Overwrite by env SRS_VHOST_HTTP_REMUX_FAST_CACHE for all vhosts.\n        # default: 0\n        fast_cache 30;\n        # Whether drop packet if not match header. For example, there is has_audio and has video flag in FLV header, if\n        # this is set to on and has_audio is false, then SRS will drop audio packets when got audio packets. Generally\n        # it should work, but sometimes you might need SRS to keep packets even when FLV header is set to false.\n        # See https://github.com/ossrs/srs/issues/939#issuecomment-1348740526\n        # TODO: Only support HTTP-FLV stream right now.\n        # Overwrite by env SRS_VHOST_HTTP_REMUX_DROP_IF_NOT_MATCH for all vhosts.\n        # Default: on\n        drop_if_not_match on;\n        # Whether stream has audio track, used as default value for stream metadata, for example, FLV header contains\n        # this flag. Sometimes you might want to force the metadata by disable guess_has_av.\n        # For HTTP-FLV, use this as default value for FLV header audio flag. See https://github.com/ossrs/srs/issues/939#issuecomment-1351385460\n        # For HTTP-TS, use this as default value for PMT table. See https://github.com/ossrs/srs/issues/939#issuecomment-1365086204\n        # Overwrite by env SRS_VHOST_HTTP_REMUX_HAS_AUDIO for all vhosts.\n        # Default: on\n        has_audio on;\n        # Whether stream has video track, used as default value for stream metadata, for example, FLV header contains\n        # this flag. Sometimes you might want to force the metadata by disable guess_has_av.\n        # For HTTP-FLV, use this as default value for FLV header video flag. See https://github.com/ossrs/srs/issues/939#issuecomment-1351385460\n        # For HTTP-TS, use this as default value for PMT table. See https://github.com/ossrs/srs/issues/939#issuecomment-1365086204\n        # Overwrite by env SRS_VHOST_HTTP_REMUX_HAS_VIDEO for all vhosts.\n        # Default: on\n        has_video on;\n        # Whether guessing stream about audio or video track, used to generate the flags in, such as FLV header. If\n        # guessing, depends on sequence header and frames in gop cache, so it might be incorrect especially your stream\n        # is not regular. If not guessing, use the configured default value has_audio and has_video.\n        # For HTTP-FLV, enable guessing for av header flag, because FLV can't change the header. See https://github.com/ossrs/srs/issues/939#issuecomment-1351385460\n        # For HTTP-TS, ignore guessing because TS refresh the PMT when codec changed. See https://github.com/ossrs/srs/issues/939#issuecomment-1365086204\n        # Overwrite by env SRS_VHOST_HTTP_REMUX_GUESS_HAS_AV for all vhosts.\n        # Default: on\n        guess_has_av on;\n        # the stream mount for rtmp to remux to live streaming.\n        # typical mount to [vhost]/[app]/[stream].flv\n        # the variables:\n        #       [vhost] current vhost for http live stream.\n        #       [app] current app for http live stream.\n        #       [stream] current stream for http live stream.\n        # @remark the [vhost] is optional, used to mount at specified vhost.\n        # the extension:\n        #       .flv mount http live flv stream, use default gop cache.\n        #       .ts mount http live ts stream, use default gop cache.\n        #       .mp3 mount http live mp3 stream, ignore video and audio mp3 codec required.\n        #       .aac mount http live aac stream, ignore video and audio aac codec required.\n        # for example:\n        #       mount to [vhost]/[app]/[stream].flv\n        #           access by http://ossrs.net:8080/live/livestream.flv\n        #       mount to /[app]/[stream].flv\n        #           access by http://ossrs.net:8080/live/livestream.flv\n        #           or by http://192.168.1.173:8080/live/livestream.flv\n        #       mount to [vhost]/[app]/[stream].mp3\n        #           access by http://ossrs.net:8080/live/livestream.mp3\n        #       mount to [vhost]/[app]/[stream].aac\n        #           access by http://ossrs.net:8080/live/livestream.aac\n        #       mount to [vhost]/[app]/[stream].ts\n        #           access by http://ossrs.net:8080/live/livestream.ts\n        # @remark the port of http is specified by http_server section.\n        # Overwrite by env SRS_VHOST_HTTP_REMUX_MOUNT for all vhosts.\n        # default: [vhost]/[app]/[stream].flv\n        mount [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example SRS DASH Configuration File - Bash\nDESCRIPTION: This snippet provides an example DASH configuration ('conf/dash.conf') for SRS. It configures server listening ports, connection limits, logging, and enables the DASH streaming feature with HTTP delivery settings. Key configuration parameters include HTTP listen port, DASH fragment duration, live timeshift, output directory, and MPD manifest filename. Intended for placing in the conf/ directory and referenced during SRS startup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-dash.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/dash.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    dash {\n        enabled         on;\n        dash_fragment       30;\n        dash_update_period  150;\n        dash_timeshift      300;\n        dash_path           ./objs/nginx/html;\n        dash_mpd_file       [app]/[stream].mpd;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing SRS with systemctl Support for Ubuntu 20\nDESCRIPTION: Complete command sequence to install SRS, configure it as both an init.d service and a systemctl service for Ubuntu 20. This includes building, installing, linking, and enabling the service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && sudo make install &&\nsudo ln -sf /usr/local/srs/etc/init.d/srs /etc/init.d/srs &&\nsudo cp -f /usr/local/srs/usr/lib/systemd/system/srs.service /usr/lib/systemd/system/srs.service &&\nsudo systemctl daemon-reload && sudo systemctl enable srs\n```\n\n----------------------------------------\n\nTITLE: Edge Server Configuration\nDESCRIPTION: Configuration file for the edge SRS server, including cluster mode settings and origin server connection details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callbacks using Node.js and Koa\nDESCRIPTION: This Node.js code snippet uses the Koa framework and `koa-router` to create an API endpoint (`/api/v1/streams`) that handles SRS callback requests. It defines a route that accepts any HTTP method (`.all`), logs the received request body to the console, and sets the response body to the standard JSON success format (`{code: 0, msg: 'OK'}`). Requires `koa` and `koa-router` npm packages to be installed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_8\n\nLANGUAGE: js\nCODE:\n```\nconst Router = require('koa-router');\nconst router = new Router();\n\nrouter.all('/api/v1/streams', async (ctx) => {\n  console.log(ctx.request.body);\n\n  ctx.body = {code: 0, msg: 'OK'};\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring the First Origin Server (ServerA)\nDESCRIPTION: Configuration for the first origin server in the cluster. This defines server parameters including listening port, connections limit, and cluster settings with coworker reference to the second origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverA.conf\nlisten              19350;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverA.pid;\nhttp_api {\n    enabled         on;\n    listen          9090;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9091;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Raw API Configuration in SRS\nDESCRIPTION: Example configuration for enabling HTTP Raw API in SRS. This configuration allows both read and write operations through the HTTP API, including the reload feature.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nhttp_api {\n    enabled         on;\n    listen          1985;\n    raw_api {\n        enabled             on;\n        allow_reload        on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Referer Anti-Suck in SRS (bash)\nDESCRIPTION: This configuration snippet demonstrates how to enable and configure referer-based anti-leeching within a specific SRS virtual host (`refer.anti_suck.com`). It allows restricting access based on the HTTP referer header sent by the client's browser or player. You can specify allowed domains for all connections (`all`), publishing (`publish`), and playback (`play`). If `enabled` is set to `on`, only requests originating from pages hosted on the specified domains (e.g., `github.com`, `github.io`) will be permitted.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/drm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the vhost for anti-suck.\nvhost refer.anti_suck.com {\n    # refer hotlink-denial.\n    refer {\n        # whether enable the refer hotlink-denial.\n        # default: off.\n        enabled         on;\n        # the common refer for play and publish.\n        # if the page url of client not in the refer, access denied.\n        # if not specified this field, allow all.\n        # default: not specified.\n        all           github.com github.io;\n        # refer for publish clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        publish   github.com github.io;\n        # refer for play clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        play      github.com github.io;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Kubernetes Deployment Architecture with Multiple Proxy Servers\nDESCRIPTION: Detailed diagram of Kubernetes deployment architecture showing load balancer, multiple proxy servers using Redis/MESH for state synchronization, and multiple origin servers as deployments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n                         +-----------------------+\n                     +---+ SRS Proxy(Deployment) +------+---------------------+\n+-----------------+  |   +-----------+-----------+      +                     +\n| LB(K8s Service) +--+               +(Redis/MESH)      + SRS Origin Servers  +\n+-----------------+  |   +-----------+-----------+      +    (Deployment)     +\n                     +---+ SRS Proxy(Deployment) +------+---------------------+\n                         +-----------------------+\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Source Repository - Bash\nDESCRIPTION: This Bash command snippet updates the existing SRS repository by fetching and merging the latest changes. Requires Git to be installed and the user to be inside the SRS repository directory. The output is the repository updated to the latest codebase.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Callback for DVR Events - SRS Config - Config\nDESCRIPTION: This code block demonstrates how to enable DVR and HTTP callback hooks within an SRS server vhost configuration block. By setting the 'enabled' property for both 'dvr' and 'http_hooks', and specifying the DVR path template and on_dvr callback URL, SRS will record streams into segmented files and notify a designated HTTP API endpoint when new segments are created. The configuration depends on a running SRS instance, and expects an API server at the URL specified. Important parameters include 'dvr_path' for file storage and 'on_dvr' for HTTP notification. The config must be placed within a vhost to take effect.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/dvr.md#2025-04-23_snippet_3\n\nLANGUAGE: config\nCODE:\n```\nvhost your_vhost {\n    dvr {\n        enabled             on;\n        dvr_path            ./objs/nginx/html/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        dvr_plan            segment;\n        dvr_duration        30;\n        dvr_wait_keyframe   on;\n    }\n    http_hooks {\n        enabled         on;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Docker Container with HTTPS Support\nDESCRIPTION: Launches SRS with HTTPS configuration for secure WebRTC streaming\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 ./objs/srs -c conf/https.docker.conf\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for HLS Transcoding\nDESCRIPTION: Configuration file for SRS that enables HLS and transcoding capabilities. It sets up an HTTP server, configures HLS settings, and defines an FFmpeg transcoding engine that copies video and converts audio to AAC format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/transcode2hls.audio.only.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting First SRS Edge Server with SO_REUSEPORT\nDESCRIPTION: This command starts the first SRS Edge server instance using the configuration specified in `conf/edge.conf`. The configuration file must enable the `reuse_port` option for this feature to work.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge.conf\n```\n\n----------------------------------------\n\nTITLE: Nginx Reverse Proxy Configuration\nDESCRIPTION: NGINX configuration for proxying requests to SRS HTTP server including SSL and various endpoints.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-server.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nworker_processes  1;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include             /etc/nginx/mime.types;\n\n    server {\n        listen       80;\n        listen       443 ssl http2;\n        server_name  _;\n        ssl_certificate      /usr/local/srs/conf/server.crt;\n        ssl_certificate_key  /usr/local/srs/conf/server.key;\n\n        location ~ ^/(console|players)/ {\n           proxy_pass http://127.0.0.1:8080/$request_uri;\n        }\n        location ~ ^/.+/.*\\.(flv|m3u8|ts|aac|mp3)$ {\n           proxy_pass http://127.0.0.1:8080$request_uri;\n        }\n        location ~ ^/(api|rtc)/ {\n           proxy_pass http://127.0.0.1:1985$request_uri;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server Parameters in SRS\nDESCRIPTION: This configuration block defines the settings for the SRT server in SRS, including network parameters, connection timeouts, latency settings, and security options. It controls both server behavior and client connection requirements.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    # whether SRT server is enabled.\n    # Overwrite by env SRS_SRT_SERVER_ENABLED\n    # default: off\n    enabled on;\n    # The UDP listen port for SRT.\n    # Overwrite by env SRS_SRT_SERVER_LISTEN\n    listen 10080;\n    # For detail parameters, please read wiki:\n    # @see https://ossrs.net/lts/zh-cn/docs/v5/doc/srt-params\n    # @see https://ossrs.io/lts/en-us/docs/v5/doc/srt-params\n    # The maxbw is the max bandwidth of the sender side.\n    # \t-1: Means the biggest bandwidth is infinity.\n    # \t 0: Means the bandwidth is determined by SRTO_INPUTBW.\n    # \t>0: Means the bandwidth is the configuration value.\n    # Overwrite by env SRS_SRT_SERVER_MAXBW\n    # default: -1\n    maxbw 1000000000;\n    # Maximum Segment Size. Used for buffer allocation and rate calculation using packet counter assuming fully\n    # filled packets. Each party can set its own MSS value independently. During a handshake the parties exchange\n    # MSS values, and the lowest is used.\n    # Overwrite by env SRS_SRT_SERVER_MSS\n    # default: 1500\n    mss 1500;\n    # The timeout time of the SRT connection on the sender side in ms. When SRT connects to a peer costs time \n    # more than this config, it will be close.\n    # Overwrite by env SRS_SRT_SERVER_CONNECT_TIMEOUT\n    # default: 3000\n    connect_timeout 4000;\n\t# The timeout time of SRT connection on the receiver side in ms. When the SRT connection is idle \n    # more than this config, it will be close.\n    # Overwrite by env SRS_SRT_SERVER_PEER_IDLE_TIMEOUT\n    # default: 10000\n    peer_idle_timeout 8000;\n    # Default app for vmix, see https://github.com/ossrs/srs/pull/1615\n    # Overwrite by env SRS_SRT_SERVER_DEFAULT_APP\n    # default: live\n    default_app live;\n\t# The peerlatency is set by the sender side and will notify the receiver side.\n    # Overwrite by env SRS_SRT_SERVER_PEERLATENCY\n    # default: 0\n    peerlatency 0;\n\t# The recvlatency means latency from sender to receiver.\n    # Overwrite by env SRS_SRT_SERVER_RECVLATENCY\n    # default: 120\n    recvlatency 0;\n\t# This latency configuration configures both recvlatency and peerlatency to the same value.\n    # Overwrite by env SRS_SRT_SERVER_LATENCY\n    # default: 120\n    latency 0;\n\t# The tsbpd mode means timestamp based packet delivery.\n\t# SRT sender side will pack timestamp in each packet. If this config is true,\n\t# the receiver will read the packet according to the timestamp in the head of the packet.\n    # Overwrite by env SRS_SRT_SERVER_TSBPDMODE\n    # default: on\n    tsbpdmode off;\n\t# The tlpkdrop means too-late Packet Drop\n\t# SRT sender side will pack timestamp in each packet, When the network is congested,\n\t# the packet will drop if latency is bigger than the configuration in both sender side and receiver side.\n\t# And on the sender side, it also will be dropped because latency is bigger than configuration.\n    # Overwrite by env SRS_SRT_SERVER_TLPKTDROP\n    # default: on\n    tlpktdrop off;\n\t# The send buffer size of SRT.\n    # Overwrite by env SRS_SRT_SERVER_SENDBUF\n    # default:  8192 * (1500-28)\n    sendbuf 2000000;\n\t# The recv buffer size of SRT.\n    # Overwrite by env SRS_SRT_SERVER_RECVBUF\n    # default:  8192 * (1500-28)\n    recvbuf 2000000;\n    # The passphrase of SRT.\n    # If passphrase is no empty, all the srt client must be using the correct passphrase to publish or play,\n    # or the srt connection will reject. The length of passphrase must be in range 10~79.\n    # @see https://github.com/Haivision/srt/blob/master/docs/API/API-socket-options.md#srto_passphrase.\n    # Overwrite by env SRS_SRT_SERVER_PASSPHRASE\n    # default: \"\"\n    passphrase xxxxxxxxxxxx;\n    # The pbkeylen of SRT.\n    # The pbkeylen determined the AES encrypt algorithm, this option only allow 4 values which is 0, 16, 24, 32\n    # @see https://github.com/Haivision/srt/blob/master/docs/API/API-socket-options.md#srto_pbkeylen.\n    # Overwrite by env SRS_SRT_SERVER_PBKEYLEN\n    # default: 0\n    pbkeylen 16;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTPS Callbacks in SRS (Conf)\nDESCRIPTION: This snippet shows an example SRS vhost configuration block for enabling HTTPS callbacks. It demonstrates setting `http_hooks { enabled on; }` and specifying `https://` URLs for various events like `on_publish`, `on_unpublish`, `on_play`, etc. This feature requires SRS version 4 or later.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_6\n\nLANGUAGE: conf\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        enabled         on;\n        on_publish      https://127.0.0.1:8085/api/v1/streams;\n        on_unpublish    https://127.0.0.1:8085/api/v1/streams;\n        on_play         https://127.0.0.1:8085/api/v1/sessions;\n        on_stop         https://127.0.0.1:8085/api/v1/sessions;\n        on_dvr          https://127.0.0.1:8085/api/v1/dvrs;\n        on_hls          https://127.0.0.1:8085/api/v1/hls;\n        on_hls_notify   https://127.0.0.1:8085/api/v1/hls/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP-FLV Configuration\nDESCRIPTION: Configuration file for HTTP-FLV live streaming, including server settings, HTTP server setup, and HTTP remux options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.flv.live.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Protocol Example for on_publish Event\nDESCRIPTION: This snippet demonstrates the HTTP callback protocol format for the on_publish event. It shows the HTTP POST request structure and the JSON body content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nPOST /api/v1/streams HTTP/1.1\nContent-Type: application-json\n\nBody:\n{\n  \"server_id\": \"vid-0xk989d\",\n  \"action\": \"on_publish\",\n  \"client_id\": \"341w361a\",\n  \"ip\": \"127.0.0.1\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"tcUrl\": \"rtmp://127.0.0.1:1935/live?vhost=__defaultVhost__\",\n  \"stream\": \"livestream\",\n  \"param\": \"\",\n  \"stream_url\": \"video.test.com/live/livestream\",\n  \"stream_id\": \"vid-124q9y3\"\n}\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Status\nDESCRIPTION: Commands to check the SRS process status and view server logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Check the process status\n./etc/init.d/srs status\n\n# Check the SRS logs\ntail -n 30 -f ./objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Building SRS - Bash\nDESCRIPTION: Configures and builds the SRS binaries in the local source code directory. Requires developer build tools (such as GCC, make, etc.) and sufficient user permissions. After running, produces the SRS server executables in the objs directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Cluster Settings\nDESCRIPTION: Configuration block for setting up an SRS origin cluster. Includes settings for cluster mode, origin cluster enablement, and coworker HTTP API endpoints. This configuration is applied within the default vhost context.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            local;\n\n        # For origin(mode local) cluster, turn on the cluster.\n        # @remark Origin cluster only supports RTMP, use Edge to transmux RTMP to FLV.\n        # default: off\n        # TODO: FIXME: Support reload.\n        origin_cluster      on;\n\n        # For origin (mode local) cluster, the co-worker's HTTP APIs.\n        # This origin will connect to co-workers and communicate with them.\n        # please read: https://ossrs.io/lts/en-us/docs/v4/doc/origin-cluster\n        # TODO: FIXME: Support reload.\n        coworkers           127.0.0.1:9091 127.0.0.1:9092;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Security Settings\nDESCRIPTION: Configuration block for setting up security rules in SRS vhost. Allows specifying allow/deny rules for publish and play actions based on IP addresses or CIDR ranges. The security system follows a sequential evaluation strategy where rules are applied in order after security is enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/security.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost your_vhost {\n    # security for host to allow or deny clients.\n    # @see https://github.com/ossrs/srs/issues/211   \n    security {\n        # whether enable the security for vhost.\n        # default: off\n        enabled         on;\n        # the security list, each item format as:\n        #       allow|deny    publish|play    all|<ip or cidr>\n        # for example:\n        #       allow           publish     all;\n        #       deny            publish     all;\n        #       allow           publish     127.0.0.1;\n        #       deny            publish     127.0.0.1;\n        #       allow           publish     10.0.0.0/8;\n        #       deny            publish     10.0.0.0/8; \n        #       allow           play        all;\n        #       deny            play        all;\n        #       allow           play        127.0.0.1;\n        #       deny            play        127.0.0.1;\n        #       allow           play        10.0.0.0/8;\n        #       deny            play        10.0.0.0/8;\n        # SRS apply the following simple strategies one by one:\n        #       1. allow all if security disabled.\n        #       2. default to deny all when security enabled.\n        #       3. allow if matches allow strategy.\n        #       4. deny if matches deny strategy.\n        allow           play        all;\n        allow           publish     all;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Exec in NGINX RTMP via SRS Configuration - NGINX\nDESCRIPTION: This configuration snippet demonstrates how to define an 'exec' section within a SRS virtual host to execute external commands, such as running FFmpeg when a stream is published. It documents how to enable or disable the feature, which variables are substituted in the command, and provides a sample command for publishing streams and transcoding them to FLV format. Dependencies include SRS with NGINX RTMP exec module support, FFmpeg availability in the specified path, and familiarity with SRS config structure. The relevant parameters include 'enabled' (to toggle the exec), 'publish' (the command run on stream events), and variables (like [url], [stream], etc.). The configuration should be included in an SRS config file (e.g., conf/exec.conf). The expected behavior is for SRS to run the command when a relevant event (such as 'publish') occurs, substituting event variables accordingly.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-exec.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    # the exec used to fork process when got some event.\n    exec {\n        # whether enable the exec.\n        # default: off.\n        enabled     off;\n        # when publish stream, exec the process with variables:\n        #       [vhost] the input stream vhost.\n        #       [port] the intput stream port.\n        #       [app] the input stream app.\n        #       [stream] the input stream name.\n        #       [engine] the tanscode engine name.\n        # other variables for exec only:\n        #       [url] the rtmp url which trigger the publish.\n        #       [tcUrl] the client request tcUrl.\n        #       [swfUrl] the client request swfUrl.\n        #       [pageUrl] the client request pageUrl.\n        # @remark empty to ignore this exec.\n        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Docker Container for WebRTC Live Streaming\nDESCRIPTION: Configures SRS for RTMP to WebRTC conversion using rtmp2rtc.conf configuration\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Server with Origin Reference\nDESCRIPTION: Example configuration for setting up an edge server that connects to a specific origin server, including basic settings and cluster configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/edge.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callbacks in PHP\nDESCRIPTION: This PHP script demonstrates a simple way to handle an incoming SRS callback request. It reads the raw POST data from the input stream (`php://input`), attempts to decode it as JSON, prints the resulting object/data using `printf` (useful for debugging), and then echoes a standard JSON success response (`{\"code\":0, \"msg\":\"OK\"}`). Assumes the web server is configured to execute PHP and handle the request.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_9\n\nLANGUAGE: php\nCODE:\n```\n$body = json_decode(file_get_contents('php://input'));\nprintf($body);\n\necho json_encode(array(\"code\"=>0, \"msg\"=>\"OK\"));\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG Transcoding in SRS\nDESCRIPTION: This snippet shows how to configure FFMPEG transcoding in the SRS configuration file. It includes settings for video and audio encoding, filters, and output formatting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # the streaming transcode configs.\n    transcode {\n        # whether the transcode enabled.\n        # if off, donot transcode.\n        # default: off.\n        enabled     on;\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine for matched stream.\n        # all matched stream will transcoded to the following stream.\n        # the transcode set name(ie. hd) is optional and not used.\n        engine example {\n            # whether the engine is enabled\n            # default: off.\n            enabled         on;\n            # input format, can be:\n            # off, do not specifies the format, ffmpeg will guess it.\n            # flv, for flv or RTMP stream.\n            # other format, for example, mp4/aac whatever.\n            # default: flv\n            iformat         flv;\n            # ffmpeg filters, follows the main input.\n            vfilter {\n                # the logo input file.\n                i               ./doc/ffmpeg-logo.png;\n                # the ffmpeg complex filter.\n                # for filters, @see: http://ffmpeg.org/ffmpeg-filters.html\n                filter_complex  'overlay=10:10';\n            }\n            # video encoder name. can be:\n            #       libx264: use h.264(libx264) video encoder.\n            #       png: use png to snapshot thumbnail.\n            #       copy: donot encoder the video stream, copy it.\n            #       vn: disable video output.\n            vcodec          libx264;\n            # video bitrate, in kbps\n            # @remark 0 to use source video bitrate.\n            # default: 0\n            vbitrate        1500;\n            # video framerate.\n            # @remark 0 to use source video fps.\n            # default: 0\n            vfps            25;\n            # video width, must be even numbers.\n            # @remark 0 to use source video width.\n            # default: 0\n            vwidth          768;\n            # video height, must be even numbers.\n            # @remark 0 to use source video height.\n            # default: 0\n            vheight         320;\n            # the max threads for ffmpeg to used.\n            # default: 1\n            vthreads        12;\n            # x264 profile, @see x264 -help, can be:\n            # high,main,baseline\n            vprofile        main;\n            # x264 preset, @see x264 -help, can be: \n            #       ultrafast,superfast,veryfast,faster,fast\n            #       medium,slow,slower,veryslow,placebo\n            vpreset         medium;\n            # other x264 or ffmpeg video params\n            vparams {\n                # ffmpeg options, @see: http://ffmpeg.org/ffmpeg.html\n                t               100;\n                # 264 params, @see: http://ffmpeg.org/ffmpeg-codecs.html#libx264\n                coder           1;\n                b_strategy      2;\n                bf              3;\n                refs            10;\n            }\n            # audio encoder name. can be:\n            #       libfdk_aac: use aac(libfdk_aac) audio encoder.\n            #       copy: donot encoder the audio stream, copy it.\n            #       an: disable audio output.\n            acodec          libfdk_aac;\n            # audio bitrate, in kbps. [16, 72] for libfdk_aac.\n            # @remark 0 to use source audio bitrate.\n            # default: 0\n            abitrate        70;\n            # audio sample rate. for flv/rtmp, it must be:\n            #       44100,22050,11025,5512\n            # @remark 0 to use source audio sample rate.\n            # default: 0\n            asample_rate    44100;\n            # audio channel, 1 for mono, 2 for stereo.\n            # @remark 0 to use source audio channels.\n            # default: 0\n            achannels       2;\n            # other ffmpeg audio params\n            aparams {\n                # audio params, @see: http://ffmpeg.org/ffmpeg-codecs.html#Audio-Encoders\n                # @remark SRS supported aac profile for HLS is: aac_low, aac_he, aac_he_v2\n                profile:a   aac_low;\n                bsf:a       aac_adtstoasc;\n            }\n            # output format, can be:\n            #       off, do not specifies the format, ffmpeg will guess it.\n            #       flv, for flv or RTMP stream.\n            #       image2, for vcodec png to snapshot thumbnail.\n            #       other format, for example, mp4/aac whatever.\n            # default: flv\n            oformat         flv;\n            # output stream. variables:\n            #       [vhost] the input stream vhost.\n            #       [port] the intput stream port.\n            #       [app] the input stream app.\n            #       [stream] the input stream name.\n            #       [engine] the tanscode engine name.\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Basic Authentication for SRS HTTP API\nDESCRIPTION: Configuration file to enable HTTP Basic Authentication for SRS HTTP API. Sets up authentication with username and password both set to 'admin'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.api.auth.conf\nhttp_api {\n    enabled on;\n    listen 1985;\n    auth {\n        enabled on;\n        username admin;\n        password admin;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Callback Handler in Go\nDESCRIPTION: Example Go code for handling SRS HTTP callbacks. Sets up an HTTP server to process callbacks and return the required response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nhttp.HandleFunc(\"/api/v1/streams\", func(w http.ResponseWriter, r *http.Request) {\n    b, err := ioutil.ReadAll(r.Body)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n\n    fmt.Println(string(b))\n\n    res, err := json.Marshal(struct {\n        Code int `json:\"code\"`\n        Message string `json:\"msg\"`\n    }{\n        0, \"OK\",\n    })\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n    w.Write(res)\n})\n\n_ = http.ListenAndServe(\":8085\", nil)\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for HLS\nDESCRIPTION: This command runs an SRS Docker container configured for HLS streaming. It maps ports 1935 and 8080, and uses the HLS configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:5 \\\n  ./objs/srs -c conf/hls.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Logrotate for SRS Log Management - Conf\nDESCRIPTION: This configuration snippet defines logrotate options for the SRS log file. It sets daily rotations, enables date extensions and compression, keeps 7 rotations, limits size to 1024M, and includes a post-rotation signal to SRS by reading its PID and sending USR1. Requires the logrotate package and proper paths for the log and PID files. Inputs: location of SRS log and PID file. Outputs: Rotated, compressed logs in place; runs the postrotate script for SRS integration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/log-rotate.md#2025-04-23_snippet_3\n\nLANGUAGE: conf\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    sharedscripts\n    postrotate\n        kill -USR1 \\`cat /usr/local/srs/objs/srs.pid\\`\n    endscript\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with HTTPS for WebRTC\nDESCRIPTION: This command runs the SRS Docker container with HTTPS configuration for secure WebRTC connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/https.docker.conf\n```\n\n----------------------------------------\n\nTITLE: Deploying SRS Edge Cluster with Kubernetes\nDESCRIPTION: This YAML configuration creates a Kubernetes edge cluster deployment. It sets up a ConfigMap containing SRS edge server configuration, deploys multiple edge server replicas, and establishes a LoadBalancer service to expose RTMP (1935) and HTTP-FLV (8080) streaming endpoints externally.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-service;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-edge-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-edge\n  ports:\n  - name: srs-edge-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-edge-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Building SRS with HTTP API Support in Bash\nDESCRIPTION: This command sequence configures the SRS build environment using './configure' and then compiles the source code using 'make'. The HTTP API is enabled by default in SRS builds.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP API Configuration\nDESCRIPTION: Complete configuration example for enabling HTTP API, system statistics, authentication, and HTTPS support in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nstats {\n    network         0;\n    disk            sda sdb xvda xvdb;\n}\nhttp_api {\n    enabled         on;\n    listen          1985;\n    crossdomain     on;\n    raw_api {\n        enabled off;\n        allow_reload off;\n    }\n    auth {\n        enabled         on;\n        username        admin;\n        password        admin;\n    }\n    https {\n        enabled on;\n        listen 1986;\n        key ./conf/server.key;\n        cert ./conf/server.crt;\n    }\n}\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for RTMP to RTC\nDESCRIPTION: Starts an SRS instance using Docker, configured for RTMP-to-RTC streaming by loading `conf/rtmp2rtc.conf`. It sets the required `CANDIDATE` environment variable with the server's public IP address and maps the necessary ports for RTMP (1935), HTTP (8080), HTTP API (1985), and WebRTC over UDP (8000). This setup allows ingesting an RTMP stream and delivering it via WebRTC (WHEP).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Enabling DVR and on_dvr HTTP Hook in SRS Configuration\nDESCRIPTION: This SRS configuration snippet demonstrates how to enable DVR functionality within a virtual host (`vhost`). It specifies DVR settings like path (`dvr_path`), plan (`dvr_plan`), segment duration (`dvr_duration`), and keyframe waiting (`dvr_wait_keyframe`). Crucially, it enables HTTP hooks (`http_hooks`) and defines the URL (`on_dvr`) where SRS will send a POST request when a DVR file is created or closed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/dvr.md#2025-04-23_snippet_2\n\nLANGUAGE: SRS Config\nCODE:\n```\nvhost your_vhost {\n    dvr {\n        enabled             on;\n        dvr_path            ./objs/nginx/html/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        dvr_plan            segment;\n        dvr_duration        30;\n        dvr_wait_keyframe   on;\n    }\n    http_hooks {\n        enabled         on;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTMP Configuration via Docker\nDESCRIPTION: Starts the SRS media server in a Docker container, exposing the default RTMP port 1935. It uses the `rtmp.conf` configuration file, enabling basic RTMP functionality. The `--rm -it` flags ensure the container is removed after exit and runs interactively.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 ossrs/srs:5 \\\n  ./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP API Authentication in SRS - bash\nDESCRIPTION: A sample SRS configuration for HTTP API authentication, specified either in config file or via environment variables. Setting 'enabled' and 'auth.enabled' to 'on' with credentials will require clients to authenticate. Can be directly included in the SRS config file or exported as environment variables for the SRS process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.api.auth.conf\nhttp_api {\n    enabled on;\n    listen 1985;\n    auth {\n        enabled on;\n        username admin;\n        password admin;\n    }\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\nenv SRS_HTTP_API_ENABLED=on SRS_HTTP_SERVER_ENABLED=on \\\n    SRS_HTTP_API_AUTH_ENABLED=on SRS_HTTP_API_AUTH_USERNAME=admin SRS_HTTP_API_AUTH_PASSWORD=admin \\\n    ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for HTTP and HLS in Bash\nDESCRIPTION: Sample configuration for SRS to enable HTTP server and HLS streaming. It sets up listening ports, maximum connections, and HLS parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.hls.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running WebRTC to RTMP Configuration in SRS with Docker\nDESCRIPTION: Docker command to run SRS with WebRTC to RTMP conversion configuration, allowing WebRTC published streams to be consumed via RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:4 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for WebRTC\nDESCRIPTION: Launches an SRS Docker container with additional ports and environment variables configured for WebRTC support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the transcoding configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/transcode2hls.audio.only.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Level in SRS\nDESCRIPTION: Configuration options for controlling the verbosity of SRS logs, from detailed trace logs to critical error logs. Supports both legacy v1 and newer v2 level specifications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# The log level for logging to console or file. It can be:\n#       verbose, info, trace, warn, error\n# If configure --log-level_v2=off, use SRS 4.0 level specs which is v1, the level text is:\n#       Verb, Info, Trace, Warn, Error\n# If configure --log-level_v2=on, use SRS 5.0 level specs which is v2, the level text is:\n#       TRACE, DEBUG, INFO, WARN, ERROR\n# Note: Do not support reloading, for SRS5+\n# Overwrite by env SRS_LOG_LEVEL or SRS_SRS_LOG_LEVEL\n# default: trace\nsrs_log_level trace;\n\n# The log level v2, rewrite the config srs_log_level if not empty, it can be:\n#       trace, debug, info, warn, error\n# If configure --log-level_v2=off, use SRS 4.0 level specs which is v1, the level text is:\n#       Verb, Info, Trace, Warn, Error\n# If configure --log-level_v2=on, use SRS 5.0 level specs which is v2, the level text is:\n#       TRACE, DEBUG, INFO, WARN, ERROR\n# Overwrite by env SRS_LOG_LEVEL_V2 or SRS_SRS_LOG_LEVEL_V2\nsrs_log_level_v2 info;\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR in SRS Vhost\nDESCRIPTION: A comprehensive example of DVR configuration options in SRS, including enabling DVR, setting the DVR plan, custom file paths, duration settings, and time jitter handling. This snippet demonstrates all available DVR parameters with detailed comments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # DVR RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv/mp4 according by specified dvr_plan.\n    dvr {\n        # whether enabled dvr features\n        # default: off\n        enabled         on;\n        # the filter for dvr to apply to.\n        #       all, dvr all streams of all apps.\n        #       <app>/<stream>, apply to specified stream of app.\n        # for example, to dvr the following two streams:\n        #       live/stream1 live/stream2\n        # default: all\n        dvr_apply       all;\n        # the dvr plan. canbe:\n        #       session reap flv/mp4 when session end(unpublish).\n        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.\n        # @remark The plan append is removed in SRS3+, for it's no use.\n        # default: session\n        dvr_plan        session;\n        # the dvr output path, *.flv or *.mp4.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        # @remark we use golang time format \"2006-01-02 15:04:05.999\" as \"[2006]-[01]-[02]_[15].[04].[05]_[999]\"\n        # for example, for url rtmp://ossrs.net/live/livestream and time 2015-01-03 10:57:30.776\n        # 1. No variables, the rule of SRS1.0(auto add [stream].[timestamp].flv as filename):\n        #       dvr_path ./objs/nginx/html;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.flv;\n        # 2. Use stream and date as dir name, time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03/10.57.30.776.flv;\n        # 3. Use stream and year/month as dir name, date and time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03-10.57.30.776.flv;\n        # 4. Use vhost/app and year/month as dir name, stream/date/time as filename:\n        #       dvr_path /data/[vhost]/[app]/[2006]/[01]/[stream]-[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/2015/01/livestream-03-10.57.30.776.flv;\n        # 5. DVR to mp4:\n        #       dvr_path ./objs/nginx/html/[app]/[stream].[timestamp].mp4;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.mp4;\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        #       segment,session apply it.\n        # default: ./objs/nginx/html/[app]/[stream].[timestamp].flv\n        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        # the duration for dvr file, reap if exceed, in seconds.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: 30\n        dvr_duration    30;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the dvr_duration,\n        # if on, reap segment when duration exceed and got keyframe.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: on\n        dvr_wait_keyframe       on;\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # apply for all dvr plan.\n        # default: full\n        time_jitter             full;\n\n        # on_dvr, never config in here, should config in http_hooks.\n        # for the dvr http callback, @see http_hooks.on_dvr of vhost hooks.callback.srs.com\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#http-callback\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#http-callback\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Exposing SRS via LoadBalancer Service in Kubernetes using Bash and YAML\nDESCRIPTION: This command uses a bash heredoc to pipe a YAML configuration to `kubectl apply`, creating a Kubernetes Service named `srs-service`. This service is of type `LoadBalancer`, which typically provisions a cloud load balancer (like Alibaba Cloud SLB if on ACK) to expose the SRS deployment externally. It maps the external ports 1935, 1985, and 8080 to the corresponding target ports on the pods selected by the `app: srs` label, enabling external access to RTMP, API, and HTTP streaming services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Log Level in Configuration File\nDESCRIPTION: Configuration options for setting the verbosity level of SRS logs. Specifies both legacy (v1) and newer (v2) log level formats, with options ranging from verbose trace logging to only critical error messages.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# The log level for logging to console or file. It can be:\n#       verbose, info, trace, warn, error\n# If configure --log-level_v2=off, use SRS 4.0 level specs which is v1, the level text is:\n#       Verb, Info, Trace, Warn, Error\n# If configure --log-level_v2=on, use SRS 5.0 level specs which is v2, the level text is:\n#       TRACE, DEBUG, INFO, WARN, ERROR\n# Note: Do not support reloading, for SRS5+\n# Overwrite by env SRS_LOG_LEVEL or SRS_SRS_LOG_LEVEL\n# default: trace\nsrs_log_level trace;\n\n# The log level v2, rewrite the config srs_log_level if not empty, it can be:\n#       trace, debug, info, warn, error\n# If configure --log-level_v2=off, use SRS 4.0 level specs which is v1, the level text is:\n#       Verb, Info, Trace, Warn, Error\n# If configure --log-level_v2=on, use SRS 5.0 level specs which is v2, the level text is:\n#       TRACE, DEBUG, INFO, WARN, ERROR\n# Overwrite by env SRS_LOG_LEVEL_V2 or SRS_SRS_LOG_LEVEL_V2\nsrs_log_level_v2 info;\n```\n\n----------------------------------------\n\nTITLE: DVR Configuration Example\nDESCRIPTION: Comprehensive configuration example for DVR settings in SRS including options for enabling DVR, setting plans, customizing paths, and controlling duration\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/dvr.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # DVR RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv/mp4 according by specified dvr_plan.\n    dvr {\n        # whether enabled dvr features\n        # default: off\n        enabled         on;\n        # the filter for dvr to apply to.\n        #       all, dvr all streams of all apps.\n        #       <app>/<stream>, apply to specified stream of app.\n        # for example, to dvr the following two streams:\n        #       live/stream1 live/stream2\n        # default: all\n        dvr_apply       all;\n        # the dvr plan. canbe:\n        #       session reap flv/mp4 when session end(unpublish).\n        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.\n        # @remark The plan append is removed in SRS3+, for it's no use.\n        # default: session\n        dvr_plan        session;\n        # the dvr output path, *.flv or *.mp4.\n        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        # the duration for dvr file, reap if exceed, in seconds.\n        dvr_duration    30;\n        dvr_wait_keyframe       on;\n        time_jitter             full;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server in SRS\nDESCRIPTION: SRS configuration for SRT server including various parameters like latency, buffer sizes, and security options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/srt.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    maxbw 1000000000;\n    mss 1500;\n    connect_timeout 4000;\n    peer_idle_timeout 8000;\n    default_app live;\n    peerlatency 0;\n    recvlatency 0;\n    latency 0;\n    tsbpdmode off;\n    tlpktdrop off;\n    sendbuf 2000000;\n    recvbuf 2000000;\n    passphrase xxxxxxxxxxxx;\n    pbkeylen 16;\n}\nvhost __defaultVhost__ {\n    srt {\n        enabled on;\n        srt_to_rtmp on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying SRS Edge with Graceful Shutdown on Kubernetes (YAML/Bash)\nDESCRIPTION: This snippet uses a bash heredoc to define and apply a Kubernetes Deployment named 'srs-edge-deploy'. It specifies 2 replicas, labels, volume mounting the 'srs-edge-config' ConfigMap, defines the container image (`ossrs/srs:v4.0.5`), ports, and crucially, sets up lifecycle hooks. The `preStop` hook executes '/usr/local/srs/etc/init.d/srs grace' to initiate SRS's graceful shutdown sequence. `terminationGracePeriodSeconds` is set to 120 seconds to allow sufficient time for connections to drain before the pod is forcefully terminated. The `--record` flag is added to `kubectl apply` to store the command in the deployment history for potential rollbacks. The Chinese remarks highlight setting replicas to 2 for demonstration and compatibility with SRS v3/v4.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply --record -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:v4.0.5\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"/usr/local/srs/etc/init.d/srs\", \"grace\"]\n      terminationGracePeriodSeconds: 120\nEOF\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Deployment for SRS and Nginx with Shared Volume (YAML)\nDESCRIPTION: This Kubernetes manifest defines a Deployment resource named 'srs-deploy'. It creates Pods containing three containers: 'srs' for media streaming, 'nginx' for serving HLS via HTTP, and 'srs-cp-files' to initialize the shared volume. An 'emptyDir' volume named 'cache-volume' is mounted by all containers, allowing SRS to write HLS segments to '/usr/local/srs/objs/nginx/html' and Nginx to read them from '/usr/share/nginx/html'. The 'srs-cp-files' container copies initial web content into the shared volume upon startup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deploy\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\nEOF\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream with FFmpeg in Docker\nDESCRIPTION: Docker command to run FFmpeg to publish a looping RTMP stream to SRS, which can be converted to WebRTC for browser playback.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS Media Server with Docker\nDESCRIPTION: Command to run the SRS media server using Docker, exposing the necessary ports (1935 for RTMP and 8080 for HTTP) and using the default configuration file. SRS 6 supports HEVC via RTMP, FLV, TS, HLS, SRT, WebRTC, and more.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:6 \\\n  ./objs/srs -c conf/docker.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR in SRS (Bash)\nDESCRIPTION: Comprehensive configuration example for DVR in SRS, including options for enabling DVR, setting the DVR plan, custom path patterns, duration settings, and time jitter handling. The configuration demonstrates how to setup DVR for a specific virtual host.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost yourvhost {\n    # DVR RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv/mp4 according by specified dvr_plan.\n    dvr {\n        # whether enabled dvr features\n        # default: off\n        enabled         on;\n        # the filter for dvr to apply to.\n        #       all, dvr all streams of all apps.\n        #       <app>/<stream>, apply to specified stream of app.\n        # for example, to dvr the following two streams:\n        #       live/stream1 live/stream2\n        # default: all\n        dvr_apply       all;\n        # the dvr plan. canbe:\n        #       session reap flv/mp4 when session end(unpublish).\n        #       segment reap flv/mp4 when flv duration exceed the specified dvr_duration.\n        # @remark The plan append is removed in SRS3+, for it's no use.\n        # default: session\n        dvr_plan        session;\n        # the dvr output path, *.flv or *.mp4.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        # @remark we use golang time format \"2006-01-02 15:04:05.999\" as \"[2006]-[01]-[02]_[15].[04].[05]_[999]\"\n        # for example, for url rtmp://ossrs.net/live/livestream and time 2015-01-03 10:57:30.776\n        # 1. No variables, the rule of SRS1.0(auto add [stream].[timestamp].flv as filename):\n        #       dvr_path ./objs/nginx/html;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.flv;\n        # 2. Use stream and date as dir name, time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03/10.57.30.776.flv;\n        # 3. Use stream and year/month as dir name, date and time as filename:\n        #       dvr_path /data/[vhost]/[app]/[stream]/[2006]/[01]/[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/livestream/2015/01/03-10.57.30.776.flv;\n        # 4. Use vhost/app and year/month as dir name, stream/date/time as filename:\n        #       dvr_path /data/[vhost]/[app]/[2006]/[01]/[stream]-[02]-[15].[04].[05].[999].flv;\n        #       =>\n        #       dvr_path /data/ossrs.net/live/2015/01/livestream-03-10.57.30.776.flv;\n        # 5. DVR to mp4:\n        #       dvr_path ./objs/nginx/html/[app]/[stream].[timestamp].mp4;\n        #       =>\n        #       dvr_path ./objs/nginx/html/live/livestream.1420254068776.mp4;\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#custom-path\n        #       segment,session apply it.\n        # default: ./objs/nginx/html/[app]/[stream].[timestamp].flv\n        dvr_path        ./objs/nginx/html/[app]/[stream].[timestamp].flv;\n        # the duration for dvr file, reap if exceed, in seconds.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: 30\n        dvr_duration    30;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the dvr_duration,\n        # if on, reap segment when duration exceed and got keyframe.\n        #       segment apply it.\n        #       session,append ignore.\n        # default: on\n        dvr_wait_keyframe       on;\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # apply for all dvr plan.\n        # default: full\n        time_jitter             full;\n\n        # on_dvr, never config in here, should config in http_hooks.\n        # for the dvr http callback, @see http_hooks.on_dvr of vhost hooks.callback.srs.com\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#http-callback\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#http-callback\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating LoadBalancer Service for SRS\nDESCRIPTION: YAML configuration to create a Kubernetes LoadBalancer service that exposes SRS streaming ports through a cloud load balancer.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Cluster - Bash Configuration\nDESCRIPTION: This snippet shows how to configure an SRS vhost for edge clustering via the bash-format configuration file. It sets up the cluster mode to remote for edge servers, specifies multiple origins for error backup, adjusts authentication methods, and defines advanced options such as vhost remapping and debug settings. Required dependency is the SRS media server (https://ossrs.io), and the configuration should be placed in the SRS config file (e.g., srs.conf). Key parameters include 'mode' (local/remote), 'origin' (list of origin servers), and optional toggles for authentication and logging. The configuration enables edge servers to efficiently fetch or push streams and provides reliability enhancements for CDN architectures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/edge.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            remote;\n\n        # For edge(mode remote), user must specifies the origin server\n        # format as: <server_name|ip>[:port]\n        # @remark user can specifies multiple origin for error backup, by space,\n        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935\n        origin          127.0.0.1:1935 localhost:1935;\n\n        # For edge(mode remote), whether open the token traverse mode,\n        # if token traverse on, all connections of edge will forward to origin to check(auth),\n        # it's very important for the edge to do the token auth.\n        # the better way is use http callback to do the token auth by the edge,\n        # but if user prefer origin check(auth), the token_traverse if better solution.\n        # default: off\n        token_traverse  off;\n\n        # For edge(mode remote), the vhost to transform for edge,\n        # to fetch from the specified vhost at origin,\n        # if not specified, use the current vhost of edge in origin, the variable [vhost].\n        # default: [vhost]\n        vhost           same.edge.srs.com;\n\n        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,\n        # it's strongly recommend to open the debug_srs_upnode,\n        # when connect to upnode, it will take the debug info,\n        # for example, the id, source id, pid.\n        # please see https://ossrs.io/lts/en-us/docs/v4/doc/log\n        # default: on\n        debug_srs_upnode    on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Entering SRS Project Directory - Bash\nDESCRIPTION: This snippet demonstrates how to clone the SRS repository from GitHub and change into the project directory. It requires Git to be installed on the system. The command downloads the full SRS source for further compilation and deployment steps, providing the foundation for the subsequent streaming server setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-dash.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Configuring Referer Anti-suck in SRS (Bash)\nDESCRIPTION: This configuration snippet demonstrates how to enable and configure Referer Anti-suck within an SRS vhost. It restricts access based on the 'PageUrl' parameter sent by Flash players, preventing unauthorized embedding. The configuration allows specifying allowed referer domains globally, or separately for publish and play actions. This method is less effective for non-Flash clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/drm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the vhost for anti-suck.\nvhost refer.anti_suck.com {\n    # refer hotlink-denial.\n    refer {\n        # whether enable the refer hotlink-denial.\n        # default: off.\n        enabled         on;\n        # the common refer for play and publish.\n        # if the page url of client not in the refer, access denied.\n        # if not specified this field, allow all.\n        # default: not specified.\n        all           github.com github.io;\n        # refer for publish clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        publish   github.com github.io;\n        # refer for play clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        play      github.com github.io;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS directly with configuration\nDESCRIPTION: Alternative way to start SRS by directly executing the binary with a specified configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: WebRTC Play Request Example using WHEP Protocol\nDESCRIPTION: This shows the HTTP POST request format for WebRTC playback using the WHEP protocol, including the SDP body that should be sent with Content-type application/sdp.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whep/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream via OBS - OBS/General\nDESCRIPTION: This snippet provides configuration parameters for publishing a stream to SRS via OBS Studio. It specifies the RTMP server URL and stream key required in OBS for output. No code is included, but these parameters must be placed in the OBS output settings for streaming. Successful use depends on OBS being installed and the SRS origin server running.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: conf\nCODE:\n```\nServer: rtmp://192.168.1.170/live\\nStreamKey: livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Vhost Specific HTTP Static File Serving in SRS (SRS Config)\nDESCRIPTION: This configuration snippet demonstrates how to configure HTTP static file serving for a specific virtual host (vhost) within the SRS srs.conf file. The `http_static` block enables (`enabled on`) static file delivery for the vhost. `mount` defines the URL path relative to the vhost (e.g., `[vhost]/hls` maps to `http://<domain>:8080/hls/`). `dir` specifies the local directory containing the static files for this vhost. This allows different vhosts to serve static content from different locations and paths.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-server.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # http static vhost specified config\n    http_static {\n        # whether enabled the http static service for vhost.\n        # default: off\n        enabled     on;\n        # the url to mount to, \n        # typical mount to [vhost]/\n        # the variables:\n        #       [vhost] current vhost for http server.\n        # @remark the [vhost] is optional, used to mount at specified vhost.\n        # @remark the http of __defaultVhost__ will override the http_stream section.\n        # for example:\n        #       mount to [vhost]/\n        #           access by http://ossrs.net:8080/xxx.html\n        #       mount to [vhost]/hls\n        #           access by http://ossrs.net:8080/hls/xxx.html\n        #       mount to /\n        #           access by http://ossrs.net:8080/xxx.html\n        #           or by http://192.168.1.173:8080/xxx.html\n        #       mount to /hls\n        #           access by http://ossrs.net:8080/hls/xxx.html\n        #           or by http://192.168.1.173:8080/hls/xxx.html\n        # default: [vhost]/\n        mount       [vhost]/hls;\n        # main dir of vhost,\n        # to delivery HTTP stream of this vhost.\n        # default: ./objs/nginx/html\n        dir         ./objs/nginx/html/hls;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server for Low Latency Mode\nDESCRIPTION: Server configuration for low latency SRT streaming with a 100ms RTT. Enables packet dropping and timestamp-based playback delay mode for optimal performance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    connect_timeout 4000;\n    peerlatency 300; # RTT * 3\n    recvlatency 300; # RTT * 3\n    latency 300; # RTT * 3\n    tlpktdrop on;\n    tsbpdmode on;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Server in SRS\nDESCRIPTION: This snippet shows how to configure an edge server in SRS. It includes settings for cluster mode, origin server addresses, token traversal, and debug options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/edge.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            remote;\n\n        # For edge(mode remote), user must specifies the origin server\n        # format as: <server_name|ip>[:port]\n        # @remark user can specifies multiple origin for error backup, by space,\n        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935\n        origin          127.0.0.1:1935 localhost:1935;\n\n        # For edge(mode remote), whether open the token traverse mode,\n        # if token traverse on, all connections of edge will forward to origin to check(auth),\n        # it's very important for the edge to do the token auth.\n        # the better way is use http callback to do the token auth by the edge,\n        # but if user prefer origin check(auth), the token_traverse if better solution.\n        # default: off\n        token_traverse  off;\n\n        # For edge(mode remote), the vhost to transform for edge,\n        # to fetch from the specified vhost at origin,\n        # if not specified, use the current vhost of edge in origin, the variable [vhost].\n        # default: [vhost]\n        vhost           same.edge.srs.com;\n\n        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,\n        # it's strongly recommend to open the debug_srs_upnode,\n        # when connect to upnode, it will take the debug info,\n        # for example, the id, source id, pid.\n        # please see https://ossrs.io/lts/en-us/docs/v4/doc/log\n        # default: on\n        debug_srs_upnode    on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Vhost Settings in SRS\nDESCRIPTION: Defines the HLS (HTTP Live Streaming) configuration within an SRS virtual host (`vhost`). Includes parameters for enabling HLS (`enabled`), segment duration (`hls_fragment`), playlist window (`hls_window`), file paths (`hls_path`, `hls_m3u8_file`, `hls_ts_file`), error handling (`hls_on_error`), AES encryption (`hls_keys`), codec defaults (`hls_acodec`, `hls_vcodec`), and various other HLS-specific settings. Variables like `[app]` and `[stream]` are used for dynamic path generation. This configuration controls how SRS converts incoming streams into HLS format for delivery.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether the hls is enabled.\n        # if off, do not write hls(ts and m3u8) when publish.\n        # default: off\n        enabled         on;\n        # the hls fragment in seconds, the duration of a piece of ts.\n        # default: 10\n        hls_fragment    10;\n        # the hls m3u8 target duration ratio,\n        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init\n        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts\n        # default: 1.5\n        hls_td_ratio    1.5;\n        # the audio overflow ratio.\n        # for pure audio, the duration to reap the segment.\n        # for example, the hls_fragment is 10s, hls_aof_ratio is 2.0,\n        # the segment will reap to 20s for pure audio.\n        # default: 2.0\n        hls_aof_ratio   2.0;\n        # the hls window in seconds, the number of ts in m3u8.\n        # default: 60\n        hls_window      60;\n        # the error strategy. can be:\n        #       ignore, disable the hls.\n        #       disconnect, require encoder republish.\n        #       continue, ignore failed try to continue output hls.\n        # @see https://github.com/ossrs/srs/issues/264\n        # default: continue\n        hls_on_error    continue;\n        # the hls output path.\n        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream].m3u8\n        # the ts file is configured by hls_path/hls_ts_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream]-[seq].ts\n        # @remark the hls_path is compatible with srs v1 config.\n        # default: ./objs/nginx/html\n        hls_path        ./objs/nginx/html;\n        # the hls m3u8 file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        # default: [app]/[stream].m3u8\n        hls_m3u8_file   [app]/[stream].m3u8;\n        # the hls ts file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        #       [seq], the sequence number of ts.\n        #       [duration], replace this const to current ts duration.\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/delivery-hls#hls-config\n        # default: [app]/[stream]-[seq].ts\n        hls_ts_file     [app]/[stream]-[seq].ts;\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enhanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # default: off\n        hls_ts_floor    off;\n        # the hls entry prefix, which is base url of ts url.\n        # for example, the prefix is:\n        #         http://your-server/\n        # then, the ts path in m3u8 will be like:\n        #         http://your-server/live/livestream-0.ts\n        #         http://your-server/live/livestream-1.ts\n        #         ...\n        # optional, default to empty string.\n        hls_entry_prefix http://your-server;\n        # the default audio codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for mp3.\n        # the available audio codec:\n        #       aac, mp3, an\n        # default: aac\n        hls_acodec      aac;\n        # the default video codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for pure audio(without video) to vn.\n        # the available video codec:\n        #       h264, vn\n        # default: h264\n        hls_vcodec      h264;\n        # whether cleanup the old expired ts files.\n        # default: on\n        hls_cleanup     on;\n        # If there is no incoming packets, dispose HLS in this timeout in seconds,\n        # which removes all HLS files including m3u8 and ts files.\n        # @remark 0 to disable dispose for publisher.\n        # @remark apply for publisher timeout only, while \"etc/init.d/srs stop\" always dispose hls.\n        # default: 0\n        hls_dispose     0;\n        # the max size to notify hls,\n        # to read max bytes from ts of specified cdn network,\n        # @remark only used when on_hls_notify is config.\n        # default: 64\n        hls_nb_notify   64;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # default: on\n        hls_wait_keyframe       on;\n\n        # whether using AES encryption.\n        # default: off\n        hls_keys        on; \n        # the number of clear ts which one key can encrypt.\n        # default: 5\n        hls_fragments_per_key 5;\n        # the hls key file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [seq], the sequence number of key corresponding to the ts.\n        hls_key_file     [app]/[stream]-[seq].key;\n        # the key output path.\n        # the key file is configed by hls_path/hls_key_file, the default is:\n        # ./objs/nginx/html/[app]/[stream]-[seq].key\n        hls_key_file_path    ./objs/nginx/html;\n        # the key root URL, use this can support https.\n        # @remark It's optional.\n        hls_key_url       https://localhost:8080;\n\n        # Special control controls.\n        ###########################################\n        # Whether calculate the DTS of audio frame directly.\n        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544\n        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.\n        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.\n        # Default: on\n        hls_dts_directly on;\n\n        # on_hls, never config in here, should config in http_hooks.\n        # for the hls http callback, @see http_hooks.on_hls of vhost hooks.callback.srs.com\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/delivery-hls#http-callback\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/delivery-hls#http-callback\n\n        # on_hls_notify, never config in here, should config in http_hooks.\n        # we support the variables to generate the notify url:\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [param], replace with the param.\n        #       [ts_url], replace with the ts url.\n        # for the hls http callback, @see http_hooks.on_hls_notify of vhost hooks.callback.srs.com\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/delivery-hls#on-hls-notify\n        # @see https://ossrs.io/lts/en-us/docs/v4/doc/delivery-hls#on-hls-notify\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Callbacks in SRS Configuration File\nDESCRIPTION: This code snippet shows how to configure HTTP callbacks in the SRS configuration file. It includes settings for various events like publish, unpublish, play, and stop.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        enabled         on;\n        on_publish      http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        on_unpublish    http://127.0.0.1:8085/api/v1/streams http://localhost:8085/api/v1/streams;\n        on_play         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        on_stop         http://127.0.0.1:8085/api/v1/sessions http://localhost:8085/api/v1/sessions;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs http://localhost:8085/api/v1/dvrs;\n        on_hls          http://127.0.0.1:8085/api/v1/hls http://localhost:8085/api/v1/hls;\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[server_id]/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Transcoding Stream for HLS in SRS with FFmpeg Bash-Style Configuration\nDESCRIPTION: This configuration snippet demonstrates setting up SRS to use FFmpeg for transcoding RTMP streams to the h.264/aac codecs required by HLS, specifying video and audio parameters for output compatibility. Prerequisites include FFmpeg installed at the defined path, SRS service running, and appropriate directory structures. Key parameters control the output resolution, bitrate, fps (vfps=20), GOP size (g=100), and audio codec, ensuring the target stream fits HLS requirements. Inputs are raw RTMP streams; outputs are HLS-compliant streams for segmented playback. Constraints may include processing overhead and the need for matching the ffmpeg binary location.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nvhost hls.transcode.vhost.com {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine hls {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            20;\n            vwidth          768;\n            vheight         320;\n            vthreads        2;\n            vprofile        baseline;\n            vpreset         superfast;\n            vparams {\n                g           100;\n            }\n            acodec          libaacplus;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with HTTPS for WebRTC\nDESCRIPTION: Start SRS with HTTPS support for WebRTC, necessary for non-local usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/https.rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS via FMLE - Bash/Reference\nDESCRIPTION: This reference snippet provides configuration values for using Adobe FMLE to publish streams to the SRS origin server. Values include the RTMP URL (FMS URL) and the stream name. There are no commands to execute; use these parameters in FMLE's configuration GUI. The output is a live stream if FMLE succeeds in publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic RTMP Distribution in SRS\nDESCRIPTION: This SRS configuration snippet sets up basic RTMP stream distribution. It specifies the listening port (1935), the maximum number of concurrent connections (1000), and defines a default virtual host (__defaultVhost__) necessary for handling RTMP connections and streams. This configuration is typically saved in an SRS .conf file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/delivery-rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing with WebRTC using SRS RTC HTTP API - JSON POST Example\nDESCRIPTION: This request and response pair demonstrates publishing a WebRTC stream to the SRS server using the /rtc/v1/publish/ HTTP POST endpoint. The client sends a JSON body with api, streamurl, and the local SDP. The server responds with a JSON object containing a code (0 for success), a negotiated SDP, and a sessionid. Requires HTTP/HTTPS API enabled and WebRTC integration configured. Inputs/outputs must conform to specified JSON structure.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n```\\nPOST /rtc/v1/publish/\\n\\nBody in JSON:\\n\\n{\\n  \"api\": \"https://d.ossrs.net/rtc/v1/publish/\"\\n  \"streamurl\": \"webrtc://d.ossrs.net/live/3abd9f34\",\\n  \"sdp\": \"v=0\\r\\n......\\r\\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\\r\\n\"\\n}\\n```\n```\n\nLANGUAGE: json\nCODE:\n```\n```\\n{\\n  \"code\": 0\\n  \"sdp\": \"v=0\\r\\n......\\r\\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\\r\\n\"\\n  \"sessionid\": \"186tj710:hMub\"\\n}\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Origin Server in SRS\nDESCRIPTION: Example configuration for setting up an origin server in SRS with basic settings including listen port, PID file, and log file location.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/edge.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              19350;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Server in SRS\nDESCRIPTION: Basic configuration for the embedded HTTP server in SRS, including port settings and root directory configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-server.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Coroutine-Native TCP Logic with ST\nDESCRIPTION: Example of coroutine-native TCP code using ST library. This shows how the same functionality can be expressed with simpler code by hiding the complexity of asynchronous I/O behind coroutine abstractions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nst_netfd_t fd = st_accept(listen_fd); // Got a TCP connection\n\nint n = st_read(fd, buf, sizeof(buf));\nif (n == -1) {\n    return n; // Error.\n}\n\nprintf(\"Got %d size of data %p\", n, buf);\n```\n\n----------------------------------------\n\nTITLE: SRS Transcoding Configuration\nDESCRIPTION: Configuration file for SRS with FFMPEG transcoding settings, including video and audio encoding parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ffmpeg.transcode.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Runner365's HEVC/RTMP Patch to FFmpeg Source - Bash\nDESCRIPTION: This block applies several patch files from Runner365's repository to FFmpeg, enabling HEVC over RTMP/FLV in legacy FFmpeg. Assumes the runner365 and FFmpeg repositories have been cloned and exist in expected locations. Copies source and header files into the FFmpeg source tree for building patched binaries. Input: none; Output: updated sources in FFmpeg tree; Note: Must build FFmpeg after applying these patches.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 5.1 https://github.com/runner365/ffmpeg_rtmp_h265.git ~/git/ffmpeg_rtmp_h265\ncp ~/git/ffmpeg_rtmp_h265/flv.h ~/git/FFmpeg/libavformat/\ncp ~/git/ffmpeg_rtmp_h265/flv*.c ~/git/FFmpeg/libavformat/\n```\n\n----------------------------------------\n\nTITLE: M3U8 TS Window Requirement Assertion - Bash\nDESCRIPTION: This pseudo-bash code documents the SRS internal assertion that the HLS window parameter (hls_window) must always be equal to or greater than the sum of the TS durations included in the m3u8 playlist. Helps administrators validate configuration and ensure expected file rotation behavior for m3u8 playlists. No external dependencies or inputs; serves as conceptual documentation rather than executable code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nhls_window >= sum(duration of each ts in m3u8)\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for FFMPEG Transcoding - Bash Configuration\nDESCRIPTION: This configuration snippet demonstrates setting up an SRS vhost to enable FFMPEG-based transcoding, specifying various transcoder parameters. It covers how to enable the transcoder, define the FFMPEG binary, set video and audio encoding settings, configure filters, manage threading, and template the output stream URL. Dependencies include having SRS and an FFMPEG binary present; key parameters include enabled flags, codec selections, bitrates, and output/template variables. The input is an SRS configuration file and outputs are transcoded streams published to RTMP targets according to specified settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # the streaming transcode configs.\n    transcode {\n        # whether the transcode enabled.\n        # if off, donot transcode.\n        # default: off.\n        enabled     on;\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine for matched stream.\n        # all matched stream will transcoded to the following stream.\n        # the transcode set name(ie. hd) is optional and not used.\n        engine example {\n            # whether the engine is enabled\n            # default: off.\n            enabled         on;\n            # input format, can be:\n            # off, do not specifies the format, ffmpeg will guess it.\n            # flv, for flv or RTMP stream.\n            # other format, for example, mp4/aac whatever.\n            # default: flv\n            iformat         flv;\n            # ffmpeg filters, follows the main input.\n            vfilter {\n                # the logo input file.\n                i               ./doc/ffmpeg-logo.png;\n                # the ffmpeg complex filter.\n                # for filters, @see: http://ffmpeg.org/ffmpeg-filters.html\n                filter_complex  'overlay=10:10';\n            }\n            # video encoder name. can be:\n            #       libx264: use h.264(libx264) video encoder.\n            #       png: use png to snapshot thumbnail.\n            #       copy: donot encoder the video stream, copy it.\n            #       vn: disable video output.\n            vcodec          libx264;\n            # video bitrate, in kbps\n            # @remark 0 to use source video bitrate.\n            # default: 0\n            vbitrate        1500;\n            # video framerate.\n            # @remark 0 to use source video fps.\n            # default: 0\n            vfps            25;\n            # video width, must be even numbers.\n            # @remark 0 to use source video width.\n            # default: 0\n            vwidth          768;\n            # video height, must be even numbers.\n            # @remark 0 to use source video height.\n            # default: 0\n            vheight         320;\n            # the max threads for ffmpeg to used.\n            # default: 1\n            vthreads        12;\n            # x264 profile, @see x264 -help, can be:\n            # high,main,baseline\n            vprofile        main;\n            # x264 preset, @see x264 -help, can be: \n            #       ultrafast,superfast,veryfast,faster,fast\n            #       medium,slow,slower,veryslow,placebo\n            vpreset         medium;\n            # other x264 or ffmpeg video params\n            vparams {\n                # ffmpeg options, @see: http://ffmpeg.org/ffmpeg.html\n                t               100;\n                # 264 params, @see: http://ffmpeg.org/ffmpeg-codecs.html#libx264\n                coder           1;\n                b_strategy      2;\n                bf              3;\n                refs            10;\n            }\n            # audio encoder name. can be:\n            #       libfdk_aac: use aac(libfdk_aac) audio encoder.\n            #       copy: donot encoder the audio stream, copy it.\n            #       an: disable audio output.\n            acodec          libfdk_aac;\n            # audio bitrate, in kbps. [16, 72] for libfdk_aac.\n            # @remark 0 to use source audio bitrate.\n            # default: 0\n            abitrate        70;\n            # audio sample rate. for flv/rtmp, it must be:\n            #       44100,22050,11025,5512\n            # @remark 0 to use source audio sample rate.\n            # default: 0\n            asample_rate    44100;\n            # audio channel, 1 for mono, 2 for stereo.\n            # @remark 0 to use source audio channels.\n            # default: 0\n            achannels       2;\n            # other ffmpeg audio params\n            aparams {\n                # audio params, @see: http://ffmpeg.org/ffmpeg-codecs.html#Audio-Encoders\n                # @remark SRS supported aac profile for HLS is: aac_low, aac_he, aac_he_v2\n                profile:a   aac_low;\n                bsf:a       aac_adtstoasc;\n            }\n            # output format, can be:\n            #       off, do not specifies the format, ffmpeg will guess it.\n            #       flv, for flv or RTMP stream.\n            #       image2, for vcodec png to snapshot thumbnail.\n            #       other format, for example, mp4/aac whatever.\n            # default: flv\n            oformat         flv;\n            # output stream. variables:\n            #       [vhost] the input stream vhost.\n            #       [port] the intput stream port.\n            #       [app] the input stream app.\n            #       [stream] the input stream name.\n            #       [engine] the tanscode engine name.\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling and Running GPERF Memory Profiler (gmp) with SRS in Bash\nDESCRIPTION: Details the shell commands to configure SRS for gmp (`--with-gperf --with-gmp`), build it (`make`), run SRS to collect heap profile data (`rm -f gperf.srs.gmp*; ./objs/srs ...`), stop SRS (`CTRL+C` or `SIGINT`) to finalize the data file (`gperf.srs.gmp*`), and analyze the results using `pprof` (`./objs/pprof --text ...`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Configure SRS with gmp enabled\n./configure --with-gperf --with-gmp\n\n# Compile SRS\nmake\n\n# Run SRS to collect heap profile data (remove old files first)\nrm -f gperf.srs.gmp*\n./objs/srs -c conf/console.conf\n\n# Stop SRS to write the profile data\nCTRL+C\n\n# Analyze the generated heap profile files\n./objs/pprof --text objs/srs gperf.srs.gmp*\n```\n\n----------------------------------------\n\nTITLE: Live Source Manager Implementation\nDESCRIPTION: Implementation of live source management showing timer-based source cleanup and relationship with various components.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nclass SrsLiveSourceManager : public ISrsHourGlass\n{\npublic:\n    virtual srs_error_t fetch_or_create(SrsRequest* r, ISrsLiveSourceHandler* h, SrsSharedPtr<SrsLiveSource>& pps);\n    virtual SrsSharedPtr<SrsLiveSource> fetch(SrsRequest* r);\n};\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to SRS using ffmpeg in Bash\nDESCRIPTION: Uses ffmpeg to read a local FLV file ('doc/source.flv') and publish it as an RTMP stream to the SRS server running on the local machine ('rtmp://127.0.0.1/live/livestream'). The '-re' flag simulates a real-time stream, and '-c copy' avoids transcoding. This command is used to simulate load or test streaming functionality during Valgrind leak detection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS HTTP Hooks for HTTPS Callbacks\nDESCRIPTION: This SRS configuration snippet demonstrates how to enable HTTP hooks (`http_hooks`) within a specific virtual host (`vhost your_vhost`) and configure them to use secure HTTPS URLs for callbacks. It lists various events (`on_publish`, `on_unpublish`, `on_play`, `on_stop`, `on_dvr`, `on_hls`, `on_hls_notify`) and assigns a corresponding `https://` URL (pointing to `127.0.0.1:8085` in this example) for each. This setup enables secure communication between SRS and the callback server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_hooks {\n        enabled         on;\n        on_publish      https://127.0.0.1:8085/api/v1/streams;\n        on_unpublish    https://127.0.0.1:8085/api/v1/streams;\n        on_play         https://127.0.0.1:8085/api/v1/sessions;\n        on_stop         https://127.0.0.1:8085/api/v1/sessions;\n        on_dvr          https://127.0.0.1:8085/api/v1/dvrs;\n        on_hls          https://127.0.0.1:8085/api/v1/hls;\n        on_hls_notify   https://127.0.0.1:8085/api/v1/hls/[app]/[stream]/[ts_url][param];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with WebRTC Candidate IP\nDESCRIPTION: Docker command to run SRS with the WebRTC candidate IP set via an environment variable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.3.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP API in SRS\nDESCRIPTION: Configuration example for enabling HTTP API in SRS, including statistics collection, authentication, HTTPS support, and various API features like raw API and cross-domain access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\n# system statistics section.\n# the main cycle will retrieve the system stat,\n# for example, the cpu/mem/network/disk-io data,\n# the http api, for instance, /api/v1/summaries will show these data.\n# @remark the heartbeat depends on the network,\n#       for example, the eth0 maybe the device which index is 0.\nstats {\n    # the index of device ip.\n    # we may retrieve more than one network device.\n    # default: 0\n    network         0;\n    # the device name to stat the disk iops.\n    # ignore the device of /proc/diskstats if not configed.\n    disk            sda sdb xvda xvdb;\n}\n# api of srs.\n# the http api config, export for external program to manage srs.\n# user can access http api of srs in browser directly, for instance, to access by:\n#       curl http://192.168.1.170:1985/api/v1/reload\n# which will reload srs, like cmd killall -1 srs, but the js can also invoke the http api,\n# where the cli can only be used in shell/terminate.\nhttp_api {\n    # whether http api is enabled.\n    # default: off\n    enabled         on;\n    # the http api listen entry is <[ip:]port>\n    # for example, 192.168.1.100:1985\n    # where the ip is optional, default to 0.0.0.0, that is 1985 equals to 0.0.0.0:1985\n    # default: 1985\n    listen          1985;\n    # whether enable crossdomain request.\n    # default: on\n    crossdomain     on;\n    # the HTTP RAW API is more powerful api to change srs state and reload.\n    raw_api {\n        # whether enable the HTTP RAW API.\n        # Overwrite by env SRS_HTTP_API_RAW_API_ENABLED\n        # default: off\n        enabled off;\n        # whether enable rpc reload.\n        # Overwrite by env SRS_HTTP_API_RAW_API_ALLOW_RELOAD\n        # default: off\n        allow_reload off;\n        # whether enable rpc query.\n        # Always off by https://github.com/ossrs/srs/issues/2653\n        #allow_query off;\n        # whether enable rpc update.\n        # Always off by https://github.com/ossrs/srs/issues/2653\n        #allow_update off;\n    }\n    # the auth is authentication for http api\n    auth {\n        # whether enable the HTTP AUTH.\n        # Overwrite by env SRS_HTTP_API_AUTH_ENABLED\n        # default: off\n        enabled         on;\n        # The username of Basic authentication:\n        # Overwrite by env SRS_HTTP_API_AUTH_USERNAME\n        username        admin;\n        # The password of Basic authentication:\n        # Overwrite by env SRS_HTTP_API_AUTH_PASSWORD\n        password        admin;\n    }\n    # For https_api or HTTPS API.\n    https {\n        # Whether enable HTTPS API.\n        # default: off\n        enabled on;\n        # The listen endpoint for HTTPS API.\n        # default: 1986\n        listen 1986;\n        # The SSL private key file, generated by:\n        #       openssl genrsa -out server.key 2048\n        # default: ./conf/server.key\n        key ./conf/server.key;\n        # The SSL public cert file, generated by:\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\n        # default: ./conf/server.crt\n        cert ./conf/server.crt;\n    }\n}\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin ServerB - Bash/SRS Config\nDESCRIPTION: This snippet is an SRS server configuration for a secondary origin server, ServerB. It specifies unique ports, PID file, enables HTTP API, and sets up clustering with coworkers. The config enables origin clustering in a local mode and defines community with ServerA (9090). It should be used as the configuration file when launching ServerB. Requires SRS built binaries.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverB.conf\\nlisten              19351;\\nmax_connections     1000;\\ndaemon              off;\\nsrs_log_tank        console;\\npid                 ./objs/origin.cluster.serverB.pid;\\nhttp_api {\\n    enabled         on;\\n    listen          9091;\\n}\\nvhost __defaultVhost__ {\\n    cluster {\\n        mode            local;\\n        origin_cluster  on;\\n        coworkers       127.0.0.1:9090;\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing SRS Origin Cluster Architecture\nDESCRIPTION: Diagram showing the architecture of SRS Origin Cluster with proxy server distributing load to multiple origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n                                       +--------------------+\n                               +-------+ SRS Origin Server  +\n                               +       +--------------------+\n                               +\n+-----------------------+      +       +--------------------+\n+ SRS Proxy(Deployment) +------+-------+ SRS Origin Server  +\n+-----------------------+      +       +--------------------+\n                               +\n                               +       +--------------------+\n                               +-------+ SRS Origin Server  +\n                                       +--------------------+\n```\n\n----------------------------------------\n\nTITLE: Setting up HTTPS Proxy with httpx-static\nDESCRIPTION: Configuration for HTTPS proxy using httpx-static as API gateway. Sets up HTTP/HTTPS ports and proxies for signaling, WebRTC, and HTTP services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm -p 80:80 -p 443:443 ossrs/httpx:1 \\\n    ./bin/httpx-static -http 80 -https 443 -ssk ./etc/server.key -ssc ./etc/server.crt \\\n          -proxy http://$CANDIDATE:1989/sig -proxy http://$CANDIDATE:1985/rtc \\\n          -proxy http://$CANDIDATE:8080/\n```\n\n----------------------------------------\n\nTITLE: Defining SRS Origin Server - Bash Minimal Configuration\nDESCRIPTION: This snippet provides a minimal configuration file for setting up an SRS origin server. The configuration listens on custom port 19350, sets logging and PID file locations, and defines a default vhost. Intended to be used as the main hub for edge servers, this setup requires the SRS server and should be saved as 'origin.conf' or a similar file. Key parameters are 'listen', 'pid', and 'srs_log_file', with the default vhost block left open for further customization. Inputs are the connection ports and file paths, output is an operational SRS origin.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/edge.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              19350;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Low-Latency HLS in SRS using Bash-Style Configuration\nDESCRIPTION: This snippet provides a sample SRS configuration to enable HLS with reduced latency by adjusting key parameters such as 'hls_fragment' and 'hls_window'. Dependencies include an operational SRS installation with edit access to the configuration file ('conf/hls.realtime.conf'). Key parameters are 'hls_fragment' (segment length in seconds) and 'hls_window' (playlist duration); changing these lowers latency but may impact buffering. The input is the configuration file, and the output is lower-latency HLS delivery after SRS reloads the config.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_fragment 2;\n        hls_window 10;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Serving HLS Files Directly from NGINX Origin - NGINX\nDESCRIPTION: Configures NGINX to serve .m3u8 and .ts HLS files from a static root directory. Sets different Cache-Control headers for playlists and segments: 10s for .m3u8, 1 day for .ts files. Requires files present at /usr/local/srs/objs/nginx/html. Inputs: client HTTP requests. Outputs: static files with caching directives, improving CDN efficiency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_10\n\nLANGUAGE: nginx\nCODE:\n```\n  # For HLS delivery\\n  location ~ /.+/.*\\.(m3u8)$ {\\n    root /usr/local/srs/objs/nginx/html;\\n    add_header Cache-Control \"public, max-age=10\";\\n  }\\n  location ~ /.+/.*\\.(ts)$ {\\n    root /usr/local/srs/objs/nginx/html;\\n    add_header Cache-Control \"public, max-age=86400\";\\n  }\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for RTC to RTMP\nDESCRIPTION: Starts an SRS instance using Docker, configured for RTC-to-RTMP streaming by loading `conf/rtc2rtmp.conf`. It sets the `CANDIDATE` environment variable and maps the necessary ports. This configuration allows ingesting a WebRTC stream via WHIP and converting it for delivery via RTMP and HTTP-FLV.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Min-Latency Settings in SRS\nDESCRIPTION: Configuration for enabling minimum latency mode in SRS vhost, which disables merged-read and uses timeout condition wait for reduced latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    # whether enable min delay mode for vhost.\n    # for min latence mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off\n    min_latency     off;\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFmpeg in Bash\nDESCRIPTION: FFmpeg command to publish a sample video stream to the SRS server using RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Applying SRS Edge Configuration via Kubernetes ConfigMap using Bash\nDESCRIPTION: This Bash command uses a heredoc (`cat <<EOF ... EOF`) to define a Kubernetes ConfigMap named `srs-edge-config` containing SRS configuration (`srs.conf`) and applies it using `kubectl apply -f -`. The SRS configuration enables graceful shutdown (`grace_start_wait`, `grace_final_wait`, `force_grace_quit`), sets up listeners for RTMP (1935), HTTP API (1985), and HTTP server (8080), and configures the cluster mode to connect to origin servers defined by their service names (`srs-origin-0.socs`, etc.). The `force_grace_quit on` setting is crucial for enabling graceful shutdown with SIGTERM in K8s.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    grace_start_wait    700;\n    grace_final_wait    800;\n    force_grace_quit    on;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-0.socs srs-origin-1.socs srs-origin-2.socs;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\nEOF\n```\n\n----------------------------------------\n\nTITLE: Retrieving SRS Service External IP\nDESCRIPTION: Command to get the External IP (EIP) address of the SRS service for accessing the streaming endpoints.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get svc/srs-service\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Edge Configuration and Services in Kubernetes\nDESCRIPTION: This YAML configuration creates a ConfigMap for SRS Edge configuration, a Deployment for SRS Edge servers, and a LoadBalancer Service for external access. It sets up multiple Edge servers that connect to the Origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-service;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\n\n---\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-edge-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-edge\n  ports:\n  - name: srs-edge-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-edge-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\n```\n\n----------------------------------------\n\nTITLE: NGINX HLS Cache Configuration\nDESCRIPTION: NGINX configuration for implementing HLS proxy caching. Sets up cache paths and proxy rules for m3u8 and ts files with different cache durations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nhttp {\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       8081;\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx Proxy Cache for HLS in aaPanel\nDESCRIPTION: This configuration sets up Nginx as a caching proxy for HLS streaming with separate cache policies for m3u8 playlists and ts segments. It establishes a cache path, defines cache keys, and sets appropriate cache validation timeouts based on file types.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/nginx-for-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       80;\n        server_name your.domain.com;\n\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring NGINX Reverse Proxy for SRS HTTP-FLV\nDESCRIPTION: This NGINX configuration sets up a reverse proxy for HTTP-FLV streams from an SRS edge server. It forwards requests for .flv files to the local SRS instance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/nginx-for-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\n# For SRS streaming, for example:\n#   http://r.ossrs.net/live/livestream.flv\nlocation ~ /.+/.*\\.(flv)$ {\n   proxy_pass http://127.0.0.1:8080$request_uri;\n}\n```\n\n----------------------------------------\n\nTITLE: RTMP Handshake Protocol Structure\nDESCRIPTION: Defines the structure of RTMP handshake packets including c0/s0 (1 byte), c1/s1 (1536 bytes), and c2/s2 (1536 bytes) with their respective components and byte allocations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-handshake.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n* c0/s0: 1 bytes, specifies the protocol is RTMP or RTMPE/RTMPS.\n* c1/s1: 1536 bytes, first 4 bytes is time, next 4 bytes is 0x00, 1528 random bytes.\n* c2/s2: 1536 bytes, first 4 bytes is time echo, next 4 bytes is time, 1528 bytes c2==s1 and s2==c1.\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Deployment on Kubernetes using Bash and YAML\nDESCRIPTION: This snippet uses a bash heredoc (`cat <<EOF ... EOF`) to define a Kubernetes Deployment configuration in YAML format and pipes it directly to `kubectl apply -f -` for creation or update. The Deployment ensures a single replica (`replicas: 1`) of the SRS server (`ossrs/srs:3` image) is running, exposing ports 1935 (RTMP), 1985 (HTTP API), and 8080 (HTTP Server). Requires `kubectl` access to a K8s cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deployment\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring MPEGTS and FLV Stream Converters - SRS Config File - conf\nDESCRIPTION: This configuration snippet contains two stream_caster blocks: one for MPEGTS over UDP, one for FLV over HTTP POST. Each block enables stream conversion, specifies the stream protocol (via the \"caster\" key), output destination (RTMP), and listen port. Proper configuration lets SRS receive raw streams on arbitrary ports and map them to RTMP outputs. Prerequisites: SRS installed and running, UDP port open for MPEGTS, TCP port for FLV. Parameters include types (caster), output URLs, and listening ports. The configuration must be saved in an SRS configuration file and referenced on startup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/streamer.md#2025-04-23_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\n# Push MPEGTS over UDP to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       mpegts_over_udp, push MPEG-TS over UDP and convert to RTMP.\n    caster mpegts_over_udp;\n    # The output rtmp url.\n    # For mpegts_over_udp converter, the typically output url:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/live/livestream;\n    # The listen port for stream converter.\n    # For mpegts_over_udp converter, listen at udp port. for example, 8935.\n    listen 8935;\n}\n\n# Push FLV by HTTP POST to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       flv, push FLV by HTTP POST and convert to RTMP.\n    caster flv;\n    # The output rtmp url.\n    # For flv converter, the typically output url:\n    #           rtmp://127.0.0.1/[app]/[stream]\n    # For example, POST to url:\n    #           http://127.0.0.1:8936/live/livestream.flv\n    # Where the [app] is \"live\" and [stream] is \"livestream\", output is:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/[app]/[stream];\n    # The listen port for stream converter.\n    # For flv converter, listen at tcp port. for example, 8936.\n    listen 8936;\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP API Authentication Configuration\nDESCRIPTION: Configuration example for enabling HTTP API authentication with username and password in SRS version 5.0.152+ or 6.0.40+.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.api.auth.conf\nhttp_api {\n    enabled on;\n    listen 1985;\n    auth {\n        enabled on;\n        username admin;\n        password admin;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS with Context for Authentication\nDESCRIPTION: SRS configuration for enabling HLS with context tracking, allowing for authentication and user statistics through callbacks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_ctx on;\n        hls_ts_ctx on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP-AAC Streaming Output with SRS (conf)\nDESCRIPTION: This configuration enables HTTP streaming (on port 8080) and remuxes RTMP input to AAC-only audio over HTTP with fast_cache enabled for smoother delivery to clients. The output mount is [vhost]/[app]/[stream].aac. Dependencies: SRS, RTMP input with AAC audio. Key parameters: http_remux.fast_cache (30), http_remux.mount (.aac). Input: RTMP with AAC audio; Output: HTTP-AAC audio stream. Limitation: Drops video, requires AAC audio codec.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-http-flv.md#2025-04-23_snippet_4\n\nLANGUAGE: conf\nCODE:\n```\nhttp_server {\n    enabled         on;\n    listen          8080;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        fast_cache  30;\n        mount       [vhost]/[app]/[stream].aac;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Vhost Settings in SRS\nDESCRIPTION: Comprehensive RTMP vhost configuration including settings for minimum latency, TCP options, chunk sizes, acknowledgment sizes, publishing parameters, and playback options. The configuration controls stream behavior, caching, timeouts, and timestamp handling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    min_latency off;\n    tcp_nodelay off;\n    chunk_size 128;\n    in_ack_size 0;\n    out_ack_size 2500000;\n    publish {\n        mr off;\n        mr_latency 350;\n        firstpkt_timeout 20000;\n        normal_timeout 7000;\n        parse_sps on;\n        try_annexb_first on;\n        kickoff_for_idle 0;\n    }\n    play {\n        gop_cache off;\n        gop_cache_max_frames 2500;\n        queue_length 10;\n        time_jitter full;\n        atc off;\n        mix_correct off;\n        atc_auto off;\n        mw_latency 350;\n        mw_msgs 8;\n        send_min_interval 10.0;\n        reduce_sequence_header on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Origin SRS Server Configuration - SRS Config (Bash context)\nDESCRIPTION: This block provides an example configuration file for the origin SRS server (conf/origin.conf). It sets parameters like the listening port, connection limit, PID file path, log file path, and default vhost declaration. This config is essential for establishing the central origin node in the RTMP cluster. Input: file saved as conf/origin.conf. Output: used at SRS startup to serve as the origin RTMP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.conf\nlisten              19350;\nmax_connections     1000;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Time Jitter for RTMP Delivery in SRS Configuration File (Bash)\nDESCRIPTION: This snippet demonstrates how to configure the 'time_jitter' and 'mix_correct' parameters under the 'play' section for a specific vhost in the SRS configuration file. Modifying these parameters ensures that the stream timestamps for audio and video are monotonically increasing as required by RTMP; 'time_jitter' can be set to 'full', 'zero', or 'off', and 'mix_correct' enables correction for mixed audio/video streams. Requires access to SRS configuration and understanding of vhost structure; inputs are configuration settings, and outputs are the adjusted server behavior for stream timestamp correction.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/time-jitter.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost jitter.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing, \n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # default: full\n        time_jitter             full;\n        # whether use the interleaved/mixed algorithm to correct the timestamp.\n        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.\n        # if off, use time_jitter to correct the timestamp if required.\n        # default: off\n        mix_correct             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for SRT Streaming\nDESCRIPTION: Launches an SRS Docker container with SRT (Secure Reliable Transport) support for low-latency streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 10080:10080/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Streaming to SRS using FFmpeg\nDESCRIPTION: This FFmpeg command streams a local video file to SRS using RTMP protocol. It copies the video and audio codecs without re-encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Forward in SRS Vhost\nDESCRIPTION: Example configuration for enabling forward functionality in an SRS vhost, including static destination and dynamic backend options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # forward stream to other servers.\n    forward {\n        # whether enable the forward.\n        # default: off\n        enabled on;\n        # forward all publish stream to the specified server.\n        # this used to split/forward the current stream for cluster active-standby,\n        # active-active for cdn to build high available fault tolerance system.\n        # format: {ip}:{port} {ip_N}:{port_N}\n        destination 127.0.0.1:1936 127.0.0.1:1937;\n\n        # when client(encoder) publish to vhost/app/stream, call the hook in creating backend forwarder.\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_forward\",\n        #           \"server_id\": \"vid-k21d7y2\",\n        #           \"client_id\": \"9o7g1330\",\n        #           \"ip\": \"127.0.0.1\",\n        #           \"vhost\": \"__defaultVhost__\",\n        #           \"app\": \"live\",\n        #           \"tcUrl\": \"rtmp://127.0.0.1:1935/live\",\n        #           \"stream\": \"livestream\",\n        #           \"param\": \"\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       {\n        #          \"code\": 0,\n        #          \"data\": {\n        #              \"urls\":[\n        #                 \"rtmp://127.0.0.1:19350/test/teststream\"\n        #              ]\n        #          }\n        #       }\n        # PS: you can transform params to backend service, such as:\n        #       { \"param\": \"?forward=rtmp://127.0.0.1:19351/test/livestream\" }\n        #     then backend return forward's url in response.\n        # if backend return empty urls, destanition is still disabled.\n        # only support one api hook, format:\n        #       backend http://xxx/api0\n        backend http://127.0.0.1:8085/api/v1/forward;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Second Origin Server for HLS Output (Bash)\nDESCRIPTION: Command to start the second SRS origin server, also listening on ports 1935 and 8080, configured for RTMP input and HLS output.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only2.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to SRS Edge\nDESCRIPTION: Command for publishing an RTMP stream to the SRS Edge server deployed on Kubernetes. The IP address should be replaced with the actual External IP of the srs-edge-service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nrtmp://28.170.32.118/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Source Code - Bash\nDESCRIPTION: Pulls the latest changes for an existing SRS codebase clone via Git. Requires an existing repository and Git installed. After completion, the local repo reflects the latest upstream commits.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Forwarding within a Vhost\nDESCRIPTION: This configuration snippet demonstrates how to enable stream forwarding within an SRS virtual host (`__defaultVhost__`). The `forward` block is used, setting `enabled on` activates the feature. The `destination` parameter specifies one or more target slave servers (IP:port) where published streams will be forwarded. This example forwards streams to two local destinations (127.0.0.1:1936 and 127.0.0.1:1937).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/forward.md#2025-04-23_snippet_0\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # forward stream to other servers.\n    forward {\n        # whether enable the forward.\n        # default: off\n        enabled on;\n        # forward all publish stream to the specified server.\n        # this used to split/forward the current stream for cluster active-standby,\n        # active-active for cdn to build high available fault tolerance system.\n        # format: {ip}:{port} {ip_N}:{port_N}\n        destination 127.0.0.1:1936 127.0.0.1:1937;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server Settings in SRS\nDESCRIPTION: Comprehensive configuration block for SRT server including network parameters, latency settings, security options, and protocol conversion. Includes settings for bandwidth control, connection timeouts, encryption, and buffer sizes with detailed documentation for each parameter.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/srt.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    maxbw 1000000000;\n    mss 1500;\n    connect_timeout 4000;\n    peer_idle_timeout 8000;\n    default_app live;\n    peerlatency 0;\n    recvlatency 0;\n    latency 0;\n    tsbpdmode off;\n    tlpktdrop off;\n    sendbuf 2000000;\n    recvbuf 2000000;\n    passphrase xxxxxxxxxxxx;\n    pbkeylen 16;\n}\nvhost __defaultVhost__ {\n    srt {\n        enabled on;\n        srt_to_rtmp on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server Example\nDESCRIPTION: Configuration example for an SRS edge server that connects to an origin server. It specifies standard listening port, PID file, log file, and remote cluster mode with origin server address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/edge.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Ingest Settings for SRS - Bash\nDESCRIPTION: This Bash-style configuration snippet defines how to set up an ingest source in an SRS vhost. It shows enabling the ingest, specifying the input type and file/stream/device source, setting the path to FFmpeg, and configuring the transcoding engine and the RTMP output destination. The snippet includes detailed comments and explanations for each directive, using placeholders for custom values. Dependencies include SRS compiled with --with-ingest, FFmpeg installed at the specified path, and correct input/output URLs. Parameters such as 'enabled', 'type', 'url', and 'output' control key behaviors; outputs are pushed to a configurable RTMP endpoint. Only a single input source is supported per ingest block, and 'device' is not yet supported.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # ingest file/stream/device then push to SRS over RTMP.\n    # the name/id used to identify the ingest, must be unique in global.\n    # ingest id is used in reload or http api management.\n    ingest livestream {\n        # whether enabled ingest features\n        # default: off\n        enabled      on;\n        # input file/stream/device\n        # @remark only support one input.\n        input {\n            # the type of input.\n            # can be file/stream/device, that is,\n            #   file: ingest file specifies by url.\n            #   stream: ingest stream specifeis by url.\n            #   device: not support yet.\n            # default: file\n            type    file;\n            # the url of file/stream.\n            url     ./doc/source.flv;\n        }\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine, @see all.transcode.srs.com\n        # @remark, the output is specified following.\n        engine {\n            # @see enabled of transcode engine.\n            # if disabled or vcodec/acodec not specified, use copy.\n            # default: off.\n            enabled          off;\n            # output stream. variables:\n            # [vhost] current vhost which start the ingest.\n            # [port] system RTMP stream port.\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Using FFmpeg Docker Container\nDESCRIPTION: Uses FFmpeg in Docker to publish a sample video stream to SRS server using RTMP protocol\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv -c copy \\\n    -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream using FMLE (Configuration)\nDESCRIPTION: Specifies the necessary settings for publishing an RTMP stream using Adobe Flash Media Live Encoder (FMLE) or similar software. The FMS URL should be set to `rtmp://192.168.1.170/live` and the Stream name to `livestream`. The IP address (192.168.1.170) needs to be adjusted to the actual server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for HTTP Callback Snapshots\nDESCRIPTION: Configuration file for SRS that sets up HTTP callbacks for stream publish and unpublish events to trigger snapshots. It also configures an ingest to simulate a live stream using a local file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\n# snapshot.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    http_hooks {\n        enabled on;\n        on_publish http://127.0.0.1:8085/api/v1/snapshots;\n        on_unpublish http://127.0.0.1:8085/api/v1/snapshots;\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for RTMP to WebRTC\nDESCRIPTION: Docker command to run SRS with RTMP to WebRTC conversion configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback on_publish Event JSON Format\nDESCRIPTION: Illustrates the JSON format for the on_publish event in HTTP callbacks, including request and response structures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_6\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"3ab26a09-59b0-42f7-98e3-a281c7d0712b\",\n  \"action\": \"on_publish\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"param\": \"?secret=8f7605d657c74d69b6b48f532c469bc9\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Ingest in SRS\nDESCRIPTION: Example configuration for setting up an ingest in SRS. It demonstrates how to define an ingest source, specify the input type and URL, set the FFmpeg path, and configure the transcode engine.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    ingest livestream {\n        enabled      on;\n        input {\n            type    file;\n            url     ./doc/source.flv;\n        }\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled          off;\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning the SRS Repository (Bash)\nDESCRIPTION: This snippet demonstrates how to download the SRS source code from its GitHub repository using Git and navigate into the main development directory (`trunk`). This is the first step in obtaining the necessary files to build the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: SRS Low Latency Configuration\nDESCRIPTION: Configuration file for SRS server optimized for low latency streaming, including TCP nodelay, minimum latency settings, and GOP cache configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/realtime.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for WebRTC\nDESCRIPTION: Docker command to run SRS with WebRTC support, including additional ports and CANDIDATE environment variable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Configuring High Quality Mode for SRT in SRS\nDESCRIPTION: Configuration settings for SRT server in high quality mode with increased tolerance for latency and better stability over unstable networks. Disables packet dropping and timestamp-based packet delivery mode.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_4\n\nLANGUAGE: plain\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    connect_timeout 4000;\n    peerlatency 0;\n    recvlatency 0;\n    latency 0;\n    tlpktdrop off;\n    tsbpdmode off;\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming HEVC over RTMP with FFmpeg\nDESCRIPTION: Command to push HEVC-encoded video over RTMP protocol to an SRS server. This uses libx265 for video encoding while copying the audio stream from the source file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./ffmpeg -stream_loop -1 -re -i ~/srs/doc/source.flv -acodec copy -vcodec libx265 \\\n  -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Proxy Server with Environment Variables\nDESCRIPTION: Command to start the SRS proxy server with all required parameters including RTMP, HTTP, WebRTC, and SRT ports using environment variables and memory load balancer.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nenv PROXY_RTMP_SERVER=1935 PROXY_HTTP_SERVER=8080 \\\n    PROXY_HTTP_API=1985 PROXY_WEBRTC_SERVER=8000 PROXY_SRT_SERVER=10080 \\\n    PROXY_SYSTEM_API=12025 PROXY_LOAD_BALANCER_TYPE=memory ./srs-proxy\n```\n\n----------------------------------------\n\nTITLE: Configuring the Master SRS Instance for Forwarding\nDESCRIPTION: This is an SRS configuration file snippet for the master server. It sets the listening port to 1935, defines connection limits, specifies PID and log file paths, and configures the default virtual host to enable stream forwarding ('forward' directive) to a destination server at 127.0.0.1 on port 19350 (the slave server).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_3\n\nLANGUAGE: SRS Config\nCODE:\n```\n# conf/forward.master.conf\nlisten              1935;\nmax_connections     1000;\npid                 ./objs/srs.master.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.master.log;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFmpeg in Bash\nDESCRIPTION: Bash script to continuously publish a stream to SRS using FFmpeg. It reads from a source file and streams to the RTMP endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Starting SRS and Viewing Initial Log Output in Bash\nDESCRIPTION: Demonstrates how to start the SRS server using a specific configuration file (`console.conf`) and view the initial log entries written to `objs/srs.log`. The log output includes crucial system information like version, build configuration, PID, listening ports (RTMP, HTTP API, HTTP Server), and timestamped events.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c console.conf \n[winlin@dev6 srs]$ cat objs/srs.log \n[2014-04-04 11:39:24.176][trace][0][0] config parsed EOF\n[2014-04-04 11:39:24.176][trace][0][0] log file is ./objs/srs.log\n[2014-04-04 11:39:24.177][trace][0][0] srs 0.9.46\n[2014-04-04 11:39:24.177][trace][0][0] uname: Linux dev6 2.6.32-71.el6.x86_64 \n#1 SMP Fri May 20 03:51:51 BST 2011 x86_64 x86_64 x86_64 GNU/Linux\n[2014-04-04 11:39:24.177][trace][0][0] build: 2014-04-03 18:38:23, little-endian\n[2014-04-04 11:39:24.177][trace][0][0] configure:  --dev --with-hls --with-nginx \n--with-ssl --with-ffmpeg --with-http-callback --with-http-server --with-http-api \n--with-librtmp --with-bwtc --with-research --with-utest --without-gperf --without-gmc \n--without-gmp --without-gcp --without-gprof --without-arm-ubuntu12 --jobs=1 \n--prefix=/usr/local/srs\n[2014-04-04 11:39:24.177][trace][0][0] write pid=4021 to ./objs/srs.pid success!\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1935, type=0, fd=6\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1985, type=1, fd=7\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=8080, type=2, fd=8\n[2014-04-04 11:39:24.177][trace][101][16] listen cycle start, port=1935, type=0, fd=6\n[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n...\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Clone the SRS source code repository from GitHub using the develop branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Receiving SDP Answer from SRS after WHIP POST - text\nDESCRIPTION: This snippet provides a sample SDP answer payload returned by SRS in response to a WHIP POST request. The response is delivered as HTTP response body, with a 201 status. Clients should parse the SDP answer from the HTTP response to complete the WebRTC session negotiation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nv=0\n......\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Configuration for Edge Server\nDESCRIPTION: Configuration file for the edge server that pulls streams from the origin servers. It specifies the remote cluster mode and lists both origin servers as potential sources.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19351 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS with a Default Vhost in Bash\nDESCRIPTION: This configuration snippet sets up the SRS media server to listen for RTMP connections on port 1935. It defines a single virtual host named `__defaultVhost__`, which acts as a catch-all for any connection requests that don't match a specifically named Vhost. This setup is suitable for simple use cases where distinguishing between multiple tenants or configurations via Vhosts is unnecessary.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server\nDESCRIPTION: This snippet shows the configuration for an SRS edge server, including the listen port, PID file, log file, and cluster settings to connect to the origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/edge.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus Exporter in SRS\nDESCRIPTION: Configuration block for enabling and setting up Prometheus exporter in SRS. It includes options for enabling the exporter, setting the listen port, and specifying labels and tags for categorizing cluster servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Prometheus exporter config.\n# See https://prometheus.io/docs/instrumenting/exporters\nexporter {\n    # Whether exporter is enabled.\n    # Overwrite by env SRS_EXPORTER_ENABLED\n    # Default: off\n    enabled off;\n    # The http api listen port for exporter metrics.\n    # Overwrite by env SRS_EXPORTER_LISTEN\n    # Default: 9972\n    # See https://github.com/prometheus/prometheus/wiki/Default-port-allocations\n    listen 9972;\n    # The logging label to category the cluster servers.\n    # Overwrite by env SRS_EXPORTER_LABEL\n    label cn-beijing;\n    # The logging tag to category the cluster servers.\n    # Overwrite by env SRS_EXPORTER_TAG\n    tag cn-edge;\n}\n```\n\n----------------------------------------\n\nTITLE: Reverse Proxying SRS with NGINX - NGINX Configuration\nDESCRIPTION: An nginx.conf snippet for setting up NGINX as a reverse proxy in front of the SRS server. It listens on HTTP and HTTPS ports, proxies static content and streaming files to the SRS HTTP server, while API and WebRTC requests go to the SRS API port. SSL certificates and configuration for HTTP/2 included. Adjust proxy_pass URLs and SSL file paths as needed for your deployment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_4\n\nLANGUAGE: nginx\nCODE:\n```\nworker_processes  1;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include             /etc/nginx/mime.types;\n\n    server {\n        listen       80;\n        listen       443 ssl http2;\n        server_name  _;\n        ssl_certificate      /usr/local/srs/conf/server.crt;\n        ssl_certificate_key  /usr/local/srs/conf/server.key;\n\n        # For SRS homepage, console and players\n        #   http://r.ossrs.net/console/\n        #   http://r.ossrs.net/players/\n        location ~ ^/(console|players)/ {\n           proxy_pass http://127.0.0.1:8080/$request_uri;\n        }\n        # For SRS streaming, for example:\n        #   http://r.ossrs.net/live/livestream.flv\n        #   http://r.ossrs.net/live/livestream.m3u8\n        location ~ ^/.+/.*\\.(flv|m3u8|ts|aac|mp3)$ {\n           proxy_pass http://127.0.0.1:8080$request_uri;\n        }\n        # For SRS backend API for console.\n        # For SRS WebRTC publish/play API.\n        location ~ ^/(api|rtc)/ {\n           proxy_pass http://127.0.0.1:1985$request_uri;\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callback in Go - Go\nDESCRIPTION: This Go code demonstrates creating an HTTP server that listens for SRS callbacks (such as on_publish) at /api/v1/streams. It reads and logs the request body, responds with a JSON object {code: 0, msg: 'OK'}, and includes error handling for request read and JSON marshal failures. Dependencies include the standard Go net/http, encoding/json, and ioutil packages. The server listens on port 8085 and returns the expected HTTP 200 response with the required body, suiting SRS protocol requirements.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nhttp.HandleFunc(\"/api/v1/streams\", func(w http.ResponseWriter, r *http.Request) {\n    b, err := ioutil.ReadAll(r.Body)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n\n    fmt.Println(string(b))\n\n    res, err := json.Marshal(struct {\n        Code int `json:\"code\"`\n        Message string `json:\"msg\"`\n    }{\n        0, \"OK\",\n    })\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n    w.Write(res)\n})\n\n_ = http.ListenAndServe(\":8085\", nil)\n```\n\n----------------------------------------\n\nTITLE: Applying DVR to Specific Streams in SRS - Bash Configuration\nDESCRIPTION: This snippet demonstrates how to apply DVR recording to specific streams using the dvr_apply directive in SRS. By specifying stream keys such as live/stream1 and live/stream2, DVR features are selectively enabled only for those streams, optimizing storage and processing. This should be placed inside a vhost section of the SRS config file. No external dependencies; only affects stream-level DVR activation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/dvr.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost xxx {\n    dvr {\n        dvr_apply live/stream1 live/stream2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting WebRTC Candidate IP via Environment Variable\nDESCRIPTION: Bash commands to obtain the server's IP address and set it as an environment variable for SRS to use as the WebRTC candidate.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\nCANDIDATE=$(ifconfig en0 inet| grep 'inet '|awk '{print $2}')\n\n# For CentOS\nCANDIDATE=$(ifconfig eth0|grep 'inet '|awk '{print $2}')\n\n# Directly set ip.\nCANDIDATE=\"192.168.3.10\"\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC over TCP Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC over TCP transport enabled on port 8000, with custom candidate IP configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080 -p 1985:1985 -p 8000:8000 \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: Running Patched FFmpeg with HEVC over RTMP via Docker - Bash\nDESCRIPTION: This snippet demonstrates how to use a pre-built Docker image (ossrs/srs:encoder) containing FFmpeg patched with HEVC-over-RTMP support. The container launches FFmpeg to stream a local FLV file, utilizing libx265 for video encoding and copying audio, then pushes the stream via RTMP to a live endpoint. Requires Docker, the ossrs/srs:encoder image, and a running SRS instance at the specified endpoint. Inputs: source FLV file path; Outputs: live RTMP stream to SRS server; Limitation: The SRS server must already be configured and accessible at rtmp://localhost/live/livestream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --net host ossrs/srs:encoder \\\n  ffmpeg -re -i doc/source.flv -acodec copy -vcodec libx265 \\\n    -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Settings in SRS (General Structure) - Conf\nDESCRIPTION: This block presents the hierarchy and context of HLS-specific and related HTTP hook settings, as encountered in the SRS configuration. It references various callback URLs and notes which settings belong in http_hooks instead of the HLS config block. This aids users in understanding the overall placement and intent of callback-related options. To be used within a full SRS configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_6\n\nLANGUAGE: conf\nCODE:\n```\n# on_hls, never config in here, should config in http_hooks.\n# for the hls http callback, @see http_hooks.on_hls of vhost hooks.callback.srs.com\n# @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#http-callback\n# @see https://ossrs.io/lts/en-us/docs/v4/doc/delivery-hls#http-callback\n\n# on_hls_notify, never config in here, should config in http_hooks.\n# we support the variables to generate the notify url:\n#       [app], replace with the app.\n#       [stream], replace with the stream.\n#       [param], replace with the param.\n#       [ts_url], replace with the ts url.\n# for the hls http callback, @see http_hooks.on_hls_notify of vhost hooks.callback.srs.com\n# @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#on-hls-notify\n# @see https://ossrs.io/lts/en-us/docs/v4/doc/delivery-hls#on-hls-notify\n```\n\n----------------------------------------\n\nTITLE: Standard Logrotate Configuration for SRS\nDESCRIPTION: Configuration for logrotate to manage SRS logs with daily rotation, compression, and proper signal handling using SIGUSR1.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/log-rotate.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    sharedscripts\n    postrotate\n        kill -USR1 \\`cat /usr/local/srs/objs/srs.pid\\`\n    endscript\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Applying Transcoding to a Specific Stream in an App - Bash Configuration\nDESCRIPTION: This configuration snippet applies transcoding via SRS to a single stream within a given application, specified as 'transcode live/livestream'. Intended to be placed within a vhost block of the SRS configuration, this ensures only the stream named 'livestream' in app 'live' is subjected to the transcoding pipeline. The block can be customized with specific settings as needed for per-stream control.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode stream name is \"livestream\" and app is \"live\"\n    transcode live/livestream{\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC over TCP\nDESCRIPTION: This command runs SRS in a Docker container with WebRTC over TCP enabled. It sets the candidate IP, enables the RTC server TCP, sets the protocol to TCP, and configures the TCP listen port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080 -p 1985:1985 -p 8000:8000 \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8000 \\\n  ossrs/srs:v5\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for SRT Streaming\nDESCRIPTION: Starts an SRS server configured for SRT (Secure Reliable Transport) streaming using `conf/srt.conf`. It maps the default UDP port 10080 required for SRT connections, along with standard RTMP/HTTP ports. This example pulls the SRS image from a specific Aliyun registry.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 10080:10080/udp \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:4 ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Server with FFMPEG Configuration (Bash)\nDESCRIPTION: Executes the compiled SRS server binary located in './objs/srs', specifying the configuration file to use ('conf/ffmpeg.conf') via the '-c' flag. This starts the SRS server with the transcoding settings defined in the configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ffmpeg.conf\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for Benchmarking and Forwarding\nDESCRIPTION: An example snippet for an SRS configuration file (`srs.conf`). It sets the listening port to 1935, the maximum connection limit to 10240, enables GOP cache, and configures the default virtual host to forward incoming streams to another server (likely the Nginx-RTMP instance) at 127.0.0.1:19350. This setup is used for performance comparison.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_38\n\nLANGUAGE: conf\nCODE:\n```\nlisten              1935;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    gop_cache       on;\n    forward         127.0.0.1:19350;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Server in SRS RTMP Cluster\nDESCRIPTION: This snippet shows the configuration for an edge server in the SRS RTMP cluster. It specifies the listening port, PID file location, log file path, and the remote cluster mode with origin server details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/edge.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Log Tank in Configuration File\nDESCRIPTION: Configuration options for specifying where SRS should write logs - either to console or to a file. When set to file, the log will be written to the path specified by srs_log_file, which defaults to ./objs/srs.log.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the log tank, console or file.\n# if console, print log to console.\n# if file, write log to file. requires srs_log_file if log to file.\n# default: file.\nsrs_log_tank        file;\n```\n\n----------------------------------------\n\nTITLE: Prometheus Configuration for SRS and Node Metrics\nDESCRIPTION: YAML configuration for Prometheus to scrape metrics from both SRS and node_exporter every 5 seconds.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_4\n\nLANGUAGE: yml\nCODE:\n```\nscrape_configs:\n  - job_name: \"node\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9100\"]\n  - job_name: \"srs\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9972\"]\n```\n\n----------------------------------------\n\nTITLE: Running SRS for WebRTC to WebRTC Streaming\nDESCRIPTION: Docker command to run SRS with configuration for WebRTC to WebRTC streaming, setting the external candidate IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Basic SRS FFMPEG Transcode Configuration\nDESCRIPTION: Core configuration for setting up FFMPEG transcoding in SRS vhost. Includes engine configuration with video/audio encoding parameters, filters, and output settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # the streaming transcode configs.\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine example {\n            enabled         on;\n            perfile {\n                re;\n                rtsp_transport tcp;\n            }\n            iformat         flv;\n            vfilter {\n                i               ./doc/ffmpeg-logo.png;\n                filter_complex  'overlay=10:10';\n            }\n            vcodec          libx264;\n            vbitrate        1500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n                t               100;\n                coder           1;\n                b_strategy      2;\n                bf              3;\n                refs            10;\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n                profile:a   aac_low;\n                bsf:a       aac_adtstoasc;\n            }\n            oformat         flv;\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Command for SRT Authentication\nDESCRIPTION: FFmpeg command demonstrating how to include authentication parameters in the SRT stream URL.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f mpegts \\\n    'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,secret=xxx,m=publish'\n```\n\n----------------------------------------\n\nTITLE: RTMP Server Configuration\nDESCRIPTION: Basic RTMP configuration file that sets up the listening port and maximum connections for the default virtual host.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/rtmp.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin ServerA - Bash/SRS Config\nDESCRIPTION: This configuration template defines parameters for running an SRS Origin Cluster ServerA. It sets listening ports, maximum connections, logging, the PID location, HTTP API configuration, and specifies the cluster mode and coworkers. Used as a config file to launch ServerA with origin clustering enabled; input is the config file, output is an operational origin server. Requires a built SRS binary.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverA.conf\\nlisten              19350;\\nmax_connections     1000;\\ndaemon              off;\\nsrs_log_tank        console;\\npid                 ./objs/origin.cluster.serverA.pid;\\nhttp_api {\\n    enabled         on;\\n    listen          9090;\\n}\\nvhost __defaultVhost__ {\\n    cluster {\\n        mode            local;\\n        origin_cluster  on;\\n        coworkers       127.0.0.1:9091;\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Handling SRS Callbacks with Node.js and Koa\nDESCRIPTION: Node.js example using Koa framework to handle SRS callbacks (specifically on_publish event). It logs the request body and returns a successful response with code 0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst Router = require('koa-router');\nconst router = new Router();\n\nrouter.all('/api/v1/streams', async (ctx) => {\n  console.log(ctx.request.body);\n  \n  ctx.body = {code: 0, msg: 'OK'};\n});\n```\n\n----------------------------------------\n\nTITLE: RTMP Playback URL for SRS Edge Server (Plaintext)\nDESCRIPTION: This is the RTMP URL used by clients (like VLC or an online player) to connect to the edge server (listening on the default port 1935) and play the `livestream` stream. The edge server handles fetching the stream from the appropriate origin server within the cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nrtmp://192.168.1.170/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Starting Signaling Server with Docker\nDESCRIPTION: Command to run the signaling server required for WebRTC communication. Maps port 1989 for signaling protocol communications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 1989:1989 registry.cn-hangzhou.aliyuncs.com/ossrs/signaling:1\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Playback Settings in SRS\nDESCRIPTION: This snippet shows the configuration options for RTMP playback in SRS, including GOP cache, queue length, time jitter handling, and ATC settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nplay {\n    gop_cache off;\n    gop_cache_max_frames 2500;\n    queue_length 10;\n    time_jitter full;\n    atc off;\n    mix_correct off;\n    atc_auto off;\n    mw_latency 350;\n    mw_msgs 8;\n    send_min_interval 10.0;\n    reduce_sequence_header on;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS FFMPEG Transcoding\nDESCRIPTION: Comprehensive configuration example for setting up FFMPEG transcoding in SRS. Includes settings for video/audio encoding, filters, and output formats. Demonstrates how to configure transcoding at vhost level with detailed parameters for video and audio processing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # the streaming transcode configs.\n    transcode {\n        # whether the transcode enabled.\n        # if off, donot transcode.\n        # default: off.\n        enabled     on;\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine for matched stream.\n        engine example {\n            enabled         on;\n            iformat         flv;\n            vfilter {\n                i               ./doc/ffmpeg-logo.png;\n                filter_complex  'overlay=10:10';\n            }\n            vcodec          libx264;\n            vbitrate        1500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n                t               100;\n                coder           1;\n                b_strategy      2;\n                bf              3;\n                refs            10;\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n                profile:a   aac_low;\n                bsf:a       aac_adtstoasc;\n            }\n            oformat         flv;\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Settings in SRS\nDESCRIPTION: This snippet shows the RTMP configuration options for an SRS vhost, including settings for minimal latency, TCP nodelay, chunk size, and acknowledge sizes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    min_latency off;\n    tcp_nodelay off;\n    chunk_size 128;\n    in_ack_size 0;\n    out_ack_size 2500000;\n    # ... other settings ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Ingest in SRS\nDESCRIPTION: This snippet demonstrates how to configure the Ingest feature in SRS. It includes settings for enabling ingest, specifying input sources, and configuring the FFmpeg transcoding engine.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # ingest file/stream/device then push to SRS over RTMP.\n    # the name/id used to identify the ingest, must be unique in global.\n    # ingest id is used in reload or http api management.\n    ingest livestream {\n        # whether enabled ingest features\n        # default: off\n        enabled      on;\n        # input file/stream/device\n        # @remark only support one input.\n        input {\n            # the type of input.\n            # can be file/stream/device, that is,\n            #   file: ingest file specifies by url.\n            #   stream: ingest stream specifeis by url.\n            #   device: not support yet.\n            # default: file\n            type    file;\n            # the url of file/stream.\n            url     ./doc/source.flv;\n        }\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine, @see all.transcode.srs.com\n        # @remark, the output is specified following.\n        engine {\n            # @see enabled of transcode engine.\n            # if disabled or vcodec/acodec not specified, use copy.\n            # default: off.\n            enabled          off;\n            # output stream. variables:\n            # [vhost] current vhost which start the ingest.\n            # [port] system RTMP stream port.\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS for RTMP to WebRTC Configuration\nDESCRIPTION: Docker command to run SRS with the RTMP to WebRTC configuration. This setup allows RTMP input streams to be delivered to WebRTC players.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: DVR Apply Configuration for Specific Streams (Bash)\nDESCRIPTION: Example configuration showing how to apply DVR only to specific streams (live/stream1 and live/stream2) within a virtual host rather than recording all streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost xxx {\n    dvr {\n        dvr_apply live/stream1 live/stream2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple RTMP Vhosts for Customers - Bash\nDESCRIPTION: This snippet configures two separate vhosts for different customers (cctv and wasu) on the same SRS server instance. Each vhost is defined independently without additional settings, allowing for separation of customer streams and statistics. Each vhost matches a specific DNS name (show.cctv.cn and show.wasu.cn). SRS server must be configured with this file; clients connect via different DNS hostnames to route to the correct vhost.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n}\nvhost show.wasu.cn {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running SRS with Custom Candidate IP\nDESCRIPTION: This snippet shows how to run SRS with a custom candidate IP using environment variables. It includes an example of running SRS in a Docker container with the CANDIDATE environment variable set.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nenv CANDIDATE=\"192.168.3.10\" \\\n  ./objs/srs -c conf/rtc.conf\n\nexport CANDIDATE=\"192.168.3.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback on_record_end Event JSON Format\nDESCRIPTION: Illustrates the JSON format for the on_record_end event in HTTP callbacks, including request and response structures with artifact details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_record_end\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"artifact_code\": 0,\n  \"artifact_path\": \"/data/record/824b96f9-8d51-4046-ba1e-a9aec7d57c95/index.mp4\",\n  \"artifact_url\": \"http://localhost/terraform/v1/hooks/record/hls/824b96f9-8d51-4046-ba1e-a9aec7d57c95/index.mp4\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: SRS WebRTC TCP Server Configuration\nDESCRIPTION: Configuration file example showing WebRTC TCP server settings including TCP port and protocol selection options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    tcp {\n        enabled off;\n        listen 8000;\n    }\n    protocol udp;\n}\n```\n\n----------------------------------------\n\nTITLE: Edge Server Configuration\nDESCRIPTION: Configuration file for edge SRS servers, configured to pull streams from the origin server and serve HTTP-FLV streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.flv.live.edge1.conf\nlisten              19351;\nmax_connections     1000;\npid                 objs/srs.flv.19351.pid;\nsrs_log_file        objs/srs.flv.19351.log;\nhttp_server {\n    enabled         on;\n    listen          8081;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    mode remote;\n    origin 127.0.0.1;\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for HTTP HLS (SRS Config)\nDESCRIPTION: This is an example SRS configuration file (`conf/http.hls.conf`) enabling the embedded HTTP server and HLS streaming. It specifies the RTMP listen port (1935), maximum connections, enables the HTTP server on port 8080 serving files from `./objs/nginx/html`, and configures HLS segment duration and window size within the default virtual host. The `hls_path` directory must exist beforehand.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.hls.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: NGINX Edge Proxy Cache Configuration for HLS Edge Delivery - Nginx Config\nDESCRIPTION: This NGINX configuration sets up a worker process, proxy cache, and HTTP server that listens on port 8081 for '.m3u8' and '.ts' files, which are proxied to the SRS origin HTTP server on port 8080. It includes cache locking, expiration times, and cache keys. Intended for HLS edge servers and requires a built NGINX with proxy and cache modules enabled. Should be saved to 'conf/hls.edge.conf'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: nginx\nCODE:\n```\n# conf/hls.edge.conf\nworker_processes  3;\nevents {\n    worker_connections  10240;\n}\n\nhttp {\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       8081;\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WebRTC Playing with WHEP Protocol\nDESCRIPTION: Example of WebRTC stream playing using WHEP protocol showing the SDP request format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whep/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\n----------------------------------------\n\nTITLE: Pushing UDP Stream to SRS Origin via FFmpeg\nDESCRIPTION: This shell command uses FFmpeg to read a UDP stream (`udp://xxx:1234`), transcode it to H.264 video and AAC audio, add metadata, and push it as an FLV-encapsulated RTMP stream to an SRS origin server at `rtmp://xxx:1935/live/xxx:1234`. The original UDP multicast group `xxx:1234` is used as the RTMP stream name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n    ffmpeg -i udp://xxx:1234 -vcodec libx264 -acodec libfdk_aac \\\n      -metadata service_name=\"Channel 1\" -metadata service_provider=\"PBS\" \\\n      -f flv rtmp://xxx:1935/live/xxx:1234\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream using FFmpeg\nDESCRIPTION: Bash script to continuously publish a sample video file to SRS using FFmpeg. The script loops to restart the stream if it ends or disconnects.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Graceful Upgrade Configuration for SRS\nDESCRIPTION: Configuration example for SRS graceful upgrades, including wait times before closing listeners, final cleanup wait time, and force graceful quit option. These settings help achieve zero-downtime upgrades.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# For gracefully quit, wait for a while then close listeners,\n# because K8S notify SRS with SIGQUIT and update Service simultaneously,\n# maybe there is some new connections incoming before Service updated.\n# @see https://github.com/ossrs/srs/issues/1595#issuecomment-587516567\n# default: 2300\ngrace_start_wait 2300;\n# For gracefully quit, final wait for cleanup in milliseconds.\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587414898\n# default: 3200\ngrace_final_wait 3200;\n# Whether force gracefully quit, never fast quit.\n# By default, SIGTERM which means fast quit, is sent by K8S, so we need to\n# force SRS to treat SIGTERM as gracefully quit for gray release or canary.\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587475077\n# default: off\nforce_grace_quit off;\n```\n\n----------------------------------------\n\nTITLE: Customizing Vhost Chunk Size for Multiple Customers - SRS - Bash\nDESCRIPTION: Demonstrates advanced SRS configuration by setting listener and custom 'chunk_size' parameters for two different vhosts: 'show.cctv.cn' (chunk_size 128) and 'show.wasu.cn' (chunk_size 4096). Intended for multi-customer scenarios where different streaming characteristics are required, such as low-latency or fast startup. Dependencies: SRS; parameters include 'chunk_size' per vhost. Config ensures isolation of configuration between different vhosts on the same server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n    chunk_size 128;\n}\nvhost show.wasu.cn {\n    chunk_size 4096;\n}\n\n```\n\n----------------------------------------\n\nTITLE: SRS Tool Parsing Example for Multi-Level RTMP URL\nDESCRIPTION: This example shows the parsing logic used by SRS tools like `srs_player` and `srs_publisher` for an RTMP URL containing multiple path components. Given the URL `rtmp://demo.srs.com/show/live/livestream/2013`, the schema is identified as `rtmp`, the host/Vhost as `demo.srs.com`, the application (`app`) as `show/live/livestream`, and the stream name as `2013`. This highlights the convention of treating the final segment as the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n// srs_playersrs_publisher\n// play or publish the following rtmp URL:\nrtmp://demo.srs.com/show/live/livestream/2013\nschema: rtmp\nhost/vhost: demo.srs.com\napp: show/live/livestream\nstream: 2013\n```\n\n----------------------------------------\n\nTITLE: Stream Caster Flow Diagram\nDESCRIPTION: Basic flow diagram showing how Stream Caster converts protocols to RTMP for distribution to clients in various formats.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/streamer.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nClient ---PUSH--> Stream Converter --RTMP--> SRS --RTMP/FLV/HLS/WebRTC--> Clients\n```\n\n----------------------------------------\n\nTITLE: Running SRS in ARMv7 Docker Environment\nDESCRIPTION: Command to run the cross-compiled SRS binary in an ARMv7 Docker container.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 armv7/armhf-ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Callback Handler in Node.js/Koa\nDESCRIPTION: Example Node.js code using Koa framework for handling SRS HTTP callbacks. Sets up a route to process callbacks and return the required response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nconst Router = require('koa-router');\nconst router = new Router();\n\nrouter.all('/api/v1/streams', async (ctx) => {\n  console.log(ctx.request.body);\n\n  ctx.body = {code: 0, msg: 'OK'};\n});\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS from GitHub\nDESCRIPTION: Direct command to clone SRS from the main GitHub repository\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/resource.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Receiving SDP Answer from SRS after WHEP POST - text\nDESCRIPTION: This snippet provides a sample SDP answer as returned by SRS in response to a WHEP POST request. The answer includes ICE candidate information and is necessary to establish the WebRTC session. The response code is 201, per WHIP/WHEP protocol expectation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nv=0\n......\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream with FFMPEG in Loop - Bash\nDESCRIPTION: This Bash loop repeatedly uses FFMPEG to publish a local FLV file as an RTMP stream to the server. FFMPEG must be present at './objs/ffmpeg/bin/ffmpeg'. Replace '192.168.1.170' with your server IP. The script reads 'source.flv', copies codecs, and streams to '/live/livestream', sleeping 1 second between each publish cycle. Edit input/output paths as needed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-realtime.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\\\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\\\\n    -c copy \\\\\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\\\\n    sleep 1; \\\\\\ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin for HLS Generation - SRS Conf\nDESCRIPTION: This configuration file sets up the SRS server to generate HLS files, enabling HTTP serving on port 8080 and configuring HLS parameters. It disables daemon mode, sets up console logging, and defines a default vhost with HLS generation turned on. Dependencies include the SRS software, and the server must have available permissions for bound ports. This config is used to support streaming and segmentation for HLS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: conf\nCODE:\n```\n# conf/hls.origin.conf\\nlisten              1935;\\nmax_connections     1000;\\ndaemon              off;\\nsrs_log_tank        console;\\nhttp_server {\\n    enabled         on;\\n    listen          8080;\\n}\\nvhost __defaultVhost__ {\\n    hls {\\n        enabled         on;\\n        hls_ctx off;\\n        hls_ts_ctx off;\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Low Latency SRT Mode\nDESCRIPTION: SRS configuration for low latency SRT mode, assuming an RTT of 100ms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/srt.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    connect_timeout 4000;\n    peerlatency 300; # RTT * 3\n    recvlatency 300; # RTT * 3\n    latency 300; # RTT * 3\n    tlpktdrop on;\n    tsbpdmode on;\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming to SRS Server using FFmpeg\nDESCRIPTION: Command to push a video stream to SRS server using FFmpeg. It reads a source FLV file and streams it to the RTMP endpoint on the SRS server without re-encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/flv.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS EXEC for Stream Publishing with FFmpeg\nDESCRIPTION: Sample configuration for the SRS exec feature that demonstrates how to execute FFmpeg when a stream is published. The configuration enables automatic recording of published streams to local FLV files. It includes various stream-related variables that can be used in the exec command.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-exec.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # the exec used to fork process when got some event.\n    exec {\n        # whether enable the exec.\n        # default: off.\n        enabled     off;\n        # when publish stream, exec the process with variables:\n        #       [vhost] the input stream vhost.\n        #       [port] the intput stream port.\n        #       [app] the input stream app.\n        #       [stream] the input stream name.\n        #       [engine] the tanscode engine name.\n        # other variables for exec only:\n        #       [url] the rtmp url which trigger the publish.\n        #       [tcUrl] the client request tcUrl.\n        #       [swfUrl] the client request swfUrl.\n        #       [pageUrl] the client request pageUrl.\n        # @remark empty to ignore this exec.\n        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server for Origin Cluster (SRS Config)\nDESCRIPTION: This configuration file sets up an SRS edge server. It listens on the standard RTMP port 1935. It operates in remote cluster mode (`mode remote`) and specifies the IP addresses and ports of the origin servers (`127.0.0.1:19351` and `127.0.0.1:19350`) it should pull streams from, enabling load balancing and failover. `daemon off` keeps the server running in the foreground.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n# conf/origin.cluster.edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19351 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Converter for FLV over HTTP POST in SRS\nDESCRIPTION: Example configuration for enabling Stream Converter to handle FLV streams pushed via HTTP POST and convert them to RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/streamer.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nstream_caster {\n    enabled on;\n    caster flv;\n    output rtmp://127.0.0.1/[app]/[stream];\n    listen 8936;\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming to SRS with FFmpeg\nDESCRIPTION: Example command for using FFmpeg to stream a video file to SRS running on Windows. This sends a copy of the source video to the RTMP endpoint on the Windows host.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/windows.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ~/srs/doc/source.flv -c copy -f flv rtmp://win11/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Min-Latency Mode in SRS\nDESCRIPTION: SRS configuration snippet for enabling min-latency mode, which disables merged-read and uses timeout condition wait to reduce latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    # whether enable min delay mode for vhost.\n    # for min latence mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off\n    min_latency     off;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus YAML\nDESCRIPTION: YAML configuration for Prometheus to scrape metrics from node_exporter and SRS exporter. It defines two jobs with their respective targets and scrape intervals.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_4\n\nLANGUAGE: yml\nCODE:\n```\nscrape_configs:\n  - job_name: \"node\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9100\"]\n  - job_name: \"srs\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9972\"]\n```\n\n----------------------------------------\n\nTITLE: Dropping Video Stream and Transcoding Audio with FFMPEG in SRS (Bash)\nDESCRIPTION: Configures the SRS transcode engine with FFMPEG to drop the video stream entirely (`vcodec vn`) and transcode only the audio stream to AAC (`acodec libfdk_aac`). This results in an audio-only output stream. Requires SRS and FFMPEG.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine vn {\n            enabled         on;\n            vcodec          vn;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Encoder-Controlled ATC and Auto ATC Detection - SRS Config/Bash\nDESCRIPTION: This snippet provides an example of configuring a specific vhost in the SRS server to control auto ATC detection. The 'atc_auto' setting determines whether the server will enable ATC based on a field (e.g., 'bravo_atc' in onMetaData) from the encoder, making stream synchronization programmatically controllable by the encoder. Requires SRS; the main parameters are 'atc_auto', toggling automatic ATC detection, impacting multi-server HLS/RTMP fault tolerance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-atc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost atc.srs.com {\\n    # for play client, both RTMP and other stream clients,\\n    # for instance, the HTTP FLV stream clients.\\n    play {\\n        # whether enable the auto atc,\\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\\n        # set atc to on if matched.\\n        # always ignore the onMetaData if atc_auto is off.\\n        # default: off\\n        atc_auto        off;\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing H.265 Stream with FFmpeg (Linux)\nDESCRIPTION: FFmpeg command to publish an H.265 encoded stream over RTMP to SRS running on the same Linux host. This uses host network mode and libx265 for video encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-03-07-Lets-Do-H265-Live-Streaming.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --net=host --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: WebRTC Publishing with WHIP Protocol\nDESCRIPTION: Example of using WHIP protocol to publish WebRTC streams to SRS server. The request includes an SDP offer in the body with application/sdp content type, and the server responds with an SDP answer with HTTP status 201.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whip/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\nLANGUAGE: text\nCODE:\n```\nv=0\n......\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimum Latency in SRS\nDESCRIPTION: Configuration for enabling minimum latency mode in SRS vhost, which disables merged-read and uses timeout waiting in consumer queue to achieve lowest possible latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    # whether enable min delay mode for vhost.\n    # for min latence mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off\n    min_latency     off;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Copy with Audio Transcoding\nDESCRIPTION: Example showing how to configure SRS to copy video stream without transcoding while converting audio to AAC format. Useful for scenarios like handling h264+speex input streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting SRS Log Level\nDESCRIPTION: Configuration for setting the logging level in SRS. Supports levels from verbose to error, controlling the amount and type of information logged. Default level is trace.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# the log level, for all log tanks.\n# can be: verbose, info, trace, warn, error\n# defualt: trace\nsrs_log_level       trace;\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Slave Server (Port 1935)\nDESCRIPTION: This configuration file content (intended for `srs.1935.conf`) sets up an SRS instance to act as a slave server. It listens on port `1935`, uses a specific PID file (`./objs/srs.1935.pid`) to avoid conflicts with other instances on the same machine, sets the maximum connections, and includes a basic default vhost configuration without forwarding enabled. This instance is designed to receive streams forwarded from a master server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/forward.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.1935.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Settings in SRS\nDESCRIPTION: This configuration block defines various RTMP settings for the default vhost in SRS. It includes options for latency control, TCP configuration, chunk sizes, acknowledgment settings, publisher settings, and playback behavior. These settings affect performance, latency, stability, and compatibility with different RTMP clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # whether enable min delay mode for vhost.\n    # for min latency mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off (for RTMP/HTTP-FLV)\n    # default: on (for WebRTC)\n    min_latency off;\n\n    # whether enable the TCP_NODELAY\n    # if on, set the nodelay of fd by setsockopt\n    # Overwrite by env SRS_VHOST_TCP_NODELAY for all vhosts.\n    # default: off\n    tcp_nodelay off;\n\n    # the default chunk size is 128, max is 65536,\n    # some client does not support chunk size change,\n    # vhost chunk size will override the global value.\n    # Overwrite by env SRS_VHOST_CHUNK_SIZE for all vhosts.\n    # default: global chunk size.\n    chunk_size 128;\n    \n    # The input ack size, 0 to not set.\n    # Generally, it's set by the message from peer,\n    # but for some peer(encoder), it never send message but use a different ack size.\n    # We can chnage the default ack size in server-side, to send acknowledge message,\n    # or the encoder maybe blocked after publishing for some time.\n    # Overwrite by env SRS_VHOST_IN_ACK_SIZE for all vhosts.\n    # Default: 0\n    in_ack_size 0;\n    \n    # The output ack size, 0 to not set.\n    # This is used to notify the peer(player) to send acknowledge to server.\n    # Overwrite by env SRS_VHOST_OUT_ACK_SIZE for all vhosts.\n    # Default: 2500000\n    out_ack_size 2500000;\n    \n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # about MR, read https://github.com/ossrs/srs/issues/241\n        # when enabled the mr, SRS will read as large as possible.\n        # Overwrite by env SRS_VHOST_PUBLISH_MR for all vhosts.\n        # default: off\n        mr off;\n        # the latency in ms for MR(merged-read),\n        # the performance+ when latency+, and memory+,\n        #       memory(buffer) = latency * kbps / 8\n        # for example, latency=500ms, kbps=3000kbps, each publish connection will consume\n        #       memory = 500 * 3000 / 8 = 187500B = 183KB\n        # when there are 2500 publisher, the total memory of SRS at least:\n        #       183KB * 2500 = 446MB\n        # the recommended value is [300, 2000]\n        # Overwrite by env SRS_VHOST_PUBLISH_MR_LATENCY for all vhosts.\n        # default: 350\n        mr_latency 350;\n\n        # the 1st packet timeout in ms for encoder.\n        # Overwrite by env SRS_VHOST_PUBLISH_FIRSTPKT_TIMEOUT for all vhosts.\n        # default: 20000\n        firstpkt_timeout 20000;\n        # the normal packet timeout in ms for encoder.\n        # Overwrite by env SRS_VHOST_PUBLISH_NORMAL_TIMEOUT for all vhosts.\n        # default: 5000\n        normal_timeout 7000;\n        # whether parse the sps when publish stream.\n        # we can got the resolution of video for stat api.\n        # but we may failed to cause publish failed.\n        # @remark If disabled, HLS might never update the sps/pps, it depends on this.\n        # Overwrite by env SRS_VHOST_PUBLISH_PARSE_SPS for all vhosts.\n        # default: on\n        parse_sps on;\n        # When parsing SPS/PPS, whether try ANNEXB first. If not, try IBMF first, then ANNEXB.\n        # Overwrite by env SRS_VHOST_PUBLISH_TRY_ANNEXB_FIRST for all vhosts.\n        # default: on\n        try_annexb_first on;\n        # The timeout in seconds to disconnect publisher when idle, which means no players.\n        # Note that 0 means no timeout or this feature is disabled.\n        # Note that this feature conflicts with forward, because it disconnect the publisher stream.\n        # Overwrite by env SRS_VHOST_PUBLISH_KICKOFF_FOR_IDLE for all vhosts.\n        # default: 0\n        kickoff_for_idle 0;\n    }\n    \n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether cache the last gop.\n        # if on, cache the last gop and dispatch to client,\n        #   to enabled fast startup for client, client play immediately.\n        # if off, send the latest media data to client,\n        #   client need to wait for the next Iframe to decode and show the video.\n        # set to off if requires min delay;\n        # set to on if requires client fast startup.\n        # Overwrite by env SRS_VHOST_PLAY_GOP_CACHE for all vhosts.\n        # default: on\n        gop_cache off;\n\n        # Limit the max frames in gop cache. It might cause OOM if video stream has no IDR frame, so we limit to N\n        # frames by default. Note that it's the size of gop cache, including videos, audios and other messages.\n        # Overwrite by env SRS_VHOST_PLAY_GOP_CACHE_MAX_FRAMES for all vhosts.\n        # default: 2500\n        gop_cache_max_frames 2500;\n\n        # the max live queue length in seconds.\n        # if the messages in the queue exceed the max length,\n        # drop the old whole gop.\n        # Overwrite by env SRS_VHOST_PLAY_QUEUE_LENGTH for all vhosts.\n        # default: 30\n        queue_length 10;\n\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # @remark for full, correct timestamp only when |delta| > 250ms.\n        # @remark disabled when atc is on.\n        # Overwrite by env SRS_VHOST_PLAY_TIME_JITTER for all vhosts.\n        # default: full\n        time_jitter full;\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        #\n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # @remark when atc is on, auto off the time_jitter\n        # Overwrite by env SRS_VHOST_PLAY_ATC for all vhosts.\n        # default: off\n        atc off;\n        # whether use the interleaved/mixed algorithm to correct the timestamp.\n        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.\n        # if off, use time_jitter to correct the timestamp if required.\n        # @remark to use mix_correct, atc should on(or time_jitter should off).\n        # Overwrite by env SRS_VHOST_PLAY_MIX_CORRECT for all vhosts.\n        # default: off\n        mix_correct off;\n\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # Overwrite by env SRS_VHOST_PLAY_ATC_AUTO for all vhosts.\n        # default: off\n        atc_auto off;\n\n        # set the MW(merged-write) latency in ms.\n        # SRS always set mw on, so we just set the latency value.\n        # the latency of stream >= mw_latency + mr_latency\n        # the value recomment is [300, 1800]\n        # @remark For WebRTC, we enable pass-by-timestamp mode, so we ignore this config.\n        # default: 350 (For RTMP/HTTP-FLV)\n        # Overwrite by env SRS_VHOST_PLAY_MW_LATENCY for all vhosts.\n        # default: 0 (For WebRTC)\n        mw_latency 350;\n\n        # Set the MW(merged-write) min messages.\n        # default: 0 (For Real-Time, min_latency on)\n        # default: 1 (For WebRTC, min_latency off)\n        # default: 8 (For RTMP/HTTP-FLV, min_latency off).\n        # Overwrite by env SRS_VHOST_PLAY_MW_MSGS for all vhosts.\n        mw_msgs 8;\n\n        # the minimal packets send interval in ms,\n        # used to control the ndiff of stream by srs_rtmp_dump,\n        # for example, some device can only accept some stream which\n        # delivery packets in constant interval(not cbr).\n        # @remark 0 to disable the minimal interval.\n        # @remark >0 to make the srs to send message one by one.\n        # @remark user can get the right packets interval in ms by srs_rtmp_dump.\n        # Overwrite by env SRS_VHOST_PLAY_SEND_MIN_INTERVAL for all vhosts.\n        # default: 0\n        send_min_interval 10.0;\n        # whether reduce the sequence header,\n        # for some client which cannot got duplicated sequence header,\n        # while the sequence header is not changed yet.\n        # Overwrite by env SRS_VHOST_PLAY_REDUCE_SEQUENCE_HEADER for all vhosts.\n        # default: off\n        reduce_sequence_header on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARMv8 (aarch64)\nDESCRIPTION: Commands to cross-compile SRS for ARMv8 (aarch64) architecture using the aarch64-linux-gnu toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=aarch64-linux-gnu-\nmake\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with WebRTC Configuration\nDESCRIPTION: Docker command to run SRS server with WebRTC configuration for ultra-low latency streaming. Sets the CANDIDATE environment variable to your local IP address and configures SRS to use the rtmp2rtc.conf file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-06-15-Experience-Ultra-Low-Latency-Live-Streaming-with-OBS-WHIP.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing First RTMP Stream to Multi-Origin Setup\nDESCRIPTION: Uses FFmpeg to publish an RTMP stream (`livestream1`) from a local file to the SRS Origin cluster listening on localhost. The Linux kernel's SO_REUSEPORT implementation will distribute the incoming connection to one of the running Origin instances randomly.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream1\n```\n\n----------------------------------------\n\nTITLE: Encoding HEVC Live Stream with FFmpeg (macOS)\nDESCRIPTION: Docker command to run FFmpeg for macOS to encode a video file to HEVC and stream it to SRS via RTMP. Uses a loop to continuously stream the source file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Applying Kubernetes ConfigMap for SRS Edge Configuration (Bash)\nDESCRIPTION: This command uses a bash heredoc (`cat <<EOF ... EOF`) to pipe the YAML definition of the `srs-edge-config` ConfigMap directly into `kubectl apply -f -`. This creates or updates the ConfigMap resource in the Kubernetes cluster, making the specified `srs.conf` available for pods to mount and use.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    grace_start_wait    700;\n    grace_final_wait    800;\n    force_grace_quit    on;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-0.socs srs-origin-1.socs srs-origin-2.socs;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\nEOF\n```\n\n----------------------------------------\n\nTITLE: Running SRS with HLS Configuration using Docker (Bash)\nDESCRIPTION: This command starts an SRS instance using Docker. It runs the container in interactive mode (`-it`), removes it after exit (`--rm`), maps host port 1935 to container port 1935 (for RTMP) and host port 8080 to container port 8080 (for HTTP/HLS). It uses the `ossrs/srs:5` image and executes the SRS binary (`./objs/srs`) with the specific HLS configuration file (`conf/hls.conf`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:5 \\\n  ./objs/srs -c conf/hls.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Authentication Context Options in SRS - Bash\nDESCRIPTION: This configuration block enables HLS and activates context options for authentication (hls_ctx and hls_ts_ctx) in the __defaultVhost__ section of the SRS config. It ensures SRS tracks playback sessions and enables integration with callback systems for authentication and statistics. No external dependencies required beyond SRS; expected input is the configuration within the broader SRS config file. Output is effect on server behavior and streamed client sessions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_ctx on;\n        hls_ts_ctx on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up HTTPS Proxy as API Gateway for WebRTC\nDESCRIPTION: Docker command to run httpx-static as an HTTPS proxy, which serves as an API gateway for WebRTC signaling, SRS API, and web content, enabling secure WebRTC connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm -p 80:80 -p 443:443 ossrs/httpx:1 \\\n    ./bin/httpx-static -http 80 -https 443 -ssk ./etc/server.key -ssc ./etc/server.crt \\\n          -proxy http://$CANDIDATE:1989/sig -proxy http://$CANDIDATE:1985/rtc \\\n          -proxy http://$CANDIDATE:8080/\n```\n\n----------------------------------------\n\nTITLE: Configuring GOP-Cache in SRS\nDESCRIPTION: SRS configuration for GOP-Cache, which caches the last GOP (Group of Pictures) for immediate playback. Includes options for enabling/disabling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# the listen ports, split by space.\nlisten              1935;\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether cache the last gop.\n        # if on, cache the last gop and dispatch to client,\n        #   to enabled fast startup for client, client play immediately.\n        # if off, send the latest media data to client,\n        #   client need to wait for the next Iframe to decode and show the video.\n        # set to off if requires min delay;\n        # set to on if requires client fast startup.\n        # default: on\n        gop_cache       off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating SFU Server Communication Flow\nDESCRIPTION: ASCII diagram demonstrating the communication flow between a browser and an SFU (Selective Forwarding Unit) server, showing both signaling and media paths.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +---------+\n+    Browser     +----<--Signaling----->--+   SFU   +\n+ (like Chrome)  +----<----Media----->----+  Server +\n+----------------+                        +---------+\n```\n\n----------------------------------------\n\nTITLE: Running SRS for RTMP to WebRTC Conversion\nDESCRIPTION: Docker command to run SRS with configuration for converting RTMP streams to WebRTC playback, setting the external candidate IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTC to RTC Configuration\nDESCRIPTION: This command runs SRS in a Docker container with RTC to RTC configuration. It sets the candidate IP and uses the rtc.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring NGINX as HLS Edge Server with Cache\nDESCRIPTION: NGINX configuration for caching HLS content. Sets up proxy cache paths, cache lock settings, and separate location blocks for m3u8 playlists and ts segments with different cache durations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhttp {\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       8081;\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Graceful Quit Configuration\nDESCRIPTION: Configuration options for SRS graceful quit behavior, including waiting times and force graceful quit option. These settings control how SRS shuts down during upgrades.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# For gracefully quit, wait for a while then close listeners,\n# because K8S notify SRS with SIGQUIT and update Service simultaneously,\n# maybe there is some new connections incoming before Service updated.\n# @see https://github.com/ossrs/srs/issues/1595#issuecomment-587516567\n# default: 2300\ngrace_start_wait 2300;\n# For gracefully quit, final wait for cleanup in milliseconds.\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587414898\n# default: 3200\ngrace_final_wait 3200;\n# Whether force gracefully quit, never fast quit.\n# By default, SIGTERM which means fast quit, is sent by K8S, so we need to\n# force SRS to treat SIGTERM as gracefully quit for gray release or canary.\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587475077\n# default: off\nforce_grace_quit off;\n```\n\n----------------------------------------\n\nTITLE: Configuring Sequence Header Reduction in SRS\nDESCRIPTION: Controls whether SRS reduces duplicate sequence headers. Useful for clients that cannot handle duplicate sequence headers. When enabled, SRS will not send duplicate sequence headers if they haven't changed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether reduce the sequence header,\n        # for some client which cannot got duplicated sequence header,\n        # while the sequence header is not changed yet.\n        # default: off\n        reduce_sequence_header  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRT Server Configuration\nDESCRIPTION: Complete SRT server configuration including connection parameters, latency settings, and security options\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    maxbw 1000000000;\n    mss 1500;\n    connect_timeout 4000;\n    peer_idle_timeout 8000;\n    default_app live;\n    peerlatency 0;\n    recvlatency 0;\n    latency 0;\n    tsbpdmode off;\n    tlpktdrop off;\n    sendbuf 2000000;\n    recvbuf 2000000;\n    passphrase xxxxxxxxxxxx;\n    pbkeylen 16;\n}\nvhost __defaultVhost__ {\n    srt {\n        enabled on;\n        srt_to_rtmp on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Oryx Docker Container for WHIP Service\nDESCRIPTION: This command runs an Oryx Docker container, setting up the necessary ports and volumes for a WHIP streaming service. It maps various ports for different protocols and mounts a local directory for data persistence.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-12-12-Oryx-OBS-WHIP-Service.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTC to RTMP Configuration\nDESCRIPTION: This command runs SRS in a Docker container with RTC to RTMP configuration. It sets the candidate IP and uses the rtc2rtmp.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Options in SRS Vhost - Bash\nDESCRIPTION: This bash-style configuration snippet demonstrates how to enable HLS in a specific SRS virtual host by setting key parameters such as segment length (hls_fragment), window (hls_window), codecs, file naming templates, encryption options, and notification hooks. It specifies the directory paths, filename patterns using variables, and advanced features like encryption and segment cleanup. The configuration is to be placed in the SRS config under the relevant vhost. No external runtime dependencies are needed, but SRS must be built with HLS support. Inputs are SRS config directives; outputs are m3u8 and ts files written to the specified directories, with URLs optionally prepended by hls_entry_prefix.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether the hls is enabled.\n        # if off, do not write hls(ts and m3u8) when publish.\n        # default: off\n        enabled         on;\n        # the hls fragment in seconds, the duration of a piece of ts.\n        # default: 10\n        hls_fragment    10;\n        # the hls m3u8 target duration ratio,\n        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init\n        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts\n        # default: 1.5\n        hls_td_ratio    1.5;\n        # the audio overflow ratio.\n        # for pure audio, the duration to reap the segment.\n        # for example, the hls_fragment is 10s, hls_aof_ratio is 2.0,\n        # the segment will reap to 20s for pure audio.\n        # default: 2.0\n        hls_aof_ratio   2.0;\n        # the hls window in seconds, the number of ts in m3u8.\n        # default: 60\n        hls_window      60;\n        # the error strategy. can be:\n        #       ignore, disable the hls.\n        #       disconnect, require encoder republish.\n        #       continue, ignore failed try to continue output hls.\n        # @see https://github.com/ossrs/srs/issues/264\n        # default: continue\n        hls_on_error    continue;\n        # the hls output path.\n        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream].m3u8\n        # the ts file is configured by hls_path/hls_ts_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream]-[seq].ts\n        # @remark the hls_path is compatible with srs v1 config.\n        # default: ./objs/nginx/html\n        hls_path        ./objs/nginx/html;\n        # the hls m3u8 file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        # default: [app]/[stream].m3u8\n        hls_m3u8_file   [app]/[stream].m3u8;\n        # the hls ts file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        #       [seq], the sequence number of ts.\n        #       [duration], replace this const to current ts duration.\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#hls-config\n        # default: [app]/[stream]-[seq].ts\n        hls_ts_file     [app]/[stream]-[seq].ts;\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enhanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # default: off\n        hls_ts_floor    off;\n        # the hls entry prefix, which is base url of ts url.\n        # for example, the prefix is:\n        #         http://your-server/\n        # then, the ts path in m3u8 will be like:\n        #         http://your-server/live/livestream-0.ts\n        #         http://your-server/live/livestream-1.ts\n        #         ...\n        # optional, default to empty string.\n        hls_entry_prefix http://your-server;\n        # the default audio codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for mp3.\n        # the available audio codec:\n        #       aac, mp3, an\n        # default: aac\n        hls_acodec      aac;\n        # the default video codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for pure audio(without video) to vn.\n        # the available video codec:\n        #       h264, vn\n        # default: h264\n        hls_vcodec      h264;\n        # whether cleanup the old expired ts files.\n        # default: on\n        hls_cleanup     on;\n        # If there is no incoming packets, dispose HLS in this timeout in seconds,\n        # which removes all HLS files including m3u8 and ts files.\n        # @remark 0 to disable dispose for publisher.\n        # @remark apply for publisher timeout only, while \"etc/init.d/srs stop\" always dispose hls.\n        # default: 0\n        hls_dispose     0;\n        # the max size to notify hls,\n        # to read max bytes from ts of specified cdn network,\n        # @remark only used when on_hls_notify is config.\n        # default: 64\n        hls_nb_notify   64;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # default: on\n        hls_wait_keyframe       on;\n\n        # whether using AES encryption.\n        # default: off\n        hls_keys        on; \n        # the number of clear ts which one key can encrypt.\n        # default: 5\n        hls_fragments_per_key 5;\n        # the hls key file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [seq], the sequence number of key corresponding to the ts.\n        hls_key_file     [app]/[stream]-[seq].key;\n        # the key output path.\n        # the key file is configed by hls_path/hls_key_file, the default is:\n        # ./objs/nginx/html/[app]/[stream]-[seq].key\n        hls_key_file_path    ./objs/nginx/html;\n        # the key root URL, use this can support https.\n        # @remark It's optional.\n        hls_key_url       https://localhost:8080;\n\n        # Special control controls.\n        ###########################################\n        # Whether calculate the DTS of audio frame directly.\n        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544\n        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.\n        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.\n        # Default: on\n        hls_dts_directly on;\n\n        # on_hls, never config in here, should config in http_hooks.\n        # for the hls http callback, @see http_hooks.on_hls of vhost hooks.callback.srs.com\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#http-callback\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#http-callback\n\n        # on_hls_notify, never config in here, should config in http_hooks.\n        # we support the variables to generate the notify url:\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [param], replace with the param.\n        #       [ts_url], replace with the ts url.\n        # for the hls http callback, @see http_hooks.on_hls_notify of vhost hooks.callback.srs.com\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#on-hls-notify\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#on-hls-notify\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS with SRT Support Using Docker (Bash)\nDESCRIPTION: This snippet demonstrates how to start the SRS server with SRT protocol support using a Docker container. It maps the necessary SRS ports (1935 for RTMP, 8080 for HTTP APIs, and 10080/UDP for SRT) and launches SRS with the specified SRT configuration file. Docker must be installed on the host. Exposed ports allow clients to push or play streams via RTMP, HTTP, or SRT.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/srt.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 -p 10080:10080/udp ossrs/srs:5 \\\n  ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Creating SRS LoadBalancer Service on Kubernetes using Bash and YAML\nDESCRIPTION: This snippet uses a bash heredoc to define a Kubernetes Service configuration in YAML and applies it using `kubectl apply -f -`. The Service is of type `LoadBalancer`, which typically provisions a cloud load balancer (like SLB with EIP in ACK) to expose the SRS deployment externally. It maps external ports 1935, 1985, and 8080 to the corresponding `targetPort` on the pods matched by the `app: srs` selector. Requires `kubectl` access and potentially cloud provider integration for LoadBalancer provisioning.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Write for SRS Player\nDESCRIPTION: This configuration sets up merged-write options for the player in SRS, balancing between performance and latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    play {\n        mw_latency      350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Write for RTMP Players in SRS\nDESCRIPTION: SRS configuration for merged-write (MW) settings, which can improve write performance. This snippet shows how to set the MW latency for players.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/low-latency.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# the MW(merged-write) settings for player.\nvhost mrw.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # set the MW(merged-write) latency in ms.\n        # SRS always set mw on, so we just set the latency value.\n        # the latency of stream >= mw_latency + mr_latency\n        # the value recomment is [300, 1800]\n        # default: 350\n        mw_latency      350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Prometheus Exporter Configuration\nDESCRIPTION: Configuration block for the SRS Prometheus exporter with options for enabling the service, setting the listen port, and specifying labels and tags for categorizing cluster servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Prometheus exporter config.\n# See https://prometheus.io/docs/instrumenting/exporters\nexporter {\n    # Whether exporter is enabled.\n    # Overwrite by env SRS_EXPORTER_ENABLED\n    # Default: off\n    enabled off;\n    # The http api listen port for exporter metrics.\n    # Overwrite by env SRS_EXPORTER_LISTEN\n    # Default: 9972\n    # See https://github.com/prometheus/prometheus/wiki/Default-port-allocations\n    listen 9972;\n    # The logging label to category the cluster servers.\n    # Overwrite by env SRS_EXPORTER_LABEL\n    label cn-beijing;\n    # The logging tag to category the cluster servers.\n    # Overwrite by env SRS_EXPORTER_TAG\n    tag cn-edge;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for DASH Streaming\nDESCRIPTION: SRS configuration file for enabling DASH streaming, including HTTP server setup and DASH-specific settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-dash.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/dash.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    dash {\n        enabled         on;\n        dash_fragment       30;\n        dash_update_period  150;\n        dash_timeshift      300;\n        dash_path           ./objs/nginx/html;\n        dash_mpd_file       [app]/[stream].mpd;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for Snapshot via HttpCallback (SRS Config, Conf)\nDESCRIPTION: This configuration snippet defines SRS settings for handling RTMP streams and enabling HTTP event hooks that trigger snapshot actions. It sets up vhost, http_hooks for on_publish/on_unpublish actions, and configures the ingest engine to read from a FLV file. Requires SRS installation and FFMPEG binary at the specified path. Key parameters: HTTP callback endpoints, ingest file path, output endpoint. Inputs: RTMP stream from local file; Outputs: HTTP events for API and FFMPEG processing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/snapshot.md#2025-04-23_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\n# snapshot.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    http_hooks {\n        enabled on;\n        on_publish http://127.0.0.1:8085/api/v1/snapshots;\n        on_unpublish http://127.0.0.1:8085/api/v1/snapshots;\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker for RTMP to WebRTC Conversion\nDESCRIPTION: Starts an SRS server configured specifically to convert incoming RTMP streams to WebRTC, using `conf/rtmp2rtc.conf`. It requires setting the `CANDIDATE` environment variable with the server's IP address and maps standard ports plus the necessary UDP port 8000 for WebRTC media.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:4 ./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server for Stream Forwarding (SRS Config)\nDESCRIPTION: This configuration snippet for SRS (version 2) defines a virtual host (`__defaultVhost__`) and uses the `forward` directive. It instructs the SRS origin server to automatically push all received streams to the specified remote edge server located at `xxx:19350`. This setup is part of the 'Europe: Forward+EXEC' use case for distributing streams from an origin to an edge without requiring the edge to pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/sample.md#2025-04-23_snippet_0\n\nLANGUAGE: srs-config\nCODE:\n```\n    vhost __defaultVhost__ {\n           forward         xxx:19350;\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for Default Vhost - Bash\nDESCRIPTION: This bash configuration snippet demonstrates setting up an SRS server to listen on port 1935 and use the default vhost (__defaultVhost__). There are no additional settings inside the vhost block in this minimal example. The config enables single-customer scenarios where vhosts are not required. Requires SRS server to read this config file on startup. Expected input is a text configuration; there are no runtime parameters. Outputs a ready-to-use RTMP service using the default vhost configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Edge SRS Server with Remote Origin - Bash\nDESCRIPTION: This snippet configures an edge SRS server listening on port 1935, with a vhost demo.srs.com set to remote mode. The origin points to a remote address (shown as xxxxxxx), indicating that this server acts as an edge node fetching streams from an origin server. Required parameters: vhost name, mode (remote), and origin address. Intended for use in distributed SRS deployments; no runtime parameters, just config setup for edge/origin architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n    mode remote;\n    origin: xxxxxxx;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the specified configuration file for HLS transcoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/transcode2hls.audio.only.conf\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Basic commands to configure and build SRS from source code using the standard build system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/install.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Source Code using Git (Bash)\nDESCRIPTION: Downloads the SRS source code from the specified Git repository, checking out the '4.0release' branch. This is the initial step required before building SRS for any use case described in the document. It's recommended to perform this on Ubuntu 20.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 4.0release https://gitee.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Running SRS for Live Streaming (Bash)\nDESCRIPTION: Starts the compiled SRS server using the default configuration file 'conf/srs.conf', typically enabling standard live streaming features (RTMP, HTTP-FLV, HLS).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Coroutine-based TCP Code\nDESCRIPTION: Example showing TCP socket handling using ST coroutines, demonstrating simplified logic compared to epoll-based code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nst_netfd_t fd = st_accept(listen_fd); // Got a TCP connection\n\nint n = st_read(fd, buf, sizeof(buf));\nif (n == -1) {\n    return n; // Error.\n}\n\nprintf(\"Got %d size of data %p\", n, buf);\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Vhosts in SRS\nDESCRIPTION: This snippet demonstrates how to configure multiple vhosts in SRS for different customers (CCTV and Wasu) using the same edge server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n}\nvhost show.wasu.cn {\n}\n```\n\n----------------------------------------\n\nTITLE: HTTPS Server Configuration\nDESCRIPTION: Configuration for enabling HTTPS support in SRS, including SSL certificate and key settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-server.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    https {\n        enabled on;\n        listen 8088;\n        key ./conf/server.key;\n        cert ./conf/server.crt;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Stream Publishing to SRT\nDESCRIPTION: FFmpeg command to publish a stream using SRT protocol. Copies the input stream without transcoding and sets MPEG-TS payload size. Uses streamid parameter to specify the publishing point.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Streaming Forwarding (bash/conf)\nDESCRIPTION: Minimal SRS configuration to accept up to 10240 connections on port 1935 and forward incoming RTMP streams to nginx-rtmp for performance comparison. The 'forward' directive points to local nginx-rtmp. Config file typically named conf/srs.conf.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    forward         127.0.0.1:19350;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS3 Edge Server with EXEC for RTMP to MPEG-TS Conversion\nDESCRIPTION: This configuration snippet sets up an SRS v3 edge server listening on port 19350. It uses the `exec` directive to automatically invoke FFmpeg for every incoming RTMP stream (`publish`). The FFmpeg command converts the received RTMP stream (`rtmp://127.0.0.1:1935/[app]?vhost=[vhost]/[stream]`) into an MPEG-TS stream delivered over UDP (`udp://[stream]?localaddr=127.0.0.1&pkt_size=1316`), using the original stream name as the UDP destination address and binding to the loopback interface. The `-vbsf h264_mp4toannexb` filter is crucial for this conversion. Requires SRS compiled with `--with-ffmpeg`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_3\n\nLANGUAGE: srs_conf\nCODE:\n```\n    listen              19350;\n    max_connections     1024;\n    srs_log_tank        file;\n    srs_log_file        ./objs/srs.slave.log;\n    srs_log_level       error;\n    vhost __defaultVhost__ {\n        exec {\n            enabled     on;\n            publish     ./objs/ffmpeg/bin/ffmpeg -v quiet -re -i rtmp://127.0.0.1:1935/[app]?vhost=[vhost]/[stream] -c copy -vbsf h264_mp4toannexb -f mpegts \"udp://[stream]?localaddr=127.0.0.1&pkt_size=1316\";\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Status and Logs - Bash\nDESCRIPTION: Contains commands to check the SRS server process status and real-time logs. The './etc/init.d/srs status' script checks if the server process is running, while 'tail -n 30 -f ./objs/srs.log' shows the last 30 lines of the SRS log file and continually updates output as new entries are written.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Check the process status\n./etc/init.d/srs status\n\n# Check the SRS logs\ntail -n 30 -f ./objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Origin and Nginx Services in Kubernetes\nDESCRIPTION: This YAML configuration creates a Deployment for SRS Origin and Nginx, along with ClusterIP and LoadBalancer Services. It sets up shared volumes for HLS storage and copies default SRS files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-origin-deploy\n  labels:\n    app: srs-origin\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs-origin\n  template:\n    metadata:\n      labels:\n        app: srs-origin\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: ClusterIP\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-http-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-http-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-http-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n```\n\n----------------------------------------\n\nTITLE: Deploying Oryx with Docker - Bash\nDESCRIPTION: This Bash snippet demonstrates how to run an Oryx container instance using Docker. It maps host volumes and ports to the container, enabling HTTP, HTTPS, RTMP, WebRTC, and SRT services. The command uses flags to ensure automatic restarts, interactive terminal allocation, and proper naming. The volume mount ensures persistent data storage in '$HOME/data'. Prerequisites include Docker installed on Ubuntu 20+. Outputs include a running Oryx service accessible via http://localhost.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Configuring an SRS Edge Node Vhost in Remote Mode (Bash)\nDESCRIPTION: This snippet shows an example configuration for an SRS server acting as an edge node in a distributed setup. It listens on port 1935 and configures the `demo.srs.com` virtual host to operate in `remote` mode. This means that when a request for a stream arrives at this edge node, SRS will attempt to pull the stream from the configured `origin` server (placeholder `xxxxxxx`). This configuration is common in CDN architectures for content distribution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nRTMP URL: rtmp://demo.srs.com/live/livestream\n50\nIP192.168.1.100  192.168.1.150\nSRS\n    listen              1935;\n    vhost demo.srs.com {\n        mode remote;\n        origin: xxxxxxx;\n    }\n```\n\n----------------------------------------\n\nTITLE: Creating an SRS Deployment in Kubernetes using Bash and YAML\nDESCRIPTION: This command uses a bash heredoc to pipe a YAML configuration directly into `kubectl apply`. The YAML defines a Kubernetes Deployment named `srs-deployment`. This Deployment ensures that one replica of the `ossrs/srs:3` container image is running, exposing ports 1935 (RTMP), 1985 (HTTP API), and 8080 (HTTP-FLV/HLS). The `app: srs` label is used for selecting the pods managed by this deployment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deployment\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Traverse in SRS\nDESCRIPTION: Configuration example for implementing token traverse functionality between edge and origin servers in SRS. Shows basic setup for enabling token traverse in edge mode.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/drm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n        token_traverse  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Linux File Descriptor Limits for High-Concurrency Streaming (bash)\nDESCRIPTION: Increases the open file limit on a Linux system to support more than 1024 concurrent connections, which is essential for high concurrency in SRS/nginx-rtmp environments. Uses 'ulimit -HSn' to set the limit and 'ulimit -n' to verify. Must be executed as root before server start.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nulimit -HSn 10240\n```\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Copying Video and Transcoding Audio with FFMPEG in SRS (Bash)\nDESCRIPTION: Configures SRS to use FFMPEG for transcoding where the video stream is copied directly (`vcodec copy`) without re-encoding, while the audio stream is transcoded to AAC (`acodec libfdk_aac`). This is useful for changing audio codecs (e.g., from Speex published by Flash) while preserving video quality and reducing CPU load. Requires SRS and FFMPEG.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Ingest Configuration in Bash\nDESCRIPTION: This snippet provides a sample configuration for SRS with ingest functionality. It sets up the server to listen on port 1935 and configures an ingest stream from a local file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ingest.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    ingest livestream {\n        enabled      on;\n        input {\n            type    file;\n            url     ./doc/source.flv;\n        }\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled          off;\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FMLE for RTMP Publishing\nDESCRIPTION: Example showing how to configure Adobe Flash Media Live Encoder (FMLE) or a similar encoder to publish an RTMP stream to SRS. It demonstrates splitting the full RTMP URL (`rtmp://192.168.1.170/live/livestream`) into the 'FMS URL' (`rtmp://192.168.1.170/live`) and 'Stream' (`livestream`) fields required by the encoder.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-rtmp.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n# For RTMP url: rtmp://192.168.1.170/live/livestream\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFMPEG Tool Support (Bash)\nDESCRIPTION: Configures the SRS build system to include the FFMPEG tool integration using the '--ffmpeg-tool=on' flag and then compiles the SRS source code using 'make'. This step requires build tools (like GCC, Make) and potentially FFMPEG development libraries to be installed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Using Environment Variables for HTTP API Authentication\nDESCRIPTION: Example of enabling SRS HTTP API authentication using environment variables. This method allows setting credentials without modifying configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nenv SRS_HTTP_API_ENABLED=on SRS_HTTP_SERVER_ENABLED=on \\\n    SRS_HTTP_API_AUTH_ENABLED=on SRS_HTTP_API_AUTH_USERNAME=admin SRS_HTTP_API_AUTH_PASSWORD=admin \\\n    ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server for High Quality Mode\nDESCRIPTION: Server configuration for maximum quality SRT streaming on public networks. Disables packet dropping and timestamp-based playback delay mode to prevent any screen glitches.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    connect_timeout 4000;\n    peerlatency 0;\n    recvlatency 0;\n    latency 0;\n    tlpktdrop off;\n    tsbpdmode off;\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS for ARM Using Cross Compilation - Bash\nDESCRIPTION: Configures and builds SRS for cross-compilation targeting ARM architecture. The './configure --cross-build' sets up the build environment for ARM, followed by 'make' to build the binaries. Requires standard build toolchain, cross-compilers, and SRS source code. Outputs ARM binaries to './objs/'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build && make\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Transcoding with GOP Control\nDESCRIPTION: Example of transcoding configuration for HLS with specific GOP control to manage segment lengths. This configuration transcodes incoming streams to H.264/AAC format compatible with HLS, setting GOP to 100 frames with 20 fps.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nvhost hls.transcode.vhost.com {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine hls {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            20;\n            vwidth          768;\n            vheight         320;\n            vthreads        2;\n            vprofile        baseline;\n            vpreset         superfast;\n            vparams {\n                g           100;\n            }\n            acodec          libaacplus;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiple Stream DVR Configuration\nDESCRIPTION: Example showing how to configure DVR for multiple specific streams\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/dvr.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost xxx {\n    dvr {\n        dvr_apply live/stream1 live/stream2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Edge SRS Server Configuration - SRS Config (Bash context)\nDESCRIPTION: This configuration snippet (conf/edge.conf) establishes an SRS edge server. It sets its own port, connection limits, and log/PID locations, and demonstrates enabling SRS's 'cluster' functionality to work as an RTMP edge pointing to the origin. Dependency: a running origin SRS server. Key parameters: listen port, origin address (points to the origin server's IP and port), and cluster mode. Used as startup config for SRS edge nodes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Compiled SRS on ARMv8 Docker\nDESCRIPTION: Docker command to run the cross-compiled SRS binary on an ARMv8 (aarch64) Ubuntu Docker container.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 arm64v8/ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Accessing SRS HTTP API Root and Endpoints via Curl\nDESCRIPTION: Examples demonstrating how to use the `curl` command to interact with the SRS HTTP API. Shows requests to the root URL (`/`), the versions endpoint (`/api/v1/versions`), and the authors endpoint (`/api/v1/authors`), along with sample JSON responses.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# curl http://192.168.1.102:1985/\n    \"urls\": {\n        \"api\": \"the api root\"\n    }\n```\n\nLANGUAGE: bash\nCODE:\n```\n# curl http://192.168.1.102:1985/api/v1/versions\n        \"major\": 0,\n        \"minor\": 9,\n        \"revision\": 43,\n        \"version\": \"0.9.43\"\n```\n\nLANGUAGE: bash\nCODE:\n```\n# curl http://192.168.1.102:1985/api/v1/authors\n        \"primary_authors\": \"xxx\",\n        \"contributors_link\": \"https://github.com/ossrs/srs/blob/master/AUTHORS.txt\",\n        \"contributors\": \"xxx\"\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP-FLV Server Configuration\nDESCRIPTION: Complete configuration example for HTTP-FLV streaming including server settings and vhost configuration\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/flv.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    enabled on;\n    listen 8080;\n    crossdomain on;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled on;\n        fast_cache 30;\n        drop_if_not_match on;\n        has_audio on;\n        has_video on;\n        guess_has_av on;\n        mount [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback JSON Request and Response for on_record_end Event\nDESCRIPTION: This snippet shows the JSON structure for the on_record_end event HTTP callback request and response. It includes details like request_id, action, stream information, UUID, artifact details, and the expected response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_record_end\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"artifact_code\": 0,\n  \"artifact_path\": \"/data/record/824b96f9-8d51-4046-ba1e-a9aec7d57c95/index.mp4\",\n  \"artifact_url\": \"http://localhost/terraform/v1/hooks/record/hls/824b96f9-8d51-4046-ba1e-a9aec7d57c95/index.mp4\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Command for HEVC Streaming over SRT\nDESCRIPTION: FFmpeg command to stream HEVC encoded video over SRT protocol using MPEG-TS format. Includes settings for optimal payload size.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i source.mp4 -c:v libx265 -c:a copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Quality Value Syntax Definition in ABNF\nDESCRIPTION: Defines the syntax for quality values used in HTTP content negotiation, specifying the format for weights between 0 and 1.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_17\n\nLANGUAGE: abnf\nCODE:\n```\nqvalue         = ( \"0\" [ \".\" 0*3DIGIT ] )\n                | ( \"1\" [ \".\" 0*3(\"0\") ] )\n```\n\n----------------------------------------\n\nTITLE: SRS Ingest Configuration in Bash\nDESCRIPTION: Sample configuration file for SRS ingest functionality. It sets up the server to listen on port 1935, defines the maximum connections, and configures an ingest stream named 'livestream' that reads from a local file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ingest.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ingest.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    ingest livestream {\n        enabled      on;\n        input {\n            type    file;\n            url     ./doc/source.flv;\n        }\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled          off;\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building FFmpeg with HEVC Support\nDESCRIPTION: Commands to build FFmpeg from source with HEVC support, enabling libx264 and libx265 encoders. This uses the package config paths from previously built libraries and configures various codec options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b master https://github.com/FFmpeg/FFmpeg.git ~/git/FFmpeg\ncd ~/git/FFmpeg\nenv PKG_CONFIG_PATH=~/git/x264/build/lib/pkgconfig:~/git/x265_git/build/linux/build/lib/pkgconfig \\\n./configure \\\n  --prefix=$(pwd)/build \\\n  --enable-gpl --enable-nonfree --enable-pthreads --extra-libs=-lpthread \\\n  --disable-asm --disable-x86asm --disable-inline-asm \\\n  --enable-decoder=aac --enable-decoder=aac_fixed --enable-decoder=aac_latm --enable-encoder=aac \\\n  --enable-libx264 --enable-libx265 \\\n  --pkg-config-flags='--static'\nmake -j10\n```\n\n----------------------------------------\n\nTITLE: Configuring Transcoding for Specific App and Stream\nDESCRIPTION: This snippet demonstrates how to configure transcoding for a specific app or stream in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # applive\n    transcode live{\n    }\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # applivelivestream\n    transcode live/livestream{\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Transcoding for HLS in SRS\nDESCRIPTION: Configuration example for transcoding settings to ensure H.264+AAC/MP3 compatibility for HLS streaming. Sets GOP size to maintain small TS segment duration with specific video/audio encoding parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nvhost hls.transcode.vhost.com {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine hls {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            20;\n            vwidth          768;\n            vheight         320;\n            vthreads        2;\n            vprofile        baseline;\n            vpreset         superfast;\n            vparams {\n                g           100;\n            }\n            acodec          libaacplus;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Oryx with Docker\nDESCRIPTION: Docker command to run Oryx container with persistent data storage and port mappings for various services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARM using Make Bash\nDESCRIPTION: This command configures the SRS build system for cross-compilation targeting ARM architecture and then initiates the build process using `make`. This step is performed on the host build machine (e.g., Ubuntu). The note indicates that for direct compilation on an ARM device like RaspberryPi, the `--cross-build` flag should be omitted.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build && make\n```\n\n----------------------------------------\n\nTITLE: WebRTC Publish API Example\nDESCRIPTION: Example of WebRTC publishing API request and response using WHIP protocol with SDP content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whip/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Demand Live Streaming in SRS\nDESCRIPTION: Configuration snippet for enabling automatic disconnection of idle publishers when no viewers are connected. The kickoff_for_idle parameter sets the timeout in seconds before disconnecting a publisher with no viewers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# The timeout in seconds to disconnect publisher when idle, which means no players.\n# Note that 0 means no timeout or this feature is disabled.\n# Note that this feature conflicts with forward, because it disconnect the publisher stream.\n# Overwrite by env SRS_VHOST_PUBLISH_KICKOFF_FOR_IDLE for all vhosts.\n# default: 0\nkickoff_for_idle 0;\n```\n\n----------------------------------------\n\nTITLE: Configuring Single Domain Vhost - SRS - Bash\nDESCRIPTION: Defines a simple SRS configuration listening on port 1935 with a single vhost for 'demo.srs.com'. This basic setup illustrates how to bind RTMP traffic to a domain without providing a default vhost. If an RTMP stream's vhost does not match 'demo.srs.com', it will not be served unless a '__defaultVhost__' is defined. Used in environments with single customer or brand segregation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Traverse in SRS\nDESCRIPTION: Configuration example for setting up token traverse functionality between edge and origin servers in SRS. Enables token verification by creating a new connection to the origin server for each client verification.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/drm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n        token_traverse  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS with FFmpeg (Bash)\nDESCRIPTION: Configures the SRS build system using `./configure` with the `--ffmpeg-tool=on` flag to enable FFmpeg integration, essential for transcoding features. Subsequently, it compiles the SRS source code using `make`. This step produces the SRS executable with the necessary transcoding capabilities enabled. Requires standard build tools (like make, gcc) and likely FFmpeg development libraries.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Example URLs for Token Authentication (URL)\nDESCRIPTION: These URLs illustrate how to append a security token as a query parameter for various streaming protocols supported by SRS (RTMP, HTTP-FLV, HLS, WHIP, WHEP). SRS uses configured HTTP callbacks to pass this token to an external application server for validation, providing a robust authentication mechanism.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/drm.md#2025-04-23_snippet_1\n\nLANGUAGE: url\nCODE:\n```\nrtmp://vhost/app/stream?token=xxxx\nhttp://vhost/app/stream.flv?token=xxxx\nhttp://vhost/app/stream.m3u8?token=xxxx\nhttp://vhost/rtc/v1/whip/?app=live&stream=livestream&token=xxx\nhttp://vhost/rtc/v1/whep/?app=live&stream=livestream&token=xxx\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for HTTP-FLV\nDESCRIPTION: This configuration snippet shows the relevant settings for enabling and configuring HTTP-FLV streaming in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/flv.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    enabled on;\n    listen 8080;\n    crossdomain on;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled on;\n        fast_cache 30;\n        drop_if_not_match on;\n        has_audio on;\n        has_video on;\n        guess_has_av on;\n        mount [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Client Management using cURL\nDESCRIPTION: Examples of using cURL to interact with client management API endpoints for getting and deleting clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_11\n\nLANGUAGE: text\nCODE:\n```\ncurl -v -X GET http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\ncurl -v -X DELETE http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callbacks with Go net/http\nDESCRIPTION: This Go code snippet demonstrates a simple HTTP server using the standard `net/http` package to handle incoming SRS callback requests on the `/api/v1/streams` endpoint. It reads the JSON request body using `ioutil.ReadAll`, prints the body content to the console for debugging, and sends back a mandatory JSON response `{\"code\":0, \"msg\":\"OK\"}` with an HTTP 200 status to indicate successful processing. This response format (HTTP 200 with '0' as integer response body, though here it's JSON) is required by SRS to allow the client action (e.g., publish) to proceed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nhttp.HandleFunc(\"/api/v1/streams\", func(w http.ResponseWriter, r *http.Request) {\n    b, err := ioutil.ReadAll(r.Body)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n\n    fmt.Println(string(b))\n\n    res, err := json.Marshal(struct {\n        Code int `json:\"code\"`\n        Message string `json:\"msg\"`\n    }{\n        0, \"OK\",\n    })\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n    w.Write(res)\n})\n\n_ = http.ListenAndServe(\":8085\", nil)\n```\n\n----------------------------------------\n\nTITLE: Setting Persistent UDP Buffer Configuration in sysctl.conf\nDESCRIPTION: Configuration to add to /etc/sysctl.conf file to make UDP buffer settings persistent across system reboots. This ensures RTC performance is maintained even after system restarts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# vi /etc/sysctl.conf\n# For RTC\nnet.core.rmem_max=16777216\nnet.core.rmem_default=16777216\nnet.core.wmem_max=16777216\nnet.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: Configuring UDP Network Settings for RTC Performance\nDESCRIPTION: Shell commands to query and set kernel UDP buffer configurations for optimal RTC performance. Sets buffer sizes to 16MB.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Query the kernel configuration\nsysctl net.core.rmem_max\nsysctl net.core.rmem_default\nsysctl net.core.wmem_max\nsysctl net.core.wmem_default\n\n# Set the UDP buffer to 16MB\nsysctl net.core.rmem_max=16777216\nsysctl net.core.rmem_default=16777216\nsysctl net.core.wmem_max=16777216\nsysctl net.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Tank in SRS\nDESCRIPTION: Configuration options for specifying where SRS logs should be stored, either to console or to file. The file option requires specifying a log file path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the log tank, console or file.\n# if console, print log to console.\n# if file, write log to file. requires srs_log_file if log to file.\n# default: file.\nsrs_log_tank        file;\n```\n\n----------------------------------------\n\nTITLE: Configuring NGINX Caching for HLS Distribution\nDESCRIPTION: This NGINX configuration sets up caching for HLS m3u8 and ts files. It defines cache paths, cache keys, and validity periods for different file types.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/nginx-for-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nhttp {\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       8081;\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic SRS Server Configuration with Default Vhost\nDESCRIPTION: Simple SRS server configuration example showing basic vhost setup without specific customizations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Importing HelloWorld Dashboard to Grafana\nDESCRIPTION: Curl commands to download a HelloWorld dashboard JSON and import it into Grafana using the HTTP API. It sets up a basic dashboard for visualization.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndata=$(curl https://raw.githubusercontent.com/ossrs/srs-grafana/main/dashboards/helloworld-import.json 2>/dev/null)\ncurl -s -H \"Content-Type: application/json\" \\\n    -XPOST http://admin:12345678@localhost:3000/api/dashboards/db \\\n    --data-binary \"{\\\"dashboard\\\":${data},\\\"overwrite\\\":true,\\\"inputs\\\":[],\\\"folderId\\\":0}\"\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Server Status and Logs (Bash)\nDESCRIPTION: Provides commands to check if the SRS server process is running using the init script and to view the latest log entries for troubleshooting or monitoring. The 'status' command shows the process ID if running, and 'tail' displays the end of the log file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# SRS\n./etc/init.d/srs status\n\n# SRS\ntail -n 30 -f ./objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Coroutine-based SRT Accept\nDESCRIPTION: New implementation of SRT accept using coroutine-based approach.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsSrtListener::cycle() {\n  while (true) {\n    srs_srt_t client_srt_fd = srs_srt_socket_invalid();\n    srt_skt_->accept(&client_srt_fd);\n    \n    srt_server_->accept_srt_client(srt_fd);\n  }\n}\n\nsrs_error_t SrsSrtServer::accept_srt_client(srs_srt_t srt_fd) {\n  fd_to_resource(srt_fd, &srt_conn);\n  conn_manager_->add(srt_conn);\n  srt_conn->start();\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming with FFmpeg to SRS RTMP Server\nDESCRIPTION: FFmpeg command to push a stream to the SRS RTMP server. It reads from a source FLV file and streams it to the /live/livestream application.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/flv.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Heartbeat Feature\nDESCRIPTION: This configuration snippet shows how to enable and configure the SRS heartbeat feature within the SRS configuration file (srs.conf). It defines settings such as enabling the heartbeat (`enabled`), the interval between heartbeats (`interval`), the target URL for the heartbeat POST request (`url`), the unique device ID to report (`device_id`), and whether to include server summaries (`summaries`). Environment variable overrides for these settings are also noted.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# heartbeat to api server\n# @remark, the ip report to server, is retrieve from system stat,\n#       which need the config item stats.network.\nheartbeat {\n    # whether heartbeat is enabled.\n    # Overwrite by env SRS_HEARTBEAT_ENABLED\n    # default: off\n    enabled off;\n    # the interval seconds for heartbeat,\n    # recommend 0.3,0.6,0.9,1.2,1.5,1.8,2.1,2.4,2.7,3,...,6,9,12,....\n    # Overwrite by env SRS_HEARTBEAT_INTERVAL\n    # default: 9.9\n    interval 9.3;\n    # when startup, srs will heartbeat to this api.\n    # @remark: must be a restful http api url, where SRS will POST with following data:\n    #   {\n    #       \"device_id\": \"my-srs-device\",\n    #       \"ip\": \"192.168.1.100\"\n    #   }\n    # Overwrite by env SRS_HEARTBEAT_URL\n    # default: http://127.0.0.1:8085/api/v1/servers\n    url http://127.0.0.1:8085/api/v1/servers;\n    # the id of device.\n    # Overwrite by env SRS_HEARTBEAT_DEVICE_ID\n    device_id       \"my-srs-device\";\n    # whether report with summaries\n    # if on, put /api/v1/summaries to the request data:\n    #   {\n    #       \"summaries\": summaries object.\n    #   }\n    # @remark: optional config.\n    # Overwrite by env SRS_HEARTBEAT_SUMMARIES\n    # default: off\n    summaries off;\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Building SRS for aarch64 Using Cross Toolchain - Shell\nDESCRIPTION: This snippet cross-configures and builds the SRS server for the aarch64 architecture with the proper cross-prefix. It first runs ./configure with --cross-build and --cross-prefix set, then makes the project. Dependencies: Installed aarch64 toolchain and SRS source code. Key parameters: cross-prefix matches toolchain command names. Output is a cross-compiled SRS binary for aarch64.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n```\n./configure --cross-build --cross-prefix=aarch64-linux-gnu-\nmake\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for Transcoder Snapshot\nDESCRIPTION: This configuration sets up SRS to use Transcoder for snapshot functionality. It defines the transcode settings, including ffmpeg parameters for capturing snapshots.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    transcode {\n        enabled on;\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine snapshot {\n            enabled on;\n            iformat flv;\n            vfilter {\n                vf fps=1;\n            }\n            vcodec png;\n            vparams {\n                vframes 6;\n            }\n            acodec an;\n            oformat image2;\n            output ./objs/nginx/html/[app]/[stream]-%03d.png;\n        }\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reverse Proxying SRS with Node.js Koa and koa-proxies - JavaScript\nDESCRIPTION: JavaScript code for creating a reverse proxy server using Koa.js and koa-proxies for SRS API, WebRTC, and streaming endpoints. BodyParser and Router are included for extensibility. Proxies /api and /rtc to 1985, static and stream-like assets to 8080, and includes a basic '/' endpoint. Dependencies: koa, koa-proxies, koa-bodyparser, koa-router.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst Koa = require('koa');\nconst proxy = require('koa-proxies');\nconst BodyParser = require('koa-bodyparser');\nconst Router = require('koa-router');\n\nconst app = new Koa();\napp.use(proxy('/api/', {target: 'http://127.0.0.1:1985/'}));\napp.use(proxy('/rtc/', {target: 'http://127.0.0.1:1985/'}));\napp.use(proxy('/*/*.(flv|m3u8|ts|aac|mp3)', {target: 'http://127.0.0.1:8080/'}));\napp.use(proxy('/console/', {target: 'http://127.0.0.1:8080/'}));\napp.use(proxy('/players/', {target: 'http://127.0.0.1:8080/'}));\n\n// Start body-parser after proxies, see https://github.com/vagusX/koa-proxies/issues/55\napp.use(BodyParser());\n\n// APIs that depends on body-parser\nconst router = new Router();\nrouter.all('/', async (ctx) => {\n  ctx.body = 'Hello World';\n});\napp.use(router.routes());\n\napp.listen(3000, () => {\n  console.log(`Server start on http://localhost:3000`);\n});\n\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Built SRS in aarch64 Docker Container - Shell\nDESCRIPTION: This shell snippet runs a cross-built SRS binary for aarch64 inside an arm64v8/ubuntu Docker container, mapping network ports and the source directory. Key dependencies are a cross-built SRS binary, Docker installed, and the arm64v8/ubuntu image. Parameters include volume mappings, working directory, and port forwarding. Result is a running aarch64 SRS server in a container.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 arm64v8/ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n```\n\n----------------------------------------\n\nTITLE: WebRTC TCP with HTTPS Docker Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC over TCP and HTTPS support on port 8088.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8088:8088/tcp \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_VHOST_RTC_RTC_TO_RTMP=on \\\n  -e SRS_HTTP_API_LISTEN=8080 \\\n  -e SRS_HTTP_API_HTTPS_ENABLED=on \\\n  -e SRS_HTTP_API_HTTPS_LISTEN=8088 \\\n  -e SRS_HTTP_SERVER_HTTTPS_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8088 \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Command for Publishing Stream to RTMP with Metadata\nDESCRIPTION: FFMPEG command that converts a UDP stream to RTMP format with H.264 video and AAC audio codecs, adding service metadata and publishing to an SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n    ffmpeg -i udp://xxx:1234 -vcodec libx264 -acodec libfdk_aac \\\n      -metadata service_name=\"Channel 1\" -metadata service_provider=\"PBS\" \\\n      -f flv rtmp://xxx:1935/live/xxx:1234\n```\n\n----------------------------------------\n\nTITLE: Streaming HEVC Encoded Video via SRT using FFmpeg\nDESCRIPTION: This FFmpeg command demonstrates how to stream HEVC encoded video over SRT. It uses libx265 for video encoding and sets the MPEG-TS payload size to 0 for optimal performance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i source.mp4 -c:v libx265 -c:a copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: English Speaking Coach Prompt Configuration\nDESCRIPTION: A prompt template for configuring the GPT AI assistant to function as an English speaking coach. This prompt instructs the AI to correct grammar mistakes, typos, and factual errors while practicing spoken English with the user.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2024-01-31-Browser-Voice-Driven-GPT.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI want you to act as a spoken English teacher and improver. \nI will speak to you in English and you will reply to me in English to practice my spoken English. \nI want you to strictly correct my grammar mistakes, typos, and factual errors. \nI want you to ask me a question in your reply. \nNow let's start practicing, you could ask me a question first. \nRemember, I want you to strictly correct my grammar mistakes, typos, and factual errors.\n```\n\n----------------------------------------\n\nTITLE: Setting Up Edge Server with Remote Origin Vhost - SRS - Bash\nDESCRIPTION: Configures an SRS edge server to listen on port 1935 and to serve the 'demo.srs.com' vhost, running in 'remote' mode and connecting to an upstream origin server (value hidden as 'xxxxxxx'). This is used in scalable deployments where multiple edge servers reference the same origin, enabling DNS-based routing for RTMP streams. Prerequisites: SRS configured as edge; main parameters: 'mode remote' and 'origin'. Vhost is isolated to 'demo.srs.com' domain for targeted user routing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n    mode remote;\n    origin: xxxxxxx;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Setting Candidate IP and Running SRS with HTTPS for WebRTC - Bash\nDESCRIPTION: Initializes the CANDIDATE variable and runs the SRS server with the 'https.rtc.conf' configuration, enabling secure (HTTPS) WebRTC functionality. Ensures correct IP address configuration for ICE protocol and requires proper HTTPS certificates/keys as referenced in SRS documentation. Best suited for remote/mobile access scenarios.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/https.rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Applying Transcoding to All Streams in an App - Bash Configuration\nDESCRIPTION: This snippet shows how to apply the SRS transcoding feature to all streams within a specific application (\"live\"). It must be included in the SRS configuration file within the correct vhost context. The configuration block for the 'transcode live' directive can further be customized as needed, but as shown, it serves as a template to hook all streams of the 'live' app for transcoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode all streams of app \"live\"\n    transcode live {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding HEVC Live Stream with FFmpeg (Linux)\nDESCRIPTION: Docker command to run FFmpeg for Linux to encode a video file to HEVC and stream it to SRS via RTMP. Uses network host mode to access the local SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# For linux\ndocker run --net=host --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Defining SRS Edge Server - Bash Minimal Configuration\nDESCRIPTION: This snippet gives a minimal configuration for an SRS edge server, which is set up to relay streams from a specified origin on port 19350. Dependencies include the SRS software and a running origin server; save this as 'edge.conf' or similar. Parameters include 'listen' (port to accept edge clients), 'pid', and 'srs_log_file'. The vhost's 'cluster' block sets 'mode' to remote and 'origin' to the local origin; expected usage is in edge CDN clusters with SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/edge.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing FLV Stream with FFmpeg via Docker\nDESCRIPTION: Uses the `ossrs/srs:encoder` Docker image, which contains FFmpeg, to publish a local file (`doc/source.flv`) as an RTMP stream. The stream loops indefinitely (`-stream_loop -1`) and is sent to the SRS server running on the Docker host (`rtmp://host.docker.internal/live/livestream`). This command is useful when publishing from within another container or environment where direct host access is needed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Handling SRS API JSON Error Codes with Curl\nDESCRIPTION: An example `curl` command showing an API request that returns an HTTP 200 OK status but includes an error code (`\"code\":100`) within the JSON response body. This illustrates the second method SRS uses to report errors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwinlin:~ winlin$ curl -v http://127.0.0.1:1985/api/v1/tests/errors && echo \"\"\n< HTTP/1.1 200 OK\n< Connection: Keep-Alive\n< Content-Length: 12\n< Content-Type: application/json\n< Server: SRS/2.0.184\n< \n{\"code\":100}\n```\n\n----------------------------------------\n\nTITLE: HLS Live M3U8 Playlist Example\nDESCRIPTION: Example of a live HLS m3u8 playlist format showing segment duration and sequence information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_9\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:YES\n#EXT-X-TARGETDURATION:13\n#EXT-X-MEDIA-SEQUENCE:430\n#EXTINF:11.800\nnews-430.ts\n#EXTINF:10.120\nnews-431.ts\n#EXTINF:11.160\nnews-432.ts\n```\n\n----------------------------------------\n\nTITLE: Pushing HEVC Stream over RTMP Using Locally Built FFmpeg - Bash\nDESCRIPTION: This snippet demonstrates how to use a custom-built FFmpeg binary to stream a local FLV file in a loop, leveraging x265 encoding and copying the audio, then sending it to an RTMP endpoint on SRS. Assumes previous successful build of FFmpeg with libx265 support and access to the media file and SRS. Inputs: source.flv path; Output: Live HEVC stream to the SRS server. Designed for testing or high-availability streaming scenarios.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./ffmpeg -stream_loop -1 -re -i ~/srs/doc/source.flv -acodec copy -vcodec libx265 \\\n  -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Demand Live Streaming Timeout in SRS\nDESCRIPTION: Configuration snippet for enabling automatic disconnection of publishers when there are no active players. This setting is useful for on-demand live streaming scenarios where publishers should automatically stop streaming when viewers are no longer watching.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# The timeout in seconds to disconnect publisher when idle, which means no players.\n# Note that 0 means no timeout or this feature is disabled.\n```\n\n----------------------------------------\n\nTITLE: Configuring NGINX as HLS Edge Cache - NGINX Conf\nDESCRIPTION: This snippet is a sample NGINX config file customized as an HLS edge server for SRS. It defines multiple worker processes, proxy cache handling, and routing rules for .m3u8 and .ts HLS assets, proxying them from the SRS origin server at localhost:8080. Dependencies include a properly installed and executable version of NGINX, and the SRS origin must be running. Configuration expects HLS assets to be generated by the SRS origin and optimizes caching for high concurrent access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: nginx\nCODE:\n```\n# conf/hls.edge.conf\\nworker_processes  3;\\nevents {\\n    worker_connections  10240;\\n}\\n\\nhttp {\\n    # For Proxy Cache.\\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\\n    proxy_temp_path /tmp/nginx-cache/tmp; \\n\\n    server {\\n        listen       8081;\\n        # For Proxy Cache.\\n        proxy_cache_valid  404      10s;\\n        proxy_cache_lock on;\\n        proxy_cache_lock_age 300s;\\n        proxy_cache_lock_timeout 300s;\\n        proxy_cache_min_uses 1;\\n\\n        location ~ /.+/.*\\\\.(m3u8)$ {\\n            proxy_pass http://127.0.0.1:8080$request_uri;\\n            # For Proxy Cache.\\n            proxy_cache srs_cache;\\n            proxy_cache_key $scheme$proxy_host$uri$args;\\n            proxy_cache_valid  200 302  10s;\\n        }\\n        location ~ /.+/.*\\\\.(ts)$ {\\n            proxy_pass http://127.0.0.1:8080$request_uri;\\n            # For Proxy Cache.\\n            proxy_cache srs_cache;\\n            proxy_cache_key $scheme$proxy_host$uri;\\n            proxy_cache_valid  200 302  60m;\\n        }\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting SRS Edge Pods and Connections (Bash)\nDESCRIPTION: This set of bash commands uses `kubectl` to inspect the state of the SRS edge deployment pods. `kubectl get po|grep edge` lists the running edge pods. `kubectl exec <pod-name> -- ./objs/srs -v` checks the SRS version inside a specific pod. `kubectl exec <pod-name> -- yum install -y net-tools` installs network utility tools within the pod (requires appropriate permissions and base image). `kubectl exec <pod-name> -- netstat -anp|grep 1935` checks for active network connections on the RTMP port (1935) within the pod, helping to identify which pod is handling the active stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get po|grep edge\nsrs-edge-deploy-58d9999b7c-pnr2f       1/1     Running   0          16s\nsrs-edge-deploy-58d9999b7c-z9gbm       1/1     Running   0          16s\n\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- ./objs/srs -v\n4.0.5\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- yum install -y net-tools\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- netstat -anp|grep 1935\ntcp        0      0 0.0.0.0:1935            0.0.0.0:*               LISTEN      1/./objs/srs\n\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- ./objs/srs -v\n4.0.5\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- yum install -y net-tools\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- netstat -anp|grep 1935\ntcp        0      0 0.0.0.0:1935            0.0.0.0:*               LISTEN      1/./objs/srs\ntcp        0      0 172.20.0.62:46482       172.20.0.41:1935        ESTABLISHED 1/./objs/srs\ntcp        0      0 172.20.0.62:1935        172.20.0.1:12066        ESTABLISHED 1/./objs/srs\n```\n\n----------------------------------------\n\nTITLE: NGINX Cache Configuration for HLS\nDESCRIPTION: Core NGINX configuration that sets up caching for HLS streams, including cache paths, proxy settings and location blocks for m3u8 and ts files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/nginx-for-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhttp {\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       8081;\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS3 Edge Server with FFMPEG Exec for Protocol Conversion\nDESCRIPTION: Configuration for SRS3 edge server that uses the 'exec' feature to run FFMPEG for each incoming RTMP stream, converting it to UDP MPEGTS format for local consumption.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample.md#2025-04-23_snippet_3\n\nLANGUAGE: conf\nCODE:\n```\n    listen              19350;\n    max_connections     1024;\n    srs_log_tank        file;\n    srs_log_file        ./objs/srs.slave.log;\n    srs_log_level       error;\n    vhost __defaultVhost__ {\n        exec {\n            enabled     on;\n            publish     ./objs/ffmpeg/bin/ffmpeg -v quiet -re -i rtmp://127.0.0.1:1935/[app]?vhost=[vhost]/[stream] -c copy -vbsf h264_mp4toannexb -f mpegts \"udp://[stream]?localaddr=127.0.0.1&pkt_size=1316\";\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: SRS HEVC Architecture Overview\nDESCRIPTION: Diagram showing SRS's architecture for supporting H.265 (HEVC) streaming from FFmpeg to browsers through various protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nFFmpeg --RTMP(h.265)---> SRS ----RTMP/FLV/TS/HLS/WebRTC(h.265)--> Chrome/Safari\n```\n\n----------------------------------------\n\nTITLE: Running SRS with Default Configuration\nDESCRIPTION: Command to run the compiled SRS binary with a console configuration file. This demonstrates how to start SRS after compilation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Multicast Stream to SRS Origin using FFmpeg (Bash)\nDESCRIPTION: This FFmpeg command reads a UDP multicast stream (`udp://xxx:1234`), transcodes the video to H.264 (`libx264`) and audio to AAC (`libfdk_aac`), adds metadata, and publishes the resulting stream in FLV format over RTMP to the SRS origin server at `rtmp://xxx:1935/live/xxx:1234`. The RTMP stream name `xxx:1234` corresponds to the original multicast group, relevant for later processing on the edge server in the 'Europe: Forward+EXEC' example.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/sample.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n    ffmpeg -i udp://xxx:1234 -vcodec libx264 -acodec libfdk_aac \\\n      -metadata service_name=\"Channel 1\" -metadata service_provider=\"PBS\" \\\n      -f flv rtmp://xxx:1935/live/xxx:1234\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server for Cluster Setup\nDESCRIPTION: Example configuration for an SRS edge server in a cluster setup. This defines the edge server's connection to the origin server, using the standard RTMP port and appropriate logging.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/edge.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Ingest with FFMPEG\nDESCRIPTION: Configuration example showing how to set up media ingestion in SRS using FFMPEG. Includes settings for input sources, transcoding options, and output stream configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # ingest file/stream/device then push to SRS over RTMP.\n    # the name/id used to identify the ingest, must be unique in global.\n    # ingest id is used in reload or http api management.\n    ingest livestream {\n        # whether enabled ingest features\n        # default: off\n        enabled      on;\n        # input file/stream/device\n        # @remark only support one input.\n        input {\n            # the type of input.\n            # can be file/stream/device, that is,\n            #   file: ingest file specifies by url.\n            #   stream: ingest stream specifeis by url.\n            #   device: not support yet.\n            # default: file\n            type    file;\n            # the url of file/stream.\n            url     ./doc/source.flv;\n        }\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine, @see all.transcode.srs.com\n        # @remark, the output is specified following.\n        engine {\n            # @see enabled of transcode engine.\n            # if disabled or vcodec/acodec not specified, use copy.\n            # default: off.\n            enabled          off;\n            # output stream. variables:\n            # [vhost] current vhost which start the ingest.\n            # [port] system RTMP stream port.\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing UDP Connectivity with Netcat\nDESCRIPTION: A command using netcat (nc) to send a STUN packet to the SRS WebRTC UDP server and verify the response. This helps troubleshoot UDP connectivity issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\necho -en \"\\x00\\x01\\x00\\x50\\x21\\x12\\xa4\\x42\\x74\\x79\\x6d\\x7a\\x41\\x51\\x2b\\x2f\\x4a\\x4b\\x77\\x52\\x00\\x06\\x00\\x0d\\x36\\x70\\x6b\\x31\\x31\\x33\\x38\\x36\\x3a\\x4a\\x38\\x58\\x37\\x00\\x00\\x00\\xc0\\x57\\x00\\x04\\x00\\x01\\x00\\x0a\\x80\\x2a\\x00\\x08\\xda\\xad\\x1d\\xce\\xe8\\x95\\x5a\\x83\\x00\\x24\\x00\\x04\\x6e\\x7f\\x1e\\xff\\x00\\x08\\x00\\x14\\x56\\x8f\\x1e\\x1e\\x4f\\x5f\\x17\\xf9\\x2e\\xa1\\xec\\xbd\\x51\\xd9\\xa2\\x27\\xe4\\xfd\\xda\\xb1\\x80\\x28\\x00\\x04\\x84\\xd3\\x5a\\x79\" \\\n  |nc -w 3 -u 127.0.0.1 8000 |od -Ax -c -t x1 |grep '000' && \\\n  echo \"Success\" || echo \"Failed\"\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Protocol Version and Status Code Pattern in BNF\nDESCRIPTION: Format pattern for the HTTP protocol version and status code that appears at the beginning of a Full-Response message.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_23\n\nLANGUAGE: BNF\nCODE:\n```\n\"HTTP/\" 1*DIGIT \".\" 1*DIGIT SP 3DIGIT SP\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Hooks for HLS Notifications in SRS\nDESCRIPTION: Sets up HTTP callbacks that trigger when SRS creates a new HLS TS file. This can be used to push files to CDN networks by making HTTP GET requests. Variables [app], [stream], and [ts_url] are replaced with the actual values when the hook is triggered.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    http_hooks {\n        # when srs reap a ts file of hls, call this hook,\n        # used to push file to cdn network, by get the ts file from cdn network.\n        # so we use HTTP GET and use the variable following:\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [ts_url], replace with the ts url.\n        # ignore any return data of server.\n        # @remark random select a url to report, not report all.\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing H.265 Stream with FFmpeg (macOS)\nDESCRIPTION: FFmpeg command to publish an H.265 encoded stream over RTMP to SRS running in Docker on macOS. This uses a looped input file and libx265 for video encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-03-07-Lets-Do-H265-Live-Streaming.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Building SRS with HTTP API Support\nDESCRIPTION: Commands to build SRS with HTTP API support enabled\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG Transcoding with GOP Settings for HLS\nDESCRIPTION: Configuration example showing how to set up transcoding with specific GOP settings to control HLS segment length. This configuration includes video and audio encoding parameters with a GOP size of 100 frames at 20 FPS, resulting in 5-second segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nvhost hls.transcode.vhost.com {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine hls {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            20;\n            vwidth          768;\n            vheight         320;\n            vthreads        2;\n            vprofile        baseline;\n            vpreset         superfast;\n            vparams {\n                g           100;\n            }\n            acodec          libaacplus;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx Proxy Cache for HLS in aaPanel\nDESCRIPTION: Nginx configuration for aaPanel that sets up proxy caching for HLS streaming. It includes cache path settings, server block configuration, and specific location directives for caching m3u8 playlist files (10s cache) and ts media segments (60m cache).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       80;\n        server_name your.domain.com;\n\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: WebRTC Publisher and Player Integration for Host A\nDESCRIPTION: WordPress shortcode configuration for the first host (Host A) in a WebRTC video chat. This creates a page with both publishing capability for Host A's stream and viewing capability for Host B's stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-06-30-Video-Chat-Live.md#2025-04-23_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n[srs_publisher url=\"webrtc://your-server-ip/live/stream-a\"]\n[srs_player url=\"webrtc://your-server-ip/live/stream-b\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Converter for MPEG-TS over UDP in SRS\nDESCRIPTION: Example configuration for enabling Stream Converter to handle MPEG-TS streams over UDP and convert them to RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/streamer.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nstream_caster {\n    enabled on;\n    caster mpegts_over_udp;\n    output rtmp://127.0.0.1/live/livestream;\n    listen 8935;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring TS Segment URL Prefix in HLS - Bash\nDESCRIPTION: This snippet demonstrates using hls_entry_prefix to prepend a base URL to each generated TS segment URL in the generated m3u8 playlist, which is particularly useful for CDN or multi-server HLS setups. By setting this parameter, you can make TS URLs absolute and fully qualified. Add it to the hls section in the SRS configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nhls_entry_prefix http://your-server;\n```\n\n----------------------------------------\n\nTITLE: Configuring the Edge Server\nDESCRIPTION: Configuration for the edge server that pulls streams from the origin servers. This edge server connects to both origin servers for redundancy.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19351 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Origin HLS Configuration\nDESCRIPTION: Configuration file for SRS origin server to enable HLS streaming with HTTP server support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-hls-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/hls.origin.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nhttp_server {\n    enabled         on;\n    listen          8080;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_ctx off;\n        hls_ts_ctx off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS VHost ATC Configuration\nDESCRIPTION: Configuration example for enabling ATC in SRS server's virtual host settings. Shows how to configure ATC for RTMP and HTTP FLV stream clients with detailed explanations in comments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-atc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        #\n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # default: off\n        atc             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server for HTTP-FLV Cluster (SRS Config)\nDESCRIPTION: Defines the configuration for an SRS edge server, like `conf/http.flv.live.edge1.conf`. It listens for RTMP on a different port (19351), specifies unique PID and log files, enables an HTTP server on port 8081, sets the mode to `remote`, specifies the origin server's IP (127.0.0.1 points to localhost in this example), and enables HTTP-FLV remuxing. HSTRS is enabled. This configuration allows the edge server to pull streams from the origin.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.flv.live.edge1.conf\nlisten              19351;\nmax_connections     1000;\npid                 objs/srs.flv.19351.pid;\nsrs_log_file        objs/srs.flv.19351.log;\nhttp_server {\n    enabled         on;\n    listen          8081;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    mode remote;\n    origin 127.0.0.1;\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC in SRS for RTMP Stream Playback\nDESCRIPTION: SRS configuration example for enabling Absolute Time Control (ATC) which allows RTMP streams to use absolute timestamps instead of starting from zero. This is essential for implementing HLS/HDS failover mechanisms across multiple servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/rtmp-atc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        # \n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # default: off\n        atc             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reverse Proxy Authentication Pattern for SRS 4.0\nDESCRIPTION: Network flow diagram showing how to implement authentication for SRS 4.0 using Nginx as a reverse proxy with authentication.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nBrowser ---HTTP-with-Authentication---> Nginx ---HTTP---> SRS 4.0\n```\n\n----------------------------------------\n\nTITLE: Checking Kubernetes Cluster Information using Bash\nDESCRIPTION: This command checks and displays information about the Kubernetes cluster endpoint and services. It's used as a prerequisite step to ensure `kubectl` is configured and can communicate with the target K8s cluster before attempting deployments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkubectl cluster-info\n```\n\n----------------------------------------\n\nTITLE: SRS Heartbeat Configuration\nDESCRIPTION: Configuration settings for enabling and customizing the SRS heartbeat feature including intervals, URL endpoints, and device identification.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# heartbeat to api server\n# @remark, the ip report to server, is retrieve from system stat,\n#       which need the config item stats.network.\nheartbeat {\n    # whether heartbeat is enabled.\n    # Overwrite by env SRS_HEARTBEAT_ENABLED\n    # default: off\n    enabled off;\n    # the interval seconds for heartbeat,\n    # recommend 0.3,0.6,0.9,1.2,1.5,1.8,2.1,2.4,2.7,3,...,6,9,12,....\n    # Overwrite by env SRS_HEARTBEAT_INTERVAL\n    # default: 9.9\n    interval 9.3;\n    # when startup, srs will heartbeat to this api.\n    # @remark: must be a restful http api url, where SRS will POST with following data:\n    #   {\n    #       \"device_id\": \"my-srs-device\",\n    #       \"ip\": \"192.168.1.100\"\n    #   }\n    # Overwrite by env SRS_HEARTBEAT_URL\n    # default: http://127.0.0.1:8085/api/v1/servers\n    url http://127.0.0.1:8085/api/v1/servers;\n    # the id of device.\n    # Overwrite by env SRS_HEARTBEAT_DEVICE_ID\n    device_id       \"my-srs-device\";\n    # whether report with summaries\n    # if on, put /api/v1/summaries to the request data:\n    #   {\n    #       \"summaries\": summaries object.\n    #   }\n    # @remark: optional config.\n    # Overwrite by env SRS_HEARTBEAT_SUMMARIES\n    # default: off\n    summaries off;\n}\n```\n\n----------------------------------------\n\nTITLE: App-Level Transcoding Configuration\nDESCRIPTION: Configuration example showing how to apply transcoding settings at the application level within SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode all streams of app \"live\"\n    transcode live {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS HLS Transcoding Configuration\nDESCRIPTION: Configuration file for SRS server that sets up HLS delivery and transcoding settings with FFMPEG.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/transcode2hls.audio.only.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting node_exporter for Host Metrics\nDESCRIPTION: This Docker command starts the node_exporter to collect host metrics, which can be combined with SRS metrics for comprehensive monitoring.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 9100:9100 prom/node-exporter\n```\n\n----------------------------------------\n\nTITLE: Configuring GOP Cache Settings in SRS\nDESCRIPTION: Configuration for GOP (Group of Pictures) cache settings in SRS, controlling whether to cache the last GOP for immediate playback.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    play {\n        gop_cache       off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: RTMP Stream Publishing Using FFMPEG - Bash\nDESCRIPTION: This Bash loop publishes a stream to the RTMP edge server using FFMPEG. It endlessly replays a source FLV file as a live RTMP stream at regular intervals, which is useful for testing or demonstration purposes. Prerequisites: FFMPEG built in the objs/ffmpeg/bin directory and a source FLV file at ./doc/source.flv. Key parameters: input file and RTMP destination URL. Outputs: continuous RTMP stream; input is static test file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source - Bash\nDESCRIPTION: This code configures and compiles the SRS server. Running ./configure detects system dependencies and requirements, and make then compiles the server and binaries. Prerequisites include essential development tools (e.g., gcc, make) and any libraries required by SRS. It produces the SRS binaries available in the output directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-dash.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with HTTP FLV Configuration - Bash Command - Bash\nDESCRIPTION: This command starts the SRS server with a configuration tailored to accept FLV streams over HTTP POST (conf/push.flv.conf). Used for scenarios where mobile or other devices POST FLV directly. Requires SRS to be built and the specified configuration file to be present at startup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/streamer.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/push.flv.conf\n```\n\n----------------------------------------\n\nTITLE: Starting Grafana in Docker\nDESCRIPTION: Docker command to start Grafana with custom environment variables for setting the admin username, password, and default theme. It exposes Grafana on port 3000.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 3000:3000 \\\n  -e GF_SECURITY_ADMIN_USER=admin \\\n  -e GF_SECURITY_ADMIN_PASSWORD=12345678 \\\n  -e GF_USERS_DEFAULT_THEME=light \\\n  grafana/grafana\n```\n\n----------------------------------------\n\nTITLE: Running the Compiled SRS Server\nDESCRIPTION: Executes the compiled SRS binary located in the `objs` directory. The `-c` flag specifies the configuration file (`conf/console.conf`) to use, which typically sets up basic console logging and default ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callback in PHP - PHP\nDESCRIPTION: This PHP snippet demonstrates how to process an SRS HTTP callback (e.g., on_publish). It reads and decodes the JSON request body from php://input, prints the entire decoded body, and returns a JSON response {code:0, msg:'OK'} as required by SRS. The implementation relies on the built-in json_decode and json_encode functions. No external dependencies are required other than PHP itself, and it must be run in a suitable web server environment capable of receiving POST requests at the relevant endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n$body = json_decode(file_get_contents('php://input'));\nprintf($body);\n\necho json_encode(array(\"code\"=>0, \"msg\"=>\"OK\"));\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS repository from GitHub.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: HDS Configuration in SRS\nDESCRIPTION: Example configuration for enabling HDS in SRS, including settings for fragment duration, window size, and output path. Similar structure to HLS configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/delivery-hds.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hds {\n        # whether hds enabled\n        # default: off\n        enabled         on;\n        # the hds fragment in seconds.\n        # default: 10\n        hds_fragment    10;\n        # the hds window in seconds, erase the segment when exceed the window.\n        # default: 60\n        hds_window      60;\n        # the path to store the hds files.\n        # default: ./objs/nginx/html\n        hds_path        ./objs/nginx/html;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Stream Mixing Command\nDESCRIPTION: FFmpeg command to mix two RTMP streams with overlay positioning and audio mixing. Configures video scaling, overlay positioning, and output encoding parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -f flv -i rtmp://192.168.3.6/live/alice -f flv -i rtmp://192.168.3.6/live/314d0336 \\\n     -filter_complex \"[1:v]scale=w=96:h=72[ckout];[0:v][ckout]overlay=x=W-w-10:y=H-h-10[out]\" -map \"[out]\" \\\n     -c:v libx264 -profile:v high -preset medium \\\n     -filter_complex amix -c:a aac \\\n     -f flv rtmp://192.168.3.6/live/merge\n```\n\n----------------------------------------\n\nTITLE: Master SRS Server Configuration\nDESCRIPTION: Configuration file for the master SRS server that forwards streams to the slave. Sets up listening port 1935 and forwards to port 19350.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-forward.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/forward.master.conf\nlisten              1935;\nmax_connections     1000;\npid                 ./objs/srs.master.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.master.log;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running httpx-static for HTTPS and WSS Protocol Conversion\nDESCRIPTION: Docker command to start httpx-static which handles the HTTPS and WSS protocol conversion. Maps HTTP and HTTPS ports and sets up proxying to the signaling, WebRTC, and HTTP services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm -p 80:80 -p 443:443 registry.cn-hangzhou.aliyuncs.com/ossrs/httpx:1 \\\n    ./bin/httpx-static -http 80 -https 443 -ssk ./etc/server.key -ssc ./etc/server.crt \\\n          -proxy http://$CANDIDATE:1989/sig -proxy http://$CANDIDATE:1985/rtc \\\n          -proxy http://$CANDIDATE:8080/\n```\n\n----------------------------------------\n\nTITLE: HTTP API Configuration with Authentication\nDESCRIPTION: Configuration example for enabling HTTP API authentication with username and password.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.api.auth.conf\nhttp_api {\n    enabled on;\n    listen 1985;\n    auth {\n        enabled on;\n        username admin;\n        password admin;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Playing HEVC Video Stream with FFplay over SRT\nDESCRIPTION: FFplay command for playing HEVC encoded video stream over SRT protocol. Uses the streamid parameter to specify request mode for playback.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::h=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Monitoring SRS Edge Pod Logs During Rolling Update (Bash)\nDESCRIPTION: These commands use `kubectl exec` to tail the SRS logs (`objs/srs.log`) inside the specific pods being replaced during the rolling update (`srs-edge-deploy-58d9999b7c-pnr2f` and `srs-edge-deploy-58d9999b7c-z9gbm`). The logs show the graceful shutdown process being triggered (SIGQUIT/SIGTERM received, force gracefully quit enabled), connection cleanup, and eventual pod termination (exit code 137). The pod with active connections (`z9gbm`) takes longer to terminate as it waits for connections to close.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- tail -f objs/srs.log\n[2020-02-19 11:07:20.818][Trace][1][937] sig=3, user start gracefully quit\n[2020-02-19 11:07:20.960][Trace][1][937] force gracefully quit, signo=15\n[2020-02-19 11:07:21.772][Trace][1][932] cleanup for quit signal fast=0, grace=1\n[2020-02-19 11:07:21.772][Warn][1][932][11] main cycle terminated, system quit normally.\ncommand terminated with exit code 137\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- tail -f objs/srs.log\n[2020-02-19 11:07:23.095][Trace][1][1009] sig=3, user start gracefully quit\n[2020-02-19 11:07:23.316][Trace][1][1009] force gracefully quit, signo=15\n[2020-02-19 11:07:23.784][Trace][1][1004] cleanup for quit signal fast=0, grace=1\n[2020-02-19 11:07:23.784][Warn][1][1004][11] main cycle terminated, system quit normally.\n[2020-02-19 11:07:24.784][Trace][1][1004] wait for 1 conns to quit\n[2020-02-19 11:07:26.968][Trace][1][1010] <- CPB time=120041497, okbps=0,0,0, ikbps=252,277,0, mr=0/350, p1stpt=20000, pnt=5000\n[2020-02-19 11:08:26.791][Trace][1][1004] wait for 1 conns to quit\n[2020-02-19 11:08:52.602][Trace][1][1010] edge change from 200 to state 0 (init).\n[2020-02-19 11:08:52.792][Trace][1][1004] wait for 0 conns to quit\ncommand terminated with exit code 137\n```\n\n----------------------------------------\n\nTITLE: Configuring Origin Server in SRS RTMP Cluster\nDESCRIPTION: This snippet demonstrates the configuration for an origin server in the SRS RTMP cluster. It specifies the listening port, PID file location, and log file path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/edge.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              19350;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Multiple SRS Instances Listening on Same Port\nDESCRIPTION: These commands verify that multiple SRS processes are running and both are listening on the same TCP port (macromedia-fcs, default 1935). `ps aux` lists processes, and `lsof -p` shows open files and ports for specific process IDs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n[root@bf2e88b31f9b trunk]# ps aux|grep srs\nroot       381  0.1  0.0  19888  5752 pts/2    S+   08:03   0:01 ./objs/srs -c conf/edge.conf\nroot       383  0.0  0.0  19204  5468 pts/1    S+   08:04   0:00 ./objs/srs -c conf/edge2.conf\n\n[root@bf2e88b31f9b trunk]# lsof -p 381\nsrs     381 root    7u     IPv6  18835      0t0        TCP *:macromedia-fcs (LISTEN)\n[root@bf2e88b31f9b trunk]# lsof -p 383\nsrs     383 root    7u     IPv6  17831      0t0        TCP *:macromedia-fcs (LISTEN)\n```\n\n----------------------------------------\n\nTITLE: Enabling Token Traversal in SRS Edge Cluster (bash)\nDESCRIPTION: This configuration snippet shows how to enable token traversal for an SRS edge server within a cluster setup. When `token_traverse` is set to `on` within the `cluster` directive of a `vhost` configured in `remote` (edge) mode, the edge server will forward authentication tokens received from clients to the specified `origin` server (127.0.0.1:19350 in this example) for validation before allowing the connection. This allows the origin server to handle the authentication logic centrally.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/drm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n        token_traverse  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: UDP Connection Testing with NetCat\nDESCRIPTION: NetCat command to test UDP connectivity by sending STUN packets to SRS WebRTC server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\necho -en \"\\x00\\x01\\x00\\x50\\x21\\x12\\xa4\\x42\\x74\\x79\\x6d\\x7a\\x41\\x51\\x2b\\x2f\\x4a\\x4b\\x77\\x52\\x00\\x06\\x00\\x0d\\x36\\x70\\x6b\\x31\\x31\\x33\\x38\\x36\\x3a\\x4a\\x38\\x58\\x37\\x00\\x00\\x00\\xc0\\x57\\x00\\x04\\x00\\x01\\x00\\x0a\\x80\\x2a\\x00\\x08\\xda\\xad\\x1d\\xce\\xe8\\x95\\x5a\\x83\\x00\\x24\\x00\\x04\\x6e\\x7f\\x1e\\xff\\x00\\x08\\x00\\x14\\x56\\x8f\\x1e\\x1e\\x4f\\x5f\\x17\\xf9\\x2e\\xa1\\xec\\xbd\\x51\\xd9\\xa2\\x27\\xe4\\xfd\\xda\\xb1\\x80\\x28\\x00\\x04\\x84\\xd3\\x5a\\x79\" \\\n  |nc -w 3 -u 127.0.0.1 8000 |od -Ax -c -t x1 |grep '000' && \\\n  echo \"Success\" || echo \"Failed\"\n```\n\n----------------------------------------\n\nTITLE: Getting Network Interface IP Address\nDESCRIPTION: Commands for obtaining local IP address from network interfaces on different operating systems to use as WebRTC candidate address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\nCANDIDATE=$(ifconfig en0 inet| grep 'inet '|awk '{print $2}')\n\n# For CentOS\nCANDIDATE=$(ifconfig eth0|grep 'inet '|awk '{print $2}')\n\n# Directly set ip.\nCANDIDATE=\"192.168.3.10\"\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server A for Cluster (SRS Config)\nDESCRIPTION: This configuration file sets up the first SRS origin server (Server A). It listens on port 19350, enables the HTTP API on port 9090, and defines itself as part of an origin cluster (`origin_cluster on`). It specifies the coworker origin server (Server B) at `127.0.0.1:9091`. `daemon off` keeps the server running in the foreground.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n# conf/origin.cluster.serverA.conf\nlisten              19350;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverA.pid;\nhttp_api {\n    enabled         on;\n    listen          9090;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9091;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Heartbeat Callbacks\nDESCRIPTION: Configuration settings for enabling heartbeat callbacks from SRS to an HTTP server. Includes options for interval, URL, device ID, and summaries reporting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# heartbeat to api server\n# @remark, the ip report to server, is retrieve from system stat,\n#       which need the config item stats.network.\nheartbeat {\n    # whether heartbeat is enabled.\n    # Overwrite by env SRS_HEARTBEAT_ENABLED\n    # default: off\n    enabled off;\n    # the interval seconds for heartbeat,\n    # recommend 0.3,0.6,0.9,1.2,1.5,1.8,2.1,2.4,2.7,3,...,6,9,12,....\n    # Overwrite by env SRS_HEARTBEAT_INTERVAL\n    # default: 9.9\n    interval 9.3;\n    # when startup, srs will heartbeat to this api.\n    # @remark: must be a restful http api url, where SRS will POST with following data:\n    #   {\n    #       \"device_id\": \"my-srs-device\",\n    #       \"ip\": \"192.168.1.100\"\n    #   }\n    # Overwrite by env SRS_HEARTBEAT_URL\n    # default: http://127.0.0.1:8085/api/v1/servers\n    url http://127.0.0.1:8085/api/v1/servers;\n    # the id of device.\n    # Overwrite by env SRS_HEARTBEAT_DEVICE_ID\n    device_id       \"my-srs-device\";\n    # whether report with summaries\n    # if on, put /api/v1/summaries to the request data:\n    #   {\n    #       \"summaries\": summaries object.\n    #   }\n    # @remark: optional config.\n    # Overwrite by env SRS_HEARTBEAT_SUMMARIES\n    # default: off\n    summaries off;\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing a Stream to SRS Master using FFmpeg\nDESCRIPTION: This bash command uses FFmpeg to continuously publish a local video file (`doc/source.flv`) to an SRS master server located at `192.168.1.5` on port `1935`. The `-re` option reads the input at its native frame rate, `-c copy` copies the codecs without re-encoding, and `-f flv` specifies the output format as FLV over RTMP. The stream is published to the `live` application with the name `livestream` in an infinite loop.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/forward.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do\\\n    ./objs/ffmpeg/bin/ffmpeg -re -i doc/source.flv \\\n        -c copy -f flv rtmp://192.168.1.5:1935/live/livestream; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Publishing Live Stream to SRS with FFmpeg - Bash\nDESCRIPTION: Uses FFmpeg to read a local FLV video file and transmit it as a live RTMP stream to the SRS server. Assumes FFmpeg is installed, and SRS server is listening for RTMP at localhost. Key parameters include '-re' for real-time reading, '-i' for input filename, '-c copy' to avoid recompression, and '-f flv' for output format. The RTMP target URL specifies the live application and stream name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server in VHOST\nDESCRIPTION: Basic configuration for setting up an SRS edge server within a vhost. This configuration defines the edge mode, origin server details, token settings, and debug options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/edge.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            remote;\n\n        # For edge(mode remote), user must specifies the origin server\n        # format as: <server_name|ip>[:port]\n        # @remark user can specifies multiple origin for error backup, by space,\n        # for example, 192.168.1.100:1935 192.168.1.101:1935 192.168.1.102:1935\n        origin          127.0.0.1:1935 localhost:1935;\n\n        # For edge(mode remote), whether open the token traverse mode,\n        # if token traverse on, all connections of edge will forward to origin to check(auth),\n        # it's very important for the edge to do the token auth.\n        # the better way is use http callback to do the token auth by the edge,\n        # but if user prefer origin check(auth), the token_traverse if better solution.\n        # default: off\n        token_traverse  off;\n\n        # For edge(mode remote), the vhost to transform for edge,\n        # to fetch from the specified vhost at origin,\n        # if not specified, use the current vhost of edge in origin, the variable [vhost].\n        # default: [vhost]\n        vhost           same.edge.srs.com;\n\n        # For edge(mode remote), when upnode(forward to, edge push to, edge pull from) is srs,\n        # it's strongly recommend to open the debug_srs_upnode,\n        # when connect to upnode, it will take the debug info,\n        # for example, the id, source id, pid.\n        # please see https://ossrs.net/lts/zh-cn/docs/v4/doc/log\n        # default: on\n        debug_srs_upnode    on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using GPROF for Performance Profiling\nDESCRIPTION: Demonstrates how to build and run SRS with GPROF support, and how to analyze the resulting performance profile.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GPROF\n./configure --gprof=on && make\n\n# Start SRS with GPROF\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop GPROF\nkillall -2 srs\n\n# To analysis result.\ngprof -b ./objs/srs gmon.out\n```\n\n----------------------------------------\n\nTITLE: Understanding HLS Window Size Rule in SRS\nDESCRIPTION: Shows the relationship between the configured `hls_window` directive and the sum of individual TS segment durations listed in the M3U8 playlist. SRS maintains the playlist such that the total duration of segments listed is always less than or equal to the `hls_window` setting (in seconds), removing older segments from the playlist and filesystem as new ones are added.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nhls_window >= sum(each ts duration in m3u8)\n```\n\n----------------------------------------\n\nTITLE: Defining the EXT-X-TARGETDURATION Tag in M3U8 Media Playlists\nDESCRIPTION: Specifies the format of the EXT-X-TARGETDURATION tag, indicating the maximum media segment duration in seconds ('s'). The EXTINF duration of each segment in the playlist (rounded to the nearest integer) MUST be less than or equal to this target duration. This tag MUST appear exactly once in a Media Playlist and applies to the entire playlist. It MUST NOT appear in a Master Playlist.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_4\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-TARGETDURATION:<s>\n```\n\n----------------------------------------\n\nTITLE: Configuring NGINX as HLS Origin Server\nDESCRIPTION: This NGINX configuration sets up direct file serving for HLS m3u8 and ts files. It specifies the root directory and sets Cache-Control headers for different file types.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/nginx-for-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\n  # For HLS delivery\n  location ~ /.+/.*\\.(m3u8)$ {\n    root /usr/local/srs/objs/nginx/html;\n    add_header Cache-Control \"public, max-age=10\";\n  }\n  location ~ /.+/.*\\.(ts)$ {\n    root /usr/local/srs/objs/nginx/html;\n    add_header Cache-Control \"public, max-age=86400\";\n  }\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using killall (Shell)\nDESCRIPTION: This command sends the SIGHUP signal (signal 1) to all running processes named 'srs'. This triggers SRS to reload its configuration file without stopping the server or disconnecting active client connections. It's a common way to apply configuration updates.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reload.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nkillall -1 srs\n```\n\n----------------------------------------\n\nTITLE: Tracing Edge Session Logs\nDESCRIPTION: Shows how to trace edge server session logs using session IDs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngrep --color -ina \"\\[108\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: SRS Edge Server Integration Architecture\nDESCRIPTION: ASCII diagram showing integration between SRS Origin, SRS Edge and NGINX Edge Servers for HLS and HTTP-FLV distribution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/nginx-for-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n+------------+           +------------+\n| SRS Origin +--RTMP-->--+ SRS Edge   +\n+-----+------+           +----+-------+\n      |                       |               +------------+\n      |                       +---HTTP-FLV->--+   NGINX    +              +-----------+\n      |                                       +   Edge     +--HLS/FLV-->--+ Visitors  +\n      +-------HLS--->-------------------------+   Servers  +              +-----------+\n                                              +------------+\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS from Gitee Mirror\nDESCRIPTION: Commands to clone SRS from Gitee mirror and switch remote to GitHub origin. Useful for users in China for faster access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/resource.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/ossrs/srs.git &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Using curl to Interact with SRS HTTP API\nDESCRIPTION: Examples of using the curl command to send HTTP requests to SRS API endpoints. Shows how to perform GET and DELETE operations for client management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v -X GET http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\ncurl -v -X DELETE http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server for Cluster Setup\nDESCRIPTION: Example configuration for an SRS origin server in a cluster setup. This defines basic parameters like listen port, PID file location, and log file path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/edge.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              19350;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Low-Latency HLS in SRS\nDESCRIPTION: Configuration example for reducing HLS latency by adjusting fragment and window sizes in the SRS configuration file. This sets the HLS fragment size to 2 seconds and the window to 10 seconds to achieve lower latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_fragment 2;\n        hls_window 10;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing FLV Stream to SRS using FFmpeg Bash\nDESCRIPTION: This command uses FFmpeg to publish a video stream from a local file (`./doc/source.flv`) to the SRS server running on the ARM device. The `-re` flag reads the input at its native frame rate. `-c copy` copies the streams without re-encoding. `-f flv` specifies the output format as FLV. The RTMP URL points to the SRS server (assuming `192.168.1.170` is the Ubuntu host IP and port `19350` is mapped to the ARM device's port `1935`) with the application `live` and stream key `livestream`. The `for` loop ensures that FFmpeg attempts to republish the stream repeatedly, pausing for 1 second between attempts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Adding Prometheus as Grafana Data Source\nDESCRIPTION: curl command to call Grafana API and add Prometheus as a data source, enabling Grafana to query and visualize metrics from Prometheus.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -H \"Content-Type: application/json\" \\\n    -XPOST http://admin:12345678@localhost:3000/api/datasources \\\n    -d '{\n    \"name\": \"prometheus\",\n    \"type\": \"prometheus\",\n    \"access\": \"proxy\", \"isDefault\": true,\n    \"url\": \"http://host.docker.internal:9090\"\n}'\n```\n\n----------------------------------------\n\nTITLE: Configuring Min-Latency Mode in SRS\nDESCRIPTION: SRS configuration snippet for enabling min-latency mode, which disables merged-read and uses timeout conditional wait to reduce latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/low-latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    # whether enable min delay mode for vhost.\n    # for min latence mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off\n    min_latency     off;\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Stream to Origin Server with FFmpeg - Bash\nDESCRIPTION: Uses FFmpeg to push a local FLV file as an RTMP stream to the SRS origin server. Requires ffmpeg and source.flv in doc/. Streams as-is (copy) via RTMP to specified endpoint. Inputs: FLV file, RTMP endpoint URL. Outputs: Live RTMP stream ingested by SRS for further HLS or cache distribution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy \\\n  -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: WebRTC Play Request and Response in JSON\nDESCRIPTION: Example of a WebRTC play request to SRS and the corresponding server response. The request includes the API endpoint, stream URL, and SDP. The response contains a status code, SDP, and session ID.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"api\": \"https://d.ossrs.net/rtc/v1/play/\"\n  \"streamurl\": \"webrtc://d.ossrs.net/live/3abd9f34\",\n  \"sdp\": \"v=0\\r\\n......\\r\\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\\r\\n\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"code\": 0\n  \"sdp\": \"v=0\\r\\n......\\r\\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\\r\\n\"\n  \"sessionid\": \"186tj710:hMub\"\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming HEVC with FFmpeg on macOS using Docker\nDESCRIPTION: Command to stream HEVC content using FFmpeg in Docker on macOS, utilizing libx265 encoder to publish via RTMP to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# macOS\ndocker run --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n    -acodec copy -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Deploying SRS Origin and Nginx with Kubernetes\nDESCRIPTION: This YAML configuration creates a Kubernetes deployment for SRS origin server with Nginx for HTTP distribution. It sets up a shared volume between SRS and Nginx containers, establishes a ClusterIP service for internal access to origin, and creates a LoadBalancer service for external HTTP distribution of HLS segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-origin-deploy\n  labels:\n    app: srs-origin\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs-origin\n  template:\n    metadata:\n      labels:\n        app: srs-origin\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: ClusterIP\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-http-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-http-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-http-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\nEOF\n```\n\n----------------------------------------\n\nTITLE: Starting Demo HTTP Callback Server\nDESCRIPTION: This command runs a demo HTTP callback server implemented in Go, which acts as the business server receiving callbacks from SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo run research/api-server/server.go\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode for SRS Upnode Connections\nDESCRIPTION: Activates debug mode for connections to upstream SRS nodes. This setting is recommended when forwarding to, pushing to, or pulling from another SRS instance, as it provides additional debug information like ID, source ID, and PID.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_4\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    debug_srs_upnode    on;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Static Vhost\nDESCRIPTION: Configuration for HTTP static vhost settings including mount points and directory specifications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-server.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_static {\n        enabled     on;\n        mount       [vhost]/hls;\n        dir         ./objs/nginx/html/hls;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Origin HLS Configuration\nDESCRIPTION: Configuration file for SRS origin server to enable HLS streaming with HTTP server on port 8080.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/hls.origin.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nhttp_server {\n    enabled         on;\n    listen          8080;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callbacks in Go\nDESCRIPTION: This Go code snippet demonstrates how to set up a basic HTTP server and a handler function (`/api/v1/streams`) to receive and process SRS callback requests (like `on_publish`). It reads the incoming request body, prints it to the console for inspection, and sends back a standard JSON success response (`{\"code\": 0, \"msg\": \"OK\"}`). Requires Go's standard `net/http`, `fmt`, `io/ioutil`, and `encoding/json` packages.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nhttp.HandleFunc(\"/api/v1/streams\", func(w http.ResponseWriter, r *http.Request) {\n    b, err := ioutil.ReadAll(r.Body)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n\n    fmt.Println(string(b))\n\n    res, err := json.Marshal(struct {\n        Code int `json:\"code\"`\n        Message string `json:\"msg\"`\n    }{\n        0, \"OK\",\n    })\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n    w.Write(res)\n})\n\n_ = http.ListenAndServe(\":8085\", nil)\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Timestamp Jitter Settings\nDESCRIPTION: Configuration snippet for setting up timestamp jitter handling in an SRS vhost. Includes options for time_jitter algorithm selection and mix_correct settings for RTMP playback.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/time-jitter.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost jitter.srs.com {\n    play {\n        time_jitter             full;\n        mix_correct             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring EXEC in SRS RTMP\nDESCRIPTION: Configuration example for setting up executable commands in SRS RTMP. Shows how to enable exec functionality and configure publish events with variable substitution for FFmpeg commands.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/nginx-exec.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    # the exec used to fork process when got some event.\n    exec {\n        # whether enable the exec.\n        # default: off.\n        enabled     off;\n        # when publish stream, exec the process with variables:\n        #       [vhost] the input stream vhost.\n        #       [port] the intput stream port.\n        #       [app] the input stream app.\n        #       [stream] the input stream name.\n        #       [engine] the tanscode engine name.\n        # other variables for exec only:\n        #       [url] the rtmp url which trigger the publish.\n        #       [tcUrl] the client request tcUrl.\n        #       [swfUrl] the client request swfUrl.\n        #       [pageUrl] the client request pageUrl.\n        # @remark empty to ignore this exec.\n        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Building SRS for ARMv7 Using Cross Toolchain - Shell\nDESCRIPTION: This shell snippet configures and builds SRS for ARMv7 (armhf) with the appropriate cross-prefix. It requires the SRS source code, cross-compiler tools for arm-linux-gnueabihf, and a suitable shell environment. The output is an SRS binary for ARMv7 platforms. Use when targeting devices like Acqua or RoadRunner boards.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n```\n./configure --cross-build --cross-prefix=arm-linux-gnueabihf-\nmake\n```\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Built SRS in ARMv7 Docker Container - Shell\nDESCRIPTION: This shell command runs the cross-built SRS server inside an ARMv7 (armhf) Docker container, mapping relevant network ports and the project directory. Inputs: Docker, cross-built SRS, armv7/armhf-ubuntu image. Outputs: A running SRS instance within the container, accessible on configured ports. Both Docker and the built binaries are required.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 armv7/armhf-ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Timestamp Jitter for RTMP Delivery in SRS\nDESCRIPTION: Configuration example for setting timestamp jitter behavior in a vhost for RTMP delivery. Options include 'full' (ensure zero start and monotonic increase), 'zero' (only ensure zero start), or 'off' (disable jitter correction). Also includes mix_correct option for interleaved timestamp correction.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/time-jitter.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost jitter.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing, \n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # default: full\n        time_jitter             full;\n        # whether use the interleaved/mixed algorithm to correct the timestamp.\n        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.\n        # if off, use time_jitter to correct the timestamp if required.\n        # default: off\n        mix_correct             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracking Session ID in Origin Server Logs\nDESCRIPTION: Uses grep to search for a specific session ID (107) in the origin server logs to track all activities related to that session. This reveals the complete lifecycle of a client connection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"\\[107\\]\" objs/srs.origin.log \n27:[2014-08-06 10:09:34.589][trace][22288][107] RTMP client ip=127.0.0.1\n28:[2014-08-06 10:09:34.591][trace][22288][107] complex handshake success\n29:[2014-08-06 10:09:34.631][trace][22288][107] connect app, tcUrl=rtmp://dev:1935/live, pageUrl=http://www.ossrs.net/players/srs_player.html?vhost=dev&stream=livestream&server=dev&port=1935, swfUrl=http://www.ossrs.net/players/srs_player/release/srs_player.swf?_version=1.23, schema=rtmp, vhost=__defaultVhost__, port=1935, app=live, args=(obj)\n30:[2014-08-06 10:09:34.631][trace][22288][107] edge-srs ip=192.168.1.159, version=0.9.190, pid=22314, id=108\n31:[2014-08-06 10:09:34.671][trace][22288][107] client identified, type=Play, stream_name=livestream, duration=-1.00\n32:[2014-08-06 10:09:34.671][trace][22288][107] out chunk size to 60000\n33:[2014-08-06 10:09:34.671][trace][22288][107] source url=__defaultVhost__/live/livestream, ip=127.0.0.1, cache=1, is_edge=0, source_id=105[105]\n34:[2014-08-06 10:09:34.672][trace][22288][107] dispatch cached gop success. count=307, duration=4515\n35:[2014-08-06 10:09:34.672][trace][22288][107] create consumer, queue_size=30.00, tba=44100, tbv=25\n36:[2014-08-06 10:09:34.672][trace][22288][107] ignored. set buffer length to 1000\n37:[2014-08-06 10:09:34.673][trace][22288][107] input chunk size to 60000\n40:[2014-08-06 10:09:44.748][trace][22288][107] -> PLA time=10007, msgs=0, okbps=464,0,0, ikbps=3,0,0\n41:[2014-08-06 10:09:47.805][warn][22288][107][104] client disconnect peer. ret=1004\n```\n\n----------------------------------------\n\nTITLE: Transferring SRS Binary and Config to ARM Device using SCP Bash\nDESCRIPTION: These commands use Secure Copy Protocol (SCP) to transfer the compiled SRS binary (`objs/srs`) and a sample configuration file (`conf/rtmp.conf`) from the build machine to the target ARM device. It specifies the port (2200, presumably mapped to the ARM device's SSH port 22) and the destination path on the ARM device (`~`, the root user's home directory). It assumes the ARM device is accessible at `localhost` on port 2200 from the build machine and the password for the `root` user is 'root'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Password isroot\nscp -P 2200 objs/srs  root@localhost:~\nscp -P 2200 conf/rtmp.conf root@localhost:~\n```\n\n----------------------------------------\n\nTITLE: Illustrating SRS HTTP Callback POST Request Format (on_publish)\nDESCRIPTION: This example demonstrates the structure of the HTTP POST request sent by SRS to a configured callback URL when an `on_publish` event occurs. It includes details like server ID, client ID, stream information, and client IP within a JSON body. This format is typical for callback events.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nPOST /api/v1/streams HTTP/1.1\nContent-Type: application-json\n\nBody:\n{\n  \"server_id\": \"vid-0xk989d\",\n  \"action\": \"on_publish\",\n  \"client_id\": \"341w361a\",\n  \"ip\": \"127.0.0.1\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"tcUrl\": \"rtmp://127.0.0.1:1935/live?vhost=__defaultVhost__\",\n  \"stream\": \"livestream\",\n  \"param\": \"\",\n  \"stream_url\": \"video.test.com/live/livestream\",\n  \"stream_id\": \"vid-124q9y3\"\n}\n```\n\n----------------------------------------\n\nTITLE: Minimal Successful HTTP Response for SRS Callback (Plain Text)\nDESCRIPTION: This example illustrates a minimal valid success response that an HTTP callback server must return to SRS to indicate the successful handling of an event (like `on_publish`). It requires an HTTP/1.1 200 OK status line and a response body containing exactly the digit '0'. SRS interprets this specific response as success; any other non-zero value or different HTTP status may cause SRS to reject the client connection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_13\n\nLANGUAGE: text\nCODE:\n```\nHTTP/1.1 200 OK\nContent-Length: 1\n0\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS with a Specific Vhost\nDESCRIPTION: This snippet shows how to configure SRS with a specific vhost (demo.srs.com) on a given IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n}\n```\n\n----------------------------------------\n\nTITLE: Stream-Specific Transcode Configuration\nDESCRIPTION: Configuration example showing how to apply transcoding to specific streams within an application.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # applivelivestream\n    transcode live/livestream{\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS using systemctl\nDESCRIPTION: This command starts the SRS service using systemctl on systems that support it.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start srs\n```\n\n----------------------------------------\n\nTITLE: Starting SRS on ARM Device\nDESCRIPTION: Command to launch the SRS server on the ARM device using the transferred configuration file. This runs the RTMP server which will accept incoming stream publications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring GOP Cache in SRS\nDESCRIPTION: SRS configuration for GOP (Group of Pictures) caching, which can enable fast startup for clients but may increase latency. This snippet shows how to disable GOP cache for minimum delay.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/low-latency.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# the listen ports, split by space.\nlisten              1935;\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether cache the last gop.\n        # if on, cache the last gop and dispatch to client,\n        #   to enabled fast startup for client, client play immediately.\n        # if off, send the latest media data to client,\n        #   client need to wait for the next Iframe to decode and show the video.\n        # set to off if requires min delay;\n        # set to on if requires client fast startup.\n        # default: on\n        gop_cache       off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Clone the SRS repository from GitHub using the develop branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Configuring logrotate for SRS log files\nDESCRIPTION: Bash script to create a logrotate configuration file for managing SRS log files. It sets up daily rotation, compression, and sends a SIGUSR1 signal to SRS after rotation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/log-rotate.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    sharedscripts\n    postrotate\n        kill -USR1 `cat /usr/local/srs/objs/srs.pid`\n    endscript\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Running SRS in Docker with WebRTC Support\nDESCRIPTION: Docker command to run SRS with WebRTC configuration and port mappings, including UDP port for WebRTC traffic.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:4 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server for High Quality Mode in Bash\nDESCRIPTION: This snippet demonstrates the recommended SRT server configuration for high quality mode, prioritizing stream stability and packet retention over latency. It's suitable for public networks with potentially unstable connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    connect_timeout 4000;\n    peerlatency 0;\n    recvlatency 0;\n    latency 0;\n    tlpktdrop off;\n    tsbpdmode off;\n}\n```\n\n----------------------------------------\n\nTITLE: SRS RTC to RTMP Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC to RTMP configuration for audio transcoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Slave SRS Server\nDESCRIPTION: Configuration file for the slave SRS server, listening on port 19350.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# conf/forward.slave.conf\nlisten              19350;\npid                 ./objs/srs.slave.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.slave.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Copying Video and Audio Streams with FFMPEG in SRS (bash)\nDESCRIPTION: This SRS configuration demonstrates setting both video ('vcodec copy;') and audio ('acodec copy;') codecs to 'copy'. This instructs FFMPEG to demux the input streams and mux them into the output RTMP stream without performing any transcoding, similar to SRS's forwarding capability. Requires SRS and a functional FFMPEG binary.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          copy;\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Compiled SRS on ARMv7 Docker\nDESCRIPTION: Docker command to run the cross-compiled SRS binary on an ARMv7 Ubuntu Docker container.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 armv7/armhf-ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Verifying Output MPEG-TS Stream on SRS Edge using ffprobe (Bash)\nDESCRIPTION: This ffprobe command inspects the UDP MPEG-TS stream `udp://xxx:1234?localaddr=127.0.0.1` being output by the edge server's FFmpeg process (triggered by SRS `exec`). It confirms that the stream forwarded from the origin has been successfully converted back to MPEG-TS format with the correct codecs (H.264 video, AAC audio) and metadata, accessible on the edge server's loopback interface.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/sample.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    [root@edge ~]# ffprobe  udp://xxx:1234?localaddr=127.0.0.1\n    Input #0, mpegts, from 'udp://xxx:5002?localaddr=127.0.0.1':\n      Duration: N/A, start: 29981.146500, bitrate: 130 kb/s\n      Program 1\n        Metadata:\n          service_name    : Channel 1\n          service_provider: PBS\n        Stream #0:0[0x100]: Video: h264 (High) ([27][0][0][0] / 0x001B), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 90k tbn, 180k tbc\n        Stream #0:1[0x101]: Audio: aac ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 130 kb/s\n```\n\n----------------------------------------\n\nTITLE: Applying Kubernetes Deployment for SRS Edge with Graceful Shutdown (Bash)\nDESCRIPTION: This command applies the Kubernetes Deployment definition for the SRS edge server using `kubectl apply --record -f -`. The `--record` flag saves the command used for the rollout history, enabling easier tracking and rollbacks. The deployment definition, including the graceful shutdown configuration (`preStop` hook and `terminationGracePeriodSeconds`), is provided via standard input using a bash heredoc (`cat <<EOF ... EOF`). This creates or updates the SRS edge deployment in the cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply --record -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-edge-deploy\n  labels:\n    app: srs-edge\nspec:\n  replicas: 2\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: srs-edge\n  template:\n    metadata:\n      labels:\n        app: srs-edge\n    spec:\n      volumes:\n      - name: config-volume\n        configMap:\n          name: srs-edge-config\n      containers:\n      - name: srs\n        image: ossrs/srs:v4.0.5\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: config-volume\n          mountPath: /usr/local/srs/conf\n        lifecycle:\n          preStop:\n            exec:\n              command: [\"/usr/local/srs/etc/init.d/srs\", \"grace\"]\n      terminationGracePeriodSeconds: 120\nEOF\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS from Source (Bash)\nDESCRIPTION: Navigates into the 'srs/trunk' directory, runs the configure script to prepare the build environment, and then compiles the SRS source code using 'make'. This sequence is necessary after cloning the repository to create the executable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Node.js Koa Callback Handler Implementation\nDESCRIPTION: Example Node.js code using Koa framework to handle SRS callbacks with JSON response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst Router = require('koa-router');\nconst router = new Router();\n\nrouter.all('/api/v1/streams', async (ctx) => {\n  console.log(ctx.request.body);\n\n  ctx.body = {code: 0, msg: 'OK'};\n});\n```\n\n----------------------------------------\n\nTITLE: Enabling and Running GPERF Memory Checker (gmc) with SRS in Bash\nDESCRIPTION: Outlines the sequence of shell commands to configure SRS with gmc support (`--with-gperf --with-gmc`), build it (`make`), run it with the heap checker enabled (`env PPROF_PATH=... HEAPCHECK=normal ...`), and stop it (`CTRL+C` or `SIGINT`) to generate the leak report. The `PPROF_PATH` environment variable is crucial for symbolization in the report.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Configure SRS with gmc enabled\n./configure --with-gperf --with-gmc\n\n# Compile SRS\nmake\n\n# Run SRS with gmc active (set environment variables)\nenv PPROF_PATH=./objs/pprof HEAPCHECK=normal ./objs/srs -c conf/console.conf\n\n# Stop SRS to trigger report generation\nCTRL+C\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Service for SRS and Nginx\nDESCRIPTION: This YAML configuration creates a Kubernetes LoadBalancer service to expose SRS and Nginx ports externally. It maps ports for RTMP, HTTP-FLV, API, and HLS services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-origin-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-origin-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-origin-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Accessing SRS HTTP API Root - Bash (curl usage)\nDESCRIPTION: This command queries the HTTP API root with curl to enumerate available API endpoints. The output is JSON containing a urls field that maps available sub-APIs. This requires the SRS HTTP API to be enabled and listening at the given address. Authentication settings may impact accessibility. Returns available API URLs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n# curl http://192.168.1.102:1985/\\n    \"urls\": {\\n        \"api\": \"the api root\"\\n    }\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring logrotate for SRS with postrotate (Recommended)\nDESCRIPTION: Provides a shell command using a heredoc (`cat << END ... END`) to create the `logrotate` configuration file `/etc/logrotate.d/srs`. This recommended configuration rotates the `/usr/local/srs/objs/srs.log` file daily, adds a date extension, compresses rotated logs, keeps the last 7 rotations, rotates if the size exceeds 1024MB, and crucially uses a `postrotate` script. The script sends the SIGUSR1 signal to the specific SRS process (identified by its PID file) after rotation, ensuring SRS switches to the new log file without losing messages.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    sharedscripts\n    postrotate\n        kill -USR1 \\`cat /usr/local/srs/objs/srs.pid\\`\n    endscript\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Handling SRS Callbacks with PHP\nDESCRIPTION: PHP example demonstrating how to handle SRS callbacks (specifically on_publish event). It reads the request body as JSON, prints it, and returns a successful response with code 0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_3\n\nLANGUAGE: php\nCODE:\n```\n$body = json_decode(file_get_contents('php://input'));\nprintf($body);\n\necho json_encode(array(\"code\"=>0, \"msg\"=>\"OK\"));\n```\n\n----------------------------------------\n\nTITLE: Streaming HEVC with FFmpeg on Linux using Docker\nDESCRIPTION: Command to stream HEVC content using FFmpeg in Docker on Linux, utilizing libx265 encoder to publish via RTMP to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# linux\ndocker run --net=host --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n    -acodec copy -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Setting Publish Normal Timeout in SRS YAML\nDESCRIPTION: Sets the timeout for normal packets from an encoder during publishing. This helps manage ongoing connection timeouts for RTMP publishers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        normal_timeout      7000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server with WebRTC Support in Bash\nDESCRIPTION: Command to start the SRS server with WebRTC support, specifying the CANDIDATE IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Direct Stream Copy Without Transcoding\nDESCRIPTION: Configuration for copying both video and audio streams without transcoding, similar to SRS forward functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          copy;\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Performance Analysis with PERF\nDESCRIPTION: Uses the Linux PERF tool to analyze performance bottlenecks in SRS, including recording performance data and generating call graphs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nperf top -p $(pidof srs)\n\nperf record -p $(pidof srs)\n\n# Press CTRL+C after about 30s.\n\nperf report\n\nperf record -a --call-graph fp -p $(pidof srs)\nperf report --call-graph --stdio\n```\n\n----------------------------------------\n\nTITLE: Enabling/Disabling TCP NoDelay Option in SRS\nDESCRIPTION: Configures whether the TCP_NODELAY socket option is enabled for SRS connections. Enabling TCP_NODELAY ('on') can reduce latency by sending small packets immediately, but might decrease overall throughput. The default setting is 'off'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    # whether enable the TCP_NODELAY\n    # if on, set the nodelay of fd by setsockopt\n    # default: off\n    tcp_nodelay     on;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin and NGINX Edge Servers - Bash\nDESCRIPTION: This command sequence starts the NGINX edge server and the SRS origin server using their respective configuration files. Assumes both binaries are built and in the current working directory structure. Requires the configuration files exist at the given paths and ports are available.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnginx -c $(pwd)/conf/hls.edge.conf\n./objs/srs -c conf/hls.origin.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with RTC to RTMP Conversion for Room-to-Live Streaming\nDESCRIPTION: Docker command to run SRS with RTC to RTMP conversion enabled, necessary for converting WebRTC calls to live streams. Uses the rtc2rtmp.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:4 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Playing HTTP-FLV Stream from Proxy Server\nDESCRIPTION: FFplay command to play an HTTP-FLV stream from the SRS proxy server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffplay http://localhost:8080/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: Pushing FLV Stream to SRS using FFmpeg in Bash\nDESCRIPTION: FFmpeg command to push an FLV stream via HTTP POST to SRS for conversion.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/streamer.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy \\\n    -f flv http://127.0.0.1:8936/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: Graceful Quit Configuration in SRS\nDESCRIPTION: Configuration options for SRS graceful shutdown, including wait times and force grace quit settings. These help manage zero-downtime upgrades.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# For gracefully quit, wait for a while then close listeners,\n# because K8S notify SRS with SIGQUIT and update Service simultaneously,\n# maybe there is some new connections incoming before Service updated.\n# @see https://github.com/ossrs/srs/issues/1595#issuecomment-587516567\n# default: 2300\ngrace_start_wait 2300;\n# For gracefully quit, final wait for cleanup in milliseconds.\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587414898\n# default: 3200\ngrace_final_wait 3200;\n# Whether force gracefully quit, never fast quit.\n# By default, SIGTERM which means fast quit, is sent by K8S, so we need to\n# force SRS to treat SIGTERM as gracefully quit for gray release or canary.\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587475077\n# default: off\nforce_grace_quit off;\n```\n\n----------------------------------------\n\nTITLE: SRS Architecture for H.265 Support\nDESCRIPTION: Diagram showing the architecture for SRS to support H.265/HEVC, demonstrating how FFmpeg can send HEVC over RTMP to SRS, which then distributes it through various protocols to supported browsers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nFFmpeg --RTMP(h.265)---> SRS ----RTMP/FLV/TS/HLS/WebRTC(h.265)--> Chrome/Safari\n```\n\n----------------------------------------\n\nTITLE: FFmpeg HEVC Streaming Commands\nDESCRIPTION: FFmpeg commands for streaming HEVC content to SRS server on different platforms (macOS and Linux)\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n\n# For linux\ndocker run --net=host --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -acodec copy -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server\nDESCRIPTION: Start the SRS server using the default configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Retrieving SRS Service Details in Kubernetes using Bash\nDESCRIPTION: This command retrieves the details of the Kubernetes Service named `srs-service`. It's used after creating the LoadBalancer service to find the assigned external IP address (`EXTERNAL-IP`), which is needed to access the deployed SRS instance from outside the cluster for publishing and playing streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get svc/srs-service\n```\n\n----------------------------------------\n\nTITLE: Filtering SRS Logs for Publish Events using Grep in Bash\nDESCRIPTION: Shows how to use the `grep` command with the `-i` (ignore case) and `-n` (line number) options to filter the `srs.log` file. It searches for log entries indicating successful client identification specifically for publishing streams, using the keyword phrase \"identify client success. type=publish\". The output shows matching lines with their original line numbers and session IDs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n43:[2014-04-04 11:56:18.138][trace][105][11] identify client success. type=publish, stream_name=winlin\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Building and Running SRS with GPROF Profiling\nDESCRIPTION: Commands to build SRS with GNU profiler support, run it, and analyze the results. GPROF provides function-level profiling for identifying performance bottlenecks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GPROF\n./configure --gprof=on && make\n\n# Start SRS with GPROF\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop GPROF\nkillall -2 srs\n\n# To analysis result.\ngprof -b ./objs/srs gmon.out\n```\n\n----------------------------------------\n\nTITLE: SRS Real-time Configuration\nDESCRIPTION: Configuration file for low-latency RTMP streaming with TCP nodelay and minimal latency settings enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/realtime.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Configuration parameters for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the SRS origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Setting up SRS with systemctl on Ubuntu 20\nDESCRIPTION: Complete sequence of commands to install SRS, configure it as both an init.d service and a systemd service on Ubuntu 20, and enable it to start on boot.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && sudo make install &&\nsudo ln -sf /usr/local/srs/etc/init.d/srs /etc/init.d/srs &&\nsudo cp -f /usr/local/srs/usr/lib/systemd/system/srs.service /usr/lib/systemd/system/srs.service &&\nsudo systemctl daemon-reload && sudo systemctl enable srs\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for ATC and Fault Backup - SRS Config/Bash\nDESCRIPTION: This snippet demonstrates how to configure an SRS vhost to control the ATC (absolute time code) feature for RTMP fault backup and HLS/HDS slicing support. The example shows how to enable or disable the 'atc' parameter under the 'play' section, influencing how timestamps are managed from origin to edge to client. This config requires SRS to be deployed; the key parameter 'atc' can be set to 'on' or 'off' to control timing between master/slave sources for fault tolerance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-atc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\\n    # for play client, both RTMP and other stream clients,\\n    # for instance, the HTTP FLV stream clients.\\n    play {\\n        # vhost for atc for hls/hds/rtmp backup.\\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\\n        # when atc is on, server delivery rtmp stream by absolute time.\\n        # atc is used, for instance, encoder will copy stream to master and slave server,\\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\\n        # if the time not the same, the HLS stream cannot slice to support system backup.\\n        #\\n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\\n        #\\n        # default: off\\n        atc             off;\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for HttpCallback Snapshot\nDESCRIPTION: Configuration file for SRS to enable HTTP callbacks for snapshot functionality. It includes settings for HTTP hooks, ingest, and FFMPEG.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/snapshot.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n# snapshot.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    http_hooks {\n        enabled on;\n        on_publish http://127.0.0.1:8085/api/v1/snapshots;\n        on_unpublish http://127.0.0.1:8085/api/v1/snapshots;\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Encoder Command for Publishing Stream\nDESCRIPTION: Bash command using FFMPEG to publish a stream to the SRS master server in a loop.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do\\\n    ./objs/ffmpeg/bin/ffmpeg -re -i doc/source.flv \\\n        -c copy -f flv rtmp://192.168.1.5:1935/live/livestream; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Source - Bash\nDESCRIPTION: This snippet updates an existing SRS codebase using git pull. It assumes that the working directory is inside the SRS repository. Dependencies are minimal: Git must be installed and the repository must be previously cloned. The command fetches and merges available updates from the remote repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Vhosts for Multi-Tenancy in SRS (Bash)\nDESCRIPTION: This SRS configuration demonstrates setting up multiple virtual hosts (Vhosts) for multi-tenancy. It listens on port 1935 and defines two distinct Vhosts: `show.cctv.cn` and `show.wasu.cn`. This allows different clients or applications (identified by the requested hostname in the RTMP URL) to use the same server infrastructure while maintaining separate configurations and resource isolation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n}\nvhost show.wasu.cn {\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling TCP NoDelay\nDESCRIPTION: Controls whether to enable TCP_NODELAY socket option for connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_9\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code\nDESCRIPTION: Command to update an existing SRS repository with the latest changes from GitHub.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring MPEGTS over UDP and HTTP FLV Stream Casters\nDESCRIPTION: Configuration example for setting up both MPEG-TS over UDP and FLV over HTTP POST stream casters in SRS. This defines the protocols, input ports, and output RTMP destinations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/streamer.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# Push MPEGTS over UDP to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       mpegts_over_udp, push MPEG-TS over UDP and convert to RTMP.\n    caster mpegts_over_udp;\n    # The output rtmp url.\n    # For mpegts_over_udp converter, the typically output url:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/live/livestream;\n    # The listen port for stream converter.\n    # For mpegts_over_udp converter, listen at udp port. for example, 8935.\n    listen 8935;\n}\n\n# Push FLV by HTTP POST to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       flv, push FLV by HTTP POST and convert to RTMP.\n    caster flv;\n    # The output rtmp url.\n    # For flv converter, the typically output url:\n    #           rtmp://127.0.0.1/[app]/[stream]\n    # For example, POST to url:\n    #           http://127.0.0.1:8936/live/livestream.flv\n    # Where the [app] is \"live\" and [stream] is \"livestream\", output is:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/[app]/[stream];\n    # The listen port for stream converter.\n    # For flv converter, listen at tcp port. for example, 8936.\n    listen 8936;\n}\n```\n\n----------------------------------------\n\nTITLE: Edge Server Connection Trace\nDESCRIPTION: Search edge server logs for connection ID 108 to trace the edge-origin connection details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[108\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker with HEVC Support\nDESCRIPTION: Command to run SRS 6.0+ in Docker with HEVC support enabled. This uses the pre-configured HEVC configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:6 \\\n  ./objs/srs -c conf/hevc.flv.conf\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code\nDESCRIPTION: Command to update an existing SRS codebase using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-realtime.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Packaging SRS for Windows using NSIS\nDESCRIPTION: Command to package SRS for Windows using NSIS (Nullsoft Scriptable Install System). This script creates an installer executable with the current SRS version and Cygwin directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/windows.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"/cygdrive/c/Program Files (x86)/NSIS/makensis.exe\" \\\n    /DSRS_VERSION=$(./objs/srs -v 2>&1) \\\n    /DCYGWIN_DIR=\"C:\\cygwin64\" \\\n    packaging/nsis/srs.nsi\n```\n\n----------------------------------------\n\nTITLE: Testing WebRTC UDP Connection with netcat\nDESCRIPTION: Command to test the WebRTC UDP connection by sending STUN packets to the SRS server using netcat, useful for checking UDP connectivity.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\necho -en \"\\x00\\x01\\x00\\x50\\x21\\x12\\xa4\\x42\\x74\\x79\\x6d\\x7a\\x41\\x51\\x2b\\x2f\\x4a\\x4b\\x77\\x52\\x00\\x06\\x00\\x0d\\x36\\x70\\x6b\\x31\\x31\\x33\\x38\\x36\\x3a\\x4a\\x38\\x58\\x37\\x00\\x00\\x00\\xc0\\x57\\x00\\x04\\x00\\x01\\x00\\x0a\\x80\\x2a\\x00\\x08\\xda\\xad\\x1d\\xce\\xe8\\x95\\x5a\\x83\\x00\\x24\\x00\\x04\\x6e\\x7f\\x1e\\xff\\x00\\x08\\x00\\x14\\x56\\x8f\\x1e\\x1e\\x4f\\x5f\\x17\\xf9\\x2e\\xa1\\xec\\xbd\\x51\\xd9\\xa2\\x27\\xe4\\xfd\\xda\\xb1\\x80\\x28\\x00\\x04\\x84\\xd3\\x5a\\x79\" \\\n  |nc -w 3 -u 127.0.0.1 8000 |od -Ax -c -t x1 |grep '000' && \\\n  echo \"Success\" || echo \"Failed\"\n```\n\n----------------------------------------\n\nTITLE: Running SRS with SRT Support Using Docker\nDESCRIPTION: This command runs SRS in a Docker container with ports 1935 (RTMP), 8080 (HTTP), and 10080 (SRT/UDP) exposed, using the SRT configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 -p 10080:10080/udp ossrs/srs:5 \\\n  ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing SRT Stream using FFmpeg\nDESCRIPTION: Command to publish an SRT stream to SRS using FFmpeg with specific SRT parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source - Bash\nDESCRIPTION: This snippet configures the SRS build and compiles the server binaries. Required dependencies include a proper build environment with GCC and make. The './configure' script prepares the build settings, and 'make' carries out the compilation. Output artifacts will be generated in the project directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-realtime.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS2 Origin Server for Stream Forwarding\nDESCRIPTION: This configuration snippet sets up an SRS v2 origin server to automatically forward all incoming streams within the default virtual host to a specified remote SRS edge server listening on `xxx:19350`. This is useful for distributing streams from a central origin to edge servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_0\n\nLANGUAGE: srs_conf\nCODE:\n```\n    vhost __defaultVhost__ {\n           forward         xxx:19350;\n    }\n```\n\n----------------------------------------\n\nTITLE: Listing Generated Snapshot Files\nDESCRIPTION: Command to list the thumbnail PNG files generated by the snapshot process. Shows the file sizes and timestamps of the snapshots, including the symbolic link to the best quality image.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwinlin:srs winlin$ ls -lh research/api-server/static-dir/live/*.png\n-rw-r--r--  1 winlin  staff    73K Oct 20 13:35 livestream-001.png\n-rw-r--r--  1 winlin  staff    91K Oct 20 13:35 livestream-002.png\n-rw-r--r--  1 winlin  staff    11K Oct 20 13:35 livestream-003.png\n-rw-r--r--  1 winlin  staff   167K Oct 20 13:35 livestream-004.png\n-rw-r--r--  1 winlin  staff   172K Oct 20 13:35 livestream-005.png\n-rw-r--r--  1 winlin  staff   264K Oct 20 13:35 livestream-006.png\nlrwxr-xr-x  1 winlin  staff   105B Oct 20 13:35 livestream-best.png -> livestream-006.png\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Service for SRS with LoadBalancer\nDESCRIPTION: Kubernetes manifest to create a LoadBalancer service that exposes SRS streaming ports (1935, 1985, 8080) to the internet through an external IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: SRS HLS Origin Server Configuration - Nginx Config (SRS conf syntax)\nDESCRIPTION: This configuration snippet sets up SRS to listen for RTMP streams and generate HLS segments, with HTTP server enabled on port 8080. The configuration disables log files in favor of console output and sets HLS parameters. Intended to be saved as 'conf/hls.origin.conf' or similar. Requires a working SRS binary.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\n# conf/hls.origin.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nhttp_server {\n    enabled         on;\n    listen          8080;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_ctx off;\n        hls_ts_ctx off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC TCP Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC over TCP configuration, enabling TCP transport on port 8000 and setting up candidate IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080 -p 1985:1985 -p 8000:8000 \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8000 \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC Auto Detection in SRS\nDESCRIPTION: Controls automatic detection of ATC (Absolute Time Code) from metadata. When enabled, SRS detects the bravo_atc=\"true\" in onMetaData packets and automatically sets ATC mode to on if matched.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_10\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS HTTP Notification\nDESCRIPTION: Configuration for HTTP hooks when HLS TS files are created, used for CDN integration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_8\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    http_hooks {\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Server Monitoring Commands\nDESCRIPTION: Commands for monitoring server processes, connections and bandwidth usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nsrs_pid=$(pidof srs); \\\nnginx_pid=`ps aux|grep nginx|grep worker|awk '{print $2}'`; \\\nload_pids=`ps aux|grep objs|grep sb_rtmp_load|awk '{ORS=\",\";print $2}'`; \\\ntop -p $load_pids$srs_pid,$nginx_pid\n```\n\n----------------------------------------\n\nTITLE: Basic Nginx Configuration for RTMP Server\nDESCRIPTION: An example snippet for an Nginx configuration file (`nginx.conf`). It sets the worker process user, number of worker processes, connection limit, and defines an RTMP server block listening on port 19350 with a 'live' application enabled for live streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_36\n\nLANGUAGE: nginx\nCODE:\n```\nuser  root;\nworker_processes  1;\nevents {\n    worker_connections  10240;\n}\nrtmp{\n    server{\n        listen 19350;\n        application live{\n            live on;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: GPROF Profiling Commands\nDESCRIPTION: Commands for building and running SRS with GNU GPROF profiling enabled, including analysis of results.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GPROF\n./configure --gprof=on && make\n\n# Start SRS with GPROF\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop GPROF\nkillall -2 srs\n\n# To analysis result.\ngprof -b ./objs/srs gmon.out\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callbacks with PHP\nDESCRIPTION: This PHP script demonstrates handling an SRS HTTP callback by reading the raw POST request body using `file_get_contents('php://input')`. It decodes the received JSON payload using `json_decode` and attempts to print the resulting object/array using `printf` (which might not display structured data correctly; `print_r` or `var_dump` would be better for inspection). Finally, it echoes the required JSON response `{\"code\":0, \"msg\":\"OK\"}` after JSON encoding an associative array, signaling success to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_4\n\nLANGUAGE: php\nCODE:\n```\n$body = json_decode(file_get_contents('php://input'));\nprintf($body);\n\necho json_encode(array(\"code\"=>0, \"msg\"=>\"OK\"));\n```\n\n----------------------------------------\n\nTITLE: Pushing MPEGTS Stream to SRS using FFmpeg - Bash Command - Bash\nDESCRIPTION: This command uses FFmpeg to ingest a local FLV file and output it as an MPEGTS stream to a specified UDP port (here, 8935). The stream is sent to the local SRS instance's stream converter for real-time transcoding or forwarding to RTMP. Requires FFmpeg to be installed, source .flv file to exist, and SRS configured/listening on the specified UDP port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/streamer.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy -f mpegts udp://127.0.0.1:8935\n```\n\n----------------------------------------\n\nTITLE: Embedding HLS m3u8 in HTML5 Video Tag (HTML)\nDESCRIPTION: This HTML snippet shows how to embed an HLS m3u8 URL into a web page using the HTML5 <video> element for playback. It is suitable for platforms (such as iOS and Android 3.0+) with built-in HLS support in browsers. Specify the video source 'src' property to point to the m3u8 URL, and include the MIME type 'application/vnd.apple.mpegurl'. Inputs are the HLS stream URL, and output is embedded video playback when supported.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!-- livestream.html -->\\n<video width=\\\"640\\\" height=\\\"360\\\"\\n        autoplay controls autobuffer \\n        src=\\\"http://demo.srs.com/live/livestream.m3u8\\\"\\n        type=\\\"application/vnd.apple.mpegurl\\\">\\n</video>\n```\n\n----------------------------------------\n\nTITLE: Analyzing GPERF Heap Data Interactively with pprof in Bash\nDESCRIPTION: Demonstrates executing the modified `pprof` command (from the gmc hint, adjusted to use `./objs/pprof` and without `--gv`) and entering the interactive pprof shell. The `top` command within pprof lists the functions allocating the most objects still in use at the end of the program execution, aiding in leak detection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@centos6 srs]$ ./objs/pprof ./objs/srs \"/tmp/srs.11469._main_-end.heap\" --inuse_objects --lines --heapcheck  --edgefraction=1e-10 --nodefraction=1e-10\nUsing local file ./objs/srs.\nUsing local file /tmp/srs.11469._main_-end.heap.\nWelcome to pprof!  For help, type 'help'.\n(pprof) top\nTotal: 9 objects\n       3  33.3%  33.3%        3  33.3% _st_netfd_new /home/winlin/srs/objs/st-1.9/io.c:136\n       3  33.3%  66.7%        3  33.3% _st_stack_new /home/winlin/srs/objs/st-1.9/stk.c:78\n       2  22.2%  88.9%        2  22.2% st_cond_new /home/winlin/srs/objs/st-1.9/sync.c:158\n       1  11.1% 100.0%        1  11.1% SrsPithyPrint::create_ingester /home/winlin/srs/src/app/srs_app_pithy_print.cpp:139\n       0   0.0% 100.0%        4  44.4% SrsAsyncCallWorker::start /home/winlin/srs/src/app/srs_app_async_call.cpp:70\n       0   0.0% 100.0%        4  44.4% SrsConnection::cycle /home/winlin/srs/src/app/srs_app_conn.cpp:88\n       0   0.0% 100.0%        2  22.2% SrsDvr::initialize /home/winlin/srs/src/app/srs_app_dvr.cpp:980\n       0   0.0% 100.0%        2  22.2% SrsDvrPlan::initialize /home/winlin/srs/src/app/srs_app_dvr.cpp:570\n       0   0.0% 100.0%        2  22.2% SrsHls::initialize /home/winlin/srs/src/app/srs_app_hls.cpp:1214\n       0   0.0% 100.0%        2  22.2% SrsHlsMuxer::initialize /home/winlin/srs/src/app/srs_app_hls.cpp:370\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Handling HTTP 404 API Errors with SRS - Bash (curl usage and output)\nDESCRIPTION: This demonstration uses curl with verbose mode to show an HTTP 404 error from the SRS HTTP API. The HTTP response headers indicate a 404 status with a short plaintext body. No JSON payload is returned, and user agents should handle such non-200 HTTP returns as API errors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n```\\nwinlin:~ winlin$ curl -v http://127.0.0.1:1985 && echo \"\"\\n< HTTP/1.1 404 Not Found\\n< Connection: Keep-Alive\\n< Content-Length: 9\\n< Content-Type: text/plain; charset=utf-8\\n< Server: SRS/2.0.184\\n< \\nNot Found\\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server - Bash/SRS Config\nDESCRIPTION: This snippet provides a configuration file for deploying an SRS edge server that pulls streams from defined origins. It sets the listening port, connection limits, PID file, disables daemon mode, and establishes the edge cluster configuration with the associated origin servers. Used as input config for edge SRS instance, outputting an edge server ready to pull streams from origins.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.edge.conf\\nlisten              1935;\\nmax_connections     1000;\\npid                 objs/edge.pid;\\ndaemon              off;\\nsrs_log_tank        console;\\nvhost __defaultVhost__ {\\n    cluster {\\n        mode            remote;\\n        origin          127.0.0.1:19351 127.0.0.1:19350;\\n    }\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Full Request and Response Format\nDESCRIPTION: Specifies the format for HTTP 1.0 full request and response messages including request line, headers and body structure.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_15\n\nLANGUAGE: http\nCODE:\n```\nFull-Request   = Request-Line             ; Section 5.1\n                        *( General-Header        ; Section 4.3\n                         | Request-Header        ; Section 5.2\n                         | Entity-Header )       ; Section 7.1\n                        CRLF\n                        [ Entity-Body ]          ; Section 7.2\n\nFull-Response  = Status-Line              ; Section 6.1\n                        *( General-Header        ; Section 4.3\n                         | Response-Header       ; Section 6.2\n                         | Entity-Header )       ; Section 7.1\n                        CRLF\n                        [ Entity-Body ]          ; Section 7.2\n```\n\n----------------------------------------\n\nTITLE: Pushing a Stream to SRS via SRT Using FFmpeg (Bash)\nDESCRIPTION: This snippet shows how to use FFmpeg to push a live stream in FLV format to the SRS server using the SRT protocol. The command reads from a local FLV file, copies the codecs, sets a PES payload size of 0 for the MPEG-TS stream, and outputs to an SRT URL indicating the publishing stream and stream ID. FFmpeg is a dependency and must be installed. Input is a source FLV file, and output is a live SRT stream for consumption by compatible players.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/srt.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Building and Running SRS with Google Memory Checker (GMC)\nDESCRIPTION: Commands to build SRS with Google Memory Checker, run it, and analyze memory leaks. GMC helps identify memory leaks by tracking heap allocations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GMC\n./configure --gperf=on --gmc=on && make\n\n# Start SRS with GMC\nenv PPROF_PATH=./objs/pprof HEAPCHECK=normal ./objs/srs -c conf/console.conf 2>gmc.log \n\n# Or CTRL+C to stop gmc\nkillall -2 srs\n\n# To analysis memory leak\ncat gmc.log\n```\n\n----------------------------------------\n\nTITLE: NGINX Proxy Configuration for HTTP-FLV\nDESCRIPTION: NGINX location configuration to proxy HTTP-FLV requests to an SRS Edge server, allowing NGINX to handle HLS while SRS Edge handles FLV.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# For SRS streaming, for example:\n#   http://r.ossrs.net/live/livestream.flv\nlocation ~ /.+/.*\\.(flv)$ {\n   proxy_pass http://127.0.0.1:8080$request_uri;\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Request Format for on_publish Event\nDESCRIPTION: Example of the HTTP request format used when SRS sends an on_publish callback. Shows the JSON payload structure containing stream and client information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nPOST /api/v1/streams HTTP/1.1\nContent-Type: application-json\n\nBody:\n{\n  \"server_id\": \"vid-0xk989d\",\n  \"action\": \"on_publish\",\n  \"client_id\": \"341w361a\",\n  \"ip\": \"127.0.0.1\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"tcUrl\": \"rtmp://127.0.0.1:1935/live?vhost=__defaultVhost__\",\n  \"stream\": \"livestream\",\n  \"param\": \"\",\n  \"stream_url\": \"video.test.com/live/livestream\",\n  \"stream_id\": \"vid-124q9y3\"\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Master Server Configuration\nDESCRIPTION: Configuration file for SRS master server showing forward settings to multiple slave servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/forward.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 192.168.1.6:1935 192.168.1.6:1936 192.168.1.7:1935 192.168.1.7:1936;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the real-time configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/realtime.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing a Live Stream using FFMPEG (Bash)\nDESCRIPTION: Uses the FFMPEG tool (located within the SRS build directory) in a continuous loop to publish a local FLV file (`./doc/source.flv`) as a live RTMP stream to the SRS server. The `-re` flag reads the input at its native frame rate, `-c copy` streams the content without re-encoding, and `-f flv` specifies the output format. The stream is published to `rtmp://192.168.1.170/live/livestream`. A one-second pause is added between publishing attempts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS Origin/Edge\nDESCRIPTION: Bash script using FFmpeg to continuously publish a stream to the SRS origin or edge server. It loops the source video and republishes if the connection is lost.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: NGINX as HLS Origin Server Configuration\nDESCRIPTION: NGINX configuration to serve HLS files directly from a filesystem path, specifying different cache control headers for m3u8 playlists and ts segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n  # For HLS delivery\n  location ~ /.+/.*\\.(m3u8)$ {\n    root /usr/local/srs/objs/nginx/html;\n    add_header Cache-Control \"public, max-age=10\";\n  }\n  location ~ /.+/.*\\.(ts)$ {\n    root /usr/local/srs/objs/nginx/html;\n    add_header Cache-Control \"public, max-age=86400\";\n  }\n```\n\n----------------------------------------\n\nTITLE: RTMP Server Configurations for nginx-rtmp (bash/conf)\nDESCRIPTION: Example nginx.conf for nginx-rtmp deployment supporting up to 10240 connections and one worker process, also enabling a simple live RTMP application. Used in perf testing scenarios, with comments providing context.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nuser  root;\nworker_processes  1;\nevents {\n    worker_connections  10240;\n}\nrtmp{\n    server{\n        listen 19350;\n        application live{\n            live on;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Live Stream to SRS using FFmpeg (Bash)\nDESCRIPTION: Demonstrates how to use FFmpeg to push a local FLV file ('./doc/source.flv') as a live stream to the SRS server running on localhost. The stream is published to the 'live' application with the name 'livestream' via RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx for RTMP Streaming (Nginx)\nDESCRIPTION: Nginx configuration (`_release/conf/nginx.conf`) setting up a basic RTMP server. It specifies running as root, using one worker process, allowing up to 10240 connections per worker, and defining an RTMP server listening on port 19350 with a 'live' application enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\nuser  root;\nworker_processes  1;\nevents {\n    worker_connections  10240;\n}\nrtmp{\n    server{\n        listen 19350;\n        application live{\n            live on;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling HTTPS-FLV Streaming on SRS (conf)\nDESCRIPTION: This configuration expands the basic HTTP-FLV example to include HTTPS live streaming, listening on port 8088 with specified key and cert files. It enables both HTTP (8080) and HTTPS (8088), requiring a server certificate and key under ./conf/. Dependencies: SRS, SSL certificate and key files. Key parameters: http_server.https.enabled ('on'), .listen (8088), .key (SSL key path), and .cert (SSL cert path). Enables delivery of RTMP streams as both HTTP and HTTPS FLV. Limitation: Appropriate cert/key required.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-http-flv.md#2025-04-23_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\nhttp_server {\n    enabled         on;\n    listen          8080;\n    https {\n        enabled on;\n        listen 8088;\n        key ./conf/server.key;\n        cert ./conf/server.crt;\n    }\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker with WebRTC over TCP on Port 8080\nDESCRIPTION: This Docker command runs SRS 5.0.60 with WebRTC over TCP enabled on port 8080. It configures the candidate IP, HTTP API, and RTC server settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080/tcp \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_HTTP_API_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server for Stream Forwarding\nDESCRIPTION: SRS2 configuration for setting up an origin server to forward streams to an edge server. The configuration defines the default vhost and specifies a forward destination address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n    vhost __defaultVhost__ {\n           forward         xxx:19350;\n    }\n```\n\n----------------------------------------\n\nTITLE: Building SRS using configure and make in Shell\nDESCRIPTION: This shell command compiles the SRS server by running the provided configure script and then 'make'. No additional dependencies are required beyond standard build tools (gcc, make, etc.). Run this command from the project root directory to prepare and build the server. The script auto-detects environment settings for SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/install.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callbacks with Node.js and Koa\nDESCRIPTION: This Node.js snippet utilizes the Koa framework and `koa-router` to define an asynchronous route handler for all HTTP methods (`router.all`) on the `/api/v1/streams` path. It logs the received request body (which Koa automatically parses if middleware like `koa-bodyparser` is used, implicitly assumed here) containing the SRS callback JSON payload to the console. It then sets the response body to the required JSON object `{\"code\": 0, \"msg\": \"OK\"}` to signal successful handling to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst Router = require('koa-router');\nconst router = new Router();\n\nrouter.all('/api/v1/streams', async (ctx) => {\n  console.log(ctx.request.body);\n\n  ctx.body = {code: 0, msg: 'OK'};\n});\n```\n\n----------------------------------------\n\nTITLE: Setting SRS Log Level\nDESCRIPTION: Configuration for controlling log verbosity level from verbose (most detailed) to error (critical issues only). Lower levels automatically include higher severity logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# the log level, for all log tanks.\n# can be: verbose, info, trace, warn, error\n# default: trace\nsrs_log_level       trace;\n```\n\n----------------------------------------\n\nTITLE: Using PERF to Analyze SRS Performance Bottlenecks\nDESCRIPTION: Command to show real-time performance bottlenecks in SRS using Linux's perf tool. This identifies which functions are consuming the most CPU.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nperf top -p $(pidof srs)\n```\n\n----------------------------------------\n\nTITLE: HTTP API Authentication Using Environment Variables\nDESCRIPTION: Example of setting HTTP API authentication credentials using environment variables when starting SRS with the -e flag.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nenv SRS_HTTP_API_ENABLED=on SRS_HTTP_SERVER_ENABLED=on \\\n    SRS_HTTP_API_AUTH_ENABLED=on SRS_HTTP_API_AUTH_USERNAME=admin SRS_HTTP_API_AUTH_PASSWORD=admin \\\n    ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: SRS Benchmark Configuration\nDESCRIPTION: Example configuration used for latency benchmarking in SRS, including HLS settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    enabled         on;\n    play {\n        gop_cache       off;\n    }\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    5;\n        hls_window      20;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with MPEG-TS Configuration in Bash\nDESCRIPTION: Command to start SRS server with a configuration file for handling MPEG-TS streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/streamer.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/push.mpegts.over.udp.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Hook for HLS TS File Notification\nDESCRIPTION: Specifies a URL to which SRS will send an HTTP GET request whenever a new HLS Transport Stream (.ts) file is created (reaped). This hook is commonly used to notify a CDN or other system about the availability of the new segment. Variables like `[app]`, `[stream]`, and `[ts_url]` are replaced in the URL. SRS randomly selects one URL if multiple are provided and ignores the response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    http_hooks {\n        # when srs reap a ts file of hls, call this hook,\n        # used to push file to cdn network, by get the ts file from cdn network.\n        # so we use HTTP GET and use the variable following:\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [ts_url], replace with the ts url.\n        # ignore any return data of server.\n        # @remark random select a url to report, not report all.\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS on ARM Server using Shell Commands - Shell\nDESCRIPTION: This snippet demonstrates how to configure and build the SRS server natively on an ARM server (either armv7 or armv8/aarch64) using the provided configure script and make utility. No cross-compilation is performed here. Prerequisites include having the SRS source code, build dependencies, and shell access to the ARM host. Outputs compiled SRS binaries in the objs directory. Limitations: Only suitable for native ARM environments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n```\n./configure && make\n```\n```\n\n----------------------------------------\n\nTITLE: Building libx265 from Source\nDESCRIPTION: Commands to clone and build libx265 from source code, which is essential for HEVC encoding support in FFmpeg. This configures x265 with CMake and builds static libraries.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://bitbucket.org/multicoreware/x265_git.git ~/git/x265_git\ncd ~/git/x265_git/build/linux\ncmake -DCMAKE_INSTALL_PREFIX=$(pwd)/build -DENABLE_SHARED=OFF ../../source\nmake -j10\nmake install\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC in SRS RTMP Server\nDESCRIPTION: Configuration example for enabling ATC (Absolute Time Control) in SRS. This shows how to configure the play section in a vhost to support ATC for HLS/HDS/RTMP backup scenarios.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp-atc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        # \n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # default: off\n        atc             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting First Packet Timeout\nDESCRIPTION: Configuration for setting the timeout duration for the first packet from FMLE/Flash publishers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        firstpkt_timeout    20000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Rotating SRS Log File using Shell Commands\nDESCRIPTION: Describes the manual process for rotating the SRS log file. First, the current log file is moved to a timestamped temporary file. Then, the SIGUSR1 signal is sent to all running SRS processes, prompting them to close the old log file descriptor and reopen the original `srs.log` path, effectively starting a new log file. The old, moved log file can then be processed (e.g., compressed or deleted).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmv objs/srs.log /tmp/srs.`date +%s`.log\n```\n\nLANGUAGE: shell\nCODE:\n```\nkillall -s SIGUSR1\n```\n\n----------------------------------------\n\nTITLE: Complete FFmpeg Command for AI Transcript Overlay\nDESCRIPTION: Full FFmpeg command used by Oryx to overlay AI transcripts on video streams, including input file, subtitle filter, video and audio codec parameters, and output file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg \\\n    -i transcript/2-org-4f06f7a5-7f83-4845-9b4b-716ffec1bead.ts \\\n    -vf subtitles=transcript/2-audio-a982892f-1d56-4b4a-a663-f3b7f1a5b548.srt:force_style='Alignment=2,MarginV=20' \\\n    -c:v libx264 -profile:v main -preset:v medium -tune zerolatency -bf 0 \\\n    -c:a aac -copyts \\\n    -y transcript/2-overlay-2ba4154c-03ed-4853-bdda-d8396fcb1f47.ts\n```\n\n----------------------------------------\n\nTITLE: Configuring Referer-based Anti-Hotlinking in SRS\nDESCRIPTION: This snippet demonstrates how to configure referer-based anti-hotlinking in SRS. It shows the setup for a vhost with referer checks enabled for both publish and play actions, specifying allowed domains.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/drm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the vhost for anti-suck.\nvhost refer.anti_suck.com {\n    # refer hotlink-denial.\n    refer {\n        # whether enable the refer hotlink-denial.\n        # default: off.\n        enabled         on;\n        # the common refer for play and publish.\n        # if the page url of client not in the refer, access denied.\n        # if not specified this field, allow all.\n        # default: not specified.\n        all           github.com github.io;\n        # refer for publish clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        publish   github.com github.io;\n        # refer for play clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        play      github.com github.io;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming HEVC Video via SRT using FFmpeg\nDESCRIPTION: Command to push an HEVC-encoded video stream using SRT protocol with FFmpeg. It converts the input video to HEVC codec and transmits it over SRT.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/srt-codec.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i source.mp4 -c:v libx265 -c:a copy -pes_payload_size 0 -f mpegts 'srt://127.0.0.1:10080?streamid=livestream'\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin Server for Edge Cluster\nDESCRIPTION: This command starts an SRS Origin server using the specified configuration file (`conf/origin.conf`). This Origin server will be the source from which the previously started Edge servers will pull streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing a Stream using FFMPEG (Bash Loop)\nDESCRIPTION: Uses the FFMPEG binary (located within the SRS build directory) to continuously publish a local video file ('./doc/source.flv') to the SRS server via RTMP. The '-re' flag simulates a real-time stream, '-c copy' copies codecs without re-encoding, and the loop ensures the stream restarts if FFMPEG exits. Replace '192.168.1.170' with the actual server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with HLS Configuration\nDESCRIPTION: This command runs an SRS Docker container with HLS configuration. It maps ports 1935 and 8080, and uses the hls.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  ./objs/srs -c conf/hls.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to Proxy Server with FFmpeg\nDESCRIPTION: FFmpeg command to publish an RTMP stream to the proxy server using a sample video file with copy codec.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Pushing Stream to Origin Server Using FFmpeg\nDESCRIPTION: FFmpeg command loop to continuously push a sample video to the origin server. This demonstrates how to publish a stream that will be distributed through the cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Changing SRS Threads CPU Affinity (bash)\nDESCRIPTION: Pins all SRS process threads (using the pid from objs/srs.pid) to CPUs except CPU0 by using taskset's hexadecimal mask (0xfe). This is typically paired after assigning all softirqs to CPU0. Prerequisite: SRS must be running and storing its PID in objs/srs.pid. Outcome: Reduces contention between kernel networking and SRS data-processing threads.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -a -p 0xfe $(cat objs/srs.pid)\n```\n\n----------------------------------------\n\nTITLE: Checking UDP Queue Length\nDESCRIPTION: Command to display UDP socket information including queue lengths. This helps identify if packets are being queued or dropped due to buffer limitations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnetstat -lpun\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Parameters for SRS Live Stream - Text\nDESCRIPTION: Specifies the RTMP server (FMS) URL and stream name to configure in FMLE for publishing a live stream to the SRS origin. Input these parameters into the FMLE software; output is the live stream available at the specified SRS endpoints.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Installing SRS with systemctl on Ubuntu 20\nDESCRIPTION: Complete commands to install SRS and set it up as a systemctl service on Ubuntu 20, enabling automatic startup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && sudo make install &&\nsudo ln -sf /usr/local/srs/etc/init.d/srs /etc/init.d/srs &&\nsudo cp -f /usr/local/srs/usr/lib/systemd/system/srs.service /usr/lib/systemd/system/srs.service &&\nsudo systemctl daemon-reload && sudo systemctl enable srs\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT Server for Low Latency Mode in Bash\nDESCRIPTION: This snippet shows the recommended SRT server configuration for low latency mode, assuming an RTT of 100ms. It sets various parameters to optimize for minimal delay while allowing some packet loss tolerance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    connect_timeout 4000;\n    peerlatency 300; # RTT * 3\n    recvlatency 300; # RTT * 3\n    latency 300; # RTT * 3\n    tlpktdrop on;\n    tsbpdmode on;\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for SRT\nDESCRIPTION: Docker command to run SRS with SRT (Secure Reliable Transport) protocol support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 10080:10080/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Checking Kubernetes Cluster Information\nDESCRIPTION: Command to verify access to a Kubernetes cluster by displaying cluster information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkubectl cluster-info\n```\n\n----------------------------------------\n\nTITLE: Compiling NGINX with RTMP Module (bash)\nDESCRIPTION: Configures and builds nginx with the rtmp module and HTTP SSL support, generating a local release installation. Uses relative paths and make. Prerequisites: nginx-1.5.7 source, nginx-rtmp-module-1.0.4 source, GNU build tools available.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n./configure --prefix=`pwd`/../_release \\\n--add-module=`pwd`/../nginx-rtmp-module-1.0.4 \\\n--with-http_ssl_module && make && make install\n```\n\n----------------------------------------\n\nTITLE: Analyzing Network Statistics and UDP Packet Drops\nDESCRIPTION: Uses netstat to query network statistics and monitor UDP packet drops, which is crucial for diagnosing performance issues in RTC applications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnetstat -suna\nnetstat -suna && sleep 30 && netstat -suna\n```\n\n----------------------------------------\n\nTITLE: Basic WebRTC Browser-to-Browser Communication Diagram\nDESCRIPTION: ASCII diagram showing basic WebRTC communication between two browsers, illustrating signaling and media paths\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +----------------+\n+    Browser     +----<--Signaling----->--+    Browser     +\n+ (like Chrome)  +----<----Media----->----+ (like Chrome)  +\n+----------------+                        +----------------+\n```\n\n----------------------------------------\n\nTITLE: Creating HEVC MP4 File for MSE Testing\nDESCRIPTION: Command to convert a source FLV file to HEVC-encoded MP4 for testing browser compatibility with Media Source Extensions (MSE). Uses libx265 for encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -i ~/git/srs/trunk/doc/source.flv -acodec copy \\\n  -vcodec libx265 -y source.hevc.mp4\n```\n\n----------------------------------------\n\nTITLE: Illustrating RTMP to FLV/MP4 Workflow in ASCII Diagram\nDESCRIPTION: A text-based diagram showing how RTMP streams from FFmpeg/OBS are processed by SRS and recorded to FLV/MP4 files via the DVR feature.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+------------+            +-------+           +---------------+\n+ FFmpeg/OBS +---RTMP-->--+  SRS  +---DVR-->--+ FLV/MP4 File  +\n+------------+            +-------+           +---------------+\n```\n\n----------------------------------------\n\nTITLE: Inspecting SRS Edge Pods and Connections in Kubernetes\nDESCRIPTION: This set of Bash commands demonstrates how to inspect the status and connections of SRS edge pods running in Kubernetes. `kubectl get po | grep edge` lists the pods associated with the edge deployment. `kubectl exec <pod-name> -- ./objs/srs -v` retrieves the SRS version running inside a specific pod. `kubectl exec <pod-name> -- yum install -y net-tools` installs network utilities inside the pod (if needed). `kubectl exec <pod-name> -- netstat -anp | grep 1935` shows active network connections on port 1935 within the pod, helping to identify client and origin connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get po|grep edge\nsrs-edge-deploy-58d9999b7c-pnr2f       1/1     Running   0          16s\nsrs-edge-deploy-58d9999b7c-z9gbm       1/1     Running   0          16s\n\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- ./objs/srs -v\n4.0.5\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- yum install -y net-tools\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- netstat -anp|grep 1935\ntcp        0      0 0.0.0.0:1935            0.0.0.0:*               LISTEN      1/./objs/srs\n\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- ./objs/srs -v\n4.0.5\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- yum install -y net-tools\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- netstat -anp|grep 1935\ntcp        0      0 0.0.0.0:1935            0.0.0.0:*               LISTEN      1/./objs/srs\ntcp        0      0 172.20.0.62:46482       172.20.0.41:1935        ESTABLISHED 1/./objs/srs\ntcp        0      0 172.20.0.62:1935        172.20.0.1:12066        ESTABLISHED 1/./objs/srs\n```\n\n----------------------------------------\n\nTITLE: Pushing RTMP Stream to SRS Edge using FFmpeg (Bash)\nDESCRIPTION: This command uses `ffmpeg` to push a local FLV file (`./doc/source.flv`) as an RTMP stream to the SRS edge server's public EIP (`rtmp://28.170.32.118/live/livestream`). The `-re` flag reads the input at its native frame rate, simulating a live source. The `-c copy` option avoids re-encoding, simply copying the existing streams. This command is used to establish a long-running connection to the edge server for testing graceful shutdown during updates. The placeholder IP `28.170.32.118` should be replaced with the actual external IP of the SRS edge service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://28.170.32.118/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Building SRS on ARM Server\nDESCRIPTION: Basic commands to build SRS directly on an ARM server. Shows both standard build and docker-based build approaches.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Minimal Successful HTTP Callback Response (HTTP)\nDESCRIPTION: Illustrates the minimal required HTTP response format for a successful SRS callback. The callback handler must return an HTTP/1.1 200 OK status code, and the response body must contain the integer 0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_7\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 200 OK\nContent-Length: 1\n0\n```\n\n----------------------------------------\n\nTITLE: Configuring UTC Time Usage in SRS\nDESCRIPTION: Determines whether SRS uses UTC time or local time for generating time structures. When enabled, SRS uses gmtime() which operates on UTC time; when disabled, it uses localtime() which uses the server's local timezone.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n# whether use utc_time to generate the time struct,\n# if off, use localtime() to generate it,\n# if on, use gmtime() instead, which use UTC time.\n# default: off\nutc_time            off;\n```\n\n----------------------------------------\n\nTITLE: Implementing Coroutine-Native SRT Socket Receive Method\nDESCRIPTION: Implementation of the SrsSrtSocket::recvmsg method which makes SRT protocol coroutine-native. This function handles I/O waiting by switching coroutines, similar to how st_read works for TCP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsSrtSocket::recvmsg(void* buf, size_t size, ssize_t* nread) {\n  while (true) {\n    int ret = srt_recvmsg(srt_fd_, (char*)buf, size);\n    if (ret >= 0) { // Receive message ok.\n      recv_bytes_ += ret; \n      *nread = ret;\n      return err;\n    }\n    \n    // Got something error, return immediately.\n    if (srt_getlasterror(NULL) != SRT_EASYNCRCV) {\n      return srs_error_new(ERROR_SRT_IO, \"srt_recvmsg\");\n    }\n    \n    // Wait for the fd ready or error, switch to other coroutines.\n    if ((err = wait_readable()) != srs_success) { // EAGAIN.\n      return srs_error_wrap(err, \"wait readable\");\n    }\n  }\n  \n  return err;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Second SRS Edge Server on Same Port\nDESCRIPTION: This command starts a second SRS Edge server instance on the same machine, listening on the same port (e.g., 1935) as the first instance, leveraging the SO_REUSEPORT feature. Requires Linux Kernel 3.9+ and a separate configuration file (`conf/edge2.conf`) specifying a different PID file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge2.conf\n```\n\n----------------------------------------\n\nTITLE: Starting Ubuntu Docker for HiSilicon Cross-Compilation\nDESCRIPTION: Command to start an Ubuntu Docker container for cross-compiling SRS for HiSilicon ARMv7 platforms, mounting the current directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -v $(pwd):/srs -w /srs/trunk \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:ubuntu20 bash\n```\n\n----------------------------------------\n\nTITLE: Stream-Specific Transcoding Configuration\nDESCRIPTION: Configuration example showing how to apply transcoding to specific streams within an application in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode stream name is \"livestream\" and app is \"live\"\n    transcode live/livestream{\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting HLS Output Paths and File Naming - Bash\nDESCRIPTION: This configuration snippet showcases how to set up the output directory and file templates for m3u8 and ts files for a given RTMP stream in SRS's HLS subsystem. It provides default variable substitutions used in the filenames, ensuring streams can be easily located based on app and stream names. Configuration must be placed under the appropriate vhost in the SRS config. No external dependencies are required beyond SRS itself.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhls_path        /data/nginx/html;\nhls_m3u8_file   [app]/[stream].m3u8;\nhls_ts_file     [app]/[stream]-[seq].ts;\n```\n\n----------------------------------------\n\nTITLE: Calculating HLS Window Size Based on TS Durations\nDESCRIPTION: This simple mathematical formula shows how the relationship between hls_window and the sum of TS segment durations is enforced by SRS to maintain the specified window size.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nhls_window >= sum(duration of each ts in m3u8)\n```\n\n----------------------------------------\n\nTITLE: Configuring Kubernetes Service Ports for SRS Edge\nDESCRIPTION: This YAML snippet defines port mappings within a Kubernetes Service configuration for an SRS edge server. It maps external port 1935 (RTMP) to the container's targetPort 1935 using TCP, and external port 8080 (HTTP-FLV/API) to the container's targetPort 8080 using TCP. This configuration makes the SRS edge service accessible on these ports within the Kubernetes cluster or via an external LoadBalancer if configured.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-edge-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Low Latency SRT Configuration\nDESCRIPTION: Optimized SRT configuration for low latency streaming with RTT consideration\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsrt_server {\n    enabled on;\n    listen 10080;\n    connect_timeout 4000;\n    peerlatency 300;\n    recvlatency 300;\n    latency 300;\n    tlpktdrop on;\n    tsbpdmode on;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Vhosts in SRS\nDESCRIPTION: Example of configuring two basic vhosts in SRS, demonstrating how to set up multiple virtual hosts on a single server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n}\nvhost show.wasu.cn {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Master Server for Forwarding\nDESCRIPTION: This is an example configuration for an SRS master server (intended for 192.168.1.5). It listens on port `1935`, defines a PID file path (`./objs/srs.pid`), sets maximum connections, and configures forwarding within the default vhost. The `enabled on` directive activates forwarding, and `destination` lists four slave server endpoints (two ports on `192.168.1.6` and two on `192.168.1.7`) to which incoming streams will be forwarded.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/forward.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 192.168.1.6:1935 192.168.1.6:1936 192.168.1.7:1935 192.168.1.7:1936;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Version - Command Line - Shell\nDESCRIPTION: This snippet checks the installed SRS version using the '-v' flag on the compiled executable. Knowing the version is crucial for matching benchmark results to software capabilities and identifying changes across releases. Takes no inputs and returns output directly to stdout showcasing the SRS version. No external dependencies beyond the SRS binary itself.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_18\n\nLANGUAGE: shell\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -v\n0.9.130\n```\n\n----------------------------------------\n\nTITLE: aaPanel (Baota) NGINX Configuration for HLS Caching\nDESCRIPTION: Complete NGINX configuration for aaPanel (Baota) to set up an HLS caching edge server with domain name support and cache settings for m3u8 and ts files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       80;\n        server_name your.domain.com;\n\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Registering an Origin Server with the Proxy Server via HTTP API\nDESCRIPTION: Example of using curl to register an SRS origin server with the proxy server through its HTTP API, providing details like IP addresses, ports for various protocols, and server identification.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST http://127.0.0.1:12025/api/v1/srs/register \\\n     -H \"Connection: Close\" \\\n     -H \"Content-Type: application/json\" \\\n     -H \"User-Agent: curl\" \\\n     -d '{\n          \"device_id\": \"origin2\",\n          \"ip\": \"10.78.122.184\",\n          \"server\": \"vid-46p14mm\",\n          \"service\": \"z2s3w865\",\n          \"pid\": \"42583\",\n          \"rtmp\": [\"19352\"],\n          \"http\": [\"8082\"],\n          \"api\": [\"19853\"],\n          \"srt\": [\"10082\"],\n          \"rtc\": [\"udp://0.0.0.0:8001\"]\n        }'\n##{\"code\":0,\"pid\":\"53783\"}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Environment Variables\nDESCRIPTION: Command to start SRS server with WebRTC candidate address specified through environment variable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nenv CANDIDATE=\"192.168.3.10\" \\\n  ./objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Setting up Origin Server Configuration - SRS config (conf)\nDESCRIPTION: Defines the configuration for an origin SRS server to handle both RTMP and HTTP-FLV streaming on ports 1935 and 8080, respectively. Key parameters include stream remuxing, HTTP FLV path format, and log directory. Save as 'conf/http.flv.live.conf' or equivalent. Ensure specified ports are available and not blocked.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: conf\nCODE:\n```\n# conf/http.flv.live.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback: on_record_begin Event - JSON\nDESCRIPTION: Details the JSON structure for the 'on_record_begin' HTTP callback event in Oryx, sent when a recording session starts for a stream. The payload identifies the stream and includes a unique recording UUID. The server should respond with {\"code\": 0}, errors are ignored by the sender.\n\nInputs: request_id, vhost, app, stream, uuid are required. Output: JSON object with code field.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"request_id\": \"80ad1ddf-1731-450c-83ec-735ea79dd6a3\",\n  \"action\": \"on_record_begin\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n\"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Manually - Bash\nDESCRIPTION: Directly starts the SRS server using the init.d script from the project directory. No dependencies except a compiled init.d script and proper directory context. The command expects the current directory to be 'srs/trunk'. Outputs service start status or errors if SRS fails to launch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\\n./etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Proxying HTTP-FLV Streams with NGINX - NGINX\nDESCRIPTION: Sets up an NGINX location block for proxying HTTP-FLV (.flv) requests to a local SRS server. Requires NGINX with http_proxy_module and SRS instance on port 8080. Inputs: client FLV requests. Outputs: proxied FLV stream from SRS. No caching directives included; primarily for unmodified data relay from SRS Edge to clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_9\n\nLANGUAGE: nginx\nCODE:\n```\n# For SRS streaming, for example:\\n#   http://r.ossrs.net/live/livestream.flv\\nlocation ~ /.+/.*\\.(flv)$ {\\n   proxy_pass http://127.0.0.1:8080$request_uri;\\n}\n```\n\n----------------------------------------\n\nTITLE: Workflow Diagram for SRS HTTP API\nDESCRIPTION: ASCII diagram showing communication flow between client applications and SRS server using HTTP API.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+-------------------------+               +-------+\n+ Chrome/Your Application +--HTTP-API-->--+  SRS  +\n+-------------------------+               +-------+\n```\n\n----------------------------------------\n\nTITLE: SRS Slave Server Configuration (Port 1935)\nDESCRIPTION: Configuration file for SRS slave server listening on port 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/forward.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.1935.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimal Send Interval for RTMP and HTTP FLV Streams in SRS\nDESCRIPTION: Sets the minimal packet send interval in milliseconds for play clients. This controls the stream's packet delivery timing, useful for devices requiring constant interval streams. Setting to 0 disables the minimal interval.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        send_min_interval       10.0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Specified Configuration - Bash\nDESCRIPTION: This command launches the SRS server with the provided configuration file (conf/dash.conf). It assumes the build step has been completed and the executable is located at ./objs/srs. The -c flag specifies which configuration file to use. This will start SRS in the foreground using the DASH-enabled settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-dash.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/dash.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTPS Server\nDESCRIPTION: HTTPS configuration including SSL certificate and key settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-server.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    https {\n        enabled on;\n        listen 8088;\n        key ./conf/server.key;\n        cert ./conf/server.crt;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Node.js KOA Proxy Configuration\nDESCRIPTION: Node.js implementation using KOA for proxying requests to SRS HTTP server with support for various endpoints.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-server.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst Koa = require('koa');\nconst proxy = require('koa-proxies');\nconst BodyParser = require('koa-bodyparser');\nconst Router = require('koa-router');\n\nconst app = new Koa();\napp.use(proxy('/api/', {target: 'http://127.0.0.1:1985/'}));\napp.use(proxy('/rtc/', {target: 'http://127.0.0.1:1985/'}));\napp.use(proxy('/*/*.(flv|m3u8|ts|aac|mp3)', {target: 'http://127.0.0.1:8080/'}));\napp.use(proxy('/console/', {target: 'http://127.0.0.1:8080/'}));\napp.use(proxy('/players/', {target: 'http://127.0.0.1:8080/'}));\n\napp.use(BodyParser());\n\nconst router = new Router();\nrouter.all('/', async (ctx) => {\n  ctx.body = 'Hello World';\n});\napp.use(router.routes());\n\napp.listen(3000, () => {\n  console.log(`Server start on http://localhost:3000`);\n});\n```\n\n----------------------------------------\n\nTITLE: Calculating HLS TS Duration in SRS\nDESCRIPTION: Illustrates how the actual HLS Transport Stream (TS) segment duration is determined in SRS. It's the maximum value between the configured `hls_fragment` (target segment duration in seconds) and the stream's GOP (Group of Pictures) size in seconds (calculated as GOP frames divided by FPS). This calculation ensures segments align with keyframes appropriately for better stream compatibility.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nTS duration(s) = max(hls_fragment, gop_size)\nhls_fragment: The length, in seconds, per ts file, for example, 5s.\ngop_size: The stream gop size, for example, the fps is 20, gop is 200frames, then gop_size=gop/fps=10s.\nSo, the actual ts duration is max(5, 10)=10s, that is why the ts duration is larger than hls_fragment.\n```\n\n----------------------------------------\n\nTITLE: SRS Master Server Configuration\nDESCRIPTION: Configuration for the SRS master server that receives the original stream and forwards it to multiple slave servers. This setup enables distribution of a single stream to multiple destination servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 192.168.1.6:1935 192.168.1.6:1936 192.168.1.7:1935 192.168.1.7:1936;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG Log Verbosity in SRS\nDESCRIPTION: Configuration example showing how to reduce FFMPEG log verbosity using the quiet parameter in the vfilter section. This helps manage log file sizes when FFMPEG processes are running.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n                # -v quiet\n                v           quiet;\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS for WebRTC-to-RTMP Conversion in Docker (Bash)\nDESCRIPTION: This command starts an SRS container configured to convert incoming WebRTC streams to RTMP streams using `conf/rtc2rtmp.conf`. This setup is necessary for scenarios like 'Room to Live' where streams need to be processed or mixed by tools like FFmpeg. Similar to the basic setup, it requires the `CANDIDATE` environment variable and maps standard SRS ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS Using FFmpeg - FFmpeg CLI\nDESCRIPTION: This snippet uses FFmpeg to push an FLV stream to an SRS server. The command depends on a local FLV input file ('doc/source.flv'), an SRS server running and listening for RTMP streams, as well as FFmpeg installed in the environment. Key parameters include '-re' for real-time emulation, '-i' to specify the input file, '-c copy' to copy codecs, and the output RTMP URL which can include parameters for authentication. The expected result is SRS receiving the live stream and triggering HTTP callbacks as configured.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_2\n\nLANGUAGE: ffmpeg\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://localhost/live/livestream?k=v\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 4.0 Branch in Bash\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 4.0 release branch. Used when implementing or testing features specific to version 4.0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 4.0release\n```\n\n----------------------------------------\n\nTITLE: Setting Up HLS Notify HTTP Hook in SRS\nDESCRIPTION: Configures an HTTP hook to be called when SRS reaps an HLS TS file. This can be used to push files to a CDN network. The hook uses HTTP GET and includes variables for app, stream, and ts_url. One URL is randomly selected for reporting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_8\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    http_hooks {\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: PHP Callback Handler Implementation\nDESCRIPTION: Example PHP code implementing an HTTP handler for SRS callbacks with JSON response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_10\n\nLANGUAGE: php\nCODE:\n```\n$body = json_decode(file_get_contents('php://input'));\nprintf($body);\n\necho json_encode(array(\"code\"=>0, \"msg\"=>\"OK\"));\n```\n\n----------------------------------------\n\nTITLE: Sample SRS Configuration File for HTTP/HLS - Bash/Conf\nDESCRIPTION: This code provides a sample configuration file for SRS to enable the embedded HTTP server and set up HLS streaming. It defines the listen ports, connection limits, and specifics for HTTP and HLS (such as output directory, fragment length). The configuration should be saved as 'conf/http.hls.conf'. The 'hls_path' directory must exist prior to launching SRS. Key parameters include listen ports, max_connections, and HLS settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.hls.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Stream to Origin Server (Bash)\nDESCRIPTION: Bash script to continuously push a stream to the origin server using FFmpeg. This simulates a live stream input.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Building SRS Server\nDESCRIPTION: Commands to configure and build the SRS server from source.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Running SRS with DASH Support in Docker\nDESCRIPTION: This command runs a Docker container with SRS 5.0 and enables HTTP server and DASH streaming capabilities on ports 8080 and 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-11-25-DASH-Issues.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080 -p 1935:1935 \\\n  -e SRS_HTTP_SERVER_ENABLED=on -e SRS_VHOST_DASH_ENABLED=on \\\n  ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Simultaneous Translator Prompt Configuration\nDESCRIPTION: A prompt template for configuring the GPT AI assistant to function as a language translator. This prompt instructs the AI to translate text between English and Chinese in a conversational tone.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2024-01-31-Browser-Voice-Driven-GPT.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nI want you to act as a language translator.\nI want you to translate my text in conversational tone.\nI want you to strictly translate to English and Chinese.\nKeep in mind that you must translate to English and Chinese.\nRemember, never answer questions but only translate.\n```\n\n----------------------------------------\n\nTITLE: Configuring the Second Origin Server (ServerB)\nDESCRIPTION: Configuration for the second origin server in the cluster. Similar to ServerA but with different ports and references ServerA as its coworker.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverB.conf\nlisten              19351;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverB.pid;\nhttp_api {\n    enabled         on;\n    listen          9091;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9090;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning SRS Process to Specific CPU Cores (bash)\nDESCRIPTION: Uses 'taskset' to set or change CPU affinity for the SRS process, distributing SRS computation away from CPU0 to manage soft interrupt contention. Requires SRS to be running and the 'pidof' utility. Usage: 'taskset -p 0xfe $(pidof srs)' to allow execution on CPUs 1-7; or 'taskset -pc 1 $(pidof srs)' for CPU 1 only.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -p 0xfe $(pidof srs)\n```\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -pc 1 $(pidof srs)\n```\n\n----------------------------------------\n\nTITLE: Configuring UDP Kernel Parameters for RTC Performance\nDESCRIPTION: Commands to query and set kernel UDP buffer sizes to 16MB, which is critical for RTC performance over UDP. This increases both send and receive buffer sizes to handle high-volume UDP traffic.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Query the kernel configuration\nsysctl net.core.rmem_max\nsysctl net.core.rmem_default\nsysctl net.core.wmem_max\nsysctl net.core.wmem_default\n\n# Set the UDP buffer to 16MB\nsysctl net.core.rmem_max=16777216\nsysctl net.core.rmem_default=16777216\nsysctl net.core.wmem_max=16777216\nsysctl net.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: SRS Reload Command Examples\nDESCRIPTION: Various methods to trigger a configuration reload in SRS server, including using killall, direct process signal, or init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/reload.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkillall -1 srs\n```\n\nLANGUAGE: bash\nCODE:\n```\nkill -1 7635\n```\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for Latency Benchmark\nDESCRIPTION: SRS configuration used for latency benchmarking, including settings for GOP cache and HLS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    enabled         on;\n    play {\n        gop_cache       off;\n    }\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    5;\n        hls_window      20;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback: on_record_end Event - JSON\nDESCRIPTION: Defines the JSON request and response format for the 'on_record_end' HTTP callback event, indicating the completion of a stream recording. Fields include identifiers, UUID, artifact code (error/status), artifact path, and URL for the recorded media. The receiving server acknowledges with code 0. Errors in acknowledgment are ignored.\n\nInputs: All fields are required for correct event handling. Output: {\"code\": 0}. Server must be able to consume and process all supplied data fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_record_end\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"artifact_code\": 0,\n  \"artifact_path\": \"/data/record/824b96f9-8d51-4046-ba1e-a9aec7d57c95/index.mp4\",\n  \"artifact_url\": \"http://localhost/terraform/v1/hooks/record/hls/824b96f9-8d51-4046-ba1e-a9aec7d57c95/index.mp4\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Exporter Enabled\nDESCRIPTION: Command to build SRS and start it with the Prometheus exporter enabled using environment variables for configuration instead of a config file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\nenv SRS_ENV_ONLY=on SRS_EXPORTER_ENABLED=on SRS_LISTEN=1935 \\\n  ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: Testing WHIP HTTP/HTTPS API with curl\nDESCRIPTION: Command to test the WHIP HTTP or HTTPS API by sending an SDP offer to the server using curl, useful for troubleshooting connection issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:1985/rtc/v1/whip/?ice-ufrag=6pk11386&ice-pwd=l91z529147ri9163933p51c4&app=live&stream=livestream-$(date +%s)\" \\\n  -H 'Origin: http://localhost' -H 'Referer: http://localhost' \\\n  -H 'Accept: */*' -H 'Content-type: application/sdp' \\\n  -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)' \\\n  --data-raw $'v=0\\r\\na=group:BUNDLE 0 1\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:0\\r\\na=sendonly\\r\\na=msid:- audio\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\na=ssrc:3184534672 cname:stream\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 106\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:1\\r\\na=sendonly\\r\\na=msid:- video\\r\\na=rtcp-mux\\r\\na=rtpmap:106 H264/90000\\r\\na=ssrc:512761356 cname:stream' \\\n  -v -k\n```\n\n----------------------------------------\n\nTITLE: Making JSONP and JSONP-DELETE Crossdomain API Calls - HTTP GET Example\nDESCRIPTION: These HTTP GET examples illustrate using JSONP and JSONP-DELETE to make crossdomain requests to the SRS API. Adding the callback= parameter instructs SRS to wrap the response in the specified function call for JavaScript integration. The method=DELETE workaround enables deletion via JSONP for clients limited to GET requests. They rely on the API supporting CORS or JSONP methods.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n```\\nGET http://localhost:1985/api/v1/vhosts/?callback=JSON_CALLBACK\\nJSON_CALLBACK({\"code\":0,\"server\":13449})\\nGET http://localhost:1985/api/v1/vhosts/100?callback=JSON_CALLBACK&method=DELETE\\nJSON_CALLBACK({\"code\":0})\\n```\n```\n\n----------------------------------------\n\nTITLE: Generating SVG Performance Graphs with PPROF\nDESCRIPTION: Command to generate an SVG visualization of CPU profile data for viewing in Chrome. This provides a graphical representation of performance bottlenecks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./objs/pprof --svg ./objs/srs gperf.srs.gcp >t.svg\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Read for RTMP Publishers in SRS\nDESCRIPTION: SRS configuration for merged-read (MR) settings, which can improve read performance but may increase latency. This snippet shows how to configure MR and set the latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/low-latency.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# the MR(merged-read) setting for publisher.\nvhost mrw.srs.com {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # about MR, read https://github.com/ossrs/srs/issues/241\n        # when enabled the mr, SRS will read as large as possible.\n        # default: off\n        mr          off;\n        # the latency in ms for MR(merged-read),\n        # the performance+ when latency+, and memory+,\n        #       memory(buffer) = latency * kbps / 8\n        # for example, latency=500ms, kbps=3000kbps, each publish connection will consume\n        #       memory = 500 * 3000 / 8 = 187500B = 183KB\n        # when there are 2500 publisher, the total memory of SRS atleast:\n        #       183KB * 2500 = 446MB\n        # the value recomment is [300, 2000]\n        # default: 350\n        mr_latency  350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Local IP Address using Bash for macOS and CentOS\nDESCRIPTION: These Bash commands demonstrate how to retrieve the primary local network IP address of a machine on macOS (using `ifconfig en0`) and CentOS (using `ifconfig eth0` with `grep` and `awk`). The output is intended to be stored in the `CANDIDATE` environment variable for use in SRS configuration, particularly when the `candidate $CANDIDATE;` setting is used.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\nCANDIDATE=$(ifconfig en0 inet| grep 'inet '|awk '{print $2}')\n\n# For CentOS\nCANDIDATE=$(ifconfig eth0|grep 'inet '|awk '{print $2}')\n```\n\n----------------------------------------\n\nTITLE: Performing Cross-Domain Requests using JSONP\nDESCRIPTION: Examples of JSONP (JSON with Padding) requests to the SRS API for cross-domain access from JavaScript. It shows a standard GET request using the `callback` query parameter and a simulated DELETE request using both `callback` and `method=DELETE` parameters, along with sample JSONP responses.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nGET http://localhost:1985/api/v1/vhosts/?callback=JSON_CALLBACK\nJSON_CALLBACK({\"code\":0,\"server\":13449})\nGET http://localhost:1985/api/v1/vhosts/100?callback=JSON_CALLBACK&method=DELETE\nJSON_CALLBACK({\"code\":0})\n```\n\n----------------------------------------\n\nTITLE: Copying Both Video and Audio Streams with FFMPEG in SRS (Bash)\nDESCRIPTION: Shows an SRS configuration using FFMPEG to simply copy both video (`vcodec copy`) and audio (`acodec copy`) streams without any transcoding. This effectively demuxes and remuxes the stream, similar to SRS's forward feature but utilizing the FFMPEG engine for the task. Requires SRS and FFMPEG.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          copy;\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example WebRTC SDP Answer with Candidate Line (SDP)\nDESCRIPTION: This snippet shows a sample SDP (Session Description Protocol) answer from a WebRTC server during the signaling phase. It highlights the `a=candidate:` line, which specifies the server's IP address (192.168.3.6) and UDP port (8000) that the client should use to establish the media connection. This illustrates the practical output of the `candidate` and `listen` configurations in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: sdp\nCODE:\n```\ntype: answer, sdp: v=0\na=candidate:0 1 udp 2130706431 192.168.3.6 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Running Ubuntu Docker for Cross-Building SRS\nDESCRIPTION: Command to start an Ubuntu 20 Docker container for cross-building SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk\ndocker run --rm -it -v `pwd`:/srs -w /srs ossrs/srs:ubuntu20 bash\n```\n\n----------------------------------------\n\nTITLE: Checking Kubernetes Cluster Information using Bash\nDESCRIPTION: This command checks the connectivity and displays basic information about the Kubernetes cluster that `kubectl` is configured to interact with. It requires `kubectl` to be installed and configured to point to a valid K8s cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkubectl cluster-info\n```\n\n----------------------------------------\n\nTITLE: Pushing Stream to Origin Server with FFmpeg\nDESCRIPTION: Bash script to continuously push a video stream to the first origin server using FFmpeg. This simulates a live stream being published to the origin cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring GOP Cache Settings in SRS\nDESCRIPTION: Configuration for GOP (Group of Pictures) caching which affects startup time and latency for clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    play {\n        gop_cache       off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Grafana for Metrics Visualization\nDESCRIPTION: Docker command to run Grafana with custom configuration for admin credentials and UI theme, ready to connect to Prometheus data source.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 3000:3000 \\\n  -e GF_SECURITY_ADMIN_USER=admin \\\n  -e GF_SECURITY_ADMIN_PASSWORD=12345678 \\\n  -e GF_USERS_DEFAULT_THEME=light \\\n  grafana/grafana\n```\n\n----------------------------------------\n\nTITLE: Native Compilation of SRS on ARM\nDESCRIPTION: This command sequence configures the SRS build environment using the default settings and then compiles the source code directly on an ARM server (like Raspberry Pi, armv7, or armv8). It assumes all necessary build dependencies are already installed on the ARM system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFMPEG Support\nDESCRIPTION: Command to configure and build SRS with FFMPEG transcoding support enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Memory Profiling with GPERF GMP\nDESCRIPTION: Shows how to use Google's Memory Profiler (GMP) to analyze memory usage in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GMP\n./configure --gperf=on --gmp=on && make\n\n# Start SRS with GMP\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop gmp\nkillall -2 srs \n\n# To analysis memory profile\n./objs/pprof --text objs/srs gperf.srs.gmp*\n```\n\n----------------------------------------\n\nTITLE: Enabling and Configuring HLS File Cleanup - Conf\nDESCRIPTION: This SRS configuration snippet enables HLS streaming and sets the time (in seconds) after streaming stops before SRS cleans up generated HLS files (TS and m3u8). The 'hls_dispose 120;' indicates a cleanup period of 120 seconds. All parameters are field entries within the SRS conf file. Intended for administrators who require control over the retention of HLS files post-stream for smooth restart and temporary pauses. Inputs: Stream source; Output: Automatic file deletion after timeout. Limitation: Recommended not to exceed 'hls_window' or be too short to avoid data loss on restart.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_dispose 120;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Service for SRS\nDESCRIPTION: Defines a Kubernetes Service of type LoadBalancer to expose the SRS deployment. This service automatically creates an SLB (Server Load Balancer) and EIP (Elastic IP) to provide external access to the SRS media server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-origin-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-origin-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS from Source (Bash)\nDESCRIPTION: Runs the `configure` script to check system dependencies and set up the build environment, followed by the `make` command to compile the SRS source code. This should be executed in the `srs/trunk` directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Optimized Low Latency Configuration for SRS\nDESCRIPTION: Recommended SRS configuration for low latency applications, including settings for TCP_NODELAY, min_latency, GOP cache, queue length, and merged read/write.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# the listen ports, split by space.\nlisten              1935;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running SRS Server in Bash\nDESCRIPTION: Provides the basic commands to compile and start the SRS server from its source directory. The first command `./configure && make` prepares the build environment based on the system and then compiles the source code. The second command `./objs/srs -c conf/srs.conf` runs the compiled SRS server located in the `objs` directory, using the configuration file `conf/srs.conf`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/install.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 3.0 Release Branch (Bash)\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 3.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/git.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to fetch the SRS source code from GitHub repository. This is the first step in setting up an RTMP Origin Cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: NGINX Log Format for Cache Status Monitoring\nDESCRIPTION: NGINX log format configuration that includes upstream_cache_status field to track cache effectiveness in access logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nlog_format  main  '$upstream_cache_status $remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\naccess_log  /var/log/nginx/access.log main;\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP API Configuration in JSON\nDESCRIPTION: Example configuration for enabling HTTP RAW API in SRS. It shows how to enable the API and allow reload functionality through the configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_12\n\nLANGUAGE: json\nCODE:\n```\nhttp_api {\n    enabled         on;\n    listen          1985;\n    raw_api {\n        enabled             on;\n        allow_reload        on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Moving HEVC MP4 to SRS Webserver for Playback\nDESCRIPTION: Commands to create a directory structure and move the HEVC-encoded MP4 file to SRS webserver for browser playback testing with the SRS player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/git/srs/trunk/objs/nginx/html/vod/\nmv source.hevc.mp4 ~/git/srs/trunk/objs/nginx/html/vod\n```\n\n----------------------------------------\n\nTITLE: SRS Edge Server Configuration\nDESCRIPTION: Configuration file for SRS edge servers that pull streams from the origin. This example configures edge servers with different ports to listen on.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.flv.live.edge1.conf\nlisten              19351;\nmax_connections     1000;\npid                 objs/srs.flv.19351.pid;\nsrs_log_file        objs/srs.flv.19351.log;\nhttp_server {\n    enabled         on;\n    listen          8081;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    mode remote;\n    origin 127.0.0.1;\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS in ARM64 Docker Container\nDESCRIPTION: Command to run a cross-compiled SRS binary in an ARM64 Docker container for testing, exposing the required ports for RTMP and HTTP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 arm64v8/ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Reverse Proxying SRS with CaddyServer - Caddy Configuration\nDESCRIPTION: Provides Caddyfile configs for using CaddyServer as a reverse proxy to SRS servers for HTTP or HTTPS. The first block listens on port 80 and reverse proxies all routes, with /api and /rtc directed to a different port. The second block enables automatic HTTPS for a real domain. Both cases forward traffic appropriately to SRS access and API endpoints, ideal for simple setups.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_5\n\nLANGUAGE: caddy\nCODE:\n```\n:80\nreverse_proxy /* 127.0.0.1:8080\nreverse_proxy /api/* 127.0.0.1:1985\nreverse_proxy /rtc/* 127.0.0.1:1985\n\n```\n\nLANGUAGE: caddy\nCODE:\n```\nexample.com {\n  reverse_proxy /* 127.0.0.1:8080\n  reverse_proxy /api/* 127.0.0.1:1985\n  reverse_proxy /rtc/* 127.0.0.1:1985\n}\n\n```\n\n----------------------------------------\n\nTITLE: Streaming HEVC over RTMP using FFmpeg\nDESCRIPTION: Uses FFmpeg to transcode a source FLV file to HEVC using libx265 and stream it over RTMP to a local SRS server. The stream is looped continuously for testing purposes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./ffmpeg -stream_loop -1 -re -i ~/srs/doc/source.flv -acodec copy -vcodec libx265 \\\n  -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Send Minimal Interval in SRS\nDESCRIPTION: Controls the minimal packet send interval in milliseconds to ensure consistent packet delivery timing. Useful for devices that require constant interval packet delivery rather than CBR (Constant Bit Rate).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_0\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # the minimal packets send interval in ms,\n        # used to control the ndiff of stream by srs_rtmp_dump,\n        # for example, some device can only accept some stream which\n        # delivery packets in constant interval(not cbr).\n        # @remark 0 to disable the minimal interval.\n        # @remark >0 to make the srs to send message one by one.\n        # @remark user can get the right packets interval in ms by srs_rtmp_dump.\n        # default: 0\n        send_min_interval       10.0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Slave Server for Small Cluster\nDESCRIPTION: Configuration for SRS slave servers in a small cluster setup, with multiple processes listening on different ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.1935.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1936;\npid                 ./objs/srs.1936.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Dropping Video and Transcoding Audio with FFMPEG in SRS (bash)\nDESCRIPTION: This SRS configuration snippet configures FFMPEG to drop the video stream entirely by setting 'vcodec vn;' (video null) and transcode the audio stream to AAC ('acodec libfdk_aac;'). The resulting output RTMP stream will contain only the transcoded audio. Requires SRS and a functional FFMPEG binary.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ffmpeg.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine vn {\n            enabled         on;\n            vcodec          vn;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Docker Volume Mount for Custom FFmpeg\nDESCRIPTION: Docker command segment to replace the default FFmpeg in Oryx with a custom version by mounting a local FFmpeg binary to the container.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\n-v /path/to/ffmpeg:/usr/local/bin/ffmpeg\n```\n\n----------------------------------------\n\nTITLE: Customizing Chunk Size per Vhost in SRS - Bash\nDESCRIPTION: This configuration sets custom RTMP chunk sizes for two vhosts: show.cctv.cn uses a small chunk size (128) for low latency, while show.wasu.cn uses a larger chunk size (4096) for faster startup. Both vhosts are explicitly configured and isolated. Prerequisite: SRS understands chunk_size settings per vhost. The input is a configuration file, and output is an RTMP server with differentiated per-vhost behavior.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n    chunk_size 128;\n}\nvhost show.wasu.cn {\n    chunk_size 4096;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Example HLS m3u8 Playlist File Structure (Bash)\nDESCRIPTION: This snippet represents the structure and content of a sample HLS m3u8 playlist file generated by SRS. It lists the playlist format and demonstrates how segment durations and filenames appear in the playlist. The playlist is generated according to HLS specifications and SRS config parameters like 'hls_fragment' and 'hls_window'. The input is the stream segments generated by SRS; output is this text file served as m3u8 for clients. No external software is required to interpret the file, but playback requires a compatible HLS player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n#EXTM3U\\n#EXT-X-VERSION:3\\n#EXT-X-MEDIA-SEQUENCE:64\\n#EXT-X-TARGETDURATION:12\\n#EXTINF:11.550\\nlivestream-64.ts\\n#EXTINF:5.250\\nlivestream-65.ts\\n#EXTINF:7.700\\nlivestream-66.ts\\n#EXTINF:6.850\\nlivestream-67.ts\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for WebRTC over TCP\nDESCRIPTION: Starts an SRS instance using Docker, exposing necessary ports (8080 for HTTP streams, 1985 for HTTP API, 8000 for WebRTC over TCP). It enables TCP transport for WebRTC (`SRS_RTC_SERVER_TCP_ENABLED=on`), sets the protocol to TCP (`SRS_RTC_SERVER_PROTOCOL=tcp`), and defines the server's candidate IP address using the `CANDIDATE` environment variable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080 -p 1985:1985 -p 8000:8000 \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic ATC Detection in SRS\nDESCRIPTION: Controls whether SRS automatically detects and enables ATC (Adobe Time Code) mode. When enabled, SRS checks for bravo_atc=\"true\" in onMetaData packets and automatically enables ATC mode if found. This affects timestamp synchronization.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Single Vhost in SRS\nDESCRIPTION: Example of configuring a single vhost in SRS, demonstrating the basic structure of a vhost configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n    enabled         on;\n}\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration for Specific Process\nDESCRIPTION: Shows how to reload the configuration for a specific SRS process by providing its process ID. This is useful when multiple SRS instances are running.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reload.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nkill -1 7635\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub or update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-realtime.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: SRS Server Configuration\nDESCRIPTION: Basic SRS server configuration with connection limits and RTMP forwarding setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    gop_cache       on;\n    forward         127.0.0.1:19350;\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for HEVC Streaming\nDESCRIPTION: Docker command to run SRS server with HEVC configuration. Maps ports 1935 (RTMP) and 8080 (HTTP) and uses the hevc.flv.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-04-08-Push-HEVC-via-RTMP-by-OBS.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:6 \\\n  ./objs/srs -c conf/hevc.flv.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing an RTMP Stream using FFmpeg\nDESCRIPTION: This command uses FFmpeg to continuously publish a local FLV file ('./doc/source.flv') as an RTMP stream to the master SRS server. The '-re' flag reads the input at its native frame rate, '-c copy' copies the stream without re-encoding, and '-f flv' specifies the output format. The stream is published to 'rtmp://192.168.1.170/live/livestream'. The loop ensures republishing if the connection drops.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with HTTPS Support\nDESCRIPTION: Launches an SRS Docker container with HTTPS configuration for secure WebRTC connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:5 ./objs/srs -c conf/https.docker.conf\n```\n\n----------------------------------------\n\nTITLE: Starting NGINX Edge Server with HLS Configuration\nDESCRIPTION: Command to start NGINX with the HLS edge configuration file for a HLS cluster example setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnginx -c $(pwd)/conf/hls.edge.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: Bash script to continuously publish a stream using FFmpeg to the master SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Pushing RTMP Stream to SRS Server Using FFmpeg\nDESCRIPTION: This command uses FFmpeg to continuously stream a test file to the SRS server using RTMP protocol. The stream will be available for conversion to DASH format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-11-25-DASH-Issues.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS with HTTPS Configuration\nDESCRIPTION: Start SRS server with HTTPS configuration for secure WebRTC connections\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/https.rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Real-Time System and Network Monitoring with 'dstat' - Shell\nDESCRIPTION: This code logs real-time system resource and network interface statistics using 'dstat' focused on the loopback interface at 30-second intervals. The output includes columns for CPU, disk, network, paging, and system interrupts, essential for tracking network throughput and system health during SRS performance tests. Requires the 'dstat' tool; inputs are real-time stats, outputs are tabular printed metrics. No parameters apart from the sample command line.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_20\n\nLANGUAGE: shell\nCODE:\n```\n[winlin@dev6 ~]$ dstat -N lo 30\n----total-cpu-usage---- -dsk/total- ---net/lo-- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  3   2  92   0   0   3|  11k   27k|   0     0 |   1B   26B|3085   443 \n 32  17  33   0   0  17| 273B   60k|  69M   69M|   0     0 |4878  6652 \n 34  18  32   0   0  16|   0    38k|  89M   89M|   0     0 |4591  6102 \n 35  19  30   0   0  17| 137B   41k|  91M   91M|   0     0 |4682  6064 \n 33  17  33   0   0  17|   0    31k|  55M   55M|   0     0 |4920  7785 \n 33  18  31   0   0  17|2867B   34k|  90M   90M|   0     0 |4742  6530 \n 32  18  33   0   0  17|   0    31k|  66M   66M|   0     0 |4922  7666 \n 33  17  32   0   0  17| 137B   39k|  65M   65M|   0     0 |4841  7299 \n 35  18  30   0   0  17|   0    28k| 100M  100M|   0     0 |4754  6752 \n 32  17  33   0   0  18|   0    41k|  44M   44M|   0     0 |5130  8251 \n 34  18  32   0   0  16|   0    30k| 104M  104M|   0     0 |4456  5718 \n```\n\n----------------------------------------\n\nTITLE: Preloading ASAN Library for SRS\nDESCRIPTION: Command to preload the Address Sanitizer library when running SRS, resolving the issue where ASAN runtime does not come first in the initial library list.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nLD_PRELOAD=$(find /usr -name libasan.so.5 2>/dev/null) ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: WebRTC Playback with WHEP Protocol\nDESCRIPTION: Example of using WHEP protocol to play WebRTC streams from SRS server. The request includes an SDP offer in the body, and the server responds with an SDP answer using HTTP status 201.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whep/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\nLANGUAGE: text\nCODE:\n```\nv=0\n......\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS on ARM Server\nDESCRIPTION: Commands to configure and build SRS directly on an ARM server. This is suitable for ARM servers with sufficient resources to compile natively.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Kickoff Client using curl in Bash\nDESCRIPTION: Examples of using curl to send HTTP requests for getting client information and kicking off a client. It demonstrates how to retrieve client IDs and use them to delete (kickoff) specific clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v -X GET http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\ncurl -v -X DELETE http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 4.0 Release Branch (Bash)\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 4.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/git.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 4.0release\n```\n\n----------------------------------------\n\nTITLE: Fast Checkout Using Chinese Mirror with GitHub Remote in Bash\nDESCRIPTION: Command to clone SRS repository from a Chinese mirror (gitee.com) and then set the origin to GitHub for continued development. This provides faster initial download while maintaining GitHub as the upstream source.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://gitee.com/ossrs/srs.git && \ncd srs && git remote set-url origin https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Servers\nDESCRIPTION: Commands to start the origin and edge SRS servers using their respective configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.flv.live.conf &\n./objs/srs -c conf/http.flv.live.edge1.conf &\n./objs/srs -c conf/http.flv.live.edge2.conf &\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server with EXEC for RTMP to MPEG-TS Conversion (SRS Config)\nDESCRIPTION: This SRS (version 3) configuration sets up the edge server to listen on port `19350`. It uses the `exec` directive's `publish` hook to automatically invoke FFmpeg for each incoming stream forwarded from the origin. FFmpeg converts the RTMP stream (`rtmp://127.0.0.1:1935/[app]?vhost=[vhost]/[stream]`) to MPEG-TS format (`-f mpegts`) and sends it via UDP (`udp://[stream]?localaddr=127.0.0.1&pkt_size=1316`). The UDP destination address uses the original stream name (`[stream]`), and the `-vbsf h264_mp4toannexb` bitstream filter is required for the H.264 conversion.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/sample.md#2025-04-23_snippet_3\n\nLANGUAGE: srs-config\nCODE:\n```\n    listen              19350;\n    max_connections     1024;\n    srs_log_tank        file;\n    srs_log_file        ./objs/srs.slave.log;\n    srs_log_level       error;\n    vhost __defaultVhost__ {\n        exec {\n            enabled     on;\n            publish     ./objs/ffmpeg/bin/ffmpeg -v quiet -re -i rtmp://127.0.0.1:1935/[app]?vhost=[vhost]/[stream] -c copy -vbsf h264_mp4toannexb -f mpegts \"udp://[stream]?localaddr=127.0.0.1&pkt_size=1316\";\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFmpeg\nDESCRIPTION: This command uses FFmpeg to publish a local video file as a live stream to SRS via RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: WebRTC Play Response Example with SDP\nDESCRIPTION: This shows the server response format for a WebRTC play request, which includes the SDP information with ICE candidates. The response HTTP status should be 201 according to WHIP requirements.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nv=0\n......\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Starting Ubuntu Docker Container for ARMv7 Cross-Compilation\nDESCRIPTION: Similar to the aarch64 setup, this navigates to the SRS source directory and launches an Ubuntu 16 Docker container. This container will be used to install the ARMv7 toolchain and cross-compile SRS for that architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:ubuntu16 bash\n```\n\n----------------------------------------\n\nTITLE: Retrieving SRS Service Details using Bash\nDESCRIPTION: This command uses `kubectl get svc` to retrieve the details of the Kubernetes Service named `srs-service`. It's specifically used here to find the `EXTERNAL-IP` assigned by the LoadBalancer, which is needed to access the SRS server from outside the cluster. Requires `kubectl` access and the service `srs-service` to exist.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get svc/srs-service\n```\n\n----------------------------------------\n\nTITLE: Configuring Forward in SRS RTMP Server\nDESCRIPTION: Example configuration for enabling forward functionality in SRS, including static destination and dynamic backend options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # forward stream to other servers.\n    forward {\n        # whether enable the forward.\n        # default: off\n        enabled on;\n        # forward all publish stream to the specified server.\n        # this used to split/forward the current stream for cluster active-standby,\n        # active-active for cdn to build high available fault tolerance system.\n        # format: {ip}:{port} {ip_N}:{port_N}\n        destination 127.0.0.1:1936 127.0.0.1:1937;\n\n        # when client(encoder) publish to vhost/app/stream, call the hook in creating backend forwarder.\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_forward\",\n        #           \"server_id\": \"vid-k21d7y2\",\n        #           \"client_id\": \"9o7g1330\",\n        #           \"ip\": \"127.0.0.1\",\n        #           \"vhost\": \"__defaultVhost__\",\n        #           \"app\": \"live\",\n        #           \"tcUrl\": \"rtmp://127.0.0.1:1935/live\",\n        #           \"stream\": \"livestream\",\n        #           \"param\": \"\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       {\n        #          \"code\": 0,\n        #          \"data\": {\n        #              \"urls\":[\n        #                 \"rtmp://127.0.0.1:19350/test/teststream\"\n        #              ]\n        #          }\n        #       }\n        # PS: you can transform params to backend service, such as:\n        #       { \"param\": \"?forward=rtmp://127.0.0.1:19351/test/livestream\" }\n        #     then backend return forward's url in response.\n        # if backend return empty urls, destanition is still disabled.\n        # only support one api hook, format:\n        #       backend http://xxx/api0\n        backend http://127.0.0.1:8085/api/v1/forward;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark Configuration for SRS\nDESCRIPTION: Example configuration used for benchmarking latency performance in SRS, including HLS settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    enabled         on;\n    play {\n        gop_cache       off;\n    }\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    5;\n        hls_window      20;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing a Stream with FFmpeg\nDESCRIPTION: FFmpeg command to publish a stream to SRS. This command takes a source video file and publishes it as an RTMP stream that can be consumed by WebRTC players.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Grep for Session Oriented Logs in SRS using Bash\nDESCRIPTION: This snippet demonstrates how to filter the SRS log file for client session activities, including identifying client connections and publication events using Bash tools such as grep. The commands require access to the SRS log file and a terminal with standard Unix text utilities. Inputs include stream keywords or session IDs; outputs are filtered log lines matching those identifiers, allowing administrators to trace specific client interactions or troubleshoot session issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Starting Prometheus with Custom Configuration\nDESCRIPTION: This Docker command starts Prometheus using a custom configuration file and exposes it on port 9090.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n  -p 9090:9090 prom/prometheus\n```\n\n----------------------------------------\n\nTITLE: Streaming with FFmpeg to SRS for HTTP-FLV\nDESCRIPTION: This FFmpeg command streams a local FLV file to SRS using RTMP protocol, which can then be accessed via HTTP-FLV.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/flv.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server\nDESCRIPTION: Configuration file for the SRS edge server that forwards RTMP requests to the origin server. It listens on the standard RTMP port 1935 and points to the origin server at 127.0.0.1:19350.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining SRS HTTP Hook Publish Protocol - text\nDESCRIPTION: This snippet displays the structure and content of the HTTP POST protocol used by SRS for the `on_publish` callback. It shows the complete HTTP/1.1 POST request, including headers and example JSON body that will be sent to the specified endpoint. Implementers must ensure that their endpoint can receive and parse such a request and respond with appropriate headers and body. There are no external dependencies for the format itself, but the endpoint must be reachable via HTTP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nPOST /api/v1/streams HTTP/1.1\nContent-Type: application-json\n\nBody:\n{\n  \"server_id\": \"vid-0xk989d\",\n  \"action\": \"on_publish\",\n  \"client_id\": \"341w361a\",\n  \"ip\": \"127.0.0.1\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"tcUrl\": \"rtmp://127.0.0.1:1935/live?vhost=__defaultVhost__\",\n  \"stream\": \"livestream\",\n  \"param\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Origin Deployment and Services in Kubernetes (YAML/Shell)\nDESCRIPTION: This snippet uses a shell heredoc (`cat <<EOF | kubectl apply -f -`) to apply Kubernetes YAML configurations. It defines a Deployment named `srs-origin-deploy` containing three containers (SRS, Nginx, and a helper `srs-cp-files` container) sharing an `emptyDir` volume for HLS segments. It also defines two Services: `srs-origin-service` (ClusterIP type) for internal cluster access to the SRS Origin on port 1935, and `srs-http-service` (LoadBalancer type) to expose Nginx (port 80 for HLS) and the SRS API (port 1985) externally.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-origin-deploy\n  labels:\n    app: srs-origin\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs-origin\n  template:\n    metadata:\n      labels:\n        app: srs-origin\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: ClusterIP\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-http-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-http-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-http-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\nEOF\n```\n\n----------------------------------------\n\nTITLE: Building and Installing SRS - Bash\nDESCRIPTION: Compiles and installs SRS to the default or configured directory prefix using 'make' and 'make install'. Requires standard build environment (make, gcc, sudo access for installation). Outputs build progress and installation logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake && sudo make install\n```\n\n----------------------------------------\n\nTITLE: Updating the SRS Repository (Bash)\nDESCRIPTION: This command updates an existing local SRS repository by pulling the latest changes from the remote repository using Git. This ensures you have the most recent version of the code before building.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Live HLS Media Playlist with HTTPS (M3U8)\nDESCRIPTION: An example of a live HLS media playlist using HTTPS for segment delivery. It specifies the HLS version, target segment duration, the media sequence number of the first segment listed, and details (duration and URL) for several consecutive media segments. The absence of #EXT-X-ENDLIST indicates it's a live stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_22\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-TARGETDURATION:8\n#EXT-X-MEDIA-SEQUENCE:2680\n\n#EXTINF:7.975,\nhttps://priv.example.com/fileSequence2680.ts\n#EXTINF:7.941,\nhttps://priv.example.com/fileSequence2681.ts\n#EXTINF:7.975,\nhttps://priv.example.com/fileSequence2682.ts\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 2.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS version 2.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/git.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: Cloning and Switching Remote for SRS Repository via Gitee - Bash\nDESCRIPTION: Performs a complete clone of the SRS repository from the Gitee mirror, then changes the remote origin to GitHub and pulls updates. This sequence is useful for users in regions with faster Gitee access but who want to keep their repo synchronized with GitHub upstream. Dependencies include Git installed on the system. Takes parameters for the source URL and optionally target directory. Input: no arguments (if copy-pasted as-is). Output: creates a local git repo folder 'srs' with GitHub set as remote origin.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/resource.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/ossrs/srs.git &&\\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Configuring Publisher Normal Packet Timeout in SRS\nDESCRIPTION: Sets the timeout in milliseconds for receiving subsequent packets from an RTMP publisher after the initial connection. If no packet is received within this duration, the connection might be considered stalled and dropped. The default value is 5000 ms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # the normal packet timeout in ms for encoder.\n        # default: 5000\n        normal_timeout      7000;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Static Forward in SRS\nDESCRIPTION: SRS configuration for enabling static stream forwarding to other servers. This enables splitting streams for cluster active-standby or active-active setups to build high availability fault tolerance systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # forward stream to other servers.\n    forward {\n        # whether enable the forward.\n        # default: off\n        enabled on;\n        # forward all publish stream to the specified server.\n        # this used to split/forward the current stream for cluster active-standby,\n        # active-active for cdn to build high available fault tolerance system.\n        # format: {ip}:{port} {ip_N}:{port_N}\n        destination 127.0.0.1:1936 127.0.0.1:1937;\n\n        # when client(encoder) publish to vhost/app/stream, call the hook in creating backend forwarder.\n        # the request in the POST data string is a object encode by json:\n        #       {\n        #           \"action\": \"on_forward\",\n        #           \"server_id\": \"vid-k21d7y2\",\n        #           \"client_id\": \"9o7g1330\",\n        #           \"ip\": \"127.0.0.1\",\n        #           \"vhost\": \"__defaultVhost__\",\n        #           \"app\": \"live\",\n        #           \"tcUrl\": \"rtmp://127.0.0.1:1935/live\",\n        #           \"stream\": \"livestream\",\n        #           \"param\": \"\"\n        #       }\n        # if valid, the hook must return HTTP code 200(Status OK) and response\n        # an int value specifies the error code(0 corresponding to success):\n        #       {\n        #          \"code\": 0,\n        #          \"data\": {\n        #              \"urls\":[\n        #                 \"rtmp://127.0.0.1:19350/test/teststream\"\n        #              ]\n        #          }\n        #       }\n        # PS: you can transform params to backend service, such as:\n        #       { \"param\": \"?forward=rtmp://127.0.0.1:19351/test/livestream\" }\n        #     then backend return forward's url in response.\n        # if backend return empty urls, destanition is still disabled.\n        # only support one api hook, format:\n        #       backend http://xxx/api0\n        backend http://127.0.0.1:8085/api/v1/forward;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for ARMv8 Platforms\nDESCRIPTION: Command to configure SRS for ARMv8 platforms like Loongson and Kunpeng, which may not be automatically detected. This sets a specific compiler flag for aarch64 architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --extra-flags='-D__aarch64__' && make\n```\n\n----------------------------------------\n\nTITLE: Setting First Packet Timeout for RTMP Publishers in SRS\nDESCRIPTION: Configures the timeout in milliseconds for the first packet from RTMP publishers (e.g., FMLE/Flash). This helps manage connection timeouts for encoders.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        firstpkt_timeout    20000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setup for HiSilicon ARMv7 Cross-Compilation\nDESCRIPTION: Docker and setup commands for cross-compiling SRS for HiSilicon ARMv7 architecture on Ubuntu 20, installing 32-bit support libraries.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -v $(pwd):/srs -w /srs/trunk \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:ubuntu20 bash\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Ingest Configuration\nDESCRIPTION: Command to start the SRS server using the ingest configuration file, which will begin the process of ingesting the specified file and publishing it as an RTMP stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ingest.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing HEVC Stream with FFmpeg 6\nDESCRIPTION: Command to use FFmpeg 6 to publish an HEVC encoded video stream via RTMP protocol. This example loops a source file continuously, keeps the original audio, and transcodes the video to HEVC (H.265) format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -stream_loop -1 -re -i doc/source.flv -acodec copy \\\n  -vcodec libx265 -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: App-Specific Transcoding Configuration\nDESCRIPTION: Configuration example showing how to apply transcoding to specific applications in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode all streams of app \"live\"\n    transcode live {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server\nDESCRIPTION: Configuration file for the SRS origin server that accepts incoming RTMP streams. It listens on port 19350 and allows up to 1000 connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.conf\nlisten              19350;\nmax_connections     1000;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Using Executor with GB SIP TCP Connection\nDESCRIPTION: Example showing how to use the executor to manage GB SIP TCP connections with proper resource management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nSrsGbSipTcpConn* raw_conn = new SrsGbSipTcpConn();\nSrsSharedResource<SrsGbSipTcpConn>* conn = new SrsSharedResource<SrsGbSipTcpConn>(raw_conn);\nSrsExecutorCoroutine* executor = new SrsExecutorCoroutine(_srs_gb_manager, conn, raw_conn, raw_conn);\nif ((err = executor->start()) != srs_success) {\n    srs_freep(executor);\n    return srs_error_wrap(err, \"gb sip\");\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Console Configuration in Bash\nDESCRIPTION: Shows the command used to start the SRS server, explicitly specifying the `conf/console.conf` configuration file using the `-c` flag. This command typically results in SRS running in the foreground and printing logs to the terminal, as defined in the console configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: SRS ATC Configuration\nDESCRIPTION: Default SRS configuration for ATC settings in the virtual host, showing how to enable/disable ATC for RTMP and HTTP FLV stream clients\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-atc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        #\n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # default: off\n        atc             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GOP Cache Settings\nDESCRIPTION: Settings for controlling GOP caching behavior which affects startup time and streaming latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    play {\n        gop_cache       off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Mixing RTMP Streams with FFmpeg (Bash)\nDESCRIPTION: This FFmpeg command demonstrates how to mix multiple RTMP streams (presumably converted from WebRTC by SRS using `rtc2rtmp.conf`). It takes two input RTMP streams, scales one video stream and overlays it onto the other, mixes the audio from both streams, encodes the result (H.264 video, AAC audio), and outputs the final mixed stream to a new RTMP URL. This is useful for creating a combined live feed from multiple participants.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -f flv -i rtmp://192.168.3.6/live/alice -f flv -i rtmp://192.168.3.6/live/314d0336 \\\n     -filter_complex \"[1:v]scale=w=96:h=72[ckout];[0:v][ckout]overlay=x=W-w-10:y=H-h-10[out]\" -map \"[out]\" \\\n     -c:v libx264 -profile:v high -preset medium \\\n     -filter_complex amix -c:a aac \\\n     -f flv rtmp://192.168.3.6/live/merge\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Listener and Default Vhost - SRS - Bash\nDESCRIPTION: Defines a basic SRS server configuration that listens on RTMP port 1935 and enables the default vhost for all incoming streams. No specific customizations are set for the vhost, making it suitable for single-customer or standard scenarios where vhost segregation is unnecessary. No dependencies beyond SRS, and key parameters are kept minimal: 'listen' for the port, and a 'vhost' block with the reserved __defaultVhost__ name. Inputs/outputs: accepts RTMP connections; applies default configuration to all streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Enabling and Running GPERF CPU Profiler (gcp) with SRS in Bash\nDESCRIPTION: Describes the shell commands to configure SRS for gcp (`--with-gperf --with-gcp`), build it (`make`), run SRS to collect CPU profile data (`rm -f gperf.srs.gcp*; ./objs/srs ...`), stop SRS (`CTRL+C` or `SIGINT`) to write the profile file (`gperf.srs.gcp*`), and analyze the results using `pprof` (`./objs/pprof --text ...`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n# Configure SRS with gcp enabled\n./configure --with-gperf --with-gcp\n\n# Compile SRS\nmake\n\n# Run SRS to collect CPU profile data (remove old files first)\nrm -f gperf.srs.gcp*\n./objs/srs -c conf/console.conf\n\n# Stop SRS to write the profile data\nCTRL+C\n\n# Analyze the generated CPU profile file\n./objs/pprof --text objs/srs gperf.srs.gcp*\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository with Git - Bash\nDESCRIPTION: This snippet uses git to clone the SRS repository's 4.0release branch to your local machine, a prerequisite for building SRS from source. It requires git to be installed and network access to GitHub. The single parameter '-b 4.0release' ensures the correct release branch is checked out. The output is a local copy of the full SRS source tree in the current directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 4.0release https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Starting Origin and Edge SRS Servers - Bash\nDESCRIPTION: This snippet launches the origin and edge SRS servers using their respective config files in the background. Both instances are started simultaneously, each referencing its configuration to bind to the correct ports and use appropriate log/PID files. Prerequisite: both configuration files must exist as specified. Output: running SRS origin and edge services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf &\n./objs/srs -c conf/edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Installing SRS using make commands\nDESCRIPTION: These commands compile and install SRS. The sudo command may be omitted if installing to a non-system directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmake && sudo make install\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Source Code Directly from GitHub using Shell\nDESCRIPTION: This shell command clones the official SRS repository directly from GitHub to the local machine. Dependencies include Git installed and available network access to GitHub. No additional configuration or parameters are necessary; outputs a new directory named 'srs' with the full source tree. Typically used when GitHub access is reliable and preferred.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/resource.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Logrotate with Copytruncate\nDESCRIPTION: Alternative configuration for logrotate using copytruncate method, suitable for SRS2 that doesn't support SIGUSR1 signal.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log-rotate.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    copytruncate\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Checking Pod Status during Rolling Update\nDESCRIPTION: This Bash command uses `kubectl get po` and filters with `grep edge` to display the status of pods belonging to the SRS edge deployment during or after a rolling update. The output shows old pods in the `Terminating` state while new pods (with a different hash in the name, e.g., `76fcbfb848`) are starting up or already `Running`. This allows monitoring the progress of the update.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get po |grep edge\nNAME                                   READY   STATUS        RESTARTS   AGE\nsrs-edge-deploy-58d9999b7c-z9gbm       0/1     Terminating   0          3m52s\nsrs-edge-deploy-76fcbfb848-z5rmn       1/1     Running       0          104s\nsrs-edge-deploy-76fcbfb848-zt4wv       1/1     Running       0          106s\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Settings in SRS\nDESCRIPTION: This configuration block defines various HLS (HTTP Live Streaming) settings for the default vhost in SRS. It includes options for enabling HLS, setting fragment duration, window size, file paths, naming conventions, encryption, and other advanced features.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether the hls is enabled.\n        # if off, do not write hls(ts and m3u8) when publish.\n        # Overwrite by env SRS_VHOST_HLS_ENABLED for all vhosts.\n        # default: off\n        enabled on;\n\n        # the hls fragment in seconds, the duration of a piece of ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENT for all vhosts.\n        # default: 10\n        hls_fragment 10;\n        # the hls m3u8 target duration ratio,\n        #   EXT-X-TARGETDURATION = hls_td_ratio * hls_fragment // init\n        #   EXT-X-TARGETDURATION = max(ts_duration, EXT-X-TARGETDURATION) // for each ts\n        # Overwrite by env SRS_VHOST_HLS_HLS_TD_RATIO for all vhosts.\n        # default: 1.0\n        hls_td_ratio 1.0;\n        # the audio overflow ratio.\n        # for pure audio, the duration to reap the segment.\n        # for example, the hls_fragment is 10s, hls_aof_ratio is 1.2,\n        # the segment will reap to 12s for pure audio.\n        # Overwrite by env SRS_VHOST_HLS_HLS_AOF_RATIO for all vhosts.\n        # default: 1.2\n        hls_aof_ratio 1.2;\n        # the hls window in seconds, the number of ts in m3u8.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WINDOW for all vhosts.\n        # default: 60\n        hls_window 60;\n        # the error strategy. can be:\n        #       ignore, disable the hls.\n        #       disconnect, require encoder republish.\n        #       continue, ignore failed try to continue output hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_ON_ERROR for all vhosts.\n        # default: continue\n        hls_on_error continue;\n        # the hls output path.\n        # the m3u8 file is configured by hls_path/hls_m3u8_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream].m3u8\n        # the ts file is configured by hls_path/hls_ts_file, the default is:\n        #       ./objs/nginx/html/[app]/[stream]-[seq].ts\n        # @remark the hls_path is compatible with srs v1 config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_PATH for all vhosts.\n        # default: ./objs/nginx/html\n        hls_path ./objs/nginx/html;\n        # the hls m3u8 file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        # Overwrite by env SRS_VHOST_HLS_HLS_M3U8_FILE for all vhosts.\n        # default: [app]/[stream].m3u8\n        hls_m3u8_file [app]/[stream].m3u8;\n        # the hls ts file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [2006], replace this const to current year.\n        #       [01], replace this const to current month.\n        #       [02], replace this const to current date.\n        #       [15], replace this const to current hour.\n        #       [04], replace this const to current minute.\n        #       [05], replace this const to current second.\n        #       [999], replace this const to current millisecond.\n        #       [timestamp],replace this const to current UNIX timestamp in ms.\n        #       [seq], the sequence number of ts.\n        #       [duration], replace this const to current ts duration.\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/dvr#custom-path\n        # @see https://ossrs.net/lts/zh-cn/docs/v4/doc/delivery-hls#hls-config\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FILE for all vhosts.\n        # default: [app]/[stream]-[seq].ts\n        hls_ts_file [app]/[stream]-[seq].ts;\n        # the hls entry prefix, which is base url of ts url.\n        # for example, the prefix is:\n        #         http://your-server/\n        # then, the ts path in m3u8 will be like:\n        #         http://your-server/live/livestream-0.ts\n        #         http://your-server/live/livestream-1.ts\n        #         ...\n        # Overwrite by env SRS_VHOST_HLS_HLS_ENTRY_PREFIX for all vhosts.\n        # optional, default to empty string.\n        hls_entry_prefix http://your-server;\n        # the default audio codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for mp3.\n        # the available audio codec:\n        #       aac, mp3, an\n        # Overwrite by env SRS_VHOST_HLS_HLS_ACODEC for all vhosts.\n        # default: aac\n        hls_acodec aac;\n        # the default video codec of hls.\n        # when codec changed, write the PAT/PMT table, but maybe ok util next ts.\n        # so user can set the default codec for pure audio(without video) to vn.\n        # the available video codec:\n        #       h264, vn\n        # Overwrite by env SRS_VHOST_HLS_HLS_VCODEC for all vhosts.\n        # default: h264\n        hls_vcodec h264;\n        # whether cleanup the old expired ts files.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CLEANUP for all vhosts.\n        # default: on\n        hls_cleanup on;\n        # If there is no incoming packets, dispose HLS in this timeout in seconds,\n        # which removes all HLS files including m3u8 and ts files.\n        # @remark 0 to disable dispose for publisher.\n        # @remark apply for publisher timeout only, while \"etc/init.d/srs stop\" always dispose hls.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DISPOSE for all vhosts.\n        # default: 120\n        hls_dispose 120;\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # Overwrite by env SRS_VHOST_HLS_HLS_WAIT_KEYFRAME for all vhosts.\n        # default: on\n        hls_wait_keyframe on;\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enhanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_FLOOR for all vhosts.\n        # default: off\n        hls_ts_floor off;\n        # the max size to notify hls,\n        # to read max bytes from ts of specified cdn network,\n        # @remark only used when on_hls_notify is config.\n        # Overwrite by env SRS_VHOST_HLS_HLS_NB_NOTIFY for all vhosts.\n        # default: 64\n        hls_nb_notify 64;\n\n        # Whether enable hls_ctx for HLS streaming, for which we create a \"fake\" connection for HTTP API and callback.\n        # For each HLS streaming session, we use a child m3u8 with a session identified by query \"hls_ctx\", it simply\n        # work as the session id.\n        # Once the HLS streaming session is created, we will cleanup it when timeout in 2*hls_window seconds. So it\n        # takes a long time period to identify the timeout.\n        # Now we got a HLS stremaing session, just like RTMP/WebRTC/HTTP-FLV streaming, we're able to stat the session\n        # as a \"fake\" connection, do HTTP callback when start playing the HLS streaming. You're able to do querying and\n        # authentication.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_CTX for all vhosts.\n        # Default: on\n        hls_ctx on;\n        # For HLS pseudo streaming, whether enable the session for each TS segment.\n        # If enabled, SRS HTTP API will show the statistics about HLS streaming bandwidth, both m3u8 and ts file. Please\n        # note that it also consumes resource, because each ts file should be served by SRS, all NGINX cache will be\n        # missed because we add session id to each ts file.\n        # Note that it will make NGINX edge cache always missed, so never enable HLS streaming if use NGINX edges.\n        # Overwrite by env SRS_VHOST_HLS_HLS_TS_CTX for all vhosts.\n        # Default: on\n        hls_ts_ctx on;\n\n        # whether using AES encryption.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEYS for all vhosts.\n        # default: off\n        hls_keys on;\n        # the number of clear ts which one key can encrypt.\n        # Overwrite by env SRS_VHOST_HLS_HLS_FRAGMENTS_PER_KEY for all vhosts.\n        # default: 5\n        hls_fragments_per_key 5;\n        # the hls key file name.\n        # we supports some variables to generate the filename.\n        #       [vhost], the vhost of stream.\n        #       [app], the app of stream.\n        #       [stream], the stream name of stream.\n        #       [seq], the sequence number of key corresponding to the ts.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE for all vhosts.\n        hls_key_file [app]/[stream]-[seq].key;\n        # the key output path.\n        # the key file is configed by hls_path/hls_key_file, the default is:\n        # ./objs/nginx/html/[app]/[stream]-[seq].key\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_FILE_PATH for all vhosts.\n        hls_key_file_path ./objs/nginx/html;\n        # the key root URL, use this can support https.\n        # @remark It's optional.\n        # Overwrite by env SRS_VHOST_HLS_HLS_KEY_URL for all vhosts.\n        hls_key_url https://localhost:8080;\n\n        # Special control controls.\n        ###########################################\n        # Whether calculate the DTS of audio frame directly.\n        # If on, guess the specific DTS by AAC samples, please read https://github.com/ossrs/srs/issues/547#issuecomment-294350544\n        # If off, directly turn the FLV timestamp to DTS, which might cause corrupt audio stream.\n        # @remark Recommend to set to off, unless your audio stream sample-rate and timestamp is not correct.\n        # Overwrite by env SRS_VHOST_HLS_HLS_DTS_DIRECTLY for all vhosts.\n        # Default: on\n        hls_dts_directly on;\n\n        # on_hls, never config in here, should config in http_hooks.\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling SRS Callbacks with Go HTTP Server\nDESCRIPTION: Go example demonstrating how to handle SRS callbacks (specifically on_publish event). It reads the request body, prints it, and returns a successful response with code 0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nhttp.HandleFunc(\"/api/v1/streams\", func(w http.ResponseWriter, r *http.Request) {\n    b, err := ioutil.ReadAll(r.Body)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n\n    fmt.Println(string(b))\n\n    res, err := json.Marshal(struct {\n        Code int `json:\"code\"`\n        Message string `json:\"msg\"`\n    }{\n        0, \"OK\",\n    })\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n    w.Write(res)\n})\n\n_ = http.ListenAndServe(\":8085\", nil)\n```\n\n----------------------------------------\n\nTITLE: Running SRS with Valgrind Memcheck\nDESCRIPTION: Command to run SRS with Valgrind's memcheck tool for comprehensive memory leak and error detection. This provides detailed information about memory issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nvalgrind --leak-check=full --show-leak-kinds=all ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing\nDESCRIPTION: FFMPEG command loop to continuously publish a stream to SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Server Configuration using Kill Signal\nDESCRIPTION: Commands to reload the SRS server configuration using the SIGHUP signal (signal 1). This can be done either using killall command, direct process signal, or the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/reload.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkillall -1 srs\n```\n\nLANGUAGE: bash\nCODE:\n```\nkill -1 7635\n```\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Demand RTMP Streaming in SRS\nDESCRIPTION: This configuration snippet sets the timeout for disconnecting a publisher when there are no active players. Setting it to 0 disables the feature. This is useful for implementing on-demand live streaming without manual intervention.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# The timeout in seconds to disconnect publisher when idle, which means no players.\n# Note that 0 means no timeout or this feature is disabled.\n# Note that this feature conflicts with forward, because it disconnect the publisher stream.\n# Overwrite by env SRS_VHOST_PUBLISH_KICKOFF_FOR_IDLE for all vhosts.\n# default: 0\nkickoff_for_idle 0;\n```\n\n----------------------------------------\n\nTITLE: Publishing an FLV File as an RTMP Stream using FFmpeg (Bash)\nDESCRIPTION: Uses FFmpeg within an infinite loop to continuously publish a local FLV file (`./doc/source.flv`) as an RTMP stream to the SRS server running at `192.168.1.170`. The `-re` option ensures native frame rate playback, `-c copy` prevents re-encoding (passing through existing codecs), and `-f flv` specifies the output container format for RTMP. The stream is named `livestream` under the `live` application. Requires FFmpeg binary at `./objs/ffmpeg/bin/ffmpeg` and the source file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Check System File Descriptor Limits\nDESCRIPTION: Command to view the system's file descriptor limits after setting them to 10240.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server with FFmpeg Exec\nDESCRIPTION: SRS3 configuration for an edge server that receives RTMP streams and converts them to UDP MPEG-TS using FFmpeg. The exec feature runs FFmpeg for each incoming stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n    listen              19350;\n    max_connections     1024;\n    srs_log_tank        file;\n    srs_log_file        ./objs/srs.slave.log;\n    srs_log_level       error;\n    vhost __defaultVhost__ {\n        exec {\n            enabled     on;\n            publish     ./objs/ffmpeg/bin/ffmpeg -v quiet -re -i rtmp://127.0.0.1:1935/[app]?vhost=[vhost]/[stream] -c copy -vbsf h264_mp4toannexb -f mpegts \"udp://[stream]?localaddr=127.0.0.1&pkt_size=1316\";\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Publishing an RTMP Stream with FFmpeg\nDESCRIPTION: A command to publish a stream to the SRS RTMP server using FFmpeg. This command takes a source video file and streams it to the RTMP server at localhost with the stream name 'livestream'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFmpeg\nDESCRIPTION: This FFmpeg command publishes a stream to SRS with additional parameters that can be used for authentication or other purposes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://localhost/live/livestream?k=v\n```\n\n----------------------------------------\n\nTITLE: SRS Ingest Configuration - Configuration\nDESCRIPTION: Sample configuration file for SRS ingest functionality, defining ingest settings for file input and RTMP output.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ingest.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    ingest livestream {\n        enabled      on;\n        input {\n            type    file;\n            url     ./doc/source.flv;\n        }\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled          off;\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for aarch64 Cross-Build Using Extra Flags - Bash\nDESCRIPTION: This bash snippet customizes the SRS configuration for an aarch64 target by explicitly specifying the architecture via --extra-flags. This is necessary if the CPU architecture is not automatically detected. Dependency: SRS source tree and necessary build tools on an ARM server. The output is a build prepared specifically for aarch64 CPUs. Use this when automatic detection fails. Requires bash and configure scripts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n./configure --extra-flags='-D__aarch64__' && make\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Vhost HTTP Static Directory - SRS Configuration - Bash\nDESCRIPTION: Specifies per-vhost static HTTP settings within the SRS configuration. The 'http_static' block enables per-vhost static serving, lets you set the mounted URL path via 'mount', and define the root directory using 'dir'. This overrides the global HTTP server config for that vhost, ensuring fine-tuned control for each domain or application.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # http static vhost specified config\n    http_static {\n        # whether enabled the http static service for vhost.\n        # default: off\n        enabled     on;\n        # the url to mount to, \n        # typical mount to [vhost]/\n        # the variables:\n        #       [vhost] current vhost for http server.\n        # @remark the [vhost] is optional, used to mount at specified vhost.\n        # @remark the http of __defaultVhost__ will override the http_stream section.\n        # for example:\n        #       mount to [vhost]/\n        #           access by http://ossrs.net:8080/xxx.html\n        #       mount to [vhost]/hls\n        #           access by http://ossrs.net:8080/hls/xxx.html\n        #       mount to /\n        #           access by http://ossrs.net:8080/xxx.html\n        #           or by http://192.168.1.173:8080/xxx.html\n        #       mount to /hls\n        #           access by http://ossrs.net:8080/hls/xxx.html\n        #           or by http://192.168.1.173:8080/hls/xxx.html\n        # default: [vhost]/\n        mount       [vhost]/hls;\n        # main dir of vhost,\n        # to delivery HTTP stream of this vhost.\n        # default: ./objs/nginx/html\n        dir         ./objs/nginx/html/hls;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS from trunk directory\nDESCRIPTION: Command to start SRS directly from the trunk directory using the init.d script without installing it as a system service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\n./etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with WebRTC Configuration in Bash\nDESCRIPTION: Docker command to run SRS with WebRTC support, passing the CANDIDATE environment variable for proper WebRTC connectivity.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.3.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:4 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using kill and PID (Shell)\nDESCRIPTION: This command sends the SIGHUP signal (signal 1) directly to a specific SRS process identified by its Process ID (PID), in this example, 7635. This achieves the same result as `killall -1 srs` but targets only a single process instance. You need to know the correct PID of the SRS server process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reload.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nkill -1 7635\n```\n\n----------------------------------------\n\nTITLE: Streaming to SRS using FFmpeg\nDESCRIPTION: FFmpeg command to stream a local video file to SRS server using RTMP protocol. The stream will be automatically converted to HLS by the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTMP to WebRTC Configuration\nDESCRIPTION: Start SRS server with RTMP to WebRTC conversion configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Adding SRS as service in Ubuntu\nDESCRIPTION: Command to add SRS as a system service in Ubuntu 12, enabling automatic startup on system boot.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n#ubuntu12\nsudo update-rc.d srs defaults\n```\n\n----------------------------------------\n\nTITLE: Network Statistics Monitoring Commands\nDESCRIPTION: Commands to monitor network statistics and UDP packets, including packet drops and buffer errors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnetstat -suna\nnetstat -suna && sleep 30 && netstat -suna\nnetstat -lpun\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for aarch64\nDESCRIPTION: Configures the SRS build system for cross-compilation targeting aarch64. It specifies the cross-compiler (`--cc`, `--cxx`), archiver (`--ar`), linker (`--ld`), and random library tool (`--randlib`) using the installed `aarch64-linux-gnu` toolchain. After configuration, it runs `make` to build the SRS binary.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cc=aarch64-linux-gnu-gcc --cxx=aarch64-linux-gnu-g++ \\\n    --ar=aarch64-linux-gnu-ar --ld=aarch64-linux-gnu-ld --randlib=aarch64-linux-gnu-randlib &&\nmake\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus Exporter in SRS\nDESCRIPTION: This YAML snippet shows the configuration options for the Prometheus Exporter in SRS. It includes settings for enabling the exporter, specifying the listen port, and setting labels and tags for categorizing cluster servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nexporter {\n    enabled off;\n    listen 9972;\n    label cn-beijing;\n    tag cn-edge;\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker with WebRTC over TCP and Live Streaming on Port 8080\nDESCRIPTION: This Docker command runs SRS 5.0.60 with WebRTC over TCP and live streaming support enabled on port 8080. It includes additional configuration for RTC to RTMP conversion.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080/tcp \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_VHOST_RTC_RTC_TO_RTMP=on \\\n  -e SRS_HTTP_API_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: Building SRS with Docker for aarch64\nDESCRIPTION: Commands to build SRS for aarch64 architecture using Docker. This allows compilation on a non-ARM host machine targeting ARM architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \\\n    bash -c \"./configure && make\"\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for Latency Benchmark\nDESCRIPTION: SRS configuration used for latency benchmarking, including settings for GOP cache and HLS (HTTP Live Streaming) with specific fragment and window sizes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/low-latency.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    enabled         on;\n    play {\n        gop_cache       off;\n    }\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    5;\n        hls_window      20;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example RTMP Playback URL\nDESCRIPTION: Provides the example URL for playing the RTMP stream published to the SRS server using a compatible player. This specific URL points to the 'livestream' stream within the 'live' application on the local SRS instance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp.md#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nrtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Restarting SRS Service\nDESCRIPTION: Command to restart the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs restart\n```\n\n----------------------------------------\n\nTITLE: Defining the `on_ocr` HTTP Callback Request/Response Structure (JSON)\nDESCRIPTION: This JSON snippet illustrates the request payload sent by SRS/Oryx for the `on_ocr` HTTP callback and the expected response format. The request includes stream details (`vhost`, `app`, `stream`), OCR task specifics (`uuid`, `prompt`, `result`), and callback context (`request_id`, `action`, `opaque`). The backend service should acknowledge receipt with a simple JSON object containing a `code` field (typically 0 for success). SRS ignores any response errors for this callback.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_ocr\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"prompt\": \"What is in the image?\",\n  \"result\": \"The image shows a scene featuring a character from a film, likely set in a military or high-tech environment.\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Monitoring SRS Pod Logs during Graceful Shutdown\nDESCRIPTION: These Bash commands use `kubectl exec` to tail the SRS log file (`objs/srs.log`) inside the terminating pods during a rolling update. The logs show messages related to receiving the termination signal (`sig=3` or `signo=15`), initiating graceful quit, waiting for connections to close (`wait for X conns to quit`), and the final termination of the process. This helps verify that the graceful shutdown mechanism is working as expected.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- tail -f objs/srs.log\n[2020-02-19 11:07:20.818][Trace][1][937] sig=3, user start gracefully quit\n[2020-02-19 11:07:20.960][Trace][1][937] force gracefully quit, signo=15\n[2020-02-19 11:07:21.772][Trace][1][932] cleanup for quit signal fast=0, grace=1\n[2020-02-19 11:07:21.772][Warn][1][932][11] main cycle terminated, system quit normally.\ncommand terminated with exit code 137\n\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- tail -f objs/srs.log\n[2020-02-19 11:07:23.095][Trace][1][1009] sig=3, user start gracefully quit\n[2020-02-19 11:07:23.316][Trace][1][1009] force gracefully quit, signo=15\n[2020-02-19 11:07:23.784][Trace][1][1004] cleanup for quit signal fast=0, grace=1\n[2020-02-19 11:07:23.784][Warn][1][1004][11] main cycle terminated, system quit normally.\n[2020-02-19 11:07:24.784][Trace][1][1004] wait for 1 conns to quit\n[2020-02-19 11:07:26.968][Trace][1][1010] <- CPB time=120041497, okbps=0,0,0, ikbps=252,277,0, mr=0/350, p1stpt=20000, pnt=5000\n[2020-02-19 11:08:26.791][Trace][1][1004] wait for 1 conns to quit\n[2020-02-19 11:08:52.602][Trace][1][1010] edge change from 200 to state 0 (init).\n[2020-02-19 11:08:52.792][Trace][1][1004] wait for 0 conns to quit\ncommand terminated with exit code 137\n```\n\n----------------------------------------\n\nTITLE: Optimized FFmpeg Command for SRT Streaming with AAC Audio\nDESCRIPTION: FFmpeg command for pushing SRT stream with AAC audio, using the pes_payload_size parameter set to 0 to prevent merging multiple AAC frames into a single PES packet, reducing latency and audio-video sync issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i source.mp4 -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source on Windows (Cygwin)\nDESCRIPTION: Commands to build SRS from source code using Cygwin on Windows. This process involves checking out the develop branch, configuring the build, and compiling the project.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/windows.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout develop\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server for RTMP to WebRTC Conversion in Bash\nDESCRIPTION: Command to start the SRS server with a configuration for converting RTMP to WebRTC streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Cloning Specific SRS Branches with and without Depth - Bash\nDESCRIPTION: These bash snippet variants demonstrate cloning specific SRS branches (such as 3.0release, develop, and min) from Gitee, both as full clones and with the --depth=1 option for shallow clones. This allows developers to optimize for either full repository history or faster/lightweight checkouts. Requires git and internet connectivity. Key parameters: branch name, clone depth. Outputs: a checked-out local branch directory with either full or shallow commit history.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/resource.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 3.0release https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 3.0release --depth=1 https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop --depth=1 https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b min https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b min --depth=1 https://gitee.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Server Response\nDESCRIPTION: Example output from the HTTP callback server showing a publish event.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nGot action=on_publish, client_id=3y1tcaw2, ip=127.0.0.1, vhost=__defaultVhost__, stream=livestream, param=?k=v\n```\n\n----------------------------------------\n\nTITLE: Graceful Quit Configuration for SRS - Bash (Configuration File Syntax)\nDESCRIPTION: Specifies SRS configuration parameters for graceful shutdown operations, including wait timing and SIGTERM handling. Should be placed in the SRS configuration file. Parameters include 'grace_start_wait', 'grace_final_wait', and 'force_grace_quit', all affecting shutdown behavior. Values are in milliseconds or on/off toggles. Allows zero-downtime upgrades and controlled service transitions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n# For gracefully quit, wait for a while then close listeners,\\n# because K8S notify SRS with SIGQUIT and update Service simultaneously,\\n# maybe there is some new connections incoming before Service updated.\\n# @see https://github.com/ossrs/srs/issues/1595#issuecomment-587516567\\n# default: 2300\\ngrace_start_wait 2300;\\n# For gracefully quit, final wait for cleanup in milliseconds.\\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587414898\\n# default: 3200\\ngrace_final_wait 3200;\\n# Whether force gracefully quit, never fast quit.\\n# By default, SIGTERM which means fast quit, is sent by K8S, so we need to\\n# force SRS to treat SIGTERM as gracefully quit for gray release or canary.\\n# @see https://github.com/ossrs/srs/issues/1579#issuecomment-587475077\\n# default: off\\nforce_grace_quit off;\n```\n\n----------------------------------------\n\nTITLE: Running sb_rtmp_load RTMP Load Test - Bash\nDESCRIPTION: This Bash command starts the sb_rtmp_load RTMP benchmarking tool with 10 clients against the specified RTMP endpoint, discarding stdout to /dev/null and backgrounding the process. Requires sb_rtmp_load compiled and available at './objs/sb_rtmp_load'. The '-c' parameter specifies client count, '-r' the RTMP URL.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/raspberrypi.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 10 -r rtmp://192.168.1.105:1935/live/livestream >/dev/null &\n\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Command for Stream Publishing\nDESCRIPTION: FFMPEG command used as an encoder to publish a stream to the SRS master server. This loop continuously publishes the source.flv file to the RTMP endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do\\\n    ./objs/ffmpeg/bin/ffmpeg -re -i doc/source.flv \\\n        -c copy -f flv rtmp://192.168.1.5:1935/live/livestream; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Updating the Local SRS Repository using Git (Bash)\nDESCRIPTION: Pulls the latest changes from the remote SRS repository into the local working directory using `git pull`. This command is used to update an existing clone of the SRS source code. Requires Git and assumes the user is already within the local repository directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Filtering SRS Logs by Stream Name in Bash\nDESCRIPTION: Example of further refining log search by combining grep filters to identify specific stream names, showing how to find all publish events for a stream called 'livestream'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"|grep -a \"livestream\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFMPEG\nDESCRIPTION: Script to continuously publish a video stream to the RTMP cluster using FFMPEG. It publishes to the edge server which forwards the stream to the origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Documenting EXT-X-VERSION Tag Usage - Markdown - English\nDESCRIPTION: This snippet shows the syntax for the EXT-X-VERSION tag, which is used to declare the protocol version of a playlist file. The tag takes an integer value and should be present in any playlist using features not supported by version 1. This ensures compliance with the correct set of protocol features during playback or playlist generation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_19\n\nLANGUAGE: markdown\nCODE:\n```\n#EXT-X-VERSION:<n>\n```\n\n----------------------------------------\n\nTITLE: Configuring Global SRS HTTP Server Settings (SRS Config)\nDESCRIPTION: This configuration snippet defines the global settings for the SRS embedded HTTP server within the srs.conf file. The `enabled` directive turns the server on or off. `listen` specifies the port the server will bind to (default 8080). `dir` sets the root directory for serving static files (default ./objs/nginx/html). This section is essential for enabling basic HTTP functionality and serving files like HLS segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-server.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# embeded http server in srs.\n# the http streaming config, for HLS/HDS/DASH/HTTPProgressive\n# global config for http streaming, user must config the http section for each vhost.\n# the embed http server used to substitute nginx in ./objs/nginx,\n# for example, srs runing in arm, can provides RTMP and HTTP service, only with srs installed.\n# user can access the http server pages, generally:\n#       curl http://192.168.1.170:80/srs.html\n# which will show srs version and welcome to srs.\n# @remeark, the http embeded stream need to config the vhost, for instance, the __defaultVhost__\n# need to open the feature http of vhost.\nhttp_server {\n    # whether http streaming service is enabled.\n    # default: off\n    enabled         on;\n    # the http streaming port\n    # @remark, if use lower port, for instance 80, user must start srs by root.\n    # default: 8080\n    listen          8080;\n    # the default dir for http root.\n    # default: ./objs/nginx/html\n    dir             ./objs/nginx/html;\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing Sequence Header for SRS RTMP/HTTP-FLV Playback\nDESCRIPTION: Enables reduction of sequence headers for clients that cannot handle duplicated headers. This is useful when the sequence header hasn't changed but some clients have issues with duplicates.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        reduce_sequence_header  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating NSIS Installer Package for SRS on Windows\nDESCRIPTION: Command to package SRS as a Windows installer using NSIS (Nullsoft Scriptable Install System). This creates an executable installer with the SRS version embedded and references the Cygwin directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/windows.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"/cygdrive/c/Program Files (x86)/NSIS/makensis.exe\" \\\n    /DSRS_VERSION=$(./objs/srs -v 2>&1) \\\n    /DCYGWIN_DIR=\"C:\\cygwin64\" \\\n    packaging/nsis/srs.nsi\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Server with Transcoding Config (Bash)\nDESCRIPTION: Executes the compiled SRS server binary located at `./objs/srs`, specifying the transcoding configuration file (`conf/ffmpeg.conf`) using the `-c` option. This starts the server with the defined transcoding settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ffmpeg.conf\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Information Exchange with SRS Upnodes\nDESCRIPTION: Configures whether SRS should exchange debug information (like connection ID, source ID, PID) when connecting to an upstream SRS node (used in forward, edge push, or edge pull scenarios). Enabling this ('on') is strongly recommended for debugging inter-SRS communication. The default is 'on'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    # when upnode(forward to, edge push to, edge pull from) is srs,\n    # it's strongly recommend to open the debug_srs_upnode,\n    # when connect to upnode, it will take the debug info, \n    # for example, the id, source id, pid.\n    # please see https://ossrs.io/lts/en-us/docs/v4/doc/log\n    # default: on\n    debug_srs_upnode    on;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Prometheus Configuration\nDESCRIPTION: YAML configuration for Prometheus to scrape metrics from both node_exporter and SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/exporter.md#2025-04-23_snippet_3\n\nLANGUAGE: yml\nCODE:\n```\nscrape_configs:\n  - job_name: \"node\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9100\"]\n  - job_name: \"srs\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9972\"]\n```\n\n----------------------------------------\n\nTITLE: Cloning the SRS Repository (Bash)\nDESCRIPTION: Clones the SRS source code repository from GitHub using Git and changes the current directory to the `srs/trunk` folder. This is the initial step to get the required source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Pushing MPEGTS Stream with FFmpeg\nDESCRIPTION: FFmpeg command to push a video file as MPEG-TS over UDP to SRS's stream caster on port 8935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/streamer.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy -f mpegts udp://127.0.0.1:8935\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Daemon Mode\nDESCRIPTION: Shows the `daemon` directive within an SRS configuration file. Setting this value to `on` (which is the default) instructs SRS to run as a background daemon process, detaching from the controlling terminal, similar to using `nohup`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_7\n\nLANGUAGE: properties\nCODE:\n```\n# whether start as deamon\n# default: on\ndaemon              on;\n```\n\n----------------------------------------\n\nTITLE: SRS Slave Server Configuration (Port 1936)\nDESCRIPTION: Configuration file for SRS slave server listening on port 1936.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/forward.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1936;\npid                 ./objs/srs.1936.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Logging HTTP DVR Callback Requests - SRS Log Output - Log\nDESCRIPTION: This snippet contains typical SRS and API server log output generated when an HTTP callback for a DVR event is triggered. The log includes a POST request to the callback endpoint with JSON-formatted action and file metadata, as well as subsequent traces confirming request receipt and completion. Review these logs to verify correct operation and troubleshoot event delivery; the log assumes a functioning SRS and callback server environment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/dvr.md#2025-04-23_snippet_4\n\nLANGUAGE: log\nCODE:\n```\n[2015-01-03 15:25:48][trace] post to dvrs, req={\"action\":\"on_dvr\",\"client_id\":108,\"ip\":\"127.0.0.1\",\"vhost\":\"__defaultVhost__\",\"app\":\"live\",\"stream\":\"livestream\",\"cwd\":\"/home/winlin/git/srs/trunk\",\"file\":\"./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\"}\n[2015-01-03 15:25:48][trace] srs on_dvr: client id=108, ip=127.0.0.1, vhost=__defaultVhost__, app=live, stream=livestream, cwd=/home/winlin/git/srs/trunk, file=./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\n127.0.0.1 - - [03/Jan/2015:15:25:48] \"POST /api/v1/dvrs HTTP/1.1\" 200 1 \"\" \"SRS(Simple RTMP Server)2.0.88\"\n```\n\n----------------------------------------\n\nTITLE: Creating PV and PVC for SRS Storage\nDESCRIPTION: Creates a Persistent Volume (PV) and Persistent Volume Claim (PVC) using Alibaba Cloud NAS for shared storage between SRS and Nginx pods.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: pv-nas\n  labels:\n    pv: nfs-pv\nspec:\n  capacity:\n    storage: 100Gi\n  storageClassName: nas\n  accessModes:\n    - ReadWriteMany\n    - ReadOnlyMany\n  persistentVolumeReclaimPolicy: Retain\n  flexVolume:\n    driver: \"alicloud/nas\"\n    options:\n      server: \"1abb5492f7-ubq80.cn-beijing.nas.aliyuncs.com\"\n      path: \"/k8s\"\n      vers: \"3\"\n      options: \"nolock,tcp,noresvport\"\n\n---\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: pvc-nas\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: nas\n  resources:\n    requests:\n      storage: 100Gi\n  selector:\n    matchLabels:\n      pv: nfs-pv\n```\n\n----------------------------------------\n\nTITLE: Configuring Timestamp Jitter for RTMP Delivery in SRS\nDESCRIPTION: This configuration snippet shows how to set up timestamp jitter correction for RTMP delivery in a vhost. It includes options for time_jitter algorithm (full/zero/off) and mixed correction to ensure monotonically increasing timestamps for both video and audio streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/time-jitter.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost jitter.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing, \n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # default: full\n        time_jitter             full;\n        # whether use the interleaved/mixed algorithm to correct the timestamp.\n        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.\n        # if off, use time_jitter to correct the timestamp if required.\n        # default: off\n        mix_correct             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS in aarch64 Docker Container using Shell Commands - Shell\nDESCRIPTION: This snippet shows how to run an aarch64 Docker container, mount the current working directory, and build the SRS server inside the container using bash, configure, and make. Dependency: Docker with access to the ossrs/srs:aarch64 image. The key parameters are the Docker volume, working directory mapping, and the build commands. The output is an SRS build targeting aarch64/ARMv8 within the container. Ensure Docker is installed and accessible.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n```\ndocker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \\\n    bash -c \"./configure && make\"\n```\n```\n\n----------------------------------------\n\nTITLE: Analyzing GMP Results\nDESCRIPTION: Command to analyze GMP results using pprof tool, showing memory allocation hotspots\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/pprof --text objs/srs gperf.srs.gmp*\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Stream Publishing Loop\nDESCRIPTION: Bash script using FFmpeg to continuously publish a video stream to SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin and Edge Servers (Bash)\nDESCRIPTION: Starts three SRS instances in the background (`&`). The first uses the origin configuration (`conf/http.flv.live.conf`), and the next two use distinct edge configurations (`conf/http.flv.live.edge1.conf`, `conf/http.flv.live.edge2.conf`). Assumes the `srs` executable is in the `./objs/` directory relative to where the command is run (typically `srs/trunk`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.flv.live.conf &\n./objs/srs -c conf/http.flv.live.edge1.conf &\n./objs/srs -c conf/http.flv.live.edge2.conf &\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source using Cygwin (Bash)\nDESCRIPTION: Provides the commands to clone the development branch, configure the build environment, and compile the SRS server on a Windows system using the Cygwin terminal. Prerequisites include installing Cygwin64 and specific packages like gcc-g++, make, automake, patch, pkg-config, tcl, and cmake. Successful execution results in an `srs.exe` executable located in the `./objs/` directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/windows.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout develop\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Pausing and Resuming Kubernetes Deployment Rollouts\nDESCRIPTION: These Bash commands control the rollout process of a Kubernetes Deployment. `kubectl rollout pause deploy/srs-edge-deploy` pauses the ongoing or subsequent rollout for the specified deployment, preventing further pod updates. `kubectl rollout resume deploy/srs-edge-deploy` resumes a paused rollout, allowing Kubernetes to continue updating pods according to the deployment strategy. This is useful for managing updates in stages or temporarily halting a problematic rollout.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nkubectl rollout pause deploy/srs-edge-deploy\nkubectl rollout resume deploy/srs-edge-deploy\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 5.0 Branch using Git\nDESCRIPTION: Command to pull the latest changes and switch to the SRS 5.0 branch (develop). This is used if the 5.0release branch doesn't exist.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/git.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout develop\n```\n\n----------------------------------------\n\nTITLE: Mounting RAM Disk for HLS Segments - Bash\nDESCRIPTION: This snippet demonstrates how to create and mount a temporary in-memory filesystem using Linux commands for high-performance HLS segment delivery. The 'mkdir' creates the target directory, and 'mount -o size=7G -t tmpfs none /ramdisk' sets up a 7GB RAM disk at '/ramdisk'. Prerequisites include root privileges, appropriate Linux kernel modules, and available RAM. Inputs: N/A. Outputs: '/ramdisk' directory acts as a fast, volatile storage location for HLS slices. Limitation: Data is lost on unmount or reboot; ensure sufficient RAM.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p /ramdisk &&\nmount -o size=7G -t tmpfs none /ramdisk\n```\n\n----------------------------------------\n\nTITLE: Tracing Client Session Logs in SRS\nDESCRIPTION: Example of using grep to trace a specific client session using PID and session ID in SRS edge server logs\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"\\[12665\\]\\[114\\]\" objs/edge.log\n```\n\n----------------------------------------\n\nTITLE: Installing Logrotate Utility - Shell\nDESCRIPTION: This command installs the 'logrotate' tool on CentOS/RHEL systems using yum. Logrotate is required for automated log file rotation, compression, and retention. Output: successful installation of the logrotate package. Must be run with superuser privileges. Does not configure logrotate itself.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/log-rotate.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nsudo yum install -y logrotate\n```\n\n----------------------------------------\n\nTITLE: Configuring Vhosts with Different Settings\nDESCRIPTION: This example shows how to configure two vhosts with different chunk sizes for CCTV (minimizing latency) and Wasu (faster startup).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n    chunk_size 128;\n}\nvhost show.wasu.cn {\n    chunk_size 4096;\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository via GitHub - Bash\nDESCRIPTION: Performs a direct git clone operation from the official SRS repository on GitHub. This command requires Git and Internet access to github.com. No directory parameter is specified, so the default directory created will be 'srs'. Input: command as typed. Output: clones the full SRS source into the working directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/resource.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with HEVC Support\nDESCRIPTION: Docker command to run SRS 6.0+ with HEVC configuration enabled on ports 1935 and 8080\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:6 \\\n  ./objs/srs -c conf/hevc.flv.conf\n```\n\n----------------------------------------\n\nTITLE: Starting Prometheus with Configuration\nDESCRIPTION: Docker command to start Prometheus with the custom configuration file. It mounts the local prometheus.yml file and exposes the Prometheus web interface on port 9090.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n  -p 9090:9090 prom/prometheus\n```\n\n----------------------------------------\n\nTITLE: Building libx265 from source\nDESCRIPTION: Compiles the libx265 library from source code, which is required for HEVC encoding in FFmpeg. Uses CMake to configure the build with static libraries and installs it to a local directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://bitbucket.org/multicoreware/x265_git.git ~/git/x265_git\ncd ~/git/x265_git/build/linux\ncmake -DCMAKE_INSTALL_PREFIX=$(pwd)/build -DENABLE_SHARED=OFF ../../source\nmake -j10\nmake install\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Keyframe Waiting in SRS\nDESCRIPTION: Determines whether SRS waits for keyframes before creating new HLS segments. When enabled, SRS will only create a new segment when the duration exceeds the fragment length and a keyframe is encountered, ensuring segments start with keyframes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # default: on\n        hls_wait_keyframe       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Forward Request JSON Example\nDESCRIPTION: Example JSON request body sent by SRS to the backend server for dynamic forwarding configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"action\": \"on_forward\",\n    \"server_id\": \"vid-k21d7y2\",\n    \"client_id\": \"9o7g1330\",\n    \"ip\": \"127.0.0.1\",\n    \"vhost\": \"__defaultVhost__\",\n    \"app\": \"live\",\n    \"tcUrl\": \"rtmp://127.0.0.1:1935/live\",\n    \"stream\": \"livestream\",\n    \"param\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Time Jitter for DVR in SRS Configuration File (Bash)\nDESCRIPTION: This snippet shows how to set the 'time_jitter' parameter under the 'dvr' section in the SRS vhost configuration for recording RTMP streams to file. By adjusting the 'time_jitter' setting, administrators ensure that both audio and video timestamps remain monotonically increasing, in compliance with RTMP specifications. This requires modifying the relevant SRS config files, and the output is a correctly recorded file adhering to the expected timestamp behavior.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/time-jitter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost dvr.srs.com {\n    # dvr RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv according by specified dvr_plan.\n    # http callbacks:\n    # @see http callback on_dvr_hss_reap_flv on http_hooks section.\n    dvr {\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing, \n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # default: full\n        time_jitter             full;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Playing HEVC Encoded Video via SRT using FFplay\nDESCRIPTION: This FFplay command shows how to play HEVC encoded video streamed over SRT. It uses the SRT URL format with streamid parameter to specify the stream and request mode.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::h=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Installing ARMv7 Cross-Compilation Toolchain in Ubuntu Docker\nDESCRIPTION: Inside the Ubuntu 16 Docker container, this command installs the `gcc-arm-linux-gnueabihf` and `g++-arm-linux-gnueabihf` packages, providing the necessary toolchain for cross-compiling SRS for ARMv7 architecture with hard-float support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Streaming to SRS using FFmpeg\nDESCRIPTION: This FFmpeg command streams a local video file to SRS using RTMP protocol. It copies the audio and video codecs without re-encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Illustrating Live Streaming Workflow with ASCII Diagram\nDESCRIPTION: This ASCII diagram illustrates the basic workflow of live streaming, showing the flow from the encoder through the SRS/CDN network to the player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/client-sdk.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n+---------+      +-----------------+       +---------+\n| Encoder +-->---+ SRS/CDN Network +--->---+ Player  |\n+---------+      +-----------------+       +---------+\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up FFmpeg 5.1 for HEVC over RTMP\nDESCRIPTION: Clones FFmpeg 5.1.2 which requires patching to support HEVC over RTMP/FLV. The specific version is chosen for compatibility with the available patches.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b n5.1.2 https://github.com/FFmpeg/FFmpeg.git ~/git/FFmpeg\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Wait Keyframe in SRS\nDESCRIPTION: Controls when HLS segments are created. When enabled, SRS waits for both the duration to exceed the fragment size and a keyframe to appear before creating a new segment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_7\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # default: on\n        hls_wait_keyframe       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFplay SRT Stream Playback\nDESCRIPTION: Command to play SRT stream using FFplay.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-srt.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Enabling TCP NoDelay in SRS\nDESCRIPTION: Controls whether the TCP_NODELAY socket option is enabled for connections. When enabled, SRS sets the nodelay option on the file descriptor using setsockopt, which can reduce latency but may increase bandwidth usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_9\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # whether enable the TCP_NODELAY\n    # if on, set the nodelay of fd by setsockopt\n    # default: off\n    tcp_nodelay     on;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP FLV POST Stream Converter\nDESCRIPTION: Configuration snippet for enabling and setting up a stream converter that accepts FLV via HTTP POST and converts it to RTMP. It defines converter type, dynamic output RTMP URL pattern, and TCP port to listen on.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/streamer.md#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n# Push FLV by HTTP POST to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       flv, push FLV by HTTP POST and convert to RTMP.\n    caster flv;\n    # The output rtmp url.\n    # For flv converter, the typically output url:\n    #           rtmp://127.0.0.1/[app]/[stream]\n    # For example, POST to url:\n    #           http://127.0.0.1:8936/live/livestream.flv\n    # Where the [app] is \"live\" and [stream] is \"livestream\", output is:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/[app]/[stream];\n    # The listen port for stream converter.\n    # For flv converter, listen at tcp port. for example, 8936.\n    listen 8936;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with systemctl\nDESCRIPTION: Command to start the SRS service using systemctl on systems that support it.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start srs\n```\n\n----------------------------------------\n\nTITLE: Creating SRS Origin Deployment in Kubernetes\nDESCRIPTION: This YAML snippet creates a Kubernetes Deployment to run an SRS origin server. It specifies a single replica using the ossrs/srs:3 Docker image and exposes ports 1935, 1985, and 8080.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deploy\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTMP via Docker - Bash\nDESCRIPTION: This snippet demonstrates how to launch the SRS streaming server with RTMP support by using Docker. The command pulls the \\\"ossrs/srs:5\\\" image, maps the RTMP default port (1935), and executes SRS with the specified configuration file. It requires Docker to be installed and accessible from the command line. Inputs include the local port to map and optional configuration adjustments; output is an SRS server instance ready to ingest RTMP streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 ossrs/srs:5 \\\n  ./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS from GitLab Mirror\nDESCRIPTION: Commands to clone SRS from GitLab mirror and switch remote to GitHub origin\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/resource.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitlab.com/winlinvip/srs-gitlab.git srs &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Running Oryx in Docker Container\nDESCRIPTION: Docker command to create and run an Oryx instance as a container. This command mounts local storage, exposes necessary ports, and uses the Oryx version 5 image.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-05-20-OCR-Video-Streams.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Go Example HTTP Callback Server\nDESCRIPTION: This command navigates into the SRS source directory containing the example Go API server (`research/api-server`) and executes the `server.go` file using `go run`. It instructs the server to listen on port 8085. This starts the built-in Go HTTP server provided with SRS, which is designed to handle SRS callbacks according to the required protocol. Requires Go to be installed and the SRS source code to be present.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncd research/api-server && go run server.go 8085\n```\n\n----------------------------------------\n\nTITLE: Adding X-Cache-Status Response Header in NGINX - NGINX\nDESCRIPTION: Adds an X-Cache-Status header to NGINX responses, populated by the current value of $upstream_cache_status. Useful for client/browser-level inspection of cache status per request. Requires existing NGINX proxy_cache setup with upstream_cache_status variable available.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_13\n\nLANGUAGE: nginx\nCODE:\n```\nadd_header X-Cache-Status $upstream_cache_status;\n```\n\n----------------------------------------\n\nTITLE: System Architecture Diagram for ATC RTMP in HLS/HDS Failover\nDESCRIPTION: ASCII diagram showing the architecture for implementing ATC-enabled RTMP streaming with hot backup support. The diagram illustrates how encoders, servers, packagers, reverse proxy, and CDN components interact in an ATC-enabled setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/rtmp-atc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n                        +----------+        +----------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n+----------+   | RTMP   +----------+ RTMP   +----------+ |   | Reverse |    +-------+\n| encoder  +->-+                                         +->-+  Proxy  +-->-+  CDN  +\n+----------+   |        +----------+        +----------+ |   | (nginx) |    +-------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n                 RTMP   +----------+ RTMP   +----------+\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream via SRT with Local FFmpeg\nDESCRIPTION: Uses a locally installed FFmpeg to publish a local file (`./doc/source.flv`) as an MPEG-TS stream over SRT to the SRS server listening on `127.0.0.1:10080`. The `streamid` parameter specifies the application (`live`), stream name (`livestream`), and mode (`publish`). Requires FFmpeg installation with SRT support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Basic SRS Prometheus Exporter Configuration\nDESCRIPTION: Configuration block for enabling and setting up the Prometheus exporter in SRS, including port settings and labeling options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/exporter.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Prometheus exporter config.\n# See https://prometheus.io/docs/instrumenting/exporters\nexporter {\n    # Whether exporter is enabled.\n    # Overwrite by env SRS_EXPORTER_ENABLED\n    # Default: off\n    enabled off;\n    # The http api listen port for exporter metrics.\n    # Overwrite by env SRS_EXPORTER_LISTEN\n    # Default: 9972\n    # See https://github.com/prometheus/prometheus/wiki/Default-port-allocations\n    listen 9972;\n    # The logging label to category the cluster servers.\n    # Overwrite by env SRS_EXPORTER_LABEL\n    label cn-beijing;\n    # The logging tag to category the cluster servers.\n    # Overwrite by env SRS_EXPORTER_TAG\n    tag cn-edge;\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream with FFMPEG in Continuous Loop\nDESCRIPTION: Bash script that continuously publishes a sample video file as an RTMP stream using FFMPEG. The script loops indefinitely, restarting the stream if it fails or completes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://127.0.0.1:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: FFmpeg SRT Stream Publishing\nDESCRIPTION: FFmpeg command to publish a stream using SRT protocol with specific stream ID parameters\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Documenting EXT-X-START Tag Usage - Markdown - English\nDESCRIPTION: This snippet shows the format for the EXT-X-START tag in HLS playlists, including its attribute list. The section details the TIME-OFFSET and PRECISE attributes, their expected values, and usage limitations. It guides playlist authors to properly indicate the preferred playback start position for media playlists while maintaining protocol compliance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_18\n\nLANGUAGE: markdown\nCODE:\n```\n#EXT-X-START:<attribute list>\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Hooks for HLS Notify in SRS YAML\nDESCRIPTION: Sets up an HTTP hook to be called when SRS reaps an HLS TS file. This can be used to push files to a CDN network.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    http_hooks {\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reducing Sequence Header Transmission in SRS Playback\nDESCRIPTION: Configures whether SRS should avoid sending duplicate sequence headers to playback clients if the header has not changed. This is useful for clients that cannot handle repeated sequence headers. Set to 'on' to enable reduction, 'off' (default) to always send headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether reduce the sequence header,\n        # for some client which cannot got duplicated sequence header,\n        # while the sequence header is not changed yet.\n        # default: off\n        reduce_sequence_header  on;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Disabling Firewall with iptables in Bash\nDESCRIPTION: This Bash code snippet shows how to stop the iptables firewall service using the init script and disable it from starting on boot via chkconfig. Ensure you have root privileges to execute these commands. Stopping the firewall is sometimes necessary to allow network traffic through for streaming applications, but be aware it reduces server security.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/install.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# disable the firewall\\nsudo /etc/init.d/iptables stop\\nsudo /sbin/chkconfig iptables off\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC Support\nDESCRIPTION: Start SRS server with WebRTC configuration and custom CANDIDATE IP\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Finding Client Session Logs\nDESCRIPTION: Demonstrates how to grep logs for a specific client session using PID and session ID to trace client connection details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngrep -ina \"\\[12665\\]\\[114\\]\" objs/edge.log\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARM using Docker\nDESCRIPTION: Command to use Docker for cross-compiling SRS for aarch64 architecture. This approach allows building ARM binaries on non-ARM systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \\\n    bash -c \"./configure && make\"\n```\n\n----------------------------------------\n\nTITLE: Configuring EXEC in SRS NGINX RTMP\nDESCRIPTION: Configuration example for setting up EXEC functionality in SRS. Demonstrates how to configure process execution on stream publish events with customizable variables like vhost, port, app, and stream names. The configuration shows how to trigger FFmpeg to record incoming streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/nginx-exec.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    # the exec used to fork process when got some event.\n    exec {\n        # whether enable the exec.\n        # default: off.\n        enabled     off;\n        # when publish stream, exec the process with variables:\n        #       [vhost] the input stream vhost.\n        #       [port] the intput stream port.\n        #       [app] the input stream app.\n        #       [stream] the input stream name.\n        #       [engine] the tanscode engine name.\n        # other variables for exec only:\n        #       [url] the rtmp url which trigger the publish.\n        #       [tcUrl] the client request tcUrl.\n        #       [swfUrl] the client request swfUrl.\n        #       [pageUrl] the client request pageUrl.\n        # @remark empty to ignore this exec.\n        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source in Bash\nDESCRIPTION: Commands to navigate to the SRS trunk directory, configure the build, and compile the source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Setting First Packet Timeout for Publishers in SRS\nDESCRIPTION: Configures the timeout in milliseconds for the first packet from an encoder. This setting specifies how long SRS waits for the initial packet when a publisher connects before timing out the connection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # the 1st packet timeout in ms for encoder.\n        # default: 20000\n        firstpkt_timeout    20000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 5.0 Branch (develop) in Bash\nDESCRIPTION: Git commands to update the local repository and switch to the develop branch, which contains SRS 5.0 features. There is no separate 5.0release branch since it's the current development version.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout develop\n```\n\n----------------------------------------\n\nTITLE: Configuring Origin Server in SRS\nDESCRIPTION: This snippet demonstrates the configuration for an origin server in SRS. It sets the listening port, PID file location, and log file path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/edge.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              19350;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling SRS Source Code (Bash)\nDESCRIPTION: This command sequence first runs the configuration script (`./configure`) to check dependencies and set up the build environment based on the system, and then uses `make` to compile the SRS server executable from the source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Service Status with Init.d - Bash\nDESCRIPTION: Queries and displays the current status of the SRS service via the init.d service script. Requires the '/etc/init.d/srs' script to be installed. Outputs status information about the running or stopped SRS instance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs status\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Traverse in SRS Edge (Bash)\nDESCRIPTION: This SRS configuration snippet enables Token Traverse mode for an edge server. When a client connects to this edge server, the edge server will forward the client's connection information (including any provided token) to the configured origin server for authentication before allowing the connection. This requires the vhost to be in 'remote' cluster mode.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/drm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n        token_traverse  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating WebRTC Browser-to-SFU Communication\nDESCRIPTION: ASCII diagram depicting the signaling and media flow between a browser and an SFU (Selective Forwarding Unit) server in a WebRTC connection. This diagram shows how SFU servers mediate WebRTC communications in practical applications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +---------+\n+    Browser     +----<--Signaling----->--+   SFU   +\n+ (like Chrome)  +----<----Media----->----+  Server +\n+----------------+                        +---------+\n```\n\n----------------------------------------\n\nTITLE: Running SRS with GMC (Memory Leak Detection)\nDESCRIPTION: Command to run SRS with Google Memory Checker (GMC) enabled for detecting memory leaks\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nenv PPROF_PATH=./objs/pprof HEAPCHECK=normal ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: FFmpeg command loop to continuously publish a video stream to the SRS origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-hls-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Enabling CORS (Crossdomain Requests) - SRS HTTP Server - Bash\nDESCRIPTION: Enables cross-origin resource sharing (CORS) for HTTP/HTTPS requests in the SRS embedded server via the 'crossdomain' directive. This setting is global and applies to all vhosts, allowing browser-based clients from different origins to fetch resources. Default is 'on'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    # whether enable crossdomain request.\n    # for both http static and stream server and apply on all vhosts.\n    # Overwrite by env SRS_HTTP_SERVER_CROSSDOMAIN\n    # default: on\n    crossdomain on;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Publishing a Live Stream to SRS via RTMP\nDESCRIPTION: Docker command to run FFmpeg that publishes a looping video file to an SRS media server using RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-11-25-DASH-Issues.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for HiSilicon ARMv7\nDESCRIPTION: Configure and make commands to cross-compile SRS for HiSilicon ARMv7(hisiv500) platform using the specialized toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=arm-hisiv500-linux-\nmake\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: Commands to clone the SRS repository from GitHub or update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-rtmp-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring Transcoding for Specific App in SRS\nDESCRIPTION: This snippet demonstrates how to configure transcoding for all streams within a specific app in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode all streams of app \"live\"\n    transcode live {\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Start the SRS server using the default configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Starting Origin Server in SRS\nDESCRIPTION: Command to start the SRS origin server from which the edge servers will pull streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf\n```\n\n----------------------------------------\n\nTITLE: Compiling SRS from Source\nDESCRIPTION: Navigate to the trunk directory, configure and compile SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Configuring logrotate for SRS\nDESCRIPTION: Script to create a logrotate configuration file for SRS, specifying rotation parameters and post-rotation actions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log-rotate.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    sharedscripts\n    postrotate\n        kill -USR1 \\`cat /usr/local/srs/objs/srs.pid\\`\n    endscript\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: GB28181 Benchmark Tool Usage\nDESCRIPTION: Commands for using the srs-bench tool to simulate a GB28181 camera and perform benchmarking. The tool supports simulating cameras with random device IDs and testing with sample audio and video files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gb28181.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b feature/rtc https://gitee.com/ossrs/srs-bench.git\ncd srs-bench\nmake && ./objs/srs_bench -sfu gb28181 --help\n```\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs_bench -sfu gb28181 -pr tcp://127.0.0.1:5060 -user 3402000000 -random 10 \\\n  -server 34020000002000000001 -domain 3402000000 -sa avatar.aac \\\n  -sv avatar.h264 -fps 25\n```\n\nLANGUAGE: bash\nCODE:\n```\ncd srs-bench\ngo test ./gb28181 -mod=vendor -v\n```\n\n----------------------------------------\n\nTITLE: Upgrading Oryx via Helm\nDESCRIPTION: Command to upgrade Oryx to version 1.0.6 using Helm package manager\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhelm upgrade srs srs/oryx --version 1.0.6\n```\n\n----------------------------------------\n\nTITLE: HEVC Support Known Issues and Limitations\nDESCRIPTION: List of known limitations regarding HEVC support in different browsers and platforms, including WebRTC, MSE, and player compatibility issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_16\n\nLANGUAGE: markdown\nCODE:\n```\n1. HEVC over Safari WebRTC, only support WebRTC to WebRTC, doesn't support converting to RTMP.\n2. Chrome/Firefox does not support HEVC, no any plan as I know.\n3. Almost all browsers supports MSE, except iOS. HEVC over MSE requires hardware decoder.\n4. Apart from mpegts.js, other H5 players such as hls.js/dash.js doesn't support HEVC.\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository from Gitlab Mirror\nDESCRIPTION: Clones the SRS source code repository from the Gitlab mirror into a directory named 'srs', then updates the remote origin to point to the main GitHub repository and pulls the latest changes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/resource.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitlab.com/winlinvip/srs-gitlab.git srs &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Running Example SRS HTTP Callback Server (Bash)\nDESCRIPTION: Provides the necessary shell commands to navigate to the SRS source directory (`srs/trunk`) and start the example Python HTTP callback server (`server.py`) listening on port 8085. This server can be used to test and understand the expected callback requests and responses.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\npython research/api-server/server.py 8085\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFmpeg Support - Bash\nDESCRIPTION: This Bash snippet configures and compiles SRS with built-in ffmpeg tool support. Requires bash shell, GCC toolchain, and build dependencies. './configure' sets ffmpeg as an enabled tool; 'make' compiles the source code. Input is local source tree; output is compiled binaries, including ffmpeg inside ./objs/ffmpeg/bin.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ingest.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Static Vhost\nDESCRIPTION: Configuration for HTTP static file serving per virtual host, including mount points and directory settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-server.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    http_static {\n        enabled     on;\n        mount       [vhost]/hls;\n        dir         ./objs/nginx/html/hls;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Playing RTMP Stream from SRS Edge\nDESCRIPTION: Command for playing an RTMP stream from the SRS Edge server deployed on Kubernetes. The IP address should be replaced with the actual External IP of the srs-edge-service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nrtmp://28.170.32.118/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running Node Exporter for Additional Metrics\nDESCRIPTION: Command to run Prometheus node_exporter in Docker to collect system-level metrics alongside SRS metrics.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 9100:9100 prom/node-exporter\n```\n\n----------------------------------------\n\nTITLE: Starting NGINX Origin Server for HLS Edge - Bash\nDESCRIPTION: Starts NGINX with a specified configuration file for HLS edge delivery. Command uses the current working directory to resolve path to hls.edge.conf. Requires NGINX installed. Inputs: NGNIX executable, HLS edge configuration file. Outputs: NGINX HTTP server on configured ports. Ensure that conf/hls.edge.conf matches edge cache/proxy needs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnginx -c $(pwd)/conf/hls.edge.conf\n```\n\n----------------------------------------\n\nTITLE: Kicking Off a Client Session with curl Commands - bash\nDESCRIPTION: Shows bash command-line usage for interacting with SRS's HTTP RESTful API to get information about a client and then kicking them off with a DELETE request. These require curl installed and sufficient network/API permission. The client ID should be known or obtained via previous queries.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v -X GET http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v -X DELETE http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\n```\n\n----------------------------------------\n\nTITLE: Displaying SRS Configure Help for Cross-Build Options\nDESCRIPTION: Executes the SRS configure script with the `-h` flag to display help information. The output shown focuses specifically on the command-line options relevant to cross-compilation, such as enabling cross-build mode (`--cross-build`) and specifying custom toolchain components (`--cc`, `--cxx`, `--ar`, `--ld`, `--randlib`, `--extra-flags`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nroot@4c618f90fc4c:/tmp/git/srs/trunk# ./configure -h\nToolchain options:          @see https://github.com/ossrs/srs/issues/1547#issuecomment-576078411\n  --cross-build             Enable crossbuild for ARM/MIPS.\n  --cc=<CC>                 Use c compiler CC, default is gcc.\n  --cxx=<CXX>               Use c++ compiler CXX, default is g++.\n  --ar=<AR>                 Use archive tool AR, default is ar.\n  --ld=<LD>                 Use linker tool LD, default is ld.\n  --randlib=<RANDLIB>       Use randlib tool RANDLIB, default is randlib.\n  --extra-flags=<EFLAGS>    Set EFLAGS as CFLAGS and CXXFLAGS. Also passed to ST as EXTRA_CFLAGS.\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Chunked Transfer-Encoding Syntax - ABNF\nDESCRIPTION: Presents the ABNF grammar for chunked transfer encoding in HTTP/1.1, detailing the structure of chunked message bodies. This includes rules for chunk size (hexadecimal), chunk data, extensions, and trailers. It requires familiarity with ABNF and referenced rules. Used to parse or generate chunked HTTP message bodies, typically in server and client HTTP implementations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_13\n\nLANGUAGE: abnf\nCODE:\n```\nChunked-Body   = *chunk\n                 last-chunk\n                 trailer\n                 CRLF\n\nchunk          = chunk-size [ chunk-extension ] CRLF\n                 chunk-data CRLF\nchunk-size     = 1*HEX\nlast-chunk     = 1*(\"0\") [ chunk-extension ] CRLF\n\nchunk-extension= *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )\nchunk-ext-name = token\nchunk-ext-val  = token | quoted-string\nchunk-data     = chunk-size(OCTET)\ntrailer        = *(entity-header CRLF)\n```\n\n----------------------------------------\n\nTITLE: Diagramming SRS Restreaming Flow\nDESCRIPTION: This ASCII diagram illustrates the flow of data in SRS restreaming, showing how OBS or FFmpeg pushes a stream to Oryx, which then pushes to multiple streaming platforms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_12\n\nLANGUAGE: plaintext\nCODE:\n```\nOBS/FFmpeg --RTMP--> Oryx --RTMP--> Video number, Bilibili, Kuaishou, and other live streaming platforms\n```\n\n----------------------------------------\n\nTITLE: Building SRS with SRT Support\nDESCRIPTION: Command to configure and build SRS with SRT support enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-srt.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --srt=on && make\n```\n\n----------------------------------------\n\nTITLE: Adjusting SRS Process Priority\nDESCRIPTION: Demonstrates how to increase the priority of the SRS process for better performance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nrenice -n -15 -p $(pidof srs)\n\ntop -n1 -p $(pidof srs)\n```\n\n----------------------------------------\n\nTITLE: Configuring Stream Caster for Public Network Deployment\nDESCRIPTION: Configuration example for GB28181 on a public network server, showing how to set the candidate IP address for SIP signaling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gb28181.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nstream_caster {\n    enabled on;\n    caster gb28181;\n    listen 9000;\n    sip {\n        enabled on;\n        listen 5060;\n        candidate a.b.c.d;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Recording Resource Usage During Streaming Benchmark (bash)\nDESCRIPTION: Script collects and displays CPU and memory usage for multiple relevant processes (SRS, nginx-rtmp worker(s), sb_rtmp_load clients) in one top session. Identifies PIDs with ps/awk, then calls top. Also provides netstat/grep/wc usage for measuring concurrent connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nsrs_pid=$(pidof srs); \\\nnginx_pid=`ps aux|grep nginx|grep worker|awk '{print $2}'`; \\\nload_pids=`ps aux|grep objs|grep sb_rtmp_load|awk '{ORS=\",\";print $2}'`; \\\ntop -p $load_pids$srs_pid,$nginx_pid\n```\n\nLANGUAGE: bash\nCODE:\n```\nsrs_connections=`netstat -anp|grep srs|grep ESTABLISHED|wc -l`; \\\nnginx_connections=`netstat -anp|grep nginx|grep ESTABLISHED|wc -l`; \\\necho \"srs_connections: $srs_connections\"; \\\necho \"nginx_connections: $nginx_connections\";\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS TS Floor in SRS\nDESCRIPTION: Controls the algorithm used for HLS TS file path generation. When enabled, SRS uses floor(timestamp/hls_fragment) as the [timestamp] variable and an enhanced algorithm to calculate segment deviation. Recommended to set hls_segment>=2*gop when enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enahanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # default: off\n        hls_ts_floor    off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Ingest Block (Bash)\nDESCRIPTION: This configuration snippet demonstrates how to set up an ingest source within an SRS virtual host. It enables the ingest feature, defines the input type as 'file' with a specific URL, specifies the path to the FFmpeg executable, and configures the output RTMP stream URL. The 'engine' block, although present, is disabled, indicating that FFmpeg will likely perform a stream copy (remux) rather than transcoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # ingest file/stream/device then push to SRS over RTMP.\n    # the name/id used to identify the ingest, must be unique in global.\n    # ingest id is used in reload or http api management.\n    ingest livestream {\n        # whether enabled ingest features\n        # default: off\n        enabled      on;\n        # input file/stream/device\n        # @remark only support one input.\n        input {\n            # the type of input.\n            # can be file/stream/device, that is,\n            #   file: ingest file specifies by url.\n            #   stream: ingest stream specifeis by url.\n            #   device: not support yet.\n            # default: file\n            type    file;\n            # the url of file/stream.\n            url     ./doc/source.flv;\n        }\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine, @see all.transcode.srs.com\n        # @remark, the output is specified following.\n        engine {\n            # @see enabled of transcode engine.\n            # if disabled or vcodec/acodec not specified, use copy.\n            # default: off.\n            enabled          off;\n            # output stream. variables:\n            # [vhost] current vhost which start the ingest.\n            # [port] system RTMP stream port.\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Logrotate with SIGUSR1\nDESCRIPTION: Configuration for logrotate to manage SRS log files with daily rotation, compression, and size limits. Uses SIGUSR1 signal to trigger log reopening.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    sharedscripts\n    postrotate\n        kill -USR1 `cat /usr/local/srs/objs/srs.pid`\n    endscript\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Building SRS with Manual ARM Architecture Specification\nDESCRIPTION: Configure command for platforms like Loongson or Kunpeng where CPU may not be correctly identified, manually specifying ARMv8 architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --extra-flags='-D__aarch64__' && make\n```\n\n----------------------------------------\n\nTITLE: Pushing Stream to SRS Origin Server via FFmpeg - Bash\nDESCRIPTION: This Bash for-loop uses FFmpeg to continuously push an RTMP stream from a local FLV file to the configured SRS origin server. Requires FFmpeg to be built and present in the ./objs/ffmpeg/bin directory. Key parameters: input FLV file, output stream URL, sleep between attempts. Output is a persistent live stream for testing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\\\\n    -c copy \\\\\\n    -f flv rtmp://192.168.1.170:19350/live/livestream; \\\\\\n    sleep 1; \\\\\\ndone\n```\n\n----------------------------------------\n\nTITLE: Adding the original SRS repository as a remote\nDESCRIPTION: Commands to add the original SRS repository as a remote named 'srs' and fetch its branches. This allows you to sync with the latest changes from the original repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add srs https://github.com/ossrs/srs.git\ngit fetch srs\n```\n\n----------------------------------------\n\nTITLE: Initializing Oryx Container with Docker\nDESCRIPTION: Docker command to create and run an Oryx container with persistent storage and necessary port mappings for streaming services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-10-21-Oryx-Live-Transcoding.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Using PERF to Analyze SRS Performance\nDESCRIPTION: Commands to use the PERF Linux profiling tool to analyze SRS performance and generate call graphs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nperf top -p $(pidof srs)\n\nperf record -p $(pidof srs)\n\n# CTRL+Crecord\n\nperf report\n\nperf record -a --call-graph fp -p $(pidof srs)\nperf report --call-graph --stdio\n```\n\n----------------------------------------\n\nTITLE: Configuring Oryx Docker Instance with Custom Ports\nDESCRIPTION: Docker command showing how to set custom ports using environment variables for HTTP, RTMP, RTC, and SRT protocols\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx1 -it -v $HOME/data1:/data \\\n  -p 2023:2022 -p 1936:1935 -p 8001:8000/udp -p 10081:10080/udp \\\n  -e HTTP_PORT=2023 -e RTMP_PORT=1936 -e RTC_PORT=8001 -e SRT_PORT=10081 \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Installing 32-bit Libraries for ARMv7 HiSilicon Toolchain\nDESCRIPTION: Command to install 32-bit development libraries needed for the HiSilicon ARMv7 cross-compilation toolchain to work on a 64-bit host.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\napt-get -y install lib32z1-dev\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server\nDESCRIPTION: Configuration file for the SRS edge server, specifying listening port, connections limit, log file location, and origin server details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-rtmp-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimum Latency Settings for SRS\nDESCRIPTION: Configuration settings to enable minimum latency mode for a vhost in SRS. This disables publish.mr and uses timeout for consumer queue.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    # whether enable min delay mode for vhost.\n    # for min latence mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off\n    min_latency     off;\n}\n```\n\n----------------------------------------\n\nTITLE: WebRTC Multi-Stream Viewing Page\nDESCRIPTION: WordPress shortcode configuration for a page that displays multiple WebRTC streams simultaneously. This is useful for creating a viewing page that shows all participants in a video chat session.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-06-30-Video-Chat-Live.md#2025-04-23_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n[srs_player url=\"webrtc://your-server-ip/live/stream-a\"]\n[srs_player url=\"webrtc://your-server-ip/live/stream-b\"]\n```\n\n----------------------------------------\n\nTITLE: Pushing SRT Stream with AAC Audio using FFmpeg\nDESCRIPTION: This FFmpeg command demonstrates how to push an SRT stream with AAC audio. It uses the -pes_payload_size 0 parameter to prevent multiple AAC frames from being combined, reducing latency and improving audio-video sync.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i source.mp4 -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Pushing Stream to SRS with Docker and FFmpeg\nDESCRIPTION: Docker command that uses the SRS encoder image to push a looping video to SRS via RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Building SRS in aarch64 Docker Container\nDESCRIPTION: Runs a Docker container based on the `ossrs/srs:aarch64` image, mounts the current directory (`pwd`) as `/srs` inside the container, sets the working directory to `/srs`, and then executes the standard SRS configure and make commands within the container's aarch64 environment. This is useful for building SRS for aarch64 without needing a native ARM server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \\\n    bash -c \"./configure && make\"\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Keyframe Wait\nDESCRIPTION: Controls whether to wait for keyframes before creating new HLS segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_7\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_wait_keyframe       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG Log Verbosity in SRS (bash)\nDESCRIPTION: This SRS configuration snippet demonstrates how to reduce the verbosity of FFMPEG logs generated during transcoding. By adding 'v quiet;' within the 'vfilter' block, it effectively passes the '-v quiet' parameter to the forked FFMPEG process, minimizing log file size. This configuration requires SRS and a functional FFMPEG binary specified in the 'ffmpeg' directive.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n                # -v quiet\n                v           quiet;\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with WebRTC Candidate Configuration in Bash\nDESCRIPTION: Example of starting SRS with a specified CANDIDATE environment variable to set the WebRTC candidate IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nenv CANDIDATE=\"192.168.3.10\" \\\n  ./objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Example URL for HTTP-FLV Player\nDESCRIPTION: URL demonstrating how to configure the SRS player to stream 'livestream.flv' via HTTP-FLV from the server 'r.ossrs.net' on port 80. Key parameters include app, stream, server, port, autostart, vhost, and schema.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/tools/demo.md#2025-04-23_snippet_0\n\nLANGUAGE: url\nCODE:\n```\nhttp://ossrs.net/players/srs_player.html?app=live&stream=livestream.flv&server=r.ossrs.net&port=80&autostart=true&vhost=r.ossrs.net&schema=http\n```\n\n----------------------------------------\n\nTITLE: Visualizing SRS HTTP API Workflow\nDESCRIPTION: A simple text-based diagram illustrating the interaction between a client application (like Chrome or a custom app) and the SRS server via the HTTP API.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+-------------------------+               +-------+\n+ Chrome/Your Application +--HTTP-API-->--+  SRS  +\n+-------------------------+               +-------+\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFmpeg Support - Bash\nDESCRIPTION: Command to configure and build SRS with FFmpeg tool support enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Publishing SRT Stream to Proxy Server with FFmpeg\nDESCRIPTION: FFmpeg command to publish an SRT stream to the proxy server with specific SRT parameters and stream ID configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARMv7\nDESCRIPTION: Commands to cross-compile SRS for ARMv7 architecture using the arm-linux-gnueabihf toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=arm-linux-gnueabihf-\nmake\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Systemctl - Bash\nDESCRIPTION: Starts the SRS service using systemctl, which interfaces with systemd. Assumes SRS has been registered as a systemd service. User must have sudo access. Outputs service status or error information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start srs\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Custom Configuration - Bash\nDESCRIPTION: This Bash snippet starts the SRS server with a specified ingest configuration file. Assumes SRS has been built and configuration exists at conf/ingest.conf. Dependencies: compiled SRS binary and valid config file. Takes no parameters, launches SRS in the foreground; RTMP streams become available at the configured endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ingest.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ingest.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server Example\nDESCRIPTION: A minimal configuration example for an SRS origin server. It specifies the listening port, PID file location, log file path, and a default vhost.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/edge.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              19350;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Read Settings for Publisher\nDESCRIPTION: Settings for controlling merged-read functionality for publishers to optimize performance and memory usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    publish {\n        mr          off;\n        mr_latency  350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rotating SRS Logs\nDESCRIPTION: Command to trigger log rotation in SRS by sending SIGUSR1 signal using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs rotate\n```\n\n----------------------------------------\n\nTITLE: Starting First Origin Server with HLS Support\nDESCRIPTION: Command to start the first SRS origin server listening on ports 1935 and 8080, configured to convert RTMP to HLS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only1.conf\n```\n\n----------------------------------------\n\nTITLE: FMLE Configuration for Stream Publishing\nDESCRIPTION: FMLE (Flash Media Live Encoder) configuration parameters for publishing a stream to the first origin server. Specifies the RTMP URL and stream name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing\nDESCRIPTION: FFMPEG command loop to continuously publish a video stream to SRS server using RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using init script (Shell)\nDESCRIPTION: This command utilizes the system's init script (typically found in `/etc/init.d/` on SysVinit systems or managed via systemd) provided by the SRS installation. The 'reload' argument instructs the script to send the appropriate signal (usually SIGHUP) to the managed SRS process, effectively reloading the configuration. This is often the preferred method when SRS is managed as a system service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reload.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code - Bash\nDESCRIPTION: This Bash snippet updates a previously cloned local SRS repository using Git. It assumes the user is already in a valid SRS git repository directory. The command fetches and integrates changes from the remote source. No additional dependencies beyond Git; does not modify files outside the repo.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ingest.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream using FFmpeg\nDESCRIPTION: This command uses FFmpeg to continuously publish a local FLV file (`./doc/source.flv`) as an RTMP stream to the SRS server cluster (either Origin or Edge) at the specified IP address and application path (`rtmp://192.168.1.170/live/livestream`). The loop ensures the stream restarts if interrupted.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to Origin Server\nDESCRIPTION: FFmpeg command to publish a stream to the origin server. The system will randomly select one of the available origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream1\n```\n\n----------------------------------------\n\nTITLE: SRS Ingest Configuration\nDESCRIPTION: Configuration file for SRS to enable ingest functionality. This setup allows SRS to read from a file source and publish it as an RTMP stream without transcoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ingest.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    ingest livestream {\n        enabled      on;\n        input {\n            type    file;\n            url     ./doc/source.flv;\n        }\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled          off;\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRT Source Manager Implementation\nDESCRIPTION: Definition of SRT source management classes showing the usage of shared pointers for source handling and consumer management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nclass SrsSrtSourceManager\n{\npublic:\n    virtual srs_error_t fetch_or_create(SrsRequest* r, SrsSharedPtr<SrsSrtSource>& pps);\n    virtual void eliminate(SrsRequest* r);\n};\n\nSrsSharedPtr<SrsSrtSource> srt;\nif ((err = _srs_srt_sources->fetch_or_create(r, srt)) != srs_success) {\n    return srs_error_wrap(err, \"create source\");\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Upstream SRS Repository as Remote using Git\nDESCRIPTION: This snippet adds the original `ossrs/srs` repository as a remote named `srs` using the HTTPS URL and then fetches the data (branches, tags) from this newly added remote. This allows the contributor to keep their fork synchronized with the upstream project.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_1\n\nLANGUAGE: git\nCODE:\n```\ngit remote add srs https://github.com/ossrs/srs.git\ngit fetch srs\n```\n\n----------------------------------------\n\nTITLE: Adding Contributor's Fork as Temporary Remote (TOC Workflow) using Bash\nDESCRIPTION: This command is part of the workflow for maintainers (TOC) to update a contributor's PR. It adds the contributor's forked repository (identified by `zhouxiaojun2008` in the example) as a new remote named `tmp` using the SSH protocol. This allows the maintainer to fetch and push changes to the contributor's fork.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add tmp git@github.com:zhouxiaojun2008/srs.git\n```\n\n----------------------------------------\n\nTITLE: Starting Origin Server (Bash)\nDESCRIPTION: Command to start the SRS origin server that the edge servers will pull streams from.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf\n```\n\n----------------------------------------\n\nTITLE: Declaring HLS Duration Constraint - Bash\nDESCRIPTION: This shell snippet illustrates the relationship between the HLS window size and the sum of the durations of all TS files in the m3u8 playlist. It's a documentation comment or assertion rather than an executable script, serving as a reference for administrators to ensure their HLS settings guarantee the m3u8 includes only TS segments whose total length does not exceed the configured 'hls_window'. No external dependencies; intended for explanatory use in configuration planning.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nhls_window >= sum(duration of each ts in m3u8)\n```\n\n----------------------------------------\n\nTITLE: Monitoring SRS CPU Usage\nDESCRIPTION: Command to monitor the CPU usage of the SRS process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep srs|grep objs|awk '{print $2}'` && top -p $pid\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARMv7\nDESCRIPTION: Configures the SRS build system for cross-compilation targeting ARMv7 (specifically `arm-linux-gnueabihf`). It enables cross-building and specifies the appropriate compiler, archiver, linker, and randlib tools from the installed toolchain before running `make`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cc=arm-linux-gnueabihf-gcc --cxx=arm-linux-gnueabihf-g++ \\\n    --ar=arm-linux-gnueabihf-ar --ld=arm-linux-gnueabihf-ld --randlib=arm-linux-gnueabihf-randlib &&\nmake\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using Process ID\nDESCRIPTION: Shows how to reload the SRS configuration by sending signal 1 (SIGHUP) to a specific process ID. This method is useful when you want to target a particular SRS instance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reload.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nkill -1 7635\n```\n\n----------------------------------------\n\nTITLE: Publishing HEVC Stream with Docker-based FFmpeg on macOS\nDESCRIPTION: Command to publish a HEVC stream via RTMP using a Docker container with FFmpeg for macOS environments. This approach is useful for those who haven't compiled FFmpeg 6 from source but still want to publish HEVC streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv -acodec copy \\\n    -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing a Test Stream to SRS using FFmpeg\nDESCRIPTION: Uses FFmpeg to publish a video stream from a local file (`doc/source.flv`) to the running SRS server. `-re` reads the input at its native frame rate, `-c copy` copies the codecs without re-encoding, and `-f flv` specifies the output format. The stream is sent via RTMP to the specified address and application/stream name (`rtmp://127.0.0.1:1935/live/livestream`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Response Header Fields in HTTP/1.1\nDESCRIPTION: Lists the standard response header fields in HTTP/1.1 with references to their sections in the RFC. These headers provide additional information about the server and access to the requested resource.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_35\n\nLANGUAGE: http\nCODE:\n```\nresponse-header = Accept-Ranges           ; Section 14.5\n                 | Age                     ; Section 14.6\n                 | ETag                    ; Section 14.19\n                 | Location                ; Section 14.30\n                 | Proxy-Authenticate      ; Section 14.33\n                 | Retry-After             ; Section 14.37\n                 | Server                  ; Section 14.38\n                 | Vary                    ; Section 14.44\n                 | WWW-Authenticate        ; Section 14.47\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server\nDESCRIPTION: Start the SRS server with default configuration\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS for RTMP to WebRTC\nDESCRIPTION: Start SRS with RTMP to WebRTC conversion support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: SRS Slave Server Configuration (Port 1936)\nDESCRIPTION: Configuration for an SRS slave server listening on port 1936.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1936;\npid                 ./objs/srs.1936.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic SRS Vhost\nDESCRIPTION: This snippet shows a basic SRS configuration with a default vhost. It sets up the RTMP listening port and defines a default virtual host.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR Stream Filtering\nDESCRIPTION: A configuration example for applying DVR only to specific streams, such as live/stream1 and live/stream2, instead of recording all streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/dvr.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost xxx {\n    dvr {\n        dvr_apply live/stream1 live/stream2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Write Settings\nDESCRIPTION: Configuration for merged-write functionality that controls how SRS sends data to clients, affecting streaming efficiency and latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    play {\n        mw_latency      350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Wait Readable Function for SRT Socket\nDESCRIPTION: Implementation of the wait_readable method for SRT sockets which modifies the socket's epoll events and waits on a condition variable. This allows the coroutine to pause execution until data is available.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsSrtSocket::wait_readable() {\n  srt_poller_->mod_socket(this, SRT_EPOLL_IN);\n  srs_cond_timedwait(read_cond_);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Customer Vhosts - SRS - Bash\nDESCRIPTION: Sets up SRS to listen for RTMP streams on port 1935 and configures two separate vhost blocks, 'show.cctv.cn' and 'show.wasu.cn'. Each vhost is prepared to serve a different customer's streams, supporting isolation and custom logic per vhost. No specific options are set in these vhosts as shown, but this structure allows for unique configuration parameters per customer. This configuration is reusable for CDN services or environments where customer separation is needed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n}\nvhost show.wasu.cn {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Testing UDP Connectivity to SRS WebRTC Port using nc\nDESCRIPTION: Uses `nc` (netcat) to send a predefined UDP packet (containing a STUN binding request structure) to the specified IP address (`127.0.0.1`) and UDP port (`8000`) where SRS is expected to be listening for WebRTC connections. It waits up to 3 seconds (`-w 3`) for a response. The response is piped to `od` for hex/char display and `grep` checks for expected content. This tests if the UDP port is open, reachable, and if SRS responds correctly to basic STUN requests, helping diagnose UDP connectivity issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\necho -en \"\\x00\\x01\\x00\\x50\\x21\\x12\\xa4\\x42\\x74\\x79\\x6d\\x7a\\x41\\x51\\x2b\\x2f\\x4a\\x4b\\x77\\x52\\x00\\x06\\x00\\x0d\\x36\\x70\\x6b\\x31\\x31\\x33\\x38\\x36\\x3a\\x4a\\x38\\x58\\x37\\x00\\x00\\x00\\xc0\\x57\\x00\\x04\\x00\\x01\\x00\\x0a\\x80\\x2a\\x00\\x08\\xda\\xad\\x1d\\xce\\xe8\\x95\\x5a\\x83\\x00\\x24\\x00\\x04\\x6e\\x7f\\x1e\\xff\\x00\\x08\\x00\\x14\\x56\\x8f\\x1e\\x1e\\x4f\\x5f\\x17\\xf9\\x2e\\xa1\\xec\\xbd\\x51\\xd9\\xa2\\x27\\xe4\\xfd\\xda\\xb1\\x80\\x28\\x00\\x04\\x84\\xd3\\x5a\\x79\" \\\n  |nc -w 3 -u 127.0.0.1 8000 |od -Ax -c -t x1 |grep '000' && \\\n  echo \"Success\" || echo \"Failed\"\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for aarch64\nDESCRIPTION: Configure and make commands to cross-compile SRS for aarch64 architecture. This uses the previously installed cross-compilation toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=aarch64-linux-gnu-\nmake\n```\n\n----------------------------------------\n\nTITLE: Publishing a Live Stream to SRS with FFMPEG Loop - Bash\nDESCRIPTION: Continuously publishes a FLV file as a live stream to the SRS server using FFMPEG in an infinite loop. The command requires FFMPEG to be built and available at ./objs/ffmpeg/bin/ffmpeg and an input FLV file. Streams to the specified RTMP URL, pausing briefly between loops.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Starting Nginx Server (Bash)\nDESCRIPTION: Command to start the compiled Nginx server using its executable located in the `_release/sbin` directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./_release/sbin/nginx\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx with Helm\nDESCRIPTION: Helm commands to add the SRS repository and install Oryx with custom configuration for persistence and service ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhelm repo add srs http://helm.ossrs.io/stable\nhelm install srs srs/oryx --set persistence.path=$HOME/data \\\n  --set service.http=80 --set service.https=443 --set service.rtmp=1935 \\\n  --set service.rtc=8000 --set service.srt=10080\n```\n\n----------------------------------------\n\nTITLE: Probing RTMP Stream with FFprobe\nDESCRIPTION: Using FFprobe to examine the details of an RTMP stream served by SRS. The output shows stream metadata, audio and video codec information, and bitrate details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n    [root@encoder1 ~]# ffprobe rtmp://xxx:1935/live/xxx:1234\n    Input #0, flv, from 'rtmp://xxx:1935/live/xxx:1234':\n      Metadata:\n        service_name    : Channel 1\n        service_provider: PBS\n        encoder         : Lavf57.24.100\n        server          : SRS/2.0.209(ZhouGuowen)\n        srs_primary     : SRS/1.0release\n        srs_authors     : winlin,wenjie.zhao\n        server_version  : 2.0.209\n      Duration: N/A, start: 0.010000, bitrate: N/A\n        Stream #0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 128 kb/s\n        Stream #0:1: Video: h264 (High), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 1k tbn\n```\n\n----------------------------------------\n\nTITLE: Upgrading and Redeploying Oryx Server with Docker\nDESCRIPTION: Commands to update, remove, and redeploy the Oryx Server Docker container. This sequence pulls the latest version and creates a new container while preserving data through volume mounting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker rm oryx\ndocker pull ossrs/oryx:5\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Installing curl in Oryx Docker Container using Bash\nDESCRIPTION: This snippet demonstrates how to install curl within the Oryx Docker container for network connectivity testing. It updates the package list and installs curl.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker exec -it oryx apt-get update -y\ndocker exec -it oryx apt-get install -y curl\n```\n\n----------------------------------------\n\nTITLE: Building SRS Executables - Bash\nDESCRIPTION: This snippet builds the SRS software from source using Bash. By chaining './configure' and 'make', it configures the build environment and compiles the binaries. Prerequisites include an appropriate build environment (e.g., GCC, make). Key steps: configuration and compilation. Outputs: compiled SRS binaries in the objs/ directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Write Settings in SRS\nDESCRIPTION: SRS configuration for merged-write settings, which improves performance by sending multiple packets at once. Includes options for setting latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# the MW(merged-write) settings for player.\nvhost mrw.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # set the MW(merged-write) latency in ms.\n        # SRS always set mw on, so we just set the latency value.\n        # the latency of stream >= mw_latency + mr_latency\n        # the value recomment is [300, 1800]\n        # default: 350\n        mw_latency      350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Authentication via Environment Variables\nDESCRIPTION: Alternative method to configure HTTP API authentication using environment variables when starting SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nenv SRS_HTTP_API_ENABLED=on SRS_HTTP_SERVER_ENABLED=on \\\n    SRS_HTTP_API_AUTH_ENABLED=on SRS_HTTP_API_AUTH_USERNAME=admin SRS_HTTP_API_AUTH_PASSWORD=admin \\\n    ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTC to RTMP Configuration\nDESCRIPTION: Docker command to run SRS with RTC to RTMP conversion configuration, enabling FFmpeg stream mixing capability.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with Custom Config in Bash\nDESCRIPTION: This Bash command launches the SRS server binary using a specific configuration file. 'objs/srs' is the built server executable, and '-c conf/srs.conf' designates the configuration file to use. The command must be run from the build output directory. Ensure that the configuration file exists and paths are correct.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/install.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Disabling SELinux via Configuration File and Reboot\nDESCRIPTION: Describes the process to disable SELinux, which might interfere with SRS operation. It involves editing the `/etc/sysconfig/selinux` file (using `vi` or another editor with `sudo`) to set `SELINUX=disabled`, followed by a system reboot (`sudo init 6`). The `getenforce` command can be used afterwards to verify that SELinux is `Disabled`. Requires root privileges.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/install.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Edit the config of selinux:\nsudo vi /etc/sysconfig/selinux\n\n# Change the SELINUX to disabled: \n# SELINUX=disabled\n\n# Reboot:\nsudo init 6\n\n# Check status after reboot:\ngetenforce\n```\n\n----------------------------------------\n\nTITLE: Kicking Off a Client Session - RESTful DELETE and GET - text\nDESCRIPTION: These snippets detail the process to forcibly remove a client session by issuing a DELETE request to SRS's REST API. The GET requests show how to retrieve client or stream details, including the client ID necessary for the deletion. This requires the user to have appropriate REST API privileges and access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nDELETE /api/v1/clients/{id}\n```\n\nLANGUAGE: text\nCODE:\n```\nGET /api/v1/clients\n```\n\nLANGUAGE: text\nCODE:\n```\nGET /api/v1/streams\nor GET /api/v1/streams/6745\n```\n\nLANGUAGE: text\nCODE:\n```\n1. GET http://192.168.1.170:1985/api/v1/streams/6745\n2. Response stream.publish.cid:\nstream: {\n    publish: {\n        active: true,\n        cid: 107\n    }\n}\n3. DELETE http://192.168.1.170:1985/api/v1/clients/107\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS2 Origin Server for Stream Forwarding\nDESCRIPTION: Basic configuration for SRS2 origin server that forwards all incoming streams to a remote edge server at the specified address and port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample.md#2025-04-23_snippet_0\n\nLANGUAGE: conf\nCODE:\n```\n    vhost __defaultVhost__ {\n           forward         xxx:19350;\n    }\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with Specific Configuration - Bash\nDESCRIPTION: This command launches the SRS server specifying a configuration file. The binary './objs/srs' is started with the '-c' flag pointing to 'conf/http.hls.conf'. Requires the SRS binary to have been properly built, and the configuration file to exist. No additional parameters are needed unless customizing startup behavior.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.hls.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server\nDESCRIPTION: This snippet demonstrates the configuration for an SRS origin server, specifying the listen port, PID file, and log file locations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/edge.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              19350;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Playing RTMP Stream using ActionScript (Flash)\nDESCRIPTION: This ActionScript 3 code demonstrates how to connect to an RTMP server and play a live stream using NetConnection and NetStream objects within a Flash application. It establishes a connection to the specified RTMP server URL and plays the stream named 'livestream', attaching it to a Video object for display.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/delivery-rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvar conn = new NetConnection();\nvar stream = new NetStream(conn);\nvar video = new Video();\nthis.addChild(video);\nvideo.attachNetStream(stream);\nconn.connect(\"rtmp://192.168.1.170/live\");\nstream.play(\"livestream\");\n```\n\n----------------------------------------\n\nTITLE: Example URL for HTTPS HLS Player\nDESCRIPTION: URL demonstrating how to configure the SRS player to stream 'livestream.m3u8' via HLS over HTTPS from the server 'r.ossrs.net' on port 443. Uses HTTPS schema, port 443, and the .m3u8 stream extension.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/tools/demo.md#2025-04-23_snippet_3\n\nLANGUAGE: url\nCODE:\n```\nhttps://ossrs.net/players/srs_player.html?app=live&stream=livestream.m3u8&server=r.ossrs.net&port=443&autostart=true&vhost=r.ossrs.net&schema=https\n```\n\n----------------------------------------\n\nTITLE: Importing SRS Grafana Dashboard\nDESCRIPTION: curl command to import a pre-configured HelloWorld dashboard for SRS metrics visualization in Grafana from the srs-grafana repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndata=$(curl https://raw.githubusercontent.com/ossrs/srs-grafana/main/dashboards/helloworld-import.json 2>/dev/null)\ncurl -s -H \"Content-Type: application/json\" \\\n    -XPOST http://admin:12345678@localhost:3000/api/dashboards/db \\\n    --data-binary \"{\\\"dashboard\\\":${data},\\\"overwrite\\\":true,\\\"inputs\\\":[],\\\"folderId\\\":0}\"\n```\n\n----------------------------------------\n\nTITLE: Cloning and Patching FFmpeg for HEVC Support\nDESCRIPTION: Commands to clone a specific version of FFmpeg and apply patches for HEVC over RTMP/FLV support. This is required for FFmpeg versions before 6.0 which don't natively support HEVC over RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b n5.1.2 https://github.com/FFmpeg/FFmpeg.git ~/git/FFmpeg\ngit clone -b 5.1 https://github.com/runner365/ffmpeg_rtmp_h265.git ~/git/ffmpeg_rtmp_h265\ncp ~/git/ffmpeg_rtmp_h265/flv.h ~/git/FFmpeg/libavformat/\ncp ~/git/ffmpeg_rtmp_h265/flv*.c ~/git/FFmpeg/libavformat/\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Affinity for SRS Process using taskset\nDESCRIPTION: These commands demonstrate how to set CPU affinity for the SRS process, either excluding CPU0 or pinning it to CPU1 specifically.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -p 0xfe $(pidof srs)\n```\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -pc 1 $(pidof srs)\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC configuration. Requires setting the CANDIDATE environment variable to the server's IP address for WebRTC ICE candidate configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Requesting Oryx HTTP API with Bearer Token - Bash\nDESCRIPTION: Performs an authenticated HTTP POST request to query a specific SRS hook/secret using the Oryx Terraform API. Requires a valid Bearer token, and sends an empty JSON object as data. Key parameters include the Authorization header and Content-Type set to application/json.\n\nInput: API endpoint, Bearer token; Output: API response on the terminal. Dependencies: curl.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/hooks/srs/secret/query \\\n  -X POST -H 'Authorization: Bearer xxxxxx' \\\n  -H 'Content-Type: application/json' --data '{}'\n```\n\n----------------------------------------\n\nTITLE: Testing SRS WHIP Endpoint using curl\nDESCRIPTION: Sends an HTTP POST request to the SRS WHIP endpoint (`/rtc/v1/whip/`) using curl to test its availability and basic functionality. It includes necessary headers like `Content-type: application/sdp` and provides sample SDP data (`--data-raw`) simulating a WebRTC publish request. The `-v` flag enables verbose output for debugging, and `-k` allows insecure connections (useful for testing HTTPS without valid certificates). This command helps diagnose issues with the HTTP API layer of WHIP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:1985/rtc/v1/whip/?ice-ufrag=6pk11386&ice-pwd=l91z529147ri9163933p51c4&app=live&stream=livestream-$(date +%s)\" \\\n  -H 'Origin: http://localhost' -H 'Referer: http://localhost' \\\n  -H 'Accept: */*' -H 'Content-type: application/sdp' \\\n  -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)' \\\n  --data-raw $'v=0\\r\\na=group:BUNDLE 0 1\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:0\\r\\na=sendonly\\r\\na=msid:- audio\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\na=ssrc:3184534672 cname:stream\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 106\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:1\\r\\na=sendonly\\r\\na=msid:- video\\r\\na=rtcp-mux\\r\\na=rtpmap:106 H264/90000\\r\\na=ssrc:512761356 cname:stream' \\\n  -v -k\n```\n\n----------------------------------------\n\nTITLE: Building and Running State Threads Example on Linux\nDESCRIPTION: Shell commands showing how to build the State Threads library from source, compile the example code, and run it. Includes results demonstrating the efficiency of the library with 10K and 30K threads running with minimal CPU and memory usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-02-26-State-Threads-for-Internet-Applications.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/git && cd ~/git\ngit clone -b srs https://github.com/ossrs/state-threads.git\nmake linux-debug\n```\n\nLANGUAGE: bash\nCODE:\n```\ngcc -I~/git/state-threads/obj -g huge_threads.c ~/git/state-threads/obj/libst.a  -o huge_threads\n```\n\nLANGUAGE: bash\nCODE:\n```\n./huge_threads 10000\n10K report:\n10000 threads, running on 1 CPU 512M machine,\nCPU 6%, MEM 8.2% (~42M = 42991K = 4.3K/thread)\n30K report:\n30000 threads, running on 1CPU 512M machine,\nCPU 3%, MEM 24.3% (4.3K/thread)\n```\n\n----------------------------------------\n\nTITLE: Setting SRS CPU Affinity (Excluding CPU0) via PID File using taskset in Bash\nDESCRIPTION: This command uses `taskset` to set the CPU affinity for the SRS process. It reads the process ID from the `objs/srs.pid` file. The `-a` flag ensures the affinity applies to all threads of the process, and `-p` specifies the PID. The affinity mask `0xfe` assigns the process to CPUs 1 through 7, excluding CPU0, which might be reserved for softirqs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -a -p 0xfe $(cat objs/srs.pid)\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR Apply Filter for Multiple Streams\nDESCRIPTION: Example of DVR configuration to apply recording to specific streams (stream1 and stream2) instead of all streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/dvr.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost xxx {\n    dvr {\n        dvr_apply live/stream1 live/stream2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying S3 Storage Access for Cloud Recording\nDESCRIPTION: Command to check if the mounted S3 storage is accessible by listing files in the mounted directory. This verifies proper configuration before setting up cloud recording.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nls -lh /data/srs-s3-bucket\n```\n\n----------------------------------------\n\nTITLE: Publishing HEVC Stream with FFmpeg Docker for Linux\nDESCRIPTION: Command to use SRS encoder Docker image to publish an HEVC stream on Linux. This uses host network mode to allow direct communication with the locally running SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --net=host --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv -acodec copy \\\n    -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration (Plain Text)\nDESCRIPTION: These are configuration parameters for publishing a stream using Adobe Flash Media Live Encoder (FMLE) to the SRS server. The `FMS URL` specifies the RTMP application endpoint (`rtmp://192.168.1.170/live`), and `Stream` defines the stream key (`livestream`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Loop Script\nDESCRIPTION: Bash script to continuously publish a stream to the origin/edge server using FFmpeg\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/reuse-port.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Basic HTTP/1.0 Grammar Rules in BNF\nDESCRIPTION: Defines basic parsing constructs used throughout the HTTP/1.0 specification. These rules establish the fundamental character sets, control characters, and formatting elements used in HTTP syntax.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_0\n\nLANGUAGE: BNF\nCODE:\n```\nOCTET          = <any 8-bit sequence of data>\nCHAR           = <any US-ASCII character (octets 0 - 127)>\nUPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\nLOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\nALPHA          = UPALPHA | LOALPHA\nDIGIT          = <any US-ASCII digit \"0\"..\"9\">\nCTL            = <any US-ASCII control character\n                 (octets 0 - 31) and DEL (127)>\nCR             = <US-ASCII CR, carriage return (13)>\nLF             = <US-ASCII LF, linefeed (10)>\nSP             = <US-ASCII SP, space (32)>\nHT             = <US-ASCII HT, horizontal-tab (9)>\n<\">            = <US-ASCII double-quote mark (34)>\n```\n\n----------------------------------------\n\nTITLE: Starting SRS and NGINX Servers\nDESCRIPTION: Commands to start both the SRS origin server and NGINX edge server with their respective configurations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnginx -c $(pwd)/conf/hls.edge.conf\n./objs/srs -c conf/hls.origin.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR Timestamp Jitter Settings\nDESCRIPTION: Configuration snippet for setting up timestamp jitter handling for DVR recording in SRS. Specifies how timestamps should be corrected when recording RTMP streams to files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/time-jitter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost dvr.srs.com {\n    dvr {\n        time_jitter             full;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Streaming Command\nDESCRIPTION: Continuous loop command for streaming video using FFMPEG to RTMP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://127.0.0.1:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS - Bash\nDESCRIPTION: This code builds SRS by first running the configure script and then making the project. Prerequisites include having the necessary build tools (such as make and GCC) and suitable dependencies for SRS on the system. Outputs include executable binaries placed in the objs directory. No configurable parameters are necessary for a basic build.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Log Tank\nDESCRIPTION: Configuration options for specifying where SRS logs should be written - either console or file output. When using file output, srs_log_file must also be specified.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the log tank, console or file.\n# if console, print log to console.\n# if file, write log to file. requires srs_log_file if log to file.\n# default: file.\nsrs_log_tank        file;\n```\n\n----------------------------------------\n\nTITLE: Scaling SRS Edge Deployments for Canary Release in Kubernetes\nDESCRIPTION: These commands adjust the number of replicas for both old and new SRS edge deployments to control traffic distribution in a canary release.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nkubectl scale --replicas=3 deploy/srs-edge-r6-deploy\nkubectl scale --replicas=1 deploy/srs-edge-r5-deploy\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing\nDESCRIPTION: Continuous loop command to publish a stream using FFMPEG with source video file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Tracing Encoder Session Logs\nDESCRIPTION: Shows how to find encoder session logs using the source ID to trace publishing details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngrep -ina \"\\[12633\\]\\[149\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Setting the CANDIDATE Environment Variable Directly in Bash\nDESCRIPTION: This Bash command shows how to directly assign a specific IP address (\"192.168.3.10\") to the `CANDIDATE` environment variable. This variable can then be referenced by the SRS configuration file (using `candidate $CANDIDATE;`) or used when launching SRS directly or via Docker.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Directly set ip.\nCANDIDATE=\"192.168.3.10\"\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with SRT Support\nDESCRIPTION: Docker command to run SRS server with SRT protocol enabled on port 10080/udp\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n    ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP-TS Streaming Output with SRS (conf)\nDESCRIPTION: This configuration enables HTTP streaming (on port 8080) and remuxes incoming RTMP streams to the .ts (MPEG-TS over HTTP) format, mounted at [vhost]/[app]/[stream].ts. Dependencies: SRS, RTMP input. Key parameters: http_server.listen, vhost.__defaultVhost__.http_remux.mount with .ts extension. Input: RTMP stream; Output: HTTP-TS stream. Limitation: For HTTP only, does not cover audio-only formats.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-http-flv.md#2025-04-23_snippet_2\n\nLANGUAGE: conf\nCODE:\n```\nhttp_server {\n    enabled         on;\n    listen          8080;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].ts;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing logrotate Utility using yum (Shell)\nDESCRIPTION: Shows the shell command to install the `logrotate` utility using the `yum` package manager, commonly found on Red Hat-based Linux distributions (like CentOS). This is a prerequisite for using `logrotate` to manage SRS logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nsudo yum install -y logrotate\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Transfer-Coding Syntax - ABNF\nDESCRIPTION: Defines transfer-coding and transfer-extension syntax for HTTP messages using ABNF, enabling specification of transport-layer encodings (e.g., 'chunked'). Parameters allow for extension with attribute/value pairs. Requires standard ABNF compliance and definitions of 'token' and 'parameter'. Used in TE and Transfer-Encoding headers to communicate permissible transfer codings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_11\n\nLANGUAGE: abnf\nCODE:\n```\ntransfer-coding         = \"chunked\" | transfer-extension\ntransfer-extension      = token *( \";\" parameter )\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Simple command to configure and build SRS from source code. This runs the configure script to prepare the build environment and then compiles the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/install.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: SRS Master Server Configuration\nDESCRIPTION: Configuration for the SRS master server that forwards streams to multiple slave servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 192.168.1.6:1935 192.168.1.6:1936 192.168.1.7:1935 192.168.1.7:1936;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing First Stream to Origin Server Cluster (Bash)\nDESCRIPTION: FFmpeg command to push the first live stream to the origin server cluster. This stream will be randomly assigned to one of the origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream1\n```\n\n----------------------------------------\n\nTITLE: Configuring EXEC in SRS RTMP Server\nDESCRIPTION: Configuration example for setting up EXEC functionality in SRS. Shows how to enable exec and configure publish events with variable substitution support. The config allows executing FFmpeg commands when streams are published.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/nginx-exec.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    # the exec used to fork process when got some event.\n    exec {\n        # whether enable the exec.\n        # default: off.\n        enabled     off;\n        # when publish stream, exec the process with variables:\n        #       [vhost] the input stream vhost.\n        #       [port] the intput stream port.\n        #       [app] the input stream app.\n        #       [stream] the input stream name.\n        #       [engine] the tanscode engine name.\n        # other variables for exec only:\n        #       [url] the rtmp url which trigger the publish.\n        #       [tcUrl] the client request tcUrl.\n        #       [swfUrl] the client request swfUrl.\n        #       [pageUrl] the client request pageUrl.\n        # @remark empty to ignore this exec.\n        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Docker Container for SRT Streaming\nDESCRIPTION: Configures SRS for SRT protocol streaming with UDP port 10080\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 10080:10080/udp \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Basic DVR Workflow Diagram\nDESCRIPTION: Text diagram showing the flow of data from FFmpeg/OBS through SRS to DVR files\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/dvr.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+------------+            +-------+           +---------------+\n+ FFmpeg/OBS +---RTMP-->--+  SRS  +---DVR-->--+ FLV/MP4 File  +\n+------------+            +-------+           +---------------+\n```\n\n----------------------------------------\n\nTITLE: SRS Origin Server Configuration\nDESCRIPTION: Configuration file for the origin SRS server with HTTP-FLV enabled. This sets up the main server that will distribute streams to edge servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.flv.live.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository Directly from Github - Bash Shell\nDESCRIPTION: This example shows how to directly clone the SRS project from its official Github repository using git. Only the destination directory (defaulting to \\\"srs\\\") and network access to Github are required. The result is a complete copy of the repository for development or deployment. Useful for users who have reliable Github connectivity.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/resource.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: WebRTC WHIP Server Response\nDESCRIPTION: Example of SRS server's SDP answer response for WHIP protocol including ICE candidate information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nv=0\n......\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Building libx264 from Source\nDESCRIPTION: Commands to clone and build libx264 from source code, which is a dependency for FFmpeg with HEVC support. It configures x264 with static libraries and disabled assembly optimizations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://code.videolan.org/videolan/x264.git ~/git/x264\ncd ~/git/x264\n./configure --prefix=$(pwd)/build --disable-asm --disable-cli --disable-shared --enable-static\nmake -j10\nmake install\n```\n\n----------------------------------------\n\nTITLE: Moving HEVC MP4 to SRS Webserver for Playback - Bash\nDESCRIPTION: This sequence creates a VOD folder on an SRS instance's web server and moves the previously created HEVC MP4 file there, making it available for playback testing (e.g., with srs-player). Ensure the SRS trunk path is valid and you have appropriate permissions. Input: HEVC MP4 file; Output: File on SRS web server accessible through HTTP. Limitation: The SRS HTTP server must be properly configured and running.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/git/srs/trunk/objs/nginx/html/vod/\nmv source.hevc.mp4 ~/git/srs/trunk/objs/nginx/html/vod\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Deployment for SRS and Nginx\nDESCRIPTION: This YAML configuration creates a Kubernetes deployment with three containers: SRS for streaming, Nginx for serving HLS, and a helper container to copy initial files. It sets up a shared volume for HLS segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deploy\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\nEOF\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Configure and build SRS from source code in the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Valgrind Leak Checking in Bash\nDESCRIPTION: Launches the compiled SRS executable under Valgrind, enabling full memory leak checking ('--leak-check=full') and reporting all kinds of leaks ('--show-leak-kinds=all'). It uses a specific SRS configuration file ('conf/console.conf').\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nvalgrind --leak-check=full --show-leak-kinds=all ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTMP Configuration Using Docker\nDESCRIPTION: A command to run SRS in Docker with the default RTMP configuration. This exposes port 1935 for RTMP connections and uses the rtmp.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 ossrs/srs:5 \\\n  ./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: SRS and NGINX Deployment Commands\nDESCRIPTION: Shell commands for deploying SRS origin server, NGINX edge server, and streaming test content using FFmpeg.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/hls.origin.conf\n\nnginx -c $(pwd)/conf/hls.edge.conf\n\nffmpeg -re -i doc/source.flv -c copy \\\n  -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Read Settings in SRS\nDESCRIPTION: Configuration for merged-read functionality in SRS vhost publish settings, which affects read performance and memory usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    publish {\n        mr          off;\n        mr_latency  350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Forward Response JSON Example\nDESCRIPTION: Example JSON response from the backend server to SRS for dynamic forwarding configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"code\": 0,\n   \"data\": {\n       \"urls\":[\n          \"rtmp://127.0.0.1:19350/test/teststream\"\n       ]\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP-FLV Load Testing with srs-bench\nDESCRIPTION: Command to use srs-bench tool via Docker to simulate 500 concurrent clients accessing an HTTP-FLV stream for performance testing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_http_load -c 500 \\\n  -r http://your_server_public_ipv4/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: Building and Installing SRS\nDESCRIPTION: Commands to build SRS from source and install it to the prefix directory (default is /usr/local/srs). This is step 1 of setting up SRS as a system service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake && sudo make install\n```\n\n----------------------------------------\n\nTITLE: DVR API Server Log Example\nDESCRIPTION: Sample log output from the API server showing DVR callback processing, including request details and server response for a DVR event.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/dvr.md#2025-04-23_snippet_4\n\nLANGUAGE: log\nCODE:\n```\n[2015-01-03 15:25:48][trace] post to dvrs, req={\"action\":\"on_dvr\",\"client_id\":108,\"ip\":\"127.0.0.1\",\"vhost\":\"__defaultVhost__\",\"app\":\"live\",\"stream\":\"livestream\",\"cwd\":\"/home/winlin/git/srs/trunk\",\"file\":\"./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\"}\n[2015-01-03 15:25:48][trace] srs on_dvr: client id=108, ip=127.0.0.1, vhost=__defaultVhost__, app=live, stream=livestream, cwd=/home/winlin/git/srs/trunk, file=./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\n127.0.0.1 - - [03/Jan/2015:15:25:48] \"POST /api/v1/dvrs HTTP/1.1\" 200 1 \"\" \"SRS(Simple RTMP Server)2.0.88\"\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with a specified configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/install.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Stream-Level Transcoding Configuration\nDESCRIPTION: Configuration example showing how to apply transcoding settings to a specific stream within an application.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode stream name is \"livestream\" and app is \"live\"\n    transcode live/livestream{\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin and Edge Servers\nDESCRIPTION: Command to start both the SRS origin and edge servers in the background using their respective configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf &\n./objs/srs -c conf/edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with Ingest Configuration in Bash\nDESCRIPTION: Command to start the SRS server using the ingest configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ingest.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ingest.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS for WebRTC with Docker\nDESCRIPTION: Docker command to run SRS with WebRTC configuration. Sets the CANDIDATE environment variable to the server's public IP address and maps all necessary ports for WebRTC communication.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:4 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring MPEG-TS over UDP Stream Converter\nDESCRIPTION: Configuration snippet for enabling and setting up a stream converter that accepts MPEG-TS over UDP and converts it to RTMP. It specifies converter type, output RTMP URL, and UDP port to listen on.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/streamer.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n# Push MPEGTS over UDP to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       mpegts_over_udp, push MPEG-TS over UDP and convert to RTMP.\n    caster mpegts_over_udp;\n    # The output rtmp url.\n    # For mpegts_over_udp converter, the typically output url:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/live/livestream;\n    # The listen port for stream converter.\n    # For mpegts_over_udp converter, listen at udp port. for example, 8935.\n    listen 8935;\n}\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP API Authentication Configuration\nDESCRIPTION: Configuration example for enabling authentication on SRS HTTP API endpoints. This requires a username and password for accessing the API endpoints.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n# conf/http.api.auth.conf\nhttp_api {\n    enabled on;\n    listen 1985;\n    auth {\n        enabled on;\n        username admin;\n        password admin;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing FLV Stream with Local FFmpeg\nDESCRIPTION: Uses a locally installed FFmpeg instance to publish a local file (`./doc/source.flv`) as an RTMP stream to an SRS server running on `localhost:1935`. The `-re` flag ensures the stream is published at its native frame rate. This requires FFmpeg to be installed on the machine running the command.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Testing Subtitle Styles with FFmpeg\nDESCRIPTION: Complete FFmpeg command example to test subtitle styling by creating a sample SRT file and applying style parameters to overlay subtitles on a video file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ncat > avatar.srt <<EOF\n1\n00:02:31,199 --> 00:02:37,399\n[Music] Strong pray on the weak. [Music] Nobody does not think. \n[Music] You have got one hour. [Music] You know this would happen?\n\n2\n00:02:37,759 --> 00:02:39,759\nEverything changed [Music]\n\n3\n00:02:39,800 --> 00:02:43,800\nJake it's crazy here the porridge is rolling and there's no stopping him\n\n4\n00:02:44,520 --> 00:02:49,440\nWe're going up against gunships his bows and arrows. I guess we better stop him\nEOF\n\nFORCE_STYLE=\"Fontname=Roboto,Fontsize=12,PrimaryColour=&HFFFFFF,BorderStyle=4,BackColour=&H40000000,Outline=1,OutlineColour=&HFF000000,Alignment=2,MarginV=20\" &&\nffmpeg -i ~/git/srs/trunk/doc/source.flv \\\n    -ss 150 -t 20 -vf \"subtitles=./avatar.srt:force_style='${FORCE_STYLE}'\" \\\n    -c:v libx264 -c:a copy -y output.mp4\n```\n\n----------------------------------------\n\nTITLE: Launching SRS with CANDIDATE Environment Variable in Bash\nDESCRIPTION: This Bash command demonstrates how to launch the SRS server executable (`./objs/srs`) while setting the `CANDIDATE` environment variable inline. This allows SRS to read the specified IP (\"192.168.3.10\") at startup if its configuration file uses `candidate $CANDIDATE;`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nenv CANDIDATE=\"192.168.3.10\" \\\n  ./objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Starting Ubuntu Docker Container for aarch64 Cross-Compilation\nDESCRIPTION: Navigates to the SRS source directory (`~/git/srs/trunk`) and launches an Ubuntu 16 Docker container (`registry.cn-hangzhou.aliyuncs.com/ossrs/srs:ubuntu16`). It mounts the host's SRS source directory into the container at `/srs` and sets the working directory. This prepares an environment for cross-compiling SRS for aarch64.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:ubuntu16 bash\n```\n\n----------------------------------------\n\nTITLE: Configuring UDP Buffer for RTC in Linux\nDESCRIPTION: Sets the UDP buffer size to 16MB for improved RTC performance. This configuration can be applied to the host system or within a Docker container running with host networking.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Query the kernel configuration\nsysctl net.core.rmem_max\nsysctl net.core.rmem_default\nsysctl net.core.wmem_max\nsysctl net.core.wmem_default\n\n# Set the UDP buffer to 16MB\nsysctl net.core.rmem_max=16777216\nsysctl net.core.rmem_default=16777216\nsysctl net.core.wmem_max=16777216\nsysctl net.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: HTTP Raw API Configuration\nDESCRIPTION: Configuration example for enabling HTTP Raw API features including reload capability.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_13\n\nLANGUAGE: text\nCODE:\n```\nhttp_api {\n    enabled         on;\n    listen          1985;\n    raw_api {\n        enabled             on;\n        allow_reload        on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFmpeg Tool in Bash\nDESCRIPTION: This command configures SRS with FFmpeg support and builds the project.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Starting First Oryx Docker Instance\nDESCRIPTION: Docker command to run the first Oryx instance with port mappings for HTTP (80:2022), RTMP (1935), UDP (8000), and SRT (10080)\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx0 -it -v $HOME/data0:/data \\\n  -p 80:2022 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FMLE\nDESCRIPTION: Configuration parameters for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the SRS server. This provides an alternative method to FFMPEG for stream publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Safari WebRTC Configuration for HEVC/H.265\nDESCRIPTION: Instructions for enabling WebRTC H.265 codec in Safari browser and URLs for publishing and playing HEVC streams over WebRTC.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_13\n\nLANGUAGE: markdown\nCODE:\n```\n* English version: `Develop > Experimental Features > WebRTC H265 codec`\n* Chinese version: `Development > Experimental Features > WebRTC H265 codec`\n\nThen open the url in safari, to publish or play WebRTC stream:\n\n* Play [http://localhost:1985/rtc/v1/whep/?app=live&stream=livestream&codec=hevc](http://localhost:8080/players/whep.html?autostart=true&codec=hevc)\n* Publish [http://localhost:1985/rtc/v1/whip/?app=live&stream=livestream&codec=hevc](http://localhost:8080/players/whip.html?autostart=true&codec=hevc)\n```\n\n----------------------------------------\n\nTITLE: HTTP Line Termination and Whitespace Rules in BNF\nDESCRIPTION: Defines the end-of-line markers and whitespace handling for HTTP/1.0 protocol. These rules are crucial for proper parsing of HTTP headers and message formatting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_1\n\nLANGUAGE: BNF\nCODE:\n```\nCRLF           = CR LF\nLWS            = [CRLF] 1*( SP | HT )\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the FFMPEG configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ffmpeg.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring UDP Buffer Sizes in sysctl.conf\nDESCRIPTION: Example of how to permanently set UDP buffer sizes by modifying the /etc/sysctl.conf file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# vi /etc/sysctl.conf\n# For RTC\nnet.core.rmem_max=16777216\nnet.core.rmem_default=16777216\nnet.core.wmem_max=16777216\nnet.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Looping RTMP Publish Shell Loop (bash)\nDESCRIPTION: Shell for-loop to continuously (infinitely) republish a local FLV file to an SRS RTMP endpoint using ffmpeg. Each iteration waits for one second after ffmpeg completes. Prerequisites: ffmpeg binary built and located at ./objs/ffmpeg/bin/ffmpeg, and presence of doc/source.flv file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://127.0.0.1:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: SRS Ingest Configuration File\nDESCRIPTION: Example configuration file for SRS that sets up an Ingest process to capture content from a local file and publish it as an RTMP stream. The configuration defines input source, FFmpeg path, and output settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ingest.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    ingest livestream {\n        enabled      on;\n        input {\n            type    file;\n            url     ./doc/source.flv;\n        }\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled          off;\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Recording sb_rtmp_load CPU Usage by PID - Bash\nDESCRIPTION: This Bash snippet finds the PID of the sb_rtmp_load benchmarking process and launches 'top' on it to monitor resource usage in real time. It filters processes with 'load' and 'rtmp' in their names, suitable for benchmarking scenarios described in the documentation. Requires ps, grep, awk, and top utilities.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/raspberrypi.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep load|grep rtmp|awk '{print $2}'` && top -p $pid\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Sequence Header Reduction\nDESCRIPTION: Controls whether to reduce duplicate sequence headers for clients that cannot handle them properly.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        reduce_sequence_header  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling SRS Upnode Debugging\nDESCRIPTION: Configuration for enabling debug information when connecting to upstream SRS nodes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_4\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    debug_srs_upnode    on;\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source - Bash\nDESCRIPTION: This script configures and compiles SRS from source code using provided build scripts. It should be executed in the SRS project directory. The './configure' script sets up the build environment, and 'make' compiles the binaries, producing the SRS server executable and related artifacts. Requires a compatible C/C++ build environment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-dash.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Without Init.d - Bash\nDESCRIPTION: Runs the SRS binary directly with a configuration file, bypassing the init.d script. Requires a compiled SRS binary and an available configuration at 'conf/srs.conf'. Expects 'cd srs/trunk' for correct relative paths. Outputs SRS server console output or errors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Server for SRS - SRS config (conf)\nDESCRIPTION: Details the setup for an SRS edge node, with unique listen, log, and PID files for each instance. Uses a remote mode to relay streams from the origin (127.0.0.1 by default) and exposes streaming services on distinct ports. Save as 'conf/http.flv.live.edge1.conf' or 'conf/http.flv.live.edge2.conf'. Each edge instance requires a unique configuration and ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: conf\nCODE:\n```\n# conf/http.flv.live.edge1.conf\nlisten              19351;\nmax_connections     1000;\npid                 objs/srs.flv.19351.pid;\nsrs_log_file        objs/srs.flv.19351.log;\nhttp_server {\n    enabled         on;\n    listen          8081;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    mode remote;\n    origin 127.0.0.1;\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Slave Server Configuration (Port 1935)\nDESCRIPTION: Configuration for an SRS slave server listening on port 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.1935.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with MPEGTS Configuration\nDESCRIPTION: Command to start SRS with the MPEG-TS over UDP configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/streamer.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/push.mpegts.over.udp.conf\n```\n\n----------------------------------------\n\nTITLE: Looped FFMPEG Encoder Publishing to RTMP - Bash\nDESCRIPTION: This bash for-loop continually uses FFMPEG to stream 'source.flv' to an RTMP URL, sleeping for 1 second between publish attempts. The command requires a locally built FFMPEG binary, and presumes access to both the input file and SRS server at the specified IP. The main parameters are the input file path and the RTMP destination, with video/audio copy options for lossless streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Daemon Mode SRS Startup with Log File Configuration\nDESCRIPTION: This snippet shows the output when starting SRS in daemon mode with logs directed to a file. It displays the initial success message and instructions on how to view the ongoing logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c conf/srs.conf \n[2014-04-14 12:12:57.775][trace][0][0] config parse complete\n[2014-04-14 12:12:57.775][trace][0][0] write log to file ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] you can: tailf ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] @see https://ossrs.net/lts/zh-cn/docs/v4/doc/log\n```\n\n----------------------------------------\n\nTITLE: Handling SRS HTTP Callback in Node.js with Koa - JavaScript\nDESCRIPTION: This JavaScript snippet uses the Koa framework and koa-router to set up an endpoint to handle SRS callbacks, such as on_publish, at /api/v1/streams. When the endpoint is triggered, it logs the incoming request body and responds with the expected JSON structure: {code: 0, msg: 'OK'}. The code assumes that Koa and koa-router are installed and that body parsing middleware has been set up to populate ctx.request.body. The route supports any HTTP method and fulfills SRS requirements for HTTP callback responses.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst Router = require('koa-router');\nconst router = new Router();\n\nrouter.all('/api/v1/streams', async (ctx) => {\n  console.log(ctx.request.body);\n\n  ctx.body = {code: 0, msg: 'OK'};\n});\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin and Edge Servers - Bash\nDESCRIPTION: This Bash snippet demonstrates how to launch SRS using the configured server configuration files for ServerA, ServerB, and Edge in background. Each command starts an SRS instance with its respective configuration; background execution allows multiple instances to run concurrently. Requires built SRS binaries and corresponding configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.cluster.serverA.conf &\\n./objs/srs -c conf/origin.cluster.serverB.conf &\\n./objs/srs -c conf/origin.cluster.edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Media Type Syntax using ABNF\nDESCRIPTION: Specifies the structure of Internet Media Types used in the HTTP Content-Type header field (RFC 1945, Section 3.6). It defines a media type as consisting of a main 'type' token, a '/' separator, a 'subtype' token, and optional parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_11\n\nLANGUAGE: abnf\nCODE:\n```\n    media-type     = type \"/\" subtype *( \";\" parameter )\n    type           = token\n    subtype        = token\n```\n\n----------------------------------------\n\nTITLE: Building and Installing SRS\nDESCRIPTION: Commands to build SRS and install it to the default prefix directory (/usr/local/srs) or a custom directory specified during configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake && sudo make install\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Quiet Mode Configuration\nDESCRIPTION: Configuration example showing how to reduce FFMPEG log output by enabling quiet mode.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n                # -v quiet\n                v           quiet;\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inspecting SRS Edge Pods and Network State (Bash)\nDESCRIPTION: This set of bash commands interacts with Kubernetes (`kubectl`) to inspect the running SRS Edge pods. It lists pods matching 'edge', executes commands within specific pods (`kubectl exec`) to check the SRS version (`./objs/srs -v`), installs network utilities (`yum install -y net-tools`), and displays active network connections on port 1935 (`netstat -anp|grep 1935`) to verify listening status and active client/origin connections. The output shows two pods running version 4.0.5, with one pod having established connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get po|grep edge\nsrs-edge-deploy-58d9999b7c-pnr2f       1/1     Running   0          16s\nsrs-edge-deploy-58d9999b7c-z9gbm       1/1     Running   0          16s\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- ./objs/srs -v\n4.0.5\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- yum install -y net-tools\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- netstat -anp|grep 1935\ntcp        0      0 0.0.0.0:1935            0.0.0.0:*               LISTEN      1/./objs/srs\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- ./objs/srs -v\n4.0.5\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- yum install -y net-tools\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- netstat -anp|grep 1935\ntcp        0      0 0.0.0.0:1935            0.0.0.0:*               LISTEN      1/./objs/srs\ntcp        0      0 172.20.0.62:46482       172.20.0.41:1935        ESTABLISHED 1/./objs/srs\ntcp        0      0 172.20.0.62:1935        172.20.0.1:12066        ESTABLISHED 1/./objs/srs\n```\n\n----------------------------------------\n\nTITLE: SRS Console Configuration Example\nDESCRIPTION: Configuration example for running SRS in non-daemon mode with console logging, showing settings for disabling daemon mode and directing logs to the console instead of a file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n# no-daemon and write log to console config for srs.\n# @see full.conf for detail config.\n\nlisten              1935;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Using Valgrind for Memory Analysis\nDESCRIPTION: Demonstrates how to use Valgrind to perform comprehensive memory analysis on SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nvalgrind --leak-check=full ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Forward Settings in SRS\nDESCRIPTION: SRS configuration block showing forward settings including destination and backend API hook setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/forward.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # forward stream to other servers.\n    forward {\n        # whether enable the forward.\n        # default: off\n        enabled on;\n        # forward all publish stream to the specified server.\n        # this used to split/forward the current stream for cluster active-standby,\n        # active-active for cdn to build high available fault tolerance system.\n        # format: {ip}:{port} {ip_N}:{port_N}\n        destination 127.0.0.1:1936 127.0.0.1:1937;\n\n        # when client(encoder) publish to vhost/app/stream, call the hook in creating backend forwarder.\n        backend http://127.0.0.1:8085/api/v1/forward;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Vhost Parameters in SRS\nDESCRIPTION: This configuration snippet defines settings for the default RTMP virtual host (`__defaultVhost__`) in SRS. It includes parameters to control latency (`min_latency`), TCP behavior (`tcp_nodelay`), RTMP chunk size (`chunk_size`), acknowledgment sizes (`in_ack_size`, `out_ack_size`), publisher-specific options (`publish` block with settings like `mr`, `mr_latency`, `firstpkt_timeout`, `normal_timeout`, `parse_sps`), and player-specific options (`play` block with settings like `gop_cache`, `queue_length`, `time_jitter`, `atc`, `mw_latency`, `send_min_interval`). Each parameter often includes comments explaining its purpose, default value, and potential environment variable override.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # whether enable min delay mode for vhost.\n    # for min latency mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off (for RTMP/HTTP-FLV)\n    # default: on (for WebRTC)\n    min_latency off;\n\n    # whether enable the TCP_NODELAY\n    # if on, set the nodelay of fd by setsockopt\n    # Overwrite by env SRS_VHOST_TCP_NODELAY for all vhosts.\n    # default: off\n    tcp_nodelay off;\n\n    # the default chunk size is 128, max is 65536,\n    # some client does not support chunk size change,\n    # vhost chunk size will override the global value.\n    # Overwrite by env SRS_VHOST_CHUNK_SIZE for all vhosts.\n    # default: global chunk size.\n    chunk_size 128;\n    \n    # The input ack size, 0 to not set.\n    # Generally, it's set by the message from peer,\n    # but for some peer(encoder), it never send message but use a different ack size.\n    # We can chnage the default ack size in server-side, to send acknowledge message,\n    # or the encoder maybe blocked after publishing for some time.\n    # Overwrite by env SRS_VHOST_IN_ACK_SIZE for all vhosts.\n    # Default: 0\n    in_ack_size 0;\n    \n    # The output ack size, 0 to not set.\n    # This is used to notify the peer(player) to send acknowledge to server.\n    # Overwrite by env SRS_VHOST_OUT_ACK_SIZE for all vhosts.\n    # Default: 2500000\n    out_ack_size 2500000;\n    \n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # about MR, read https://github.com/ossrs/srs/issues/241\n        # when enabled the mr, SRS will read as large as possible.\n        # Overwrite by env SRS_VHOST_PUBLISH_MR for all vhosts.\n        # default: off\n        mr off;\n        # the latency in ms for MR(merged-read),\n        # the performance+ when latency+, and memory+,\n        #       memory(buffer) = latency * kbps / 8\n        # for example, latency=500ms, kbps=3000kbps, each publish connection will consume\n        #       memory = 500 * 3000 / 8 = 187500B = 183KB\n        # when there are 2500 publisher, the total memory of SRS at least:\n        #       183KB * 2500 = 446MB\n        # the recommended value is [300, 2000]\n        # Overwrite by env SRS_VHOST_PUBLISH_MR_LATENCY for all vhosts.\n        # default: 350\n        mr_latency 350;\n\n        # the 1st packet timeout in ms for encoder.\n        # Overwrite by env SRS_VHOST_PUBLISH_FIRSTPKT_TIMEOUT for all vhosts.\n        # default: 20000\n        firstpkt_timeout 20000;\n        # the normal packet timeout in ms for encoder.\n        # Overwrite by env SRS_VHOST_PUBLISH_NORMAL_TIMEOUT for all vhosts.\n        # default: 5000\n        normal_timeout 7000;\n        # whether parse the sps when publish stream.\n        # we can got the resolution of video for stat api.\n        # but we may failed to cause publish failed.\n        # @remark If disabled, HLS might never update the sps/pps, it depends on this.\n        # Overwrite by env SRS_VHOST_PUBLISH_PARSE_SPS for all vhosts.\n        # default: on\n        parse_sps on;\n        # When parsing SPS/PPS, whether try ANNEXB first. If not, try IBMF first, then ANNEXB.\n        # Overwrite by env SRS_VHOST_PUBLISH_TRY_ANNEXB_FIRST for all vhosts.\n        # default: on\n        try_annexb_first on;\n        # The timeout in seconds to disconnect publisher when idle, which means no players.\n        # Note that 0 means no timeout or this feature is disabled.\n        # Note that this feature conflicts with forward, because it disconnect the publisher stream.\n        # Overwrite by env SRS_VHOST_PUBLISH_KICKOFF_FOR_IDLE for all vhosts.\n        # default: 0\n        kickoff_for_idle 0;\n    }\n    \n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether cache the last gop.\n        # if on, cache the last gop and dispatch to client,\n        #   to enabled fast startup for client, client play immediately.\n        # if off, send the latest media data to client,\n        #   client need to wait for the next Iframe to decode and show the video.\n        # set to off if requires min delay;\n        # set to on if requires client fast startup.\n        # Overwrite by env SRS_VHOST_PLAY_GOP_CACHE for all vhosts.\n        # default: on\n        gop_cache off;\n\n        # Limit the max frames in gop cache. It might cause OOM if video stream has no IDR frame, so we limit to N\n        # frames by default. Note that it's the size of gop cache, including videos, audios and other messages.\n        # Overwrite by env SRS_VHOST_PLAY_GOP_CACHE_MAX_FRAMES for all vhosts.\n        # default: 2500\n        gop_cache_max_frames 2500;\n\n        # the max live queue length in seconds.\n        # if the messages in the queue exceed the max length,\n        # drop the old whole gop.\n        # Overwrite by env SRS_VHOST_PLAY_QUEUE_LENGTH for all vhosts.\n        # default: 30\n        queue_length 10;\n\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing,\n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved/mixed monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure stream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # @remark for full, correct timestamp only when |delta| > 250ms.\n        # @remark disabled when atc is on.\n        # Overwrite by env SRS_VHOST_PLAY_TIME_JITTER for all vhosts.\n        # default: full\n        time_jitter full;\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        #\n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # @remark when atc is on, auto off the time_jitter\n        # Overwrite by env SRS_VHOST_PLAY_ATC for all vhosts.\n        # default: off\n        atc off;\n        # whether use the interleaved/mixed algorithm to correct the timestamp.\n        # if on, always ensure the timestamp of audio+video is interleaved/mixed monotonically increase.\n        # if off, use time_jitter to correct the timestamp if required.\n        # @remark to use mix_correct, atc should on(or time_jitter should off).\n        # Overwrite by env SRS_VHOST_PLAY_MIX_CORRECT for all vhosts.\n        # default: off\n        mix_correct off;\n\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\\\"true\\\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # Overwrite by env SRS_VHOST_PLAY_ATC_AUTO for all vhosts.\n        # default: off\n        atc_auto off;\n\n        # set the MW(merged-write) latency in ms.\n        # SRS always set mw on, so we just set the latency value.\n        # the latency of stream >= mw_latency + mr_latency\n        # the value recomment is [300, 1800]\n        # @remark For WebRTC, we enable pass-by-timestamp mode, so we ignore this config.\n        # default: 350 (For RTMP/HTTP-FLV)\n        # Overwrite by env SRS_VHOST_PLAY_MW_LATENCY for all vhosts.\n        # default: 0 (For WebRTC)\n        mw_latency 350;\n\n        # Set the MW(merged-write) min messages.\n        # default: 0 (For Real-Time, min_latency on)\n        # default: 1 (For WebRTC, min_latency off)\n        # default: 8 (For RTMP/HTTP-FLV, min_latency off).\n        # Overwrite by env SRS_VHOST_PLAY_MW_MSGS for all vhosts.\n        mw_msgs 8;\n\n        # the minimal packets send interval in ms,\n        # used to control the ndiff of stream by srs_rtmp_dump,\n        # for example, some device can only accept some stream which\n        # delivery packets in constant interval(not cbr).\n        # @remark 0 to disable the minimal interval.\n        # @remark >0 to make the srs to send message one by one.\n        # @remark user can get the right packets interval in ms by srs_rtmp_dump.\n        # Overwrite by env SRS_VHOST_PLAY_SEND_MIN_INTERVAL for all vhosts.\n        # default: 0\n        send_min_interval 10.0;\n        # whether reduce the sequence header,\n        # for some client which cannot got duplicated sequence header,\n        # while the sequence header is not changed yet.\n        # Overwrite by env SRS_VHOST_PLAY_REDUCE_SEQUENCE_HEADER for all vhosts.\n        # default: off\n        reduce_sequence_header on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming HEVC Video over SRT with FFmpeg\nDESCRIPTION: FFmpeg command for streaming HEVC (H.265) encoded video over SRT protocol. Uses libx265 encoder and disables PES payload size limitation to optimize transmission.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i source.mp4 -c:v libx265 -c:a copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Basic SRS HTTP API Workflow Diagram\nDESCRIPTION: ASCII diagram showing the workflow between Chrome/Application and SRS server using HTTP API.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+-------------------------+               +-------+\n+ Chrome/Your Application +--HTTP-API-->--+  SRS  +\n+-------------------------+               +-------+\n```\n\n----------------------------------------\n\nTITLE: Handling JSON Error Response with Nonzero Code - Bash (curl usage and output)\nDESCRIPTION: This snippet shows a successful HTTP 200 response from the SRS API with a JSON body that indicates an error via a nonzero code. API clients should examine both the HTTP status and the code field in the JSON body to properly handle errors under SRS API conventions. This pattern applies regardless of endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n```\\nwinlin:~ winlin$ curl -v http://127.0.0.1:1985/api/v1/tests/errors && echo \"\"\\n< HTTP/1.1 200 OK\\n< Connection: Keep-Alive\\n< Content-Length: 12\\n< Content-Type: application/json\\n< Server: SRS/2.0.184\\n< \\n{\"code\":100}\\n```\n```\n\n----------------------------------------\n\nTITLE: Basic DVR Workflow Diagram (Text)\nDESCRIPTION: A text diagram showing the basic workflow of DVR in SRS, where FFmpeg/OBS publishes RTMP streams to SRS, which then records them to FLV/MP4 files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+------------+            +-------+           +---------------+\n+ FFmpeg/OBS +---RTMP-->--+  SRS  +---DVR-->--+ FLV/MP4 File  +\n+------------+            +-------+           +---------------+\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source Code on Windows with Cygwin\nDESCRIPTION: Commands to build SRS from source code on Windows using Cygwin64. This involves checking out the development branch, configuring the build environment, and compiling the code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/windows.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout develop\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Compiling srs-bench (Bash)\nDESCRIPTION: Standard commands to configure and compile the `srs-bench` tool, which is used for simulating RTMP client load.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Stream Push Command\nDESCRIPTION: Docker command to push a test stream to SRS using FFmpeg.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/exporter.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -re -i doc/source.flv -c copy \\\n  -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream using FMLE (Configuration Details)\nDESCRIPTION: Provides the configuration details needed to publish a live stream using Adobe Flash Media Live Encoder (FMLE) or a similar publishing tool. The FMS URL should be set to `rtmp://192.168.1.170/live` and the Stream name should be `livestream`. Replace `192.168.1.170` with the actual server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ffmpeg.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Deploying Nginx Origin and HTTP Service\nDESCRIPTION: Creates Nginx deployment for serving HLS content and static files. Includes volume mounts for shared storage and initialization container for copying SRS files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-origin-deploy\n  labels:\n    app: nginx-origin\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: nginx-origin\n  template:\n    metadata:\n      labels:\n        app: nginx-origin\n    spec:\n      volumes:\n      - name: cache-volume\n        persistentVolumeClaim:\n          claimName: pvc-nas\n      containers:\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n```\n\n----------------------------------------\n\nTITLE: Configuring Referer Anti-suck in SRS\nDESCRIPTION: Configuration example for setting up referer-based hotlink protection in SRS. Demonstrates how to enable referer checking and specify allowed domains for both play and publish operations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/drm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the vhost for anti-suck.\nvhost refer.anti_suck.com {\n    # refer hotlink-denial.\n    refer {\n        # whether enable the refer hotlink-denial.\n        # default: off.\n        enabled         on;\n        # the common refer for play and publish.\n        # if the page url of client not in the refer, access denied.\n        # if not specified this field, allow all.\n        # default: not specified.\n        all           github.com github.io;\n        # refer for publish clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        publish   github.com github.io;\n        # refer for play clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        play      github.com github.io;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing SRT Stream using FFmpeg\nDESCRIPTION: This command uses FFmpeg to publish a local video file as an SRT stream to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Managing SRS using init.d commands\nDESCRIPTION: These commands demonstrate various operations to manage SRS using the init.d script, including checking status, starting, stopping, restarting, reloading, rotating logs, and graceful shutdown.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs status\n/etc/init.d/srs start\n/etc/init.d/srs stop\n/etc/init.d/srs restart\n/etc/init.d/srs reload\n/etc/init.d/srs rotate\n/etc/init.d/srs grace\n```\n\n----------------------------------------\n\nTITLE: Running node_exporter for Node Metrics\nDESCRIPTION: Docker command to run node_exporter, which collects and exposes system metrics for Prometheus to scrape.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 9100:9100 prom/node-exporter\n```\n\n----------------------------------------\n\nTITLE: Running Sample API Server for Snapshots in SRS\nDESCRIPTION: Command to start the sample API server that will handle snapshot requests from SRS HTTP callbacks. The server runs on port 8085 and will process the snapshot requests triggered by publish/unpublish events.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd research/api-server && go run server.go 8085\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: A bash loop that uses FFmpeg to continuously publish a video file to the SRS origin server as an RTMP stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: FFmpeg HTTP FLV Push Command\nDESCRIPTION: FFmpeg command to push FLV stream over HTTP to SRS\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/streamer.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy \\\n    -f flv http://127.0.0.1:8936/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: Starting Master SRS Instance (Bash)\nDESCRIPTION: Starts the master SRS server process using the specified configuration file (`conf/forward.master.conf`). Assumes the SRS binary is located at `./objs/srs` and the configuration file exists at the specified path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/forward.master.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to SRS using FFmpeg (Bash)\nDESCRIPTION: Demonstrates how to use FFmpeg to publish a local video file (`source.flv`) as a live RTMP stream to an SRS server instance running on `win11`. The `-re` flag simulates a real-time source, and `-c copy` streams the content without re-encoding. Assumes FFmpeg is installed and the SRS server is running and accessible.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/windows.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ~/srs/doc/source.flv -c copy -f flv rtmp://win11/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR and HTTP Callbacks in SRS\nDESCRIPTION: Configuration snippet for enabling DVR functionality and HTTP callbacks in SRS. Sets up DVR path patterns, segment duration, keyframe waiting, and callback URL for DVR events.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/dvr.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nvhost your_vhost {\n    dvr {\n        enabled             on;\n        dvr_path            ./objs/nginx/html/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        dvr_plan            segment;\n        dvr_duration        30;\n        dvr_wait_keyframe   on;\n    }\n    http_hooks {\n        enabled         on;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying SRS Receive Bandwidth in Prometheus\nDESCRIPTION: This PromQL query calculates the input bandwidth (bitrate) of the live stream in Prometheus.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_6\n\nLANGUAGE: sql\nCODE:\n```\nrate(srs_receive_bytes_total[10s])*8\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Console Mode for Debugging\nDESCRIPTION: Presents an example SRS configuration (`conf/console.conf`) tailored for debugging. It sets `daemon off;` to prevent SRS from running in the background and `srs_log_tank console;` to direct log output directly to the standard output (console) instead of a file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_8\n\nLANGUAGE: properties\nCODE:\n```\n# no-daemon and write log to console config for srs.\n# @see full.conf for detail config.\n\nlisten              1935;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for Transcoder Snapshot\nDESCRIPTION: Configuration file for SRS to use the transcoder feature for snapshot functionality. It includes settings for transcoding, FFMPEG, and ingest.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/snapshot.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    transcode {\n        enabled on;\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine snapshot {\n            enabled on;\n            iformat flv;\n            vfilter {\n                vf fps=1;\n            }\n            vcodec png;\n            vparams {\n                vframes 6;\n            }\n            acodec an;\n            oformat image2;\n            output ./objs/nginx/html/[app]/[stream]-%03d.png;\n        }\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for HLS in Bash\nDESCRIPTION: Sample configuration file for SRS to enable HLS delivery. It sets up the RTMP listener, HTTP server, and HLS-specific settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/hls.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Server with Custom Config - Bash\nDESCRIPTION: This Bash command starts the SRS server with the previously specified realtime configuration. It assumes SRS has been built and 'conf/realtime.conf' exists. The '-c' flag specifies the configuration file path. Output logs and execution run in the current shell.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-realtime.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/realtime.conf\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for HiSilicon ARMv7\nDESCRIPTION: Configuration and make commands for cross-compiling SRS for HiSilicon ARMv7 architecture using the installed HiSilicon toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=arm-hisiv500-linux-\nmake\n```\n\n----------------------------------------\n\nTITLE: Monitoring Server Process IDs for Performance Testing\nDESCRIPTION: Bash script to capture the process IDs of SRS, Nginx worker, and load testing tools for performance monitoring. This information is used as input for the top command to track CPU and memory usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\nsrs_pid=$(pidof srs); \\\nnginx_pid=`ps aux|grep nginx|grep worker|awk '{print $2}'`; \\\nload_pids=`ps aux|grep objs|grep sb_rtmp_load|awk '{ORS=\",\";print $2}'`; \\\ntop -p $load_pids$srs_pid,$nginx_pid\n```\n\n----------------------------------------\n\nTITLE: Example HLS TS Base URL Configuration\nDESCRIPTION: Demonstrates the effect of the `hls_entry_prefix` directive within the SRS HLS configuration. This prefix, if set (e.g., `http://your-server`), is prepended to each TS file path listed within the M3U8 playlist (e.g., `http://your-server/live/livestream-0.ts`). This allows specifying a base URL or CDN path for serving the HLS segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nFor ts: live/livestream-0.ts\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Repository - Bash\nDESCRIPTION: This Bash command updates the local SRS source repository to the latest version using 'git pull'. This assumes the working directory is already inside the SRS Git repository. Requires Git installed and network access to GitHub. Updates files in-place.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Starting Oryx with HTTPS Support\nDESCRIPTION: Docker command to run Oryx with additional port mappings for HTTPS (443) and HTTP (80) for certificate verification\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  -p 80:2022 -p 443:2443 \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFmpeg Tools\nDESCRIPTION: Command to configure and build SRS with FFmpeg tools enabled, which are required for transcoding functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-transcode-to-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Playing HEVC over RTMP with FFplay\nDESCRIPTION: Command to play HEVC-encoded video streamed over RTMP using FFplay. This requires FFplay to be built with HEVC support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./ffplay rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Illustrating a Single-Line Header Field (RFC 822)\nDESCRIPTION: Provides an example of a basic, unfolded 'To:' header field conforming to RFC 822 syntax. This shows the field-name ('To:'), followed by the field-body containing addresses, all on a single logical line.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nTo:  \"Joe & J. Harvey\" <ddd @Org>, JJV @ BBN\n```\n\n----------------------------------------\n\nTITLE: Starting Slave SRS Server\nDESCRIPTION: Command to start the slave SRS server with its configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-forward.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/forward.slave.conf\n```\n\n----------------------------------------\n\nTITLE: Reload SRS Configuration Using Kill Command\nDESCRIPTION: Commands to reload the SRS server configuration using the kill signal. Includes both general process reload and specific process ID targeting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/reload.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkillall -1 srs\n```\n\nLANGUAGE: bash\nCODE:\n```\nkill -1 7635\n```\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Repository - Bash\nDESCRIPTION: This snippet updates the already cloned SRS repository to the latest version using git pull. It assumes you are within the srs/trunk directory and git is installed. This ensures your SRS installation is up to date before building.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-dash.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Getting IP Address of Network Interface (bash)\nDESCRIPTION: Uses 'ifconfig' to print the configuration and IP address (inet addr) of a network interface. Output is filtered for eth0. Prerequisite: net-tools package installed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# ifconfig eth0\neth0      Link encap:Ethernet  HWaddr 08:00:27:8A:EC:94  \n          inet addr:192.168.2.101  Bcast:192.168.2.255  Mask:255.255.255.0\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Docker Container for H.265 Streaming\nDESCRIPTION: Command to run SRS 6.0 in a Docker container, exposing ports for RTMP and HTTP streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-03-07-Lets-Do-H265-Live-Streaming.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:6 \\\n  ./objs/srs -c conf/docker.conf\n```\n\n----------------------------------------\n\nTITLE: Playing HLS Stream from Proxy Server\nDESCRIPTION: FFplay command to play an HLS stream from the SRS proxy server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffplay http://localhost:8080/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Starting 500 srs-bench Clients for SRS Test (Bash)\nDESCRIPTION: Runs the `srs-bench` tool (`sb_rtmp_load`) to simulate 500 concurrent RTMP clients connecting to the SRS server (port 1935). The command is run in the background (`&`), and output is redirected to `/dev/null`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 500 -r rtmp://127.0.0.1:1935/live/livestream >/dev/null &\n```\n\n----------------------------------------\n\nTITLE: Native Compilation of SRS on aarch64 with Extra Flags\nDESCRIPTION: This command configures and compiles SRS natively on an armv8 or aarch64 system. It explicitly passes the '-D__aarch64__' flag during configuration, which might be necessary if the build system doesn't automatically detect the CPU architecture correctly.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --extra-flags='-D__aarch64__' && make\n```\n\n----------------------------------------\n\nTITLE: Documenting EXT-X-I-FRAME-STREAM-INF Tag Usage - Markdown - English\nDESCRIPTION: This snippet illustrates the use and required attributes for the EXT-X-I-FRAME-STREAM-INF tag in HLS playlists. It specifies the format of the tag and details required attributes such as BANDWIDTH and URI, as well as protocol compliance requirements. The example is helpful for implementers needing to validate or generate master playlists containing alternative video renditions and I-frame playlists.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_17\n\nLANGUAGE: markdown\nCODE:\n```\n#EXT-X-I-FRAME-STREAM-INF:<attribute-list>\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub or update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Publishing SRT Stream Using FFmpeg\nDESCRIPTION: FFmpeg command to publish stream using SRT protocol to SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin and Edge Servers in Bash\nDESCRIPTION: Commands to start both the SRS origin and edge servers using their respective configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-rtmp-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf &\n./objs/srs -c conf/edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Directly from Github - Bash\nDESCRIPTION: This bash snippet illustrates how to directly clone the SRS source code from its primary Github repository. It requires git installed and network connectivity, with no additional configuration or parameters. Input: none; Output: a local clone of the SRS repository mirroring the current state of Github's default branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/resource.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Tracking Session-specific Logs by ID in SRS\nDESCRIPTION: This snippet demonstrates how to use a session ID from filtered logs to view all log entries for a specific connection. It extracts the complete history of session ID 104 to analyze the connection lifecycle.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log |grep -ina \"\\[104\\]\\[\"\n14:[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n15:[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n16:[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n17:[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n18:[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n19:[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n21:[2014-04-04 11:56:06.288][trace][104][11] set output chunk size to 60000\n22:[2014-04-04 11:56:06.288][trace][104][11] set chunk_size=60000 success\n23:[2014-04-04 11:56:07.397][trace][104][11] <- time=225273, obytes=4168, ibytes=7607, okbps=32, ikbps=59\n24:[2014-04-04 11:56:07.398][trace][104][11] dispatch metadata success.\n25:[2014-04-04 11:56:07.398][trace][104][11] process onMetaData message success.\n26:[2014-04-04 11:56:07.398][trace][104][11] update video sequence header success. size=67\n27:[2014-04-04 11:56:08.704][trace][104][11] <- time=226471, obytes=4168, ibytes=36842, okbps=13, ikbps=116\n28:[2014-04-04 11:56:09.901][trace][104][11] <- time=227671, obytes=4168, ibytes=67166, okbps=9, ikbps=152\n29:[2014-04-04 11:56:11.102][trace][104][11] <- time=228869, obytes=4168, ibytes=97481, okbps=6, ikbps=155\n30:[2014-04-04 11:56:11.219][trace][104][11] clear cache/metadata/sequence-headers when unpublish.\n31:[2014-04-04 11:56:11.219][trace][104][11] control message(unpublish) accept, retry stream service.\n32:[2014-04-04 11:56:11.219][trace][104][11] ignore AMF0/AMF3 command message.\n33:[2014-04-04 11:56:11.419][trace][104][11] drop the AMF0/AMF3 command message, command_name=deleteStream\n34:[2014-04-04 11:56:11.420][trace][104][11] ignore AMF0/AMF3 command message.\n35:[2014-04-04 11:56:12.620][error][104][104] recv client message failed. ret=207(Connection reset by peer)\n36:[2014-04-04 11:56:12.620][error][104][104] identify client failed. ret=207(Connection reset by peer)\n37:[2014-04-04 11:56:12.620][warn][104][104] client disconnect peer. ret=204\n```\n\n----------------------------------------\n\nTITLE: Customizing NGINX Logging for Cache Status Analysis - NGINX\nDESCRIPTION: Defines a custom log_format in NGINX access logs that includes the upstream_cache_status field, allowing operators to analyze cache HIT/MISS status per request. Specifies main log format and sets access_log path. Dependencies: NGINX with standard log modules enabled; make sure permissions for /var/log/nginx/access.log are correct.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_11\n\nLANGUAGE: nginx\nCODE:\n```\nlog_format  main  '$upstream_cache_status $remote_addr - $remote_user [$time_local] \"$request\" '\\n                    '$status $body_bytes_sent \"$http_referer\" '\\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\\naccess_log  /var/log/nginx/access.log main;\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running Node.js Koa Proxy - Bash\nDESCRIPTION: Bash commands to initialize a Node.js project and install the necessary dependencies for the Koa proxy example above. Commands cover creating package.json, installing koa, koa-proxies, koa-bodyparser, koa-router, and running the entry point. Ensure Node.js and npm are installed beforehand.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnpm init -y \nnpm install koa koa-proxies koa-proxies koa-bodyparser koa-router\nnode .\n\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 'Resent-Date' Field Syntax (ABNF-like)\nDESCRIPTION: Specifies the syntax for the 'Resent-Date' header field in RFC 822 using an ABNF-like grammar, indicating the time the message was forwarded.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_27\n\nLANGUAGE: abnf\nCODE:\n```\nresent-date =  \"Resent-Date\" \":\"   date-time\n```\n\n----------------------------------------\n\nTITLE: Adding SRS as service in CentOS\nDESCRIPTION: Command to add SRS as a system service in CentOS, enabling automatic startup on system boot.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n#centos 6\nsudo /sbin/chkconfig --add srs\n```\n\n----------------------------------------\n\nTITLE: Enabling TCP NoDelay in SRS\nDESCRIPTION: Controls whether to enable the TCP_NODELAY option on the socket. When enabled, it sets the nodelay option using setsockopt, which can reduce network latency for certain types of traffic.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_9\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n}\n```\n\n----------------------------------------\n\nTITLE: Profiling System Calls for a Process using strace in Bash\nDESCRIPTION: Suggests using the `strace` command with the `-c` option (count time, calls, and errors for each syscall) and `-p PID` (attach to the specified process ID) to analyze system call performance issues for a running process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\nstrace -c -p PID\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Prometheus Exporter Enabled\nDESCRIPTION: This bash command demonstrates how to compile and start SRS with the Prometheus Exporter feature enabled using environment variables.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\nenv SRS_ENV_ONLY=on SRS_EXPORTER_ENABLED=on SRS_LISTEN=1935 \\\n  ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: Specifying Content-Language HTTP Header for Single Language\nDESCRIPTION: Example of using the Content-Language HTTP header to indicate content intended for a Danish-speaking audience. This helps users identify content in their preferred language.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_60\n\nLANGUAGE: http\nCODE:\n```\nContent-Language: da\n```\n\n----------------------------------------\n\nTITLE: Implementing Shared Pointer Template Class in C++\nDESCRIPTION: Basic implementation of a shared pointer class with reference counting for automatic memory management. Includes core member variables for pointer management and reference counting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<class T>\nclass SrsSharedPtr\n{\nprivate:\n    // Pointer to the object.\n    T* ptr_;\n    // Reference count of the object.\n    uint32_t* ref_count_;\n```\n\n----------------------------------------\n\nTITLE: Configuring Nginx Proxy Cache for HLS Streaming in aaPanel\nDESCRIPTION: This Nginx configuration sets up proxy caching for HLS streaming. It defines cache paths, server blocks, and location directives for handling m3u8 and ts files. The configuration is intended to be added to an aaPanel site setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       80;\n        server_name your.domain.com;\n\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Running Oryx with Docker\nDESCRIPTION: Docker command to run Oryx container with persistent storage and necessary port mappings for streaming protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-09-Oryx-Tutorial.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Setting HLS Dispose Time in SRS Configuration - Bash\nDESCRIPTION: This snippet demonstrates how to set the hls_dispose parameter, configuring how long SRS retains HLS slice files after a stream ends. Reducing this duration purges files sooner, but setting it too short can prevent HLS playback after restarts. This should be placed inside a vhost block in the SRS configuration file. The main requirement is an operational SRS deployment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_dispose 120;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing SRS HTTP API Request with curl in Bash\nDESCRIPTION: This snippet shows how to make HTTP API requests to the SRS API proxied by Oryx. It includes both an unauthenticated request and an authenticated request using a Bearer token.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/api/v1/versions\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/api/v1/vhosts/ \\\n  -X GET -H 'Authorization: Bearer xxxxxx' \\\n  -H 'Content-Type: application/json'\n```\n\n----------------------------------------\n\nTITLE: Defining Delta Seconds Format\nDESCRIPTION: Specifies the format for representing time intervals in seconds within HTTP headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_8\n\nLANGUAGE: HTTP\nCODE:\n```\ndelta-seconds  = 1*DIGIT\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFmpeg Support\nDESCRIPTION: Command to configure and build SRS with FFmpeg tool support enabled, which is required for the ingest functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server (Bash)\nDESCRIPTION: Command to start the compiled SRS server in the background (`nohup`, `&`). It specifies the configuration file (`conf/srs.conf`) and redirects standard output and standard error to `/dev/null`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnohup ./objs/srs -c conf/srs.conf >/dev/null 2>&1 &\n```\n\n----------------------------------------\n\nTITLE: Starting CaddyServer with Custom Caddyfile - Bash\nDESCRIPTION: Command to start CaddyServer using a specified Caddyfile. The file should contain the reverse proxy configurations for SRS as shown above. Make sure the Caddy binary is in your PATH or specify its location explicitly. No parameters are required except '-config' pointing to the intended Caddyfile.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncaddy start -config Caddyfile\n\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Configuration parameters for publishing streams using Flash Media Live Encoder (FMLE).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Servers\nDESCRIPTION: Sets up SRS Edge servers with configuration for connecting to origin cluster. Includes deployment configuration and load balancer service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-0.socs srs-origin-1.socs srs-origin-2.socs;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Configuring Send Minimal Interval in SRS\nDESCRIPTION: Configuration for controlling the minimal packet send interval for RTMP and HTTP FLV stream clients. Used to control stream delivery timing with a configurable interval in milliseconds.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        send_min_interval       10.0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Server Ports\nDESCRIPTION: Command to verify that both master and slave SRS servers are listening on their respective ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nsudo netstat -anp|grep srs\n```\n\n----------------------------------------\n\nTITLE: Rotating SRS Logs (Logrotate) via Init.d Script - Bash\nDESCRIPTION: Triggers log rotation for SRS using the init.d script and sends SIGUSR1. SRS logs are rotated for archival or cleanup purposes. Requires SRS service and init.d script; outputs success/failure of rotation action.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs rotate\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using Init Script\nDESCRIPTION: Illustrates the use of the SRS init script to perform a configuration reload. This method is typically used in production environments with system service management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reload.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Using FFmpeg to Merge Multiple RTMP Streams for Room-to-Live\nDESCRIPTION: FFmpeg command to combine multiple RTMP streams into a single stream. Scales one video, overlays it on the other, and mixes the audio. The result is output as a new RTMP stream for live broadcasting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -f flv -i rtmp://192.168.3.6/live/alice -f flv -i rtmp://192.168.3.6/live/314d0336 \\\n     -filter_complex \"[1:v]scale=w=96:h=72[ckout];[0:v][ckout]overlay=x=W-w-10:y=H-h-10[out]\" -map \"[out]\" \\\n     -c:v libx264 -profile:v high -preset medium \\\n     -filter_complex amix -c:a aac \\\n     -f flv rtmp://192.168.3.6/live/merge\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg (Bash)\nDESCRIPTION: This bash loop uses FFmpeg to continuously publish a local video file (`./doc/source.flv`) to the SRS server via RTMP. It reads the input file (`-re` simulates real-time), copies the codecs without re-encoding (`-c copy`), specifies the output format as FLV (`-f flv`), and sends it to the RTMP endpoint `rtmp://192.168.1.170/live/livestream`. The loop restarts the stream every second.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Setting Up HTTPS Proxy for WebRTC\nDESCRIPTION: Docker command for running httpx-static as an API gateway, providing HTTPS for WebRTC endpoints. Routes requests to the signaling server, SRS HTTP API, and the web interface.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm -p 80:80 -p 443:443 ossrs/httpx:1 \\\n    ./bin/httpx-static -http 80 -https 443 -ssk ./etc/server.key -ssc ./etc/server.crt \\\n          -proxy http://$CANDIDATE:1989/sig -proxy http://$CANDIDATE:1985/rtc \\\n          -proxy http://$CANDIDATE:8080/\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Compiled SRS on ARMv8 Docker\nDESCRIPTION: Docker command to run the cross-compiled SRS binary on an ARMv8/aarch64 Docker container, exposing the necessary ports for RTMP and HTTP services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 arm64v8/ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Stream Publishing Command\nDESCRIPTION: FFmpeg command to push a video stream to SRS server using RTMP protocol\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/flv.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Origin ServerA Configuration\nDESCRIPTION: Configuration file for the first origin server (ServerA) with cluster settings, HTTP API, and basic server parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverA.conf\nlisten              19350;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverA.pid;\nhttp_api {\n    enabled         on;\n    listen          9090;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9091;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Forwarding SRT Stream with FFmpeg\nDESCRIPTION: Command line example for using FFmpeg to push SRT streams to SRS, which then converts it to RTMP for further processing or forwarding to Nginx. This snippet is inferred from the Q&A section.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -i <input_source> -c:v libx264 -c:a aac -f mpegts srt://<srs_server_ip>:<srs_srt_port>\n```\n\n----------------------------------------\n\nTITLE: SRS Restream Architecture Diagram\nDESCRIPTION: Diagram showing the architecture of SRS multi-platform restreaming, where Oryx serves as an intermediary between the source stream (OBS/FFmpeg) and multiple target platforms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nOBS/FFmpeg --RTMP--> Oryx --RTMP--> B\n```\n\n----------------------------------------\n\nTITLE: Starting API Server for HttpCallback Snapshot in Go\nDESCRIPTION: This code snippet starts an instance of the API server used for HttpCallback snapshot functionality. It runs a Go server on port 8085.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ncd research/api-server && go run server.go 8085\n```\n\n----------------------------------------\n\nTITLE: Starting Second SRS Origin Server for HLS (Reuse Port)\nDESCRIPTION: Starts a second SRS Origin server instance on the same machine, also configured for HLS delivery and listening on the same ports (1935, 8080) using SO_REUSEPORT. Requires a separate configuration file (`conf/origin.hls.only2.conf`) with a unique PID file setting. This allows load balancing for HLS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only2.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server for Live Streaming\nDESCRIPTION: Launches the SRS server using the default configuration file for live streaming scenarios.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Filtering SRS Publish Logs by Stream Name using Grep in Bash\nDESCRIPTION: Demonstrates refining the log search by piping the output of a `grep` command (searching for publish events) to another `grep` command. This second `grep` filters the results further to show only publish events associated with the specific stream named `livestream`. The `-a` option treats the input as text.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"|grep -a \"livestream\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Reverse Tracing Edge Servers in SRS\nDESCRIPTION: Example of reverse tracing edge servers connected to origin using edge-srs keyword\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"edge-srs\" objs/srs.origin.log\n```\n\n----------------------------------------\n\nTITLE: Building and Installing SRS\nDESCRIPTION: Commands to build SRS and install it to the default prefix directory (/usr/local/srs) or a custom directory specified during configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmake && sudo make install\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for HTTP and HLS in Bash\nDESCRIPTION: This configuration snippet sets up SRS for HTTP server and HLS delivery, including server settings and HLS parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.hls.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Signaling Server for WebRTC SFU in Docker\nDESCRIPTION: Docker command to start the signaling server required for WebRTC SFU (Selective Forwarding Unit) functionalities like one-to-one calls or video rooms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 1989:1989 ossrs/signaling:1\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and compile SRS from source code. This builds the SRS binary with default options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-dash.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Command to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-hls-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Example of Abbreviated Domain Reference Format\nDESCRIPTION: An example of specifying subordinate domain references within the local-part of an email address, which was acceptable to RFC #733 parsers but contrary to the intent of this newer standard.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_35\n\nLANGUAGE: plain text\nCODE:\n```\nmailbox.sub1.sub2@this-domain\n```\n\n----------------------------------------\n\nTITLE: Patching FFmpeg 5.1 for HEVC over RTMP/FLV\nDESCRIPTION: Applies the runner365 patches to FFmpeg 5.1 to add support for HEVC over RTMP and FLV. This replaces the FLV-related files in the FFmpeg source code with patched versions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 5.1 https://github.com/runner365/ffmpeg_rtmp_h265.git ~/git/ffmpeg_rtmp_h265\ncp ~/git/ffmpeg_rtmp_h265/flv.h ~/git/FFmpeg/libavformat/\ncp ~/git/ffmpeg_rtmp_h265/flv*.c ~/git/FFmpeg/libavformat/\n```\n\n----------------------------------------\n\nTITLE: Starting Additional Edge Server in SRS\nDESCRIPTION: Command to start a second SRS edge server also listening on port 1935. This demonstrates the REUSE_PORT feature allowing multiple processes to bind to the same port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge2.conf\n```\n\n----------------------------------------\n\nTITLE: Checking UDP Packet Statistics with netstat\nDESCRIPTION: Commands to view UDP packet statistics and monitor packet loss using netstat.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# \nnetstat -suna\n# 30\nnetstat -suna && sleep 30 && netstat -suna\n```\n\n----------------------------------------\n\nTITLE: FMLE RTMP Stream Configuration Parameters - Bash\nDESCRIPTION: Provides the required RTMP URL and Stream name parameters for FMLE to publish a stream to the SRS server. No code execution here, just configuration values to input in FMLE's GUI. Replace the sample IP with your actual server IP as needed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-arm.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Defining Server Header Syntax and Example in HTTP/1.1\nDESCRIPTION: Syntax definition and example of the Server response header in HTTP/1.1, which provides information about the software used by the origin server to handle the request.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_86\n\nLANGUAGE: http\nCODE:\n```\nServer         = \"Server\" \":\" 1*( product | comment )\n\nExample:\n\nServer: CERN/3.0 libwww/2.17\n```\n\n----------------------------------------\n\nTITLE: Specification of Reserved Postmaster Address\nDESCRIPTION: The definition of a special reserved local-part address 'Postmaster' that must be valid at each site, to be used for contacting the person responsible for the site's mail system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_38\n\nLANGUAGE: plain text\nCODE:\n```\nPostmaster@domain\n```\n\n----------------------------------------\n\nTITLE: Building SRS Directly on ARM Server\nDESCRIPTION: Standard commands to build SRS directly on an ARM server without cross-compilation. This is the recommended approach for most ARM servers with sufficient resources.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Cloning the SRS Repository using Git\nDESCRIPTION: This command sequence clones the official SRS repository from GitHub into the current directory and then changes the current directory to the 'trunk' folder within the cloned repository, preparing for the build process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Mounting Custom Directory for Oryx Recording with Docker\nDESCRIPTION: Command for running Oryx in Docker with a custom host directory mounted for recording files. This allows storing recordings in a different location than the default path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -v /your-host-dir:/data/record\n```\n\n----------------------------------------\n\nTITLE: Compiling SRS (Bash)\nDESCRIPTION: Standard commands to configure and compile the SRS (Simple Realtime Server) source code using default settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Finding Play Request in Origin Log\nDESCRIPTION: Search for play request in origin server log to identify the client connection ID 107 playing the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"type=Play\" objs/srs.origin.log \n31:[2014-08-06 10:09:34.671][trace][22288][107] client identified, type=Play, stream_name=livestream, duration=-1.00\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback JSON Request and Response for on_unpublish Event\nDESCRIPTION: This snippet shows the JSON structure for the on_unpublish event HTTP callback request and response. It includes details like request_id, action, stream information, and the expected response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_7\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"9ea987fa-1563-4c28-8c6c-a0e9edd4f536\",\n  \"action\": \"on_unpublish\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Traverse Authentication for SRS Edge Servers\nDESCRIPTION: This configuration shows how to enable token traverse authentication in an SRS edge server. When enabled, the edge server will forward authentication tokens to the origin server for validation, creating a new connection for each authentication request.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/drm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n        token_traverse  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with Configuration (Bash)\nDESCRIPTION: Bash command to start the Simple RTMP Server (SRS) executable located in the './objs/' directory, using the configuration specified in the 'conf/rtmp.conf' file. This command initiates the server process with the defined RTMP settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-rtmp.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Pushing Test Stream to SRS Using FFmpeg\nDESCRIPTION: Docker command to run FFmpeg and push a test live stream to SRS for generating metrics that can be collected by the exporter.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -re -i doc/source.flv -c copy \\\n  -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS with GCP (CPU Profiling)\nDESCRIPTION: Command to configure SRS with GPERF support for CPU profiling (gcp)\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./configure --with-gperf --with-gcp\n```\n\n----------------------------------------\n\nTITLE: Starting the Slave SRS Instance\nDESCRIPTION: This command starts the slave SRS server using its specific configuration file ('forward.slave.conf') provided via the '-c' flag.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_6\n\nLANGUAGE: Bash\nCODE:\n```\n./objs/srs -c conf/forward.slave.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFmpeg Docker Container\nDESCRIPTION: This command uses the FFmpeg Docker container to publish a looping video stream to SRS via RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Prometheus to Scrape SRS and node_exporter Metrics\nDESCRIPTION: This YAML configuration for Prometheus sets up jobs to scrape metrics from both SRS and node_exporter at 5-second intervals.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nscrape_configs:\n  - job_name: \"node\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9100\"]\n  - job_name: \"srs\"\n    metrics_path: \"/metrics\"\n    scrape_interval: 5s\n    static_configs:\n      - targets: [\"host.docker.internal:9972\"]\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP API Authentication in SRS\nDESCRIPTION: Configuration file to enable HTTP basic authentication for SRS HTTP API with username and password settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.api.auth.conf\nhttp_api {\n    enabled on;\n    listen 1985;\n    auth {\n        enabled on;\n        username admin;\n        password admin;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Read Settings\nDESCRIPTION: Settings for merged-read functionality which controls how SRS reads data from publishers, affecting performance and latency trade-offs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    publish {\n        mr          off;\n        mr_latency  350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx with HELM\nDESCRIPTION: HELM commands to add SRS repository and install Oryx with persistence and service port configurations\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhelm repo add srs http://helm.ossrs.io/stable\nhelm install srs srs/oryx --set persistence.path=$HOME/data \\\n  --set service.http=80 --set service.https=443 --set service.rtmp=1935 \\\n  --set service.rtc=8000 --set service.srt=10080\n```\n\n----------------------------------------\n\nTITLE: Configuring IRQ Affinity for Network Interfaces\nDESCRIPTION: This bash script sets the IRQ affinity for virtio network interfaces to specific CPUs, which can help optimize network performance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nfor irq in $(grep virtio /proc/interrupts | grep -e in -e out | cut -d: -f1); do \n    echo 1 > /proc/irq/$irq/smp_affinity\ndone\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx on AWS Lightsail\nDESCRIPTION: Bash script to install Oryx on an AWS Lightsail instance using a one-click installation method.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-09-Oryx-Tutorial.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/ossrs/oryx/HEAD/scripts/lightsail.sh)\"\n```\n\n----------------------------------------\n\nTITLE: Session-oriented RTMP Publish Stream Logs\nDESCRIPTION: This snippet shows the typical log entries for an RTMP publish stream session, including handshake, connection establishment, and stream identification. These logs are crucial for troubleshooting streaming issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Performing Rolling Update for SRS Edge Deployment (Bash)\nDESCRIPTION: This command initiates a rolling update for the 'srs-edge-deploy' Kubernetes Deployment. It uses `kubectl set image` to change the image for the container named 'srs' to `ossrs/srs:v4.0.6`. The `--record` flag appends this command to the deployment's rollout history, facilitating potential rollbacks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nkubectl set image deploy/srs-edge-deploy srs=ossrs/srs:v4.0.6 --record\n```\n\n----------------------------------------\n\nTITLE: SRS Cross-Build Configuration Options Help Output - Bash\nDESCRIPTION: This bash snippet displays the help message for SRS's configure script, outlining all cross-build and toolchain options. It must be run from the root of the SRS source directory. No dependencies besides the configure script. Output describes available presets, toolchain options, and how to specify cross-prefix, architecture, and other relevant flags for cross-compilation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n```bash\n./configure -h\n\nPresets:\n  --cross-build             Enable cross-build, please set bellow Toolchain also. Default: off\n  \nCross Build options:        @see https://ossrs.io/lts/en-us/docs/v6/doc/arm#ubuntu-cross-build-srs\n  --cpu=<CPU>               Toolchain: Select the minimum required CPU. For example: --cpu=24kc\n  --arch=<ARCH>             Toolchain: Select architecture. For example: --arch=aarch64\n  --host=<BUILD>            Toolchain: Build programs to run on HOST. For example: --host=aarch64-linux-gnu\n  --cross-prefix=<PREFIX>   Toolchain: Use PREFIX for tools. For example: --cross-prefix=aarch64-linux-gnu-\n\nToolchain options:\n  --static=on|off           Whether add '-static' to link options. Default: off\n  --cc=<CC>                 Toolchain: Use c compiler CC. Default: gcc\n  --cxx=<CXX>               Toolchain: Use c++ compiler CXX. Default: g++\n  --ar=<AR>                 Toolchain: Use archive tool AR. Default: g++\n  --ld=<LD>                 Toolchain: Use linker tool LD. Default: g++\n  --randlib=<RANDLIB>       Toolchain: Use randlib tool RANDLIB. Default: g++\n  --extra-flags=<EFLAGS>    Set EFLAGS as CFLAGS and CXXFLAGS. Also passed to ST as EXTRA_CFLAGS.\n```\n```\n\n----------------------------------------\n\nTITLE: Publishing SRT Stream Using FFmpeg\nDESCRIPTION: Uses FFmpeg to publish a stream using SRT protocol to SRS server\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG to Drop Video and Keep Audio in SRS\nDESCRIPTION: Configuration example showing how to set up FFMPEG to drop the video stream and only output audio. This is useful for creating audio-only variants of streams by setting vcodec to vn.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine vn {\n            enabled         on;\n            vcodec          vn;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS with configure and make - Bash\nDESCRIPTION: This script compiles and builds the SRS (Simple Realtime Server) application by running the configuration script and then invoking make. It is assumed that build dependencies are already installed. Standard output will reflect the configuration and compilation process. Required for enabling HTTP API features by ensuring the core binaries are present.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n./configure && make\\n```\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Using FFmpeg Docker Container\nDESCRIPTION: Docker command to run FFmpeg for publishing a stream to SRS server in a loop using RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Setting HLS TS File Path Generation Method in SRS\nDESCRIPTION: Configures whether to use floor() function for HLS TS file path generation. When enabled, it uses an enhanced algorithm to calculate segment deviation. Recommended to set hls_segment>=2*gop when enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_6\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_ts_floor    off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the real-time configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-realtime.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/realtime.conf\n```\n\n----------------------------------------\n\nTITLE: Gracefully Quitting SRS\nDESCRIPTION: Command to gracefully quit SRS by sending SIGQUIT signal via the init.d script, allowing existing connections to complete.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs grace\n```\n\n----------------------------------------\n\nTITLE: Publishing HEVC Stream with FFmpeg 6\nDESCRIPTION: Command to publish a HEVC stream via RTMP using FFmpeg 6. This uses libx265 for video encoding while keeping the original audio codec. The stream is published to the SRS server running on localhost.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -stream_loop -1 -re -i doc/source.flv -acodec copy \\\n  -vcodec libx265 -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing\nDESCRIPTION: FFMPEG command loop to continuously publish a video stream to SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-realtime.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: NGINX HLS Origin Server Configuration\nDESCRIPTION: NGINX configuration for serving as an HLS origin server, including cache control headers for m3u8 and ts files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\nlocation ~ /.+/.*\\.(m3u8)$ {\n  root /usr/local/srs/objs/nginx/html;\n  add_header Cache-Control \"public, max-age=10\";\n}\nlocation ~ /.+/.*\\.(ts)$ {\n  root /usr/local/srs/objs/nginx/html;\n  add_header Cache-Control \"public, max-age=86400\";\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 5.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS version 5.0 development branch (develop branch if 5.0release doesn't exist)\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/git.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout develop\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Command for SRT Stream Playback\nDESCRIPTION: FFmpeg command to play HEVC encoded video streamed over SRT protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::h=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFmpeg Tools\nDESCRIPTION: Command to configure and build SRS with FFmpeg tools enabled, which are required for transcoding functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to RTMP with FFmpeg\nDESCRIPTION: FFmpeg command to convert a UDP multicast stream to RTMP format and publish it to an SRS server. The command preserves metadata and uses libx264 and libfdk_aac codecs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n    ffmpeg -i udp://xxx:1234 -vcodec libx264 -acodec libfdk_aac \\\n      -metadata service_name=\"Channel 1\" -metadata service_provider=\"PBS\" \\\n      -f flv rtmp://xxx:1935/live/xxx:1234\n```\n\n----------------------------------------\n\nTITLE: Authenticated SRS HTTP API Request with Bearer Token in Bash\nDESCRIPTION: Example of making an authenticated request to the SRS HTTP API using a Bearer token.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/api/v1/vhosts/ \\\n  -X GET -H 'Authorization: Bearer xxxxxx' \\\n  -H 'Content-Type: application/json'\n```\n\n----------------------------------------\n\nTITLE: Publishing FLV Stream to SRS using FFmpeg (Bash)\nDESCRIPTION: This command uses FFmpeg to publish a video stream to the SRS server. `-re` reads the input at its native frame rate. `-i ./doc/source.flv` specifies the input file. `-c copy` instructs FFmpeg to copy the existing codecs without re-encoding. `-f flv` specifies the output format as FLV. `rtmp://localhost/live/livestream` is the RTMP URL of the SRS server where the stream will be published under the application `live` with the stream key `livestream`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Searching for Play Events in Origin Server Logs\nDESCRIPTION: Uses grep to search for 'type=Play' in the origin server logs to identify clients playing streams. This command returns lines containing session information for playback requests.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"type=Play\" objs/srs.origin.log \n31:[2014-08-06 10:09:34.671][trace][22288][107] client identified, type=Play, stream_name=livestream, duration=-1.00\n```\n\n----------------------------------------\n\nTITLE: Configuring DNS A Record for Oryx Domain\nDESCRIPTION: Example of a DNS A record configuration for pointing a domain to the Oryx Server IP address. This allows users to access the Oryx admin panel via a domain name rather than an IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nA bt.yourdomain.com 121.13.75.20\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Wait Keyframe in SRS YAML\nDESCRIPTION: Determines whether to wait for a keyframe before reaping an HLS segment. When on, segments are reaped only when duration is exceeded and a keyframe is received.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_wait_keyframe       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Playing SRT Stream from Proxy Server\nDESCRIPTION: FFplay command to play an SRT stream from the SRS proxy server using stream ID with request mode.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server for WebRTC\nDESCRIPTION: Launches SRS configured for WebRTC, setting the CANDIDATE environment variable for ICE.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG to Copy Video and Transcode Audio in SRS\nDESCRIPTION: Configuration example showing how to set up FFMPEG to copy video streams without transcoding while converting audio to AAC. This is useful when the input video codec is already compatible but audio needs conversion.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracing Upnode Server Session in SRS\nDESCRIPTION: Example of tracing upnode server session logs using PID and session ID\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"\\[12633\\]\\[141\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Transferring SRS Executable and Configuration to ARM via SCP - Bash\nDESCRIPTION: Sends SRS compiled binary and configuration files from the build machine to the ARM device via SCP. Assumes SSH access to the ARM device with user 'root' and port 2200. Requires 'scp' and network connectivity. The password for root is 'root'. Files are copied to the root user's home.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Password isroot\nscp -P 2200 objs/srs  root@localhost:~\nscp -P 2200 conf/rtmp.conf root@localhost:~\n```\n\n----------------------------------------\n\nTITLE: Running SRS for WebRTC over HTTPS (Bash)\nDESCRIPTION: Starts the SRS server configured for WebRTC communication using HTTPS. This is necessary when accessing WebRTC features from browsers not on the same machine as the server. It uses the 'conf/https.rtc.conf' configuration file, requires setting the 'CANDIDATE' environment variable, and assumes HTTPS certificates are correctly configured as per documentation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/https.rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS for WebRTC to RTMP Conversion\nDESCRIPTION: Docker command to run SRS with configuration for converting WebRTC streams to RTMP for playback, setting the external candidate IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Repository\nDESCRIPTION: Command to update an existing SRS repository to the latest version using Git.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-dash.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring NGINX Logging for Cache Debugging\nDESCRIPTION: This NGINX configuration adds cache status to the access log format and optionally to response headers for debugging cache effectiveness.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/nginx-for-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nlog_format  main  '$upstream_cache_status $remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\naccess_log  /var/log/nginx/access.log main;\n\n# Optional: Add cache status to response headers\nadd_header X-Cache-Status $upstream_cache_status;\n```\n\n----------------------------------------\n\nTITLE: Starting WebRTC Signaling Server\nDESCRIPTION: Docker command to run the signaling server required for WebRTC communication on port 1989.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 1989:1989 ossrs/signaling:1\n```\n\n----------------------------------------\n\nTITLE: Installing HiSilicon Cross-Compilation Toolchain\nDESCRIPTION: Commands to install and setup the HiSilicon cross-compilation toolchain for ARMv7(hisiv500) platform.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nchmod +x arm-hisiv500-linux.install\n./arm-hisiv500-linux.install\nsource /etc/profile\n```\n\n----------------------------------------\n\nTITLE: Verifying SRS Listening Port (Bash)\nDESCRIPTION: Uses `netstat` to check if the SRS process is successfully listening on the configured RTMP port (1935). It filters for TCP connections in the LISTEN state associated with the specified port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 trunk]# netstat -anp|grep \"1935 \"\ntcp        0      0 0.0.0.0:1935                0.0.0.0:*                   LISTEN      6583/srs\n```\n\n----------------------------------------\n\nTITLE: Cloning and Entering SRS Repository - Git - Bash\nDESCRIPTION: This snippet details how to clone the SRS repository from GitHub and navigate into its trunk directory in preparation for building and configuring SRS. It requires Git to be installed on the system. The snippet takes no input parameters and creates a local copy of the repository, preparing the environment for the next deployment steps.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Network Traffic Monitoring During 4k Client Test\nDESCRIPTION: Output of the 'dstat' command showing network traffic on the loopback interface during the 4k client test. Shows high network throughput with up to 104MB/s of traffic on the loopback interface.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 ~]$ dstat -N lo 30\n----total-cpu-usage---- -dsk/total- ---net/lo-- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  3   2  92   0   0   3|  11k   27k|   0     0 |   1B   26B|3085   443 \n 32  17  33   0   0  17| 273B   60k|  69M   69M|   0     0 |4878  6652 \n 34  18  32   0   0  16|   0    38k|  89M   89M|   0     0 |4591  6102 \n 35  19  30   0   0  17| 137B   41k|  91M   91M|   0     0 |4682  6064 \n 33  17  33   0   0  17|   0    31k|  55M   55M|   0     0 |4920  7785 \n 33  18  31   0   0  17|2867B   34k|  90M   90M|   0     0 |4742  6530 \n 32  18  33   0   0  17|   0    31k|  66M   66M|   0     0 |4922  7666 \n 33  17  32   0   0  17| 137B   39k|  65M   65M|   0     0 |4841  7299 \n 35  18  30   0   0  17|   0    28k| 100M  100M|   0     0 |4754  6752 \n 32  17  33   0   0  18|   0    41k|  44M   44M|   0     0 |5130  8251 \n 34  18  32   0   0  16|   0    30k| 104M  104M|   0     0 |4456  5718\n```\n\n----------------------------------------\n\nTITLE: Publishing HEVC Stream with Docker-based FFmpeg on Linux\nDESCRIPTION: Command to publish a HEVC stream via RTMP using a Docker container with FFmpeg for Linux environments. This uses the host network to directly access the SRS server running on the localhost.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --net=host --rm -it ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv -acodec copy \\\n    -vcodec libx265 -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Triggering Incremental Valgrind Check via SRS API using curl in Bash\nDESCRIPTION: Sends an HTTP GET request to the SRS API endpoint '/api/v1/valgrind' with the query parameter 'check=added'. This instructs the Valgrind-instrumented SRS process to perform an incremental memory leak check, reporting leaks added since the last check. This is used to establish a baseline and detect leaks after specific operations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://127.0.0.1:1985/api/v1/valgrind?check=added\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for Audio-Only HLS Transcoding\nDESCRIPTION: Configuration file that sets up SRS for transcoding audio to HLS format. It configures the HTTP server, HLS settings, and FFmpeg transcoding parameters focusing on audio transcoding with libfdk_aac codec.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-transcode-to-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/transcode2hls.audio.only.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    hls {\n        enabled         on;\n        hls_path        ./objs/nginx/html;\n        hls_fragment    10;\n        hls_window      60;\n    }\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Forward API Response Format\nDESCRIPTION: Expected JSON response format from backend server containing forward destination URLs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/forward.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"code\": 0,\n   \"data\": {\n       \"urls\":[\n          \"rtmp://127.0.0.1:19350/test/teststream\"\n       ]\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Tracing Client Connection Details\nDESCRIPTION: Search for all log entries related to client connection ID 107 in origin server log to see the complete connection lifecycle.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"\\[107\\]\" objs/srs.origin.log\n```\n\n----------------------------------------\n\nTITLE: Installing Logrotate Package\nDESCRIPTION: Command to install logrotate utility using yum package manager.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/log-rotate.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum install -y logrotate\n```\n\n----------------------------------------\n\nTITLE: Docker Commands for Services\nDESCRIPTION: Commands for running Prometheus and Grafana in Docker containers with appropriate configurations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/exporter.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n  -p 9090:9090 prom/prometheus\n```\n\n----------------------------------------\n\nTITLE: Deploying SRS Origin and Nginx Origin on Kubernetes\nDESCRIPTION: This YAML configuration creates a Kubernetes deployment for SRS origin and Nginx origin servers, along with associated services. It sets up a shared volume for HLS segments, deploys SRS and Nginx containers, and creates ClusterIP and LoadBalancer services for internal and external access respectively.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/k8s.md#2025-04-23_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-origin-deploy\n  labels:\n    app: srs-origin\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs-origin\n  template:\n    metadata:\n      labels:\n        app: srs-origin\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: ClusterIP\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n\n---\n\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-http-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs-origin\n  ports:\n  - name: srs-http-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-http-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n```\n\n----------------------------------------\n\nTITLE: Running SRS with HTTP Callback Enabled\nDESCRIPTION: This command starts SRS with HTTP callback functionality enabled using a specific configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.hooks.callback.conf\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration via Init.d Script - Bash\nDESCRIPTION: Reloads the SRS configuration without taking the service offline by using the init.d script's reload command. Requires the running SRS service. No parameters; input is implicit through the script call. Outputs confirmation or failure.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Playing SRT Stream Using FFplay\nDESCRIPTION: FFplay command to play stream using SRT protocol from SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Linking SRS init.d Script to System\nDESCRIPTION: Command to create a symbolic link from the SRS init.d script to the system's init.d directory. This is step 2 of setting up SRS as a system service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo ln -sf \\\n    /usr/local/srs/etc/init.d/srs \\\n    /etc/init.d/srs\n```\n\n----------------------------------------\n\nTITLE: Verifying HiSilicon Toolchain Installation\nDESCRIPTION: Command to verify that the HiSilicon cross-compilation toolchain is correctly installed and available in the system path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nwhich arm-hisiv500-linux-g++\n# /opt/hisi-linux/x86-arm/arm-hisiv500-linux/target/bin/arm-hisiv500-linux-g++\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream with FFmpeg Loop (Bash)\nDESCRIPTION: A shell loop that continuously uses FFmpeg to publish a local FLV file (`doc/source.flv`) as an RTMP stream to the SRS server running on localhost port 1935. `-re` simulates a real-time stream, codecs are copied without re-encoding, and the loop restarts after a 1-second sleep if ffmpeg exits.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://127.0.0.1:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: Installing curl in Oryx Docker Container - Bash\nDESCRIPTION: Installs curl inside the running Oryx Docker container using the apt-get package manager. The commands update the container's package index and then install curl, making it available for further API and connectivity testing from within the container environment.\n\nDependencies: Docker must be installed and the 'oryx' container running. Requires network access to Debian/Ubuntu repositories.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker exec -it oryx apt-get update -y\ndocker exec -it oryx apt-get install -y curl\n```\n\n----------------------------------------\n\nTITLE: FFMPEG SRT Stream Publishing\nDESCRIPTION: FFMPEG command to publish a stream using SRT protocol to SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-srt.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts 'srt://192.168.1.170:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Starting 500 RTMP Load Test Clients for SRS\nDESCRIPTION: Command to start 500 RTMP client connections for load testing SRS. The command initiates client connections to the specified RTMP endpoint and redirects output to /dev/null.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 500 -r rtmp://127.0.0.1:1935/live/livestream >/dev/null &\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: Command to publish a stream to SRS using FFmpeg with FLV source file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Viewing SRS Server Startup Logs with System Information\nDESCRIPTION: This snippet demonstrates how to start the SRS server and view its startup logs, which include version information, configuration details, PID file location, and listening ports for RTMP, HTTP API, and HTTP service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c console.conf \n[winlin@dev6 srs]$ cat objs/srs.log \n[2014-04-04 11:39:24.176][trace][0][0] config parsed EOF\n[2014-04-04 11:39:24.176][trace][0][0] log file is ./objs/srs.log\n[2014-04-04 11:39:24.177][trace][0][0] srs 0.9.46\n[2014-04-04 11:39:24.177][trace][0][0] uname: Linux dev6 2.6.32-71.el6.x86_64 \n#1 SMP Fri May 20 03:51:51 BST 2011 x86_64 x86_64 x86_64 GNU/Linux\n[2014-04-04 11:39:24.177][trace][0][0] build: 2014-04-03 18:38:23, little-endian\n[2014-04-04 11:39:24.177][trace][0][0] configure:  --dev --with-hls --with-nginx \n--with-ssl --with-ffmpeg --with-http-callback --with-http-server --with-http-api \n--with-librtmp --with-bwtc --with-research --with-utest --without-gperf --without-gmc \n--without-gmp --without-gcp --without-gprof --without-arm-ubuntu12 --jobs=1 \n--prefix=/usr/local/srs\n[2014-04-04 11:39:24.177][trace][0][0] write pid=4021 to ./objs/srs.pid success!\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1935, type=0, fd=6\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1985, type=1, fd=7\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=8080, type=2, fd=8\n[2014-04-04 11:39:24.177][trace][101][16] listen cycle start, port=1935, type=0, fd=6\n[2014-04-04 11:39:24.177][trace][102][11] listen cycle start, port=1985, type=1, fd=7\n[2014-04-04 11:39:24.177][trace][103][11] listen cycle start, port=8080, type=2, fd=8\n[2014-04-04 11:39:26.799][trace][0][11] get a signal, signo=2\n[2014-04-04 11:39:26.799][trace][0][11] user terminate program\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARMv7\nDESCRIPTION: Configuration and make commands for cross-compiling SRS for ARMv7 architecture using the installed toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=arm-linux-gnueabihf-\nmake\n```\n\n----------------------------------------\n\nTITLE: Running SRS on ARM\nDESCRIPTION: Command to run the compiled SRS binary on an ARM platform using a sample configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: SRT Authentication with Token Parameter in streamid\nDESCRIPTION: FFmpeg command demonstrating how to include authentication parameters such as a secret token in the SRT streamid. This allows for token-based authentication similar to RTMP URLs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/srt.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f mpegts \\\n    'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,secret=xxx,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with Ingest Configuration in Bash\nDESCRIPTION: This command starts the SRS server using the ingest configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ingest.conf\n```\n\n----------------------------------------\n\nTITLE: Dynamic Forward Request JSON in SRS\nDESCRIPTION: Example JSON request sent by SRS to the backend service for dynamic forward configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"action\": \"on_forward\",\n    \"server_id\": \"vid-k21d7y2\",\n    \"client_id\": \"9o7g1330\",\n    \"ip\": \"127.0.0.1\",\n    \"vhost\": \"__defaultVhost__\",\n    \"app\": \"live\",\n    \"tcUrl\": \"rtmp://127.0.0.1:1935/live\",\n    \"stream\": \"livestream\",\n    \"param\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for Live Streaming\nDESCRIPTION: Basic Docker command to run SRS server with ports exposed for RTMP (1935), HTTP API (1985), and HTTP streaming (8080).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Keyframe Wait in SRS\nDESCRIPTION: Determines whether to wait for a keyframe before reaping an HLS segment. When on, segments are reaped only when the duration exceeds the fragment size and a keyframe is encountered. When off, segments are reaped solely based on duration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_7\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_wait_keyframe       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WebRTC Publisher and Player Integration for Host B\nDESCRIPTION: WordPress shortcode configuration for the second host (Host B) in a WebRTC video chat. This creates a page with both publishing capability for Host B's stream and viewing capability for Host A's stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-06-30-Video-Chat-Live.md#2025-04-23_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n[srs_publisher url=\"webrtc://your-server-ip/live/stream-b\"]\n[srs_player url=\"webrtc://your-server-ip/live/stream-a\"]\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with HttpCallback Snapshot Configuration\nDESCRIPTION: This command starts SRS using the snapshot configuration file, which will initiate the ingest and trigger the API server to start taking snapshots.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n./objs/srs -c snapshot.conf\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Request Format and Types\nDESCRIPTION: Specifies both simple and full request formats including methods, URIs and version information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_18\n\nLANGUAGE: http\nCODE:\n```\nRequest        = Simple-Request | Full-Request\n\nSimple-Request = \"GET\" SP Request-URI CRLF\n\nFull-Request   = Request-Line             ; Section 5.1\n                        *( General-Header        ; Section 4.3\n                         | Request-Header        ; Section 5.2\n                         | Entity-Header )       ; Section 7.1\n                        CRLF\n                        [ Entity-Body ]          ; Section 7.2\n```\n\n----------------------------------------\n\nTITLE: Complete FFmpeg Command for Subtitle Overlay\nDESCRIPTION: Full FFmpeg command example for overlaying subtitles on a video file with specific codec parameters, including disabling B-frames for WebRTC compatibility.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg \\\n    -i transcript/2-org-4f06f7a5-7f83-4845-9b4b-716ffec1bead.ts \\\n    -vf subtitles=transcript/2-audio-a982892f-1d56-4b4a-a663-f3b7f1a5b548.srt:force_style='Alignment=2,MarginV=20' \\\n    -c:v libx264 -profile:v main -preset:v medium -tune zerolatency -bf 0 \\\n    -c:a aac -copyts \\\n    -y transcript/2-overlay-2ba4154c-03ed-4853-bdda-d8396fcb1f47.ts\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing\nDESCRIPTION: FFMPEG command loop to continuously publish a stream to SRS using RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Starting First Origin Server for HLS Output (Bash)\nDESCRIPTION: Command to start the first SRS origin server listening on ports 1935 and 8080, configured to receive RTMP input and output HLS streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only1.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring UTC Time Usage in SRS YAML\nDESCRIPTION: Determines whether to use UTC time for generating time structures. When off, localtime() is used; when on, gmtime() is used for UTC time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nutc_time            off;\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FMLE\nDESCRIPTION: Configuration parameters for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the RTMP cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing DASH Streams via FFMPEG in a Loop - Bash\nDESCRIPTION: This snippet runs FFMPEG in an infinite loop, repeatedly reading input from a FLV file and streaming it to the SRS server as an RTMP stream. It assumes FFMPEG is built and available at ./objs/ffmpeg/bin/ffmpeg, and the input file exists at ./doc/source.flv. The -re flag reads at native rate, -c copy copies codecs, and -f flv specifies the output format. A sleep command pauses 1 second between loops to continuously broadcast the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-dash.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Retrieving HLS VCodec Setting in SRS (C++)\nDESCRIPTION: This C++ method retrieves the video codec setting for HLS in SRS, defaulting to 'h264' if not found. It uses a static variable for the default value and accesses directive settings based on the provided vhost parameter. Dependencies: The SrsConfig class, SrsConfDirective definition, and get_hls method must exist. Returns a string representing the codec name, with the limitation that if get_hls returns null, the fallback default is always 'h264'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nstring SrsConfig::get_hls_vcodec(string vhost) {\n    SRS_STATIC string DEFAULT = \"h264\";\n    SrsConfDirective* conf = get_hls(vhost);\n    if (!conf) {\n        return DEFAULT;\n```\n\n----------------------------------------\n\nTITLE: Getting Server IP Address (Bash)\nDESCRIPTION: Uses the `ifconfig` command to display network interface information for `eth0` and identify the server's IP address (192.168.2.101 in this example), which is needed for constructing the RTMP URLs for clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# ifconfig eth0\neth0      Link encap:Ethernet  HWaddr 08:00:27:8A:EC:94  \n          inet addr:192.168.2.101  Bcast:192.168.2.255  Mask:255.255.255.0\n```\n\n----------------------------------------\n\nTITLE: Configuring Sequence Header Reduction in SRS YAML\nDESCRIPTION: Enables reduction of sequence headers for clients that cannot handle duplicated headers. This is useful when the sequence header hasn't changed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        reduce_sequence_header  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Mounting a RAM Disk for HLS Output - Bash\nDESCRIPTION: This system-level bash code creates the /ramdisk directory and mounts a 7GB tmpfs memory disk at that location to store HLS segments in memory. This enhances performance and concurrent stream capacity by avoiding disk I/O. Prerequisites: root access, Linux system with enough free RAM. Input: shell commands; Output: memory disk mounted for fast I/O. Use 'umount /ramdisk' to unmount later.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p /ramdisk &&\nmount -o size=7G -t tmpfs none /ramdisk\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with HTTPS for WebRTC\nDESCRIPTION: Launches SRS with HTTPS configuration for secure WebRTC connections, necessary for non-localhost usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/https.rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing a Test Stream to SRS\nDESCRIPTION: FFmpeg command to publish a test video stream to SRS using RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Analyzing Session-Specific Logs by ID in Bash\nDESCRIPTION: Example of filtering SRS logs by connection ID to trace the full lifecycle of a specific streaming session, showing handshake, connection, metadata handling, and disconnection events.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log |grep -ina \"\\[104\\]\\[\"\n14:[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n15:[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n16:[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n17:[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n18:[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n19:[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n21:[2014-04-04 11:56:06.288][trace][104][11] set output chunk size to 60000\n22:[2014-04-04 11:56:06.288][trace][104][11] set chunk_size=60000 success\n23:[2014-04-04 11:56:07.397][trace][104][11] <- time=225273, obytes=4168, ibytes=7607, okbps=32, ikbps=59\n24:[2014-04-04 11:56:07.398][trace][104][11] dispatch metadata success.\n25:[2014-04-04 11:56:07.398][trace][104][11] process onMetaData message success.\n26:[2014-04-04 11:56:07.398][trace][104][11] update video sequence header success. size=67\n27:[2014-04-04 11:56:08.704][trace][104][11] <- time=226471, obytes=4168, ibytes=36842, okbps=13, ikbps=116\n28:[2014-04-04 11:56:09.901][trace][104][11] <- time=227671, obytes=4168, ibytes=67166, okbps=9, ikbps=152\n29:[2014-04-04 11:56:11.102][trace][104][11] <- time=228869, obytes=4168, ibytes=97481, okbps=6, ikbps=155\n30:[2014-04-04 11:56:11.219][trace][104][11] clear cache/metadata/sequence-headers when unpublish.\n31:[2014-04-04 11:56:11.219][trace][104][11] control message(unpublish) accept, retry stream service.\n32:[2014-04-04 11:56:11.219][trace][104][11] ignore AMF0/AMF3 command message.\n33:[2014-04-04 11:56:11.419][trace][104][11] drop the AMF0/AMF3 command message, command_name=deleteStream\n34:[2014-04-04 11:56:11.420][trace][104][11] ignore AMF0/AMF3 command message.\n35:[2014-04-04 11:56:12.620][error][104][104] recv client message failed. ret=207(Connection reset by peer)\n36:[2014-04-04 11:56:12.620][error][104][104] identify client failed. ret=207(Connection reset by peer)\n37:[2014-04-04 11:56:12.620][warn][104][104] client disconnect peer. ret=204\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to SRS Using FFmpeg - Bash\nDESCRIPTION: This infinite Bash loop repeatedly uses FFmpeg to stream a local FLV file as RTMP to the SRS origin server, re-publishing every second. Dependencies: FFmpeg built and accessible at './objs/ffmpeg/bin/ffmpeg', source video available at './doc/source.flv'. Parameters: none. Outputs to RTMP ingest URL; stops only when interrupted.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Polling SRS RTMP Connections in a Loop - Bash\nDESCRIPTION: This Bash loop script periodically (every 5 seconds) counts the number of established TCP connections on port 1935 (used for RTMP by SRS) and prints the count with the label 'srs_connections'. It uses netstat, grep, wc, and sleep commands, and must be run with sufficient privileges to invoke 'sudo netstat'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/raspberrypi.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    srs_connections=`sudo netstat -anp|grep 1935|grep ESTABLISHED|wc -l`;  \\\n    echo \"srs_connections: $srs_connections\";  \\\n    sleep 5;  \\\ndone\n\n```\n\n----------------------------------------\n\nTITLE: Building SRS for ARMv8/aarch64 with Architecture Flag\nDESCRIPTION: Command to configure and build SRS for ARMv8/aarch64 architectures, specifying the architecture when it's not automatically identified.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --extra-flags='-D__aarch64__' && make\n```\n\n----------------------------------------\n\nTITLE: Running srs-bench Container for HLS Load Testing - Bash\nDESCRIPTION: Runs a Docker container with ossrs/srs:sb to simulate 500 concurrent clients fetching an HLS stream, using the sb_hls_load benchmarking utility. Requires Docker installed and network access to the target HLS server. Key parameters: -c (concurrency), -r (target playlist URL). Designed to stress-test NGINX or SRS streaming setups and measure system throughput.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_hls_load -c 500 \\\n  -r http://your_server_public_ipv4/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Calculating TS Segment Duration in SRS HLS Config - Bash\nDESCRIPTION: This snippet shows how the TS segment duration is determined within SRS's HLS config, emphasizing the effect of hls_fragment and encoder's gop_size. The formula ensures that the resulting TS file's duration is at least as long as either the configured fragment or the encoder's gop duration. This logic is critical for tuning latency and segment length; it is implemented within the SRS streaming server, not directly executable bash code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nts\\u6587\\u4ef6\\u65f6\\u957f = max(hls_fragment, gop_size)\nhls_fragment\\uff1a\\u914d\\u7f6e\\u6587\\u4ef6\\u4e2d\\u7684\\u957f\\u5ea6\\u3002\\u8bd5\\u5982\\uff1a5\\u79d2\\u3002\ngop_size\\uff1a\\u7f16\\u7801\\u5668\\u914d\\u7f6e\\u7684gop\\u7684\\u957f\\u5ea6\\uff0c\\u8bd5\\u5982ffmpeg\\u6307\\u5b9afps\\u4e3a20\\u5e27\\uff0f\\u79d2\\uff0cgop\\u4e3a200\\u5e27\\uff0c\\u5219gop_size=gop/fps=10\\u79d2\\u3002\n\\u90a3\\u4e48\\uff0c\\u6700\\u7ec8ts\\u7684\\u65f6\\u957f\\u4e3amax(5, 10) = 10\\u79d2\\u3002\\u8fd9\\u4e5f\\u662f\\u4e3a\\u4ec0\\u4e48\\u6709\\u4e9b\\u6d41\\u914d\\u7f6e\\u4e86hls_fragment\\uff0c\\u4f46\\u662fts\\u65f6\\u957f\\u4ecd\\u7136\\u6bd4\\u8fd9\\u4e2a\\u5927\\u7684\\u539f\\u56e0\\u3002\n```\n\n----------------------------------------\n\nTITLE: Cross-Building SRS for aarch64\nDESCRIPTION: Commands to configure and build SRS for aarch64 architecture using cross-compilation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=aarch64-linux-gnu-\nmake\n```\n\n----------------------------------------\n\nTITLE: Filter SRS Logs for Specific Stream Names - Bash\nDESCRIPTION: This command filters previously matched publication logs for a specific stream name, like 'livestream'. It demonstrates combining grep commands to extract events associated with named streams. Requires output from the previous grep and the stream name as key input. The result includes only those session lines relating to the designated stream, allowing for narrow tracking of individual stream activity.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"|grep -a \"livestream\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Version for 4k Performance Test\nDESCRIPTION: Command to display the version of SRS being used for the 4k clients performance benchmark. Shows the server is running version 0.9.130.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -v\n0.9.130\n```\n\n----------------------------------------\n\nTITLE: Running Prometheus with Configuration\nDESCRIPTION: Docker command to run Prometheus with the custom configuration file that includes SRS and node_exporter scrape targets.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \\\n  -p 9090:9090 prom/prometheus\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFmpeg Docker\nDESCRIPTION: Uses the SRS encoder Docker image to publish a looping video stream to the SRS server using FFmpeg.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes LoadBalancer Service for SRS and Nginx (YAML)\nDESCRIPTION: This Kubernetes manifest defines a Service resource named 'srs-origin-service' of type 'LoadBalancer'. It exposes the Pods matched by the label 'app: srs' (created by the previous Deployment) externally. The service maps external ports 80 (for Nginx HLS), 1935 (for SRS RTMP), 1985 (for SRS API), and 8080 (for SRS HTTP-FLV/HLS) to the corresponding container ports, typically using a cloud provider's load balancer to assign an external IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/k8s.md#2025-04-23_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-origin-service-80-80\n    port: 80\n    protocol: TCP\n    targetPort: 80\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-origin-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-origin-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\nEOF\n```\n\n----------------------------------------\n\nTITLE: Fetching PR branch as a TOC member\nDESCRIPTION: Command for TOC members to fetch the branch from a contributor's fork. This retrieves the latest code from the PR branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch tmp\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin Server for HLS Streaming - Bash\nDESCRIPTION: Starts an SRS (Simple Realtime Server) instance using the provided HLS origin configuration file. Prerequisites: SRS compiled, valid hls.origin.conf present in conf/. Input: SRS server binary and config file. Output: Running SRS server ready to accept RTMP and provide HLS streams. Ensure ports and paths match the NGINX or client configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/hls.origin.conf\n```\n\n----------------------------------------\n\nTITLE: Finding Stream Source\nDESCRIPTION: Search for the original stream source connection (ID 105) that is publishing the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[105\\]\" objs/srs.origin.log\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Read for SRS Publisher\nDESCRIPTION: This configuration sets up merged-read options for the publisher in SRS, allowing for improved performance at the cost of some latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    publish {\n        mr          off;\n        mr_latency  350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling iptables Firewall in Bash\nDESCRIPTION: These commands stop the `iptables` firewall service immediately and configure it not to start automatically on system boot. This is suggested as a troubleshooting step if stream playback fails or server connections are unsuccessful without clear error messages. Requires root privileges (`sudo`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/install.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# disable the firewall\nsudo /etc/init.d/iptables stop\nsudo /sbin/chkconfig iptables off\n```\n\n----------------------------------------\n\nTITLE: Monitoring Network Bandwidth with dstat\nDESCRIPTION: Command to monitor network bandwidth usage using dstat tool.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 ~]$ dstat 30\n----total-cpu-usage---- -dsk/total- -net/lo- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  0   0  96   0   0   3|   0     0 |1860B   58k|   0     0 |2996   465 \n  0   1  96   0   0   3|   0     0 |1800B   56k|   0     0 |2989   463 \n  0   0  97   0   0   2|   0     0 |1500B   46k|   0     0 |2979   461 \n```\n\n----------------------------------------\n\nTITLE: Checking SRS Server Status in Bash\nDESCRIPTION: Commands to check the SRS process status and view the server logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Check the process status\n./etc/init.d/srs status\n\n# Check the SRS logs\ntail -n 30 -f ./objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Limiting HTTP API Access to Local Machine for SRS 4.0\nDESCRIPTION: Configuration for SRS 4.0 to limit HTTP API access to the local machine only, allowing a local proxy to handle authentication.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nhttp_api {\n    enabled on;\n    listen 127.0.0.1:1985;\n}\n```\n\n----------------------------------------\n\nTITLE: Deploying Oryx Server with Docker\nDESCRIPTION: Command to deploy Oryx server using Docker with volume mapping for data persistence and port forwarding for various services including HTTP, HTTPS, RTMP, and UDP streaming endpoints.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2024-02-21-Dubbing-Translating.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: RTMP URL for Playing Stream from SRS Plain Text\nDESCRIPTION: This shows the RTMP URL that client applications, such as VLC player, should use to connect to and play the live stream being published to the SRS server. The IP address `192.168.1.170` and port `19350` need to be replaced with the actual accessible IP and port of the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-arm.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\nrtmp://192.168.1.170:19350/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Sample FFmpeg Command for Streaming to SRS\nDESCRIPTION: FFmpeg command to push a video stream to the SRS server running on ARM, using RTMP protocol for streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS in ARMv7 Docker Container\nDESCRIPTION: Command to run a cross-compiled SRS binary in an ARMv7 Docker container for testing, exposing the RTMP and HTTP ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 armv7/armhf-ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS codebase from GitHub repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Servers\nDESCRIPTION: Commands to start all SRS servers (Origin ServerA, ServerB, and Edge) with their respective configurations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.cluster.serverA.conf &\n./objs/srs -c conf/origin.cluster.serverB.conf &\n./objs/srs -c conf/origin.cluster.edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Publishing HEVC WebRTC Stream in Safari\nDESCRIPTION: URL for publishing an HEVC WebRTC stream using WHIP protocol in Safari. This requires enabling the experimental WebRTC H265 codec feature in Safari's settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_14\n\nLANGUAGE: markdown\nCODE:\n```\n* Publish [http://localhost:1985/rtc/v1/whip/?app=live&stream=livestream&codec=hevc](http://localhost:8080/players/whip.html?autostart=true&codec=hevc)\n```\n\n----------------------------------------\n\nTITLE: Dynamic Forward Response JSON in SRS\nDESCRIPTION: Example JSON response expected by SRS from the backend service for dynamic forward configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"code\": 0,\n   \"data\": {\n       \"urls\":[\n          \"rtmp://127.0.0.1:19350/test/teststream\"\n       ]\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming Video with FFmpeg to SRS\nDESCRIPTION: Bash script to continuously stream a video file to SRS using FFmpeg.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://192.168.1.105:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: Displaying GPERF Heap Checker Active Warning in Bash\nDESCRIPTION: Shows the warning message printed to the console when SRS is started with the GPERF memory checker (gmc) enabled via the `HEAPCHECK` environment variable. This indicates that the heap checker is running, which might impact performance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ env PPROF_PATH=./objs/pprof HEAPCHECK=normal ./objs/srs -c conf/console.conf\nWARNING: Perftools heap leak checker is active -- Performance may suffer\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARMv8/aarch64\nDESCRIPTION: Configuration and make commands for cross-compiling SRS for ARMv8/aarch64 architecture using the installed toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=aarch64-linux-gnu-\nmake\n```\n\n----------------------------------------\n\nTITLE: Persistent UDP Buffer Configuration in Linux\nDESCRIPTION: Modifies the /etc/sysctl.conf file to set UDP buffer sizes permanently, ensuring the configuration persists across system reboots.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# vi /etc/sysctl.conf\n# For RTC\nnet.core.rmem_max=16777216\nnet.core.rmem_default=16777216\nnet.core.wmem_max=16777216\nnet.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Command for AAC Audio Streaming over SRT\nDESCRIPTION: FFmpeg command to push AAC audio format over SRT with optimized PES payload size settings to reduce latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/srt.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i source.mp4 -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server using the DASH configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-dash.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/dash.conf\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug for SRS Upnode in YAML\nDESCRIPTION: Enables debug information for upstream SRS nodes. This is useful for collecting debug info such as ID, source ID, and PID when connecting to upnodes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    debug_srs_upnode    on;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Multiple SRS Origin Servers\nDESCRIPTION: Commands to start three SRS origin servers with different configuration files, which connect to the proxy server via the system API port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin1-for-proxy.conf\n./objs/srs -c conf/origin2-for-proxy.conf\n./objs/srs -c conf/origin3-for-proxy.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Transcoding for Specific Stream in SRS\nDESCRIPTION: This snippet shows how to configure transcoding for a specific stream within an app in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # Transcode stream name is \"livestream\" and app is \"live\"\n    transcode live/livestream{\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback: on_publish Event - JSON\nDESCRIPTION: Defines the request and response message formats for the 'on_publish' HTTP callback event in Oryx. The JSON object includes fields like request_id, action ('on_publish'), vhost, app, stream, and param, which are POSTed to the configured callback URL. Response with code 0 permits publish; other codes reject.\n\nInputs: All fields must be provided in the request payload. Output: {\"code\": 0} for accept. Dependencies: The receiving server must accept JSON bodies.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"request_id\": \"3ab26a09-59b0-42f7-98e3-a281c7d0712b\",\n  \"action\": \"on_publish\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"param\": \"?secret=8f7605d657c74d69b6b48f532c469bc9\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS for ARMv8/aarch64\nDESCRIPTION: Configuration command with special flags for ARMv8/aarch64 architecture when automatic detection fails.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --extra-flags='-D__aarch64__' && make\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Entity Encoding Model in BNF\nDESCRIPTION: Definition of the two-layer encoding model for HTTP entity bodies, showing the relationship between Content-Type and Content-Encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_28\n\nLANGUAGE: BNF\nCODE:\n```\nentity-body := Content-Encoding( Content-Type( data ) )\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with HLS Configuration\nDESCRIPTION: Command to start an SRS server container with HLS support using Docker. Exposes ports 1935 (RTMP) and 8080 (HTTP) and uses the HLS configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:5 \\\n  ./objs/srs -c conf/hls.conf\n```\n\n----------------------------------------\n\nTITLE: Starting Master SRS Server\nDESCRIPTION: Command to start the master SRS server using the specified configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/forward.master.conf\n```\n\n----------------------------------------\n\nTITLE: Copying Binaries to ARM Device\nDESCRIPTION: SCP commands to transfer the compiled SRS binary and configuration files to the ARM device running in a virtual machine. The commands use port 2200 which is mapped to the ARM device's SSH port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Password isroot\nscp -P 2200 objs/srs  root@localhost:~\nscp -P 2200 conf/rtmp.conf root@localhost:~\n```\n\n----------------------------------------\n\nTITLE: Configuring UTC Time Usage in SRS\nDESCRIPTION: Determines whether to use UTC time for generating time structures. When off, localtime() is used; when on, gmtime() is used instead, which utilizes UTC time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_5\n\nLANGUAGE: nginx\nCODE:\n```\nutc_time            off;\n```\n\n----------------------------------------\n\nTITLE: Secondary Player Connection Trace\nDESCRIPTION: Search for the second player connection ID 110 on edge server to see additional player details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[110\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server on ARM Device Bash\nDESCRIPTION: This command executes the SRS binary (`./objs/srs`) located in the `objs` directory on the ARM device. The `-c` flag specifies the path to the configuration file (`conf/rtmp.conf`) that SRS should use upon startup. This command should be run after logging into the ARM device.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with DASH Configuration\nDESCRIPTION: Command to start the SRS server with the DASH configuration file. This launches the server that will handle RTMP ingestion and DASH delivery.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-dash.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/dash.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring UTC Time Usage\nDESCRIPTION: Controls whether to use UTC time (gmtime()) or local time for generating time structures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_5\n\nLANGUAGE: nginx\nCODE:\n```\nutc_time            off;\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-dash.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Repeatedly Using FFMPEG in an Infinite Loop - Bash\nDESCRIPTION: Uses a bash loop to continuously publish a stream to the SRS server using FFMPEG. The FFMPEG command reads a local FLV file, copies the stream, and transmits to the RTMP endpoint. Key parameters: 'source.flv' as input, RTMP URL for output, and a 1-second sleep between publishes. Requires FFMPEG available at './objs/ffmpeg/bin/ffmpeg'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: NodeJS KOA Proxy Configuration\nDESCRIPTION: NodeJS implementation using KOA for proxying requests to SRS HTTP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-server.md#2025-04-23_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst Koa = require('koa');\nconst proxy = require('koa-proxies');\nconst BodyParser = require('koa-bodyparser');\nconst Router = require('koa-router');\n\nconst app = new Koa();\napp.use(proxy('/api/', {target: 'http://127.0.0.1:1985/'}));\napp.use(proxy('/rtc/', {target: 'http://127.0.0.1:1985/'}));\napp.use(proxy('/*/*.(flv|m3u8|ts|aac|mp3)', {target: 'http://127.0.0.1:8080/'}));\napp.use(proxy('/console/', {target: 'http://127.0.0.1:8080/'}));\napp.use(proxy('/players/', {target: 'http://127.0.0.1:8080/'}));\n\napp.use(BodyParser());\n\nconst router = new Router();\nrouter.all('/', async (ctx) => {\n  ctx.body = 'Hello World';\n});\napp.use(router.routes());\n\napp.listen(3000, () => {\n  console.log(`Server start on http://localhost:3000`);\n});\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Server Status\nDESCRIPTION: Commands to verify if SRS is running properly by checking its status or viewing logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# SRS\n./etc/init.d/srs status\n\n# SRS\ntail -n 30 -f ./objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the realtime configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/realtime.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Second RTMP Stream to Multi-Origin Setup\nDESCRIPTION: Uses FFmpeg to publish a second, distinct RTMP stream (`livestream2`) to the same multi-Origin SRS setup. The connection will be handled by one of the available Origin server processes selected by the kernel.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream2\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS TS Floor in SRS\nDESCRIPTION: Controls the algorithm used for HLS TS file path generation. When enabled, it uses floor(timestamp/hls_fragment) as the timestamp variable and an enhanced algorithm to calculate deviation for segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_6\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enahanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # default: off\n        hls_ts_floor    off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Normal Packet Timeout for SRS RTMP Publishers\nDESCRIPTION: Sets the timeout in milliseconds for normal packets from RTMP publishers. This configuration helps manage ongoing connections for encoders pushing RTMP streams to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        normal_timeout      7000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Monitoring Network Bandwidth with dstat Tool\nDESCRIPTION: Example of using the dstat tool to monitor network traffic on the loopback interface. This command shows CPU usage, disk activity, network bandwidth, paging, and system statistics with a 30-second update interval.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\ndstat -N lo 30\n```\n\n----------------------------------------\n\nTITLE: Cross-Building SRS for ARMv7\nDESCRIPTION: Commands to configure and build SRS for ARMv7 architecture using cross-compilation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=arm-linux-gnueabihf-\nmake\n```\n\n----------------------------------------\n\nTITLE: JSON Request for Dynamic Forward\nDESCRIPTION: Example JSON request body sent by SRS to the backend server when a client publishes a stream. This request contains all necessary stream metadata for the backend to make forwarding decisions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"action\": \"on_forward\",\n    \"server_id\": \"vid-k21d7y2\",\n    \"client_id\": \"9o7g1330\",\n    \"ip\": \"127.0.0.1\",\n    \"vhost\": \"__defaultVhost__\",\n    \"app\": \"live\",\n    \"tcUrl\": \"rtmp://127.0.0.1:1935/live\",\n    \"stream\": \"livestream\",\n    \"param\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying RTMP Stream on SRS Origin using FFprobe\nDESCRIPTION: This shell command utilizes `ffprobe` to connect to the RTMP stream being served by the SRS origin server (`rtmp://xxx:1935/live/xxx:1234`) and display its details, including metadata and stream information (codecs, resolution, bitrate). This helps confirm the stream was successfully published by FFmpeg.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n    [root@encoder1 ~]# ffprobe rtmp://xxx:1935/live/xxx:1234\n    Input #0, flv, from 'rtmp://xxx:1935/live/xxx:1234':\n      Metadata:\n        service_name    : Channel 1\n        service_provider: PBS\n        encoder         : Lavf57.24.100\n        server          : SRS/2.0.209(ZhouGuowen)\n        srs_primary     : SRS/1.0release\n        srs_authors     : winlin,wenjie.zhao\n        server_version  : 2.0.209\n      Duration: N/A, start: 0.010000, bitrate: N/A\n        Stream #0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 128 kb/s\n        Stream #0:1: Video: h264 (High), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 1k tbn\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using Init Script\nDESCRIPTION: Illustrates how to reload the SRS configuration using the provided init script. This method is convenient for system administrators managing SRS as a service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reload.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Exporter Enabled\nDESCRIPTION: Command to build and start SRS with Prometheus exporter enabled using environment variables. It sets the SRS listen port to 1935 and enables the exporter.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\nenv SRS_ENV_ONLY=on SRS_EXPORTER_ENABLED=on SRS_LISTEN=1935 \\\n  ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: Defining the EXT-X-BYTERANGE Tag in M3U8 Media Playlists\nDESCRIPTION: Specifies the format of the EXT-X-BYTERANGE tag, indicating a media segment is a sub-range of the resource identified by the following media URI. 'n' is the length in bytes, and optional 'o' is the starting byte offset. If 'o' is absent, the sub-range starts immediately after the previous segment's sub-range from the same resource. Applies only to the next media URI and MUST NOT appear in Master Playlists. Introduced in protocol version 4.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_3\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-BYTERANGE:<n>[@<o>]\n```\n\n----------------------------------------\n\nTITLE: SRS Connection Count Monitoring\nDESCRIPTION: Continuous loop command to monitor the number of established connections to SRS server on port 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    srs_connections=`sudo netstat -anp|grep 1935|grep ESTABLISHED|wc -l`;  \\\n    echo \"srs_connections: $srs_connections\";  \\\n    sleep 5;  \ndone\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Streaming Loop\nDESCRIPTION: Bash script using FFmpeg to continuously stream a video file to the RTMP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub or update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS TS Filename Generation Method (Floor)\nDESCRIPTION: Controls the algorithm for generating HLS Transport Stream (.ts) filenames based on timestamps. When set to 'on', it uses `floor(timestamp/hls_fragment)` for the `[timestamp]` variable and an enhanced deviation calculation. It's recommended to set `hls_segment` >= 2*GOP when 'on'. The default is 'off'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether use floor for the hls_ts_file path generation.\n        # if on, use floor(timestamp/hls_fragment) as the variable [timestamp],\n        #       and use enahanced algorithm to calc deviation for segment.\n        # @remark when floor on, recommend the hls_segment>=2*gop.\n        # default: off\n        hls_ts_floor    off;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Verifying Connection Limit Before Nginx Start (Bash)\nDESCRIPTION: Checks the open file descriptor limit immediately before starting the Nginx server to ensure the previously set limit (`10240`) is still in effect for the current shell session.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Continuous RTMP Publishing with FFmpeg\nDESCRIPTION: This bash script continuously publishes a video file as an RTMP stream using FFmpeg, restarting the stream every second if it ends.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://127.0.0.1:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic ATC Detection for Playback\nDESCRIPTION: Controls whether SRS automatically enables Absolute Time Code (ATC) handling for playback streams based on the presence of `bravo_atc=\"true\"` in the stream's onMetaData packet. If set to 'on', ATC is enabled when this metadata is detected. If 'off' (default), the onMetaData packet related to ATC is ignored.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG to Copy Both Video and Audio in SRS\nDESCRIPTION: Configuration example showing how to set up FFMPEG to copy both video and audio streams without transcoding. This acts similar to a forward operation, simply remuxing the content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          copy;\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server in Bash\nDESCRIPTION: Command to start the SRS server using the default configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Edge Server with Origin Reference\nDESCRIPTION: This snippet shows how to configure an edge server in SRS, specifying the origin server's address. It includes settings for the listening port, PID file, log file, and cluster configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/edge.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 objs/edge.pid;\nsrs_log_file        ./objs/edge.log;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Status Codes in HTTP/1.1\nDESCRIPTION: Lists all the standard HTTP/1.1 status codes with references to their sections in the RFC. Status codes are grouped by their first digit which indicates the class of response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_34\n\nLANGUAGE: http\nCODE:\n```\nStatus-Code    =\n      \"100\"  ; Section 10.1.1: Continue\n    | \"101\"  ; Section 10.1.2: Switching Protocols\n    | \"200\"  ; Section 10.2.1: OK\n    | \"201\"  ; Section 10.2.2: Created\n    | \"202\"  ; Section 10.2.3: Accepted\n    | \"203\"  ; Section 10.2.4: Non-Authoritative Information\n    | \"204\"  ; Section 10.2.5: No Content\n    | \"205\"  ; Section 10.2.6: Reset Content\n    | \"206\"  ; Section 10.2.7: Partial Content\n    | \"300\"  ; Section 10.3.1: Multiple Choices\n    | \"301\"  ; Section 10.3.2: Moved Permanently\n    | \"302\"  ; Section 10.3.3: Found\n    | \"303\"  ; Section 10.3.4: See Other\n    | \"304\"  ; Section 10.3.5: Not Modified\n    | \"305\"  ; Section 10.3.6: Use Proxy\n    | \"307\"  ; Section 10.3.8: Temporary Redirect\n    | \"400\"  ; Section 10.4.1: Bad Request\n    | \"401\"  ; Section 10.4.2: Unauthorized\n    | \"402\"  ; Section 10.4.3: Payment Required\n    | \"403\"  ; Section 10.4.4: Forbidden\n    | \"404\"  ; Section 10.4.5: Not Found\n    | \"405\"  ; Section 10.4.6: Method Not Allowed\n    | \"406\"  ; Section 10.4.7: Not Acceptable\n    | \"407\"  ; Section 10.4.8: Proxy Authentication Required\n    | \"408\"  ; Section 10.4.9: Request Time-out\n    | \"409\"  ; Section 10.4.10: Conflict\n    | \"410\"  ; Section 10.4.11: Gone\n    | \"411\"  ; Section 10.4.12: Length Required\n    | \"412\"  ; Section 10.4.13: Precondition Failed\n    | \"413\"  ; Section 10.4.14: Request Entity Too Large\n    | \"414\"  ; Section 10.4.15: Request-URI Too Large\n    | \"415\"  ; Section 10.4.16: Unsupported Media Type\n    | \"416\"  ; Section 10.4.17: Requested range not satisfiable\n    | \"417\"  ; Section 10.4.18: Expectation Failed\n    | \"500\"  ; Section 10.5.1: Internal Server Error\n    | \"501\"  ; Section 10.5.2: Not Implemented\n    | \"502\"  ; Section 10.5.3: Bad Gateway\n    | \"503\"  ; Section 10.5.4: Service Unavailable\n    | \"504\"  ; Section 10.5.5: Gateway Time-out\n    | \"505\"  ; Section 10.5.6: HTTP Version not supported\n    | extension-code\n\nextension-code = 3DIGIT\nReason-Phrase  = *<TEXT, excluding CR, LF>\n```\n\n----------------------------------------\n\nTITLE: Accessing HLS m3u8 Playlist over HTTP (Bash)\nDESCRIPTION: This snippet demonstrates how to access a sample HLS m3u8 playlist URL via HTTP, which is the endpoint served by SRS for HLS streams. No external dependencies are required to access this URL, but you must have a configured SRS server delivering live streams at this endpoint. This URL is intended as input for players or browsers that support HTTP Live Streaming (HLS); the output is the m3u8 playlist file served by SRS for clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhttp://demo.srs.com/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFMPEG\nDESCRIPTION: A continuous loop script that uses FFMPEG to publish a video stream to the SRS server. The command reads from a source file and streams it to the RTMP endpoint on the configured server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Running SRS with HTTP Callbacks\nDESCRIPTION: Command to start SRS server with HTTP callback configuration enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.hooks.callback.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS\nDESCRIPTION: FFmpeg command to publish a video stream to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Network Interface IP Detection Commands\nDESCRIPTION: Shell commands for retrieving network interface IP addresses on different operating systems for WebRTC candidate configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\nCANDIDATE=$(ifconfig en0 inet| grep 'inet '|awk '{print $2}')\n\n# For CentOS\nCANDIDATE=$(ifconfig eth0|grep 'inet '|awk '{print $2}')\n\n# Directly set ip.\nCANDIDATE=\"192.168.3.10\"\n```\n\n----------------------------------------\n\nTITLE: Grep for Published Streams in SRS Log - Bash\nDESCRIPTION: This Bash snippet filters the SRS log for successful stream publication events by searching for log lines with 'identify client success. type=publish'. It builds upon previous filtering steps to narrow down sessions of interest, helpful for identifying when and by whom streams have been published. The command requires the SRS log file and standard grep implementation; key parameters are the target string and possibly the stream name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n43:[2014-04-04 11:56:18.138][trace][105][11] identify client success. type=publish, stream_name=winlin\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode for SRS Upnode Connections\nDESCRIPTION: Controls whether to collect debug information from upnode connections (forward, edge push, edge pull). When enabled, SRS will collect diagnostic information such as ID, source ID, and PID from connected SRS instances.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    # when upnode(forward to, edge push to, edge pull from) is srs,\n    # it's strongly recommend to open the debug_srs_upnode,\n    # when connect to upnode, it will take the debug info, \n    # for example, the id, source id, pid.\n    # please see https://ossrs.io/lts/en-us/docs/v4/doc/log\n    # default: on\n    debug_srs_upnode    on;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FMLE for Publishing to Master SRS (Plaintext)\nDESCRIPTION: Provides the necessary settings for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the master SRS server. The FMS URL should be set to `rtmp://192.168.1.170/live` and the Stream name should be `livestream`. Replace `192.168.1.170` with the actual master server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Running pprof Manually for GPERF Heap Analysis in Bash\nDESCRIPTION: Provides the `pprof` command suggested by gmc when symbol resolution fails in the initial report. This command manually invokes `pprof` to analyze the heap dump file (`/tmp/srs.11469._main_-end.heap`) generated by gmc, specifying options for object view, line numbers, and filtering. The `--gv` option is often removed for interactive use as shown in the text.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npprof ./objs/srs \"/tmp/srs.11469._main_-end.heap\" --inuse_objects --lines --heapcheck  --edgefraction=1e-10 --nodefraction=1e-10 --gv\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Using Local FFmpeg\nDESCRIPTION: Command to publish stream using locally installed FFmpeg to SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Checking System File Descriptor Limits\nDESCRIPTION: Command to view the current system file descriptor limits after setting them to 10240.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Running FFmpeg with HEVC encoding in Docker\nDESCRIPTION: Uses the ossrs/srs:encoder Docker image to encode video to HEVC format and stream it over RTMP. This pre-built container has FFmpeg configured with libx265 support for HEVC streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --net host \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n    ffmpeg -re -i doc/source.flv -acodec copy -vcodec libx265 \\\n      -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Starting the Master SRS Instance\nDESCRIPTION: This command starts the master SRS server using the configuration file specified by the '-c' flag. It points to the 'forward.master.conf' file created or provided in the previous step.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\n./objs/srs -c conf/forward.master.conf\n```\n\n----------------------------------------\n\nTITLE: Building and Running SRS with Google Memory Profiler (GMP)\nDESCRIPTION: Commands to build SRS with Google Memory Profiler, run it, and analyze memory performance. GMP helps identify memory usage patterns and inefficiencies.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GMP\n./configure --gperf=on --gmp=on && make\n\n# Start SRS with GMP\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop gmp\nkillall -2 srs \n\n# To analysis memory profile\n./objs/pprof --text objs/srs gperf.srs.gmp*\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration File\nDESCRIPTION: SRS server configuration with maximum connections and forward settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    gop_cache       on;\n    forward         127.0.0.1:19350;\n}\n```\n\n----------------------------------------\n\nTITLE: Playing SRT Stream Using FFplay\nDESCRIPTION: Uses FFplay to play a stream from SRS server using SRT protocol\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Ubuntu Docker Setup for ARMv8 Cross-Compilation\nDESCRIPTION: Docker command to set up an Ubuntu 20 environment for cross-compiling SRS for ARMv8/aarch64 architecture, mounting the SRS directory for access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk\ndocker run --rm -it -v `pwd`:/srs -w /srs \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:ubuntu20 bash\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP-Version Format in BNF\nDESCRIPTION: Specifies the format for HTTP version numbers using Backus-Naur Form (BNF) notation. It defines the structure as 'HTTP' followed by a forward slash and version numbers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_5\n\nLANGUAGE: BNF\nCODE:\n```\nHTTP-Version   = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n```\n\n----------------------------------------\n\nTITLE: Performing Rolling Update of SRS Edge Deployment Image in Kubernetes\nDESCRIPTION: This Bash command initiates a rolling update for the Kubernetes Deployment named `srs-edge-deploy`. It updates the container named `srs` to use the new image `ossrs/srs:v4.0.6`. The `--record` flag annotates the deployment revision with the executed command, which is useful for tracking changes and facilitating rollbacks. Kubernetes will replace the old pods with new ones incrementally, respecting the graceful shutdown configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nkubectl set image deploy/srs-edge-deploy srs=ossrs/srs:v4.0.6 --record\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Servers\nDESCRIPTION: Commands to start the two origin servers and the edge server using the previously created configuration files. Each server is started in the background.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.cluster.serverA.conf &\n./objs/srs -c conf/origin.cluster.serverB.conf &\n./objs/srs -c conf/origin.cluster.edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Building SRS for ARM using Docker\nDESCRIPTION: Docker command to build SRS for ARM architecture using an aarch64 Docker image. This method allows cross-compilation on non-ARM systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \\\n    bash -c \"./configure && make\"\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC Auto Detection\nDESCRIPTION: Controls automatic ATC (Adobe Time Code) detection based on metadata packets.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_10\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for ARMv8/aarch64 Platforms\nDESCRIPTION: Configuration command for platforms like Loongson and Kunpeng that might not be automatically detected, using extra flags to specify ARMv8 architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --extra-flags='-D__aarch64__' && make\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository with Git\nDESCRIPTION: Commands to fetch the SRS source code from GitHub repository. This is the first step in deploying SRS for DASH streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-dash.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Defining Kubernetes ConfigMap for SRS Edge Configuration (YAML)\nDESCRIPTION: This YAML snippet defines a Kubernetes ConfigMap named `srs-edge-config`. It contains the `srs.conf` configuration file for an SRS edge server, setting parameters like listen ports (1935, 1985, 8080), connection limits, daemon mode off, graceful shutdown timings (`grace_start_wait`, `grace_final_wait`), forcing graceful quit on SIGTERM (`force_grace_quit`), enabling HTTP API and HTTP server, and configuring cluster mode to connect to origin servers (`srs-origin-*.socs`) via their headless service names. This configuration is crucial for enabling zero-downtime updates by allowing SRS to handle shutdown signals gracefully.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: srs-edge-config\ndata:\n  srs.conf: |-\n    listen              1935;\n    max_connections     1000;\n    daemon              off;\n    grace_start_wait    700;\n    grace_final_wait    800;\n    force_grace_quit    on;\n    http_api {\n        enabled         on;\n        listen          1985;\n    }\n    http_server {\n        enabled         on;\n        listen          8080;\n    }\n    vhost __defaultVhost__ {\n        cluster {\n            mode            remote;\n            origin          srs-origin-0.socs srs-origin-1.socs srs-origin-2.socs;\n        }\n        http_remux {\n            enabled     on;\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Defining Authorization Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax of the Authorization header field in HTTP/1.1. This header is used by a user agent to authenticate itself with a server, typically after receiving a 401 response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_55\n\nLANGUAGE: plaintext\nCODE:\n```\nAuthorization  = \"Authorization\" \":\" credentials\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx with Docker for Video Translation Services\nDESCRIPTION: Docker command to deploy Oryx with persistent storage and appropriate port mapping. This creates a containerized instance of Oryx version 5 with all necessary services for video translation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-02-21-Dubbing-Translating.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Finding Upnode Server Logs\nDESCRIPTION: Demonstrates finding logs for the upstream server connection using PID and session ID.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngrep -ina \"\\[12633\\]\\[141\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Publishing Test Stream with FFmpeg Docker\nDESCRIPTION: Docker command to run FFmpeg and publish a test stream to SRS. This command loops a source video and publishes it via RTMP to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg in Bash\nDESCRIPTION: This bash script uses FFmpeg to continuously publish a stream to SRS, restarting after each iteration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Go HTTP Callback Handler Implementation\nDESCRIPTION: Example Go code implementing an HTTP handler for SRS callbacks, specifically handling the on_publish event with JSON response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nhttp.HandleFunc(\"/api/v1/streams\", func(w http.ResponseWriter, r *http.Request) {\n    b, err := ioutil.ReadAll(r.Body)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n\n    fmt.Println(string(b))\n\n    res, err := json.Marshal(struct {\n        Code int `json:\"code\"`\n        Message string `json:\"msg\"`\n    }{\n        0, \"OK\",\n    })\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n    w.Write(res)\n})\n\n_ = http.ListenAndServe(\":8085\", nil)\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code using Git (Bash)\nDESCRIPTION: Pulls the latest changes from the remote repository for an existing local SRS clone. Assumes the user is already in the `srs/trunk` directory. Requires Git.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Starting SRS With Custom Snapshot Configuration (Bash)\nDESCRIPTION: This Bash snippet shows how to start the SRS server with a custom configuration file (snapshot.conf) to activate the previously defined HTTP callbacks and ingest pipeline. Assumes snapshot.conf is in the current directory and SRS has been built with correct binary paths. Input: none; Output: SRS RTMP ingest and event handling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/snapshot.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c snapshot.conf\n```\n\n----------------------------------------\n\nTITLE: Monitoring System Resource Usage with 'top' - Shell\nDESCRIPTION: Demonstrates capturing live system statistics using the 'top' utility under a streaming server load. Provides detailed outputs including CPU, memory, and process details revealing SRS and load-testing tool resource consumption. Inputs are runtime system metrics; output is tabular process and system statistics. Requires access to a Linux shell and the 'top' utility.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_19\n\nLANGUAGE: shell\nCODE:\n```\ntop - 19:52:35 up 1 day, 11:11,  8 users,  load average: 1.20, 1.05, 0.92\nTasks: 171 total,   4 running, 167 sleeping,   0 stopped,   0 zombie\nCpu0  : 26.0%us, 23.0%sy,  0.0%ni, 34.0%id,  0.3%wa,  0.0%hi, 16.7%si,  0.0%st\nCpu1  : 26.4%us, 20.4%sy,  0.0%ni, 34.1%id,  0.7%wa,  0.0%hi, 18.4%si,  0.0%st\nCpu2  : 22.5%us, 15.4%sy,  0.0%ni, 45.3%id,  1.0%wa,  0.0%hi, 15.8%si,  0.0%st\nMem:   2055440k total,  1972196k used,    83244k free,   136836k buffers\nSwap:  2064376k total,     3184k used,  2061192k free,   926124k cached\n\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                          \n17034 root      20   0  415m 151m 2040 R 94.4  7.6  14:29.33 ./objs/srs -c console.conf                                                        \n 1063 winlin    20   0  131m  68m 1336 S 17.9  3.4  54:05.77 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1011 winlin    20   0  132m  68m 1336 R 17.6  3.4  54:45.53 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18736 winlin    20   0  113m  48m 1336 S 17.6  2.4   1:37.96 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1051 winlin    20   0  131m  68m 1336 S 16.9  3.4  53:25.04 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18739 winlin    20   0  104m  39m 1336 R 15.6  2.0   1:25.71 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream   \n```\n\n----------------------------------------\n\nTITLE: Running SRS Media Server with Docker\nDESCRIPTION: Command to run an SRS media server using Docker. This sets up the server on ports 1935 (RTMP) and 8080 (HTTP) using the SRS 6 Docker image and a default configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:6 \\\n    ./objs/srs -c conf/docker.conf\n```\n\n----------------------------------------\n\nTITLE: JSON Response for Dynamic Forward\nDESCRIPTION: Example JSON response from the backend server that specifies where SRS should forward the stream. The response includes an array of RTMP URLs to which SRS will forward the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"code\": 0,\n   \"data\": {\n       \"urls\":[\n          \"rtmp://127.0.0.1:19350/test/teststream\"\n       ]\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin and Edge Servers (Bash)\nDESCRIPTION: These commands start the two SRS origin servers (A and B) and the SRS edge server using their respective configuration files. The `-c` flag specifies the configuration file, and the `&` runs each server process in the background.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.cluster.serverA.conf &\n./objs/srs -c conf/origin.cluster.serverB.conf &\n./objs/srs -c conf/origin.cluster.edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Logrotate with SIGUSR1\nDESCRIPTION: Configuration for logrotate to manage SRS log files using SIGUSR1 signal method. Includes daily rotation, compression, and retention settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log-rotate.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    sharedscripts\n    postrotate\n        kill -USR1 `cat /usr/local/srs/objs/srs.pid`\n    endscript\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Triggering Log Rotation in SRS via Unix Signal - Shell\nDESCRIPTION: This code sends a SIGUSR1 signal to all running 'killall' processes, instructing SRS to close and reopen its log file descriptor. Used in conjunction with log file movement to enable safe log rotation. Requires SRS server to be running with the relevant PID. No parameters except the signal; output is that SRS continues logging to a new file. Must be run after moving the old log file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/log-rotate.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nkillall -s SIGUSR1\n```\n\n----------------------------------------\n\nTITLE: Checking System File Descriptor Limits in Linux\nDESCRIPTION: Command to view the current file descriptor limits set for the system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: Bash loop script that uses FFmpeg to repeatedly publish a source video file to the SRS server. The script copies the original codecs and streams to RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-transcode-to-hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring Tool Logs in SRS\nDESCRIPTION: Configuration option for specifying where external tool logs (like FFMPEG used for transcoding/ingest) should be stored, with the option to disable them completely.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# the logs dir.\n# if enabled ffmpeg, each stracoding stream will create a log file.\n# \"/dev/null\" to disable the log.\n# default: ./objs\nff_log_dir          ./objs;\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Media Type Parameter Syntax using ABNF\nDESCRIPTION: Defines the attribute-value pair structure for parameters that can follow the main media type/subtype definition in HTTP/1.0 (RFC 1945, Section 3.6). An attribute is a token, and its value can be either a token or a quoted string.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_12\n\nLANGUAGE: abnf\nCODE:\n```\n    parameter      = attribute \"=\" value\n    attribute      = token\n    value          = token | quoted-string\n```\n\n----------------------------------------\n\nTITLE: Installing Cross-Compilation Toolchain for ARMv7\nDESCRIPTION: Command to install the required cross-compilation tools for ARMv7 architecture in Ubuntu.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for RTMP Streaming\nDESCRIPTION: This command runs an SRS Docker container, exposing port 1935 for RTMP streaming and using the rtmp.conf configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  ./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Linking SRS init.d script to system services\nDESCRIPTION: Command to create a symbolic link from the installed SRS init.d script to the system's init.d directory to enable service management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo ln -sf \\\n    /usr/local/srs/etc/init.d/srs \\\n    /etc/init.d/srs\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Status-Line Format in HTTP/1.1\nDESCRIPTION: Specifies the format of the Status-Line in HTTP/1.1 responses, consisting of the protocol version, status code, and reason phrase separated by spaces and ending with CRLF.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_33\n\nLANGUAGE: http\nCODE:\n```\nStatus-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n```\n\n----------------------------------------\n\nTITLE: Starting 500 srs-bench Clients for Nginx Test (Bash)\nDESCRIPTION: Runs the `srs-bench` tool (`sb_rtmp_load`) to simulate 500 concurrent RTMP clients connecting to the nginx-rtmp server (port 19350). The command is run in the background (`&`), and output is redirected to `/dev/null`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 500 -r rtmp://127.0.0.1:19350/live/livestream >/dev/null &\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS GitHub repository to start the build process. Also includes an alternative command for updating existing code via git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Enabling TCP NoDelay in SRS YAML\nDESCRIPTION: Enables the TCP_NODELAY option for socket connections. This can reduce network latency by disabling Nagle's algorithm.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Minimal Send Interval for SRS Playback\nDESCRIPTION: Configures the minimum interval in milliseconds between sending packets to playback clients (RTMP, HTTP-FLV, etc.). This can be used to control stream smoothness for devices requiring constant packet intervals. Setting it to 0 disables this feature, while a value greater than 0 enforces sending packets one by one at the specified interval.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # the minimal packets send interval in ms,\n        # used to control the ndiff of stream by srs_rtmp_dump,\n        # for example, some device can only accept some stream which\n        # delivery packets in constant interval(not cbr).\n        # @remark 0 to disable the minimal interval.\n        # @remark >0 to make the srs to send message one by one.\n        # @remark user can get the right packets interval in ms by srs_rtmp_dump.\n        # default: 0\n        send_min_interval       10.0;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Media Tag Format\nDESCRIPTION: Format specification for EXT-X-MEDIA tag used to relate Media Playlists containing alternative renditions\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_11\n\nLANGUAGE: plaintext\nCODE:\n```\n#EXT-X-MEDIA:<attribute-list>\n```\n\n----------------------------------------\n\nTITLE: Moving and Archiving SRS Log File - Shell\nDESCRIPTION: This snippet moves the active SRS log file to a temporary location named with a timestamp, allowing safe archiving or deletion before log rotation. It requires shell access and that SRS is running. The key parameter is the log file path, and the command expects the parent directories to exist. Output is a new file in /tmp with a current timestamp. Limitations: does not trigger SRS to reopen the log file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/log-rotate.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nmv objs/srs.log /tmp/srs.`date +%s`.log\n```\n\n----------------------------------------\n\nTITLE: Building and Running SRS with Google Memory Debugger (GMD)\nDESCRIPTION: Commands to build SRS with Google Memory Debugger and run it with page fence protection. GMD helps detect memory corruption issues like buffer overflows.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GMD.\n./configure --gperf=on --gmd=on && make\n\n# Start SRS with GMD.\nenv TCMALLOC_PAGE_FENCE=1 ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Executing HTTP API Request with curl in Bash\nDESCRIPTION: This snippet demonstrates how to make a simple HTTP API request to Oryx using curl in Bash. It shows both an unauthenticated request and an authenticated request using a Bearer token.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/mgmt/versions\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/hooks/srs/secret/query \\\n  -X POST -H 'Authorization: Bearer xxxxxx' \\\n  -H 'Content-Type: application/json' --data '{}'\n```\n\n----------------------------------------\n\nTITLE: Testing WHIP HTTP API with curl\nDESCRIPTION: This curl command tests the WHIP HTTP API by sending a POST request with SDP data. It can be used to troubleshoot connection issues with the WHIP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:1985/rtc/v1/whip/?ice-ufrag=6pk11386&ice-pwd=l91z529147ri9163933p51c4&app=live&stream=livestream-$(date +%s)\" \\\n  -H 'Origin: http://localhost' -H 'Referer: http://localhost' \\\n  -H 'Accept: */*' -H 'Content-type: application/sdp' \\\n  -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)' \\\n  --data-raw $'v=0\\r\\na=group:BUNDLE 0 1\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:0\\r\\na=sendonly\\r\\na=msid:- audio\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\na=ssrc:3184534672 cname:stream\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 106\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:1\\r\\na=sendonly\\r\\na=msid:- video\\r\\na=rtcp-mux\\r\\na=rtpmap:106 H264/90000\\r\\na=ssrc:512761356 cname:stream' \\\n  -v -k\n```\n\n----------------------------------------\n\nTITLE: Cloning and Switching Remote for SRS Repository via GitLab - Bash\nDESCRIPTION: Clones the SRS repository from the GitLab mirror into a directory named 'srs', then resets the git remote origin to GitHub and pulls the latest changes. Recommended for users with better access to GitLab and who need to sync from GitHub. Requires Git, network access to GitLab and GitHub, and sufficient local storage. Inputs: explicit destination directory 'srs'. Outputs: SRS source code in the 'srs' folder.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/resource.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitlab.com/winlinvip/srs-gitlab.git srs &&\\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: FFmpeg command to publish a stream to SRS origin server in a continuous loop.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: CPU Profiling with GPERF GCP\nDESCRIPTION: Shows how to build and run SRS with Google's CPU Profiler (GCP) and analyze the resulting CPU profile.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GCP\n./configure --gperf=on --gcp=on && make\n\n# Start SRS with GCP\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop GCP\nkillall -2 srs\n\n# To analysis cpu profile\n./objs/pprof --text objs/srs gperf.srs.gcp*\n```\n\n----------------------------------------\n\nTITLE: Building libx264 from source\nDESCRIPTION: Builds the libx264 library from source code, which is a prerequisite for compiling FFmpeg with H.264 support. The configuration disables assembly optimizations, CLI tools, and shared libraries for a static build.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://code.videolan.org/videolan/x264.git ~/git/x264\ncd ~/git/x264\n./configure --prefix=$(pwd)/build --disable-asm --disable-cli --disable-shared --enable-static\nmake -j10\nmake install\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARM in Bash\nDESCRIPTION: Commands to configure and build SRS for ARM architecture using cross-compilation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build && make\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS server repository from GitHub.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Starting 500 RTMP Load Test Clients for NginxRTMP\nDESCRIPTION: Command to start 500 RTMP client connections for load testing NginxRTMP. The command initiates client connections to the specified RTMP endpoint and redirects output to /dev/null.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 500 -r rtmp://127.0.0.1:19350/live/livestream >/dev/null &\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server with HTTPS for WebRTC in Bash\nDESCRIPTION: Command to start the SRS server with HTTPS configuration for WebRTC support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/https.rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Upgrading Oryx Docker Container\nDESCRIPTION: Commands to upgrade Oryx by removing old container and running new version with proper port mappings and volume mounts\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker rm oryx\ndocker pull registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Creating Oryx Instance using Docker\nDESCRIPTION: Docker command to create an Oryx instance that will serve as the foundation for the voice-driven GPT AI assistant. This command sets up the necessary ports and volumes for the Oryx service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2024-01-31-Browser-Voice-Driven-GPT.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Flash Media Live Encoder (FMLE) configuration settings for stream publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: FFProbe Command for RTMP Stream Analysis\nDESCRIPTION: Command to analyze and display information about an RTMP stream, including its metadata, video and audio stream details, and encoding properties.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n    [root@encoder1 ~]# ffprobe rtmp://xxx:1935/live/xxx:1234\n    Input #0, flv, from 'rtmp://xxx:1935/live/xxx:1234':\n      Metadata:\n        service_name    : Channel 1\n        service_provider: PBS\n        encoder         : Lavf57.24.100\n        server          : SRS/2.0.209(ZhouGuowen)\n        srs_primary     : SRS/1.0release\n        srs_authors     : winlin,wenjie.zhao\n        server_version  : 2.0.209\n      Duration: N/A, start: 0.010000, bitrate: N/A\n        Stream #0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 128 kb/s\n        Stream #0:1: Video: h264 (High), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 1k tbn\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: This command sequence configures the SRS build environment using the default settings and then compiles the source code using 'make'. This prepares the SRS executable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Using FFmpeg Local Install\nDESCRIPTION: Uses locally installed FFmpeg to publish a video stream to SRS server\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback: on_unpublish Event - JSON\nDESCRIPTION: Specifies the request and response format for the 'on_unpublish' HTTP callback, triggered when a live stream is stopped. The request body includes identifying fields for the stream to be unpublished, while the response should acknowledge receipt with code 0. Errors in response are ignored by Oryx.\n\nInputs: All key fields in the request are required. Output: {\"code\": 0} for acknowledgment. No authentication is specified.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"request_id\": \"9ea987fa-1563-4c28-8c6c-a0e9edd4f536\",\n  \"action\": \"on_unpublish\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Tracing Edge Session Details in SRS\nDESCRIPTION: Example of tracing specific edge session details using session ID\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[108\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Posting WebRTC Play Request via WHEP - HTTP Request/SDP Exchange - text\nDESCRIPTION: This snippet illustrates the HTTP POST request to initiate a pull (play) session from SRS using the WHEP protocol. Like WHIP, the request carries an SDP offer in 'application/sdp' format. Ensure SRS supports WHEP, and proper stream and query parameters are set. The returned response will be an SDP answer.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-api.md#2025-04-23_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whep/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\n----------------------------------------\n\nTITLE: Creating Oryx Instance with Docker\nDESCRIPTION: This command creates an Oryx instance using Docker, mapping necessary ports and volumes for live streaming functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-09-09-Oryx-Multi-Platform-Streaming.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 80:2022 -p 443:2443 -p 1935:1935 \\\n  -p 8080:8080 -p 8000:8000/udp -p 10080:10080/udp --name oryx \\\n  -v $HOME/data:/data registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Publishing FLV Stream to Master SRS using FFMPEG (Bash)\nDESCRIPTION: Uses FFMPEG within an infinite loop to repeatedly publish a local FLV file (`./doc/source.flv`) as an RTMP stream to the master SRS server at `rtmp://192.168.1.170/live/livestream`. The `-re` flag simulates a real-time stream source, `-c copy` streams the content without re-encoding, and `sleep 1` pauses for 1 second between publishing attempts. Requires FFMPEG and the specified source file. Replace `192.168.1.170` with the actual master server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Building SRS in Ubuntu20 Docker for Cross-Compilation - Shell\nDESCRIPTION: This sequence of shell commands enters an Ubuntu 20 Docker container, mounts the SRS source from the host, and opens a bash prompt for further operations (like building or installing dependencies). It assumes the SRS source is cloned to ~/git/srs/trunk. Docker must be installed and the ossrs/srs:ubuntu20 image available. This prepares an environment for cross-building SRS for various ARM targets.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n```\ncd ~/git/srs/trunk\ndocker run --rm -it -v `pwd`:/srs -w /srs ossrs/srs:ubuntu20 bash\n```\n```\n\n----------------------------------------\n\nTITLE: Monitor RTMP Connections Count\nDESCRIPTION: Continuous monitoring script that counts the number of established RTMP connections on port 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/raspberrypi.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    srs_connections=`sudo netstat -anp|grep 1935|grep ESTABLISHED|wc -l`;  \\\n    echo \"srs_connections: $srs_connections\";  \\\n    sleep 5;  \ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring Token Traverse in SRS Edge Server\nDESCRIPTION: This configuration snippet shows how to set up token traverse authentication in an SRS edge server. It enables the edge mode and configures the origin server address along with token traverse.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/drm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19350;\n        token_traverse  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP RAW API Configuration\nDESCRIPTION: Configuration example for enabling HTTP RAW API which allows write operations like reloading configuration. The raw_api must be explicitly enabled to use these features.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nhttp_api {\n    enabled         on;\n    listen          1985;\n    raw_api {\n        enabled             on;\n        allow_reload        on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling HLS TS Floor Calculation in SRS\nDESCRIPTION: Controls the path generation algorithm for HLS TS files. When enabled, it uses floor(timestamp/hls_fragment) for the [timestamp] variable and an enhanced algorithm for segment deviation calculation. Recommended to set hls_segment>=2*gop when enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_6\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_ts_floor    off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Server IP Address for WebRTC Candidate in Bash\nDESCRIPTION: Commands to obtain the server's IP address using ifconfig for different operating systems and setting it as a CANDIDATE environment variable for SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\nCANDIDATE=$(ifconfig en0 inet| grep 'inet '|awk '{print $2}')\n\n# For CentOS\nCANDIDATE=$(ifconfig eth0|grep 'inet '|awk '{print $2}')\n\n# Directly set ip.\nCANDIDATE=\"192.168.3.10\"\n```\n\n----------------------------------------\n\nTITLE: API Server Logs for DVR Callbacks\nDESCRIPTION: Example log output showing the HTTP callback triggered when a DVR segment is created. The log shows the POST request with details about the recorded file including path and client information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_4\n\nLANGUAGE: log\nCODE:\n```\n[2015-01-03 15:25:48][trace] post to dvrs, req={\"action\":\"on_dvr\",\"client_id\":108,\"ip\":\"127.0.0.1\",\"vhost\":\"__defaultVhost__\",\"app\":\"live\",\"stream\":\"livestream\",\"cwd\":\"/home/winlin/git/srs/trunk\",\"file\":\"./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\"}\n[2015-01-03 15:25:48][trace] srs on_dvr: client id=108, ip=127.0.0.1, vhost=__defaultVhost__, app=live, stream=livestream, cwd=/home/winlin/git/srs/trunk, file=./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\n127.0.0.1 - - [03/Jan/2015:15:25:48] \"POST /api/v1/dvrs HTTP/1.1\" 200 1 \"\" \"SRS(Simple RTMP Server)2.0.88\"\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Repository using Git (Bash)\nDESCRIPTION: This command updates an existing local SRS repository cloned via Git by pulling the latest changes from the remote repository. It should be run from within the existing `srs/trunk` directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring logrotate for SRS using copytruncate (Not Recommended)\nDESCRIPTION: Presents an alternative `logrotate` configuration using the `copytruncate` directive instead of signaling the process. This method first copies the log file and then truncates the original file to zero size. It's **not recommended** because logs written by SRS between the copy and truncate operations might be lost. It's mentioned as a possible workaround for older SRS versions (like SRS2) or environments where sending SIGUSR1 is problematic, although SRS3 fully supports SIGUSR1.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    copytruncate\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using Kill Command\nDESCRIPTION: Demonstrates how to reload the SRS configuration using the kill command with signal 1 (SIGHUP). This method allows applying new configurations without restarting the server or disconnecting user connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reload.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkillall -1 srs\n```\n\n----------------------------------------\n\nTITLE: Running SRS on HiSilicon Board\nDESCRIPTION: Command to run the cross-compiled SRS binary on a HiSilicon board with the console configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: SRS Process CPU Monitoring\nDESCRIPTION: Command to monitor CPU usage of the SRS process using top command.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep srs|grep objs|awk '{print $2}'` && top -p $pid\n```\n\n----------------------------------------\n\nTITLE: Cloning and Preparing SRS Repository - Bash\nDESCRIPTION: This snippet provides Bash commands to clone the SRS repository from GitHub and navigate to the trunk directory. It is the first step in preparing the environment for building and configuring the SRS Origin Cluster. Dependencies include Git and Bash. The output is a local copy of the SRS code ready for compilation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Wireshark GB28181 Plugin for Media Packet Analysis\nDESCRIPTION: Lua script for Wireshark to enable analysis of GB28181 media packets. This plugin allows Wireshark to decode TCP/9000 data as RFC4571 format packets, making it easier to analyze GB28181 media streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gb28181.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk/research/wireshark\nmkdir -p ~/.local/lib/wireshark/plugins\nln -sf $(pwd)/gb28181.lua ~/.local/lib/wireshark/plugins/gb28181.lua\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration for Specific Process\nDESCRIPTION: This command sends a SIGHUP signal to a specific SRS process identified by its PID, triggering a configuration reload for that instance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/reload.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nkill -1 7635\n```\n\n----------------------------------------\n\nTITLE: Requesting HTTP API with curl in Bash\nDESCRIPTION: Example of how to use curl to make a basic HTTP API request to Oryx.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/mgmt/versions\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Message Body Format in BNF\nDESCRIPTION: BNF grammar specification for HTTP message body structure including transfer encoding handling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_22\n\nLANGUAGE: BNF\nCODE:\n```\nmessage-body = entity-body\n             | <entity-body encoded as per Transfer-Encoding>\n```\n\n----------------------------------------\n\nTITLE: Monitoring Resource Usage with top (Bash)\nDESCRIPTION: A complex shell command that identifies the process IDs (PIDs) of the SRS server, the Nginx worker process, and all running `sb_rtmp_load` processes. It then uses the `top` command with the `-p` option to monitor the resource usage (CPU, memory) of these specific processes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nsrs_pid=`ps aux|grep srs|grep conf|awk '{print $2}'`; \\\nnginx_pid=`ps aux|grep nginx|grep worker|awk '{print $2}'`; \\\nload_pids=`ps aux|grep objs|grep sb_rtmp_load|awk '{ORS=\",\";print $2}'`; \\\ntop -p $load_pids$srs_pid,$nginx_pid\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Flash Media Live Encoder (FMLE) configuration settings for stream publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Basic Stream Converter Flow\nDESCRIPTION: Illustrates the basic workflow of Stream Converter from client push to final delivery\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/streamer.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nClient ---PUSH--> Stream Converter --RTMP--> SRS --RTMP/FLV/HLS/WebRTC--> Clients\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS with GPERF support\nDESCRIPTION: Command to configure SRS with GPERF support for memory leak detection (gmc)\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --with-gperf --with-gmc\n```\n\n----------------------------------------\n\nTITLE: Recording Performance Data with PERF\nDESCRIPTION: Commands to record performance data for SRS and generate a report. This allows for detailed analysis of performance issues after they occur.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nperf record -p $(pidof srs)\n\n# Press CTRL+C after about 30s.\n\nperf report\n```\n\n----------------------------------------\n\nTITLE: Accessing WebRTC SDP Answer with Candidate Information in Bash\nDESCRIPTION: Example of an SDP answer containing a candidate entry, which shows the IP address and port that the client should connect to for WebRTC communication.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ntype: answer, sdp: v=0\na=candidate:0 1 udp 2130706431 192.168.3.6 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Testing UDP Connectivity with nc\nDESCRIPTION: This command uses netcat (nc) to send a UDP packet to the SRS WHIP server and checks the response. It's useful for testing UDP connectivity and server response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\necho -en \"\\x00\\x01\\x00\\x50\\x21\\x12\\xa4\\x42\\x74\\x79\\x6d\\x7a\\x41\\x51\\x2b\\x2f\\x4a\\x4b\\x77\\x52\\x00\\x06\\x00\\x0d\\x36\\x70\\x6b\\x31\\x31\\x33\\x38\\x36\\x3a\\x4a\\x38\\x58\\x37\\x00\\x00\\x00\\xc0\\x57\\x00\\x04\\x00\\x01\\x00\\x0a\\x80\\x2a\\x00\\x08\\xda\\xad\\x1d\\xce\\xe8\\x95\\x5a\\x83\\x00\\x24\\x00\\x04\\x6e\\x7f\\x1e\\xff\\x00\\x08\\x00\\x14\\x56\\x8f\\x1e\\x1e\\x4f\\x5f\\x17\\xf9\\x2e\\xa1\\xec\\xbd\\x51\\xd9\\xa2\\x27\\xe4\\xfd\\xda\\xb1\\x80\\x28\\x00\\x04\\x84\\xd3\\x5a\\x79\" \\\n  |nc -w 3 -u 127.0.0.1 8000 |od -Ax -c -t x1 |grep '000' && \\\n  echo \"Success\" || echo \"Failed\"\n```\n\n----------------------------------------\n\nTITLE: Stopping SRS via Init.d Script - Bash\nDESCRIPTION: Stops the SRS service using the init.d script. Requires service to be registered and '/etc/init.d/srs' script to be present. Outputs confirmation of service stop.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs stop\n```\n\n----------------------------------------\n\nTITLE: Starting SRS and NGINX Servers\nDESCRIPTION: Commands to start the NGINX edge server and SRS origin server with their respective configurations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-hls-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnginx -c $(pwd)/conf/hls.edge.conf\n./objs/srs -c conf/hls.origin.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring UDP Buffer Sizes for RTC in Bash\nDESCRIPTION: Commands to view and modify UDP buffer sizes to improve RTC performance. Shows how to check current values and increase them to 16MB.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# UDP200KB\nsysctl net.core.rmem_max\nsysctl net.core.rmem_default\nsysctl net.core.wmem_max\nsysctl net.core.wmem_default\n\n# 16MB\nsysctl net.core.rmem_max=16777216\nsysctl net.core.rmem_default=16777216\nsysctl net.core.wmem_max=16777216\nsysctl net.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 5.0 Development Branch (Bash)\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 5.0 development branch (develop).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/git.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout develop\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Codebase - Git - Bash\nDESCRIPTION: This command pulls the latest changes from the default Git remote for the existing SRS codebase. It assumes the user is already within the SRS project directory, and that Git is initialized. The operation synchronizes your repository with upstream developments without additional configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS codebase from GitHub repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Authentication Config\nDESCRIPTION: Command to start SRS server using the HTTP API authentication configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.api.auth.conf\n```\n\n----------------------------------------\n\nTITLE: Illustrating Browser-to-Browser WebRTC Communication Flow\nDESCRIPTION: ASCII diagram showing the basic WebRTC communication flow between two browsers, highlighting signaling and media paths.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +----------------+\n+    Browser     +----<--Signaling----->--+    Browser     +\n+ (like Chrome)  +----<----Media----->----+ (like Chrome)  +\n+----------------+                        +----------------+\n```\n\n----------------------------------------\n\nTITLE: Setting Candidate IP for WebRTC in SRS\nDESCRIPTION: This snippet demonstrates how to set the candidate IP for WebRTC in SRS using the ifconfig command and environment variables. It shows examples for both macOS and CentOS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# For macOS\nCANDIDATE=$(ifconfig en0 inet| grep 'inet '|awk '{print $2}')\n\n# For CentOS\nCANDIDATE=$(ifconfig eth0|grep 'inet '|awk '{print $2}')\n\n# Directly set ip.\nCANDIDATE=\"192.168.3.10\"\n```\n\n----------------------------------------\n\nTITLE: Running Multiple Oryx Instances\nDESCRIPTION: Docker commands to run multiple isolated Oryx instances with different port mappings\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx0 -it -v $HOME/data0:/data \\\n  -p 80:2022 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx1 -it -v $HOME/data1:/data \\\n  -p 2023:2022 -p 1936:1935 -p 8001:8000/udp -p 10081:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx1 -it -v $HOME/data1:/data \\\n  -p 2023:2022 -p 1936:1935 -p 8001:8000/udp -p 10081:10080/udp \\\n  -e HTTP_PORT=2023 -e RTMP_PORT=1936 -e RTC_PORT=8001 -e SRT_PORT=10081 \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: WebRTC TCP Basic Docker Configuration\nDESCRIPTION: Docker command to run SRS with basic WebRTC over TCP support using port 8080, sharing the port with HTTP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080/tcp \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_HTTP_API_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with HTTP FLV Configuration\nDESCRIPTION: Command to start SRS with the HTTP FLV push configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/streamer.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/push.flv.conf\n```\n\n----------------------------------------\n\nTITLE: Building FFmpeg with Patched HEVC/RTMP/FLV Support (v6+) - Bash\nDESCRIPTION: This batch demonstrates downloading FFmpeg's master branch, configuring it to use the user's own static builds of x264 and x265, and compiling FFmpeg with several codecs enabled. Notable configuration options include disabling various assembly optimizations for portability and enabling several AAC decoders/encoders. This script presumes previous builds of x264/x265 and properly set PKG_CONFIG_PATH. Outputs a statically built FFmpeg binary in the local directory; limitation: The script assumes x264/x265 are already available in the expected build folders.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b master https://github.com/FFmpeg/FFmpeg.git ~/git/FFmpeg\ncd ~/git/FFmpeg\nenv PKG_CONFIG_PATH=~/git/x264/build/lib/pkgconfig:~/git/x265_git/build/linux/build/lib/pkgconfig \\\n./configure \\\n  --prefix=$(pwd)/build \\\n  --enable-gpl --enable-nonfree --enable-pthreads --extra-libs=-lpthread \\\n  --disable-asm --disable-x86asm --disable-inline-asm \\\n  --enable-decoder=aac --enable-decoder=aac_fixed --enable-decoder=aac_latm --enable-encoder=aac \\\n  --enable-libx264 --enable-libx265 \\\n  --pkg-config-flags='--static'\nmake -j10\n```\n\n----------------------------------------\n\nTITLE: Visualizing Stream Flow in Proxy-Origin Architecture\nDESCRIPTION: Diagram showing how client streaming traffic flows through proxy servers to SRS origin servers in various deployment scenarios including Kubernetes Service integration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nClient ----> Proxy Server ---> Origin Servers\nClient ---> LB --> Proxy Servers --> Origin Servers\n\nOBS/FFmpeg --RTMP--> K8s(Service) --Proxy--> SRS(pod A)\n\nBrowsers --FLV/HLS/SRT--> K8s(Service) --Proxy--> SRS(pod A)\n\nBrowsers --+---HTTP-API--> K8s(Service) --Proxy--> SRS(pod A)\n           +---WebRTC----> K8s(Service) --Proxy--> SRS(pod A)\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Command to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Mounting RAM Disk for HLS Performance\nDESCRIPTION: Commands to create a RAM disk for storing HLS segments to improve performance by avoiding disk I/O operations, useful for high-concurrency scenarios.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p /ramdisk &&\nmount -o size=7G -t tmpfs none /ramdisk\n```\n\n----------------------------------------\n\nTITLE: Creating Oryx Instance Using Docker\nDESCRIPTION: This command runs an Oryx container exposing necessary ports for streaming services. It maps container ports to host ports and mounts a local directory for persistent data storage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-09-09-Oryx-Multi-Platform-Streaming.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 80:2022 -p 443:2443 -p 1935:1935 \\\n  -p 8080:8080 -p 8000:8000/udp -p 10080:10080/udp --name oryx \\\n  -v $HOME/data:/data ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG Log Verbosity in SRS Transcoding\nDESCRIPTION: Configuration example showing how to reduce FFMPEG log verbosity by setting the quiet parameter in the vfilter section. This reduces the size of log files generated during transcoding operations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n                # -v quiet\n                v           quiet;\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFMPEG Tool Support (Bash)\nDESCRIPTION: Configures the SRS build system to enable FFMPEG tool integration using the `--ffmpeg-tool=on` flag with the `configure` script, and then compiles the SRS server using `make`. This enables the transcoding functionality within SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: WHIP HTTP API Testing with cURL\nDESCRIPTION: cURL command to test WHIP HTTP/HTTPS API endpoint with SDP payload for WebRTC streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:1985/rtc/v1/whip/?ice-ufrag=6pk11386&ice-pwd=l91z529147ri9163933p51c4&app=live&stream=livestream-$(date +%s)\" \\\n  -H 'Origin: http://localhost' -H 'Referer: http://localhost' \\\n  -H 'Accept: */*' -H 'Content-type: application/sdp' \\\n  -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)' \\\n  --data-raw $'v=0\\r\\na=group:BUNDLE 0 1\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:0\\r\\na=sendonly\\r\\na=msid:- audio\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\na=ssrc:3184534672 cname:stream\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 106\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:1\\r\\na=sendonly\\r\\na=msid:- video\\r\\na=rtcp-mux\\r\\na=rtpmap:106 H264/90000\\r\\na=ssrc:512761356 cname:stream' \\\n  -v -k\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing\nDESCRIPTION: Command to publish a stream using FFMPEG in a continuous loop to the RTMP endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: SRS Connection Count Monitoring\nDESCRIPTION: Script to continuously monitor the number of established connections to SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/raspberrypi.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\n    srs_connections=`sudo netstat -anp|grep 1935|grep ESTABLISHED|wc -l`;  \\n    echo \"srs_connections: $srs_connections\";  \\n    sleep 5;  \\ndone\n```\n\n----------------------------------------\n\nTITLE: Adding SRS Service with chkconfig - Bash\nDESCRIPTION: Registers the SRS service with CentOS's chkconfig tool. Requires '/etc/init.d/srs' to exist. No parameters; enables SRS to start at boot time controlled by service management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n#centos 6\\nsudo /sbin/chkconfig --add srs\n```\n\n----------------------------------------\n\nTITLE: Example of WebRTC WHIP Protocol Request\nDESCRIPTION: Demonstrates how to publish a WebRTC stream to SRS using the WHIP protocol, showing the SDP exchange format between client and server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nPOST /rtc/v1/whip/?app=live&stream=livestream\n\nBody in SDP, the Content-type is application/sdp:\n\nv=0\n......\na=ssrc:2064016335 label:c8243ce9-ace5-4d17-9184-41a2543101b5\n```\n\n----------------------------------------\n\nTITLE: Configuring UTC Time Usage in SRS\nDESCRIPTION: Determines whether to use UTC time (gmtime()) or local time (localtime()) for generating time structures in SRS. This affects timestamp generation across the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_5\n\nLANGUAGE: nginx\nCODE:\n```\nutc_time            off;\n```\n\n----------------------------------------\n\nTITLE: Starting HLS Origin Servers\nDESCRIPTION: Commands to start multiple origin servers for HLS streaming using port reuse\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/reuse-port.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only1.conf\n```\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only2.conf\n```\n\n----------------------------------------\n\nTITLE: Setting HLS Dispose Timeout Configuration\nDESCRIPTION: Configuration for the HLS dispose timeout, which determines how long SRS waits before cleaning up HLS files after a stream ends.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hls.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_dispose 120;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback on_record_begin Event JSON Format\nDESCRIPTION: Demonstrates the JSON format for the on_record_begin event in HTTP callbacks, including request and response structures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_8\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"80ad1ddf-1731-450c-83ec-735ea79dd6a3\",\n  \"action\": \"on_record_begin\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\"\n}\n\nResponse:\n{\n\"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing RTMP Stream Publishing Logs in Bash\nDESCRIPTION: Example showing streaming connection logs for an RTMP publisher, including connection establishment, handshake, stream identification, and metadata handling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Installing ARMv7 Cross-Compilation Toolchain\nDESCRIPTION: Command to install ARMv7 cross-compilation tools in an Ubuntu environment. Different from aarch64, this targets 32-bit ARM architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Running SRS in Docker with Custom Candidate\nDESCRIPTION: Docker command to run SRS container with custom candidate IP and port mappings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.3.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Streaming Loop Command\nDESCRIPTION: Bash script to continuously stream a source video file using FFMPEG to an RTMP endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/raspberrypi.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\n    ./objs/ffmpeg/bin/ffmpeg \\n        -re -i doc/source.flv \\n        -acodec copy -vcodec copy \\n        -f flv rtmp://192.168.1.105:1935/live/livestream; \\n    sleep 1; \\ndone\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Configuration\nDESCRIPTION: Configuration example for enabling HTTP callbacks with DVR functionality\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/dvr.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    dvr {\n        enabled             on;\n        dvr_path            ./objs/nginx/html/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        dvr_plan            segment;\n        dvr_duration        30;\n        dvr_wait_keyframe   on;\n    }\n    http_hooks {\n        enabled         on;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream using FMLE\nDESCRIPTION: Configuration settings for publishing an RTMP stream using Flash Media Live Encoder (FMLE).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-rtmp-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Defining Cache-Control Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax and directives for the Cache-Control header field in HTTP/1.1. This header is used to specify directives that must be obeyed by all caching mechanisms along the request/response chain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_56\n\nLANGUAGE: plaintext\nCODE:\n```\nCache-Control   = \"Cache-Control\" \":\" 1#cache-directive\n\ncache-directive = cache-request-directive\n     | cache-response-directive\n\ncache-request-directive =\n       \"no-cache\"                          ; Section 14.9.1\n     | \"no-store\"                          ; Section 14.9.2\n     | \"max-age\" \"=\" delta-seconds         ; Section 14.9.3, 14.9.4\n     | \"max-stale\" [ \"=\" delta-seconds ]   ; Section 14.9.3\n     | \"min-fresh\" \"=\" delta-seconds       ; Section 14.9.3\n     | \"no-transform\"                      ; Section 14.9.5\n     | \"only-if-cached\"                    ; Section 14.9.4\n     | cache-extension                     ; Section 14.9.6\n\n cache-response-directive =\n       \"public\"                               ; Section 14.9.1\n     | \"private\" [ \"=\" <\"> 1#field-name <\"> ] ; Section 14.9.1\n     | \"no-cache\" [ \"=\" <\"> 1#field-name <\"> ]; Section 14.9.1\n     | \"no-store\"                             ; Section 14.9.2\n     | \"no-transform\"                         ; Section 14.9.5\n     | \"must-revalidate\"                      ; Section 14.9.4\n     | \"proxy-revalidate\"                     ; Section 14.9.4\n     | \"max-age\" \"=\" delta-seconds            ; Section 14.9.3\n     | \"s-maxage\" \"=\" delta-seconds           ; Section 14.9.3\n     | cache-extension                        ; Section 14.9.6\n\ncache-extension = token [ \"=\" ( token | quoted-string ) ]\n```\n\n----------------------------------------\n\nTITLE: Rolling Back SRS Edge Deployment to Previous Revision in Kubernetes\nDESCRIPTION: This command rolls back the SRS edge deployment to a specific revision number, in this case, revision 1.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nkubectl rollout undo deploy/srs-edge-deploy --to-revision=1\n```\n\n----------------------------------------\n\nTITLE: Testing Network Connectivity in Oryx Docker Container using Bash\nDESCRIPTION: This snippet shows how to use curl within the Oryx Docker container to test network connectivity to a target URL. It simulates an HTTP request to verify accessibility.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ndocker exec -it oryx curl http://your-target-URL\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Message Header Format in BNF\nDESCRIPTION: BNF grammar specification for HTTP message headers defining the structure of field names, values and content formatting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_21\n\nLANGUAGE: BNF\nCODE:\n```\nmessage-header = field-name \":\" [ field-value ]\nfield-name     = token\nfield-value    = *( field-content | LWS )\nfield-content  = <the OCTETs making up the field-value\n                 and consisting of either *TEXT or combinations\n                 of token, separators, and quoted-string>\n```\n\n----------------------------------------\n\nTITLE: System Resource Monitoring During 4k Client Test\nDESCRIPTION: Output of the 'top' command showing system resource usage during the 4k client performance test. Displays CPU, memory usage, and running processes including SRS and multiple instances of load generators.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ntop - 19:52:35 up 1 day, 11:11,  8 users,  load average: 1.20, 1.05, 0.92\nTasks: 171 total,   4 running, 167 sleeping,   0 stopped,   0 zombie\nCpu0  : 26.0%us, 23.0%sy,  0.0%ni, 34.0%id,  0.3%wa,  0.0%hi, 16.7%si,  0.0%st\nCpu1  : 26.4%us, 20.4%sy,  0.0%ni, 34.1%id,  0.7%wa,  0.0%hi, 18.4%si,  0.0%st\nCpu2  : 22.5%us, 15.4%sy,  0.0%ni, 45.3%id,  1.0%wa,  0.0%hi, 15.8%si,  0.0%st\nMem:   2055440k total,  1972196k used,    83244k free,   136836k buffers\nSwap:  2064376k total,     3184k used,  2061192k free,   926124k cached\n\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                          \n17034 root      20   0  415m 151m 2040 R 94.4  7.6  14:29.33 ./objs/srs -c console.conf                                                        \n 1063 winlin    20   0  131m  68m 1336 S 17.9  3.4  54:05.77 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1011 winlin    20   0  132m  68m 1336 R 17.6  3.4  54:45.53 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18736 winlin    20   0  113m  48m 1336 S 17.6  2.4   1:37.96 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1051 winlin    20   0  131m  68m 1336 S 16.9  3.4  53:25.04 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18739 winlin    20   0  104m  39m 1336 R 15.6  2.0   1:25.71 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Server with a Specific Configuration (Bash)\nDESCRIPTION: Executes the compiled SRS server binary (`./objs/srs`) using the specified configuration file (`conf/transcode2hls.audio.only.conf`) via the `-c` flag. This command starts the SRS server process, applying the settings defined in the configuration file, including the HLS and transcoding configurations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/transcode2hls.audio.only.conf\n```\n\n----------------------------------------\n\nTITLE: DVR Workflow Diagram Text\nDESCRIPTION: Ascii diagram showing the workflow of DVR from FFmpeg/OBS through SRS to FLV/MP4 file\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/dvr.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+------------+            +-------+           +---------------+\n+ FFmpeg/OBS +---RTMP-->--+  SRS  +---DVR-->--+ FLV/MP4 File  +\n+------------+            +-------+           +---------------+\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS - Bash\nDESCRIPTION: This Bash snippet runs SRS's configure script and Makefile to compile the source code. Dependencies: GNU build tools and compiler must be installed. Parameters: none. Outputs SRS binaries to the ./objs/ directory. Must be run in SRS source root.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Monitoring RTMP Connection Counts for Server Comparison\nDESCRIPTION: Bash script to count and compare the number of established connections between SRS and Nginx-RTMP servers. Uses netstat to identify ESTABLISHED connections to each server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\nsrs_connections=`netstat -anp|grep srs|grep ESTABLISHED|wc -l`; \\\nnginx_connections=`netstat -anp|grep nginx|grep ESTABLISHED|wc -l`; \\\necho \"srs_connections: $srs_connections\"; \\\necho \"nginx_connections: $nginx_connections\";\n```\n\n----------------------------------------\n\nTITLE: Moving HEVC file to SRS web server for testing\nDESCRIPTION: Creates a directory in the SRS web server path and moves the HEVC MP4 file there for testing playback through the SRS player interface.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/git/srs/trunk/objs/nginx/html/vod/\nmv source.hevc.mp4 ~/git/srs/trunk/objs/nginx/html/vod\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream with FFmpeg Docker\nDESCRIPTION: This command uses FFmpeg in a Docker container to publish an RTMP stream to the SRS server. It loops the source file and publishes it as a live stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback JSON Example - on_publish\nDESCRIPTION: Example JSON request and response format for the on_publish callback event\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"3ab26a09-59b0-42f7-98e3-a281c7d0712b\",\n  \"action\": \"on_publish\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"param\": \"?secret=8f7605d657c74d69b6b48f532c469bc9\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: NGINX-RTMP Build Configuration\nDESCRIPTION: Configure and build command for NGINX with RTMP module support and SSL module.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --prefix=`pwd`/../_release \\\n--add-module=`pwd`/../nginx-rtmp-module-1.0.4 \\\n--with-http_ssl_module && make && make install\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running RTMP Load Test Client (sb_rtmp_load) (bash)\nDESCRIPTION: Example compilation and execution for a custom RTMP load testing tool (srs-bench/sb_rtmp_load), simulating up to 800 RTMP clients per process for server stress testing. The '-c' flag controls number of clients; '-r' takes the RTMP URL.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 800 -r <rtmp_url>\n```\n\n----------------------------------------\n\nTITLE: Branch and Shallow Cloning SRS Repo via Gitee - Bash\nDESCRIPTION: These lines (appearing in the markdown table) are variant git clone commands that download specific branches and optionally with --depth=1 for shallow clone (only the latest commit and reduced size). They are useful for users who want only a subset of the project's history or a particular branch (e.g., '3.0release', 'develop', 'min'). Requires Git and correct branch names on remote. Inputs: cloning parameters. Outputs: local repo with reduced size and faster clone time based on depth and branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/resource.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 3.0release https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b 3.0release --depth=1 https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop --depth=1 https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b min https://gitee.com/ossrs/srs.git\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b min --depth=1 https://gitee.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server\nDESCRIPTION: Command to start the SRS server with a console configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Installation\nDESCRIPTION: Command to update an existing SRS installation using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS service\nDESCRIPTION: Command to reload the SRS service configuration without stopping the service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Service\nDESCRIPTION: Command to start the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Different Configurations - Bash\nDESCRIPTION: These command-line examples demonstrate how to start SRS with either a console or default configuration file. Inputs are the SRS binary path and chosen configuration file. Depending on the configuration, output will go to the console or to the log file, allowing for real-time monitoring during development or background operation in production. Prerequisite is a compiled SRS binary with configuration files properly set.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf \n```\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c conf/srs.conf \n[2014-04-14 12:12:57.775][trace][0][0] config parse complete\n[2014-04-14 12:12:57.775][trace][0][0] write log to file ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] you can: tailf ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] @see https://ossrs.io/lts/en-us/docs/v4/doc/log\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC Auto in SRS YAML\nDESCRIPTION: Enables automatic ATC (Absolute Timeline Clock) detection. When enabled, SRS will check for 'bravo_atc=\"true\"' in onMetaData packets and adjust ATC settings accordingly.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with FLV Configuration in Bash\nDESCRIPTION: Command to start SRS server with a configuration file for handling FLV streams pushed via HTTP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/streamer.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/push.flv.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with systemctl\nDESCRIPTION: Command to start the SRS service using systemctl for systems that use systemd.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start srs\n```\n\n----------------------------------------\n\nTITLE: Configuring HDS in SRS NGINX Configuration\nDESCRIPTION: NGINX configuration snippet for enabling and configuring HDS distribution in SRS. It includes settings for enabling HDS, fragment duration, window size, and storage path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/delivery-hds.md#2025-04-23_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hds {\n        # whether hds enabled\n        # default: off\n        enabled         on;\n        # the hds fragment in seconds.\n        # default: 10\n        hds_fragment    10;\n        # the hds window in seconds, erase the segment when exceed the window.\n        # default: 60\n        hds_window      60;\n        # the path to store the hds files.\n        # default: ./objs/nginx/html\n        hds_path        ./objs/nginx/html;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Copytruncate Logrotate Configuration for SRS\nDESCRIPTION: Alternative logrotate configuration using copytruncate method, suitable for SRS2 but not recommended due to potential log loss.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/log-rotate.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    copytruncate\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic ATC Detection in SRS\nDESCRIPTION: Configuration example for disabling automatic ATC detection in SRS. This prevents SRS from automatically enabling ATC mode when it detects the \"bravo_atc\"=\"true\" attribute in the metadata of incoming streams from encoders.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/rtmp-atc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost atc.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Secondary Edge Server\nDESCRIPTION: Command to start an additional SRS edge server on the same port 1935. Requires different PID file configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/reuse-port.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge2.conf\n```\n\n----------------------------------------\n\nTITLE: Basic Log Rotation Commands for SRS\nDESCRIPTION: Manual commands to rotate SRS log files by moving the current log file and sending SIGUSR1 signal to reopen log file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/log-rotate.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmv objs/srs.log /tmp/srs.`date +%s`.log\n```\n\nLANGUAGE: bash\nCODE:\n```\nkillall -s SIGUSR1\n```\n\n----------------------------------------\n\nTITLE: Playing SRT Stream with Local ffplay\nDESCRIPTION: Uses a locally installed ffplay instance to connect to the SRS server via SRT on `127.0.0.1:10080` and play the specified stream. The `streamid` parameter indicates the application (`live`), stream name (`livestream`), and mode (`request`). Requires ffplay installation with SRT support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Stream Mixing for Live Video Chat\nDESCRIPTION: Bash command using FFmpeg to combine two RTMP streams into a single output stream with picture-in-picture layout. This command takes two input streams, scales the second video to a smaller size, overlays it on the first video, and mixes the audio channels.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-06-30-Video-Chat-Live.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -f flv -i rtmp://your-server-ip/live/stream-a -f flv -i rtmp://your-server-ip/live/stream-b \\\n     -filter_complex \"[1:v]scale=w=96:h=72[ckout];[0:v][ckout]overlay=x=W-w-10:y=H-h-10[out]\" -map \"[out]\" \\\n     -c:v libx264 -profile:v high -preset medium \\\n     -filter_complex amix -c:a aac \\\n     -f flv -y rtmp://your-server-ip/live/merge\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC to RTMP Configuration\nDESCRIPTION: Docker command to run SRS with configuration that enables converting WebRTC streams to RTMP, allowing for stream mixing with external tools like FFmpeg.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc2rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: RTMP Publishing Parameters for FMLE - Text as Bash block\nDESCRIPTION: This snippet lists the RTMP publishing endpoint and stream name suitable for the Flash Media Live Encoder (FMLE). It is an example of simple configuration for software encoders to broadcast to the RTMP edge. Parameters: FMS URL (edge RTMP endpoint), Stream name. No runtime dependencies beyond FMLE or compatible RTMP publishing tool.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Default Video Codec Parameters for Subtitle Overlay\nDESCRIPTION: Default video codec parameters for FFmpeg when overlaying subtitles, using libx264 with main profile, medium preset, and zerolatency tuning.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n-c:v libx264 -profile:v main -preset:v medium -tune zerolatency -bf 0\n```\n\n----------------------------------------\n\nTITLE: Configuring HDS Delivery Settings in SRS\nDESCRIPTION: Virtual host configuration for HDS delivery including fragment duration, window size, and storage path settings\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/delivery-hds.md#2025-04-23_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hds {\n        # whether hds enabled\n        # default: off\n        enabled         on;\n        # the hds fragment in seconds.\n        # default: 10\n        hds_fragment    10;\n        # the hds window in seconds, erase the segment when exceed the window.\n        # default: 60\n        hds_window      60;\n        # the path to store the hds files.\n        # default: ./objs/nginx/html\n        hds_path        ./objs/nginx/html;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS WebRTC SDP Response Format\nDESCRIPTION: Example of a server response to a WebRTC WHIP request, providing the SDP information with ICE candidates for establishing the WebRTC connection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nv=0\n......\na=candidate:1 1 udp 2130706431 172.18.0.4 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Configuring Send Minimal Interval in SRS YAML\nDESCRIPTION: Sets the minimal packet send interval for play clients. This controls the stream delivery rate and can be used to maintain constant intervals for certain devices.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        send_min_interval       10.0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Command to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-realtime.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Time Generation (UTC vs Local)\nDESCRIPTION: Determines whether SRS uses UTC (Coordinated Universal Time) or the server's local time for internal time structures. If set to 'on', `gmtime()` (UTC) is used. If set to 'off' (default), `localtime()` is used.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n```\n# whether use utc_time to generate the time struct,\n# if off, use localtime() to generate it,\n# if on, use gmtime() instead, which use UTC time.\n# default: off\nutc_time            off;\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring logrotate with copytruncate for SRS2\nDESCRIPTION: Bash script to create a logrotate configuration file using copytruncate method for SRS2. This method is not recommended for SRS3 as it may result in log loss.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/log-rotate.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    copytruncate\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Protocol Example for on_publish\nDESCRIPTION: Example of the POST request format for the on_publish callback endpoint showing the JSON structure with server, client, and stream details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nPOST /api/v1/streams HTTP/1.1\nContent-Type: application-json\n\nBody:\n{\n  \"server_id\": \"vid-0xk989d\",\n  \"action\": \"on_publish\",\n  \"client_id\": \"341w361a\",\n  \"ip\": \"127.0.0.1\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"tcUrl\": \"rtmp://127.0.0.1:1935/live?vhost=__defaultVhost__\",\n  \"stream\": \"livestream\",\n  \"param\": \"\",\n  \"stream_url\": \"video.test.com/live/livestream\",\n  \"stream_id\": \"vid-124q9y3\"\n}\n```\n\n----------------------------------------\n\nTITLE: Setting CPU Affinity for SRS Process using taskset in Bash\nDESCRIPTION: These commands use `taskset` to control the CPU affinity of the SRS process. The first example uses a hexadecimal bitmask (`0xfe`) to assign the process identified by `pidof srs` to CPUs 1 through 7 (excluding CPU0). The second example uses `-pc 1` to pin the process to CPU 1 specifically. This is often done to isolate processes or avoid contention with kernel tasks like softirqs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -p 0xfe $(pidof srs)\n```\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -pc 1 $(pidof srs)\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code in Bash\nDESCRIPTION: Command to update an existing SRS codebase using Git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Streaming to SRS with FFmpeg\nDESCRIPTION: FFmpeg command to stream a local video file to SRS for testing. This can be used to verify a successful SRS installation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Enabling HDS during SRS Build (Shell)\nDESCRIPTION: This shell command is executed during the SRS configuration phase before compilation. It uses the `--hds=on` flag to explicitly enable HTTP Dynamic Streaming (HDS) functionality in the resulting SRS build. This step is necessary if HDS support is not enabled by default.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/delivery-hds.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./configure --hds=on\n```\n\n----------------------------------------\n\nTITLE: Edge Server Configuration\nDESCRIPTION: Configuration file for the edge server that pulls streams from origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.edge.conf\nlisten              1935;\nmax_connections     1000;\npid                 objs/edge.pid;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    cluster {\n        mode            remote;\n        origin          127.0.0.1:19351 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Directly Using the Binary\nDESCRIPTION: Command to start SRS by directly invoking the binary with a configuration file, providing an alternative to the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS for RTMP to WebRTC Conversion (Bash)\nDESCRIPTION: Starts the SRS server specifically configured for converting incoming RTMP live streams to WebRTC for playback. It uses the 'conf/rtmp2rtc.conf' configuration file and requires setting the 'CANDIDATE' environment variable to the server's external IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Reducing Sequence Headers in SRS\nDESCRIPTION: Controls whether to reduce duplicated sequence headers in the stream. This is useful for clients that cannot handle duplicated sequence headers, while the sequence header hasn't changed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_1\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether reduce the sequence header,\n        # for some client which cannot got duplicated sequence header,\n        # while the sequence header is not changed yet.\n        # default: off\n        reduce_sequence_header  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg in Bash\nDESCRIPTION: Bash script using FFmpeg to continuously publish a stream to SRS server for HLS conversion.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Extracting SRS Logs for a Specific Session ID using Grep in Bash\nDESCRIPTION: Explains how to extract all log entries related to a specific SRS session (identified by ID `104` in this example) from the `srs.log` file. It uses `grep` with a pattern `\\[104\\]\\[` that matches the session ID format within the log lines. This technique is crucial for debugging issues related to a single client connection or stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log |grep -ina \"\\[104\\]\\[\"\n14:[2014-04-04 11:56:06.074][trace][104][11] rtmp get peer ip success. ip=192.168.1.179, \nsend_to=30000000us, recv_to=30000000us\n15:[2014-04-04 11:56:06.080][trace][104][11] srand initialized the random.\n16:[2014-04-04 11:56:06.082][trace][104][11] simple handshake with client success.\n17:[2014-04-04 11:56:06.083][trace][104][11] rtmp connect app success. \ntcUrl=rtmp://192.168.1.107:1935/live, pageUrl=, swfUrl=rtmp://192.168.1.107:1935/live, \nschema=rtmp, vhost=__defaultVhost__, port=1935, app=live\n18:[2014-04-04 11:56:06.288][trace][104][11] set ack window size to 2500000\n19:[2014-04-04 11:56:06.288][trace][104][11] identify ignore messages except AMF0/AMF3 \ncommand message. type=0x5\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. \ntype=publish(FMLEPublish), stream_name=livestream\n21:[2014-04-04 11:56:06.288][trace][104][11] set output chunk size to 60000\n22:[2014-04-04 11:56:06.288][trace][104][11] set chunk_size=60000 success\n23:[2014-04-04 11:56:07.397][trace][104][11] <- time=225273, obytes=4168, ibytes=7607, okbps=32, ikbps=59\n24:[2014-04-04 11:56:07.398][trace][104][11] dispatch metadata success.\n25:[2014-04-04 11:56:07.398][trace][104][11] process onMetaData message success.\n26:[2014-04-04 11:56:07.398][trace][104][11] update video sequence header success. size=67\n27:[2014-04-04 11:56:08.704][trace][104][11] <- time=226471, obytes=4168, ibytes=36842, okbps=13, ikbps=116\n28:[2014-04-04 11:56:09.901][trace][104][11] <- time=227671, obytes=4168, ibytes=67166, okbps=9, ikbps=152\n29:[2014-04-04 11:56:11.102][trace][104][11] <- time=228869, obytes=4168, ibytes=97481, okbps=6, ikbps=155\n30:[2014-04-04 11:56:11.219][trace][104][11] clear cache/metadata/sequence-headers when unpublish.\n31:[2014-04-04 11:56:11.219][trace][104][11] control message(unpublish) accept, retry stream service.\n32:[2014-04-04 11:56:11.219][trace][104][11] ignore AMF0/AMF3 command message.\n33:[2014-04-04 11:56:11.419][trace][104][11] drop the AMF0/AMF3 command message, command_name=deleteStream\n34:[2014-04-04 11:56:11.420][trace][104][11] ignore AMF0/AMF3 command message.\n35:[2014-04-04 11:56:12.620][error][104][104] recv client message failed. ret=207(Connection reset by peer)\n36:[2014-04-04 11:56:12.620][error][104][104] identify client failed. ret=207(Connection reset by peer)\n37:[2014-04-04 11:56:12.620][warn][104][104] client disconnect peer. ret=204\n[winlin@dev6 srs]$ \n```\n\n----------------------------------------\n\nTITLE: Running HLS Load Test with srs-bench Docker Container\nDESCRIPTION: Command to use srs-bench tool via Docker to simulate 500 concurrent clients accessing an HLS stream, useful for benchmarking a HLS delivery cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_hls_load -c 500 \\\n  -r http://your_server_public_ipv4/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory. Also includes commands to update existing code via git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Media-Type Syntax - ABNF\nDESCRIPTION: Specifies the ABNF for HTTP media types (MIME types) used in Content-Type and Accept headers. Dependencies are RFC 2616 rules for 'token' and 'parameter'. Used to communicate data format and type information within HTTP header fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_14\n\nLANGUAGE: abnf\nCODE:\n```\nmedia-type     = type \"/\" subtype *( \";\" parameter )\ntype           = token\nsubtype        = token\n```\n\n----------------------------------------\n\nTITLE: Memory Leak Detection with GPERF GMC\nDESCRIPTION: Demonstrates how to use Google's Memory Checker (GMC) to detect memory leaks in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GMC\n./configure --gperf=on --gmc=on && make\n\n# Start SRS with GMC\nenv PPROF_PATH=./objs/pprof HEAPCHECK=normal ./objs/srs -c conf/console.conf 2>gmc.log \n\n# Or CTRL+C to stop gmc\nkillall -2 srs\n\n# To analysis memory leak\ncat gmc.log\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server in Bash\nDESCRIPTION: This command starts the SRS server using the HTTP and HLS configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.hls.conf\n```\n\n----------------------------------------\n\nTITLE: Building SRS Proxy Server\nDESCRIPTION: Instructions for building the SRS proxy server component. Requires Go 1.18+ and shows the build command to compile the proxy server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/proxy && make\n```\n\n----------------------------------------\n\nTITLE: Importing a Grafana Dashboard for SRS Metrics\nDESCRIPTION: This bash script imports a pre-configured Grafana dashboard for visualizing SRS metrics using the Grafana HTTP API.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ndata=$(curl https://raw.githubusercontent.com/ossrs/srs-grafana/main/dashboards/helloworld-import.json 2>/dev/null)\ncurl -s -H \"Content-Type: application/json\" \\\n    -XPOST http://admin:12345678@localhost:3000/api/dashboards/db \\\n    --data-binary \"{\\\"dashboard\\\":${data},\\\"overwrite\\\":true,\\\"inputs\\\":[],\\\"folderId\\\":0}\"\n```\n\n----------------------------------------\n\nTITLE: Setting Candidate IP and Running SRS for RTMP-to-WebRTC - Bash\nDESCRIPTION: Sets the CANDIDATE variable for a WebRTC setup and starts the SRS server with the 'rtmp2rtc.conf' configuration, enabling RTMP to WebRTC streaming conversion. SRS uses this IP during WebRTC ICE negotiation. The configuration file should be customized for RTMP/WebRTC bridging.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Grep for Play Events in Origin Log\nDESCRIPTION: Searches the origin server log for Play events to identify client connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngrep -ina \"type=Play\" objs/srs.origin.log\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with DASH Configuration - Bash\nDESCRIPTION: This command runs the SRS server executable using the specified DASH configuration file. It assumes the binaries for SRS have been built and the configuration file exists. The '-c' flag specifies which configuration to use; essential for enabling DASH streaming as previously set up.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-dash.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/dash.conf\n```\n\n----------------------------------------\n\nTITLE: Illustrating SRS 'on_ocr' HTTP Callback Request/Response (JSON)\nDESCRIPTION: This JSON example shows the request body sent by SRS for the `on_ocr` event, containing details like the stream identifier (`vhost`, `app`, `stream`), OCR task UUID (`uuid`), AI prompt (`prompt`), and the OCR result (`result`). It also includes the simple success response (`code: 0`) expected from the receiving HTTP server. This callback allows external systems to be notified about completed OCR tasks. Note that response errors from the callback endpoint are ignored by SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_4\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_ocr\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"prompt\": \"What is in the image?\",\n  \"result\": \"The image shows a scene featuring a character from a film, likely set in a military or high-tech environment.\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository Using Git - Bash\nDESCRIPTION: Clones the SRS repository from GitHub and navigates to the trunk directory. Requires 'git' to be installed, and network access to GitHub. The output directory will contain the latest SRS source code ready for building. Expects no input other than executing in a shell with git installed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Checking Process Priority (NI Field) using top in Bash\nDESCRIPTION: Runs the `top` command filtered for the SRS process ID (`-p $(pidof srs)`) and shows a single update (`-n1`). The `NI` column in the output displays the niceness value, which should reflect the value set by `renice` (e.g., -15).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\ntop -n1 -p $(pidof srs)\n#  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                \n# 1505 root       5 -15  519920 421556   4376 S  66.7  5.3   4:41.12 srs\n```\n\n----------------------------------------\n\nTITLE: Publishing Additional Stream to Origin Server\nDESCRIPTION: FFmpeg command to publish another stream to the origin server, demonstrating load distribution across multiple origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream2\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server for SRS Documentation\nDESCRIPTION: This command starts a local development server for the SRS documentation project. It opens a browser window and reflects most changes live without needing to restart the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 4.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS 4.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 4.0release\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFmpeg Support in Bash\nDESCRIPTION: Command to configure and build SRS with FFmpeg tool support enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ingest.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Linking SRS Init.d Script to System Scripts - Bash\nDESCRIPTION: Symbolically links the installed init.d script to the system '/etc/init.d/srs' for service management integration. Requires SRS to be installed at '/usr/local/srs'. Needs sudo privileges. No input; ensures the SRS init.d service script is discoverable by the OS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo ln -sf \\\\n    /usr/local/srs/etc/init.d/srs \\\\n    /etc/init.d/srs\n```\n\n----------------------------------------\n\nTITLE: Creating Oryx Container with Docker\nDESCRIPTION: This command runs a Docker container for Oryx, setting up ports and volumes for live streaming transcoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-10-21-Oryx-Live-Transcoding.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic ATC (Absolute Timestamp Control) in SRS\nDESCRIPTION: Enables automatic ATC detection for play clients. When enabled, SRS checks for 'bravo_atc=\"true\"' in onMetaData packets and sets ATC accordingly. This setting is ignored if atc_auto is off.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_10\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Compilation for ARM Server\nDESCRIPTION: Simple command to compile SRS directly on an ARM server such as Kunpeng servers or other ARM-based systems. This is the recommended approach for most ARM deployments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Service\nDESCRIPTION: Command to reload the SRS service configuration without stopping the service, using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Starting SRS on ARM Device in Bash\nDESCRIPTION: Command to start the SRS server on the ARM device using the transferred configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Project Table - HLS LLHLS Implementation\nDESCRIPTION: Markdown table defining the HLS LLHLS mode project details including mentor information, skills needed, and expected outcomes\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-02-10-GSoC.md#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n|Name of project|HLS support LLHLS mode|\n| :---- | :----- |\n|Project Description|HLS is a live file slicing method proposed by APPLE, the current drawback is the long delay, LLHLS can greatly reduce the delay of HLS.|\n|Mentor|Zhihong Xiao(hondaxiao@tencent.com)|\n|Backup Mentor|Wei Shi(shiwei05@kuaishou.com)|\n|Skills needed|Familiar with HLS, LLHLS, good ability to read standard documents, familiar with programming in C++.|\n|Expected size of project|350 hours|\n|Difficulty|Advanced|\n|Expected results|Be able to play on a player that supports LLHLS and achieve latency within expectations.|\n|Qualification Task|LLHLS coding, encapsulation, manifest file generation.|\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFMPEG Support\nDESCRIPTION: Command to configure and build SRS with FFMPEG transcoding capabilities enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Stream Publishing with FFmpeg\nDESCRIPTION: FFmpeg command loop to continuously publish a video stream to the RTMP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Commit Supporting HEVC via RTMP\nDESCRIPTION: Git commit information showing the addition of enhanced RTMP protocol support in FFmpeg, which enables HEVC, AV1, and VP9 codec support via the RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncommit 637c761be1bf9c3e1f0f347c5c3a390d7c32b282\nAuthor: Steven Liu <liuqi05@kuaishou.com>\nDate:   Mon Aug 28 09:59:24 2023 +0800\n\n    avformat/rtmpproto: support enhanced rtmp\n    \n    add option named rtmp_enhanced_codec,\n    it would support hvc1,av01,vp09 now,\n    the fourcc is using Array of strings.\n    \n    Signed-off-by: Steven Liu <lq@chinaffmpeg.org>\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with DASH Support\nDESCRIPTION: Docker command to run an SRS media server with HTTP server and DASH enabled on ports 8080 and 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-11-25-DASH-Issues.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080 -p 1935:1935 \\\n  -e SRS_HTTP_SERVER_ENABLED=on -e SRS_VHOST_DASH_ENABLED=on \\\n  ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Starting Multiple SRS Slave Processes\nDESCRIPTION: Bash commands to start two SRS slave processes with different configurations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/forward.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnohup ./objs/srs -c srs.1935.conf >/dev/null 2>&1 &\nnohup ./objs/srs -c srs.1936.conf >/dev/null 2>&1 &\n```\n\n----------------------------------------\n\nTITLE: Configuring FMLE to Push RTMP Stream to SRS Origin (Plaintext)\nDESCRIPTION: These lines provide the necessary settings for Adobe Flash Media Live Encoder (FMLE) or similar software to push an RTMP stream to the first SRS origin server (A). The FMS URL specifies the server address, port, and application name, while Stream indicates the stream key.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: ActionScript RTMP Connection Code\nDESCRIPTION: Example ActionScript code showing how to establish an RTMP connection and play a stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_3\n\nLANGUAGE: actionscript\nCODE:\n```\n// how to play url: rtmp://demo.srs.com/live/livestream\nconn = new NetConnection();\nconn.connect(\"rtmp://demo.srs.com/live\");\n\nstream = new NetStream(conn);\nstream.play(\"livestream\");\n```\n\n----------------------------------------\n\nTITLE: Publishing Media to SRS Windows Using FFmpeg\nDESCRIPTION: FFmpeg command to publish a video file to an SRS server running on Windows. This command reads a FLV file and streams it to the RTMP endpoint on a Windows host named 'win11'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/windows.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ~/srs/doc/source.flv -c copy -f flv rtmp://win11/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Displaying Per-CPU Usage with top and mpstat (bash)\nDESCRIPTION: Invokes 'top' to show real-time per-CPU usage (by pressing '1' in the UI after starting), and calls 'mpstat -P ALL' to print quantitative CPU usage across all processors on the system. Dependencies: procps and sysstat packages should be available. Inputs are optional; outputs are displayed interactively or on stdout.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ntop # 1\n#%Cpu0  :  1.8 us,  1.1 sy,  0.0 ni, 90.8 id,  0.0 wa,  0.0 hi,  6.2 si,  0.0 st\n#%Cpu1  : 67.6 us, 17.6 sy,  0.0 ni, 14.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n```\n\nLANGUAGE: bash\nCODE:\n```\nmpstat -P ALL\n#01:23:14 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle\n#01:23:14 PM  all   33.33    0.00    8.61    0.04    0.00    3.00    0.00    0.00    0.00   55.02\n#01:23:14 PM    0    2.46    0.00    1.32    0.06    0.00    6.27    0.00    0.00    0.00   89.88\n#01:23:14 PM    1   61.65    0.00   15.29    0.02    0.00    0.00    0.00    0.00    0.00   23.03\n```\n\n----------------------------------------\n\nTITLE: SRS HDS Configuration Block - NGINX Style\nDESCRIPTION: This configuration snippet, written in the SRS/NGINX-style format, enables HDS streaming on the default vhost for SRS. It covers several HDS-specific parameters including enablement, fragment duration, window size, and output file path. Requires SRS to be built with HDS support and used in the appropriate SRS configuration file (e.g., conf/full.conf); expected input values are shown with default comments. Outputs configured HDS segment files to the specified path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hds.md#2025-04-23_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hds {\n        # whether hds enabled\n        # default: off\n        enabled         on;\n        # the hds fragment in seconds.\n        # default: 10\n        hds_fragment    10;\n        # the hds window in seconds, erase the segment when exceed the window.\n        # default: 60\n        hds_window      60;\n        # the path to store the hds files.\n        # default: ./objs/nginx/html\n        hds_path        ./objs/nginx/html;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Write Settings for Players\nDESCRIPTION: Configuration for merged-write functionality affecting player latency and stream delivery efficiency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    play {\n        mw_latency      350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Second Origin Server with HLS Support\nDESCRIPTION: Command to start the second SRS origin server, also listening on ports 1935 and 8080, configured to convert RTMP to HLS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only2.conf\n```\n\n----------------------------------------\n\nTITLE: Coroutine-Native SRT Client Acceptance in C++\nDESCRIPTION: This snippet shows the coroutine-native approach for accepting SRT clients. It demonstrates the main loop for accepting connections and starting the processing coroutine for each client.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsSrtListener::cycle() {\n  while (true) {\n    srs_srt_t client_srt_fd = srs_srt_socket_invalid();\n    srt_skt_->accept(&client_srt_fd);\n    \n    srt_server_->accept_srt_client(srt_fd);\n  }\n}\n\nsrs_error_t SrsSrtServer::accept_srt_client(srs_srt_t srt_fd) {\n  fd_to_resource(srt_fd, &srt_conn);\n  conn_manager_->add(srt_conn);\n  srt_conn->start();\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code. This compiles the SRS streaming server software.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR with HTTP Callback in SRS\nDESCRIPTION: Configuration example for enabling DVR in SRS with HTTP callbacks. This sets up segment-based recording with 30-second duration that triggers a callback when a recording is created.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nvhost your_vhost {\n    dvr {\n        enabled             on;\n        dvr_path            ./objs/nginx/html/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        dvr_plan            segment;\n        dvr_duration        30;\n        dvr_wait_keyframe   on;\n    }\n    http_hooks {\n        enabled         on;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Local Git User Name and Email using Bash\nDESCRIPTION: These commands configure the user name and email specifically for the local SRS repository (`--local`). This ensures commits are correctly attributed to the contributor. The final command lists the current configuration to verify the settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs\ngit config --local user.name \"username\"\ngit config --local user.email \"useremail@xxx.com\"\ngit config --list\n```\n\n----------------------------------------\n\nTITLE: Starting Ubuntu Docker for Cross-Compilation\nDESCRIPTION: Command to start an Ubuntu Docker container for cross-compiling SRS, mounting the current directory as the workspace.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk\ndocker run --rm -it -v `pwd`:/srs -w /srs \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:ubuntu20 bash\n```\n\n----------------------------------------\n\nTITLE: Viewing SRS Server Startup Logs in Bash\nDESCRIPTION: Example of starting SRS server with a configuration file and examining the initial log entries showing version information, system details, configuration parameters, and listening ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c console.conf \n[winlin@dev6 srs]$ cat objs/srs.log \n[2014-04-04 11:39:24.176][trace][0][0] config parsed EOF\n[2014-04-04 11:39:24.176][trace][0][0] log file is ./objs/srs.log\n[2014-04-04 11:39:24.177][trace][0][0] srs 0.9.46\n[2014-04-04 11:39:24.177][trace][0][0] uname: Linux dev6 2.6.32-71.el6.x86_64 \n#1 SMP Fri May 20 03:51:51 BST 2011 x86_64 x86_64 x86_64 GNU/Linux\n[2014-04-04 11:39:24.177][trace][0][0] build: 2014-04-03 18:38:23, little-endian\n[2014-04-04 11:39:24.177][trace][0][0] configure:  --dev --with-hls --with-nginx \n--with-ssl --with-ffmpeg --with-http-callback --with-http-server --with-http-api \n--with-librtmp --with-bwtc --with-research --with-utest --without-gperf --without-gmc \n--without-gmp --without-gcp --without-gprof --without-arm-ubuntu12 --jobs=1 \n--prefix=/usr/local/srs\n[2014-04-04 11:39:24.177][trace][0][0] write pid=4021 to ./objs/srs.pid success!\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1935, type=0, fd=6\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1985, type=1, fd=7\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=8080, type=2, fd=8\n[2014-04-04 11:39:24.177][trace][101][16] listen cycle start, port=1935, type=0, fd=6\n[2014-04-04 11:39:24.177][trace][102][11] listen cycle start, port=1985, type=1, fd=7\n[2014-04-04 11:39:24.177][trace][103][11] listen cycle start, port=8080, type=2, fd=8\n[2014-04-04 11:39:26.799][trace][0][11] get a signal, signo=2\n[2014-04-04 11:39:26.799][trace][0][11] user terminate program\n```\n\n----------------------------------------\n\nTITLE: FFProbe Command for UDP MPEGTS Stream Analysis\nDESCRIPTION: Command to analyze and display information about a UDP MPEGTS stream, including its video and audio stream details, codecs, and metadata after conversion from RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    [root@edge ~]# ffprobe  udp://xxx:1234?localaddr=127.0.0.1\n    Input #0, mpegts, from 'udp://xxx:5002?localaddr=127.0.0.1':\n      Duration: N/A, start: 29981.146500, bitrate: 130 kb/s\n      Program 1\n        Metadata:\n          service_name    : Channel 1\n          service_provider: PBS\n        Stream #0:0[0x100]: Video: h264 (High) ([27][0][0][0] / 0x001B), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 90k tbn, 180k tbc\n        Stream #0:1[0x101]: Audio: aac ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 130 kb/s\n```\n\n----------------------------------------\n\nTITLE: Interpreting GPERF Heap Checker (gmc) Leak Report in Bash\nDESCRIPTION: Displays example output from the GPERF memory checker (gmc) after SRS terminates. It reports detected memory leaks, including the total size, number of objects, and stack traces for the largest leaks, helping identify memory leak sources. Requires `PPROF_PATH` environment variable to be set correctly for symbol resolution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nLeak check _main_ detected leaks of 184 bytes in 4 objects\nThe 4 largest leaks:\nUsing local file ./objs/srs.\nLeak of 56 bytes in 1 objects allocated from:\n\t@ 46fae8 _st_stack_new\n\t@ 46f6b1 st_thread_create\n\t@ 46ea65 st_init\n\t@ 433f41 SrsServer::initialize\n\t@ 46e4ca main\n\t@ 3855a1ec5d __libc_start_main\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS codebase from GitHub repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Product Token Syntax Definition in ABNF\nDESCRIPTION: Specifies the format for product tokens used to identify software name and version in HTTP communications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_16\n\nLANGUAGE: abnf\nCODE:\n```\nproduct         = token [\"/\" product-version]\nproduct-version = token\n```\n\n----------------------------------------\n\nTITLE: Adding Prometheus as a Data Source in Grafana\nDESCRIPTION: This curl command adds Prometheus as a data source in Grafana using the HTTP API.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -H \"Content-Type: application/json\" \\\n    -XPOST http://admin:12345678@localhost:3000/api/datasources \\\n    -d '{\n    \"name\": \"prometheus\",\n    \"type\": \"prometheus\",\n    \"access\": \"proxy\", \"isDefault\": true,\n    \"url\": \"http://host.docker.internal:9090\"\n}'\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with MPEGTS over UDP Configuration - Bash Command - Bash\nDESCRIPTION: This Bash snippet demonstrates launching the SRS server with a specific configuration file (conf/push.mpegts.over.udp.conf) necessary for MPEGTS-over-UDP stream conversion. Ensure SRS is built and conf/push.mpegts.over.udp.conf is correctly set. Command line arguments specify the config file to use; SRS must be installed and compiled beforehand.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/streamer.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/push.mpegts.over.udp.conf\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Status on RaspberryPi\nDESCRIPTION: Command to check if SRS is running on the RaspberryPi.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs status\n```\n\n----------------------------------------\n\nTITLE: Building FFmpeg with HEVC Support using Docker\nDESCRIPTION: Docker command to run FFmpeg with HEVC encoding support using the SRS encoder image, converting a source FLV file to HEVC and publishing it to a local RTMP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --net host ossrs/srs:encoder \\\n  ffmpeg -re -i doc/source.flv -acodec copy -vcodec libx265 \\\n    -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Examining Client Connection on Edge Server\nDESCRIPTION: Uses grep to track session ID 107 on the edge server, which represents a client that triggered the edge server to fetch the stream from the origin. Shows the complete session lifecycle.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[107\\]\" objs/srs.log\n18:[2014-08-06 10:09:34.281][trace][22314][107] RTMP client ip=192.168.1.179\n19:[2014-08-06 10:09:34.282][trace][22314][107] srand initialized the random.\n20:[2014-08-06 10:09:34.291][trace][22314][107] complex handshake success\n21:[2014-08-06 10:09:34.291][trace][22314][107] connect app, tcUrl=rtmp://dev:1935/live, pageUrl=http://www.ossrs.net/players/srs_player.html?vhost=dev&stream=livestream&server=dev&port=1935, swfUrl=http://www.ossrs.net/players/srs_player/release/srs_player.swf?_version=1.23, schema=rtmp, vhost=__defaultVhost__, port=1935, app=live, args=null\n22:[2014-08-06 10:09:34.532][trace][22314][107] ignored. set buffer length to 800\n23:[2014-08-06 10:09:34.568][trace][22314][107] client identified, type=Play, stream_name=livestream, duration=-1.00\n24:[2014-08-06 10:09:34.568][trace][22314][107] out chunk size to 60000\n25:[2014-08-06 10:09:34.568][trace][22314][107] source url=__defaultVhost__/live/livestream, ip=192.168.1.179, cache=1, is_edge=1, source_id=-1[-1]\n26:[2014-08-06 10:09:34.579][trace][22314][107] dispatch cached gop success. count=0, duration=0\n27:[2014-08-06 10:09:34.579][trace][22314][107] create consumer, queue_size=30.00, tba=0, tbv=0\n28:[2014-08-06 10:09:34.579][trace][22314][107] ignored. set buffer length to 800\n39:[2014-08-06 10:09:34.779][trace][22314][107] update source_id=108[108]\n54:[2014-08-06 10:09:47.805][trace][22314][107] cleanup when unpublish\n55:[2014-08-06 10:09:47.805][trace][22314][107] edge change from 101 to state 0 (init).\n56:[2014-08-06 10:09:47.805][warn][22314][107][9] client disconnect peer. ret=1004\n```\n\n----------------------------------------\n\nTITLE: Checking Maximum Open File Descriptors (Bash)\nDESCRIPTION: Displays the current soft limit for the maximum number of open file descriptors allowed for the shell session. This check is performed after attempting to increase the limit using `ulimit -HSn 10240` to ensure the setting was applied, which is necessary for handling a large number of connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Starting Edge Server in SRS\nDESCRIPTION: Command to start an SRS edge server listening on port 1935. This is the first instance of the edge server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/reuse-port.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge.conf\n```\n\n----------------------------------------\n\nTITLE: Setting up HTTP Hooks for HLS Notify in SRS\nDESCRIPTION: Configures HTTP hooks that are triggered when SRS creates a new TS file for HLS. This can be used to push files to CDN networks by getting the TS file from the CDN network using variables like [app], [stream], and [ts_url].\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_8\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    http_hooks {\n        # when srs reap a ts file of hls, call this hook,\n        # used to push file to cdn network, by get the ts file from cdn network.\n        # so we use HTTP GET and use the variable following:\n        #       [app], replace with the app.\n        #       [stream], replace with the stream.\n        #       [ts_url], replace with the ts url.\n        # ignore any return data of server.\n        # @remark random select a url to report, not report all.\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SRS Build Command\nDESCRIPTION: Command to build SRS with HTTP API support enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: System Resource Usage Statistics\nDESCRIPTION: Shows detailed system resource usage including CPU, memory, and process statistics during the benchmark test with multiple clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\ntop - 19:52:35 up 1 day, 11:11,  8 users,  load average: 1.20, 1.05, 0.92\nTasks: 171 total,   4 running, 167 sleeping,   0 stopped,   0 zombie\nCpu0  : 26.0%us, 23.0%sy,  0.0%ni, 34.0%id,  0.3%wa,  0.0%hi, 16.7%si,  0.0%st\nCpu1  : 26.4%us, 20.4%sy,  0.0%ni, 34.1%id,  0.7%wa,  0.0%hi, 18.4%si,  0.0%st\nCpu2  : 22.5%us, 15.4%sy,  0.0%ni, 45.3%id,  1.0%wa,  0.0%hi, 15.8%si,  0.0%st\nMem:   2055440k total,  1972196k used,    83244k free,   136836k buffers\nSwap:  2064376k total,     3184k used,  2061192k free,   926124k cached\n\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                          \n17034 root      20   0  415m 151m 2040 R 94.4  7.6  14:29.33 ./objs/srs -c console.conf                                                        \n 1063 winlin    20   0  131m  68m 1336 S 17.9  3.4  54:05.77 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1011 winlin    20   0  132m  68m 1336 R 17.6  3.4  54:45.53 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18736 winlin    20   0  113m  48m 1336 S 17.6  2.4   1:37.96 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1051 winlin    20   0  131m  68m 1336 S 16.9  3.4  53:25.04 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18739 winlin    20   0  104m  39m 1336 R 15.6  2.0   1:25.71 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Rotating SRS logs\nDESCRIPTION: Command to trigger log rotation for SRS by sending SIGUSR1 signal.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs rotate\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Codebase using Git Pull - Bash\nDESCRIPTION: Updates the current SRS git repository to the latest version using 'git pull'. Assumes you are inside a previously cloned git repository directory. Requires 'git' and internet access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Starting Origin Server\nDESCRIPTION: Command to start the SRS origin server from which edge servers will pull streams\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/reuse-port.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Server (Bash)\nDESCRIPTION: This command starts the compiled SRS server executable (`./objs/srs`) using the specified configuration file (`conf/http.hls.conf`). The `-c` flag indicates the path to the configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.hls.conf\n```\n\n----------------------------------------\n\nTITLE: Accept-Ranges Header Syntax in BNF\nDESCRIPTION: BNF syntax definition for the Accept-Ranges response header that indicates server's acceptance of range requests.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_52\n\nLANGUAGE: BNF\nCODE:\n```\nAccept-Ranges     = \"Accept-Ranges\" \":\" acceptable-ranges\nacceptable-ranges = 1#range-unit | \"none\"\n```\n\n----------------------------------------\n\nTITLE: Starting Slave SRS Server\nDESCRIPTION: Command to start the slave SRS server using the specified configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/forward.slave.conf\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Repository\nDESCRIPTION: Command to update an existing SRS codebase by pulling the latest changes from the remote repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Status\nDESCRIPTION: Commands to check SRS process status and view server logs\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Check the process status\n./etc/init.d/srs status\n\n# Check the SRS logs\ntail -n 30 -f ./objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using Kill Command\nDESCRIPTION: Demonstrates how to reload SRS configuration using the kill command with the SIGHUP signal. This method allows for applying configuration changes without restarting the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reload.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkillall -1 srs\n```\n\n----------------------------------------\n\nTITLE: Starting Demo HTTP Callback Server - Go\nDESCRIPTION: This command launches the example HTTP callback server, written in Go, which acts as the business server endpoint for SRS HTTP callback events. The dependency is the Go programming language environment and the source code located at 'research/api-server/server.go'. Running this command will start a local HTTP server that receives and processes HTTP POST events from SRS, such as on_publish or on_play, allowing for custom business logic integration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngo run research/api-server/server.go\n```\n\n----------------------------------------\n\nTITLE: Running SRS with ASAN for Memory Error Detection\nDESCRIPTION: Command to run SRS with Address Sanitizer enabled, configuring it to halt on errors and detect memory leaks. ASAN helps identify memory corruption issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nASAN_OPTIONS=halt_on_error=1:detect_leaks=1 ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Directly Using init.d Script\nDESCRIPTION: Command to start SRS directly using the init.d script from the trunk directory without adding it as a system service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\n./etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Setting Publish First Packet Timeout in SRS\nDESCRIPTION: Configures the timeout in milliseconds for the first packet received from an encoder during publishing. This helps handle encoder connectivity issues during the initial connection phase.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_2\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # the 1st packet timeout in ms for encoder.\n        # default: 20000\n        firstpkt_timeout    20000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Sample API Server for SRS Snapshot\nDESCRIPTION: Command to start the sample API server for handling snapshot requests in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/snapshot.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd research/api-server && go run server.go 8085\n```\n\n----------------------------------------\n\nTITLE: Running SRS in Docker for H.265 Streaming\nDESCRIPTION: Command to run SRS 6.0 in a Docker container, configured for H.265 live streaming. This sets up the necessary ports and configuration for RTMP and HTTP streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-03-07-Lets-Do-H265-Live-Streaming.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:6 \\\n  ./objs/srs -c conf/docker.conf\n```\n\n----------------------------------------\n\nTITLE: Gracefully quitting SRS\nDESCRIPTION: Command to gracefully shut down SRS by sending SIGQUIT signal, allowing existing connections to complete.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs grace\n```\n\n----------------------------------------\n\nTITLE: Running HTTPX-Static as Go-based Reverse Proxy - Go\nDESCRIPTION: Provides Go commands to install and run the HTTPX-Static proxy application, a standalone reverse proxy for SRS written in Go. It proxies HTTP and HTTPS to different endpoints with SSL credentials and multiple proxy backends. Install httpx-static via go get, then run with proper flags for HTTP/HTTPS ports, SSL cert/key, and proxy endpoints. Requires Go toolchain and SRS backend servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_9\n\nLANGUAGE: go\nCODE:\n```\ngo get github.com/ossrs/go-oryx/httpx-static\ncd $GOPATH/bin\n./httpx-static -http=80 -https=443 \\\n  -skey /usr/local/srs/etc/server.key -scert /usr/local/srs/etc/server.crt \\\n  -proxy=http://127.0.0.1:1985/api/v1/ \\\n  -proxy=http://127.0.0.1:1985/rtc/v1/ \\\n  -proxy=http://127.0.0.1:8080/\n\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug for SRS Upnode\nDESCRIPTION: Controls whether to enable debug information when connecting to an upnode (forward to, edge push to, edge pull from). This captures important debug information such as id, source id, and pid when connecting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_4\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # when upnode(forward to, edge push to, edge pull from) is srs,\n    # it's strongly recommend to open the debug_srs_upnode,\n    # when connect to upnode, it will take the debug info, \n    # for example, the id, source id, pid.\n    # please see https://ossrs.io/lts/en-us/docs/v4/doc/log\n    # default: on\n    debug_srs_upnode    on;\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying SRS Processes are Listening\nDESCRIPTION: This command uses 'netstat' to check network connections and filters for processes named 'srs'. It verifies that both the master (listening on port 1935) and slave (listening on port 19350) SRS instances are running and listening on their configured ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\n[winlin@dev6 srs]$ sudo netstat -anp|grep srs\ntcp        0      0 0.0.0.0:1935                0.0.0.0:*                   LISTEN      7826/srs            \ntcp        0      0 0.0.0.0:19350               0.0.0.0:*                   LISTEN      7834/srs\n```\n\n----------------------------------------\n\nTITLE: Monitoring SRS Connection Count\nDESCRIPTION: Bash script to continuously monitor the number of established connections to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    srs_connections=`sudo netstat -anp|grep 1935|grep ESTABLISHED|wc -l`;  \\\n    echo \"srs_connections: $srs_connections\";  \\\n    sleep 5;  \ndone\n```\n\n----------------------------------------\n\nTITLE: SRS Slave Server Configuration (Port 1935)\nDESCRIPTION: Configuration for an SRS slave server listening on port 1935. This is part of a setup where multiple SRS instances run on the same machine with different ports to utilize multiple CPU cores.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.1935.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Timestamp Jitter for DVR in SRS\nDESCRIPTION: This configuration snippet demonstrates how to configure timestamp jitter handling for DVR (Digital Video Recording) in SRS. It allows control over how timestamps are corrected when recording RTMP streams to files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/time-jitter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost dvr.srs.com {\n    # dvr RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv according by specified dvr_plan.\n    # http callbacks:\n    # @see http callback on_dvr_hss_reap_flv on http_hooks section.\n    dvr {\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing, \n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # default: full\n        time_jitter             full;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Log Tank\nDESCRIPTION: Configuration snippet for specifying the log output destination (tank). Can be set to either console or file, with file being the default option that requires a log file path specification.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the log tank, console or file.\n# if console, print log to console.\n# if file, write log to file. requires srs_log_file if log to file.\n# default: file.\nsrs_log_tank        file;\n```\n\n----------------------------------------\n\nTITLE: Simplified MPEG-TS over UDP Configuration Example\nDESCRIPTION: Minimal configuration example for MPEG-TS over UDP stream converter, showing the essential settings needed to enable the feature in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/streamer.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n# the streamer cast stream from other protocol to SRS over RTMP.\n# @see https://github.com/ossrs/srs/tree/develop#stream-architecture\nstream_caster {\n    enabled         on;\n    caster          mpegts_over_udp;\n    output          rtmp://127.0.0.1/live/livestream;\n    listen          1935;\n}\n```\n\n----------------------------------------\n\nTITLE: Explaining URL Parsing in SRS Player and Publisher\nDESCRIPTION: Example showing how srs_player and srs_publisher parse RTMP URLs. They consider everything after the last slash as the stream name, and everything before that as the tcUrl (vhost/app).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n// For both srs_player and srs_publisher:\n// play or publish the following rtmp URL:\nrtmp://demo.srs.com/show/live/livestream/2013\nschema: rtmp\nhost/vhost: demo.srs.com\napp: show/live/livestream\nstream: 2013\n```\n\n----------------------------------------\n\nTITLE: Using Valgrind for Memory Analysis in SRS\nDESCRIPTION: Commands to use Valgrind for memory leak detection and analysis in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nvalgrind --leak-check=full --show-leak-kinds=all ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Creating Kubernetes Deployment for SRS and Nginx with Shared Volume\nDESCRIPTION: YAML configuration to create a Kubernetes deployment with SRS and Nginx containers sharing an emptyDir volume. SRS writes HLS segments to the volume while Nginx serves them. Includes a third container to copy default SRS files to the shared volume.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: srs-deploy\n  labels:\n    app: srs\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: srs\n  template:\n    metadata:\n      labels:\n        app: srs\n    spec:\n      volumes:\n      - name: cache-volume\n        emptyDir: {}\n      containers:\n      - name: srs\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 1935\n        - containerPort: 1985\n        - containerPort: 8080\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/local/srs/objs/nginx/html\n          readOnly: false\n      - name: nginx\n        image: nginx\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 80\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /usr/share/nginx/html\n          readOnly: true\n      - name: srs-cp-files\n        image: ossrs/srs:3\n        imagePullPolicy: IfNotPresent\n        volumeMounts:\n        - name: cache-volume\n          mountPath: /tmp/html\n          readOnly: false\n        command: [\"/bin/sh\"]\n        args:\n        - \"-c\"\n        - >\n          if [[ ! -f /tmp/html/index.html ]]; then\n            cp -R ./objs/nginx/html/* /tmp/html\n          fi &&\n          sleep infinity\nEOF\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code. This prepares the SRS executable for deployment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Monitor SRS Bench Process CPU Usage\nDESCRIPTION: Command to identify and monitor CPU usage of the srs-bench load testing process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/raspberrypi.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep load|grep rtmp|awk '{print $2}'` && top -p $pid\n```\n\n----------------------------------------\n\nTITLE: Cloning Forked SRS Repository using Git\nDESCRIPTION: This snippet clones the contributor's forked SRS repository to their local machine, checks out the master branch tracking the origin/master, and changes the current directory into the cloned repository folder. It's the initial step after forking the project on GitHub.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_0\n\nLANGUAGE: git\nCODE:\n```\ngit clone git@github.com:your-account/srs.git\ngit checkout -b master origin/master\ncd srs\n```\n\n----------------------------------------\n\nTITLE: Checking Server Listening Port and Connections with netstat (bash)\nDESCRIPTION: Uses 'netstat -anp' to verify nginx-rtmp and SRS are listening on the correct ports (19350 for nginx-rtmp and 1935 for SRS), and to count established connections. Also used inside scripts to monitor connection numbers for both servers. Requires root privileges.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# netstat -anp|grep 19350\ntcp        0      0 0.0.0.0:19350               0.0.0.0:*                   LISTEN      6486/nginx\n```\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 trunk]# netstat -anp|grep \"1935 \"\ntcp        0      0 0.0.0.0:1935                0.0.0.0:*                   LISTEN      6583/srs\n```\n\n----------------------------------------\n\nTITLE: Replacing FFmpeg in Docker Installation\nDESCRIPTION: Docker command parameter to mount a custom FFmpeg binary into the Oryx container, allowing the use of a custom FFmpeg version instead of the default one.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n-v /path/to/ffmpeg:/usr/local/bin/ffmpeg\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to SRS Edge using FFmpeg (Bash)\nDESCRIPTION: This command uses FFmpeg to publish a local video file (`./doc/source.flv`) as an RTMP stream to the SRS Edge service. `-re` reads the input at its native frame rate, `-c copy` copies the streams without re-encoding, and `-f flv` specifies the output format. The target URL `rtmp://28.170.32.118/live/livestream` points to the SRS Edge service's external IP (EIP) and the desired application/stream name. The user is reminded to replace the example EIP with their actual service EIP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://28.170.32.118/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS1.0 Branch with Git - Shell\nDESCRIPTION: This shell snippet demonstrates how to synchronize your local SRS repository with the remote and switch to the 1.0release branch, which corresponds to version 1.0 of SRS. Dependencies include having Git installed and the SRS repository already cloned. The command first pulls the latest changes from the remote before checking out the specified branch; no inputs or outputs outside the repo are required, but the branch must exist remotely.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/git.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit pull && git checkout 1.0release\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS from GitHub\nDESCRIPTION: This snippet demonstrates how to clone the SRS repository directly from GitHub. This is the standard method for most users to obtain the SRS codebase.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/resource.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Defining ETag Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax and usage of the ETag response-header field in HTTP/1.1. This header provides the current value of the entity tag for the requested variant.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_69\n\nLANGUAGE: HTTP\nCODE:\n```\nETag = \"ETag\" \":\" entity-tag\n```\n\n----------------------------------------\n\nTITLE: Running External SRS-SIP Server\nDESCRIPTION: Command to launch the external SRS-SIP server with configuration for SIP port, media address, API port, and HTTP server port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gb28181.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./bin/srs-sip -sip-port 5060 -media-addr 127.0.0.1:1985 -api-port 2020 -http-server-port 8888\n```\n\n----------------------------------------\n\nTITLE: Illustrating Static Variable Causing Valgrind 'Still Reachable' in C++\nDESCRIPTION: This C++ code snippet shows an example from `srs_app_config.cpp` where a static string variable `DEFAULT` within the `SrsConfig::get_hls_vcodec` function is allocated. Such static variables are allocated on first use and persist for the program's lifetime, leading to 'still reachable' reports in Valgrind if memory checks are performed after initialization but before program exit.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_24\n\nLANGUAGE: cpp\nCODE:\n```\n// It's caused by static variable:\nstring SrsConfig::get_hls_vcodec(string vhost) {\n    SRS_STATIC string DEFAULT = \"h264\";\n    SrsConfDirective* conf = get_hls(vhost);\n    if (!conf) {\n        return DEFAULT;\n```\n\n----------------------------------------\n\nTITLE: Increasing SRS Process Priority using renice in Bash\nDESCRIPTION: Uses the `renice` command to set the scheduling priority ('niceness') of the SRS process(es) (found using `pidof srs`) to -15. Lower niceness values (range -20 to +19) correspond to higher priority, potentially improving SRS responsiveness.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\nrenice -n -15 -p $(pidof srs)\n```\n\n----------------------------------------\n\nTITLE: Installing Cross-Build Toolchain for armv7 in Ubuntu - Shell\nDESCRIPTION: This snippet installs the cross-compilation toolchain for ARMv7 (armhf) architectures in Ubuntu, using apt-get for gcc-arm-linux-gnueabihf and g++-arm-linux-gnueabihf. Precondition: Use inside a Docker container or Ubuntu host. Enables building ARMv7/armhf binaries such as for Acqua or RoadRunner boards. Internet connectivity and root privileges required.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n```\napt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS 4 with Shared SRT Library Support (Bash)\nDESCRIPTION: This command configures the SRS 4 build to enable support for the SRT protocol (`--srt=on`) and dynamically link against the shared SRT library (`libsrt.so`) (`--shared-srt=on`). This allows SRS to handle SRT streams while using a system-provided or separately installed SRT library (libsrt), which uses the MPL 2.0 license.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/license.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --srt=on --shared-srt=on\n```\n\n----------------------------------------\n\nTITLE: Network and System Performance Metrics\nDESCRIPTION: Displays network statistics for the loopback interface and system metrics including CPU usage, disk I/O, and context switches during the benchmark.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n[winlin@dev6 ~]$ dstat -N lo 30\n----total-cpu-usage---- -dsk/total- ---net/lo-- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  3   2  92   0   0   3|  11k   27k|   0     0 |   1B   26B|3085   443 \n 32  17  33   0   0  17| 273B   60k|  69M   69M|   0     0 |4878  6652 \n 34  18  32   0   0  16|   0    38k|  89M   89M|   0     0 |4591  6102 \n 35  19  30   0   0  17| 137B   41k|  91M   91M|   0     0 |4682  6064 \n 33  17  33   0   0  17|   0    31k|  55M   55M|   0     0 |4920  7785 \n 33  18  31   0   0  17|2867B   34k|  90M   90M|   0     0 |4742  6530 \n 32  18  33   0   0  17|   0    31k|  66M   66M|   0     0 |4922  7666 \n 33  17  32   0   0  17| 137B   39k|  65M   65M|   0     0 |4841  7299 \n 35  18  30   0   0  17|   0    28k| 100M  100M|   0     0 |4754  6752 \n 32  17  33   0   0  18|   0    41k|  44M   44M|   0     0 |5130  8251 \n 34  18  32   0   0  16|   0    30k| 104M  104M|   0     0 |4456  5718\n```\n\n----------------------------------------\n\nTITLE: Setting Publish First Packet Timeout in SRS YAML\nDESCRIPTION: Configures the timeout for the first packet from an encoder when publishing. This helps manage connection timeouts for RTMP publishers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        firstpkt_timeout    20000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Persistent UDP Network Configuration\nDESCRIPTION: Configuration settings to add to sysctl.conf file for persistent UDP buffer settings across system reboots.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# vi /etc/sysctl.conf\n# For RTC\nnet.core.rmem_max=16777216\nnet.core.rmem_default=16777216\nnet.core.wmem_max=16777216\nnet.core.wmem_default=16777216\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS2.0 Branch with Git - Shell\nDESCRIPTION: This shell command updates the local SRS repository and switches to the 2.0release branch for SRS version 2.0. It presumes that Git is installed and the repository is locally available. The 'git pull' ensures all changes are downloaded before switching branches; succeeds only if '2.0release' exists.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/git.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: Counting Established Connections for SRS and Nginx\nDESCRIPTION: These bash commands count the number of established connections for SRS and Nginx servers using netstat.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nsrs_connections=`netstat -anp|grep srs|grep ESTABLISHED|wc -l`; \\\nnginx_connections=`netstat -anp|grep nginx|grep ESTABLISHED|wc -l`; \\\necho \"srs_connections: $srs_connections\"; \\\necho \"nginx_connections: $nginx_connections\";\n```\n\n----------------------------------------\n\nTITLE: Configuring logrotate with copytruncate for SRS2\nDESCRIPTION: Alternative logrotate configuration using copytruncate method for SRS2, which doesn't support SIGUSR1 signal handling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log-rotate.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    copytruncate\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS4.0 Branch with Git - Shell\nDESCRIPTION: This shell command updates the local copy of the SRS repository and checks out the 4.0release branch, associated with version 4.0. It relies on having a local repository set up and access to the remote branch. The command sequence first pulls new commits and then checks out the release branch, assuming the branch name is valid.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/git.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngit pull && git checkout 4.0release\n```\n\n----------------------------------------\n\nTITLE: Restarting SRS Service\nDESCRIPTION: Command to restart the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs restart\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Command to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Service\nDESCRIPTION: Command to start the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code\nDESCRIPTION: Command to update the existing SRS codebase from the Git repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-transcode-to-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Codebase\nDESCRIPTION: Update an existing SRS codebase to the latest version using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Streaming Loop Command\nDESCRIPTION: Continuous loop command to stream video content using FFMPEG to an SRS server, copying audio and video codecs without re-encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://192.168.1.105:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: Tracing Source Session Logs in SRS\nDESCRIPTION: Example of tracing source session logs using source ID in SRS edge server\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"\\[12665\\]\\[115\\]\" objs/edge.log\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to SRS Using FFmpeg - Shell\nDESCRIPTION: This snippet uses FFmpeg to publish a local FLV file as an RTMP stream to the SRS server. The command takes an input file (source.flv), copies its codecs, and outputs to the specified RTMP URL. Dependencies: FFmpeg installed, SRS running, and doc/source.flv present. Key parameters include the input file, codec copy, output format, and RTMP URL. Output is a stream playable via RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n```\n\n----------------------------------------\n\nTITLE: Benchmarking HLS Cluster with srs-bench via NGINX - Bash\nDESCRIPTION: Launches Dockerized srs-bench to simulate 500 concurrent HLS clients requesting playlists from the NGINX edge (e.g., at 192.168.0.14:8081). Used to measure edge caching performance and NGINX CPU load relative to SRS. Make sure NGINX is running and accessible at the specified address before executing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_hls_load -c 500 \\\n  -r http://192.168.0.14:8081/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with Realtime Config\nDESCRIPTION: Command to start the SRS server using the realtime configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-realtime.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/realtime.conf\n```\n\n----------------------------------------\n\nTITLE: Running SRS with HEVC Support Using Docker\nDESCRIPTION: Command to run SRS 6.0+ in Docker with HEVC support using a predefined configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 registry.cn-hangzhou.aliyuncs.com/ossrs/srs:6 \\\n  ./objs/srs -c conf/hevc.flv.conf\n```\n\n----------------------------------------\n\nTITLE: Listing Transcoder-Generated Snapshot Files\nDESCRIPTION: Command to list the snapshot PNG files generated by the transcoder in the specified directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/snapshot.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nls -lh objs/nginx/html/live/*.png\n```\n\n----------------------------------------\n\nTITLE: Finding Edge Server Connections\nDESCRIPTION: Demonstrates how to find edge server connections by searching for the edge-srs keyword in origin logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngrep -ina \"edge-srs\" objs/srs.origin.log\n```\n\n----------------------------------------\n\nTITLE: Finding Stream Source Information in Origin Logs\nDESCRIPTION: Uses grep with color highlighting to locate the source ID (105) in the origin server logs, which allows examining the ingest stream source details. This reveals metadata about the published stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[105\\]\" objs/srs.origin.log \n16:[2014-08-06 10:09:30.331][trace][22288][105] RTMP client ip=127.0.0.1\n17:[2014-08-06 10:09:30.331][trace][22288][105] srand initialized the random.\n18:[2014-08-06 10:09:30.332][trace][22288][105] simple handshake success.\n19:[2014-08-06 10:09:30.373][trace][22288][105] connect app, tcUrl=rtmp://127.0.0.1:1936/live?vhost=__defaultVhost__, pageUrl=, swfUrl=, schema=rtmp, vhost=__defaultVhost__, port=1936, app=live, args=null\n21:[2014-08-06 10:09:30.417][trace][22288][105] client identified, type=publish(FMLEPublish), stream_name=livestream, duration=-1.00\n22:[2014-08-06 10:09:30.417][trace][22288][105] out chunk size to 60000\n23:[2014-08-06 10:09:30.418][trace][22288][105] source url=__defaultVhost__/live/livestream, ip=127.0.0.1, cache=1, is_edge=0, source_id=-1[-1]\n24:[2014-08-06 10:09:30.466][trace][22288][105] got metadata, width=768, height=320, vcodec=7, acodec=10\n25:[2014-08-06 10:09:30.466][trace][22288][105] 46B video sh, codec(7, profile=100, level=32, 0x0, 0kbps, 0fps, 0s)\n26:[2014-08-06 10:09:30.466][trace][22288][105] 4B audio sh, codec(10, profile=1, 2channels, 0kbps, 44100HZ), flv(16bits, 2channels, 44100HZ)\n33:[2014-08-06 10:09:34.671][trace][22288][107] source url=__defaultVhost__/live/livestream, ip=127.0.0.1, cache=1, is_edge=0, source_id=105[105]\n38:[2014-08-06 10:09:40.732][trace][22288][105] <- CPB time=10100, okbps=3,0,0, ikbps=332,0,0\n```\n\n----------------------------------------\n\nTITLE: Retrieving SRS Service External IP in Kubernetes\nDESCRIPTION: This bash command retrieves the external IP address of the SRS service created in Kubernetes. The external IP can be used to publish and play streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get svc/srs-origin-service\n```\n\n----------------------------------------\n\nTITLE: SRS 4.0 Proxy Architecture\nDESCRIPTION: Diagram showing the authentication flow for SRS 4.0 using Nginx as a proxy with authentication.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nBrowser ---HTTP-with-Authentication---> Nginx ---HTTP---> SRS 4.0\n```\n\n----------------------------------------\n\nTITLE: Pushing HTTP FLV Stream with FFmpeg\nDESCRIPTION: FFmpeg command to push a video file as FLV over HTTP POST to SRS's stream caster on port 8936.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/streamer.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy \\\n    -f flv http://127.0.0.1:8936/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with HTTP-FLV Config\nDESCRIPTION: Docker command to run SRS server with HTTP-FLV live streaming configuration\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/flv.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  ./objs/srs -c conf/http.flv.live.conf\n```\n\n----------------------------------------\n\nTITLE: HLS Cluster Architecture Diagram\nDESCRIPTION: Text diagram showing the architecture of an HLS cluster with FFmpeg/OBS streaming to SRS Origin, which sends HLS to NGINX servers that distribute to visitors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n+------------+          +------------+          +------------+          +------------+\n+ FFmpeg/OBS +--RTMP-->-+ SRS Origin +--HLS-->--+ NGINX      +--HLS-->--+ Visitors   +\n+------------+          +------------+          + Servers    +          +------------+\n                                                +------------+          \n```\n\n----------------------------------------\n\nTITLE: Configuring EXEC in SRS Server\nDESCRIPTION: Configuration snippet showing how to enable and configure EXEC functionality in SRS server. It demonstrates setting up command execution on stream publish events with various available variables like vhost, port, app, stream, and URL parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/nginx-exec.md#2025-04-23_snippet_0\n\nLANGUAGE: conf\nCODE:\n```\nvhost __defaultVhost__ {\n    # the exec used to fork process when got some event.\n    exec {\n        # whether enable the exec.\n        # default: off.\n        enabled     off;\n        # when publish stream, exec the process with variables:\n        #       [vhost] the input stream vhost.\n        #       [port] the intput stream port.\n        #       [app] the input stream app.\n        #       [stream] the input stream name.\n        #       [engine] the tanscode engine name.\n        # other variables for exec only:\n        #       [url] the rtmp url which trigger the publish.\n        #       [tcUrl] the client request tcUrl.\n        #       [swfUrl] the client request swfUrl.\n        #       [pageUrl] the client request pageUrl.\n        # @remark empty to ignore this exec.\n        publish     ./objs/ffmpeg/bin/ffmpeg -f flv -i [url] -c copy -y ./[stream].flv;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code\nDESCRIPTION: Command to update an existing SRS codebase using Git.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Multiple Level App and Stream Structure (Not Recommended)\nDESCRIPTION: Example of not recommended multiple level app and stream URL structure in SRS, which can confuse users by having multiple path segments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n// Not recomment multiple level app and stream, which confuse people.\nrtmp://demo.srs.com/show/live/livestream\nrtmp://demo.srs.com/show/live/livestream/2013\n```\n\n----------------------------------------\n\nTITLE: Installing Cross-Build Toolchain for aarch64 in Ubuntu - Shell\nDESCRIPTION: This snippet shows how to install the cross-compilation toolchain for aarch64 (ARMv8) on Ubuntu 20 using apt-get. Key packages are gcc-aarch64-linux-gnu and g++-aarch64-linux-gnu. Dependencies: Ubuntu 20 container or host with apt package manager. This enables cross-compiling applications for aarch64. Ensure package manager access and proper permissions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/arm.md#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n```\napt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG Log Verbosity in SRS (Bash)\nDESCRIPTION: Demonstrates configuring the SRS transcode engine to reduce FFMPEG's log output level to 'quiet'. This is achieved by adding the `-v quiet` parameter via the `vfilter` block within the `engine ff` configuration. This helps manage potentially large log file sizes generated by FFMPEG processes forked by SRS. Requires SRS and FFMPEG.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n                # -v quiet\n                v           quiet;\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Client Deletion using curl HTTP DELETE\nDESCRIPTION: This shows how to kick off a connected client using the curl command with the HTTP DELETE method, as well as how to query client information with GET.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncurl -v -X GET http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\ncurl -v -X DELETE http://192.168.1.170:1985/api/v1/clients/426 && echo \"\"\n```\n\n----------------------------------------\n\nTITLE: Pushing Changes to Contributor's Fork (TOC Workflow) using Bash\nDESCRIPTION: After making necessary updates to the contributor's branch locally, this command pushes the changes from the maintainer's (TOC) local copy of the branch (`bugfix/fix-srt-url`) back to the `tmp` remote (the contributor's fork). This updates the Pull Request automatically on GitHub.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit push tmp bugfix/fix-srt-url\n```\n\n----------------------------------------\n\nTITLE: Updating Local SRS Repository - Bash\nDESCRIPTION: This one-line snippet updates the existing SRS local repository using Git. It fetches the latest changes from the remote origin to keep the local environment up to date. Dependency: a pre-existing cloned SRS repository and Git. No parameters except the context directory. Input: none. Output: updated SRS source files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Running SRS with HTTPS Support\nDESCRIPTION: Start SRS server with HTTPS configuration for WebRTC support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/https.rtc.conf\n```\n\n----------------------------------------\n\nTITLE: DVR Workflow Diagram\nDESCRIPTION: A text-based diagram showing the workflow of the DVR system, illustrating how FFmpeg/OBS publishes RTMP streams to SRS, which then records them to FLV/MP4 files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/dvr.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+------------+            +-------+           +---------------+\n+ FFmpeg/OBS +---RTMP-->--+  SRS  +---DVR-->--+ FLV/MP4 File  +\n+------------+            +-------+           +---------------+\n```\n\n----------------------------------------\n\nTITLE: App-Specific Transcode Configuration\nDESCRIPTION: Configuration example showing how to apply transcoding to specific applications in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    # applive\n    transcode live{\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS on ARM Platform\nDESCRIPTION: Command to start SRS on an ARM platform using the console configuration file, which provides a minimal setup for testing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to Cross-Compiled ARMv7 SRS\nDESCRIPTION: Uses FFmpeg on the host machine to publish a test stream (`doc/source.flv`) to the SRS server running inside the ARMv7 Docker container. This command targets the mapped RTMP port 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: HTTP Last-Modified Header Example\nDESCRIPTION: Example showing the correct format for a Last-Modified header with an HTTP date value.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_79\n\nLANGUAGE: HTTP\nCODE:\n```\nLast-Modified: Tue, 15 Nov 1994 12:45:26 GMT\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream to SRS Edge using FFmpeg\nDESCRIPTION: This command uses FFmpeg to publish a local video file (`./doc/source.flv`) as an RTMP stream to the SRS edge server. The `-re` option reads the input at its native frame rate, `-c copy` copies the streams without re-encoding, and `-f flv` specifies the output format. The stream is published to the URL `rtmp://28.170.32.118/live/livestream`, where `28.170.32.118` should be replaced with the actual External IP (EIP) of the SRS edge service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://28.170.32.118/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Defining Header Field Syntax in ABNF\nDESCRIPTION: Defines the meta-syntax for header fields in ARPA Internet text messages, showing how fields should be structured with field names, field bodies, and proper line termination.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_12\n\nLANGUAGE: ABNF\nCODE:\n```\nfield       =  field-name \":\" [ field-body ] CRLF\n\nfield-name  =  1*<any CHAR, excluding CTLs, SPACE, and \":\">\n\nfield-body  =  field-body-contents\n                [CRLF LWSP-char field-body]\n\nfield-body-contents =\n               <the ASCII characters making up the field-body, as\n                defined in the following sections, and consisting\n                of combinations of atom, quoted-string, and\n                specials tokens, or else consisting of texts>\n```\n\n----------------------------------------\n\nTITLE: Starting Multiple SRS Slave Instances\nDESCRIPTION: These bash commands start two SRS slave server instances in the background (`nohup ... &`). Each command launches the SRS executable (`./objs/srs`) with a specific configuration file (`-c srs.1935.conf` and `-c srs.1936.conf` respectively), corresponding to the configurations defined previously. Output and errors are redirected to `/dev/null` to prevent console clutter. This demonstrates running multiple SRS processes listening on different ports on the same slave machine.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/forward.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnohup ./objs/srs -c srs.1935.conf >/dev/null 2>&1 &\nnohup ./objs/srs -c srs.1936.conf >/dev/null 2>&1 &\n```\n\n----------------------------------------\n\nTITLE: Running SRS in aarch64 Docker Environment\nDESCRIPTION: Command to run the cross-compiled SRS binary in an aarch64 Docker container.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 arm64v8/ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Installing ARM Cross-Compilation Toolchain\nDESCRIPTION: Command to install ARM cross-compilation tools in an Ubuntu environment. This is required for cross-building SRS for ARM platforms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: SRS Configure Options for Cross-Building\nDESCRIPTION: Overview of the SRS configuration options available for cross-building for different architectures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./configure -h\n\nPresets:\n  --cross-build             Enable cross-build, please set bellow Toolchain also. Default: off\n  \nCross Build options:        @see https://ossrs.io/lts/en-us/docs/v5/doc/arm#ubuntu-cross-build-srs\n  --cpu=<CPU>               Toolchain: Select the minimum required CPU. For example: --cpu=24kc\n  --arch=<ARCH>             Toolchain: Select architecture. For example: --arch=aarch64\n  --host=<BUILD>            Toolchain: Build programs to run on HOST. For example: --host=aarch64-linux-gnu\n  --cross-prefix=<PREFIX>   Toolchain: Use PREFIX for tools. For example: --cross-prefix=aarch64-linux-gnu-\n\nToolchain options:\n  --static=on|off           Whether add '-static' to link options. Default: off\n  --cc=<CC>                 Toolchain: Use c compiler CC. Default: gcc\n  --cxx=<CXX>               Toolchain: Use c++ compiler CXX. Default: g++\n  --ar=<AR>                 Toolchain: Use archive tool AR. Default: g++\n  --ld=<LD>                 Toolchain: Use linker tool LD. Default: g++\n  --randlib=<RANDLIB>       Toolchain: Use randlib tool RANDLIB. Default: g++\n  --extra-flags=<EFLAGS>    Set EFLAGS as CFLAGS and CXXFLAGS. Also passed to ST as EXTRA_CFLAGS.\n```\n\n----------------------------------------\n\nTITLE: FMLE Stream Configuration\nDESCRIPTION: RTMP configuration parameters for Adobe Flash Media Live Encoder (FMLE).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Setting Process Priority for SRS using renice\nDESCRIPTION: This command increases the priority of the SRS process by setting a negative nice value, which can improve its CPU scheduling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nrenice -n -15 -p $(pidof srs)\n```\n\n----------------------------------------\n\nTITLE: Interpreting GPERF CPU Profiler (gcp) Results with pprof in Bash\nDESCRIPTION: Displays example output generated by running `pprof --text` on CPU profile data (`gperf.srs.gcp*`) collected by gcp during SRS execution. It shows the total number of samples collected and lists functions consuming the most CPU time (based on samples), helping identify performance bottlenecks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/pprof --text objs/srs gperf.srs.gcp*\nUsing local file objs/srs.\nUsing local file gperf.srs.gcp.\nRemoving _L_unlock_16 from all stack traces.\nTotal: 20 samples\n       8  40.0%  40.0%        8  40.0% 0x00007fff0ea35917\n       4  20.0%  60.0%        4  20.0% __epoll_wait_nocancel\n       2  10.0%  70.0%        2  10.0% __read_nocancel\n       1   5.0%  95.0%        1   5.0% memset\n       1   5.0% 100.0%        1   5.0% tc_delete\n       0   0.0% 100.0%        5  25.0% 0x00007f9fad927c4f\n       0   0.0% 100.0%        2  10.0% SrsBuffer::ensure_buffer_bytes\n       0   0.0% 100.0%        5  25.0% SrsClient::do_cycle\n       0   0.0% 100.0%        5  25.0% SrsClient::fmle_publish\n       0   0.0% 100.0%        1   5.0% SrsClient::process_publish_message\n```\n\n----------------------------------------\n\nTITLE: Installing logrotate using Yum package manager\nDESCRIPTION: Command to install logrotate package on systems using Yum package manager.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/log-rotate.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum install -y logrotate\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 5.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to development branch (used for 5.0 when no release branch exists)\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout develop\n```\n\n----------------------------------------\n\nTITLE: Adding SRS Service with update-rc.d - Bash\nDESCRIPTION: Registers the SRS service with Ubuntu's update-rc.d tool for automatic boot/startup. Requires the init.d script to be in place. No user parameters; integrates SRS with traditional SysV startup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n#ubuntu12\\nsudo update-rc.d srs defaults\n```\n\n----------------------------------------\n\nTITLE: Checking Certificate Renewal Logs\nDESCRIPTION: Bash command to examine the Docker container logs for certificate renewal activity, showing whether the automated renewal process is functioning properly.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-12-Oryx-HTTPS.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker logs platform |grep renew\n```\n\n----------------------------------------\n\nTITLE: Callback-Based SRT Data Handling in C++\nDESCRIPTION: This code demonstrates the callback-based approach for handling SRT data. It shows the event loop, data handling for different socket statuses, and the process of reading data from the SRT connection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nwhile (run_flag) {\n  int ret = srt_epoll_wait(_pollid, read_fds, &rfd_num, write_fds);\n  for (int index = 0; index < rfd_num; index++) {\n    SRT_SOCKSTATUS status = srt_getsockstate(read_fds[index]);\n    srt_handle_data(status, read_fds[index], \"read fd\");\n  }\n}\n\nvoid srt_handle::handle_srt_socket(SRT_SOCKSTATUS status, SRTSOCKET conn_fd) {\n  auto conn_ptr = get_srt_conn(conn_fd);\n  int mode = conn_ptr->get_mode();\n  if (mode == PUSH_SRT_MODE && status == SRTS_CONNECTED) {\n    handle_push_data(status, path, subpath, conn_fd);\n  }\n}\n\nvoid srt_handle::handle_push_data(SRT_SOCKSTATUS status, SRTSOCKET conn_fd) {\n  srt_conn_ptr = get_srt_conn(conn_fd);\n  if (status != SRTS_CONNECTED) { // Error.\n    close_push_conn(conn_fd);\n    return;\n  }\n\n  ret = srt_conn_ptr->read_async(data, DEF_DATA_SIZE);\n  if (ret <= 0) { // Error.\n    if (srt_getlasterror(NULL) != SRT_EASYNCRCV) {\n      return;\n    }\n    close_push_conn(conn_fd);\n    return;\n  }\n\n  srt2rtmp::get_instance()->insert_data_message(data, ret, subpath);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Build with HDS Support\nDESCRIPTION: Command to configure SRS build with HDS support enabled. This is done during the compilation process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/delivery-hds.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --hds=on\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code (Bash)\nDESCRIPTION: Updates the local SRS repository to the latest version from the remote GitHub repository using the `git pull` command. Use this command if you have previously cloned the repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Build with HDS Support\nDESCRIPTION: Command to enable HDS support when building SRS from source\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/delivery-hds.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --hds=on\n```\n\n----------------------------------------\n\nTITLE: Launching SRS and Analyzing Startup Logs - Bash\nDESCRIPTION: This snippet illustrates the process of starting the SRS server and viewing its log output, showing typical log statements generated at startup. It requires a compiled SRS binary and a valid configuration file. Command outputs reveal runtime environment, version, build settings, ports listened to, and process identifiers; this is useful for confirming the system's operational parameters and initial state after launch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c console.conf \n[winlin@dev6 srs]$ cat objs/srs.log \n[2014-04-04 11:39:24.176][trace][0][0] config parsed EOF\n[2014-04-04 11:39:24.176][trace][0][0] log file is ./objs/srs.log\n[2014-04-04 11:39:24.177][trace][0][0] srs 0.9.46\n[2014-04-04 11:39:24.177][trace][0][0] uname: Linux dev6 2.6.32-71.el6.x86_64 \n#1 SMP Fri May 20 03:51:51 BST 2011 x86_64 x86_64 x86_64 GNU/Linux\n[2014-04-04 11:39:24.177][trace][0][0] build: 2014-04-03 18:38:23, little-endian\n[2014-04-04 11:39:24.177][trace][0][0] configure:  --dev --with-hls --with-nginx \n--with-ssl --with-ffmpeg --with-http-callback --with-http-server --with-http-api \n--with-librtmp --with-bwtc --with-research --with-utest --without-gperf --without-gmc \n--without-gmp --without-gcp --without-gprof --without-arm-ubuntu12 --jobs=1 \n--prefix=/usr/local/srs\n[2014-04-04 11:39:24.177][trace][0][0] write pid=4021 to ./objs/srs.pid success!\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1935, type=0, fd=6\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=1985, type=1, fd=7\n[2014-04-04 11:39:24.177][trace][100][16] server started, listen at port=8080, type=2, fd=8\n[2014-04-04 11:39:24.177][trace][101][16] listen cycle start, port=1935, type=0, fd=6\n[2014-04-04 11:39:24.177][trace][102][11] listen cycle start, port=1985, type=1, fd=7\n[2014-04-04 11:39:24.177][trace][103][11] listen cycle start, port=8080, type=2, fd=8\n[2014-04-04 11:39:26.799][trace][0][11] get a signal, signo=2\n[2014-04-04 11:39:26.799][trace][0][11] user terminate program\n```\n\n----------------------------------------\n\nTITLE: Configuring Origin Cluster in SRS\nDESCRIPTION: This configuration snippet shows how to set up an Origin Cluster in SRS. It includes settings for cluster mode, enabling the origin cluster functionality, and specifying coworkers (other origin servers in the cluster) via their HTTP API addresses.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    # The config for cluster.\n    cluster {\n        # The cluster mode, local or remote.\n        #       local: It's an origin server, serve streams itself.\n        #       remote: It's an edge server, fetch or push stream to origin server.\n        # default: local\n        mode            local;\n\n        # For origin(mode local) cluster, turn on the cluster.\n        # @remark Origin cluster only supports RTMP, use Edge to transmux RTMP to FLV.\n        # default: off\n        # TODO: FIXME: Support reload.\n        origin_cluster      on;\n\n        # For origin (mode local) cluster, the co-worker's HTTP APIs.\n        # This origin will connect to co-workers and communicate with them.\n        # please read: https://ossrs.net/lts/zh-cn/docs/v4/doc/origin-cluster\n        # TODO: FIXME: Support reload.\n        coworkers           127.0.0.1:9091 127.0.0.1:9092;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pausing and Resuming Kubernetes Deployment Rollouts (Bash)\nDESCRIPTION: These commands demonstrate how to control the rollout process of a Kubernetes Deployment ('srs-edge-deploy' in this case). `kubectl rollout pause` prevents further changes from being rolled out until resumed. `kubectl rollout resume` allows the rollout process to continue. This is useful for temporarily halting an update if issues are observed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nkubectl rollout pause deploy/srs-edge-deploy\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl rollout resume deploy/srs-edge-deploy\n```\n\n----------------------------------------\n\nTITLE: Packaging SRS into a Windows Installer using NSIS (Bash/Cygwin)\nDESCRIPTION: Shows the command to create a Windows installer package (`.exe`) for the compiled SRS application using NSIS (Nullsoft Scriptable Install System) from within a Cygwin terminal. It dynamically retrieves the SRS version using `./objs/srs -v` and specifies the Cygwin installation path (`C:\\cygwin64`) as parameters for the NSIS script located at `packaging/nsis/srs.nsi`. Requires NSIS to be installed on the Windows host, typically at `C:\\Program Files (x86)\\NSIS`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/windows.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"/cygdrive/c/Program Files (x86)/NSIS/makensis.exe\" \\\n    /DSRS_VERSION=$(./objs/srs -v 2>&1) \\\n    /DCYGWIN_DIR=\"C:\\cygwin64\" \\\n    packaging/nsis/srs.nsi\n```\n\n----------------------------------------\n\nTITLE: Starting SRS service\nDESCRIPTION: Command to start the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: NGINX Debug Logging Configuration\nDESCRIPTION: NGINX logging configuration to track cache status and debug cache effectiveness.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nlog_format  main  '$upstream_cache_status $remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\naccess_log  /var/log/nginx/access.log main;\n```\n\n----------------------------------------\n\nTITLE: FFmpeg MPEG-TS Push Command\nDESCRIPTION: FFmpeg command to push MPEG-TS stream over UDP to SRS\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/streamer.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy -f mpegts udp://127.0.0.1:8935\n```\n\n----------------------------------------\n\nTITLE: Playing SRT Stream using FFplay\nDESCRIPTION: This command uses FFplay to play an SRT stream from SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 2.0 Branch using Git\nDESCRIPTION: Command to pull the latest changes and switch to the SRS 2.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/git.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: Starting SRS manually from trunk directory\nDESCRIPTION: This command demonstrates how to start SRS manually from the trunk directory without adding it as a system service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\n./etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Manual Log Rotation for SRS\nDESCRIPTION: Steps to manually rotate the SRS log file by moving it, sending a signal to SRS, and then managing the rotated file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log-rotate.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nmv objs/srs.log /tmp/srs.`date +%s`.log\n```\n\nLANGUAGE: bash\nCODE:\n```\nkillall -s SIGUSR1\n```\n\n----------------------------------------\n\nTITLE: Encoding an HEVC MP4 Using FFmpeg with libx265 - Bash\nDESCRIPTION: This snippet shows how to encode an input FLV video file to an HEVC-encoded MP4 using FFmpeg and libx265 while copying over the original audio. Appropriate for creating test files to verify HEVC support in players or browsers (e.g., Chrome 105+ with MSE). Requires ffmpeg with libx265 enabled. Input: FLV file path; Output: .mp4 file encoded as HEVC video with original audio. Limitation: Source file and output directories must be accessible.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -i ~/git/srs/trunk/doc/source.flv -acodec copy \\\n  -vcodec libx265 -y source.hevc.mp4\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Docker Container for Live Streaming\nDESCRIPTION: Launches SRS server in Docker container exposing RTMP (1935), HTTP API (1985) and HTTP streaming (8080) ports\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 \\\n    registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Running srs-bench Container for HTTP-FLV Load Testing - Bash\nDESCRIPTION: Executes an ossrs/srs:sb Docker container to run the sb_http_load tool with 500 simulated concurrent clients targeting an HTTP-FLV stream. Requires Docker, input FLV stream URL, and sufficient system resources. Parameters mirror the HLS load test but target FLV endpoints, useful for benchmarking both protocols under stress.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_http_load -c 500 \\\n  -r http://your_server_public_ipv4/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: SRS Transcoder Configuration for Snapshots\nDESCRIPTION: Configuration file for SRS that uses the transcoder feature to generate periodic snapshots as PNG files\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/snapshot.md#2025-04-23_snippet_2\n\nLANGUAGE: conf\nCODE:\n```\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    transcode {\n        enabled on;\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine snapshot {\n            enabled on;\n            iformat flv;\n            vfilter {\n                vf fps=1;\n            }\n            vcodec png;\n            vparams {\n                vframes 6;\n            }\n            acodec an;\n            oformat image2;\n            output ./objs/nginx/html/[app]/[stream]-%03d.png;\n        }\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up HiSilicon Cross-Compilation Tools\nDESCRIPTION: Commands to setup the HiSilicon cross-compilation toolchain after downloading it from the vendor or other sources.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nchmod +x arm-hisiv500-linux.install\n./arm-hisiv500-linux.install\nsource /etc/profile\n```\n\n----------------------------------------\n\nTITLE: Implementing Round Robin Load Balancing in C++\nDESCRIPTION: This snippet demonstrates a simple round-robin load balancing strategy where the next server is selected from a list of servers in a circular manner. It's effective for balanced, short-lived requests but may not be ideal for long-lived streaming connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-05-16-Load-Balancing-Streaming-Servers.md#2025-04-23_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nserver = servers[pos++ % servers.length()]\n```\n\n----------------------------------------\n\nTITLE: Visualizing Live Streaming Architecture with ASCII Diagram\nDESCRIPTION: A simple ASCII diagram showing the basic architecture of live streaming, with an encoder sending data through SRS/CDN Network to the player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/client-sdk.md#2025-04-23_snippet_0\n\nLANGUAGE: ascii\nCODE:\n```\n+---------+      +-----------------+       +---------+\n| Encoder +-->---+ SRS/CDN Network +--->---+ Player  |\n+---------+      +-----------------+       +---------+\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimum Latency for SRS Vhost\nDESCRIPTION: This configuration enables minimum latency mode for an SRS vhost, disabling merged-read and using timeout for consumer queue.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    # whether enable min delay mode for vhost.\n    # for min latence mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off\n    min_latency     off;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Timestamp Jitter for DVR in SRS\nDESCRIPTION: Configuration example for setting timestamp jitter behavior for the DVR (Digital Video Recording) component in SRS. Similar to RTMP delivery, it offers 'full', 'zero', and 'off' options to handle timestamps when recording streams to files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/time-jitter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost dvr.srs.com {\n    # dvr RTMP stream to file,\n    # start to record to file when encoder publish,\n    # reap flv according by specified dvr_plan.\n    # http callbacks:\n    # @see http callback on_dvr_hss_reap_flv on http_hooks section.\n    dvr {\n        # about the stream monotonically increasing:\n        #   1. video timestamp is monotonically increasing, \n        #   2. audio timestamp is monotonically increasing,\n        #   3. video and audio timestamp is interleaved monotonically increasing.\n        # it's specified by RTMP specification, @see 3. Byte Order, Alignment, and Time Format\n        # however, some encoder cannot provides this feature, please set this to off to ignore time jitter.\n        # the time jitter algorithm:\n        #   1. full, to ensure stream start at zero, and ensure stream monotonically increasing.\n        #   2. zero, only ensure sttream start at zero, ignore timestamp jitter.\n        #   3. off, disable the time jitter algorithm, like atc.\n        # default: full\n        time_jitter             full;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using GPERF Tools (GCP, GMD, GMC, GMP) with SRS\nDESCRIPTION: Instructions for using various GPERF tools including GCP (CPU profiler), GMD (memory debugger), GMC (memory checker), and GMP (memory profiler) with SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GCP\n./configure --gperf=on --gcp=on && make\n\n# Start SRS with GCP\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop GCP\nkillall -2 srs\n\n# To analysis cpu profile\n./objs/pprof --text objs/srs gperf.srs.gcp*\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Source Code via Gitee Mirror using Shell\nDESCRIPTION: This shell snippet demonstrates cloning the SRS repository from Gitee, then updating the remote URL to GitHub and pulling the latest code. Dependencies include Git installed on the system and network access to both Gitee and GitHub. It requires no parameters and produces a local 'srs' directory with the synchronized source code. The process assumes the user has permissions to pull from GitHub; suitable for users in regions where GitHub access is slow or restricted.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/resource.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://gitee.com/ossrs/srs.git &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: Command to clone the SRS repository from GitHub, using the develop branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Compiled aarch64 SRS in Docker\nDESCRIPTION: Navigates to the SRS source directory on the host and runs the cross-compiled SRS binary inside an `arm64v8/ubuntu` Docker container. It mounts the host's SRS directory, maps the necessary ports (1935, 1985, 8080), and executes the `srs` binary with the specified configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 arm64v8/ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source in Bash\nDESCRIPTION: This snippet demonstrates how to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring Vhosts with Different Chunk Sizes\nDESCRIPTION: Example of configuring two vhosts with different chunk sizes in SRS, showing how to customize settings for different virtual hosts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n    chunk_size 128;\n}\nvhost show.wasu.cn {\n    chunk_size 4906;\n}\n```\n\n----------------------------------------\n\nTITLE: CPU Affinity Configuration for SRS and Softirq\nDESCRIPTION: Shows how to set CPU affinity for SRS and softirq handling to optimize performance on multi-core systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ntaskset -p 0xfe $(pidof srs)\n\ntaskset -pc 1 $(pidof srs)\n\nfor irq in $(grep virtio /proc/interrupts | grep -e in -e out | cut -d: -f1); do \n    echo 1 > /proc/irq/$irq/smp_affinity\ndone\n\ntaskset -a -p 0xfe $(cat objs/srs.pid)\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository - Bash\nDESCRIPTION: This Bash snippet demonstrates how to clone the official SRS repository from GitHub and enter the main working directory. Requires Git command-line tools. The first command fetches the remote repository, while the second changes directory to the project's trunk folder. No input parameters required; outputs are side-effects (local files and folders created).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Checking System File Descriptor Limits\nDESCRIPTION: Command to view the current file descriptor limits set for the system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/raspberrypi.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\\n10240\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS5.0/Development Branch with Git - Shell\nDESCRIPTION: This snippet checks out the 'develop' branch, which is used for SRS 5.0 or ongoing development in the absence of a '5.0release' branch. The command synchronizes your repository before switching branches. It assumes the user has a local copy of the SRS repository and the appropriate branch exists on the remote.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/git.md#2025-04-23_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit pull && git checkout develop\n```\n\n----------------------------------------\n\nTITLE: Defining Trailer Header Syntax in HTTP/1.1\nDESCRIPTION: Syntax definition of the Trailer general field in HTTP/1.1, which indicates that the given set of header fields is present in the trailer of a message encoded with chunked transfer-coding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_88\n\nLANGUAGE: http\nCODE:\n```\nTrailer  = \"Trailer\" \":\" 1#field-name\n```\n\n----------------------------------------\n\nTITLE: Running SRS with RTMP to WebRTC Configuration\nDESCRIPTION: Start SRS server with RTMP to WebRTC conversion configuration\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 1.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS version 1.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/git.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 1.0release\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Streaming Loop Command\nDESCRIPTION: Bash script that continuously streams a source video file using FFMPEG to an RTMP endpoint, copying audio and video codecs without re-encoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/raspberrypi.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://192.168.1.105:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: Building libx264 Dependency from Source - Bash\nDESCRIPTION: This sequence illustrates cloning, configuring, compiling, and installing the x264 library from source for subsequent FFmpeg builds. It disables assembly, CLI, and shared libraries, enabling a static build required for compatibility in certain carefully controlled environments (e.g., static linking into FFmpeg). Prerequisites include build tools (make, gcc), internet connectivity, and write permissions to the user's home directory. Input: none; Output: Installed libx264 static library in a user-local build directory; Note: Run as a user with sufficient permissions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://code.videolan.org/videolan/x264.git ~/git/x264\ncd ~/git/x264\n./configure --prefix=$(pwd)/build --disable-asm --disable-cli --disable-shared --enable-static\nmake -j10\nmake install\n```\n\n----------------------------------------\n\nTITLE: Transferring SRS Files to ARM Device in Bash\nDESCRIPTION: SCP commands to transfer the compiled SRS binary and configuration file to an ARM device running in a virtual machine.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-arm.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Password isroot\nscp -P 2200 objs/srs  root@localhost:~\nscp -P 2200 conf/rtmp.conf root@localhost:~\n```\n\n----------------------------------------\n\nTITLE: Playing HEVC Video Stream via SRT using FFplay\nDESCRIPTION: Command to play an HEVC-encoded video stream received over SRT protocol using FFplay. It connects to the SRT server and requests the livestream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/srt-codec.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::h=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Measuring Network Traffic with dstat (bash)\nDESCRIPTION: Runs 'dstat' to monitor the loopback network interface (lo) every 30 seconds, displaying CPU, disk, and network I/O for server performance validation. Prerequisite: dstat package installed. Output fields include per-interval bytes received and sent.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# dstat -N lo 30\n----total-cpu-usage---- -dsk/total- -net/lo- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  0   0  96   0   0   3|   0     0 |1860B   58k|   0     0 |2996   465 \n  0   1  96   0   0   3|   0     0 |1800B   56k|   0     0 |2989   463 \n  0   0  97   0   0   2|   0     0 |1500B   46k|   0     0 |2979   461 \n```\n\n----------------------------------------\n\nTITLE: Checking SRS service status\nDESCRIPTION: Command to check the current status of the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs status\n```\n\n----------------------------------------\n\nTITLE: Configuring RTMP Publisher Disconnect on Idle in SRS\nDESCRIPTION: This configuration snippet sets the timeout for disconnecting an RTMP publisher when there are no active viewers. It's used for implementing on-demand streaming where the stream is only active when viewers are present.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# The timeout in seconds to disconnect publisher when idle, which means no players.\n# Note that 0 means no timeout or this feature is disabled.\n# Note that this feature conflicts with forward, because it disconnect the publisher stream.\n# Overwrite by env SRS_VHOST_PUBLISH_KICKOFF_FOR_IDLE for all vhosts.\n# default: 0\nkickoff_for_idle 0;\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Clone the SRS repository from GitHub to get the source code needed for the RTMP cluster deployment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Profiling C++ Application on macOS using Instruments\nDESCRIPTION: This command uses the Instruments tool on macOS to profile a C++ application. It samples the process for 30 seconds using the Time Profiler instrument.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ninstruments -l 30000 -t Time\\ Profiler -p 72030\n```\n\n----------------------------------------\n\nTITLE: Starting Demo HTTP Callback Server\nDESCRIPTION: Command to run a demo HTTP callback server implementation in Go.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo run research/api-server/server.go\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Master Server for Small Cluster\nDESCRIPTION: Configuration for the SRS master server in a small cluster setup, enabling forwarding to multiple slave servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\npid                 ./objs/srs.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 192.168.1.6:1935 192.168.1.6:1936 192.168.1.7:1935 192.168.1.7:1936;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Connection Limit Before SRS Start (Bash)\nDESCRIPTION: Checks the open file descriptor limit immediately before starting the SRS server to ensure the previously set limit (`10240`) is still in effect for the current shell session.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 trunk]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository using Domestic Mirror (Bash)\nDESCRIPTION: Commands to clone the SRS repository from a domestic mirror (Gitee) and set the remote origin to the GitHub repository. This approach speeds up the initial clone for users in certain regions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/git.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://gitee.com/ossrs/srs.git && \ncd srs && git remote set-url origin https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS with GMP (Memory Profiling)\nDESCRIPTION: Command to configure SRS with GPERF support for memory profiling (gmp)\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./configure --with-gperf --with-gmp\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Version\nDESCRIPTION: Shows the SRS version being tested in the performance benchmark.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -v\n0.9.130\n```\n\n----------------------------------------\n\nTITLE: SRT Coroutine Socket Implementation\nDESCRIPTION: Implementation of coroutine-based SRT socket receive functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsSrtSocket::recvmsg(void* buf, size_t size, ssize_t* nread) {\n  while (true) {\n    int ret = srt_recvmsg(srt_fd_, (char*)buf, size);\n    if (ret >= 0) { // Receive message ok.\n      recv_bytes_ += ret; \n      *nread = ret;\n      return err;\n    }\n    \n    // Got something error, return immediately.\n    if (srt_getlasterror(NULL) != SRT_EASYNCRCV) {\n      return srs_error_new(ERROR_SRT_IO, \"srt_recvmsg\");\n    }\n    \n    // Wait for the fd ready or error, switch to other coroutines.\n    if ((err = wait_readable()) != srs_success) { // EAGAIN.\n      return srs_error_wrap(err, \"wait readable\");\n    }\n  }\n  \n  return err;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Repository\nDESCRIPTION: Command to update existing SRS codebase.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with HTTP API Authentication Configuration\nDESCRIPTION: Command to start SRS with the HTTP API authentication configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.api.auth.conf\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS3.0 Branch with Git - Shell\nDESCRIPTION: This snippet shows how to update your local repository and switch to the '3.0release' branch, providing access to the stable SRS 3.0 code. The prerequisite is a cloned SRS repo and a functioning Git installation. The command updates and then switches to the specified release branch, which must exist on the remote.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/git.md#2025-04-23_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit pull && git checkout 3.0release\n```\n\n----------------------------------------\n\nTITLE: Adding SRS as a Service on Ubuntu\nDESCRIPTION: Command to add SRS as a system service on Ubuntu 12.04 using update-rc.d, enabling automatic startup on system boot.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n#ubuntu12\nsudo update-rc.d srs defaults\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker for WebRTC over HTTPS\nDESCRIPTION: Starts an SRS server configured for WebRTC using HTTPS, specified by `conf/https.docker.conf`. This setup is necessary when accessing WebRTC from non-localhost environments, like mobile devices. It requires setting the `CANDIDATE` IP and maps ports including 1990 (HTTPS API) and 8088 (HTTPS Web Server). Actual HTTPS certificate configuration might be needed within the config file or via a reverse proxy.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 1990:1990 -p 8088:8088 \\\n    --env CANDIDATE=$CANDIDATE -p 8000:8000/udp \\\n    ossrs/srs:4 ./objs/srs -c conf/https.docker.conf\n```\n\n----------------------------------------\n\nTITLE: Monitoring SRS Edge Pod Logs During Rolling Update (Bash)\nDESCRIPTION: These commands use `kubectl exec` to tail the logs (`objs/srs.log`) of specific SRS edge pods that are being replaced during the rolling update. The logs demonstrate the graceful shutdown process: SRS receives the signal (`sig=3` or `signo=15` due to `force_grace_quit`), initiates cleanup (`cleanup for quit signal fast=0, grace=1`), waits for existing connections to close (`wait for X conns to quit`), and finally terminates. This confirms that the graceful shutdown configuration is working as expected, minimizing disruption to connected clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nkubectl exec srs-edge-deploy-58d9999b7c-pnr2f -- tail -f objs/srs.log\n[2020-02-19 11:07:20.818][Trace][1][937] sig=3, user start gracefully quit\n[2020-02-19 11:07:20.960][Trace][1][937] force gracefully quit, signo=15\n[2020-02-19 11:07:21.772][Trace][1][932] cleanup for quit signal fast=0, grace=1\n[2020-02-19 11:07:21.772][Warn][1][932][11] main cycle terminated, system quit normally.\ncommand terminated with exit code 137\n\nkubectl exec srs-edge-deploy-58d9999b7c-z9gbm -- tail -f objs/srs.log\n[2020-02-19 11:07:23.095][Trace][1][1009] sig=3, user start gracefully quit\n[2020-02-19 11:07:23.316][Trace][1][1009] force gracefully quit, signo=15\n[2020-02-19 11:07:23.784][Trace][1][1004] cleanup for quit signal fast=0, grace=1\n[2020-02-19 11:07:23.784][Warn][1][1004][11] main cycle terminated, system quit normally.\n[2020-02-19 11:07:24.784][Trace][1][1004] wait for 1 conns to quit\n[2020-02-19 11:07:26.968][Trace][1][1010] <- CPB time=120041497, okbps=0,0,0, ikbps=252,277,0, mr=0/350, p1stpt=20000, pnt=5000\n[2020-02-19 11:08:26.791][Trace][1][1004] wait for 1 conns to quit\n[2020-02-19 11:08:52.602][Trace][1][1010] edge change from 200 to state 0 (init).\n[2020-02-19 11:08:52.792][Trace][1][1004] wait for 0 conns to quit\ncommand terminated with exit code 137\n```\n\n----------------------------------------\n\nTITLE: Installing and configuring SRS with systemctl on Ubuntu 20\nDESCRIPTION: This command sequence installs SRS, sets up the init.d script, configures systemctl, and enables the SRS service for Ubuntu 20.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && sudo make install &&\nsudo ln -sf /usr/local/srs/etc/init.d/srs /etc/init.d/srs &&\nsudo cp -f /usr/local/srs/usr/lib/systemd/system/srs.service /usr/lib/systemd/system/srs.service &&\nsudo systemctl daemon-reload && sudo systemctl enable srs\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS to Use System SSL Libraries (Bash)\nDESCRIPTION: This command configures the SRS build process to link against the system-installed OpenSSL libraries (`libssl.so` and `libcrypto.so`) instead of potentially using a bundled version. This is useful for managing dependencies and potentially avoiding OpenSSL license compatibility issues mentioned in the text.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/license.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --use-sys-ssl\n```\n\n----------------------------------------\n\nTITLE: Playing HEVC WebRTC Stream in Safari\nDESCRIPTION: URL for playing an HEVC WebRTC stream using WHEP protocol in Safari. This requires enabling the experimental WebRTC H265 codec feature in Safari's settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_13\n\nLANGUAGE: markdown\nCODE:\n```\n* Play [http://localhost:1985/rtc/v1/whep/?app=live&stream=livestream&codec=hevc](http://localhost:8080/players/whep.html?autostart=true&codec=hevc)\n```\n\n----------------------------------------\n\nTITLE: Measuring Bandwidth with dstat - Bash\nDESCRIPTION: This shows the use of the 'dstat' monitoring tool for 30-second intervals to measure CPU, disk, and network bandwidth usage. The output is captured on a Linux system by running 'dstat 30'. Dstat must be pre-installed; results include total CPU usage as well as per-interface bandwidth figures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/raspberrypi.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 ~]$ dstat 30\n----total-cpu-usage---- -dsk/total- -net/lo- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  0   0  96   0   0   3|   0     0 |1860B   58k|   0     0 |2996   465 \n  0   1  96   0   0   3|   0     0 |1800B   56k|   0     0 |2989   463 \n  0   0  97   0   0   2|   0     0 |1500B   46k|   0     0 |2979   461 \n\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Read Settings in SRS\nDESCRIPTION: SRS configuration for merged-read settings, which can improve read performance but may increase latency. Includes options for enabling/disabling and setting latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# the MR(merged-read) setting for publisher.\nvhost mrw.srs.com {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # about MR, read https://github.com/ossrs/srs/issues/241\n        # when enabled the mr, SRS will read as large as possible.\n        # default: off\n        mr          off;\n        # the latency in ms for MR(merged-read),\n        # the performance+ when latency+, and memory+,\n        #       memory(buffer) = latency * kbps / 8\n        # for example, latency=500ms, kbps=3000kbps, each publish connection will consume\n        #       memory = 500 * 3000 / 8 = 187500B = 183KB\n        # when there are 2500 publisher, the total memory of SRS atleast:\n        #       183KB * 2500 = 446MB\n        # the value recomment is [300, 2000]\n        # default: 350\n        mr_latency  350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example API Server Log for on_dvr Callback\nDESCRIPTION: This log snippet shows the output from an API server receiving the `on_dvr` HTTP callback from SRS. It includes trace logs detailing the received JSON payload containing information about the DVR event (action, client details, stream info, file path) and an access log entry showing the successful POST request from the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/dvr.md#2025-04-23_snippet_3\n\nLANGUAGE: Log\nCODE:\n```\n[2015-01-03 15:25:48][trace] post to dvrs, req={\"action\":\"on_dvr\",\"client_id\":108,\"ip\":\"127.0.0.1\",\"vhost\":\"__defaultVhost__\",\"app\":\"live\",\"stream\":\"livestream\",\"cwd\":\"/home/winlin/git/srs/trunk\",\"file\":\"./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\"}\n[2015-01-03 15:25:48][trace] srs on_dvr: client id=108, ip=127.0.0.1, vhost=__defaultVhost__, app=live, stream=livestream, cwd=/home/winlin/git/srs/trunk, file=./objs/nginx/html/live/livestream/2015/1/3/15.25.18.442.flv\n127.0.0.1 - - [03/Jan/2015:15:25:48] \"POST /api/v1/dvrs HTTP/1.1\" 200 1 \"\" \"SRS(Simple RTMP Server)2.0.88\"\n```\n\n----------------------------------------\n\nTITLE: Verifying HiSilicon Toolchain Installation\nDESCRIPTION: Command to verify that the HiSilicon cross-compilation toolchain is correctly installed and accessible in the system path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nwhich arm-hisiv500-linux-g++\n# /opt/hisi-linux/x86-arm/arm-hisiv500-linux/target/bin/arm-hisiv500-linux-g++\n```\n\n----------------------------------------\n\nTITLE: Enabling HDS in SRS Build Process - Shell\nDESCRIPTION: This shell command enables the HDS module during the SRS build process by passing the --hds=on flag to the configuration script. No extra dependencies are needed beyond the standard build environment for SRS. It must be executed in a shell before compiling the server, and toggles HDS support as part of the build output.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hds.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./configure --hds=on\n```\n\n----------------------------------------\n\nTITLE: Cloning and Syncing SRS Repository from Gitee Mirror - Bash Shell\nDESCRIPTION: This snippet demonstrates how to clone the SRS project from Gitee, change into the project directory, update the remote origin to Github, and pull the latest changes. Dependencies include git and network access to the relevant repository URLs. The key parameters are the source URL for cloning and the target URL for setting the new origin; the result is a local Git repository updated from the official Github source. Useful for users who need to bypass regional network restrictions or prefer Gitee as an initial mirror.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/resource.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/ossrs/srs.git &&\\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Configuring Min-Latency Settings in SRS\nDESCRIPTION: Configuration for enabling minimum latency mode in SRS vhost. This disables merged-read and uses timeout condition wait to achieve lower latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    # whether enable min delay mode for vhost.\n    # for min latence mode:\n    # 1. disable the publish.mr for vhost.\n    # 2. use timeout for cond wait for consumer queue.\n    # @see https://github.com/ossrs/srs/issues/257\n    # default: off\n    min_latency     off;\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with SRT Support\nDESCRIPTION: Command to run SRS server in a Docker container with SRT protocol support. Exposes ports 1935 (RTMP), 8080 (HTTP), and 10080 (SRT/UDP).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 -p 10080:10080/udp ossrs/srs:5 \\\n  ./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository using Git (Bash)\nDESCRIPTION: This snippet demonstrates how to download the SRS source code from its official GitHub repository using the `git clone` command and then navigates into the `trunk` directory where the main source code resides.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Configuring On-Demand Live Streaming in SRS\nDESCRIPTION: This snippet shows how to configure the timeout for disconnecting idle publishers in SRS, which is useful for implementing on-demand live streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# The timeout in seconds to disconnect publisher when idle, which means no players.\n# Note that 0 means no timeout or this feature is disabled.\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic Stream URLs in Oryx\nDESCRIPTION: Example URLs showing the basic streaming configuration with authentication secret for publishing and public playback URLs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-08-29-Oryx-Ensuring-Authentication-for-Live-Streaming-Publishing.md#2025-04-23_snippet_0\n\nLANGUAGE: url\nCODE:\n```\nrtmp://135.98.31.15/live/livestream?secret=5181a08ee6eab86597e913e1f9e4c294\nhttp://135.98.31.15/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Viewing File Descriptor Limit on Linux - Bash\nDESCRIPTION: This Bash snippet retrieves the current open file descriptor limit for the active shell user. It uses the 'ulimit -n' command, typically after the limit is set using 'ulimit -HSn 10240'. No external dependencies are required beyond core Linux/Bash utilities. The output shows the integer value of the current descriptor limit.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/raspberrypi.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n\n```\n\n----------------------------------------\n\nTITLE: Deploying Oryx Server with Docker\nDESCRIPTION: A Docker command to create and run an Oryx server instance. This command sets up a container with the necessary port mappings for streaming services and mounts a data volume for persistence.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-01-31-Browser-Voice-Driven-GPT.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Specifying HTTP Date/Time Format Grammar\nDESCRIPTION: Defines the grammar for representing date and time in HTTP headers, including three accepted formats: RFC 1123, RFC 850, and ANSI C's asctime().\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_7\n\nLANGUAGE: HTTP\nCODE:\n```\nHTTP-date    = rfc1123-date | rfc850-date | asctime-date\nrfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\nrfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\nasctime-date = wkday SP date3 SP time SP 4DIGIT\ndate1        = 2DIGIT SP month SP 4DIGIT\n               ; day month year (e.g., 02 Jun 1982)\ndate2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n               ; day-month-year (e.g., 02-Jun-82)\ndate3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n               ; month day (e.g., Jun  2)\ntime         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n               ; 00:00:00 - 23:59:59\nwkday        = \"Mon\" | \"Tue\" | \"Wed\"\n             | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\nweekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n             | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\nmonth        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n             | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n             | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n```\n\n----------------------------------------\n\nTITLE: Nginx Proxy Configuration\nDESCRIPTION: Nginx configuration for proxying requests to SRS HTTP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-server.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nworker_processes  1;\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include             /etc/nginx/mime.types;\n\n    server {\n        listen       80;\n        listen       443 ssl http2;\n        server_name  _;\n        ssl_certificate      /usr/local/srs/conf/server.crt;\n        ssl_certificate_key  /usr/local/srs/conf/server.key;\n\n        location ~ ^/(console|players)/ {\n           proxy_pass http://127.0.0.1:8080/$request_uri;\n        }\n        location ~ ^/.+/.*\\.(flv|m3u8|ts|aac|mp3)$ {\n           proxy_pass http://127.0.0.1:8080$request_uri;\n        }\n        location ~ ^/(api|rtc)/ {\n           proxy_pass http://127.0.0.1:1985$request_uri;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying SRS Configure Help for Cross-Build Options\nDESCRIPTION: Shows the configure help command that lists all cross-build related options available in SRS. This provides reference for customizing the cross-compilation process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./configure -h\n\nPresets:\n  --cross-build             Enable cross-build, please set bellow Toolchain also. Default: off\n  \nCross Build options:        @see https://ossrs.net/lts/zh-cn/docs/v6/doc/arm#ubuntu-cross-build-srs\n  --cpu=<CPU>               Toolchain: Select the minimum required CPU. For example: --cpu=24kc\n  --arch=<ARCH>             Toolchain: Select architecture. For example: --arch=aarch64\n  --host=<BUILD>            Toolchain: Build programs to run on HOST. For example: --host=aarch64-linux-gnu\n  --cross-prefix=<PREFIX>   Toolchain: Use PREFIX for tools. For example: --cross-prefix=aarch64-linux-gnu-\n\nToolchain options:\n  --static=on|off           Whether add '-static' to link options. Default: off\n  --cc=<CC>                 Toolchain: Use c compiler CC. Default: gcc\n  --cxx=<CXX>               Toolchain: Use c++ compiler CXX. Default: g++\n  --ar=<AR>                 Toolchain: Use archive tool AR. Default: g++\n  --ld=<LD>                 Toolchain: Use linker tool LD. Default: g++\n  --randlib=<RANDLIB>       Toolchain: Use randlib tool RANDLIB. Default: g++\n  --extra-flags=<EFLAGS>    Set EFLAGS as CFLAGS and CXXFLAGS. Also passed to ST as EXTRA_CFLAGS.\n```\n\n----------------------------------------\n\nTITLE: Running srs-bench Load Test (Bash)\nDESCRIPTION: Example command syntax for running the `srs-bench` RTMP load testing tool (`sb_rtmp_load`). The `-c` flag specifies the number of concurrent clients to simulate (e.g., 800), and the `-r` flag specifies the target RTMP stream URL.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 800 -r <rtmp_url>\n```\n\n----------------------------------------\n\nTITLE: Building SRS in ARM Docker Container\nDESCRIPTION: Commands to build SRS using an aarch64 docker container, mounting the current directory as a volume.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \\\n    bash -c \"./configure && make\"\n```\n\n----------------------------------------\n\nTITLE: Configuring FFmpeg Tool Logs\nDESCRIPTION: Configuration for external tool (FFmpeg) log directory location. Can be set to /dev/null to disable logging for embedded systems with limited storage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# the logs dir.\n# if enabled ffmpeg, each stracoding stream will create a log file.\n# \"/dev/null\" to disable the log.\n# default: ./objs\nff_log_dir          ./objs;\n```\n\n----------------------------------------\n\nTITLE: Trace Flash Player Client in Edge Log\nDESCRIPTION: Uses grep to find log entries for a specific Flash player client on the edge server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\ngrep --color -ina \"\\[110\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Checking Network Interrupts and IRQ Affinity (bash)\nDESCRIPTION: Queries Linux /proc virtual files to display network-related interrupt-to-CPU binding, for tuning or troubleshooting IRQ and softirq affinity. Suitable for environments where virtualized network adapters such as virtio are present. Use grep to filter interrupts, and cat to check IRQ-specific CPU affinity mask.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n# grep virtio /proc/interrupts | grep -e in -e out\n 29:   64580032          0          0          0   PCI-MSI-edge      virtio0-input.0\n 30:          1         49          0          0   PCI-MSI-edge      virtio0-output.0\n 31:   48663403          0   11845792          0   PCI-MSI-edge      virtio0-input.1\n 32:          1          0          0         52   PCI-MSI-edge      virtio0-output.1\n```\n\nLANGUAGE: bash\nCODE:\n```\n# cat /proc/irq/29/smp_affinity\n1 # virtio0CPU0\n# cat /proc/irq/30/smp_affinity\n2 # virtio0CPU1\n# cat /proc/irq/31/smp_affinity\n4 # virtio1CPU2\n# cat /proc/irq/32/smp_affinity\n8 # virtio1CPU3\n```\n\n----------------------------------------\n\nTITLE: Enabling TCP_NODELAY for SRS Connections\nDESCRIPTION: Activates the TCP_NODELAY option for SRS connections. When enabled, it sets the nodelay flag on the file descriptor using setsockopt.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_9\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Send Minimal Interval in SRS\nDESCRIPTION: Sets the minimal packet send interval in milliseconds to control stream delivery timing. Useful for devices that require constant packet intervals. Setting a value above 0 forces SRS to send messages one by one at the specified interval.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # the minimal packets send interval in ms,\n        # used to control the ndiff of stream by srs_rtmp_dump,\n        # for example, some device can only accept some stream which\n        # delivery packets in constant interval(not cbr).\n        # @remark 0 to disable the minimal interval.\n        # @remark >0 to make the srs to send message one by one.\n        # @remark user can get the right packets interval in ms by srs_rtmp_dump.\n        # default: 0\n        send_min_interval       10.0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: List of HEVC-related Commits and Pull Requests in SRS\nDESCRIPTION: A comprehensive list of commits and pull requests related to HEVC/H.265 implementation in SRS, showing the evolution of HEVC support across different protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_14\n\nLANGUAGE: markdown\nCODE:\n```\n* [H265: For #1747, Support HEVC/H.265 in SRT/RTMP/HLS.](https://github.com/ossrs/srs-gb28181/commit/3ca11071b45495e82d2d6958e5d0f7eab05e71e5)\n* [H265: For #1747, Fix build fail bug for H.265](https://github.com/ossrs/srs-gb28181/commit/e355f3c37228f3602c88fed68e8fe5e6ba1153ea)\n* [H265: For #1747, GB28181 support h.265 (#2037)](https://github.com/ossrs/srs-gb28181/commit/b846217bc7f94034b33bdf918dc3a49fb17947e0)\n* [H265: fix some important bugs (#2156)](https://github.com/ossrs/srs-gb28181/commit/26218965dd083d13173af6eb31fcdf9868b753c6)\n* [H265: Deliver the right hevc nalu and dump the wrong nalu. (#2447)](https://github.com/ossrs/srs-gb28181/commit/a13b9b54938a14796abb9011e7a8ee779439a452)\n* [H265: Fix multi nal hevc frame demux fail. #2494](https://github.com/ossrs/srs-gb28181/commit/6c5e6090d7c82eb37530e109c230cabaedf948e1)\n* [H265: Fix build error #2657 #2664](https://github.com/ossrs/srs-gb28181/commit/eac99e19fba6063279b9e47272523014f5e3334a)\n* [H265: Update mpegts demux in srt. #2678](https://github.com/ossrs/srs-gb28181/commit/391c1426fc484c990e4324a4ae2f0de900074578)\n* [H265: Fix the stat issue for h265. (#1949)](https://github.com/ossrs/srs-gb28181/commit/b4486e3b51281b4c227b2cc4f58d2b06db599ce0)\n* [H265: Add h265 codec written support for MP4 format. (#2697)](https://github.com/ossrs/srs-gb28181/commit/3175d7e26730a04b27724e55dc95ef86c1f2886e)\n* [H265: Add h265 for SRT.](https://github.com/runner365/srs/commit/0fa86e4f23847e8a46e3d0e91e0acd2c27047e11)\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and compile SRS from source code. This builds the SRS binary that will be used for the origin cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Checking Active Connections with netstat (Bash)\nDESCRIPTION: Shell commands to count the number of established TCP connections for both the SRS and Nginx processes using `netstat`. It filters connections by process name (`srs`, `nginx`) and connection state (`ESTABLISHED`), then uses `wc -l` to count the lines (connections).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nsrs_connections=`netstat -anp|grep srs|grep ESTABLISHED|wc -l`; \\\nnginx_connections=`netstat -anp|grep nginx|grep ESTABLISHED|wc -l`; \\\necho \"srs_connections: $srs_connections\"; \\\necho \"nginx_connections: $nginx_connections\";\n```\n\n----------------------------------------\n\nTITLE: Starting SRS HTTP Callback Server (Bash)\nDESCRIPTION: This snippet demonstrates how to start the default Python-based HTTP callback server provided with SRS. The command runs the `server.py` script, specifying port 8085 for the server to listen on. The output shows the server successfully starting and listening on 0.0.0.0:8085.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ python research/api-server/server.py 8085\n[2014-02-27 09:42:25][trace] api server listen at port: 8085, static_dir: /home/winlin/git/srs/trunk/research/api-server/static-dir\n[2014-02-27 09:42:25][trace] start cherrypy server\n[27/Feb/2014:09:42:25] ENGINE Listening for SIGHUP.\n[27/Feb/2014:09:42:25] ENGINE Listening for SIGTERM.\n[27/Feb/2014:09:42:25] ENGINE Listening for SIGUSR1.\n[27/Feb/2014:09:42:25] ENGINE Bus STARTING\n[27/Feb/2014:09:42:25] ENGINE Started monitor thread '_TimeoutMonitor'.\n[27/Feb/2014:09:42:25] ENGINE Started monitor thread 'Autoreloader'.\n[27/Feb/2014:09:42:25] ENGINE Serving on 0.0.0.0:8085\n[27/Feb/2014:09:42:25] ENGINE Bus STARTED\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Console Configuration\nDESCRIPTION: This bash command demonstrates how to start SRS using a console configuration file, which disables daemon mode and logs to the console.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Illustrating WebRTC Browser-to-Browser Communication\nDESCRIPTION: ASCII diagram showing the signaling and media flow between two browsers in a WebRTC connection. This diagram illustrates the basic concept of WebRTC communication without intermediary servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +----------------+\n+    Browser     +----<--Signaling----->--+    Browser     +\n+ (like Chrome)  +----<----Media----->----+ (like Chrome)  +\n+----------------+                        +----------------+\n```\n\n----------------------------------------\n\nTITLE: Interpreting GPERF Heap Profiler (gmp) Results with pprof in Bash\nDESCRIPTION: Displays example output generated by running `pprof --text` on heap profile data (`gperf.srs.gmp*`) collected by gmp during SRS execution. It shows the total memory allocated and lists functions contributing significantly to memory allocation, helping identify memory usage hotspots.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/pprof --text objs/srs gperf.srs.gmp*\nUsing local file objs/srs.\nUsing local file gperf.srs.gmp.0001.heap.\nTotal: 0.1 MB\n     0.0  31.5%  31.5%      0.0  49.1% SrsConfDirective::parse_conf\n     0.0  28.4%  59.9%      0.0  28.4% std::basic_string::_Rep::_S_create\n     0.0  27.4%  87.3%      0.0  27.4% _st_epoll_init\n     0.0  11.7%  99.0%      0.0  11.7% __gnu_cxx::new_allocator::allocate\n     0.0   0.4%  99.5%      0.0  27.9% st_init\n```\n\n----------------------------------------\n\nTITLE: Pushing Second Stream to Origin Server Cluster (Bash)\nDESCRIPTION: FFmpeg command to push the second live stream to the origin server cluster. This stream will also be randomly assigned to one of the origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream2\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Source Code via GitLab Mirror using Shell\nDESCRIPTION: This shell snippet shows how to clone the SRS repository from the GitLab mirror into a directory named 'srs', reconfigure the Git remote URL to point to GitHub, and then pull updates. Requires Git and access to GitLab and GitHub. No parameters are required; it outputs a local copy of the repository in the 'srs' directory, suitable for users needing an alternative to Gitee or GitHub for initial cloning.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/resource.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://gitlab.com/winlinvip/srs-gitlab.git srs &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: SRS Bench Process CPU Monitoring\nDESCRIPTION: Command to monitor CPU usage of the srs-bench load testing process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep load|grep rtmp|awk '{print $2}'` && top -p $pid\n```\n\n----------------------------------------\n\nTITLE: Filtering SRS Logs for Publish Streams\nDESCRIPTION: This snippet demonstrates how to use grep to filter logs to find specific publish stream sessions. It shows how to find all publish streams and then narrow down to a specific stream name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n43:[2014-04-04 11:56:18.138][trace][105][11] identify client success. type=publish, stream_name=winlin\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Updating an Existing Pull Request Branch using Git\nDESCRIPTION: This snippet shows how to update an existing Pull Request. First, ensure you are on the correct branch. Then, stage all modified files (`-am` combines staging modified/deleted files and committing) with a descriptive commit message. Finally, push the changes to the origin remote, which automatically updates the associated PR on GitHub.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_5\n\nLANGUAGE: git\nCODE:\n```\ngit checkout bugfix/bug-summary\ngit commit -am 'Description for update'\ngit push\n```\n\n----------------------------------------\n\nTITLE: Adding SRS as a Service in Ubuntu\nDESCRIPTION: Command to add SRS as a system service in Ubuntu using update-rc.d. This is step 3 of the setup process for Ubuntu systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n#ubuntu12\nsudo update-rc.d srs defaults\n```\n\n----------------------------------------\n\nTITLE: Upgrading Oryx Server Using Helm\nDESCRIPTION: Command to upgrade Oryx Server from version 1.0.1 to 1.0.6 using Helm package manager. This allows for version-specific upgrades with the ability to rollback if needed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhelm upgrade srs srs/oryx --version 1.0.6\n```\n\n----------------------------------------\n\nTITLE: Pushing MPEG-TS Stream to SRS using FFmpeg in Bash\nDESCRIPTION: FFmpeg command to push an MPEG-TS stream over UDP to SRS for conversion.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/streamer.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -f flv -i doc/source.flv -c copy -f mpegts udp://127.0.0.1:8935\n```\n\n----------------------------------------\n\nTITLE: Checking External IP of Kubernetes Services\nDESCRIPTION: Kubernetes commands to check the External IP addresses of the deployed SRS services. These commands are useful for retrieving the correct IP addresses to use in streaming URLs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get svc/srs-http-service\nkubectl get svc/srs-edge-service\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS Origin with FFmpeg\nDESCRIPTION: FFmpeg command to publish a video stream to the SRS origin server using RTMP protocol, which will then be distributed as HLS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy \\\n  -f flv rtmp://127.0.0.1/live/livestream\n```\n\n----------------------------------------\n\nTITLE: SRS HTTP Callback Configuration for Snapshots\nDESCRIPTION: Configuration file for SRS that enables HTTP callbacks for publish/unpublish events to trigger snapshots using FFMPEG\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/snapshot.md#2025-04-23_snippet_1\n\nLANGUAGE: conf\nCODE:\n```\n# snapshot.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    http_hooks {\n        enabled on;\n        on_publish http://127.0.0.1:8085/api/v1/snapshots;\n        on_unpublish http://127.0.0.1:8085/api/v1/snapshots;\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding SRS as a Service on CentOS\nDESCRIPTION: Command to add SRS as a system service on CentOS using chkconfig, enabling automatic startup on system boot.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n#centos 6\nsudo /sbin/chkconfig --add srs\n```\n\n----------------------------------------\n\nTITLE: Configuring GOP Cache Settings\nDESCRIPTION: Configuration for GOP (Group of Pictures) caching which affects startup time and streaming latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    play {\n        gop_cache       off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Playing HTTP-FLV Stream from SRS Edge\nDESCRIPTION: URL for playing an HTTP-FLV stream from the SRS Edge server deployed on Kubernetes. The IP address should be replaced with the actual External IP of the srs-edge-service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nhttp://28.170.32.118:8080/live/livestream.flv\n```\n\n----------------------------------------\n\nTITLE: Cloning and Navigating SRS Repository - Bash\nDESCRIPTION: This Bash snippet demonstrates how to clone the SRS code repository from GitHub and navigate into the trunk directory. Dependencies: Git is required. No parameters. The output is a checked-out local copy of SRS ready for build or configuration. Use on a Unix-like shell.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR Apply for Multiple Streams\nDESCRIPTION: Example configuration showing how to apply DVR to specific streams instead of all streams, targeting live/stream1 and live/stream2 for recording.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost xxx {\n    dvr {\n        dvr_apply live/stream1 live/stream2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring a Specific Enabled Vhost in SRS (Bash)\nDESCRIPTION: This SRS configuration defines a listener on port 1935 and a single, explicitly enabled virtual host named `demo.srs.com`. Because the `enabled` directive is set to `on` (which is often the default but shown here for clarity) and no `__defaultVhost__` is configured, SRS will only accept connections explicitly intended for the `demo.srs.com` Vhost. Requests targeting other Vhosts (e.g., via IP address) will be rejected.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n    enabled         on;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Repository\nDESCRIPTION: Command to update an existing SRS repository to the latest version using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Requesting Oryx HTTP API - Bash\nDESCRIPTION: Demonstrates making a basic HTTP GET request to the Oryx Terraform management API endpoint using curl. Assumes the API server is running locally with no authentication required for the endpoint. Input is the API URL; output is the API response in the terminal.\n\nDependencies: curl must be installed and accessible in the shell environment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/mgmt/versions\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Write Settings in SRS\nDESCRIPTION: Configuration for merged-write settings in SRS vhost play settings, which affects write performance and stream latency.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/low-latency.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    play {\n        mw_latency      350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding SRS service on Ubuntu 12\nDESCRIPTION: This command adds SRS as a system service on Ubuntu 12 using update-rc.d.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nsudo update-rc.d srs defaults\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS Windows using FFmpeg\nDESCRIPTION: FFmpeg command to publish a video stream to SRS running on Windows. This example uses a local FLV file as the source and publishes it to the RTMP endpoint.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/windows.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ~/srs/doc/source.flv -c copy -f flv rtmp://win11/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Restarting SRS via Init.d Script - Bash\nDESCRIPTION: Restarts the SRS service through the init.d service script. Needs the init.d script accessible at '/etc/init.d/srs'. Outputs restart process logs and new service status.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs restart\n```\n\n----------------------------------------\n\nTITLE: Configuration for Origin ServerB\nDESCRIPTION: Configuration file for the second origin server (ServerB) in the cluster. Similar to ServerA but with different port settings and referencing ServerA as a coworker.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.cluster.serverB.conf\nlisten              19351;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverB.pid;\nhttp_api {\n    enabled         on;\n    listen          9091;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9090;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FMLE for RTMP Publishing\nDESCRIPTION: These are configuration parameters for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the master SRS server. The 'FMS URL' should be set to the master SRS server's RTMP address ('rtmp://192.168.1.170/live'), and the 'Stream' name should be set to 'livestream'. Replace '192.168.1.170' with the actual server IP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Ingest Configuration\nDESCRIPTION: Command to start the SRS server using the Ingest configuration file created earlier.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ingest.conf\n```\n\n----------------------------------------\n\nTITLE: Checking DNS Record with Ping Command\nDESCRIPTION: Bash command to verify the correct setup of DNS A record by pinging the domain name and confirming it resolves to the expected IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-12-Oryx-HTTPS.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nping your_domain_name\n```\n\n----------------------------------------\n\nTITLE: Using Expires Header in HTTP/1.0\nDESCRIPTION: Example of the Expires entity-header field that indicates when the entity should be considered stale. This allows information providers to suggest resource volatility and helps caching mechanisms determine resource freshness.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_35\n\nLANGUAGE: plaintext\nCODE:\n```\nExpires: Thu, 01 Dec 1994 16:00:00 GMT\n```\n\n----------------------------------------\n\nTITLE: Enabling HLS Authentication Context - Conf\nDESCRIPTION: This configuration snippet demonstrates how to enable HLS playback with authentication and user statistics in SRS. It shows the 'vhost' and nested 'hls' block with 'enabled', 'hls_ctx', and 'hls_ts_ctx' parameters switched on. 'hls_ctx' and 'hls_ts_ctx' enable per-play authentication and statistics callbacks, potentially affecting CDN caching. Requires SRS with HLS and HTTP hooks support. All parameters (\"enabled\", \"hls_ctx\", \"hls_ts_ctx\") are fields within the SRS conf file. Inputs: N/A. Outputs: SRS enables authentication/tracking for HLS streams. Limitation: Should be disabled in distributed CDN clusters to ensure caching works.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        enabled  on;\n        hls_ctx on;\n        hls_ts_ctx on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing 32-bit Support Libraries for Cross-Compilation\nDESCRIPTION: Command to install 32-bit support libraries needed when using 32-bit HiSilicon tools on a 64-bit host system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\napt-get -y install lib32z1-dev\n```\n\n----------------------------------------\n\nTITLE: Installing Cross-Compilation Toolchain for aarch64\nDESCRIPTION: Command to install the required cross-compilation tools for aarch64 architecture in Ubuntu.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: HLS Event M3U8 Playlist Example\nDESCRIPTION: Example of an event-type HLS m3u8 playlist with playlist type specification.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_10\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:YES\n#EXT-X-TARGETDURATION:13\n#EXT-X-MEDIA-SEQUENCE:430\n#EXT-X-PLAYLIST-TYPE:EVENT\n#EXTINF:11.800\nnews-430.ts\n#EXTINF:10.120\nnews-431.ts\n#EXTINF:11.160\nnews-432.ts\n```\n\n----------------------------------------\n\nTITLE: Starting Grafana for Metric Visualization\nDESCRIPTION: This Docker command starts Grafana with custom settings for admin credentials and default theme.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 3000:3000 \\\n  -e GF_SECURITY_ADMIN_USER=admin \\\n  -e GF_SECURITY_ADMIN_PASSWORD=12345678 \\\n  -e GF_USERS_DEFAULT_THEME=light \\\n  grafana/grafana\n```\n\n----------------------------------------\n\nTITLE: Playing RTMP Stream in Flash (ActionScript)\nDESCRIPTION: ActionScript code demonstrating how to connect to an RTMP server and play a live stream using NetConnection and NetStream objects within a Flash application. This snippet shows the minimal code required to attach the video stream to a Video object for display.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: actionscript\nCODE:\n```\nvar conn = new NetConnection();\nvar stream = new NetStream(conn);\nvar video = new Video();\nthis.addChild(video);\nvideo.attachNetStream(stream);\nconn.connect(\"rtmp://192.168.1.170/live\");\nstream.play(\"livestream\");\n```\n\n----------------------------------------\n\nTITLE: Running Oryx in Docker\nDESCRIPTION: Docker command to deploy an Oryx instance with appropriate port mappings for streaming services. This exposes ports for web management, RTMP, HTTP streaming, and UDP services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-10-11-Oryx-Stream-IP-Camera-Events.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 80:2022 -p 443:2443 -p 1935:1935 \\\n  -p 8080:8080 -p 8000:8000/udp -p 10080:10080/udp --name oryx \\\n  -v $HOME/data:/data ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Binding Network IRQs to CPU0 (bash)\nDESCRIPTION: This shell snippet loops through all virtio-related network IRQs (filtered from interrupts) and sets their affinity to CPU0 by echoing '1' to the appropriate /proc/irq/<irq>/smp_affinity file. Used for optimizing softirq distributions on multicore servers. Requires root privileges. Limitation: Over-concentration on CPU0 may degrade softirq performance if not balanced.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nfor irq in $(grep virtio /proc/interrupts | grep -e in -e out | cut -d: -f1); do \n    echo 1 > /proc/irq/$irq/smp_affinity\ndone\n```\n\n----------------------------------------\n\nTITLE: Setting First Packet Timeout for SRS RTMP Publishers\nDESCRIPTION: Configures the timeout in milliseconds for the first packet from RTMP publishers (e.g., FMLE/Flash). This setting helps manage connection establishment for encoders pushing RTMP streams to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_2\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        firstpkt_timeout    20000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling TCP_NODELAY in SRS\nDESCRIPTION: Controls whether the TCP_NODELAY socket option is enabled for client connections. When enabled, SRS sets this socket option which disables Nagle's algorithm, potentially reducing latency at the cost of increased network traffic.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    # whether enable the TCP_NODELAY\n    # if on, set the nodelay of fd by setsockopt\n    # default: off\n    tcp_nodelay     on;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Stream Converter Flow in Text\nDESCRIPTION: Demonstrates the basic flow of data through the Stream Converter to SRS and then to clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/streamer.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nClient ---PUSH--> Stream Converter --RTMP--> SRS --RTMP/FLV/HLS/WebRTC--> Clients\n```\n\n----------------------------------------\n\nTITLE: Probing UDP MPEG-TS Stream with FFprobe\nDESCRIPTION: Using FFprobe to examine a UDP MPEG-TS stream converted from RTMP by the SRS edge server. The output shows the program information, video and audio codec details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    [root@edge ~]# ffprobe  udp://xxx:1234?localaddr=127.0.0.1\n    Input #0, mpegts, from 'udp://xxx:5002?localaddr=127.0.0.1':\n      Duration: N/A, start: 29981.146500, bitrate: 130 kb/s\n      Program 1\n        Metadata:\n          service_name    : Channel 1\n          service_provider: PBS\n        Stream #0:0[0x100]: Video: h264 (High) ([27][0][0][0] / 0x001B), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 90k tbn, 180k tbc\n        Stream #0:1[0x101]: Audio: aac ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 130 kb/s\n```\n\n----------------------------------------\n\nTITLE: Grep for Session-Oriented Logs in SRS\nDESCRIPTION: This bash snippet demonstrates how to use grep to search for specific client sessions in SRS logs, using keywords like 'identify client success' and stream names.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ncat objs/srs.log|grep -ina \"identify client success. type=publish\"\ncat objs/srs.log|grep -ina \"identify client success. type=publish\"|grep -a \"livestream\"\ncat objs/srs.log |grep -ina \"\\[104\\]\\[\"\n```\n\n----------------------------------------\n\nTITLE: Observing SRS Startup Output in Daemon Mode (Bash)\nDESCRIPTION: Displays the typical console output when starting SRS using a standard configuration file (`conf/srs.conf`) where daemon mode is enabled and logs are written to a file. SRS prints confirmation messages indicating successful configuration parsing and the path to the log file (`./objs/srs.log` in this case).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c conf/srs.conf \n[2014-04-14 12:12:57.775][trace][0][0] config parse complete\n[2014-04-14 12:12:57.775][trace][0][0] write log to file ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] you can: tailf ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] @see https://ossrs.net/lts/zh-cn/docs/v4/doc/log\n```\n\n----------------------------------------\n\nTITLE: Linking SRS init.d script to system directory\nDESCRIPTION: This command creates a symbolic link for the SRS init.d script in the system's init.d directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo ln -sf \\\n    /usr/local/srs/etc/init.d/srs \\\n    /etc/init.d/srs\n```\n\n----------------------------------------\n\nTITLE: Media PS Packet Structure Example\nDESCRIPTION: Example showing how PS (Program Stream) packets are structured in GB28181 media streams, demonstrating how frames larger than 64KB are split across multiple PES packets and how video and audio messages are packaged.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gb28181.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nPS: New pack header clock=2454808848, rate=159953\nPS: New system header rate_bound=159953, video_bound=1, audio_bound=1\nPS: Got message Video, dts=2454808848, seq=22204, base=2454808848 payload=29B, 0, 0, 0, 0x1, 0x67, 0x4d, 0, 0x32\nPS: Got message Video, dts=0, seq=22204, base=2454808848 payload=8B, 0, 0, 0, 0x1, 0x68, 0xee, 0x3c, 0x80\nPS: Got message Video, dts=0, seq=22204, base=2454808848 payload=9B, 0, 0, 0, 0x1, 0x6, 0xe5, 0x1, 0x2b\nPS: Got message Video, dts=0, seq=22250, base=2454808848 payload=65471B, 0, 0, 0, 0x1, 0x65, 0xb8, 0, 0\nPS: Got message Video, dts=0, seq=22252, base=2454808848 payload=2112B, 0x48, 0x4c, 0xf2, 0x94, 0xaa, 0xbc, 0xed, 0x3d\nPS: Got message Audio, dts=2454812268, seq=22253, base=2454808848 payload=99B, 0xff, 0xf9, 0x50, 0x40, 0xc, 0x7f, 0xfc, 0x1\nPS: Got message Audio, dts=2454814338, seq=22254, base=2454808848 payload=96B, 0xff, 0xf9, 0x50, 0x40, 0xc, 0x1f, 0xfc, 0x1\n\nPS: New pack header clock=2454812448, rate=159953\nPS: Got message Video, dts=2454812448, seq=22283, base=2454812448 payload=39457B, 0, 0, 0, 0x1, 0x61, 0xe0, 0x8, 0xbf\nPS: Got message Audio, dts=2454816498, seq=22284, base=2454812448 payload=101B, 0xff, 0xf9, 0x50, 0x40, 0xc, 0xbf, 0xfc, 0x1\nPS: Got message Audio, dts=2454818568, seq=22285, base=2454812448 payload=107B, 0xff, 0xf9, 0x50, 0x40, 0xd, 0x7f, 0xfc, 0x1\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS from Gitee Mirror\nDESCRIPTION: This snippet demonstrates how to clone the SRS repository from the Gitee mirror and then update the remote URL to the GitHub repository. This is useful for users in China to get faster initial clone speeds.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/resource.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/ossrs/srs.git &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS\nDESCRIPTION: FFmpeg command to publish a stream to SRS with query parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://localhost/live/livestream?k=v\n```\n\n----------------------------------------\n\nTITLE: Setting Candidate IP and Running SRS for WebRTC - Bash\nDESCRIPTION: Illustrates setting the CANDIDATE environment variable to a specific server IP address before running SRS, which is essential for WebRTC support. This ensures the server advertises the proper IP for ICE candidate negotiation in WebRTC. The configuration file parameter should match a WebRTC-enabled config.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Adding SRS service on CentOS 6\nDESCRIPTION: This command adds SRS as a system service on CentOS 6 using chkconfig.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo /sbin/chkconfig --add srs\n```\n\n----------------------------------------\n\nTITLE: Syncing with all remotes before creating a PR\nDESCRIPTION: Command to fetch updates from all remotes before starting work on a new PR. This ensures you're working with the latest code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch --all\n```\n\n----------------------------------------\n\nTITLE: Gracefully Quitting SRS\nDESCRIPTION: Command to gracefully shut down SRS by sending SIGQUIT signal using the init.d script. This allows existing connections to complete.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs grace\n```\n\n----------------------------------------\n\nTITLE: Disabling IPTables Firewall for SRS\nDESCRIPTION: Commands to disable the system firewall (iptables) to prevent streaming connection issues. Includes stopping the service and disabling it on startup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/install.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# disable the firewall\nsudo /etc/init.d/iptables stop\nsudo /sbin/chkconfig iptables off\n```\n\n----------------------------------------\n\nTITLE: Starting Multiple SRS Server Instances - Bash\nDESCRIPTION: Launches the SRS origin and two edge servers in the background, each with its specified configuration file. The commands rely on prior build and configuration steps and require execution permissions. Resulting processes run concurrently for the HTTP-FLV cluster setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.flv.live.conf &\n./objs/srs -c conf/http.flv.live.edge1.conf &\n./objs/srs -c conf/http.flv.live.edge2.conf &\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Command to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Ingest Settings\nDESCRIPTION: Configuration example for setting up SRS ingest functionality. Shows how to configure input sources, FFmpeg settings, and transcoding options. The config allows ingesting files, streams or devices and publishing them as RTMP streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    # ingest file/stream/device then push to SRS over RTMP.\n    # the name/id used to identify the ingest, must be unique in global.\n    # ingest id is used in reload or http api management.\n    ingest livestream {\n        # whether enabled ingest features\n        # default: off\n        enabled      on;\n        # input file/stream/device\n        # @remark only support one input.\n        input {\n            # the type of input.\n            # can be file/stream/device, that is,\n            #   file: ingest file specifies by url.\n            #   stream: ingest stream specifeis by url.\n            #   device: not support yet.\n            # default: file\n            type    file;\n            # the url of file/stream.\n            url     ./doc/source.flv;\n        }\n        # the ffmpeg \n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        # the transcode engine, @see all.transcode.srs.com\n        # @remark, the output is specified following.\n        engine {\n            # @see enabled of transcode engine.\n            # if disabled or vcodec/acodec not specified, use copy.\n            # default: off.\n            enabled          off;\n            # output stream. variables:\n            # [vhost] current vhost which start the ingest.\n            # [port] system RTMP stream port.\n            output          rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting Process Priority with renice (bash)\nDESCRIPTION: Sets a higher CPU scheduling priority for the SRS process by reducing its nice value to -15. Requires root privileges. Usage: 'renice -n -15 -p $(pidof srs)'. Effects are visible via tools like 'ps' or 'top' on the NI (nice) field.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nrenice -n -15 -p $(pidof srs)\n```\n\nLANGUAGE: bash\nCODE:\n```\ntop -n1 -p $(pidof srs)\n#  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                \n# 1505 root       5 -15  519920 421556   4376 S  66.7  5.3   4:41.12 srs\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Servers\nDESCRIPTION: Commands to start both origin and edge SRS servers using their respective configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf &\n./objs/srs -c conf/edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Testing Connectivity from Oryx Docker Container - Bash\nDESCRIPTION: Sends an HTTP GET request from inside the Oryx Docker container to verify connectivity to a specified target URL. This is useful for confirming that webhooks or callback endpoints are reachable from Oryx before configuring event subscriptions.\n\nInput: Replace 'your-target-URL' with the actual endpoint. Dependencies: curl installed inside the Oryx container, Docker.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ndocker exec -it oryx curl http://your-target-URL\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 1.0 Release Branch (Bash)\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 1.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/git.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 1.0release\n```\n\n----------------------------------------\n\nTITLE: Origin Server Configuration\nDESCRIPTION: Configuration file for the origin SRS server, enabling HTTP-FLV streaming on port 8080 and RTMP on port 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/http.flv.live.conf\nlisten              1935;\nmax_connections     1000;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    http_remux {\n        enabled     on;\n        mount       [vhost]/[app]/[stream].flv;\n        hstrs       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Service Status\nDESCRIPTION: Command to check the current status of the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs status\n```\n\n----------------------------------------\n\nTITLE: Compiling SRS with Valgrind Support in Bash\nDESCRIPTION: This command configures the SRS build system to include Valgrind support using the '--valgrind=on' flag and then compiles the project using 'make'. This step is necessary before running SRS with Valgrind for memory leak detection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./configure --valgrind=on && make\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with a specified configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Default Video Codec Parameters for AI Transcript\nDESCRIPTION: Default video codec configuration parameters used for processing AI transcripts with libx264 in Oryx, optimized for streaming with zerolatency tuning and no B-frames.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\n-c:v libx264 -profile:v main -preset:v medium -tune zerolatency -bf 0\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Workflow Diagram\nDESCRIPTION: ASCII diagram showing the workflow between FFmpeg, SRS, and the business server for HTTP callbacks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/http-callback.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+--------+     +--------+                    +-----------------------+\n| FFmpeg |-->--+  SRS   |--HTTP-Callback-->--+  Your Business Server |\n+--------+     +--------+                    +-----------------------+\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic ATC Detection in SRS\nDESCRIPTION: Enables automatic detection of ATC (Absolute Timestamp Control) for play clients. When enabled, SRS checks for 'bravo_atc=\"true\"' in onMetaData packets and sets ATC accordingly. This setting is ignored if atc_auto is off.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_10\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running FFmpeg to Push a Stream to SRS\nDESCRIPTION: This Docker command runs FFmpeg to push a sample video stream to the SRS server for testing purposes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/exporter.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Edge Client Connection Trace\nDESCRIPTION: Search for client connection ID 107 on edge server to see player connection details.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[107\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: SDP Answer Example for WebRTC Candidate\nDESCRIPTION: Example of SDP answer showing candidate IP and port configuration returned by the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntype: answer, sdp: v=0\na=candidate:0 1 udp 2130706431 192.168.3.6 8000 typ host generation 0\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS TS Floor\nDESCRIPTION: Controls the HLS timestamp file path generation algorithm using floor calculation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_6\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_ts_floor    off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Domain DNS Configuration Examples\nDESCRIPTION: Example DNS and hosts file configurations for setting up domain name resolution for Oryx\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nA bt.yourdomain.com 121.13.75.20\n```\n\nLANGUAGE: text\nCODE:\n```\n121.13.75.20 bt.yourdomain.com\n```\n\n----------------------------------------\n\nTITLE: Defining Internet Media Type message/http Registration\nDESCRIPTION: Specification for registering the message/http media type with IANA, including required and optional parameters, encoding considerations and security notes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_40\n\nLANGUAGE: plaintext\nCODE:\n```\nMedia Type name:         message\n\nMedia subtype name:      http\n\nRequired parameters:     none\n\nOptional parameters:     version, msgtype\n\n        version: The HTTP-Version number of the enclosed message\n                 (e.g., \"1.0\"). If not present, the version can be\n                 determined from the first line of the body.\n\n        msgtype: The message type -- \"request\" or \"response\". If\n                 not present, the type can be determined from the\n                 first line of the body.\n\nEncoding considerations: only \"7bit\", \"8bit\", or \"binary\" are\n                          permitted\n\nSecurity considerations: none\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Configuration\nDESCRIPTION: Command to start the SRS server with a specified configuration file. This launches the SRS binary and points it to the default configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/install.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source in Bash\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Cloning/Updating SRS Repository using Git Bash\nDESCRIPTION: This snippet shows how to obtain the SRS source code. The first command clones the official SRS repository from GitHub and navigates into the 'trunk' directory. The second command updates an existing local repository to the latest version.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: FMLE Streaming Configuration\nDESCRIPTION: Configuration parameters for Adobe Flash Media Live Encoder (FMLE) to push streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub or update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-srt.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: HLS Loop M3U8 Playlist Example\nDESCRIPTION: Example of a looping HLS m3u8 playlist with discontinuity markers for segment transitions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_12\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:YES\n#EXT-X-TARGETDURATION:13\n#EXT-X-MEDIA-SEQUENCE:430\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXTINF:11.800\nnews-430.ts\n#EXTINF:10.120\nnews-431.ts\n#EXT-X-DISCONTINUITY\n#EXTINF:11.952\nnews-430.ts\n#EXTINF:12.640\nnews-431.ts\n#EXTINF:11.160\nnews-432.ts\n#EXT-X-DISCONTINUITY\n#EXTINF:11.751\nnews-430.ts\n#EXTINF:2.040\nnews-431.ts\n#EXT-X-ENDLIST\n```\n\n----------------------------------------\n\nTITLE: Deploying Oryx Docker Container\nDESCRIPTION: Command to deploy Oryx streaming server using Docker. Maps necessary ports (80, 443, 1935, 8080, 8000, 10080) and creates a data volume mount.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-09-11-Oryx-Virtual-Live-Events.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 80:2022 -p 443:2443 -p 1935:1935 \\\n  -p 8080:8080 -p 8000:8000/udp -p 10080:10080/udp --name oryx \\\n  -v $HOME/data:/data ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Shell Command to Analyze NGINX TS Cache Log Status - Bash\nDESCRIPTION: Shell pipeline to extract and count the frequency of different cache statuses (HIT, MISS, etc.) for .ts HLS segment requests from the NGINX access log. Requires standard Unix tools: cat, grep, awk, sort, uniq. Input: /var/log/nginx/access.log. Output: sorted counts per unique cache status value. Use for debugging and verifying cache effectiveness.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ncat /var/log/nginx/access.log | grep '.ts HTTP' \\\n  | awk '{print $1}' | sort | uniq -c | sort -r\n```\n\n----------------------------------------\n\nTITLE: Specifying Content-Length HTTP Header\nDESCRIPTION: Example of using the Content-Length HTTP header to indicate the size of the entity body in bytes (octets). This allows recipients to know the exact size of the content being transferred.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_62\n\nLANGUAGE: http\nCODE:\n```\nContent-Length: 3495\n```\n\n----------------------------------------\n\nTITLE: Reducing Sequence Header for RTMP and HTTP FLV Clients in SRS\nDESCRIPTION: Enables the reduction of sequence headers for clients that cannot handle duplicated headers. This is useful when the sequence header remains unchanged.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_1\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        reduce_sequence_header  on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Linking to Pages from Blogs Using Markdown\nDESCRIPTION: Shows how to create links from blog posts to other pages. The example demonstrates linking to the cloud page using a relative path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n[Cloud](../cloud)\n```\n\n----------------------------------------\n\nTITLE: Checking System File Descriptor Limits in Linux\nDESCRIPTION: Command to view the current file descriptor limits set for the system, which is important for handling multiple connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/raspberrypi.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for SRS Documentation Project\nDESCRIPTION: This command installs the necessary dependencies for the SRS documentation project using Yarn package manager.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn install\n```\n\n----------------------------------------\n\nTITLE: Displaying GPERF Heap Profiler Active Message in Bash\nDESCRIPTION: Shows the message printed to the console when SRS is started with GPERF memory profiling (gmp) enabled via configure flags. This confirms that heap allocation tracking has begun for performance analysis.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/gperf.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c conf/console.conf\nStarting tracking the heap\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository from Gitee Mirror\nDESCRIPTION: Clones the SRS source code repository from the Gitee mirror, then updates the remote origin to point to the main GitHub repository and pulls the latest changes. This is often faster for users in certain regions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/resource.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/ossrs/srs.git &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Cloning and Preparing SRS Source - Bash\nDESCRIPTION: This snippet demonstrates how to clone the SRS repository from GitHub and navigate into its trunk directory. It is needed to obtain the SRS source code prior to building or deploying the cluster. Git must be installed on the system. The key parameters are the repository URL and the directory navigation. Inputs: none. Outputs: SRS source code in the local directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Snapshot Configuration\nDESCRIPTION: Command to start SRS with the snapshot configuration, which will trigger the on_publish event and initiate the snapshot process via the API server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c snapshot.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Using Binary Executable\nDESCRIPTION: Command to start SRS directly by executing the binary with a configuration file. This is the most basic way to run SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Running Oryx in Docker for Virtual Live Streaming\nDESCRIPTION: Docker command to create an Oryx instance with the necessary port mappings for live streaming functionality. The command mounts a local data directory and uses the Oryx container from Aliyun registry.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-09-11-Oryx-Virtual-Live-Events.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 80:2022 -p 443:2443 -p 1935:1935 \\\n  -p 8080:8080 -p 8000:8000/udp -p 10080:10080/udp --name oryx \\\n  -v $HOME/data:/data registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Setting Normal Packet Timeout\nDESCRIPTION: Configuration for setting the timeout duration for normal packets from encoders.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/special-control.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        normal_timeout      7000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a new feature branch from SRS develop branch\nDESCRIPTION: Command to create a new feature branch based on the develop branch of the original SRS repository. The branch should be named according to the bug or feature being addressed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b bugfix/bug-summary srs/develop\n```\n\n----------------------------------------\n\nTITLE: Verifying PNG Output From SRS Transcoder Snapshot (Bash, ls)\nDESCRIPTION: This Bash snippet lists the PNG files produced by the SRS transcoder configuration, allowing users to verify that snapshot images were generated correctly. Shows actual file sizes and timestamps for each PNG. Input: none; Output: List of PNG thumbnails created via transcoding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/snapshot.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwinlin:srs winlin$ ls -lh objs/nginx/html/live/*.png\n-rw-r--r--  1 winlin  staff   265K Oct 20 14:52 livestream-001.png\n-rw-r--r--  1 winlin  staff   265K Oct 20 14:52 livestream-002.png\n-rw-r--r--  1 winlin  staff   287K Oct 20 14:52 livestream-003.png\n-rw-r--r--  1 winlin  staff   235K Oct 20 14:52 livestream-004.png\n-rw-r--r--  1 winlin  staff   315K Oct 20 14:52 livestream-005.png\n-rw-r--r--  1 winlin  staff   405K Oct 20 14:52 livestream-006.png\n```\n\n----------------------------------------\n\nTITLE: Example HLS File Path Generation in SRS\nDESCRIPTION: Provides a concrete example of how SRS generates M3U8 and TS file paths based on the `hls_path`, `hls_m3u8_file`, and `hls_ts_file` directives. It shows the resulting file structure (`/data/nginx/html/live/livestream.m3u8`, `/data/nginx/html/live/livestream-*.ts`) for a specific RTMP stream (`rtmp://localhost/live/livestream`) and the corresponding HLS playback URL (`http://localhost/live/livestream.m3u8`). Variables like `[app]` and `[stream]` are substituted with actual stream information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFor RTMP stream: rtmp://localhost/live/livestream\nHLS path: \n        hls_path        /data/nginx/html;\n        hls_m3u8_file   [app]/[stream].m3u8;\n        hls_ts_file     [app]/[stream]-[seq].ts;\nSRS will generate the below files:\n/data/nginx/html/live/livestream.m3u8\n/data/nginx/html/live/livestream-0.ts\n/data/nginx/html/live/livestream-1.ts\n/data/nginx/html/live/livestream-2.ts\nAnd the HLS URL for playback will be: http://localhost/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: NGINX-RTMP Configuration\nDESCRIPTION: NGINX configuration file showing RTMP server setup with worker processes and connection limits.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nuser  root;\nworker_processes  1;\nevents {\n    worker_connections  10240;\n}\nrtmp{\n    server{\n        listen 19350;\n        application live{\n            live on;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Getting SRS Source Code with Git\nDESCRIPTION: Commands to clone or update the SRS server source code from GitHub repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: SRS Vhost Config with Named Vhost - Bash\nDESCRIPTION: This snippet configures the SRS server to listen on port 1935 and defines a vhost named demo.srs.com without additional settings. This setup enables the vhost rule for connections matching the specified DNS name. Requires the SRS server and DNS mapping so that demo.srs.com resolves to the server's IP. There are no constraints within the vhost block; it acts as a placeholder for further settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n}\n\n```\n\n----------------------------------------\n\nTITLE: Starting Python API Server for Snapshots\nDESCRIPTION: Command to start the sample API server that handles snapshot requests on port 8085\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/snapshot.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython research/api-server/server.py 8085\n```\n\n----------------------------------------\n\nTITLE: Starting Primary Edge Server\nDESCRIPTION: Command to start the first SRS edge server listening on port 1935\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/reuse-port.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge.conf\n```\n\n----------------------------------------\n\nTITLE: Running Oryx Docker Container for Live Stream Recording\nDESCRIPTION: This command runs the Oryx container with necessary port mappings for live streaming and recording. It exposes ports for HTTP (80), HTTPS (443), RTMP (1935), and other protocols while mounting a local data directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-09-10-Oryx-Record-Live-Streaming.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 80:2022 -p 443:2443 -p 1935:1935 \\\n  -p 8080:8080 -p 8000:8000/udp -p 10080:10080/udp --name oryx \\\n  -v $HOME/data:/data ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Filtering SRS Logs for Specific Stream Name\nDESCRIPTION: This snippet shows how to further filter logs to find publish sessions for a specific stream name, allowing users to focus on troubleshooting a particular stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"|grep -a \"livestream\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring FMLE for Publishing to SRS Plain Text\nDESCRIPTION: This snippet provides the necessary configuration parameters for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the running SRS instance. The 'FMS URL' specifies the server address and application name, while 'Stream' defines the stream key or name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-arm.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Cloning and Navigating SRS Source - Bash\nDESCRIPTION: This snippet demonstrates how to clone the SRS repository from GitHub and change into the trunk source directory. It assumes Git is installed and network access to GitHub. No special parameters are required, but the user must have permission to create and write to the target directory. Output is the local SRS source code ready for build and configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Monitor SRS Process CPU Usage\nDESCRIPTION: Command to identify and monitor CPU usage of the SRS streaming process using top command.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/raspberrypi.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep srs|grep objs|awk '{print $2}'` && top -p $pid\n```\n\n----------------------------------------\n\nTITLE: Overriding ASAN Options for SRS\nDESCRIPTION: Command to run SRS with custom ASAN options, enabling error halting, leak detection, and allocation/deallocation mismatch detection for more thorough debugging.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nASAN_OPTIONS=halt_on_error=1:detect_leaks=1:alloc_dealloc_mismatch=1 ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS 4 with Shared FFmpeg Library Linking (Bash)\nDESCRIPTION: This command configures the SRS 4 build process to enable integration with FFmpeg (`--ffmpeg-fit=on`) and link against it as a shared library (`--shared-ffmpeg=on`). This allows SRS to leverage FFmpeg functionalities, often used for transcoding, while dynamically linking to the FFmpeg libraries, which are typically LGPL licensed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/license.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-fit=on --shared-ffmpeg=on\n```\n\n----------------------------------------\n\nTITLE: OCR AI Instructions for Text Recognition\nDESCRIPTION: Instructions prompt for configuring the AI to perform text recognition in images. This prompt should be added to the Service Settings > AI Instructions section in Oryx.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-05-20-OCR-Video-Streams.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nRecognize the text in the image. Output the identified text directly.\n```\n\n----------------------------------------\n\nTITLE: Building NGINX-RTMP from Source\nDESCRIPTION: Configure and build commands for compiling NGINX with RTMP module support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./configure --prefix=`pwd`/../_release \\\n--add-module=`pwd`/../nginx-rtmp-module-1.0.4 \\\n--with-http_ssl_module && make && make install\n```\n\n----------------------------------------\n\nTITLE: Installing ARMv7 Cross-Compilation Tools\nDESCRIPTION: Command to install the necessary toolchain for cross-compiling to ARMv7 architecture on an Ubuntu system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Visualizing Edge Distribution via SRS and NGINX - Text Diagram\nDESCRIPTION: ASCII art diagram showing a more complex topology where both SRS Edge and NGINX participate in distributing FLV and HLS streams, highlighting the role of each node for various protocols. Used exclusively for explanatory context.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n+------------+           +------------+\\n| SRS Origin +--RTMP-->--+ SRS Edge   +\\n+-----+------+           +----+-------+\\n      |                       |               +------------+\\n      |                       +---HTTP-FLV->--+   NGINX    +              +-----------+\\n      |                                       +   Edge     +--HLS/FLV-->--+ Visitors  +\\n      +-------HLS--->-------------------------+   Servers  +              +-----------+\\n                                              +------------+\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Server on ARM - Bash\nDESCRIPTION: Launches the SRS server on the ARM device using the specified configuration file. Assumes prior deployment of SRS binaries and configuration file to 'objs/srs' and 'conf/rtmp.conf'. Outputs server log to the process's stdout/stderr.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-arm.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/rtmp.conf\n```\n\n----------------------------------------\n\nTITLE: Trace Session ID in Edge Log\nDESCRIPTION: Uses grep to find all log entries for a specific session ID on the edge server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\ngrep --color -ina \"\\[108\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Service Status\nDESCRIPTION: Command to check the current status of the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs status\n```\n\n----------------------------------------\n\nTITLE: Illustrating ATC-Based Fault-Tolerant RTMP/HLS Architecture - Bash/Diagram\nDESCRIPTION: This ASCII-art bash code block illustrates a typical SRS-based deployment for RTMP ATC fault backup. The diagram outlines encoders, multiple origin servers, packagers, and a reverse proxy (e.g., nginx) feeding a CDN, all connected with RTMP/ATC links. It serves as a high-level guidance for system architects designing fault-tolerant streaming systems. No dependenciespurely a visual aid; receives no input and produces no output.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-atc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n                        +----------+        +----------+\\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\\n+----------+   | RTMP   +----------+ RTMP   +----------+ |   | Reverse |    +-------+\\n| encoder  +->-+                                         +->-+  Proxy  +-->-+  CDN  +\\n+----------+   |        +----------+        +----------+ |   | (nginx) |    +-------+\\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\\n                 RTMP   +----------+ RTMP   +----------+\n```\n\n----------------------------------------\n\nTITLE: Configuring UTC Time Usage in SRS\nDESCRIPTION: Controls whether SRS uses UTC time or local time for generating time structures. When enabled, gmtime() is used instead of localtime() to generate timestamps with UTC time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_5\n\nLANGUAGE: config\nCODE:\n```\n# whether use utc_time to generate the time struct,\n# if off, use localtime() to generate it,\n# if on, use gmtime() instead, which use UTC time.\n# default: off\nutc_time            off;\n```\n\n----------------------------------------\n\nTITLE: Markdown Blog Post Structure\nDESCRIPTION: Frontmatter and structure for a blog post documenting SRS's 10th anniversary and 2023 year-end review. Includes metadata like slug, title, authors and tags.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-12-15-SRS-Ten-Years.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nslug: srs-ten-years\ntitle: SRS 10th Anniversary and 2023 Year-end Review\nauthors: []\ntags: [srs, community]\ncustom_edit_url: null\n---\n```\n\n----------------------------------------\n\nTITLE: Illustrating Header Field Folding Example 2 (RFC 822)\nDESCRIPTION: Provides another example of header field folding, showing more complex splitting within and between address specifications. Folding occurs where linear-white-space is permitted, indicated by indentation on subsequent lines.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nTo:  \"Joe & J. Harvey\"\n                <ddd@ Org>, JJV\n @BBN\n```\n\n----------------------------------------\n\nTITLE: Single Proxy Server with Multiple Origin Servers Architecture\nDESCRIPTION: Diagram showing a simpler architecture with a single proxy server connecting to multiple origin servers, suitable for supporting many streams with fewer viewers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n                                       +--------------------+\n                               +-------+ SRS Origin Server  +\n                               +       +--------------------+\n                               +\n+-----------------------+      +       +--------------------+\n+ SRS Proxy(Deployment) +------+-------+ SRS Origin Server  +\n+-----------------------+      +       +--------------------+\n                               +\n                               +       +--------------------+\n                               +-------+ SRS Origin Server  +\n                                       +--------------------+\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server with HLS Configuration in Bash\nDESCRIPTION: Command to start the SRS server using the HLS configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/hls.conf\n```\n\n----------------------------------------\n\nTITLE: Parsing Multi-Level RTMP URLs in srs_player/srs_publisher (Bash Example)\nDESCRIPTION: Demonstrates how SRS client tools (`srs_player`, `srs_publisher`) parse a given RTMP URL, even one with multiple levels in the path. The tools interpret the part after the last '/' as the stream name and the preceding path components (after the host) as the application name (tcUrl).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n// For both srs_player and srs_publisher:\n// play or publish the following rtmp URL:\nrtmp://demo.srs.com/show/live/livestream/2013\nschema: rtmp\nhost/vhost: demo.srs.com\napp: show/live/livestream\nstream: 2013\n```\n\n----------------------------------------\n\nTITLE: FMLE Streaming Configuration\nDESCRIPTION: Configuration parameters for Adobe Flash Media Live Encoder (FMLE) to stream to the RTMP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Code\nDESCRIPTION: Command to update existing SRS codebase using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-srt.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: WordPress SRS Player Integration for FLV Live Streaming\nDESCRIPTION: Code snippet showing how to embed an FLV live stream into a WordPress page using the SRS Player plugin. This allows for displaying live video content directly on a WordPress site.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-06-30-Video-Chat-Live.md#2025-04-23_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n[srs_player url=\"http://your-server-ip/live/livestream.flv\"]\n```\n\n----------------------------------------\n\nTITLE: Installing aarch64 Cross-Compilation Toolchain in Ubuntu Docker\nDESCRIPTION: Inside the Ubuntu 16 Docker container (started previously), this command uses `apt-get` to install the necessary cross-compilation toolchain (`gcc-aarch64-linux-gnu` and `g++-aarch64-linux-gnu`) required to build SRS for the aarch64 architecture.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Defining the EXTINF Tag in M3U8 Media Playlists\nDESCRIPTION: Specifies the format of the EXTINF tag, used to declare the duration of the media segment that immediately follows it in the playlist. Each media segment URI MUST be preceded by an EXTINF tag. 'duration' is the segment duration in seconds (integer or float depending on protocol version), and 'title' is an optional human-readable informative description.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_2\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTINF:<duration>,<title>\n```\n\n----------------------------------------\n\nTITLE: Slave SRS Server Configuration\nDESCRIPTION: Configuration file for the slave SRS server that receives forwarded streams. Sets up listening port 19350.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-forward.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# conf/forward.slave.conf\nlisten              19350;\npid                 ./objs/srs.slave.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.slave.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Publish Normal Timeout in SRS\nDESCRIPTION: Configures the timeout in milliseconds for normal packets received from an encoder during publishing. This handles ongoing connectivity issues after the initial connection has been established.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/special-control.md#2025-04-23_snippet_3\n\nLANGUAGE: config\nCODE:\n```\nvhost __defaultVhost__ {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # the normal packet timeout in ms for encoder.\n        # default: 5000\n        normal_timeout      7000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Email Address with Periods in Local-Part\nDESCRIPTION: A demonstration of a valid email address containing periods in the local-part which doesn't require quotation marks, as the periods are treated as lexical separators with no semantic meaning.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_34\n\nLANGUAGE: plain text\nCODE:\n```\nFirst.Last@Registry.Org\n```\n\n----------------------------------------\n\nTITLE: Example RTMP URL Structure\nDESCRIPTION: This snippet demonstrates the structure of an RTMP URL, showing how to split it into a push stream address and stream key for custom platform integration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_14\n\nLANGUAGE: plaintext\nCODE:\n```\nrtmp://ip/app/stream\n```\n\n----------------------------------------\n\nTITLE: Cloning the Tencent Cloud XiaoZhiBo Repository\nDESCRIPTION: Git command to clone the XiaoZhiBo repository from Tencent Cloud. This repository contains a complete implementation of a live streaming solution with chat functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-06-30-Video-Chat-Live.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/tencentyun/XiaoZhiBo\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Configuration settings for publishing stream using Flash Media Live Encoder (FMLE).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-realtime.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Servers\nDESCRIPTION: Commands to start the origin SRS server and two edge servers using their respective configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.flv.live.conf &\n./objs/srs -c conf/http.flv.live.edge1.conf &\n./objs/srs -c conf/http.flv.live.edge2.conf &\n```\n\n----------------------------------------\n\nTITLE: Diagramming OBS Restreaming Flow\nDESCRIPTION: This ASCII diagram shows the direct restreaming flow from OBS to multiple streaming platforms, highlighting the difference from SRS restreaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_13\n\nLANGUAGE: plaintext\nCODE:\n```\nOBS --RTMP--> Video number, Bilibili, Kuaishou, and other live streaming platforms\n```\n\n----------------------------------------\n\nTITLE: WordPress Shortcode for SRS Player Integration\nDESCRIPTION: WordPress shortcode example to embed an SRS player into a WordPress page. The URL parameter points to the HLS stream that will be played on the WordPress site.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-29-BT-aaPanel.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n[srs_player url=\"http://159.223.85.157/live/livestream.m3u8\"]\n```\n\n----------------------------------------\n\nTITLE: Rotating SRS Logs\nDESCRIPTION: Command to trigger log rotation in SRS by sending SIGUSR1 signal via the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs rotate\n```\n\n----------------------------------------\n\nTITLE: Building libx265 Dependency from Source - Bash\nDESCRIPTION: This snippet shows how to clone, configure, build, and install libx265 for use as an HEVC encoder within FFmpeg. The build process disables shared libraries (makes a static build), suitable for statically linking with FFmpeg. Required tools include git, cmake, make, and a compiler chain; ensure that the ~/git path exists and is writable. Input: none; Output: Static library and binaries for libx265; Limitation: May need to modify cmake prefix paths depending on OS layout.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://bitbucket.org/multicoreware/x265_git.git ~/git/x265_git\ncd ~/git/x265_git/build/linux\ncmake -DCMAKE_INSTALL_PREFIX=$(pwd)/build -DENABLE_SHARED=OFF ../../source\nmake -j10\nmake install\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS TS Floor in SRS YAML\nDESCRIPTION: Enables floor-based calculation for HLS TS file path generation. This affects timestamp calculations and segment deviation algorithms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/special-control.md#2025-04-23_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_ts_floor    off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository - Bash\nDESCRIPTION: Commands to clone the SRS media server repository from GitHub or update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Cloning and Navigating SRS Repository - Bash\nDESCRIPTION: This snippet demonstrates how to clone the SRS project from GitHub and change into the relevant directory for building the server. Git must be installed on the system. The command downloads the source code and prepares it for subsequent build steps. No parameters are required beyond a functioning network connection.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-realtime.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Manually Triggering logrotate for SRS Configuration (Shell)\nDESCRIPTION: Specifies the command to manually force `logrotate` to run using the defined SRS configuration file (`/etc/logrotate.d/srs`). This is useful for testing the configuration immediately without waiting for the scheduled execution (e.g., daily cron job).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nlogrotate -f /etc/logrotate.d/srs\n```\n\n----------------------------------------\n\nTITLE: Applying Netflix-Style Subtitles\nDESCRIPTION: Configures subtitles with Netflix-like styling including font, size, color, and background with the Roboto font as a substitute for Consolas.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_18\n\nLANGUAGE: text\nCODE:\n```\nFontname=Roboto,Fontsize=12,PrimaryColour=&HFFFFFF,BorderStyle=0,BackColour=&H80000000,Outline=0,Shadow=0.75\n```\n\n----------------------------------------\n\nTITLE: SRS ATC Auto Configuration\nDESCRIPTION: Configuration for automatic ATC detection based on encoder metadata, showing how to enable/disable automatic ATC detection\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-atc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost atc.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Auto ATC for Encoder in SRS RTMP Server\nDESCRIPTION: This snippet demonstrates how to configure automatic ATC detection for encoders in the SRS RTMP server. It allows the server to automatically enable ATC when the encoder sets the 'bravo_atc' field to 'true' in the onMetaData packet.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-atc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost atc.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Analyzing NGINX Cache Hit Rate for TS Files\nDESCRIPTION: Command to analyze NGINX logs and check cache effectiveness for TS files by counting cache status occurrences.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncat /var/log/nginx/access.log | grep '.ts HTTP' \\\n  | awk '{print $1}' | sort | uniq -c | sort -r\n```\n\n----------------------------------------\n\nTITLE: Starting Second Edge Server on Port 1935 (Bash)\nDESCRIPTION: Command to start a second SRS edge server listening on the same port 1935. This demonstrates the use of SO_REUSEPORT.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge2.conf\n```\n\n----------------------------------------\n\nTITLE: Adding SRS as a Service in CentOS\nDESCRIPTION: Command to add SRS as a system service in CentOS using chkconfig. This is step 3 of the setup process for CentOS systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n#centos 6\nsudo /sbin/chkconfig --add srs\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARMv7\nDESCRIPTION: Configure and make commands to cross-compile SRS for ARMv7 architecture. This uses the ARMv7 cross-compilation toolchain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/arm.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=arm-linux-gnueabihf-\nmake\n```\n\n----------------------------------------\n\nTITLE: Example Valgrind 'Still Reachable' Leak Report\nDESCRIPTION: Displays a specific Valgrind report indicating 'still reachable' memory, often associated with global or static variables that are allocated once and never freed, which is usually not a true leak. The stack trace points to the allocation site within SRS code (`srs_app_config.cpp`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_23\n\nLANGUAGE: text\nCODE:\n```\n==3430715== 1,040 (+1,040) bytes in 1 (+1) blocks are still reachable in new loss record 797 of 836\n==3430715==    at 0x4C3F963: calloc (vg_replace_malloc.c:1595)\n==3430715==    by 0x7D8DB0: SrsConfig::get_hls_vcodec(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >) (srs_app_config.cpp:7156)\n==3430715==    by 0x781283: SrsHlsMuxer::segment_open() (srs_app_hls.cpp:418)\n```\n\n----------------------------------------\n\nTITLE: Playing HLS Stream from SRS Origin\nDESCRIPTION: URL for playing an HLS stream from the SRS Origin server deployed on Kubernetes. The IP address should be replaced with the actual External IP of the srs-http-service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nhttp://28.170.32.118/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: This snippet shows how to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Monitoring Per-CPU Usage with top/mpstat in Bash\nDESCRIPTION: Provides two methods to monitor per-CPU utilization. First, run `top` and press the '1' key to toggle the display of individual CPU statistics. Second, use `mpstat -P ALL` to get a detailed report of CPU statistics for all available CPUs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\ntop # Press 1\n#%Cpu0  :  1.8 us,  1.1 sy,  0.0 ni, 90.8 id,  0.0 wa,  0.0 hi,  6.2 si,  0.0 st\n#%Cpu1  : 67.6 us, 17.6 sy,  0.0 ni, 14.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n```\n\nLANGUAGE: bash\nCODE:\n```\nmpstat -P ALL\n#01:23:14 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle\n#01:23:14 PM  all   33.33    0.00    8.61    0.04    0.00    3.00    0.00    0.00    0.00   55.02\n#01:23:14 PM    0    2.46    0.00    1.32    0.06    0.00    6.27    0.00    0.00    0.00   89.88\n#01:23:14 PM    1   61.65    0.00   15.29    0.02    0.00    0.00    0.00    0.00    0.00   23.03\n```\n\n----------------------------------------\n\nTITLE: Discouraged Multi-Level RTMP URL Paths in SRS\nDESCRIPTION: These examples illustrate RTMP URLs with hierarchical application (`show/live/livestream`) or stream (`livestream/2013`) names. The accompanying text discourages this practice within the SRS ecosystem, as default SRS tools like `srs_player` and `srs_publisher` might parse them incorrectly, assuming only the last component after a slash is the stream name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n// appstream\nrtmp://demo.srs.com/show/live/livestream\nrtmp://demo.srs.com/show/live/livestream/2013\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-Coroutine TCP Logic with Epoll\nDESCRIPTION: Example of non-coroutine TCP code using epoll for asynchronous I/O handling. This demonstrates how business logic gets mixed with low-level event handling, making code more complex and harder to maintain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint fd = accept(listen_fd); // Got a TCP connection.\n\nint n = read(fd, buf, sizeof(buf));\nif (n == -1) {\n  if (errno == EAGAIN) { // Not ready\n    return epoll_ctl(fd, EPOLLIN); // Wait for fd to be ready.\n  }\n  return n; // Error.\n}\n\nprintf(\"Got %d size of data %p\", n, buf);\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Configuration parameters for publishing a stream using Flash Media Live Encoder (FMLE) to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-realtime.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Visualizing HLS Edge Cluster Architecture - Text Diagram\nDESCRIPTION: This snippet is an ASCII art diagram that visually represents the data flow in an HLS edge cluster using FFmpeg/OBS for source, SRS for the origin, NGINX as proxy/cache, and Visitors as clients. The diagram helps explain overall architecture and streaming flow but does not contain executable code. It provides context for subsequent technical configurations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/nginx-for-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+------------+          +------------+          +------------+          +------------+\\n+ FFmpeg/OBS +--RTMP-->-+ SRS Origin +--HLS-->--+ NGINX      +--HLS-->--+ Visitors   +\\n+------------+          +------------+          + Servers    +          +------------+\\n                                                +------------+          \n```\n\n----------------------------------------\n\nTITLE: Using SrsSharedPtr in C++\nDESCRIPTION: Example demonstrating the usage of SrsSharedPtr for managing object lifecycle, including creation and copying of shared pointers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nSrsSharedPtr<MyClass> ptr(new MyClass());\nptr->do_something();\n\nSrsSharedPtr<MyClass> cp = ptr;\ncp->do_something();\n```\n\n----------------------------------------\n\nTITLE: System Process Profiling with Instruments on macOS (bash)\nDESCRIPTION: Invokes Apple's Instruments tool to profile a process using the Time Profiler template for 30 seconds. This command requires Xcode tools installed and a running process PID (72030 in this example). The '-l 30000' parameter sets the duration in milliseconds, while '-t Time\\ Profiler' specifies the profiler type.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ninstruments -l 30000 -t Time\\ Profiler -p 72030\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Parameter, Attribute, and Value Syntax - ABNF\nDESCRIPTION: Provides formal grammar for HTTP parameters, attributes, and values used in transfer-coding extensions. Dependencies include RFC 2616 rules for 'token' and 'quoted-string'. Parameters are essential for specifying key/value options in HTTP header fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_12\n\nLANGUAGE: abnf\nCODE:\n```\nparameter               = attribute \"=\" value\nattribute               = token\nvalue                   = token | quoted-string\n```\n\n----------------------------------------\n\nTITLE: System Resource Statistics Command\nDESCRIPTION: Command showing system resource usage including CPU, disk, network, and paging statistics.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/raspberrypi.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 ~]$ dstat 30\\n----total-cpu-usage---- -dsk/total- -net/lo- ---paging-- ---system--\\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \\n  0   0  96   0   0   3|   0     0 |1860B   58k|   0     0 |2996   465 \\n  0   1  96   0   0   3|   0     0 |1800B   56k|   0     0 |2989   463 \\n  0   0  97   0   0   2|   0     0 |1500B   46k|   0     0 |2979   461\n```\n\n----------------------------------------\n\nTITLE: Configuring Normal Packet Timeout for RTMP Publishers in SRS\nDESCRIPTION: Sets the timeout in milliseconds for normal packets from RTMP publishers. This helps manage ongoing connection timeouts for encoders during streaming.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    publish {\n        normal_timeout      7000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code using Git (Bash)\nDESCRIPTION: Pulls the latest changes from the remote repository for an existing local clone of SRS. This command should be run within the SRS repository directory to ensure the code is up-to-date before building.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ffmpeg.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFMPEG\nDESCRIPTION: A loop script that uses FFMPEG to continuously publish a source video to the SRS server. It copies the stream without re-encoding for better performance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-realtime.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Checking UDP Queue Length\nDESCRIPTION: Displays the current length of UDP queues, which can help identify potential bottlenecks in network processing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/performance.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnetstat -lpun\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository using Git (Bash)\nDESCRIPTION: Clones the SRS source code from the official GitHub repository into a local directory named 'srs' and changes the current directory to `srs/trunk`. Requires Git to be installed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Implementation of ST Read Function with Coroutine Switching\nDESCRIPTION: The implementation of st_read function which handles EAGAIN by switching coroutines, allowing the thread to process other work while waiting for I/O. This demonstrates how coroutines hide the complexity of asynchronous operations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nssize_t st_read(_st_netfd_t *fd, void *buf, size_t nbyte) {\n    while ((n = read(fd->osfd, buf, nbyte)) < 0) {\n        if (errno == EINTR)\n            continue;\n        if (!_IO_NOT_READY_ERROR) // Error, if not EAGAIN.\n            return -1;\n\n        /* Wait until the socket becomes readable */\n        if (st_netfd_poll(fd, POLLIN) < 0) // EAGAIN\n            return -1;\n    }\n    \n    return n;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Nginx with RTMP Module (Bash)\nDESCRIPTION: Shell commands to configure, compile, and install Nginx with the nginx-rtmp-module and http_ssl_module. The compilation uses specific source versions (nginx-1.5.7, nginx-rtmp-module-1.0.4) and installs the result into a relative `_release` directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --prefix=`pwd`/../_release \\\n--add-module=`pwd`/../nginx-rtmp-module-1.0.4 \\\n--with-http_ssl_module && make && make install\n```\n\n----------------------------------------\n\nTITLE: HLS Master Playlist with Alternative Audio Tracks (M3U8)\nDESCRIPTION: Illustrates a master playlist providing alternative audio tracks using the #EXT-X-MEDIA tag with TYPE=AUDIO. It defines an audio group (\"aac\") and lists English (default), German, and Commentary tracks, linking them to their respective playlists. The #EXT-X-STREAM-INF tags reference the audio group using the AUDIO attribute.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_26\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",NAME=\"English\", \\\n   DEFAULT=YES,AUTOSELECT=YES,LANGUAGE=\"en\", \\\n   URI=\"main/english-audio.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",NAME=\"Deutsch\", \\\n   DEFAULT=NO,AUTOSELECT=YES,LANGUAGE=\"de\", \\\n   URI=\"main/german-audio.m3u8\"\n#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID=\"aac\",NAME=\"Commentary\", \\\n   DEFAULT=NO,AUTOSELECT=NO,URI=\"commentary/audio-only.m3u8\"\n#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"...\",AUDIO=\"aac\"\nlow/video-only.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=2560000,CODECS=\"...\",AUDIO=\"aac\"\nmid/video-only.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=7680000,CODECS=\"...\",AUDIO=\"aac\"\nhi/video-only.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\",AUDIO=\"aac\"\nmain/english-audio.m3u8\n```\n\n----------------------------------------\n\nTITLE: Cloning and Syncing SRS Repository from Gitlab Mirror - Bash Shell\nDESCRIPTION: This snippet illustrates cloning the SRS project from the Gitlab mirror to a folder named \\\"srs\\\", changing into that folder, setting the remote origin to the Github repository, and fetching the latest commits. You must have git installed and access to Gitlab and Github. The \\\"git clone\\\" command fetches the repository, and \\\"git remote set-url\\\" ensures future pulls update from the official source. Ideal for scenarios where the Gitlab mirror is more accessible initially.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/resource.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitlab.com/winlinvip/srs-gitlab.git srs &&\\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Demonstrating URL Parsing in SRS Player and Publisher\nDESCRIPTION: Example showing how SRS player and publisher parse RTMP URLs, where the last segment after the final slash is considered the stream name and everything before it (after host) is treated as the tcUrl (vhost/app).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n// For both srs_player and srs_publisher:\n// play or publish the following rtmp URL:\nrtmp://demo.srs.com/show/live/livestream/2013\nschema: rtmp\nhost/vhost: demo.srs.com\napp: show/live/livestream\nstream: 2013\n```\n\n----------------------------------------\n\nTITLE: HTTP Status Code 204 No Content Headers\nDESCRIPTION: Specifies that the 204 response must not include a message body and is terminated by first empty line after headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_45\n\nLANGUAGE: http\nCODE:\n```\n204 No Content\n[headers]\n\n\n```\n\n----------------------------------------\n\nTITLE: HDS Stream URL Format\nDESCRIPTION: Example of an HDS stream URL that can be played with OSMF players or VLC.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/delivery-hds.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhttp://localhost:8080/live/livestream.f4m\n```\n\n----------------------------------------\n\nTITLE: Project Table - Prometheus API Integration\nDESCRIPTION: Markdown table defining the Prometheus API integration project details including mentor information, skills needed, and expected outcomes\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-02-10-GSoC.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|Name of project|SRS support Prometheus API|\n| :---- | :----- |\n|Project Description|Prometheus is a common component of system monitoring, support Prometheus API, so that the monitoring system can display SRS service related properties in the form of charts, or audio and video frame rate, bit rate and other information.|\n|Mentor|Haibo Chen(nmgchenhaibo@foxmail.com)|\n|Backup Mentor|Junqin Zhang(chundonglinlin@163.com)|\n|Skills needed|Familiar with HTTP protocol, understand HTTP server-client interaction process.|\n|Expected size of project|180 hours|\n|Difficulty|Beginner|\n|Expected results|Use Prometheus client to be able to access and get the expected results.|\n|Qualification Task|Complete the Prometheus API writing and testing.|\n```\n\n----------------------------------------\n\nTITLE: Monitoring Network Statistics and UDP Packet Drops\nDESCRIPTION: Commands to check network statistics and UDP packet dropping, useful for diagnosing performance issues. The second command compares statistics over a 30-second interval.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnetstat -suna\nnetstat -suna && sleep 30 && netstat -suna\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Code - Bash\nDESCRIPTION: Command to update existing SRS codebase using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC in SRS RTMP Server\nDESCRIPTION: This snippet shows how to configure ATC (Absolute Timestamp Control) in the SRS RTMP server. It enables the server to deliver RTMP streams using absolute time, which is crucial for implementing HLS/HDS hot backup systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-atc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        # \n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # default: off\n        atc             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: WebRTC Source Manager Implementation\nDESCRIPTION: Definition of WebRTC source manager class showing shared pointer usage for source management and consumer relationships.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nclass SrsRtcSourceManager\n{\npublic:\n    virtual srs_error_t fetch_or_create(SrsRequest* r, SrsSharedPtr<SrsRtcSource>& pps);\n    virtual SrsSharedPtr<SrsRtcSource> fetch(SrsRequest* r);\n    virtual void eliminate(SrsRequest* r);\n};\n```\n\n----------------------------------------\n\nTITLE: Gracefully Quitting SRS via Init.d Script - Bash\nDESCRIPTION: Initiates a graceful shutdown of SRS, allowing active connections to close before the service exits, using SIGQUIT. Triggered via the 'grace' command of the init.d script. Needs running SRS service; ensures minimal disruption during upgrades or restarts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs grace\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source in Bash\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: HLS Master Playlist for Adaptive Bitrate Streaming (M3U8)\nDESCRIPTION: An example of an HLS master playlist file. It lists multiple variant streams (#EXT-X-STREAM-INF), each with a different bandwidth and linking to its corresponding media playlist (e.g., low.m3u8, mid.m3u8). It also includes an audio-only variant with specified codecs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_24\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=1280000\nhttp://example.com/low.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=2560000\nhttp://example.com/mid.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=7680000\nhttp://example.com/hi.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\nhttp://example.com/audio-only.m3u8\n```\n\n----------------------------------------\n\nTITLE: Filtering SRS Logs for Publish Events in Bash\nDESCRIPTION: Example of using grep to filter SRS logs to identify publish events, showing how to find specific streaming sessions based on stream type and name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ cat objs/srs.log|grep -ina \"identify client success. type=publish\"\n20:[2014-04-04 11:56:06.288][trace][104][11] identify client success. type=publish, stream_name=livestream\n43:[2014-04-04 11:56:18.138][trace][105][11] identify client success. type=publish, stream_name=winlin\n65:[2014-04-04 11:56:29.531][trace][106][11] identify client success. type=publish, stream_name=livestream\n86:[2014-04-04 11:56:35.966][trace][107][11] identify client success. type=publish, stream_name=livestream\n```\n\n----------------------------------------\n\nTITLE: NGINX Edge Server Configuration\nDESCRIPTION: NGINX configuration for edge server with proxy cache settings to deliver HLS content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: nginx\nCODE:\n```\n# conf/hls.edge.conf\nworker_processes  3;\nevents {\n    worker_connections  10240;\n}\n\nhttp {\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       8081;\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring FMLE for RTMP Publishing - Text\nDESCRIPTION: This snippet provides the parameters needed to configure Flash Media Live Encoder (FMLE) to publish an RTMP stream to SRS. The FMS URL is the RTMP endpoint, and the Stream field specifies the stream name. These should be entered into the FMLE GUI to begin publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-realtime.md#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Service\nDESCRIPTION: Command to reload the SRS service using the init.d script without full restart.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Accessing S3 Recorded File Path in Bash\nDESCRIPTION: This snippet shows the file path structure for recorded files stored in S3 storage. The {RECORD-UUID} is a placeholder for the unique identifier of each recorded file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n/data/srs-s3-bucket/{RECORD-UUID}.mp4\n```\n\n----------------------------------------\n\nTITLE: Running RTMP Load Test with sb_rtmp_load\nDESCRIPTION: Command to launch the sb_rtmp_load testing tool with 500 concurrent clients targeting the SRS RTMP server. The output is redirected to /dev/null and the process runs in the background to allow monitoring.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 500 -r rtmp://127.0.0.1:1935/live/livestream >/dev/null &\n```\n\n----------------------------------------\n\nTITLE: Pausing and Resuming Kubernetes Rolling Updates (Bash)\nDESCRIPTION: These commands demonstrate controlling the rollout process of a Kubernetes deployment. `kubectl rollout pause deploy/srs-edge-deploy` halts the ongoing or prevents the next rolling update for the specified deployment. This allows for inspection or manual intervention. `kubectl rollout resume deploy/srs-edge-deploy` continues a paused rollout process from where it left off. Note that pausing doesn't stop pods currently being terminated but prevents new pods from being created or old ones from being terminated until resumed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nkubectl rollout pause deploy/srs-edge-deploy\n```\n\nLANGUAGE: bash\nCODE:\n```\nkubectl rollout resume deploy/srs-edge-deploy\n```\n\n----------------------------------------\n\nTITLE: NGINX-RTMP Configuration File\nDESCRIPTION: NGINX configuration file with RTMP settings for live streaming on port 19350.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nuser  root;\nworker_processes  1;\nevents {\n    worker_connections  10240;\n}\nrtmp{\n    server{\n        listen 19350;\n        application live{\n            live on;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code\nDESCRIPTION: Command to update the existing SRS codebase to the latest version from the repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Installing Logrotate on CentOS/RHEL\nDESCRIPTION: Command to install the logrotate utility using yum package manager\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum install -y logrotate\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using Init Script\nDESCRIPTION: This command uses the SRS init script to perform a configuration reload, which internally sends the SIGHUP signal to the SRS process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/reload.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs reload\n```\n\n----------------------------------------\n\nTITLE: Forcing Network Softirq Affinity to CPU0 in Bash\nDESCRIPTION: This loop identifies IRQ numbers for virtio network interfaces (input/output) and then writes '1' to the `smp_affinity` file for each IRQ. This forces the kernel to handle these network-related interrupts exclusively on CPU0, disabling the default IRQ balancing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\nfor irq in $(grep virtio /proc/interrupts | grep -e in -e out | cut -d: -f1); do \n    echo 1 > /proc/irq/$irq/smp_affinity\ndone\n```\n\n----------------------------------------\n\nTITLE: Adding a fork repository as a remote for TOC members\nDESCRIPTION: Command for TOC members to add a contributor's fork as a remote. This is used when TOC members need to update PRs from contributors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add tmp git@github.com:zhouxiaojun2008/srs.git\n```\n\n----------------------------------------\n\nTITLE: Generating Call Graph Reports with PERF\nDESCRIPTION: Commands to record performance data with call graph information and display the report, showing the call stack for performance hotspots.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nperf record -a --call-graph fp -p $(pidof srs)\nperf report --call-graph --stdio\n```\n\n----------------------------------------\n\nTITLE: Monitoring SRS and Nginx Process Statistics\nDESCRIPTION: This bash command uses top to monitor CPU and memory usage of SRS, Nginx, and load testing processes simultaneously.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nsrs_pid=$(pidof srs); \\\nnginx_pid=`ps aux|grep nginx|grep worker|awk '{print $2}'`; \\\nload_pids=`ps aux|grep objs|grep sb_rtmp_load|awk '{ORS=\",\";print $2}'`; \\\ntop -p $load_pids$srs_pid,$nginx_pid\n```\n\n----------------------------------------\n\nTITLE: HTTP API Request Examples\nDESCRIPTION: Example curl commands demonstrating how to make HTTP API requests to Oryx with and without Bearer authentication\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/mgmt/versions\n```\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/hooks/srs/secret/query \\\n  -X POST -H 'Authorization: Bearer xxxxxx' \\\n  -H 'Content-Type: application/json' --data '{}'\n```\n\n----------------------------------------\n\nTITLE: Project Table - CPU Platform Adaptation\nDESCRIPTION: Markdown table defining the CPU platform adaptation project details including mentor information, skills needed, and expected outcomes\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-02-10-GSoC.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n|Name of project|SRS ported to RISC platform, CPU adaptation|\n| :---- | :----- |\n|Project Description|SRS underlying use of IO libraries, currently has been adapted to Intel, ARM and many other platforms. With the gradual development of RISC, the support for RISC can further enhance the support of SRS for multiple platforms.|\n|Mentor|Winlin(winlinvip@gmail.com)|\n|Backup Mentor|Zhihong Xiao(hondaxiao@tencent.com), Feng Yi(yifeng1983@gmail.com)|\n|Skills needed|Familiar with RISC platform assembly instruction set, familiar with the principle of computer program execution.|\n|Expected size of project|350 hours|\n|Difficulty|Advanced|\n|Expected results|Be able to run SRS on the RIST platform, and run all the functions of 4.0release normally.|\n|Qualification Task|Implement st-thread stack saving on RISC platform, restore logic.|\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream using FFmpeg in Bash\nDESCRIPTION: Bash script using FFmpeg to continuously publish a stream to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-rtmp-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Illustrating Browser-to-SFU WebRTC Communication\nDESCRIPTION: This ASCII diagram depicts a more common WebRTC setup where a browser communicates with an SFU (Selective Forwarding Unit) server, like SRS. The SFU handles both Signaling and Media relay/forwarding, simplifying multi-party communication.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n+----------------+                        +---------+\n+    Browser     +----<--Signaling----->--+   SFU   +\n+ (like Chrome)  +----<----Media----->----+  Server +\n+----------------+                        +---------+\n```\n\n----------------------------------------\n\nTITLE: Example Output of SRS Go HTTP Callback Server Startup\nDESCRIPTION: This shows the typical log output generated when the SRS example Go HTTP callback server (`server.go`) is successfully started using the `go run` command. It confirms that the API server is listening on the specified port (8085) and indicates the directory being served for static files, confirming the server is ready to receive callback requests.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n#2023/01/18 22:57:40.835254 server.go:572: api server listen at port:8085, static_dir:/Users/panda/srs/trunk/static-dir\n#2023/01/18 22:57:40.835600 server.go:836: start listen on::8085\n```\n\n----------------------------------------\n\nTITLE: Defining Specific Repetition (NRULE) in Augmented BNF\nDESCRIPTION: Describes the notation for specifying an exact number of repetitions in augmented BNF. '<n>(element)' is defined as equivalent to '<n>*<n>(element)', meaning exactly 'n' occurrences. Examples '2DIGIT' for a two-digit number and '3ALPHA' for a three-character alphabetic string are provided.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_4\n\nLANGUAGE: abnf\nCODE:\n```\n<n>(element)\n```\n\nLANGUAGE: abnf\nCODE:\n```\n<n>*<n>(element)\n```\n\nLANGUAGE: abnf\nCODE:\n```\n2DIGIT\n```\n\nLANGUAGE: abnf\nCODE:\n```\n3ALPHA\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS codebase from GitHub repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: SRS Daemon Mode Startup Message\nDESCRIPTION: Example of the startup message when running SRS in default daemon mode, showing the initial log messages and suggestions for how to follow the log file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -c conf/srs.conf \n[2014-04-14 12:12:57.775][trace][0][0] config parse complete\n[2014-04-14 12:12:57.775][trace][0][0] write log to file ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] you can: tailf ./objs/srs.log\n[2014-04-14 12:12:57.775][trace][0][0] @see https://ossrs.net/lts/zh-cn/docs/v4/doc/log\n```\n\n----------------------------------------\n\nTITLE: Trace Session ID in Origin Log\nDESCRIPTION: Uses grep to find all log entries for a specific session ID on the origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngrep -ina \"\\[107\\]\" objs/srs.origin.log\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg in Bash\nDESCRIPTION: Bash script to continuously publish a video stream using FFmpeg to the SRS server running on the ARM device.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-arm.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for RTMP Forwarding (plaintext)\nDESCRIPTION: SRS configuration file (`conf/srs.conf`) content. Sets the listening port to 1935, maximum connections to 10240, and configures the default virtual host to forward incoming RTMP streams to the nginx-rtmp server running on localhost port 19350.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\nlisten              1935;\nmax_connections     10240;\nvhost __defaultVhost__ {\n    forward         127.0.0.1:19350;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Master SRS Server\nDESCRIPTION: Command to start the master SRS server with the forward configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-forward.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/forward.master.conf\n```\n\n----------------------------------------\n\nTITLE: HLS Playlist with AES-128 Encrypted Segments (M3U8)\nDESCRIPTION: Demonstrates an M3U8 playlist where media segments are encrypted using AES-128. It includes the #EXT-X-KEY tag specifying the encryption method and the URI to fetch the decryption key. The key tag applies to subsequent segments until another key tag is encountered.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_23\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-MEDIA-SEQUENCE:7794\n#EXT-X-TARGETDURATION:15\n\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=52\"\n\n#EXTINF:2.833,\nhttp://media.example.com/fileSequence52-A.ts\n#EXTINF:15.0,\nhttp://media.example.com/fileSequence52-B.ts\n#EXTINF:13.333,\nhttp://media.example.com/fileSequence52-C.ts\n\n#EXT-X-KEY:METHOD=AES-128,URI=\"https://priv.example.com/key.php?r=53\"\n\n#EXTINF:15.0,\nhttp://media.example.com/fileSequence53-A.ts\n```\n\n----------------------------------------\n\nTITLE: Defining Date Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax and usage of the Date general-header field in HTTP/1.1. This header represents the date and time at which the message was originated.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_67\n\nLANGUAGE: HTTP\nCODE:\n```\nDate  = \"Date\" \":\" HTTP-date\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Request Structure in BNF Notation\nDESCRIPTION: Defines the structure of an HTTP request message using Backus-Naur Form notation. A request consists of a Request-Line followed by headers and an optional message body.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_24\n\nLANGUAGE: text\nCODE:\n```\nRequest       = Request-Line              ; Section 5.1\n                        *(( general-header        ; Section 4.5\n                         | request-header         ; Section 5.3\n                         | entity-header ) CRLF)  ; Section 7.1\n                        CRLF\n                        [ message-body ]          ; Section 4.3\n```\n\n----------------------------------------\n\nTITLE: Creating an SRS Windows Package with NSIS\nDESCRIPTION: Command for building a Windows installer package using NSIS. This script sets the SRS version dynamically, specifies the Cygwin directory, and runs the NSIS script to create the installer.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/windows.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"/cygdrive/c/Program Files (x86)/NSIS/makensis.exe\" \\\n    /DSRS_VERSION=$(./objs/srs -v 2>&1) \\\n    /DCYGWIN_DIR=\"C:\\cygwin64\" \\\n    packaging/nsis/srs.nsi\n```\n\n----------------------------------------\n\nTITLE: SRS 6.0 HEVC Integration Pull Requests\nDESCRIPTION: List of pull requests that merge HEVC support into SRS 6.0, showing the implementation timeline across different protocols like WebRTC, GB28181, SRT, DVR, HLS, and HTTP-TS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/hevc.md#2025-04-23_snippet_15\n\nLANGUAGE: markdown\nCODE:\n```\n* [PULL HEVC over WebRTC by Safari. v6.0.34](https://github.com/ossrs/srs/pull/3441)\n* [GB: Support H.265 for GB28181. v6.0.25 (#3408)](https://github.com/ossrs/srs/pull/3408)\n* [H265: Support HEVC over SRT. v6.0.20 (#465) (#3366)](https://github.com/ossrs/srs/pull/3366)\n* [H265: Support DVR HEVC stream to MP4. v6.0.14](https://github.com/ossrs/srs/pull/3360)\n* HLS: Support HEVC over HLS. v6.0.11\n* [HEVC: The codec information is incorrect. v6.0.5](https://github.com/ossrs/srs/issues/3271)\n* FFmpeg support libx265 and HEVC over RTMP/FLV: [CentOS7](https://github.com/ossrs/dev-docker/commit/0691d016adfe521f77350728d15cead8086d527d), [Ubuntu20](https://github.com/ossrs/dev-docker/commit/0e36323d15544ffe2901d10cfd255d9ef08fb250) and [Encoder](https://github.com/ossrs/dev-docker/commit/782bb31039653f562e0765a0c057d9f9babd1d1f).\n* [H265: Support HEVC over HTTP-TS. v6.0.4](https://github.com/ossrs/srs/commit/70d5618979e5c8dc41b7cd87c78db7ca2b8a10e8)\n* [H265: Support parse multiple NALUs in a frame. v6.0.3](https://github.com/ossrs/srs/commit/f316e9a0de3a892d25f2d8e7efd28ee9334f5bd6)\n* [H265: Support HEVC over RTMP or HTTP-FLV. v6.0.2](https://github.com/ossrs/srs/commit/178e40a5fc3cf0856ace914ae61696a73007f5bf)\n* [H265: Update mpegts.js to play HEVC over HTTP-TS/FLV. v6.0.1](https://github.com/ossrs/srs/commit/7e02d972ea74faad9f4f96ae881d5ece0b89f33b)\n```\n\n----------------------------------------\n\nTITLE: Age Header Syntax in BNF\nDESCRIPTION: BNF syntax definition for the Age response header that conveys time since response generation at origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_53\n\nLANGUAGE: BNF\nCODE:\n```\nAge = \"Age\" \":\" age-value\nage-value = delta-seconds\n```\n\n----------------------------------------\n\nTITLE: Verifying Generated Thumbnails from HttpCallback Approach (Bash, ls)\nDESCRIPTION: This Bash snippet uses the ls command to list PNG snapshot files generated by the callback API server. It helps verify output thumbnails and showcases expected filenames and symlinks for best snapshot selection. Assumes snapshots are stored under research/api-server/static-dir/live/. Inputs: none; Outputs: PNG filenames and metadata.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/snapshot.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nwinlin:srs winlin$ ls -lh research/api-server/static-dir/live/*.png\n-rw-r--r--  1 winlin  staff    73K Oct 20 13:35 livestream-001.png\n-rw-r--r--  1 winlin  staff    91K Oct 20 13:35 livestream-002.png\n-rw-r--r--  1 winlin  staff    11K Oct 20 13:35 livestream-003.png\n-rw-r--r--  1 winlin  staff   167K Oct 20 13:35 livestream-004.png\n-rw-r--r--  1 winlin  staff   172K Oct 20 13:35 livestream-005.png\n-rw-r--r--  1 winlin  staff   264K Oct 20 13:35 livestream-006.png\nlrwxr-xr-x  1 winlin  staff   105B Oct 20 13:35 livestream-best.png -> livestream-006.png\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Command for Mixing Multiple RTMP Streams\nDESCRIPTION: FFmpeg command that combines two RTMP streams into one output stream with picture-in-picture overlay and audio mixing, useful for creating composite views of multiple WebRTC participants.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -f flv -i rtmp://192.168.3.6/live/alice -f flv -i rtmp://192.168.3.6/live/314d0336 \\\n     -filter_complex \"[1:v]scale=w=96:h=72[ckout];[0:v][ckout]overlay=x=W-w-10:y=H-h-10[out]\" -map \"[out]\" \\\n     -c:v libx264 -profile:v high -preset medium \\\n     -filter_complex amix -c:a aac \\\n     -f flv rtmp://192.168.3.6/live/merge\n```\n\n----------------------------------------\n\nTITLE: Updating an existing PR\nDESCRIPTION: Commands to update an existing PR by committing changes to your feature branch and pushing them. This automatically updates the PR without needing to create a new one.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout bugfix/bug-summary\ngit commit -am 'Description for update'\ngit push\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Details for FMLE (Text)\nDESCRIPTION: Provides the connection details required to publish a stream using Adobe Flash Media Live Encoder (FMLE). Users should configure FMLE with the specified FMS URL (`rtmp://192.168.1.170/live`) and Stream name (`livestream`) to send video/audio data to the running SRS instance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Publisher First Packet Timeout in SRS\nDESCRIPTION: Sets the timeout in milliseconds for receiving the first packet from an RTMP publisher (like FMLE or Flash). If the first packet isn't received within this duration, the connection might be dropped. The default value is 20000 ms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # the 1st packet timeout in ms for encoder.\n        # default: 20000\n        firstpkt_timeout    20000;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Certificate Renewal Log Output\nDESCRIPTION: Example output from the certificate renewal log check showing the automated renewal system is working correctly and the certificate is not yet due for renewal.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-12-Oryx-HTTPS.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nOutput\nThread #crontab: auto renew the Let's Encrypt ssl\nThread #crontab: renew ssl updated=false, message is \nProcessing /etc/letsencrypt/renewal/lh.ossrs.io.conf\nCertificate not yet due for renewal\nThe following certificates are not due for renewal yet:\nNo renewals were attempted.\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 3.0 Branch using Git\nDESCRIPTION: Command to pull the latest changes and switch to the SRS 3.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/git.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 3.0release\n```\n\n----------------------------------------\n\nTITLE: Getting SRS Source Code\nDESCRIPTION: Commands to clone or update the SRS source code repository from GitHub.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-hls-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Checking Kubernetes Cluster Access in Bash\nDESCRIPTION: Command to verify access to a Kubernetes cluster by displaying cluster information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/k8s.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkubectl cluster-info\n```\n\n----------------------------------------\n\nTITLE: Linking Blogs in Documentation Using Markdown\nDESCRIPTION: Shows how to create a link to a blog post from within documentation. The example demonstrates a relative path using three directory level upward traversals to reach the blog directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[Oryx aaPanel Plugin](../../../blog/BT-aaPanel)\n```\n\n----------------------------------------\n\nTITLE: Analyzing GMC Results with pprof\nDESCRIPTION: Command to analyze GMC results using pprof tool, showing memory leaks and allocation sites\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/pprof ./objs/srs \"/tmp/srs.11469._main_-end.heap\" --inuse_objects --lines --heapcheck  --edgefraction=1e-10 --nodefraction=1e-10\n```\n\n----------------------------------------\n\nTITLE: HTTP GET Method Implementation\nDESCRIPTION: Details the GET method for retrieving information identified by the Request-URI, including conditional and partial GET implementations using various header fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_41\n\nLANGUAGE: http\nCODE:\n```\nGET /path HTTP/1.1\\nHost: example.com\\nIf-Modified-Since: timestamp\n```\n\n----------------------------------------\n\nTITLE: Markdown Frontmatter Configuration\nDESCRIPTION: YAML frontmatter configuration for the documentation page defining title, sidebar label and display options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/delivery-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: HLS Delivery\nsidebar_label: HLS Delivery\nhide_title: false\nhide_table_of_contents: false\n---\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building SRS - Bash\nDESCRIPTION: This command sequence configures and compiles the SRS project in the current directory. './configure' sets up the build environment based on system parameters, and 'make' compiles the source code. Requires standard build tools (like gcc, make, etc.) to be installed. Outputs compiled binaries and does not require parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository using Git (Bash)\nDESCRIPTION: Clones the Simple Realtime Server (SRS) source code repository from GitHub using Git and changes the current directory to the 'trunk' folder within the cloned repository. This is the first step in obtaining the necessary SRS code for compilation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Build with HDS Support\nDESCRIPTION: Command to configure SRS build with HDS delivery support enabled. This configuration option should be used when compiling SRS from source.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/delivery-hds.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --hds=on\n```\n\n----------------------------------------\n\nTITLE: Compiling the State Threads Example Program\nDESCRIPTION: This bash command compiles the example program (huge_threads.c) with the State Threads library. It includes the necessary headers and links against the static library.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-02-26-State-Threads-for-Internet-Applications.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngcc -I~/git/state-threads/obj -g huge_threads.c ~/git/state-threads/obj/libst.a  -o huge_threads\n```\n\n----------------------------------------\n\nTITLE: Restarting SRS service\nDESCRIPTION: Command to restart the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs restart\n```\n\n----------------------------------------\n\nTITLE: Monitoring Network Bandwidth with dstat (Bash)\nDESCRIPTION: Uses the `dstat` command to monitor network traffic specifically on the loopback interface (`-N lo`) at 30-second intervals (`30`). This helps measure the actual bandwidth consumed by the server processes during the benchmark.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# dstat -N lo 30\n----total-cpu-usage---- -dsk/total- -net/lo- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  0   0  96   0   0   3|   0     0 |1860B   58k|   0     0 |2996   465 \n  0   1  96   0   0   3|   0     0 |1800B   56k|   0     0 |2989   463 \n  0   0  97   0   0   2|   0     0 |1500B   46k|   0     0 |2979   461 \n```\n\n----------------------------------------\n\nTITLE: Pushing your feature branch to your fork\nDESCRIPTION: Command to push your feature branch to your forked repository. The -u flag sets the upstream tracking so future pushes can be done without specifying the remote and branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit push -u origin bugfix/bug-summary\n```\n\n----------------------------------------\n\nTITLE: Profiling C++ Application on macOS using Instruments in Bash\nDESCRIPTION: Demonstrates how to use the `instruments` command-line tool on macOS to perform time profiling on a running process. It specifies a time limit (`-l 30000` ms), the profiling template (`-t Time\\ Profiler`), and the target process ID (`-p 72030`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\ninstruments -l 30000 -t Time\\ Profiler -p 72030\n```\n\n----------------------------------------\n\nTITLE: Full SRS Service Installation and Systemctl Integration - Bash\nDESCRIPTION: Performs complete installation, init.d linking, systemd service copying, daemon reload, and enables SRS startup via systemctl. Requires sudo access, correct system paths, and a built SRS. Outputs progress of each step; prepares SRS for management by systemd (systemctl) on Ubuntu 20 or similar.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make && sudo make install &&\\nsudo ln -sf /usr/local/srs/etc/init.d/srs /etc/init.d/srs &&\\nsudo cp -f /usr/local/srs/usr/lib/systemd/system/srs.service /usr/lib/systemd/system/srs.service &&\\nsudo systemctl daemon-reload && sudo systemctl enable srs\n```\n\n----------------------------------------\n\nTITLE: Illustrating HTTP Callback Workflow in SRS\nDESCRIPTION: This diagram shows the workflow of HTTP callbacks in SRS, demonstrating how FFmpeg/OBS publishes a stream to SRS, which then notifies a business server via HTTP callback.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+--------+     +--------+                    +-----------------------+\n| FFmpeg |-->--+  SRS   |--HTTP-Callback-->--+  Your Business Server |\n+--------+     +--------+                    +-----------------------+\n```\n\n----------------------------------------\n\nTITLE: Network Interface Statistics\nDESCRIPTION: dstat output showing CPU usage, disk activity, network traffic, paging and system stats for loopback interface\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_22\n\nLANGUAGE: plaintext\nCODE:\n```\n[winlin@dev6 ~]$ dstat -N lo 30\n----total-cpu-usage---- -dsk/total- ---net/lo-- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw \n  3   2  92   0   0   3|  11k   27k|   0     0 |   1B   26B|3085   443 \n 32  17  33   0   0  17| 273B   60k|  69M   69M|   0     0 |4878  6652 \n 34  18  32   0   0  16|   0    38k|  89M   89M|   0     0 |4591  6102 \n 35  19  30   0   0  17| 137B   41k|  91M   91M|   0     0 |4682  6064 \n 33  17  33   0   0  17|   0    31k|  55M   55M|   0     0 |4920  7785 \n 33  18  31   0   0  17|2867B   34k|  90M   90M|   0     0 |4742  6530 \n 32  18  33   0   0  17|   0    31k|  66M   66M|   0     0 |4922  7666 \n 33  17  32   0   0  17| 137B   39k|  65M   65M|   0     0 |4841  7299 \n 35  18  30   0   0  17|   0    28k| 100M  100M|   0     0 |4754  6752 \n 32  17  33   0   0  18|   0    41k|  44M   44M|   0     0 |5130  8251 \n 34  18  32   0   0  16|   0    30k| 104M  104M|   0     0 |4456  5718\n```\n\n----------------------------------------\n\nTITLE: Verifying UDP MPEG-TS Stream on SRS Edge using FFprobe\nDESCRIPTION: This shell command uses `ffprobe` to check the UDP MPEG-TS stream (`udp://xxx:1234?localaddr=127.0.0.1`) generated by FFmpeg (invoked by the SRS edge server's `exec` feature). It confirms that the stream forwarded from the origin was successfully received, processed, and is available as MPEG-TS over UDP on the edge server's loopback interface.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    [root@edge ~]# ffprobe  udp://xxx:1234?localaddr=127.0.0.1\n    Input #0, mpegts, from 'udp://xxx:5002?localaddr=127.0.0.1':\n      Duration: N/A, start: 29981.146500, bitrate: 130 kb/s\n      Program 1\n        Metadata:\n          service_name    : Channel 1\n          service_provider: PBS\n        Stream #0:0[0x100]: Video: h264 (High) ([27][0][0][0] / 0x001B), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 90k tbn, 180k tbc\n        Stream #0:1[0x101]: Audio: aac ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 130 kb/s\n```\n\n----------------------------------------\n\nTITLE: Defining the EXT-X-KEY Tag for Encryption in M3U8 Media Playlists\nDESCRIPTION: Specifies the format of the EXT-X-KEY tag, used to define how to decrypt subsequent media segments using an attribute list. It applies to all segments between it and the next EXT-X-KEY tag (or end of playlist). Key attributes include METHOD (REQUIRED: NONE, AES-128, SAMPLE-AES), URI (REQUIRED unless METHOD=NONE, specifies key location), and optional IV (Initialization Vector). Multiple EXT-X-KEY tags with different KEYFORMAT attributes can apply if they resolve to the same decryption key.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_6\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-KEY:<attribute-list>\n```\n\n----------------------------------------\n\nTITLE: PERF Performance Analysis Commands\nDESCRIPTION: Commands for using Linux PERF tools to analyze SRS performance and generate performance reports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nperf top -p $(pidof srs)\n\nperf record -p $(pidof srs)\n\n# Press CTRL+C after about 30s.\n\nperf report\n\nperf record -a --call-graph fp -p $(pidof srs)\nperf report --call-graph --stdio\n```\n\n----------------------------------------\n\nTITLE: Starting the SRS Go Example HTTP Callback Server (Repeated)\nDESCRIPTION: This command, identical to a previous example, navigates into the SRS source directory (`research/api-server`) and executes the Go example server (`server.go`) using `go run`, making it listen on port 8085. Running this server allows developers to test their SRS callback configuration and observe the expected successful response format in practice. Requires Go installation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk/research/api-server && go run server.go 8085\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Directly Using init.d Script\nDESCRIPTION: Command to start SRS directly using the init.d script without installing it as a system service. This approach requires manual restart after system reboot.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk &&\n./etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP/1.1 End-of-Line and Whitespace Rules in ABNF\nDESCRIPTION: Specifies the format for line endings and whitespace handling in HTTP/1.1, including the CR LF sequence and rules for folding header field values across multiple lines.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_1\n\nLANGUAGE: ABNF\nCODE:\n```\nCRLF           = CR LF\nLWS            = [CRLF] 1*( SP | HT )\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Entity Body Format in BNF\nDESCRIPTION: Specification of the HTTP/1.0 entity body format, defining it as a sequence of octets (bytes).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_27\n\nLANGUAGE: BNF\nCODE:\n```\nEntity-Body    = *OCTET\n```\n\n----------------------------------------\n\nTITLE: Load Testing with srs-bench\nDESCRIPTION: Docker command to run load testing using srs-bench for simulating multiple HLS clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_hls_load -c 100 -r http://192.168.1.170:8081/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Cloning and Switching SRS Git Remote URL - Bash\nDESCRIPTION: This bash snippet demonstrates how to clone the SRS repository from Gitee, switch into the project directory, update the remote URL to point to Github, and pull the latest changes. It depends on the git command-line tool and requires network access to both Gitee and Github. Parameters include the initial clone URL and the subsequent remote URL update, facilitating migration or mirror synchronization. Inputs: none; Outputs: local repository mirroring the latest Github main branch contents, with remote tracking switched from Gitee to Github.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/resource.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitee.com/ossrs/srs.git &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Tracking Edge Server Session in Edge Logs\nDESCRIPTION: Uses grep to find session ID 108 (identified from origin logs) in the edge server logs. This reveals how the edge server connects to origin and handles stream forwarding.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[108\\]\" objs/srs.log \n29:[2014-08-06 10:09:34.579][trace][22314][108] edge pull connected, can_publish=1, url=rtmp://dev:1935/live/livestream, server=127.0.0.1:1936\n30:[2014-08-06 10:09:34.591][trace][22314][108] complex handshake success.\n31:[2014-08-06 10:09:34.671][trace][22314][108] connected, version=0.9.190, ip=127.0.0.1, pid=22288, id=107\n32:[2014-08-06 10:09:34.672][trace][22314][108] out chunk size to 60000\n33:[2014-08-06 10:09:34.672][trace][22314][108] ignore the disabled transcode: \n34:[2014-08-06 10:09:34.672][trace][22314][108] edge change from 100 to state 101 (pull).\n35:[2014-08-06 10:09:34.672][trace][22314][108] input chunk size to 60000\n36:[2014-08-06 10:09:34.672][trace][22314][108] got metadata, width=768, height=320, vcodec=7, acodec=10\n37:[2014-08-06 10:09:34.672][trace][22314][108] 46B video sh, codec(7, profile=100, level=32, 0x0, 0kbps, 0fps, 0s)\n38:[2014-08-06 10:09:34.672][trace][22314][108] 4B audio sh, codec(10, profile=1, 2channels, 0kbps, 44100HZ), flv(16bits, 2channels, 44100HZ)\n39:[2014-08-06 10:09:34.779][trace][22314][107] update source_id=108[108]\n46:[2014-08-06 10:09:36.853][trace][22314][110] source url=__defaultVhost__/live/livestream, ip=192.168.1.179, cache=1, is_edge=1, source_id=108[108]\n50:[2014-08-06 10:09:44.949][trace][22314][108] <- EIG time=10293, okbps=3,0,0, ikbps=441,0,0\n53:[2014-08-06 10:09:47.805][warn][22314][108][4] origin disconnected, retry. ret=1007\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 1.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS 1.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 1.0release\n```\n\n----------------------------------------\n\nTITLE: Downloading SRS Source Code\nDESCRIPTION: Clone the SRS repository from Gitee, using the develop branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://gitee.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Example Content-Type Header Usage\nDESCRIPTION: Shows an example of how the Content-Type header is used in an HTTP message to specify the media type and character set of the content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_66\n\nLANGUAGE: HTTP\nCODE:\n```\nContent-Type: text/html; charset=ISO-8859-4\n```\n\n----------------------------------------\n\nTITLE: Adding Cache Status to HTTP Response Headers\nDESCRIPTION: NGINX directive to add the cache status to HTTP response headers for debugging cache behavior in browsers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nadd_header X-Cache-Status $upstream_cache_status;\n```\n\n----------------------------------------\n\nTITLE: HTTP User-Agent Header Example\nDESCRIPTION: An example of the User-Agent request header that contains information about the user agent originating the request. Used for statistical purposes, tracing protocol violations, and tailoring responses to avoid user agent limitations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_91\n\nLANGUAGE: HTTP\nCODE:\n```\nUser-Agent: CERN-LineMode/2.15 libwww/2.17b3\n```\n\n----------------------------------------\n\nTITLE: Using Content-Length Header in HTTP/1.0\nDESCRIPTION: Example of the Content-Length header that indicates the size of the Entity-Body in decimal number of octets. This is required on all HTTP/1.0 request messages containing an entity body.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_32\n\nLANGUAGE: plaintext\nCODE:\n```\nContent-Length: 3495\n```\n\n----------------------------------------\n\nTITLE: Tracing Encoder Session in SRS\nDESCRIPTION: Example of tracing encoder session logs using source ID\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep -ina \"\\[12633\\]\\[149\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: HTTP 304 Not Modified Required Headers\nDESCRIPTION: Shows mandatory header fields for 304 Not Modified responses including Date, ETag/Content-Location, and caching headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_47\n\nLANGUAGE: http\nCODE:\n```\n304 Not Modified\nDate: Tue, 15 Nov 1994 08:12:31 GMT\nETag: \"74ed0f7a102bb2f\"\nCache-Control: max-age=3600\n```\n\n----------------------------------------\n\nTITLE: Simplified HTTP FLV Configuration Example\nDESCRIPTION: Minimal configuration example for HTTP FLV stream converter, showing the essential settings needed to enable the feature in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/streamer.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n# the streamer cast stream from other protocol to SRS over RTMP.\n# @see https://github.com/ossrs/srs/tree/develop#stream-architecture\nstream_caster {\n    enabled         on;\n    caster          flv;\n    output          rtmp://127.0.0.1/[app]/[stream];\n    listen          8936;\n}\n```\n\n----------------------------------------\n\nTITLE: HLS VOD M3U8 Playlist Example\nDESCRIPTION: Example of a VOD (Video on Demand) HLS m3u8 playlist with endlist marker.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hls.md#2025-04-23_snippet_11\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-ALLOW-CACHE:YES\n#EXT-X-PLAYLIST-TYPE:VOD\n#EXT-X-TARGETDURATION:12\n#EXTINF:10.120,\nlivestream-184.ts\n#EXTINF:10.029,\nlivestream-185.ts\n#EXTINF:10.206,\nlivestream-186.ts\n#EXTINF:10.160,\nlivestream-187.ts\n#EXTINF:11.360,\nlivestream-188.ts\n#EXTINF:9.782,\nlivestream-189.ts\n#EXT-X-ENDLIST\n```\n\n----------------------------------------\n\nTITLE: Example HDS Stream URL for Testing\nDESCRIPTION: Sample HDS stream URL that can be used for testing HDS playback in compatible players like VLC or Adobe OSMF player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/delivery-hds.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nhttp://ossrs.net:8081/live/livestream.f4m\n```\n\n----------------------------------------\n\nTITLE: RTMP Stream Publishing with FFmpeg\nDESCRIPTION: FFmpeg command to publish a looping video stream via RTMP protocol for WebRTC playback testing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder ffmpeg -stream_loop -1 -re -i doc/source.flv \\\n  -c copy -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: CMake Project Configuration for CLion\nDESCRIPTION: Project configuration path for opening the SRS project in JetBrains CLion IDE. The CMakeLists.txt file is located in the trunk/ide/srs_clion directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/ide.md#2025-04-23_snippet_0\n\nLANGUAGE: path\nCODE:\n```\ntrunk/ide/srs_clion/CMakeLists.txt\n```\n\n----------------------------------------\n\nTITLE: SRS CPU Usage Monitoring\nDESCRIPTION: Command to monitor CPU usage of the SRS process using top.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/raspberrypi.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep srs|grep objs|awk '{print $2}'` && top -p $pid\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 2.0 Branch in Bash\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 2.0 release branch. Used when implementing or testing features specific to version 2.0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and compile SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 4.0 Branch using Git\nDESCRIPTION: Command to pull the latest changes and switch to the SRS 4.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/git.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 4.0release\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to Cross-Compiled aarch64 SRS\nDESCRIPTION: Uses FFmpeg on the host machine to publish a test stream (`doc/source.flv`) to the SRS server running inside the aarch64 Docker container. The command is identical to the native publishing command, targeting the mapped port 1935.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f flv rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: SRT Consumer Class Implementation\nDESCRIPTION: Definition of SRT consumer class and source cleanup implementations showing the relationship between consumers and sources.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nclass SrsSrtConsumer\n{\nprivate:\n    // Because source references to this object, so we should directly use the source ptr.\n    SrsSrtSource* source_;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Entity Body Format in HTTP/1.1\nDESCRIPTION: Specifies the format of the entity body in HTTP messages and the encoding model with Content-Type and Content-Encoding headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_37\n\nLANGUAGE: http\nCODE:\n```\nentity-body    = *OCTET\n```\n\n----------------------------------------\n\nTITLE: Running SRS with GCP\nDESCRIPTION: Command to run SRS with Google CPU Profiler (GCP) enabled for CPU performance analysis\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nrm -f gperf.srs.gcp*; ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Adding Prometheus DataSource to Grafana\nDESCRIPTION: Curl command to add Prometheus as a data source in Grafana using the HTTP API. It configures Prometheus as the default data source with proxy access.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/exporter.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s -H \"Content-Type: application/json\" \\\n    -XPOST http://admin:12345678@localhost:3000/api/datasources \\\n    -d '{\n    \"name\": \"prometheus\",\n    \"type\": \"prometheus\",\n    \"access\": \"proxy\", \"isDefault\": true,\n    \"url\": \"http://host.docker.internal:9090\"\n}'\n```\n\n----------------------------------------\n\nTITLE: Console Mode Startup for SRS with Non-Daemon Configuration\nDESCRIPTION: This snippet shows how to start SRS in non-daemon mode with logs printing to the console. It requires specific configuration settings in the console.conf file for daemon mode and log output.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/log.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf \n```\n\n----------------------------------------\n\nTITLE: Example URL for HTTPS-FLV Player\nDESCRIPTION: URL demonstrating how to configure the SRS player to stream 'livestream.flv' via HTTPS-FLV from the server 'r.ossrs.net' on port 443. Uses HTTPS schema and specifies port 443.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/tools/demo.md#2025-04-23_snippet_1\n\nLANGUAGE: url\nCODE:\n```\nhttps://ossrs.net/players/srs_player.html?app=live&stream=livestream.flv&server=r.ossrs.net&port=443&autostart=true&vhost=r.ossrs.net&schema=https\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 3.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS version 3.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/git.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 3.0release\n```\n\n----------------------------------------\n\nTITLE: Using GPROF for CPU Profiling in SRS\nDESCRIPTION: Steps to build and run SRS with GPROF for CPU profiling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GPROF\n./configure --gprof=on && make\n\n# Start SRS with GPROF\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop GPROF\nkillall -2 srs\n\n# To analysis result.\ngprof -b ./objs/srs gmon.out\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Recording Directory with Symbolic Link\nDESCRIPTION: Commands to replace the default data directory with a symbolic link to a custom directory. This approach is suitable for non-Docker Oryx installations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nrm -rf /data && ln -sf /your-host-dir /data\n```\n\n----------------------------------------\n\nTITLE: Configuring Git user information locally\nDESCRIPTION: Commands to set up your Git user name and email for the SRS repository. This ensures your contributions are properly attributed in the GitHub contributors list.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs\ngit config --local user.name \"username\"\ngit config --local user.email \"useremail@xxx.com\"\ngit config --list\n```\n\n----------------------------------------\n\nTITLE: Handling SRS API HTTP Status Errors with Curl\nDESCRIPTION: An example `curl` command demonstrating an API request that results in an HTTP error status (404 Not Found). The `-v` flag shows the HTTP headers and response body. This illustrates one way SRS signals errors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-api.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nwinlin:~ winlin$ curl -v http://127.0.0.1:1985 && echo \"\"\n< HTTP/1.1 404 Not Found\n< Connection: Keep-Alive\n< Content-Length: 9\n< Content-Type: text/plain; charset=utf-8\n< Server: SRS/2.0.184\n< \nNot Found\n```\n\n----------------------------------------\n\nTITLE: Embedding SRS Player Shortcode in WordPress\nDESCRIPTION: Example of the SRS Player WordPress plugin shortcode for embedding video streams with a custom width parameter to control the player size.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-15-Oryx-WordPress-Plugin.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n[srs_player url=\"https://ip/live/livestream.m3u8\" width=\"320\"]\n```\n\n----------------------------------------\n\nTITLE: Installing Oryx with Docker\nDESCRIPTION: Docker command to run Oryx with persistent storage and necessary port mappings for RTMP, WebRTC, and HTTP/HTTPS services\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx -v $HOME/data:/data \\\n  -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Displaying Live Streaming Workflow Diagram in Markdown\nDESCRIPTION: This Markdown diagram uses ASCII-art within a code block to visually explain the high-level data flow of a live streaming system, depicting an encoder publishing video to the SRS/CDN, which then delivers streams to players. Intended for documentation or tutorials, it aids in conceptualizing the end-to-end live streaming process using simple box-and-arrow notation. There are no external dependencies, and the code should be rendered in Markdown as monospaced ASCII-art.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/client-sdk.md#2025-04-23_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```\n+---------+      +-----------------+       +---------+\n| Encoder +-->---+ SRS/CDN Network +--->---+ Player  |\n+---------+      +-----------------+       +---------+\n```\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory. Also includes an alternative command to update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Defining EXT-X-I-FRAMES-ONLY Tag in HLS Media Playlist\nDESCRIPTION: Specifies the format of the EXT-X-I-FRAMES-ONLY tag used in HLS media playlists to indicate that each media segment describes a single I-frame. This tag applies to the entire playlist and is not allowed in master playlists.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_15\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-I-FRAMES-ONLY\n```\n\n----------------------------------------\n\nTITLE: Verifying RTMP Stream on SRS Origin using ffprobe (Bash)\nDESCRIPTION: This ffprobe command connects to the RTMP stream `rtmp://xxx:1935/live/xxx:1234` on the SRS origin server to inspect its properties. It confirms the stream format (FLV container), codecs (AAC audio, H.264 video), metadata, and that the SRS server (version 2.0.209) is successfully handling the stream published by FFmpeg in the 'Europe: Forward+EXEC' scenario.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/sample.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n    [root@encoder1 ~]# ffprobe rtmp://xxx:1935/live/xxx:1234\n    Input #0, flv, from 'rtmp://xxx:1935/live/xxx:1234':\n      Metadata:\n        service_name    : Channel 1\n        service_provider: PBS\n        encoder         : Lavf57.24.100\n        server          : SRS/2.0.209(ZhouGuowen)\n        srs_primary     : SRS/1.0release\n        srs_authors     : winlin,wenjie.zhao\n        server_version  : 2.0.209\n      Duration: N/A, start: 0.010000, bitrate: N/A\n        Stream #0:0: Audio: aac (LC), 48000 Hz, stereo, fltp, 128 kb/s\n        Stream #0:1: Video: h264 (High), yuvj420p(pc, bt709), 720x576 [SAR 16:11 DAR 20:11], 24 fps, 24 tbr, 1k tbn\n```\n\n----------------------------------------\n\nTITLE: Running SRS with GMP\nDESCRIPTION: Command to run SRS with Google Memory Profiler (GMP) enabled for memory performance analysis\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nrm -f gperf.srs.gmp*; ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Checking Softirq SMP Affinity for Network IRQs in Bash\nDESCRIPTION: These commands identify the IRQ numbers associated with virtio network interfaces (input and output queues) using `grep` on `/proc/interrupts` and then display the `smp_affinity` setting for each specific IRQ by reading the corresponding file under `/proc/irq/`. The value shown (e.g., `1`, `2`, `4`, `8`) is a bitmask indicating which CPU(s) are allowed to handle that IRQ.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\n# grep virtio /proc/interrupts | grep -e in -e out\n 29:   64580032          0          0          0   PCI-MSI-edge      virtio0-input.0\n 30:          1         49          0          0   PCI-MSI-edge      virtio0-output.0\n 31:   48663403          0   11845792          0   PCI-MSI-edge      virtio0-input.1\n 32:          1          0          0         52   PCI-MSI-edge      virtio0-output.1\n\n# cat /proc/irq/29/smp_affinity\n1 # Bind softirq of virtio0 incoming to CPU0.\n# cat /proc/irq/30/smp_affinity\n2 # Bind softirq of virtio0 outgoing to CPU1.\n# cat /proc/irq/31/smp_affinity\n4 # Bind softirq of virtio1 incoming to CPU2.\n# cat /proc/irq/32/smp_affinity\n8 # Bind softirq of virtio1 outgoing to CPU3.\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Command Line Used by SRS Transcoder - Bash Example\nDESCRIPTION: This code snippet illustrates the FFMPEG command line that SRS generates and executes when starting a transcoder process, using appropriate parameters derived from the SRS config. It includes variables like input URL, vcodec, bitrates, output URL, and more. This must be run in an environment with FFMPEG accessible at the specified path. This example helps verify the actual FFMPEG invocation as seen in SRS logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -f flv -i \\\nrtmp://127.0.0.1:1935/live?vhost=__defaultVhost__/livestream \\\n-vcodec libx264 -b:v 500000 -r 25.00 -s 768x320 -aspect 768:320 \\\n-threads 12 -profile:v main -preset medium -acodec libfdk_aac \\\n-b:a 70000 -ar 44100 -ac 2 -f flv \\\n-y rtmp://127.0.0.1:1935/live?vhost=__defaultVhost__/livestream_ff \n```\n\n----------------------------------------\n\nTITLE: Using If-Modified-Since Header in HTTP/1.0\nDESCRIPTION: Example of the If-Modified-Since request-header field used with GET to make requests conditional. This enables efficient updates of cached information by only transferring resources that have changed since a specified time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_37\n\nLANGUAGE: plaintext\nCODE:\n```\nIf-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n```\n\n----------------------------------------\n\nTITLE: Linking to Documentation from Blogs Using Markdown\nDESCRIPTION: Shows how to create links from blog posts to documentation pages. The example demonstrates linking to a specific section of a documentation page using an anchor link.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n[Getting Started](../docs/v5/doc/getting-started-oryx#docker)\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream to SRS using FFMPEG\nDESCRIPTION: Bash script using FFMPEG to publish a sample video stream to SRS. The script runs in a loop to continuously stream the content to the RTMP endpoint for DASH conversion.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-dash.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Find Client Connections in Edge Log\nDESCRIPTION: Searches for log entries related to client connections on the edge server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngrep --color -ina \"\\[107\\]\" objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server - Bash\nDESCRIPTION: Command to start the SRS server with the specified ingest configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ingest.conf\n```\n\n----------------------------------------\n\nTITLE: Displaying Not Recommended URL Format in RTMP with Multiple Level App and Stream\nDESCRIPTION: Example of multiple level app and stream RTMP URLs that are not recommended for use with SRS. This approach can confuse users and is not supported by SRS player and publisher tools.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n// Not recomment multiple level app and stream, which confuse people.\nrtmp://demo.srs.com/show/live/livestream\nrtmp://demo.srs.com/show/live/livestream/2013\n```\n\n----------------------------------------\n\nTITLE: Monitoring SRS-Bench CPU Usage\nDESCRIPTION: Command to monitor the CPU usage of the SRS-Bench load testing tool.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep load|grep rtmp|awk '{print $2}'` && top -p $pid\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-dash.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Defining Content-Type Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax and usage of the Content-Type entity-header field in HTTP/1.1. This header indicates the media type of the entity-body sent to the recipient.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_65\n\nLANGUAGE: HTTP\nCODE:\n```\nContent-Type   = \"Content-Type\" \":\" media-type\n```\n\n----------------------------------------\n\nTITLE: Playlist Type Tag Format\nDESCRIPTION: Format specification for EXT-X-PLAYLIST-TYPE tag that provides playlist mutability information\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_9\n\nLANGUAGE: plaintext\nCODE:\n```\n#EXT-X-PLAYLIST-TYPE:<EVENT|VOD>\n```\n\n----------------------------------------\n\nTITLE: Additional Lexical Token Definitions for ARPA Internet Messages in ABNF\nDESCRIPTION: Continues the definition of lexical tokens for ARPA Internet messages, including text elements, comments, quoted pairs, and phrase structures used in email addresses and headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_14\n\nLANGUAGE: ABNF\nCODE:\n```\ndtext       =  <any CHAR excluding \"[\",     ; => may be folded\n                 \"]\", \"\\\" & CR, & including\n                 linear-white-space>\n\ncomment     =  \"(\" *(ctext / quoted-pair / comment) \")\"\n\nctext       =  <any CHAR excluding \"(\",     ; => may be folded\n                 \")\", \"\\\" & CR, & including\n                 linear-white-space>\n\nquoted-pair =  \"\\\" CHAR                     ; may quote any char\n\nphrase      =  1*word                       ; Sequence of words\n\nword        =  atom / quoted-string\n```\n\n----------------------------------------\n\nTITLE: HTTP Upgrade Header Example\nDESCRIPTION: An example of the Upgrade header field allowing a client to specify additional communication protocols it supports and would like to use. This provides a mechanism for transitioning from HTTP/1.1 to other protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_90\n\nLANGUAGE: HTTP\nCODE:\n```\nUpgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11\n```\n\n----------------------------------------\n\nTITLE: RTMP Delivery Page Frontmatter Configuration\nDESCRIPTION: YAML frontmatter configuration for the documentation page, setting up title, sidebar label and display options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/delivery-rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: RTMP Delivery\nsidebar_label: RTMP Delivery \nhide_title: false\nhide_table_of_contents: false\n---\n```\n\n----------------------------------------\n\nTITLE: HTTP If-Modified-Since Header Example\nDESCRIPTION: Example of an If-Modified-Since header field used for conditional GET requests based on timestamp.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_76\n\nLANGUAGE: http\nCODE:\n```\nIf-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n```\n\n----------------------------------------\n\nTITLE: Defining Range Header Syntax and Examples in HTTP/1.1\nDESCRIPTION: Examples of byte-ranges-specifier values for an HTTP Range header, showing different ways to request portions of a resource with a length of 10000 bytes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_82\n\nLANGUAGE: http\nCODE:\n```\n- The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-499\n\n- The second 500 bytes (byte offsets 500-999, inclusive):\n  bytes=500-999\n\n- The final 500 bytes (byte offsets 9500-9999, inclusive):\n  bytes=-500\n\n- Or bytes=9500-\n\n- The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1\n\n- Several legal but not canonical specifications of the second 500\n  bytes (byte offsets 500-999, inclusive):\n   bytes=500-600,601-999\n   bytes=500-700,601-999\n```\n\n----------------------------------------\n\nTITLE: Range Units Syntax Definition in ABNF\nDESCRIPTION: Specifies the syntax for range units used in Range and Content-Range header fields for partial content requests.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_20\n\nLANGUAGE: abnf\nCODE:\n```\nrange-unit       = bytes-unit | other-range-unit\nbytes-unit       = \"bytes\"\nother-range-unit = token\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Non-Recommended Multiple Level App and Stream Format in RTMP URLs\nDESCRIPTION: Examples of multiple level app and stream formats in RTMP URLs that are not recommended as they can be confusing to users.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n// Not recomment multiple level app and stream, which confuse people.\nrtmp://demo.srs.com/show/live/livestream\nrtmp://demo.srs.com/show/live/livestream/2013\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Force Style Example for Subtitle Font Customization\nDESCRIPTION: Example subtitle style configuration for FFmpeg that sets font size to 12px and text color to white. This can be used for AI transcript styling in Oryx.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_11\n\nLANGUAGE: text\nCODE:\n```\nFontsize=12,PrimaryColour=&HFFFFFF\n```\n\n----------------------------------------\n\nTITLE: DNS A Record Configuration Example\nDESCRIPTION: Example of how to configure a DNS A record to point a domain name to the server's public IP address, which is required for Let's Encrypt certificate validation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-12-Oryx-HTTPS.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nA your_domain_name your_public_ipv4\n```\n\n----------------------------------------\n\nTITLE: Playing RTMP Stream from Proxy Server\nDESCRIPTION: FFplay command to play an RTMP stream from the SRS proxy server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/origin-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nffplay rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code in Bash\nDESCRIPTION: Command to update an existing SRS codebase using Git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: NGINX Edge HLS Configuration\nDESCRIPTION: NGINX configuration for edge server with proxy cache settings to deliver HLS content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-hls-cluster.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/hls.edge.conf\nworker_processes  3;\nevents {\n    worker_connections  10240;\n}\n\nhttp {\n    # For Proxy Cache.\n    proxy_cache_path  /tmp/nginx-cache levels=1:2 keys_zone=srs_cache:8m max_size=1000m inactive=600m;\n    proxy_temp_path /tmp/nginx-cache/tmp; \n\n    server {\n        listen       8081;\n        # For Proxy Cache.\n        proxy_cache_valid  404      10s;\n        proxy_cache_lock on;\n        proxy_cache_lock_age 300s;\n        proxy_cache_lock_timeout 300s;\n        proxy_cache_min_uses 1;\n\n        location ~ /.+/.*\\.(m3u8)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri$args;\n            proxy_cache_valid  200 302  10s;\n        }\n        location ~ /.+/.*\\.(ts)$ {\n            proxy_pass http://127.0.0.1:8080$request_uri;\n            # For Proxy Cache.\n            proxy_cache srs_cache;\n            proxy_cache_key $scheme$proxy_host$uri;\n            proxy_cache_valid  200 302  60m;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Mode for SRS Upnode Connections\nDESCRIPTION: Activates debug mode for connections to upstream SRS nodes. This provides additional debug information such as ID, source ID, and PID when connecting to upnodes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_4\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    debug_srs_upnode    on;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Date/Time Formats in BNF\nDESCRIPTION: Specifies the three acceptable date/time formats for HTTP/1.0 using BNF notation. It includes RFC 1123, RFC 850, and ANSI C's asctime formats, along with their component parts.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_8\n\nLANGUAGE: BNF\nCODE:\n```\nHTTP-date      = rfc1123-date | rfc850-date | asctime-date\n\nrfc1123-date   = wkday \",\" SP date1 SP time SP \"GMT\"\nrfc850-date    = weekday \",\" SP date2 SP time SP \"GMT\"\nasctime-date   = wkday SP date3 SP time SP 4DIGIT\n\ndate1          = 2DIGIT SP month SP 4DIGIT\n                        ; day month year (e.g., 02 Jun 1982)\ndate2          = 2DIGIT \"-\" month \"-\" 2DIGIT\n                        ; day-month-year (e.g., 02-Jun-82)\ndate3          = month SP ( 2DIGIT | ( SP 1DIGIT ))\n                        ; month day (e.g., Jun  2)\n\ntime           = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n                        ; 00:00:00 - 23:59:59\n\nwkday          = \"Mon\" | \"Tue\" | \"Wed\"\n                      | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n\nweekday        = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n                      | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\n\nmonth          = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n                      | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n                      | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Windows Hosts File for Local Domain Resolution\nDESCRIPTION: Example of how to modify the hosts file on Windows systems to resolve a domain name to the Oryx Server IP address locally. This allows Windows users to access Oryx via a domain name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n121.13.75.20 bt.yourdomain.com\n```\n\n----------------------------------------\n\nTITLE: Example GET Request with Absolute URI\nDESCRIPTION: Demonstrates a GET request using an absoluteURI format, typically used when making requests through a proxy server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_29\n\nLANGUAGE: text\nCODE:\n```\nGET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1\n```\n\n----------------------------------------\n\nTITLE: Running SRS with Custom Candidate IP\nDESCRIPTION: Command to run SRS with a custom candidate IP address set through environment variables.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nenv CANDIDATE=\"192.168.3.10\" \\\n  ./objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Message Template for Redirecting Questions to Stack Overflow\nDESCRIPTION: Template message directing users to ask questions on Stack Overflow using the appropriate tag, or to use Discord for discussions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-server-en.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nPlease ask this question on Stack Overflow using the [#simple-realtime-server tag](https://stackoverflow.com/questions/tagged/simple-realtime-server).\n\nIf want some discussion, here's the [discord](https://discord.gg/yZ4BnPmHAd).\n\nThis issue will be eliminated, see #2716\n```\n\n----------------------------------------\n\nTITLE: Starting Edge Server on Port 1935 (Bash)\nDESCRIPTION: Command to start an SRS edge server listening on port 1935. This is the first instance of the edge server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge.conf\n```\n\n----------------------------------------\n\nTITLE: Project Table - YAML Configuration Parser\nDESCRIPTION: Markdown table defining the YAML configuration parser project details including mentor information, skills needed, and expected outcomes\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-02-10-GSoC.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n|Name of project|Configuration file support yaml parsing|\n| :---- | :----- |\n|Project Description|SRS current configuration file format is a private format, similar to nginx, yaml is a common way of configuration file, there are more people familiar with the use of.|\n|Mentor|Junqin Zhang(chundonglinlin@163.com)|\n|Backup Mentor|Haibo Chen(nmgchenhaibo@foxmail.com)|\n|Skills needed|Familiar with yaml file format and its parsing method, skilled in C++ programming.|\n|Expected size of project|175 hours|\n|Difficulty|Beginner|\n|Expected results|SRS existing configuration file can be converted to yaml parsing and execution.|\n|Qualification Task|Implement the parsing of yaml files.|\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 2.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS 2.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback on_unpublish Event JSON Format\nDESCRIPTION: Shows the JSON format for the on_unpublish event in HTTP callbacks, including request and response structures.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_7\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"9ea987fa-1563-4c28-8c6c-a0e9edd4f536\",\n  \"action\": \"on_unpublish\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SRT Poller Wait Function with Event Notification\nDESCRIPTION: Implementation of the SrsSrtPoller::wait method which waits for SRT events and signals the corresponding condition variables. This is the mechanism that wakes up waiting coroutines when I/O events occur.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsSrtPoller::wait(int timeout_ms, int* pn_fds) {\n  int ret = srt_epoll_uwait(srt_epoller_fd_, events_.data(), events_.size());\n  for (int i = 0; i < ret; ++i) {\n    if (event.events & SRT_EPOLL_IN) {\n      srt_skt->notify_readable();\n    }\n  }\n}\n\nvoid SrsSrtSocket::notify_readable() {\n  srs_cond_signal(read_cond_);\n}\n```\n\n----------------------------------------\n\nTITLE: Stopping SRS Service\nDESCRIPTION: Command to stop the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs stop\n```\n\n----------------------------------------\n\nTITLE: Original Callback-based SRT Accept\nDESCRIPTION: Original implementation of SRT accept using callback-based approach.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nwhile (run_flag) {\n  int ret = srt_epoll_wait(_pollid, read_fds, &rfd_num, write_fds);\n  for (int index = 0; index < rfd_num; index++) {\n    SRT_SOCKSTATUS status = srt_getsockstate(read_fds[index]);\n    srt_handle_connection(status, read_fds[index], \"read fd\");\n  }\n}\n\nvoid srt_server::srt_handle_connection(SRT_SOCKSTATUS status, SRTSOCKET input_fd) {\n  if (status == SRTS_LISTENING) {\n    conn_fd = srt_accept(input_fd, (sockaddr*)&scl, &sclen);\n    _handle_ptr->add_newconn(conn_fd, SRT_EPOLL_IN);\n  }\n}\n\nvoid srt_handle::add_newconn(SRT_CONN_PTR conn_ptr, int events) {\n    _push_conn_map.insert(std::make_pair(conn_ptr->get_path(), conn_ptr));\n    _conn_map.insert(std::make_pair(conn_ptr->get_conn(), conn_ptr));\n    int ret = srt_epoll_add_usock(_handle_pollid, conn_ptr->get_conn(), &events);\n}\n```\n\n----------------------------------------\n\nTITLE: Example URL for WebRTC Player\nDESCRIPTION: URL demonstrating how to configure the RTC player (`rtc_player.html`) to connect via WebRTC to the server 'r.ossrs.net' on port 1985. Key parameters include vhost, server, port, and autostart.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/tools/demo.md#2025-04-23_snippet_4\n\nLANGUAGE: url\nCODE:\n```\nhttp://ossrs.net/players/rtc_player.html?vhost=r.ossrs.net&server=r.ossrs.net&port=1985&autostart=true\n```\n\n----------------------------------------\n\nTITLE: Fetching from Contributor's Fork Remote (TOC Workflow) using Bash\nDESCRIPTION: This command fetches updates from the `tmp` remote, which was previously added and points to the contributor's forked repository. This downloads the necessary branch information (like `bugfix/fix-srt-url`) for the maintainer (TOC) to check out and modify.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit fetch tmp\n```\n\n----------------------------------------\n\nTITLE: Simple HLS Media Playlist (M3U8)\nDESCRIPTION: A basic M3U8 media playlist example representing a complete, single media file (VoD). It specifies the HLS version, target duration, information about the single segment, its duration, URL, and indicates the end of the playlist.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_21\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-TARGETDURATION:5220\n#EXTINF:5219.2,\nhttp://media.example.com/entire.ts\n#EXT-X-ENDLIST\n```\n\n----------------------------------------\n\nTITLE: Testing WHIP API with cURL\nDESCRIPTION: A cURL command to test the WHIP HTTP API endpoint. This request simulates a WebRTC client initiating a connection by sending an SDP offer to the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl \"http://localhost:1985/rtc/v1/whip/?ice-ufrag=6pk11386&ice-pwd=l91z529147ri9163933p51c4&app=live&stream=livestream-$(date +%s)\" \\\n  -H 'Origin: http://localhost' -H 'Referer: http://localhost' \\\n  -H 'Accept: */*' -H 'Content-type: application/sdp' \\\n  -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)' \\\n  --data-raw $'v=0\\r\\na=group:BUNDLE 0 1\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:0\\r\\na=sendonly\\r\\na=msid:- audio\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\na=ssrc:3184534672 cname:stream\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 106\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=ice-ufrag:J8X7\\r\\na=ice-pwd:Dpq7/fW/osYcPeLsCW2Ek1JH\\r\\na=setup:actpass\\r\\na=mid:1\\r\\na=sendonly\\r\\na=msid:- video\\r\\na=rtcp-mux\\r\\na=rtpmap:106 H264/90000\\r\\na=ssrc:512761356 cname:stream' \\\n  -v -k\n```\n\n----------------------------------------\n\nTITLE: HLS Master Playlist with I-Frame Streams (M3U8)\nDESCRIPTION: A master playlist that includes I-frame playlists (#EXT-X-I-FRAME-STREAM-INF) alongside regular media streams (#EXT-X-STREAM-INF). I-frame playlists allow for faster seeking and trick play modes by providing the locations of I-frames.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_25\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=1280000\nlow/audio-video.m3u8\n#EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=86000,URI=\"low/iframe.m3u8\"\n#EXT-X-STREAM-INF:BANDWIDTH=2560000\nmid/audio-video.m3u8\n#EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=150000,URI=\"mid/iframe.m3u8\"\n#EXT-X-STREAM-INF:BANDWIDTH=7680000\nhi/audio-video.m3u8\n#EXT-X-I-FRAME-STREAM-INF:BANDWIDTH=550000,URI=\"hi/iframe.m3u8\"\n#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\naudio-only.m3u8\n```\n\n----------------------------------------\n\nTITLE: Enabling HTTPS on SRS Embedded HTTP Server - Bash\nDESCRIPTION: Shows how to activate HTTPS in the SRS server configuration. The 'https' block within 'http_server' enables secure traffic, specifies listen port, SSL key, and certificate files. You can auto-generate test certificates with OpenSSL or supply CA-issued certs. Keys: 'enabled', 'listen', 'key', and 'cert'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-server.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    https {\n        # Whether enable HTTPS Streaming.\n        # Overwrite by env SRS_HTTP_SERVER_HTTPS_ENABLED\n        # default: off\n        enabled on;\n        # The listen endpoint for HTTPS Streaming.\n        # Overwrite by env SRS_HTTP_SERVER_HTTPS_LISTEN\n        # default: 8088\n        listen 8088;\n        # The SSL private key file, generated by:\n        #       openssl genrsa -out server.key 2048\n        # Overwrite by env SRS_HTTP_SERVER_HTTPS_KEY\n        # default: ./conf/server.key\n        key ./conf/server.key;\n        # The SSL public cert file, generated by:\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\n        # Overwrite by env SRS_HTTP_SERVER_HTTPS_CERT\n        # default: ./conf/server.crt\n        cert ./conf/server.crt;\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for SRT\nDESCRIPTION: Basic SRS server configuration file that enables SRT support with default settings and listening ports.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-srt.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/srt.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nsrt_server {\n    enabled on;\n    listen 10080;\n}\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback: on_ocr Event - JSON\nDESCRIPTION: Describes the message formats for the 'on_ocr' HTTP callback, triggered by Oryx OCR tasks. Includes the stream identifiers, UUID for task, prompt used by the AI, and OCR result string. Respond with {\"code\": 0} to acknowledge. All errors in response are ignored.\n\nInput: Must supply all documented fields. Output: {\"code\": 0}. The receiving system should be OCR-compatible.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_ocr\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"prompt\": \"What is in the image?\",\n  \"result\": \"The image shows a scene featuring a character from a film, likely set in a military or high-tech environment.\"\n}\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining URI Syntax in BNF\nDESCRIPTION: Specifies the general syntax for Uniform Resource Identifiers (URIs) using BNF notation. It defines various components of URIs including absolute and relative forms, paths, parameters, and character sets.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_6\n\nLANGUAGE: BNF\nCODE:\n```\nURI            = ( absoluteURI | relativeURI ) [ \"#\" fragment ]\n\nabsoluteURI    = scheme \":\" *( uchar | reserved )\n\nrelativeURI    = net_path | abs_path | rel_path\n\nnet_path       = \"//\" net_loc [ abs_path ]\nabs_path       = \"/\" rel_path\nrel_path       = [ path ] [ \";\" params ] [ \"?\" query ]\n\npath           = fsegment *( \"/\" segment )\nfsegment       = 1*pchar\nsegment        = *pchar\n\nparams         = param *( \";\" param )\nparam          = *( pchar | \"/\" )\n\nscheme         = 1*( ALPHA | DIGIT | \"+\" | \"-\" | \".\" )\nnet_loc        = *( pchar | \";\" | \"?\" )\nquery          = *( uchar | reserved )\nfragment       = *( uchar | reserved )\n\npchar          = uchar | \":\" | \"@\" | \"&\" | \"=\" | \"+\"\nuchar          = unreserved | escape\nunreserved     = ALPHA | DIGIT | safe | extra | national\n\nescape         = \"%\" HEX HEX\nreserved       = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\"\nextra          = \"!\" | \"*\" | \"'\" | \"(\" | \")\" | \",\"\nsafe           = \"$\" | \"-\" | \"_\" | \".\"\nunsafe         = CTL | SP | <\"> | \"#\" | \"%\" | \"<\" | \">\"\nnational       = <any OCTET excluding ALPHA, DIGIT,\n                        reserved, extra, safe, and unsafe>\n```\n\n----------------------------------------\n\nTITLE: Applying Vintage Yellow Subtitle Style\nDESCRIPTION: Configures subtitles with an aesthetic vintage yellow style using the Roboto font with italic formatting and character spacing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_19\n\nLANGUAGE: text\nCODE:\n```\nFontname=Roboto,Fontsize=12,PrimaryColour=&H03fcff,Italic=1,Spacing=0.3\n```\n\n----------------------------------------\n\nTITLE: Example Valgrind Incremental Leak Summary Output\nDESCRIPTION: Shows example output from Valgrind after an incremental leak check triggered via the SRS API. It details different categories of memory leaks (definitely lost, indirectly lost, possibly lost, still reachable) and the change in bytes/blocks since the last check (indicated by `(+0)` here, signifying no new leaks were detected in this specific check).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_22\n\nLANGUAGE: text\nCODE:\n```\nHTTP #0 11.176.19.95:42162 GET http://9.134.74.169:1985/api/v1/valgrind?check=added, content-length=-1\nquery check=added\n==1481822== LEAK SUMMARY:\n==1481822==    definitely lost: 0 (+0) bytes in 0 (+0) blocks\n==1481822==    indirectly lost: 0 (+0) bytes in 0 (+0) blocks\n==1481822==      possibly lost: 3,406,847 (+0) bytes in 138 (+0) blocks\n==1481822==    still reachable: 18,591,709 (+0) bytes in 819 (+0) blocks\n==1481822==                       of which reachable via heuristic:\n==1481822==                         multipleinheritance: 536 (+0) bytes in 4 (+0) blocks\n==1481822==         suppressed: 0 (+0) bytes in 0 (+0) blocks\n==1481822== Reachable blocks (those to which a pointer was found) are not shown.\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Daemon Mode\nDESCRIPTION: This snippet shows the configuration option to enable or disable daemon mode in SRS, which affects how logs are written and whether the server runs in the background.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\n# whether start as deamon\n# default: on\ndaemon              on;\n```\n\n----------------------------------------\n\nTITLE: Generating HEVC MP4 file for MSE testing\nDESCRIPTION: Creates an HEVC-encoded MP4 file from a source FLV for testing HEVC support in browsers with Media Source Extensions (MSE). This is useful for verifying Chrome 105+ HEVC support.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -i ~/git/srs/trunk/doc/source.flv -acodec copy \\\n  -vcodec libx265 -y source.hevc.mp4\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS from Gitlab and Switching Remote URL - Bash\nDESCRIPTION: This bash code clones the SRS repository from Gitlab into a local 'srs' directory, changes into it, updates the git origin remote URL to Github, and pulls the latest code. It requires the git command-line tool and internet connectivity. The keys parameters are the source repository URL and the new remote for syncing with Github, allowing developers to start from a mirror and keep their code up-to-date with the upstream main repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/resource.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitlab.com/winlinvip/srs-gitlab.git srs &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream with FFmpeg\nDESCRIPTION: FFmpeg command loop to continuously publish a stream to the master SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-forward.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 4.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS version 4.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/git.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 4.0release\n```\n\n----------------------------------------\n\nTITLE: Analyzing GCP Results\nDESCRIPTION: Command to analyze GCP results using pprof tool, showing CPU usage hotspots\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gperf.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./objs/pprof --text objs/srs gperf.srs.gcp*\n```\n\n----------------------------------------\n\nTITLE: Example HTTP Response with Content-Range Header\nDESCRIPTION: Demonstrates a sample HTTP response including Content-Range, Content-Length, and other relevant headers for a partial content response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_64\n\nLANGUAGE: HTTP\nCODE:\n```\nHTTP/1.1 206 Partial content\nDate: Wed, 15 Nov 1995 06:25:24 GMT\nLast-Modified: Wed, 15 Nov 1995 04:58:08 GMT\nContent-Range: bytes 21010-47021/47022\nContent-Length: 26012\nContent-Type: image/gif\n```\n\n----------------------------------------\n\nTITLE: Dynamic Forward API Request Format\nDESCRIPTION: JSON format for the HTTP request body sent to backend server when requesting forward configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/forward.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"action\": \"on_forward\",\n    \"server_id\": \"vid-k21d7y2\",\n    \"client_id\": \"9o7g1330\",\n    \"ip\": \"127.0.0.1\",\n    \"vhost\": \"__defaultVhost__\",\n    \"app\": \"live\",\n    \"tcUrl\": \"rtmp://127.0.0.1:1935/live\",\n    \"stream\": \"livestream\",\n    \"param\": \"\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Destination Fields Syntax (ABNF-like)\nDESCRIPTION: Defines the syntax for various destination header fields (To, Resent-To, cc, Resent-cc, bcc, Resent-bcc) in RFC 822 using an ABNF-like grammar. It specifies primary, secondary (carbon copy), and blind carbon copy recipients for both original and forwarded messages.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_28\n\nLANGUAGE: abnf\nCODE:\n```\ndestination =  \"To\"          \":\" 1#address  ; Primary\n             /  \"Resent-To\"   \":\" 1#address\n             /  \"cc\"          \":\" 1#address  ; Secondary\n             /  \"Resent-cc\"   \":\" 1#address\n             /  \"bcc\"         \":\"  #address  ; Blind carbon\n             /  \"Resent-bcc\"  \":\"  #address\n```\n\n----------------------------------------\n\nTITLE: Specifying Content-Language HTTP Header for Multiple Languages\nDESCRIPTION: Example of using the Content-Language HTTP header to indicate content available in multiple languages, specifically Maori and English. This indicates content intended for audiences of both languages.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_61\n\nLANGUAGE: http\nCODE:\n```\nContent-Language: mi, en\n```\n\n----------------------------------------\n\nTITLE: Sport Stream Configuration Example\nDESCRIPTION: Example URLs showing stream configuration with 'sport' as the resource name.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-08-29-Oryx-Ensuring-Authentication-for-Live-Streaming-Publishing.md#2025-04-23_snippet_2\n\nLANGUAGE: url\nCODE:\n```\nrtmp://135.98.31.15/live/sport?secret=5181a08ee6eab86597e913e1f9e4c294\nhttp://135.98.31.15/live/sport.m3u8\n```\n\n----------------------------------------\n\nTITLE: HTTP If-Unmodified-Since Header Example\nDESCRIPTION: Example showing the correct format for an If-Unmodified-Since header with an HTTP date value.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_78\n\nLANGUAGE: HTTP\nCODE:\n```\nIf-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP/1.1 Comment and Quoted String Rules in ABNF\nDESCRIPTION: Describes the syntax for comments and quoted strings in HTTP header fields, including the backslash character as a quoting mechanism.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_4\n\nLANGUAGE: ABNF\nCODE:\n```\ncomment        = \"(\" *( ctext | quoted-pair | comment ) \")\"\nctext          = <any TEXT excluding \"(\" and \")\">\nquoted-string  = ( <\"> *(qdtext | quoted-pair ) <\"> )\nqdtext         = <any TEXT except <\">>\nquoted-pair    = \"\\\\\" CHAR\n```\n\n----------------------------------------\n\nTITLE: Example GET Request with Host Header\nDESCRIPTION: Shows a GET request using the abs_path format with a separate Host header, which is the most common form for direct requests to origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_30\n\nLANGUAGE: text\nCODE:\n```\nGET /pub/WWW/TheProject.html HTTP/1.1\nHost: www.w3.org\n```\n\n----------------------------------------\n\nTITLE: Visualizing Browser-to-SFU WebRTC Topology using Bash Pseudo-Diagram\nDESCRIPTION: This ASCII diagram, encapsulated in a bash code block, illustrates the relationship between a browser and an SFU (Selective Forwarding Unit) in a WebRTC setup. Key flows, 'Signaling' and 'Media', are indicated, reflecting the roles of browsers and SFU servers. The code serves a documentary and visual-communication purpose, contains no dependencies, requires no parameters, and is not executable.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +---------+\\n+    Browser     +----<--Signaling----->--+   SFU   +\\n+ (like Chrome)  +----<----Media----->----+  Server +\\n+----------------+                        +---------+\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP/1.1 Token and Separator Rules in ABNF\nDESCRIPTION: Specifies the format for tokens and separator characters in HTTP/1.1 header field values, defining the characters that must be quoted when used in parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_3\n\nLANGUAGE: ABNF\nCODE:\n```\ntoken          = 1*<any CHAR except CTLs or separators>\nseparators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n              | \",\" | \";\" | \":\" | \"\\\\\" | <\">\n              | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n              | \"{\" | \"}\" | SP | HT\n```\n\n----------------------------------------\n\nTITLE: Issue Elimination Notice - Discord Reference\nDESCRIPTION: Template for redirecting discussions to Discord and marking issues for elimination.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/faq.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nFor discussion or idea, please ask in [discord](https://discord.gg/yZ4BnPmHAd).\n\nThis issue will be eliminated, see #2716\n```\n\n----------------------------------------\n\nTITLE: FMLE Stream Publishing Configuration\nDESCRIPTION: Configuration details for publishing a stream using Flash Media Live Encoder (FMLE) to the SRS server on ARM.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-arm.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Creating a New Branch from Upstream Develop using Git\nDESCRIPTION: This command creates a new local branch named `bugfix/bug-summary` based on the `develop` branch of the `srs` remote (the upstream repository) and switches the working directory to this new branch. Contributors should use descriptive names reflecting the bug or feature.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_3\n\nLANGUAGE: git\nCODE:\n```\ngit checkout -b bugfix/bug-summary srs/develop\n```\n\n----------------------------------------\n\nTITLE: Specifying Character Set Token Format\nDESCRIPTION: Defines the format for character set tokens used in HTTP headers to specify character encodings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_9\n\nLANGUAGE: HTTP\nCODE:\n```\ncharset = token\n```\n\n----------------------------------------\n\nTITLE: HTTP HEAD Method Implementation\nDESCRIPTION: Describes the HEAD method which is identical to GET but returns only headers without message body, useful for obtaining metainformation about resources.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_42\n\nLANGUAGE: http\nCODE:\n```\nHEAD /path HTTP/1.1\\nHost: example.com\n```\n\n----------------------------------------\n\nTITLE: Installing logrotate on CentOS/RHEL\nDESCRIPTION: Command to install logrotate package using yum package manager on CentOS or RHEL systems.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log-rotate.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum install -y logrotate\n```\n\n----------------------------------------\n\nTITLE: Calculating HTTP Response Age - Pseudocode Algorithm\nDESCRIPTION: Algorithm for calculating the current age of a cached HTTP response. Takes into account age_value from Age header, date_value from Date header, request and response times, and current time to compute the effective age of a cached response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_48\n\nLANGUAGE: pseudocode\nCODE:\n```\n/*\n * age_value\n *      is the value of Age: header received by the cache with\n *              this response.\n * date_value\n *      is the value of the origin server's Date: header\n * request_time\n *      is the (local) time when the cache made the request\n *              that resulted in this cached response\n * response_time\n *      is the (local) time when the cache received the\n *              response\n * now\n *      is the current (local) time\n */\n\napparent_age = max(0, response_time - date_value);\ncorrected_received_age = max(apparent_age, age_value);\nresponse_delay = response_time - request_time;\ncorrected_initial_age = corrected_received_age + response_delay;\nresident_time = now - response_time;\ncurrent_age   = corrected_initial_age + resident_time;\n```\n\n----------------------------------------\n\nTITLE: Verifying SRS Server Network Ports (Bash)\nDESCRIPTION: Uses `netstat` with filtering to check if processes named 'srs' are listening on TCP ports 1935 (master) and 19350 (slave). This helps confirm both SRS instances started successfully and are bound to their respective ports. Requires `netstat` command.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ sudo netstat -anp|grep srs\ntcp        0      0 0.0.0.0:1935                0.0.0.0:*                   LISTEN      7826/srs            \ntcp        0      0 0.0.0.0:19350               0.0.0.0:*                   LISTEN      7834/srs\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Request-Line Structure in BNF Notation\nDESCRIPTION: Specifies the format of the Request-Line which is the first line of an HTTP request. It contains the method, URI, and HTTP version.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_25\n\nLANGUAGE: text\nCODE:\n```\nRequest-Line   = Method SP Request-URI SP HTTP-Version CRLF\n```\n\n----------------------------------------\n\nTITLE: Setting HTTP API Authentication via Environment Variables\nDESCRIPTION: Command to start SRS with HTTP API authentication enabled through environment variables instead of a configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-04-02-Secure-Your-HTTP-API.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nenv SRS_HTTP_API_ENABLED=on SRS_HTTP_SERVER_ENABLED=on \\\n    SRS_HTTP_API_AUTH_ENABLED=on SRS_HTTP_API_AUTH_USERNAME=admin SRS_HTTP_API_AUTH_PASSWORD=admin \\\n    ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: Configuring Merged-Read Settings in SRS\nDESCRIPTION: Configuration for merged-read functionality which affects read performance and latency. Controls buffer size and read behavior for RTMP publishers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost mrw.srs.com {\n    publish {\n        mr          off;\n        mr_latency  350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining EXT-X-STREAM-INF Tag in HLS Master Playlist\nDESCRIPTION: Specifies the format and attributes of the EXT-X-STREAM-INF tag used in HLS master playlists to define variant streams. Includes required and optional attributes such as BANDWIDTH, CODECS, RESOLUTION, AUDIO, VIDEO, SUBTITLES, and CLOSED-CAPTIONS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_12\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-STREAM-INF:<attribute-list>\n<URI>\n```\n\n----------------------------------------\n\nTITLE: RTMP Delivery Page Frontmatter in Markdown\nDESCRIPTION: Markdown frontmatter configuration for the RTMP delivery documentation page, setting up title, sidebar label and display options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/delivery-rtmp.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: RTMP Delivery\nsidebar_label: RTMP Delivery \nhide_title: false\nhide_table_of_contents: false\n---\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 1.0 Branch in Bash\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 1.0 release branch. Used when implementing or testing features specific to version 1.0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 1.0release\n```\n\n----------------------------------------\n\nTITLE: Checking Network Interface IP\nDESCRIPTION: Command to check the IP address of the network interface on Linux.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# ifconfig eth0\neth0      Link encap:Ethernet  HWaddr 08:00:27:8A:EC:94  \n          inet addr:192.168.1.105  Bcast:192.168.2.255  Mask:255.255.255.0\n```\n\n----------------------------------------\n\nTITLE: Describing Stream Conversion Topology - Text Diagram - Text\nDESCRIPTION: This snippet provides a text-based ASCII diagram illustrating the flow of media streams from a client pushing to the stream converter, which then posts RTMP streams to the SRS system, which finally serves those via various protocols. It demonstrates the logical arrangement but does not use any programming logic or implementation. No dependencies required; serves solely as illustrative documentation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/streamer.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nClient ---PUSH--> Stream Converter --RTMP--> SRS --RTMP/FLV/HLS/WebRTC--> Clients\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with systemctl\nDESCRIPTION: Command to start the SRS service using systemctl on distributions that use systemd.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nsudo systemctl start srs\n```\n\n----------------------------------------\n\nTITLE: Setting Up XiaoZhiBo iOS App Dependencies\nDESCRIPTION: Bash commands to navigate to the iOS app directory, install dependencies using CocoaPods, and open the Xcode workspace. This prepares the development environment for the XiaoZhiBo iOS application.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-06-30-Video-Chat-Live.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncd XiaoZhiBo/iOS/APP\npod install\nopen XiaoZhiBoApp.xcworkspace\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Optional Header Fields (ABNF-like)\nDESCRIPTION: Defines various optional header fields allowed in RFC 822 messages using an ABNF-like grammar. This includes fields like Message-ID, In-Reply-To, References, Keywords, Subject, Comments, Encrypted, as well as placeholders for extension and user-defined fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_29\n\nLANGUAGE: abnf\nCODE:\n```\noptional-field =\n             /  \"Message-ID\"        \":\"   msg-id\n             /  \"Resent-Message-ID\" \":\"   msg-id\n             /  \"In-Reply-To\"       \":\"  *(phrase / msg-id)\n             /  \"References\"        \":\"  *(phrase / msg-id)\n             /  \"Keywords\"          \":\"  #phrase\n             /  \"Subject\"           \":\"  *text\n             /  \"Comments\"          \":\"  *text\n             /  \"Encrypted\"         \":\" 1#2word\n             /  extension-field              ; To be defined\n             /  user-defined-field           ; May be pre-empted\n```\n\n----------------------------------------\n\nTITLE: Running SRS-Bench Load Test\nDESCRIPTION: Command to run SRS-Bench load testing tool with 10 simulated clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./objs/sb_rtmp_load -c 10 -r rtmp://192.168.1.105:1935/live/livestream >/dev/null &\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Message Structure (ABNF-like)\nDESCRIPTION: Defines the top-level structure of an RFC 822 message using an ABNF-like grammar. A message consists of header fields followed by an optional message body, separated by a blank line (CRLF).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_15\n\nLANGUAGE: abnf\nCODE:\n```\nmessage     =  fields *( CRLF *text )       ; Everything after\n                                             ;  first null line\n                                             ;  is message body\n```\n\n----------------------------------------\n\nTITLE: Stream Converter Configuration Example\nDESCRIPTION: Complete configuration example showing settings for MPEGTS over UDP, HTTP FLV, and GB28181 protocols including SIP server settings\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/streamer.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n# Push MPEGTS over UDP to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       mpegts_over_udp, push MPEG-TS over UDP and convert to RTMP.\n    caster mpegts_over_udp;\n    # The output rtmp url.\n    # For mpegts_over_udp converter, the typically output url:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/live/livestream;\n    # The listen port for stream converter.\n    # For mpegts_over_udp converter, listen at udp port. for example, 8935.\n    listen 8935;\n}\n\n# Push FLV by HTTP POST to SRS.\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled on;\n    # The type of stream converter, could be:\n    #       flv, push FLV by HTTP POST and convert to RTMP.\n    caster flv;\n    # The output rtmp url.\n    # For flv converter, the typically output url:\n    #           rtmp://127.0.0.1/[app]/[stream]\n    # For example, POST to url:\n    #           http://127.0.0.1:8936/live/livestream.flv\n    # Where the [app] is \"live\" and [stream] is \"livestream\", output is:\n    #           rtmp://127.0.0.1/live/livestream\n    output rtmp://127.0.0.1/[app]/[stream];\n    # The listen port for stream converter.\n    # For flv converter, listen at tcp port. for example, 8936.\n    listen 8936;\n}\n\n# For GB28181 server, see https://github.com/ossrs/srs/issues/3176\n# For SIP specification, see https://www.ietf.org/rfc/rfc3261.html\n# For GB28181 2016 spec, see https://openstd.samr.gov.cn/bzgk/gb/newGbInfo?hcno=469659DC56B9B8187671FF08748CEC89\nstream_caster {\n    # Whether stream converter is enabled.\n    # Default: off\n    enabled off;\n    # The type of stream converter, could be:\n    #       gb28181, Push GB28181 stream and convert to RTMP.\n    caster gb28181;\n    # The output rtmp url.\n    # For gb28181 converter, the typically output url:\n    #           rtmp://127.0.0.1/live/[stream]\n    # The available variables:\n    #           [stream] The video channel codec ID.\n    output rtmp://127.0.0.1/live/[stream];\n    # The listen TCP/UDP port for stream converter.\n    #       For gb28181 converter, listen at TCP/UDP port. for example, 9000.\n    # @remark We always enable bundle for media streams at this port.\n    listen 9000;\n    # SIP server for GB28181. Please note that this is only a demonstrated SIP server, please never use it in your\n    # online production environment. Instead please use [jsip](https://github.com/usnistgov/jsip) and there is a demo\n    # [srs-sip](https://github.com/ossrs/srs-sip) also base on it.\n    sip {\n        # Whether enable embedded SIP server.\n        # Default: on\n        enabled on;\n        # The SIP listen port, for both TCP and UDP protocol.\n        # Default: 5060\n        listen 5060;\n        # The SIP or media transport timeout in seconds.\n        # Default: 60\n        timeout 60;\n        # When media disconnect, the wait time in seconds to re-invite device to publish. During this wait time, device\n        # might send bye or unregister message(expire is 0), so that we will cancel the re-invite.\n        # Default: 5\n        reinvite 5;\n        # The exposed candidate IPs, response in SDP connection line. It can be:\n        #       *           Retrieve server IP automatically, from all network interfaces.\n        #       $CANDIDATE  Read the IP from ENV variable, use * if not set.\n        #       x.x.x.x     A specified IP address or DNS name, use * if 0.0.0.0.\n        # Default: *\n        candidate *;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Originator Fields (ABNF-like)\nDESCRIPTION: Defines the 'originator' component within the 'source' section of RFC 822 headers using an ABNF-like grammar. It consists of authenticated sender/author information ('authentic') and an optional 'Reply-To' field.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_21\n\nLANGUAGE: abnf\nCODE:\n```\noriginator  =   authentic                   ; authenticated addr\n               [ \"Reply-To\"   \":\" 1#address] )\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Force Style Example for Vintage Yellow Subtitles\nDESCRIPTION: Subtitle style configuration for a vintage look with yellow text, italic formatting, and increased character spacing for a more stylized appearance.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nFontname=Roboto,Fontsize=12,PrimaryColour=&H03fcff,Italic=1,Spacing=0.3\n```\n\n----------------------------------------\n\nTITLE: RTMP URL Structure for Custom Platform Restreaming\nDESCRIPTION: Example of RTMP URL format for custom platform restreaming, showing how to separate the URL into push address and stream key components for configuration in Oryx.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nrtmp://ip/app/stream\n```\n\n----------------------------------------\n\nTITLE: SRS Player and Publisher URL Component Parsing Example\nDESCRIPTION: Demonstrates how SRS player and publisher parse RTMP URLs, showing how they extract schema, host/vhost, app, and stream components from a URL.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n// For both srs_player and srs_publisher:\n// play or publish the following rtmp URL:\nrtmp://demo.srs.com/show/live/livestream/2013\nschema: rtmp\nhost/vhost: demo.srs.com\napp: show/live/livestream\nstream: 2013\n```\n\n----------------------------------------\n\nTITLE: Example SRS Status and Log Output (Bash)\nDESCRIPTION: Illustrates the expected output when checking the status of a running SRS server and tailing its log file. It shows the server process ID and sample log messages indicating normal operation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/getting-started-build.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nMB0:trunk $ ./etc/init.d/srs status\nSRS(pid 90408) is running.                                 [  OK  ]\n\nMB0:trunk $ tail -n 30 -f ./objs/srs.log\n[2021-08-13 10:30:36.634][Trace][90408][12c97232] Hybrid cpu=0.00%,0MB, cid=1,1, timer=61,0,0, clock=0,22,25,0,0,0,0,1,0\n```\n\n----------------------------------------\n\nTITLE: Tracing Source Session Logs\nDESCRIPTION: Shows how to trace source session logs using the source ID to find upstream connection information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngrep -ina \"\\[12665\\]\\[115\\]\" objs/edge.log\n```\n\n----------------------------------------\n\nTITLE: Coroutine-Native SRT Publishing in C++\nDESCRIPTION: This snippet illustrates the coroutine-native approach for SRT publishing. It shows a simplified main loop for reading and processing SRT packets within a coroutine, demonstrating clearer error handling and state management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsMpegtsSrtConn::do_publishing() {\n  while (true) {\n    ssize_t nb = 0;\n    if ((err = srt_conn_->read(buf, sizeof(buf), &nb)) != srs_success) {\n      return srs_error_wrap(err, \"srt: recvmsg\");\n    }\n    \n    if ((err = on_srt_packet(buf, nb)) != srs_success) {\n      return srs_error_wrap(err, \"srt: process packet\");\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Updates from All Remotes using Git\nDESCRIPTION: This command fetches updates (new commits, branches, tags) from all configured remote repositories (typically `origin` and `srs`) without merging them into local branches. This step ensures the local repository has the latest information before creating a new branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_2\n\nLANGUAGE: git\nCODE:\n```\ngit fetch --all\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Extension Fields Placeholder (ABNF-like)\nDESCRIPTION: Provides a placeholder definition for extension fields within the RFC 822 grammar. These are fields defined in separate, formal extension documents and must not start with 'X-'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_31\n\nLANGUAGE: abnf\nCODE:\n```\nextension-field = \n               <Any field which is defined in a document\n                published as a formal extension to this\n                specification; none will have names beginning\n                with the string \"X-\">\n```\n\n----------------------------------------\n\nTITLE: Cloning FFmpeg v5.1.2 Source for Legacy Patch - Bash\nDESCRIPTION: This snippet is for obtaining a specific release (v5.1.2) of FFmpeg for cases where legacy patching is necessary to enable HEVC over RTMP/FLV in older FFmpeg versions. Requires git and creates a source directory for patching. Input: none; Output: checked out source repository in ~/git/FFmpeg.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b n5.1.2 https://github.com/FFmpeg/FFmpeg.git ~/git/FFmpeg\n```\n\n----------------------------------------\n\nTITLE: Defining Comments with Semicolon in Augmented BNF\nDESCRIPTION: Specifies that a semicolon (';') initiates a comment in the augmented BNF notation. The comment extends from the semicolon to the end of the line and is typically offset to the right of the rule definition for clarity.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_6\n\nLANGUAGE: abnf\nCODE:\n```\n; COMMENTS\n```\n\n----------------------------------------\n\nTITLE: Creating Symlink to init.d Script\nDESCRIPTION: Command to create a symbolic link from the SRS init.d script to the system's init.d directory, allowing it to be managed as a system service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/service.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsudo ln -sf \\\n    /usr/local/srs/etc/init.d/srs \\\n    /etc/init.d/srs\n```\n\n----------------------------------------\n\nTITLE: Project Table - DASH SegmentTemplate Implementation\nDESCRIPTION: Markdown table defining the DASH SegmentTemplate Time mode project details including mentor information, skills needed, and expected outcomes\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-02-10-GSoC.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n|Name of project|DASH support SegmentTemplate Time mode|\n| :---- | :----- |\n|Project Description|The current SRS DASH only supports SegmentTemplate's Number mode, while the mainstream players are more recommended Time mode.|\n|Mentor|Zhihong Xiao(hondaxiao@tencent.com)|\n|Backup Mentor|Winlin(winlinvip@gmail.com), Steven Liu(lq@chinaffmpeg.org)|\n|Skills needed|Familiar with DASH protocol, understand video to encapsulation, familiar with using C++ programming.|\n|Expected size of project|280 hours|\n|Difficulty|Intermediate|\n|Expected results|Be able to use dash.js, VLC, ffplay and other common players for playback.|\n|Qualification Task|Implement DASH SegmentTemplate Time mode.|\n```\n\n----------------------------------------\n\nTITLE: Allow Cache Tag Format\nDESCRIPTION: Format specification for EXT-X-ALLOW-CACHE tag that indicates whether clients can cache media segments\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\n#EXT-X-ALLOW-CACHE:<YES|NO>\n```\n\n----------------------------------------\n\nTITLE: Defining Optional Elements with Square Brackets in Augmented BNF\nDESCRIPTION: Explains that square brackets ('[]') in augmented BNF enclose optional elements. The example '[foo bar]' is shown to be equivalent to '*1(foo bar)', meaning zero or one occurrence of the sequence 'foo bar'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_3\n\nLANGUAGE: abnf\nCODE:\n```\n[foo bar]\n```\n\nLANGUAGE: abnf\nCODE:\n```\n*1(foo bar)\n```\n\n----------------------------------------\n\nTITLE: Defining Expect Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax and usage of the Expect request-header field in HTTP/1.1. This header is used to indicate that particular server behaviors are required by the client.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_71\n\nLANGUAGE: HTTP\nCODE:\n```\nExpect       =  \"Expect\" \":\" 1#expectation\n\nexpectation  =  \"100-continue\" | expectation-extension\nexpectation-extension =  token [ \"=\" ( token | quoted-string )\n                           *expect-params ]\nexpect-params =  \";\" token [ \"=\" ( token | quoted-string ) ]\n```\n\n----------------------------------------\n\nTITLE: API Workflow Diagram\nDESCRIPTION: Text-based diagram showing the workflow between Chrome/Application and SRS server via HTTP API.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/http-api.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+-------------------------+               +-------+\n+ Chrome/Your Application +--HTTP-API-->--+  SRS  +\n+-------------------------+               +-------+\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Trace Fields (ABNF-like)\nDESCRIPTION: Defines the 'trace' component within the 'source' section of RFC 822 headers using an ABNF-like grammar. Trace information consists of a 'Return-path' field and one or more 'Received' fields, documenting the message's transit.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_18\n\nLANGUAGE: abnf\nCODE:\n```\ntrace       =    return                     ; path to sender\n                1*received                   ; receipt tags\n```\n\n----------------------------------------\n\nTITLE: Defining Attribute List Syntax in M3U8\nDESCRIPTION: Specifies the syntax for an attribute/value pair within an M3U8 Attribute List. An Attribute List is a comma-separated list of these pairs with no whitespace, used by certain extended M3U tags. AttributeName is an unquoted string ([A..Z], '-'), and AttributeValue can be various types (decimal-integer, hexadecimal-integer, decimal-floating-point, quoted-string, enumerated-string, decimal-resolution). A given AttributeName MUST NOT appear more than once in a list.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_0\n\nLANGUAGE: m3u8\nCODE:\n```\nAttributeName=AttributeValue\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Slave Server (Port 1936)\nDESCRIPTION: This configuration file content (intended for `srs.1936.conf`) defines another SRS slave instance on the same machine as the previous one but listening on a different port (`1936`). It uses a distinct PID file (`./objs/srs.1936.pid`) and sets the maximum connections. This instance also receives forwarded streams, allowing load distribution or redundancy on the slave server by running multiple SRS processes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/forward.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1936;\npid                 ./objs/srs.1936.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: ST Read Implementation\nDESCRIPTION: Internal implementation of st_read showing how coroutine switching is handled for non-blocking IO.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nssize_t st_read(_st_netfd_t *fd, void *buf, size_t nbyte) {\n    while ((n = read(fd->osfd, buf, nbyte)) < 0) {\n        if (errno == EINTR)\n            continue;\n        if (!_IO_NOT_READY_ERROR) // Error, if not EAGAIN.\n            return -1;\n\n        /* Wait until the socket becomes readable */\n        if (st_netfd_poll(fd, POLLIN) < 0) // EAGAIN\n            return -1;\n    }\n    \n    return n;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Logrotate Package\nDESCRIPTION: Command to install the logrotate package using yum package manager.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/log-rotate.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo yum install -y logrotate\n```\n\n----------------------------------------\n\nTITLE: Accept-Language Header Syntax in BNF\nDESCRIPTION: BNF syntax definition for the Accept-Language header that indicates preferred natural languages for the response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_51\n\nLANGUAGE: BNF\nCODE:\n```\nAccept-Language = \"Accept-Language\" \":\"\n                         1#( language-range [ \";\" \"q\" \"=\" qvalue ] )\nlanguage-range  = ( ( 1*8ALPHA *( \"-\" 1*8ALPHA ) ) | \"*\" )\n```\n\n----------------------------------------\n\nTITLE: HTTP Location Header Example\nDESCRIPTION: Example of a Location response header field used to redirect recipients to a different URI.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_80\n\nLANGUAGE: http\nCODE:\n```\nLocation: http://www.w3.org/pub/WWW/People.html\n```\n\n----------------------------------------\n\nTITLE: Defining Retry-After Header Syntax and Examples in HTTP/1.1\nDESCRIPTION: Syntax definition and examples of the Retry-After response header in HTTP/1.1, used to indicate how long a service will be unavailable or the minimum time before a redirected request should be issued.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_85\n\nLANGUAGE: http\nCODE:\n```\nRetry-After  = \"Retry-After\" \":\" ( HTTP-date | delta-seconds )\n\nTwo examples of its use are\n\nRetry-After: Fri, 31 Dec 1999 23:59:59 GMT\nRetry-After: 120\n```\n\n----------------------------------------\n\nTITLE: WebRTC TCP Connection Class Implementation\nDESCRIPTION: Definition of SrsRtcTcpConn and SrsRtcTcpNetwork classes showing the relationship between TCP connection and RTC session management using shared resources.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nclass SrsRtcTcpConn\n{\nprivate:\n    // Since the session references this object, we should directly use the session pointer.\n    SrsRtcConnection* session_;\n};\n\nclass SrsRtcTcpNetwork: public ISrsRtcNetwork\n{\nprivate:\n    SrsSharedResource<SrsRtcTcpConn> owner_;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 'Message-ID' Value Syntax (ABNF-like)\nDESCRIPTION: Specifies the syntax for the value of a 'Message-ID' (or 'Resent-Message-ID') field in RFC 822 using an ABNF-like grammar. It must be a unique identifier enclosed in angle brackets, typically based on an address specification.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_30\n\nLANGUAGE: abnf\nCODE:\n```\nmsg-id      =  \"<\" addr-spec \">\"            ; Unique message id\n```\n\n----------------------------------------\n\nTITLE: HTTP Client Binary Exponential Backoff Algorithm\nDESCRIPTION: Algorithm for HTTP/1.1 clients to reliably retry requests when server prematurely closes connection. Implements exponential backoff to avoid overwhelming the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_39\n\nLANGUAGE: plaintext\nCODE:\n```\n1. Initiate a new connection to the server\n2. Transmit the request-headers\n3. Initialize a variable R to the estimated round-trip time to the server (e.g., based on the time it took to establish the connection), or to a constant value of 5 seconds if the round-trip time is not available.\n4. Compute T = R * (2**N), where N is the number of previous retries of this request.\n5. Wait either for an error response from the server, or for T seconds (whichever comes first)\n6. If no error response is received, after T seconds transmit the body of the request.\n7. If client sees that the connection is closed prematurely, repeat from step 1 until the request is accepted, an error response is received, or the user becomes impatient and terminates the retry process.\n```\n\n----------------------------------------\n\nTITLE: Find Source ID in Origin Log\nDESCRIPTION: Searches for log entries related to a specific source ID on the origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ngrep --color -ina \"\\[105\\]\" objs/srs.origin.log\n```\n\n----------------------------------------\n\nTITLE: Defining Transfer-Encoding Header Syntax and Example in HTTP/1.1\nDESCRIPTION: Syntax definition and example of the Transfer-Encoding general-header field in HTTP/1.1, which indicates what type of transformation has been applied to the message body for safe transfer.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_89\n\nLANGUAGE: http\nCODE:\n```\nTransfer-Encoding       = \"Transfer-Encoding\" \":\" 1#transfer-coding\n\nAn example is:\n\nTransfer-Encoding: chunked\n```\n\n----------------------------------------\n\nTITLE: Using From Header in HTTP/1.0\nDESCRIPTION: Example of the From request-header field containing an Internet email address for the human user controlling the requesting user agent. This helps with identifying the source of requests and contacting responsible parties.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_36\n\nLANGUAGE: plaintext\nCODE:\n```\nFrom: webmaster@w3.org\n```\n\n----------------------------------------\n\nTITLE: HEVC Streaming Architecture Diagram\nDESCRIPTION: Text diagram showing the architecture flow from FFmpeg through SRS to various clients for H.265 streaming\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/hevc.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nFFmpeg --RTMP(h.265)---> SRS ----RTMP/FLV/TS/HLS/WebRTC(h.265)--> Chrome/Safari\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Event Format for OCR in JSON\nDESCRIPTION: Demonstrates the JSON structure for OCR callback requests and responses. The request includes various identification fields like request_id, vhost, app, and stream, along with OCR-specific fields such as prompt and result. The response is a simple status acknowledgment with a code field.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_ocr\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"prompt\": \"What is in the image?\",\n  \"result\": \"The image shows a scene featuring a character from a film, likely set in a military or high-tech environment.\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Simple Request and Response Format\nDESCRIPTION: Specifies the basic format for simplified HTTP 1.0 requests (GET only) and responses without headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_16\n\nLANGUAGE: http\nCODE:\n```\nSimple-Request  = \"GET\" SP Request-URI CRLF\n\nSimple-Response = [ Entity-Body ]\n```\n\n----------------------------------------\n\nTITLE: Starting SRS via Init.d Script - Bash\nDESCRIPTION: Starts the SRS service using the established init.d script. Needs '/etc/init.d/srs' in place. No parameters required; outputs service start result.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/service.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs start\n```\n\n----------------------------------------\n\nTITLE: Illustrating Header Field Folding Example 1 (RFC 822)\nDESCRIPTION: Demonstrates the concept of header field folding in RFC 822, where a long logical line can be split into multiple physical lines. This example shows the 'To:' field split after a comma, with the subsequent line indented by LWSP-chars (Linear White Space Characters).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nTo:  \"Joe & J. Harvey\" <ddd @ Org>,\n        JJV@BBN\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 3.0 Branch\nDESCRIPTION: Git commands to pull latest changes and switch to SRS 3.0 release branch\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 3.0release\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP URL Structure\nDESCRIPTION: Specifies the syntax for http URLs, including the scheme, host, optional port, path, and optional query string.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_6\n\nLANGUAGE: HTTP\nCODE:\n```\nhttp_URL = \"http:\" \"//\" host [ \":\" port ] [ abs_path [ \"?\" query ]]\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Repository - Bash\nDESCRIPTION: This command updates an existing SRS local repository by pulling the latest changes from the remote origin via Git. Assumes the working directory is inside an already cloned SRS repo. Updates source code to the latest version, which is recommended before building.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-dash.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 'Return-path' Field Syntax (ABNF-like)\nDESCRIPTION: Specifies the syntax for the 'Return-path' header field in RFC 822 using an ABNF-like grammar. This field indicates the address to which return messages (like bounces) should be sent.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_19\n\nLANGUAGE: abnf\nCODE:\n```\nreturn      =  \"Return-path\" \":\" route-addr ; return address\n```\n\n----------------------------------------\n\nTITLE: Configuring FFMPEG with Reduced Log Output\nDESCRIPTION: This snippet shows how to configure FFMPEG in SRS to output less verbose logs by adding the '-v quiet' parameter.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n                # -v quiet\n                v           quiet;\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Oryx Docker Container\nDESCRIPTION: Command to create and run an Oryx instance using Docker. It maps necessary ports and mounts a data volume.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-11-28-Oryx-Live-Streams-Transcription.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 80:2022 -p 443:2443 -p 1935:1935 \\\n  -p 8080:8080 -p 8000:8000/udp -p 10080:10080/udp --name oryx \\\n  -v $HOME/data:/data registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Keyframe Wait for Segment Reaping in SRS\nDESCRIPTION: Determines whether to wait for a keyframe before reaping an HLS segment. If enabled, segments are reaped when duration exceeds the fragment and a keyframe is received.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_7\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    hls {\n        hls_wait_keyframe       on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Local Alternatives with Parentheses in Augmented BNF\nDESCRIPTION: Describes how parentheses are used in the augmented BNF to group elements, allowing alternatives within a sequence. The example '(elem (foo / bar) elem)' shows that the valid sequences are 'elem foo elem' and 'elem bar elem'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_1\n\nLANGUAGE: abnf\nCODE:\n```\n(elem (foo / bar) elem)\n```\n\n----------------------------------------\n\nTITLE: Cloning your forked SRS repository\nDESCRIPTION: Commands to clone your forked SRS repository and checkout the master branch. This is the first step after forking the SRS repository to your GitHub account.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:your-account/srs.git\ngit checkout -b master origin/master\ncd srs\n```\n\n----------------------------------------\n\nTITLE: OBS Direct Restream Architecture Diagram\nDESCRIPTION: Diagram illustrating OBS direct restreaming architecture, where OBS pushes streams directly to multiple platforms without an intermediary server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_8\n\nLANGUAGE: text\nCODE:\n```\nOBS --RTMP--> B\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: FMLE (Flash Media Live Encoder) configuration settings for stream publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ffmpeg.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Verifying Service Listening Port using netstat in Bash\nDESCRIPTION: These examples use `netstat -anp` piped to `grep` to check if a process is listening on a specific TCP port. The first checks for Nginx (PID 6486) on port 19350. The second checks for SRS (PID 6583) on port 1935. This verifies that the server started correctly and is bound to the expected port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# netstat -anp|grep 19350\ntcp        0      0 0.0.0.0:19350               0.0.0.0:*                   LISTEN      6486/nginx\n```\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 trunk]# netstat -anp|grep \"1935 \"\ntcp        0      0 0.0.0.0:1935                0.0.0.0:*                   LISTEN      6583/srs\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Flash Media Live Encoder (FMLE) configuration settings for stream publishing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Multiple Stream Configuration with Movie Stream\nDESCRIPTION: Example URLs demonstrating how to configure multiple streams by changing the resource name to 'movie'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-08-29-Oryx-Ensuring-Authentication-for-Live-Streaming-Publishing.md#2025-04-23_snippet_1\n\nLANGUAGE: url\nCODE:\n```\nrtmp://135.98.31.15/live/movie?secret=5181a08ee6eab86597e913e1f9e4c294\nhttp://135.98.31.15/live/movie.m3u8\n```\n\n----------------------------------------\n\nTITLE: Starting Origin Server\nDESCRIPTION: Command to start the SRS origin server from which edge servers pull streams\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/reuse-port.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.conf\n```\n\n----------------------------------------\n\nTITLE: HTTP Request/Response Message Format Definition in ABNF\nDESCRIPTION: Defines the basic structure of HTTP messages using ABNF notation, showing both request and response formats including start-line, headers, and message body components.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_15\n\nLANGUAGE: abnf\nCODE:\n```\nHTTP-message   = Request | Response     ; HTTP/1.1 messages\ngeneric-message = start-line\n                 *(message-header CRLF)\n                 CRLF\n                 [ message-body ]\nstart-line      = Request-Line | Status-Line\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Repository\nDESCRIPTION: Command to update an existing SRS repository to the latest version using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Entity Header Fields in BNF\nDESCRIPTION: Specification of HTTP/1.0 entity header fields that define optional metainformation about the entity body or resource.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_26\n\nLANGUAGE: BNF\nCODE:\n```\nEntity-Header  = Allow                    ; Section 10.1\n                      | Content-Encoding         ; Section 10.3\n                      | Content-Length           ; Section 10.4\n                      | Content-Type             ; Section 10.5\n                      | Expires                  ; Section 10.7\n                      | Last-Modified            ; Section 10.10\n                      | extension-header\n\nextension-header = HTTP-header\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Compile SRS from source code using the configure script and make command.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Linking to Pages in Documentation Using Markdown\nDESCRIPTION: Shows how to create a link to a page within the documentation using a relative path. The example demonstrates linking to the license page by traversing three directory levels upward.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n[MIT Licensed](../../../license)\n```\n\n----------------------------------------\n\nTITLE: Using Content-Encoding Header in HTTP/1.0\nDESCRIPTION: Example of the Content-Encoding header usage that indicates compression has been applied to a resource. This header specifies what decoding mechanism must be applied to obtain the media-type referenced by Content-Type.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_31\n\nLANGUAGE: plaintext\nCODE:\n```\nContent-Encoding: x-gzip\n```\n\n----------------------------------------\n\nTITLE: Basic Epoll-driven Async TCP Code\nDESCRIPTION: Example showing traditional epoll-based asynchronous TCP socket handling without coroutines.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint fd = accept(listen_fd); // Got a TCP connection.\n\nint n = read(fd, buf, sizeof(buf));\nif (n == -1) {\n  if (errno == EAGAIN) { // Not ready\n    return epoll_ctl(fd, EPOLLIN); // Wait for fd to be ready.\n  }\n  return n; // Error.\n}\n\nprintf(\"Got %d size of data %p\", n, buf);\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Request-URI Options in BNF Notation\nDESCRIPTION: Specifies the formats for Request-URI in HTTP requests. Four options are available: '*', absoluteURI, abs_path, or authority, depending on the request context.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_27\n\nLANGUAGE: text\nCODE:\n```\nRequest-URI    = \"*\" | absoluteURI | abs_path | authority\n```\n\n----------------------------------------\n\nTITLE: Implementing Executor Coroutine for Resource Management\nDESCRIPTION: Implementation of a coroutine executor that manages resource lifecycles, including construction, destruction, and cycle handling.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nSrsExecutorCoroutine::SrsExecutorCoroutine(ISrsResourceManager* m, ISrsResource* r)\n{\n    resource_ = r;\n    manager_ = m;\n    trd_ = new SrsSTCoroutine(\"ar\", this, resource_->get_id());\n}\n\nSrsExecutorCoroutine::~SrsExecutorCoroutine()\n{\n    manager_->remove(resource_);\n    srs_freep(trd_);\n}\n\nsrs_error_t SrsExecutorCoroutine::cycle()\n{\n    srs_error_t err = handler_->cycle();\n    manager_->remove(this);\n    return err;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multipart Byteranges HTTP Response Example\nDESCRIPTION: Example of an HTTP/1.1 206 Partial Content response using multipart/byteranges media type to transmit multiple content ranges. Shows response headers and body format with boundary separators.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_93\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 206 Partial Content\nDate: Wed, 15 Nov 1995 06:25:24 GMT\nLast-Modified: Wed, 15 Nov 1995 04:58:08 GMT\nContent-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES\n\n--THIS_STRING_SEPARATES\nContent-type: application/pdf\nContent-range: bytes 500-999/8000\n\n...the first range...\n--THIS_STRING_SEPARATES\nContent-type: application/pdf\nContent-range: bytes 7000-7999/8000\n\n...the second range\n--THIS_STRING_SEPARATES--\n```\n\n----------------------------------------\n\nTITLE: Illustrating Header Field Folding Example 3 (RFC 822)\nDESCRIPTION: Shows a third variation of header field folding, demonstrating that folding can occur even within quoted strings or address components, as long as the continuation line starts with at least one LWSP-char.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nTo:  \"Joe &\n J. Harvey\" <ddd @ Org>, JJV @ BBN\n```\n\n----------------------------------------\n\nTITLE: Multiple Customer Vhost Configuration\nDESCRIPTION: SRS configuration example showing how to set up multiple virtual hosts for different customers (CCTV and WASU).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n}\nvhost show.wasu.cn {\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP URL Syntax in BNF\nDESCRIPTION: Specifies the syntax for HTTP URLs using BNF notation. It defines the structure of an HTTP URL, including the scheme, host, optional port, and absolute path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_7\n\nLANGUAGE: BNF\nCODE:\n```\nhttp_URL       = \"http:\" \"//\" host [ \":\" port ] [ abs_path ]\n\nhost           = <A legal Internet host domain name\n                         or IP address (in dotted-decimal form),\n                         as defined by Section 2.1 of RFC 1123>\n\nport           = *DIGIT\n```\n\n----------------------------------------\n\nTITLE: Setting Subtitle Position with FFmpeg force_style\nDESCRIPTION: Configures subtitle alignment to bottom center with 20px margin from the bottom using FFmpeg's force_style format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_15\n\nLANGUAGE: text\nCODE:\n```\nAlignment=2,MarginV=20\n```\n\n----------------------------------------\n\nTITLE: Defining EXT-X-MAP Tag in HLS Media Playlist\nDESCRIPTION: Specifies the format and attributes of the EXT-X-MAP tag used in HLS media playlists to indicate how to obtain header information required to parse media segments. Includes URI and optional BYTERANGE attributes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_16\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-MAP:<attribute-list>\n```\n\n----------------------------------------\n\nTITLE: Starting Edge Server with Port Reuse\nDESCRIPTION: Commands to start multiple SRS edge servers listening on the same port 1935 using SO_REUSEPORT feature\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/reuse-port.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge.conf\n```\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/edge2.conf\n```\n\n----------------------------------------\n\nTITLE: Content-Disposition Header Syntax\nDESCRIPTION: Definition of the Content-Disposition response header field syntax, used for suggesting default filenames when saving content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_95\n\nLANGUAGE: text\nCODE:\n```\ncontent-disposition = \"Content-Disposition\" \":\"\n                      disposition-type *( \";\" disposition-parm )\n```\n\n----------------------------------------\n\nTITLE: Example of a Domain-Literal in ARPA Internet Address Format\nDESCRIPTION: An example of a domain-literal format representing a 32-bit Internet address in four 8-bit fields noted in decimal, as specified in RFC #820.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_33\n\nLANGUAGE: plain text\nCODE:\n```\n[10.0.3.19]\n```\n\n----------------------------------------\n\nTITLE: Illustrating Direct Browser-to-Browser WebRTC Communication\nDESCRIPTION: This ASCII diagram shows the basic concept of WebRTC, where two browsers communicate directly using Signaling (for negotiation) and Media (for data streams). This represents the foundational peer-to-peer model.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n+----------------+                        +----------------+\n+    Browser     +----<--Signaling----->--+    Browser     +\n+ (like Chrome)  +----<----Media----->----+ (like Chrome)  +\n+----------------+                        +----------------+\n```\n\n----------------------------------------\n\nTITLE: Defining Allow Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax and example usage of the Allow header field in HTTP/1.1. The Allow header lists the set of methods supported by the resource identified by the Request-URI.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_54\n\nLANGUAGE: plaintext\nCODE:\n```\nAllow   = \"Allow\" \":\" #Method\n\nExample of use:\n\nAllow: GET, HEAD, PUT\n```\n\n----------------------------------------\n\nTITLE: Handling SRT Connections with Epoll in C++\nDESCRIPTION: This code snippet demonstrates how SRT connections are handled using epoll in a callback-based approach. It shows the event loop, connection handling, and new connection addition process.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nwhile (run_flag) {\n  int ret = srt_epoll_wait(_pollid, read_fds, &rfd_num, write_fds);\n  for (int index = 0; index < rfd_num; index++) {\n    SRT_SOCKSTATUS status = srt_getsockstate(read_fds[index]);\n    srt_handle_connection(status, read_fds[index], \"read fd\");\n  }\n}\n\nvoid srt_server::srt_handle_connection(SRT_SOCKSTATUS status, SRTSOCKET input_fd) {\n  if (status == SRTS_LISTENING) {\n    conn_fd = srt_accept(input_fd, (sockaddr*)&scl, &sclen);\n    _handle_ptr->add_newconn(conn_fd, SRT_EPOLL_IN);\n  }\n}\n\nvoid srt_handle::add_newconn(SRT_CONN_PTR conn_ptr, int events) {\n    _push_conn_map.insert(std::make_pair(conn_ptr->get_path(), conn_ptr));\n    _conn_map.insert(std::make_pair(conn_ptr->get_conn(), conn_ptr));\n    int ret = srt_epoll_add_usock(_handle_pollid, conn_ptr->get_conn(), &events);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Method Types in BNF Notation\nDESCRIPTION: Lists the standard HTTP methods (OPTIONS, GET, HEAD, etc.) and allows for extension methods. Defines the structure for valid HTTP method tokens.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_26\n\nLANGUAGE: text\nCODE:\n```\nMethod         = \"OPTIONS\"                ; Section 9.2\n                      | \"GET\"                    ; Section 9.3\n                      | \"HEAD\"                   ; Section 9.4\n                      | \"POST\"                   ; Section 9.5\n                      | \"PUT\"                    ; Section 9.6\n                      | \"DELETE\"                 ; Section 9.7\n                      | \"TRACE\"                  ; Section 9.8\n                      | \"CONNECT\"                ; Section 9.9\n                      | extension-method\nextension-method = token\n```\n\n----------------------------------------\n\nTITLE: HTTP Basic Authentication Credentials Format\nDESCRIPTION: Example of client authorization header containing base64 encoded credentials for user 'Aladdin' with password 'open sesame'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_39\n\nLANGUAGE: http\nCODE:\n```\nAuthorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Codebase - Bash\nDESCRIPTION: This snippet updates an existing local clone of the SRS codebase from the remote repository using Git. It assumes the repository has already been cloned and that you are within the SRS directory. No extra dependencies or parameters are needed other than Git.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-realtime.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Entity Header Fields in HTTP/1.1\nDESCRIPTION: Lists the standard entity header fields in HTTP/1.1 with references to their sections in the RFC. These headers define metadata about the entity body or the resource identified by the request.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_36\n\nLANGUAGE: http\nCODE:\n```\nentity-header  = Allow                    ; Section 14.7\n                | Content-Encoding         ; Section 14.11\n                | Content-Language         ; Section 14.12\n                | Content-Length           ; Section 14.13\n                | Content-Location         ; Section 14.14\n                | Content-MD5              ; Section 14.15\n                | Content-Range            ; Section 14.16\n                | Content-Type             ; Section 14.17\n                | Expires                  ; Section 14.21\n                | Last-Modified            ; Section 14.29\n                | extension-header\n\nextension-header = message-header\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback JSON Request and Response for on_ocr Event\nDESCRIPTION: This snippet illustrates the JSON structure for the on_ocr event HTTP callback request and response. It includes details like request_id, action, stream information, UUID, OCR prompt and result, and the expected response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_ocr\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"prompt\": \"What is in the image?\",\n  \"result\": \"The image shows a scene featuring a character from a film, likely set in a military or high-tech environment.\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Message Template for Closing Duplicate Issues\nDESCRIPTION: Template message indicating that the issue will be closed because it's a duplicate or better suited for discussion platforms like Discord.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-server-en.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nFor discussion or idea, please ask in [discord](https://discord.gg/yZ4BnPmHAd).\n\nThis issue will be eliminated, see #2716\n```\n\n----------------------------------------\n\nTITLE: HTTP POST Method Implementation\nDESCRIPTION: Documents the POST method for submitting entities to servers, covering functions like resource annotation, message posting, and data submission.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_43\n\nLANGUAGE: http\nCODE:\n```\nPOST /path HTTP/1.1\\nHost: example.com\\nContent-Type: application/x-www-form-urlencoded\n```\n\n----------------------------------------\n\nTITLE: Content Disposition Header Format\nDESCRIPTION: Specification of content disposition header format including attachment and filename parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_96\n\nLANGUAGE: text\nCODE:\n```\ndisposition-type = \"attachment\" | disp-extension-token\ndisposition-parm = filename-parm | disp-extension-parm\nfilename-parm = \"filename\" \"=\" quoted-string\ndisp-extension-token = token\ndisp-extension-parm = token \"=\" ( token | quoted-string )\n```\n\n----------------------------------------\n\nTITLE: Discouraging Multi-Level App/Stream RTMP URLs in SRS (Bash Example)\nDESCRIPTION: Illustrates RTMP URLs with multi-level application and stream paths. SRS documentation discourages this format, recommending a single-level structure (e.g., rtmp://server/app/stream) for clarity and compatibility with tools like srs_player and srs_publisher.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n// Not recomment multiple level app and stream, which confuse people.\nrtmp://demo.srs.com/show/live/livestream\nrtmp://demo.srs.com/show/live/livestream/2013\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 User-Defined Fields Placeholder (ABNF-like)\nDESCRIPTION: Provides a placeholder definition for user-defined fields within the RFC 822 grammar. These are fields not defined in the specification or its extensions and may be preempted by future standards.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_32\n\nLANGUAGE: abnf\nCODE:\n```\nuser-defined-field =\n               <Any field which has not been defined\n                in this specification or published as an\n                extension to this specification; names for\n                such fields must be unique and may be\n                pre-empted by published extensions>\n```\n\n----------------------------------------\n\nTITLE: Checking Pod Status After Rolling Update (Bash)\nDESCRIPTION: This command uses `kubectl get po` and filters the output using `grep edge` to display the status of pods belonging to the SRS edge deployment during or after a rolling update. The example output shows an old pod (`srs-edge-deploy-58d9999b7c-z9gbm`) in the `Terminating` state while new pods (`srs-edge-deploy-76fcbfb848-*`) with the updated configuration are already `Running`. This provides a snapshot of the rolling update progress.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/k8s.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get po |grep edge\nNAME                                   READY   STATUS        RESTARTS   AGE\nsrs-edge-deploy-58d9999b7c-z9gbm       0/1     Terminating   0          3m52s\nsrs-edge-deploy-76fcbfb848-z5rmn       1/1     Running       0          104s\nsrs-edge-deploy-76fcbfb848-zt4wv       1/1     Running       0          106s\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Force Style Example for Netflix-like Subtitles\nDESCRIPTION: Subtitle style configuration that resembles Netflix subtitles with Roboto font, white text, semi-transparent background, and no outline or shadow effects.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_13\n\nLANGUAGE: text\nCODE:\n```\nFontname=Roboto,Fontsize=12,PrimaryColour=&HFFFFFF,BorderStyle=0,BackColour=&H80000000,Outline=0,Shadow=0.75\n```\n\n----------------------------------------\n\nTITLE: Ping Command Output for DNS Verification\nDESCRIPTION: Example output from the ping command showing successful DNS resolution where the domain correctly points to the server's public IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-12-Oryx-HTTPS.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nOutput\nPING ossrs.io (your_public_ipv4): 56 data bytes\n64 bytes from your_public_ipv4: icmp_seq=0 ttl=64 time=11.828 ms\n64 bytes from your_public_ipv4: icmp_seq=1 ttl=64 time=16.553 ms\n64 bytes from your_public_ipv4: icmp_seq=2 ttl=64 time=12.433 ms\n```\n\n----------------------------------------\n\nTITLE: Proxying SRS HTTP API with Bearer Token - Bash\nDESCRIPTION: Executes an authenticated HTTP GET request to retrieve the list of virtual hosts from the SRS API via the Oryx proxy within the '/api/v1/vhosts/' endpoint. Requires a valid Bearer token, Content-Type header, and uses the GET method.\n\nInput: API URL, Bearer token; Output: JSON response listing vhosts. Dependencies: curl.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/api/v1/vhosts/ \\\n  -X GET -H 'Authorization: Bearer xxxxxx' \\\n  -H 'Content-Type: application/json'\n```\n\n----------------------------------------\n\nTITLE: Disabling Auto ATC Detection in SRS\nDESCRIPTION: Configuration example for disabling automatic ATC detection in SRS. This prevents SRS from automatically enabling ATC when it detects the 'bravo_atc=true' metadata in the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp-atc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost atc.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: English Speaking Coach Prompt for GPT AI Assistant\nDESCRIPTION: A text prompt configuration for the GPT AI assistant to act as an English language coach. This prompt instructs the AI to correct grammar mistakes and engage in practice conversations to improve spoken English.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-01-31-Browser-Voice-Driven-GPT.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nI want you to act as a spoken English teacher and improver. \nI will speak to you in English and you will reply to me in English to practice my spoken English. \nI want you to strictly correct my grammar mistakes, typos, and factual errors. \nI want you to ask me a question in your reply. \nNow let's start practicing, you could ask me a question first. \nRemember, I want you to strictly correct my grammar mistakes, typos, and factual errors.\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Coroutines with State Threads in C\nDESCRIPTION: This C program demonstrates how to use State Threads to create and manage multiple coroutines. Each coroutine simulates a network connection by sleeping for a specified time. The number of coroutines is specified as a command-line argument.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-02-26-State-Threads-for-Internet-Applications.md#2025-04-23_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>\n#include \"st.h\"\n\nvoid* do_calc(void* arg){\n    int sleep_ms = (int)(long int)(char*)arg * 10;\n    \n    for(;;){\n        printf(\"in sthread #%dms\\n\", sleep_ms);\n        st_usleep(sleep_ms * 1000);\n    }\n    \n    return NULL;\n}\n\nint main(int argc, char** argv){\n    if(argc <= 1){\n        printf(\"Test the concurrence of state-threads!\\n\");\n        printf(\"Usage: %s <sthread_count>\\n\");\n        printf(\"eg. %s 10000\\n\", argv[0], argv[0]);\n        return -1;\n    }\n    \n    if(st_init() < 0){\n        printf(\"st_init error!\");\n        return -1;\n    }\n    \n    int i;\n    int count = atoi(argv[1]);\n    for(i = 1; i <= count; i++){\n        if(st_thread_create(do_calc, (void*)i, 0, 0) == NULL){\n            printf(\"st_thread_create error!\");\n            return -1;\n        }\n    }\n    \n    st_thread_exit(NULL);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Exporter Enabled\nDESCRIPTION: Command to build and start SRS with Prometheus exporter enabled using environment variables.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/exporter.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\nenv SRS_ENV_ONLY=on SRS_EXPORTER_ENABLED=on SRS_LISTEN=1935 \\\n  ./objs/srs -e\n```\n\n----------------------------------------\n\nTITLE: HTTP If-None-Match Header Examples\nDESCRIPTION: Examples showing different valid formats for the If-None-Match header, including single ETag, multiple ETags, and wildcard (*) matching.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_77\n\nLANGUAGE: HTTP\nCODE:\n```\nIf-None-Match: \"xyzzy\"\nIf-None-Match: W/\"xyzzy\"\nIf-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\"\nIf-None-Match: *\n```\n\n----------------------------------------\n\nTITLE: Tracking Additional Client Connection on Edge Server\nDESCRIPTION: Uses grep to examine session ID 110 on the edge server, which represents a Flash player client connecting to the stream. Shows connection details, buffer settings, and stream metadata.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ grep --color -ina \"\\[110\\]\" objs/srs.log\n40:[2014-08-06 10:09:36.609][trace][22314][110] RTMP client ip=192.168.1.179\n41:[2014-08-06 10:09:36.613][trace][22314][110] complex handshake success\n42:[2014-08-06 10:09:36.613][trace][22314][110] connect app, tcUrl=rtmp://dev:1935/live, pageUrl=http://www.ossrs.net/players/srs_player.html?vhost=dev&stream=livestream&server=dev&port=1935, swfUrl=http://www.ossrs.net/players/srs_player/release/srs_player.swf?_version=1.23, schema=rtmp, vhost=__defaultVhost__, port=1935, app=live, args=null\n43:[2014-08-06 10:09:36.835][trace][22314][110] ignored. set buffer length to 800\n44:[2014-08-06 10:09:36.853][trace][22314][110] client identified, type=Play, stream_name=livestream, duration=-1.00\n45:[2014-08-06 10:09:36.853][trace][22314][110] out chunk size to 60000\n46:[2014-08-06 10:09:36.853][trace][22314][110] source url=__defaultVhost__/live/livestream, ip=192.168.1.179, cache=1, is_edge=1, source_id=108[108]\n47:[2014-08-06 10:09:36.853][trace][22314][110] dispatch cached gop success. count=95, duration=1573\n48:[2014-08-06 10:09:36.853][trace][22314][110] create consumer, queue_size=30.00, tba=44100, tbv=25\n49:[2014-08-06 10:09:36.853][trace][22314][110] ignored. set buffer length to 800\n51:[2014-08-06 10:09:45.919][trace][22314][110] -> PLA time=8759, msgs=21, okbps=461,0,0, ikbps=3,0,0\n52:[2014-08-06 10:09:46.247][warn][22314][110][104] client disconnect peer. ret=1004\n```\n\n----------------------------------------\n\nTITLE: Using Cache-Control with Community Extension Example\nDESCRIPTION: Example showing how to use a hypothetical cache-control extension 'community' as a modifier to the private directive, allowing a specific community to use an otherwise private response in their shared caches.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_57\n\nLANGUAGE: plaintext\nCODE:\n```\nCache-Control: private, community=\"UCI\"\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback on_ocr Event JSON Format\nDESCRIPTION: Shows the JSON format for the on_ocr event in HTTP callbacks, including request and response structures with OCR results.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_10\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"d13a0e60-e2fe-42cd-a8d8-f04c7e71b5f5\",\n  \"action\": \"on_ocr\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"uuid\": \"824b96f9-8d51-4046-ba1e-a9aec7d57c95\",\n  \"prompt\": \"What is in the image?\",\n  \"result\": \"The image shows a scene featuring a character from a film, likely set in a military or high-tech environment.\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Playing SRT Stream using FFplay\nDESCRIPTION: Command to play an SRT stream from SRS using FFplay.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffplay 'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=request'\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Content Coding Values using ABNF\nDESCRIPTION: Defines the syntax for content coding values used in the Content-Encoding header field in HTTP/1.0. It specifies 'x-gzip' and 'x-compress' as defined values, representing specific compression formats, and allows for other tokens. This definition is from RFC 1945, Section 3.5.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_10\n\nLANGUAGE: abnf\nCODE:\n```\n    content-coding = \"x-gzip\" | \"x-compress\" | token\n```\n\n----------------------------------------\n\nTITLE: Listing Transcoder-Generated Snapshot Files\nDESCRIPTION: Command to list the thumbnail PNG files generated by the transcoder-based snapshot process. Shows the file sizes and timestamps of the six PNG images created.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nwinlin:srs winlin$ ls -lh objs/nginx/html/live/*.png\n-rw-r--r--  1 winlin  staff   265K Oct 20 14:52 livestream-001.png\n-rw-r--r--  1 winlin  staff   265K Oct 20 14:52 livestream-002.png\n-rw-r--r--  1 winlin  staff   287K Oct 20 14:52 livestream-003.png\n-rw-r--r--  1 winlin  staff   235K Oct 20 14:52 livestream-004.png\n-rw-r--r--  1 winlin  staff   315K Oct 20 14:52 livestream-005.png\n-rw-r--r--  1 winlin  staff   405K Oct 20 14:52 livestream-006.png\n```\n\n----------------------------------------\n\nTITLE: Linking to External Images Using Markdown\nDESCRIPTION: Demonstrates how to embed external images using absolute URLs. The example shows linking to a PNG image from the img directory on the ossrs.io domain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n![](https://ossrs.io/lts/en-us/img/SRS-SingleNode-4.0-hd.png)\n```\n\n----------------------------------------\n\nTITLE: Implementing Shared Resource Template Class in C++\nDESCRIPTION: Implementation of a shared resource class that implements ISrsResource interface and uses SrsSharedPtr internally for resource management.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate<typename T>\nclass SrsSharedResource : public ISrsResource\n{\nprivate:\n    SrsSharedPtr<T> ptr_;\n```\n\n----------------------------------------\n\nTITLE: Defining Lists with Hash (#) in Augmented BNF\nDESCRIPTION: Introduces the '#' construct in augmented BNF for defining lists of elements separated by one or more commas. The form '<l>#<m>element' indicates at least 'l' and at most 'm' elements. Null elements are permitted but don't count towards the total. The default range is 0 to infinity. '1#element' simplifies the common list form '(element *(',' element))'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_5\n\nLANGUAGE: abnf\nCODE:\n```\n<l>#<m>element\n```\n\nLANGUAGE: abnf\nCODE:\n```\n(element *( \",\" element))\n```\n\nLANGUAGE: abnf\nCODE:\n```\n1#element\n```\n\nLANGUAGE: abnf\nCODE:\n```\n#(element)\n```\n\nLANGUAGE: abnf\nCODE:\n```\n1#2element\n```\n\nLANGUAGE: abnf\nCODE:\n```\n(element),,(element)\n```\n\n----------------------------------------\n\nTITLE: HTTP OPTIONS Method Implementation\nDESCRIPTION: Explains the OPTIONS method implementation for retrieving communication options available on the request/response chain. The method allows clients to determine server capabilities without initiating resource actions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_40\n\nLANGUAGE: http\nCODE:\n```\nOPTIONS * HTTP/1.1\\nHost: server.example.com\n```\n\n----------------------------------------\n\nTITLE: Example of Non-Standard Subdomain Specification Syntax\nDESCRIPTION: An example of a subdomain using a different parsing sequence for local-part than for domain, demonstrating variation in email address formats.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_36\n\nLANGUAGE: plain text\nCODE:\n```\nsub-net.mailbox@sub-domain.domain\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-forward.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Status-Line Format in BNF\nDESCRIPTION: Specification of the Status-Line format for HTTP/1.0 responses, showing the protocol version, status code, and reason phrase components.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_22\n\nLANGUAGE: BNF\nCODE:\n```\nStatus-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n```\n\n----------------------------------------\n\nTITLE: Multilingual Translator Prompt for GPT AI Assistant\nDESCRIPTION: A text prompt configuration to transform the GPT AI assistant into a language translator. This prompt instructs the AI to translate conversations between English and Chinese in a conversational tone.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-01-31-Browser-Voice-Driven-GPT.md#2025-04-23_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nI want you to act as a language translator.\nI want you to translate my text in conversational tone.\nI want you to strictly translate to English and Chinese.\nKeep in mind that you must translate to English and Chinese.\nRemember, never answer questions but only translate.\n```\n\n----------------------------------------\n\nTITLE: Querying SRS API Versions Endpoint - Bash (curl usage)\nDESCRIPTION: This snippet demonstrates using curl to fetch the SRS server version information from the /api/v1/versions endpoint. The output is JSON-formatted with fields for major, minor, revision, and version string. The endpoint must be active and reachable. Useful for diagnostics or client logic depending on versioning.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n# curl http://192.168.1.102:1985/api/v1/versions\\n        \"major\": 0,\\n        \"minor\": 9,\\n        \"revision\": 43,\\n        \"version\": \"0.9.43\"\\n```\n```\n\n----------------------------------------\n\nTITLE: Publishing Stream Loop Script\nDESCRIPTION: Bash script to continuously publish a video stream to the origin server using FFmpeg\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/reuse-port.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n    -c copy \\\n    -f flv rtmp://192.168.1.170/live/livestream; \\\n    sleep 1; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Example Date Header Usage\nDESCRIPTION: Demonstrates how the Date header is formatted in an HTTP message, using the RFC 1123 date format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_68\n\nLANGUAGE: HTTP\nCODE:\n```\nDate: Tue, 15 Nov 1994 08:12:31 GMT\n```\n\n----------------------------------------\n\nTITLE: Example HTTP Callback Event Log - Text\nDESCRIPTION: This is an example of what the business (callback) server will log when it receives an HTTP callback from SRS. The log displays key action parameters, such as client_id, IP, vhost, stream name, and query parameters. This output helps developers verify that callbacks are being received and provides information useful for debugging and authentication workflows.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nGot action=on_publish, client_id=3y1tcaw2, ip=127.0.0.1, vhost=__defaultVhost__, stream=livestream, param=?k=v\n```\n\n----------------------------------------\n\nTITLE: Defining the EXT-X-MEDIA-SEQUENCE Tag in M3U8 Media Playlists\nDESCRIPTION: Specifies the format of the EXT-X-MEDIA-SEQUENCE tag, indicating the sequence number ('number') of the first media segment appearing in the playlist file. Each subsequent segment implicitly increments this number. The sequence number MUST NOT decrease. A Media Playlist MUST NOT contain more than one such tag; if absent, the sequence number of the first segment is considered 0. This tag MUST NOT appear in a Master Playlist.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_5\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-MEDIA-SEQUENCE:<number>\n```\n\n----------------------------------------\n\nTITLE: Defining Allow Header Syntax in HTTP/1.0\nDESCRIPTION: Shows the syntax definition for the Allow HTTP header field which lists methods supported by a resource. It specifies how the header should be constructed and includes an example of usage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_29\n\nLANGUAGE: http\nCODE:\n```\nAllow          = \"Allow\" \":\" 1#method\n\nExample of use:\n\n   Allow: GET, HEAD\n```\n\n----------------------------------------\n\nTITLE: Language Tag Syntax Definition in ABNF\nDESCRIPTION: Specifies the format for language tags used in Accept-Language and Content-Language fields, following RFC 1766 specifications.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_18\n\nLANGUAGE: abnf\nCODE:\n```\nlanguage-tag  = primary-tag *( \"-\" subtag )\nprimary-tag   = 1*8ALPHA\nsubtag        = 1*8ALPHA\n```\n\n----------------------------------------\n\nTITLE: Defining the EXTM3U Tag in M3U8\nDESCRIPTION: Specifies the format of the EXTM3U tag. This tag distinguishes an Extended M3U file from a basic M3U file and MUST be the very first line in both Media Playlists and Master Playlists.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_1\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n```\n\n----------------------------------------\n\nTITLE: Retrieving HLS Video Codec Configuration in C++\nDESCRIPTION: This snippet defines a method to retrieve the HLS video codec configuration for a given virtual host. It uses a static default value and checks a configuration directive.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/performance.md#2025-04-23_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nstring SrsConfig::get_hls_vcodec(string vhost) {\n    SRS_STATIC string DEFAULT = \"h264\";\n    SrsConfDirective* conf = get_hls(vhost);\n    if (!conf) {\n        return DEFAULT;\n```\n\n----------------------------------------\n\nTITLE: Defining EXT-X-DISCONTINUITY-SEQUENCE Tag in HLS Media Playlist\nDESCRIPTION: Specifies the format of the EXT-X-DISCONTINUITY-SEQUENCE tag used in HLS media playlists for synchronization between different renditions or variant streams. It must appear before any EXT-X-DISCONTINUITY tag and is not allowed in VOD or EVENT playlists.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_14\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-DISCONTINUITY-SEQUENCE:<number>\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP/1.1 Version Format in ABNF\nDESCRIPTION: Specifies the syntax for HTTP version numbers, using the major.minor numbering scheme to indicate protocol versions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_5\n\nLANGUAGE: ABNF\nCODE:\n```\nHTTP-Version   = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n```\n\n----------------------------------------\n\nTITLE: HTTP If-Match Header Examples\nDESCRIPTION: Examples of If-Match header field usage showing different ways to specify entity tags for conditional requests.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_75\n\nLANGUAGE: http\nCODE:\n```\nIf-Match: \"xyzzy\"\nIf-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\"\nIf-Match: *\n```\n\n----------------------------------------\n\nTITLE: Accept-Encoding Header Syntax in BNF\nDESCRIPTION: BNF syntax definition for the Accept-Encoding header that specifies acceptable content encodings for the response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_50\n\nLANGUAGE: BNF\nCODE:\n```\nAccept-Encoding  = \"Accept-Encoding\" \":\"\n                          1#( codings [ \";\" \"q\" \"=\" qvalue ] )\ncodings          = ( content-coding | \"*\" )\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Compiled ARMv7 SRS in Docker\nDESCRIPTION: Runs the cross-compiled ARMv7 SRS binary inside an `armv7/armhf-ubuntu` Docker container. It mounts the host's SRS directory containing the compiled binary, maps the standard SRS ports, and starts the server using the console configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/arm.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 armv7/armhf-ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Using Content-Type Header in HTTP/1.0\nDESCRIPTION: Example of the Content-Type entity-header field that indicates the media type of the Entity-Body sent to the recipient. This header is essential for clients to properly interpret the received content.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_33\n\nLANGUAGE: plaintext\nCODE:\n```\nContent-Type: text/html\n```\n\n----------------------------------------\n\nTITLE: Example ETag Header Usage\nDESCRIPTION: Shows examples of how the ETag header can be formatted in HTTP responses, including strong and weak entity tags.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_70\n\nLANGUAGE: HTTP\nCODE:\n```\nETag: \"xyzzy\"\nETag: W/\"xyzzy\"\nETag: \"\"\n```\n\n----------------------------------------\n\nTITLE: Defining Repetition with Asterisk in Augmented BNF\nDESCRIPTION: Details the use of the asterisk ('*') prefix in augmented BNF to indicate repetition of an element. The full form '<l>*<m>element' specifies at least 'l' and at most 'm' occurrences. Defaults are 0 and infinity, so '*(element)' allows zero or more, '1*element' requires at least one, and '1*2element' allows one or two.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_2\n\nLANGUAGE: abnf\nCODE:\n```\n<l>*<m>element\n```\n\nLANGUAGE: abnf\nCODE:\n```\n*(element)\n```\n\nLANGUAGE: abnf\nCODE:\n```\n1*element\n```\n\nLANGUAGE: abnf\nCODE:\n```\n1*2element\n```\n\n----------------------------------------\n\nTITLE: DASH-Enabled SRS Configuration File - Bash\nDESCRIPTION: This snippet is a sample SRS configuration file (typically saved as conf/dash.conf) with DASH delivery enabled. It configures SRS to listen for RTMP input on port 1935, enables HTTP server output for DASH fragments on port 8080, and sets up the vhost and DASH parameters including fragment duration, update periods, and output paths. No computational output is expected; the file is declarative and must be referenced when starting SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-dash.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/dash.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\nvhost __defaultVhost__ {\n    dash {\n        enabled         on;\n        dash_fragment       30;\n        dash_update_period  150;\n        dash_timeshift      300;\n        dash_path           ./objs/nginx/html;\n        dash_mpd_file       [app]/[stream].mpd;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Configuration for DVR Events\nDESCRIPTION: Configuration example showing how to set up HTTP callbacks for DVR events, which allows external systems to be notified when DVR files are created or closed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/dvr.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    dvr {\n        enabled             on;\n        dvr_path            ./objs/nginx/html/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        dvr_plan            segment;\n        dvr_duration        30;\n        dvr_wait_keyframe   on;\n    }\n    http_hooks {\n        enabled         on;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Live Streaming Architecture using ASCII Art\nDESCRIPTION: This ASCII diagram illustrates the basic components of a live streaming setup, showing the flow from encoder through CDN to player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/client-sdk.md#2025-04-23_snippet_0\n\nLANGUAGE: ascii\nCODE:\n```\n+---------+      +-----------------+       +---------+\n| Encoder +-->---+ SRS/CDN Network +--->---+ Player  |\n+---------+      +-----------------+       +---------+\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source (Bash)\nDESCRIPTION: Configures the build environment using the `./configure` script and then compiles the SRS source code using `make`. This should be run from the `srs/trunk` directory after cloning or updating the code. Requires build tools like make and a C++ compiler.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Stopping SRS Service\nDESCRIPTION: Command to stop the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/service.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs stop\n```\n\n----------------------------------------\n\nTITLE: Configuring Logrotate for SRS with CopyTruncate - Conf\nDESCRIPTION: This snippet configures logrotate for SRS with the 'copytruncate' method, which copies and truncates the log file in-place during rotation (used for older SRS versions or systems not supporting USR1). Includes options for daily rotation, date extensions, compression, retention, and maximum size, but omits process signaling. Prerequisites: logrotate utility, proper log path, and understanding of possible log loss risk. Input is the tail log file; output is archived logs with possible truncation race conditions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/log-rotate.md#2025-04-23_snippet_4\n\nLANGUAGE: conf\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    copytruncate\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: Basic FFmpeg Command for Subtitle Overlay\nDESCRIPTION: Template for FFmpeg command to overlay subtitles on a video stream with placeholder parameters for video and audio codecs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg \\\n    -i input.ts -vf '{subtitles}' \\\n    -c:v libx264 \\ # Video codec and its parameters\n    -c:a aac \\ # Audio codec and its parameters\n    -copyts -y output.ts\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Header Field Format\nDESCRIPTION: Specifies the format for HTTP header fields including field names, values and content structure.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_17\n\nLANGUAGE: http\nCODE:\n```\nHTTP-header    = field-name \":\" [ field-value ] CRLF\n\nfield-name     = token\nfield-value    = *( field-content | LWS )\n\nfield-content  = <the OCTETs making up the field-value\n                        and consisting of either *TEXT or combinations\n                        of token, tspecials, and quoted-string>\n```\n\n----------------------------------------\n\nTITLE: Checking Open File Descriptor Limit using ulimit in Bash\nDESCRIPTION: This command uses `ulimit -n` to display the current shell's limit on the number of open file descriptors. Ensuring this limit is sufficiently high (e.g., 10240 as shown) is important for servers like SRS that handle many concurrent connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Example HDS Playback URL (Text)\nDESCRIPTION: This is an example URL pointing to an HDS manifest file (.f4m). HDS-compatible players, such as VLC or OSMF-based players, can use this URL to initiate streaming of the content named 'livestream'. The stream is served by an SRS instance located at `ossrs.net` on port 8081.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/delivery-hds.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nhttp://ossrs.net:8081/live/livestream.f4m\n```\n\n----------------------------------------\n\nTITLE: Issue Elimination Notice - Stack Overflow Reference\nDESCRIPTION: Template for redirecting questions to Stack Overflow and Discord, with elimination notice.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/faq.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nPlease ask this question on Stack Overflow using the [#simple-realtime-server tag](https://stackoverflow.com/questions/tagged/simple-realtime-server).\n\nIf want some discussion, here's the [discord](https://discord.gg/yZ4BnPmHAd).\n\nThis issue will be eliminated, see #2716\n```\n\n----------------------------------------\n\nTITLE: Visualizing DVR Workflow in SRS\nDESCRIPTION: A text diagram showing the basic workflow of DVR in SRS, where FFmpeg/OBS publishes RTMP streams to SRS, which then records them to FLV/MP4 files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/dvr.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+------------+            +-------+           +---------------+\n+ FFmpeg/OBS +---RTMP-->--+  SRS  +---DVR-->--+ FLV/MP4 File  +\n+------------+            +-------+           +---------------+\n```\n\n----------------------------------------\n\nTITLE: Visualizing WebRTC Browser-to-Browser Communication\nDESCRIPTION: ASCII diagram showing the signaling and media flow between two browsers using WebRTC.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +----------------+\n+    Browser     +----<--Signaling----->--+    Browser     +\n+ (like Chrome)  +----<----Media----->----+ (like Chrome)  +\n+----------------+                        +----------------+\n```\n\n----------------------------------------\n\nTITLE: Markdown Image Syntax for Tracking Pixel\nDESCRIPTION: Markdown syntax for embedding a tracking pixel image from ossrs.net. The URL includes query parameters likely used for analytics, specifying the site and path.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/tools/demo.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n![](https://ossrs.net/gif/v1/sls.gif?site=ossrs.io&path=/lts/tools/en/v4/demo)\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Authentic Originator Syntax (ABNF-like)\nDESCRIPTION: Specifies the syntax for authenticated originator fields ('From', 'Sender') in RFC 822 using an ABNF-like grammar. It defines how to represent a single author ('From') versus cases with a separate submitter ('Sender') and potentially multiple authors ('From').\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_22\n\nLANGUAGE: abnf\nCODE:\n```\nauthentic   =   \"From\"       \":\"   mailbox  ; Single author\n             / ( \"Sender\"     \":\"   mailbox  ; Actual submittor\n                 \"From\"       \":\" 1#mailbox) ; Multiple authors\n                                             ;  or not sender\n```\n\n----------------------------------------\n\nTITLE: HTTP Header Field Syntax Definitions\nDESCRIPTION: BNF syntax definitions for Max-Forwards, Pragma, and Range header fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_81\n\nLANGUAGE: http\nCODE:\n```\nMax-Forwards   = \"Max-Forwards\" \":\" 1*DIGIT\n\nPragma            = \"Pragma\" \":\" 1#pragma-directive\npragma-directive  = \"no-cache\" | extension-pragma\nextension-pragma  = token [ \"=\" ( token | quoted-string ) ]\n\nranges-specifier = byte-ranges-specifier\nbyte-ranges-specifier = bytes-unit \"=\" byte-range-set\nbyte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )\nbyte-range-spec = first-byte-pos \"-\" [last-byte-pos]\nfirst-byte-pos  = 1*DIGIT\nlast-byte-pos   = 1*DIGIT\nsuffix-byte-range-spec = \"-\" suffix-length\nsuffix-length = 1*DIGIT\n```\n\n----------------------------------------\n\nTITLE: Pushing updates to PR branch as a TOC member\nDESCRIPTION: Command for TOC members to push updates to the contributor's fork after making changes. This automatically updates the PR with the TOC member's changes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit push tmp bugfix/fix-srt-url\n```\n\n----------------------------------------\n\nTITLE: Defining Lexical Tokens for ARPA Internet Messages in ABNF\nDESCRIPTION: Specifies the basic lexical tokens used in the ARPA Internet message format, including character sets, special characters, whitespace handling, and syntax elements for email parsing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_13\n\nLANGUAGE: ABNF\nCODE:\n```\nCHAR        =  <any ASCII character>        ; (  0-177,  0.-127.)\nALPHA       =  <any ASCII alphabetic character>\n                                             ; (101-132, 65.- 90.)\n                                             ; (141-172, 97.-122.)\nDIGIT       =  <any ASCII decimal digit>    ; ( 60- 71, 48.- 57.)\nCTL         =  <any ASCII control           ; (  0- 37,  0.- 31.)\n                 character and DEL>          ; (    177,     127.)\nCR          =  <ASCII CR, carriage return>  ; (     15,      13.)\nLF          =  <ASCII LF, linefeed>         ; (     12,      10.)\nSPACE       =  <ASCII SP, space>            ; (     40,      32.)\nHTAB        =  <ASCII HT, horizontal-tab>   ; (     11,       9.)\n<\">         =  <ASCII quote mark>           ; (     42,      34.)\nCRLF        =  CR LF\n\nLWSP-char   =  SPACE / HTAB                 ; semantics = SPACE\n\nlinear-white-space =  1*([CRLF] LWSP-char)  ; semantics = SPACE\n                                             ; CRLF => folding\n\nspecials    =  \"(\" / \")\" / \"<\" / \">\" / \"@\"  ; Must be in quoted-\n             /  \",\" / \";\" / \":\" / \"\\\" / <\">  ;  string, to use\n             /  \".\" / \"[\" / \"]\"              ;  within a word.\n\ndelimiters  =  specials / linear-white-space / comment\n\ntext        =  <any CHAR, including bare    ; => atoms, specials,\n                 CR & bare LF, but NOT       ;  comments and\n                 including CRLF>             ;  quoted-strings are\n                                             ;  NOT recognized.\n\natom        =  1*<any CHAR except specials, SPACE and CTLs>\n\nquoted-string = <\"> *(qtext/quoted-pair) <\">; Regular qtext or\n                                             ;   quoted chars.\n\nqtext       =  <any CHAR excepting <\">,     ; => may be folded\n                 \"\\\" & CR, and including\n                 linear-white-space>\n\ndomain-literal =  \"[\" *(dtext / quoted-pair) \"]\"\n```\n\n----------------------------------------\n\nTITLE: Referencing the SRS FAQ Documentation\nDESCRIPTION: Code snippet showing how to reference the SRS FAQ documentation in both Chinese and English languages for users who need more information.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-server-en.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSee FAQ:\n* Chinese: https://ossrs.net/lts/zh-cn/faq\n* English: https://ossrs.io/lts/en-us/faq\n```\n\n----------------------------------------\n\nTITLE: HTTP From Header Example\nDESCRIPTION: Example of a From header field containing an email address to identify the human user controlling the requesting user agent.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_73\n\nLANGUAGE: http\nCODE:\n```\nFrom: webmaster@w3.org\n```\n\n----------------------------------------\n\nTITLE: HTTP 206 Partial Content Required Headers\nDESCRIPTION: Demonstrates required header fields for a 206 Partial Content response including Content-Range, Date, ETag/Content-Location, and cache control headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_46\n\nLANGUAGE: http\nCODE:\n```\n206 Partial Content\nContent-Range: bytes 21010-47021/47022\nDate: Tue, 15 Nov 1994 08:12:31 GMT\nETag: \"74ed0f7a102bb2f\"\\nCache-Control: private\n```\n\n----------------------------------------\n\nTITLE: Running the State Threads Example Program\nDESCRIPTION: This bash command runs the compiled example program with 10,000 threads. The output shows the resource usage for both 10,000 and 30,000 threads on a single CPU machine with 512MB of memory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-02-26-State-Threads-for-Internet-Applications.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./huge_threads 10000\n10K report:\n10000 threads, running on 1 CPU 512M machine,\nCPU 6%, MEM 8.2% (~42M = 42991K = 4.3K/thread)\n30K report:\n30000 threads, running on 1CPU 512M machine,\nCPU 3%, MEM 24.3% (4.3K/thread)\n```\n\n----------------------------------------\n\nTITLE: Origin Server Configuration\nDESCRIPTION: Configuration file for the origin SRS server, setting up basic RTMP parameters including listen port, connections limit, and logging.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.conf\nlisten              19350;\nmax_connections     1000;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Resolving Domain Name Using HTTP DNS in Bash\nDESCRIPTION: This code snippet shows how to use curl to make an HTTP request to an HTTP DNS service to resolve a domain name. It demonstrates the concept of HTTP DNS as an alternative to traditional DNS for more controlled name resolution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-05-16-Load-Balancing-Streaming-Servers.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://your-http-dns-service/resolve?domain=ossrs.io\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Status Codes in BNF\nDESCRIPTION: Enumeration of valid HTTP/1.0 status codes and their corresponding reason phrases, showing standard response codes from 200-503.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_24\n\nLANGUAGE: BNF\nCODE:\n```\nStatus-Code    = \"200\"   ; OK\n                      | \"201\"   ; Created\n                      | \"202\"   ; Accepted\n                      | \"204\"   ; No Content\n                      | \"301\"   ; Moved Permanently\n                      | \"302\"   ; Moved Temporarily\n                      | \"304\"   ; Not Modified\n                      | \"400\"   ; Bad Request\n                      | \"401\"   ; Unauthorized\n                      | \"403\"   ; Forbidden\n                      | \"404\"   ; Not Found\n                      | \"500\"   ; Internal Server Error\n                      | \"501\"   ; Not Implemented\n                      | \"502\"   ; Bad Gateway\n                      | \"503\"   ; Service Unavailable\n                      | extension-code\n\nextension-code = 3DIGIT\n\nReason-Phrase  = *<TEXT, excluding CR, LF>\n```\n\n----------------------------------------\n\nTITLE: Setting Connection Limit on Linux\nDESCRIPTION: Commands to set and verify the connection limit on Linux for testing high connection loads.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nulimit -HSn 10240\n```\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 ~]# ulimit -n\n10240\n```\n\n----------------------------------------\n\nTITLE: Accept-Charset Header Syntax in BNF\nDESCRIPTION: BNF syntax definition for the Accept-Charset header that indicates acceptable character sets for the response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_49\n\nLANGUAGE: BNF\nCODE:\n```\nAccept-Charset = \"Accept-Charset\" \":\"\n              1#( ( charset | \"*\" )[ \";\" \"q\" \"=\" qvalue ] )\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP General Header Fields in BNF\nDESCRIPTION: BNF grammar specification listing all valid general-header fields in HTTP/1.1 with their corresponding specification sections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_23\n\nLANGUAGE: BNF\nCODE:\n```\ngeneral-header = Cache-Control            ; Section 14.9\n               | Connection               ; Section 14.10\n               | Date                     ; Section 14.18\n               | Pragma                   ; Section 14.32\n               | Trailer                  ; Section 14.40\n               | Transfer-Encoding        ; Section 14.41\n               | Upgrade                  ; Section 14.42\n               | Via                      ; Section 14.45\n               | Warning                  ; Section 14.46\n```\n\n----------------------------------------\n\nTITLE: Verifying Nginx Listening Port (Bash)\nDESCRIPTION: Uses `netstat` to check if the Nginx process is successfully listening on the configured RTMP port (19350). It filters for TCP connections in the LISTEN state associated with the specified port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n[root@dev6 nginx-rtmp]# netstat -anp|grep 19350\ntcp        0      0 0.0.0.0:19350               0.0.0.0:*                   LISTEN      6486/nginx\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Response Header Fields in BNF\nDESCRIPTION: Specification of standard HTTP/1.0 response header fields that provide additional information about the server and the response.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_25\n\nLANGUAGE: BNF\nCODE:\n```\nResponse-Header = Location                ; Section 10.11\n                       | Server                  ; Section 10.14\n                       | WWW-Authenticate        ; Section 10.16\n```\n\n----------------------------------------\n\nTITLE: Using Date Header in HTTP/1.0\nDESCRIPTION: Example of the Date general-header field that represents when the message was originated. This field is important for evaluating cached responses and should always be included by origin servers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_34\n\nLANGUAGE: plaintext\nCODE:\n```\nDate: Tue, 15 Nov 1994 08:12:31 GMT\n```\n\n----------------------------------------\n\nTITLE: Configuring HLS Segment Reap Based on Keyframes\nDESCRIPTION: Determines whether SRS waits for a keyframe before creating (reaping) a new HLS segment. If 'on' (default), a segment is created only when its duration exceeds `hls_fragment` AND a keyframe is received. If 'off', the segment is created as soon as the duration exceeds `hls_fragment`, regardless of keyframes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/special-control.md#2025-04-23_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n```\nvhost __defaultVhost__ {\n    hls {\n        # whether wait keyframe to reap segment,\n        # if off, reap segment when duration exceed the fragment,\n        # if on, reap segment when duration exceed and got keyframe.\n        # default: on\n        hls_wait_keyframe       on;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Connection Close Header in HTTP/1.1\nDESCRIPTION: Example showing how to use the 'close' connection option in the Connection header field to signal that the connection should not be considered persistent after the current request/response is complete.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_58\n\nLANGUAGE: plaintext\nCODE:\n```\nConnection: close\n```\n\n----------------------------------------\n\nTITLE: Example HTTP GET Request URIs\nDESCRIPTION: Demonstrates proper formatting of GET requests for both proxy and direct server requests.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_20\n\nLANGUAGE: http\nCODE:\n```\nGET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.0\n\nGET /pub/WWW/TheProject.html HTTP/1.0\n```\n\n----------------------------------------\n\nTITLE: Defining Overall HTTP Message Structure using ABNF\nDESCRIPTION: Defines the top-level structure of an HTTP message according to RFC 1945 (Section 4.1). It specifies that an HTTP message can be either a simple request/response (characteristic of HTTP/0.9) or a full request/response (used in HTTP/1.0).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_14\n\nLANGUAGE: abnf\nCODE:\n```\n    HTTP-message   = Simple-Request           ; HTTP/0.9 messages\n                   | Simple-Response\n                   | Full-Request             ; HTTP/1.0 messages\n                   | Full-Response\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Character Set Values using ABNF\nDESCRIPTION: Specifies the allowed values for the 'charset' parameter in HTTP/1.0, listing common registered character sets like US-ASCII, ISO-8859 variants, and Unicode encodings, and permitting other IANA-registered tokens. This definition is part of the HTTP/1.0 specification (RFC 1945, Section 3.4).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_9\n\nLANGUAGE: abnf\nCODE:\n```\n  charset = \"US-ASCII\"\n          | \"ISO-8859-1\" | \"ISO-8859-2\" | \"ISO-8859-3\"\n          | \"ISO-8859-4\" | \"ISO-8859-5\" | \"ISO-8859-6\"\n          | \"ISO-8859-7\" | \"ISO-8859-8\" | \"ISO-8859-9\"\n          | \"ISO-2022-JP\" | \"ISO-2022-JP-2\" | \"ISO-2022-KR\"\n          | \"UNICODE-1-1\" | \"UNICODE-1-1-UTF-7\" | \"UNICODE-1-1-UTF-8\"\n          | token\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container with CANDIDATE Environment Variable (Bash)\nDESCRIPTION: This Bash command shows how to run SRS within a Docker container while passing the host's `CANDIDATE` environment variable (previously set, e.g., `export CANDIDATE=\"192.168.3.10\"`) into the container using the `--env CANDIDATE=$CANDIDATE` flag. It also maps necessary ports (1935, 8080, 1985, 8000/udp). This ensures the SRS instance inside Docker uses the correct external IP address for WebRTC candidate advertisement.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.3.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: IP Camera to Platform Streaming Workflow in Bash\nDESCRIPTION: A basic workflow diagram showing the data flow from an IP camera through OBS or Oryx to streaming platforms using RTSP and RTMP/RTMPS protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-10-11-Oryx-Stream-IP-Camera-Events.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nIP Camera ---RTSP---> OBS or Oryx ---RTMP/RTMPS---> YouTube, Twitch, or Facebook\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Configuration parameters for publishing a stream using Adobe Flash Media Live Encoder (FMLE) to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Linux/Unix Hosts File for Local Domain Resolution\nDESCRIPTION: Example of how to modify the /etc/hosts file on Linux/Unix systems to resolve a domain name to the Oryx Server IP address locally. This is useful for testing or internal deployments.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n121.13.75.20 bt.yourdomain.com\n```\n\n----------------------------------------\n\nTITLE: Decoding Chunked Transfer-Encoding in HTTP/1.1\nDESCRIPTION: Pseudo-code implementation for decoding chunked transfer encoding in HTTP/1.1. The algorithm reads chunks of data and reconstructs the complete entity body while tracking length and handling headers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_94\n\nLANGUAGE: pseudocode\nCODE:\n```\nlength := 0\nread chunk-size, chunk-extension (if any) and CRLF\nwhile (chunk-size > 0) {\n   read chunk-data and CRLF\n   append chunk-data to entity-body\n   length := length + chunk-size\n   read chunk-size and CRLF\n}\nread entity-header\nwhile (entity-header not empty) {\n   append entity-header to existing header fields\n   read entity-header\n}\nContent-Length := length\nRemove \"chunked\" from Transfer-Encoding\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Full-Response Format in BNF\nDESCRIPTION: Specification of the Full-Response format structure in HTTP/1.0, showing the components including Status-Line, headers, and optional Entity-Body.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_21\n\nLANGUAGE: BNF\nCODE:\n```\nFull-Response   = Status-Line             ; Section 6.1\n                         *( General-Header       ; Section 4.3\n                          | Response-Header      ; Section 6.2\n                          | Entity-Header )      ; Section 7.1\n                         CRLF\n                         [ Entity-Body ]         ; Section 7.2\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Entity Body Encoding Model in HTTP/1.1\nDESCRIPTION: Specifies the two-layer ordered encoding model for HTTP entity bodies, showing how Content-Encoding and Content-Type work together to define the data type.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_38\n\nLANGUAGE: http\nCODE:\n```\nentity-body := Content-Encoding( Content-Type( data ) )\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Version\nDESCRIPTION: Shows the version of SRS server being tested\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n[winlin@dev6 srs]$ ./objs/srs -v\n0.9.130\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS codebase from GitHub repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-forward.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Defining Authorization Header Syntax in HTTP/1.0\nDESCRIPTION: Shows the syntax definition for the Authorization HTTP header field used by clients to authenticate with a server. This header contains credentials for accessing protected resources.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_30\n\nLANGUAGE: http\nCODE:\n```\nAuthorization  = \"Authorization\" \":\" credentials\n```\n\n----------------------------------------\n\nTITLE: JSON Successful HTTP Callback Response (HTTP)\nDESCRIPTION: Shows an alternative successful HTTP response format for SRS callbacks using JSON. The handler should return an HTTP/1.1 200 OK status, and the response body should be a JSON object containing a 'code' field with the value 0 (`{\"code\": 0}`).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-callback.md#2025-04-23_snippet_8\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 200 OK\nContent-Length: 11\n{\"code\": 0}\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP/1.1 Text and Hexadecimal Character Rules in ABNF\nDESCRIPTION: Defines the TEXT rule for descriptive field contents and the HEX rule for hexadecimal numeric characters used in various protocol elements.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_2\n\nLANGUAGE: ABNF\nCODE:\n```\nTEXT           = <any OCTET except CTLs,\n                but including LWS>\nHEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n              | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n```\n\n----------------------------------------\n\nTITLE: Example of Empty Group Distribution List Format\nDESCRIPTION: The syntax for specifying a named distribution list without including its contents, serving only as an indication of group distribution.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_37\n\nLANGUAGE: plain text\nCODE:\n```\nname:;\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Date Fields Structure (ABNF-like)\nDESCRIPTION: Defines the 'dates' component of RFC 822 headers using an ABNF-like grammar. It requires the original date ('orig-date') and allows for an optional forwarded date ('resent-date').\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_25\n\nLANGUAGE: abnf\nCODE:\n```\ndates       =   orig-date                   ; Original\n               [ resent-date ]               ; Forwarded\n```\n\n----------------------------------------\n\nTITLE: Entity Tag Syntax Definition in ABNF\nDESCRIPTION: Defines the format for entity tags used in HTTP caching and validation mechanisms, including both strong and weak tags.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_19\n\nLANGUAGE: abnf\nCODE:\n```\nentity-tag = [ weak ] opaque-tag\nweak       = \"W/\"\nopaque-tag = quoted-string\n```\n\n----------------------------------------\n\nTITLE: Coroutine-based SRT Publishing\nDESCRIPTION: Implementation of SRT publishing using coroutine-based approach.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-07-01-Coroutine-Native-SRT.md#2025-04-23_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nsrs_error_t SrsMpegtsSrtConn::do_publishing() {\n  while (true) {\n    ssize_t nb = 0;\n    if ((err = srt_conn_->read(buf, sizeof(buf), &nb)) != srs_success) {\n      return srs_error_wrap(err, \"srt: recvmsg\");\n    }\n    \n    if ((err = on_srt_packet(buf, nb)) != srs_success) {\n      return srs_error_wrap(err, \"srt: process packet\");\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Load Testing with srs-bench\nDESCRIPTION: Docker command to run srs-bench for load testing the HLS stream with 100 concurrent connections.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-hls-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_hls_load -c 100 -r http://192.168.1.170:8081/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for WebRTC over TCP\nDESCRIPTION: This configuration snippet shows the detailed settings for enabling and configuring WebRTC over TCP in SRS. It includes options for TCP listening, protocol selection, and candidate generation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    tcp {\n        enabled off;\n        listen 8000;\n    }\n    protocol udp;\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Basic Authentication Challenge Example\nDESCRIPTION: Example of a server challenge header for basic authentication in HTTP/1.0, requesting credentials for the 'WallyWorld' realm.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_38\n\nLANGUAGE: http\nCODE:\n```\nWWW-Authenticate: Basic realm=\"WallyWorld\"\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS for HttpCallback Snapshot\nDESCRIPTION: This configuration sets up SRS to use HTTP callbacks for snapshot functionality. It defines the listeners, hooks, and ingest settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n# snapshot.conf\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    http_hooks {\n        enabled on;\n        on_publish http://127.0.0.1:8085/api/v1/snapshots;\n        on_unpublish http://127.0.0.1:8085/api/v1/snapshots;\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Referer Header Syntax and Example in HTTP/1.1\nDESCRIPTION: Syntax definition and example of the Referer request header in HTTP/1.1, which allows the client to specify the address from which the Request-URI was obtained.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_84\n\nLANGUAGE: http\nCODE:\n```\nReferer        = \"Referer\" \":\" ( absoluteURI | relativeURI )\n\nExample:\n\nReferer: http://www.w3.org/hypertext/DataSources/Overview.html\n```\n\n----------------------------------------\n\nTITLE: Testing Subtitle Styles with FFmpeg\nDESCRIPTION: Complete bash script to test subtitle styling effects using FFmpeg with a sample SRT file and force_style parameter configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\ncat > avatar.srt <<EOF\n1\n00:02:31,199 --> 00:02:37,399\n[Music] Strong pray on the weak. [Music] Nobody does not think. \n[Music] You have got one hour. [Music] You know this would happen?\n\n2\n00:02:37,759 --> 00:02:39,759\nEverything changed [Music]\n\n3\n00:02:39,800 --> 00:02:43,800\nJake it's crazy here the porridge is rolling and there's no stopping him\n\n4\n00:02:44,520 --> 00:02:49,440\nWe're going up against gunships his bows and arrows. I guess we better stop him\nEOF\n\nFORCE_STYLE=\"Fontname=Roboto,Fontsize=12,PrimaryColour=&HFFFFFF,BorderStyle=4,BackColour=&H40000000,Outline=1,OutlineColour=&HFF000000,Alignment=2,MarginV=20\" &&\nffmpeg -i ~/git/srs/trunk/doc/source.flv \\\n    -ss 150 -t 20 -vf \"subtitles=./avatar.srt:force_style='${FORCE_STYLE}'\" \\\n    -c:v libx264 -c:a copy -y output.mp4\n```\n\n----------------------------------------\n\nTITLE: Linking to Documentation from Tutorials Using Markdown\nDESCRIPTION: Demonstrates how to link to documentation pages from tutorial content. The example shows a relative path to a document in the doc directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n[ReusePort](../doc/reuse-port.md)\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Product Token Syntax using ABNF\nDESCRIPTION: Specifies the format for product tokens used in HTTP/1.0 headers like User-Agent and Server to identify applications (RFC 1945, Section 3.7). It consists of a required token (product name) and an optional version identifier preceded by a slash.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_13\n\nLANGUAGE: abnf\nCODE:\n```\n    product         = token [\"/\" product-version]\n    product-version = token\n```\n\n----------------------------------------\n\nTITLE: Verifying File Upload in Docker Container\nDESCRIPTION: Command to check if an uploaded file exists in the Oryx Docker container's data directory\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ndocker exec -it oryx ls -lh /data/my-upload/my-file.mp4\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server in Bash\nDESCRIPTION: Command to start the SRS server using the HTTP and HLS configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.hls.conf\n```\n\n----------------------------------------\n\nTITLE: Copying Video and Transcoding Audio with FFMPEG in SRS (bash)\nDESCRIPTION: This SRS configuration snippet shows how to configure FFMPEG to copy the video stream without transcoding ('vcodec copy;') while transcoding the audio stream to AAC ('acodec libfdk_aac;'). This is useful for scenarios like handling Flash publisher streams (h264+speex) where only audio conversion is needed. Requires SRS and a functional FFMPEG binary.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vcodec          copy;\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for RTC to RTC Relay\nDESCRIPTION: Starts an SRS instance using Docker, configured purely for WebRTC streaming (WHIP ingest, WHEP playback) by loading `conf/rtc.conf`. It requires setting the `CANDIDATE` environment variable with the server's IP and maps standard ports including RTMP (1935), HTTP (8080), HTTP API (1985), and WebRTC over UDP (8000). This setup acts as a WebRTC SFU or relay.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nexport CANDIDATE=\"192.168.1.10\"\ndocker run --rm --env CANDIDATE=$CANDIDATE \\\n  -p 1935:1935 -p 8080:8080 -p 1985:1985 -p 8000:8000/udp \\\n  ossrs/srs:5 \\\n  objs/srs -c conf/rtc.conf\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS GitHub repository to your local machine. This is the first step to get the SRS source code for deployment.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: HDS Configuration in SRS\nDESCRIPTION: Configuration block for HDS delivery in SRS showing all available options. Includes settings for enabling HDS, fragment duration, window size for segments, and the storage path for HDS files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/delivery-hds.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    hds {\n        # whether hds enabled\n        # default: off\n        enabled         on;\n        # the hds fragment in seconds.\n        # default: 10\n        hds_fragment    10;\n        # the hds window in seconds, erase the segment when exceed the window.\n        # default: 60\n        hds_window      60;\n        # the path to store the hds files.\n        # default: ./objs/nginx/html\n        hds_path        ./objs/nginx/html;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting Second Oryx Docker Instance\nDESCRIPTION: Docker command to run a second Oryx instance with different port mappings to avoid conflicts with the first instance\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --restart always -d -it --name oryx1 -it -v $HOME/data1:/data \\\n  -p 2023:2022 -p 1936:1935 -p 8001:8000/udp -p 10081:10080/udp \\\n  ossrs/oryx:5\n```\n\n----------------------------------------\n\nTITLE: Defining Range Request Header Syntax in HTTP/1.1\nDESCRIPTION: Formal syntax definition for the Range request header in HTTP/1.1, used to request one or more sub-ranges of an entity instead of the entire entity.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_83\n\nLANGUAGE: http\nCODE:\n```\nRange = \"Range\" \":\" ranges-specifier\n```\n\n----------------------------------------\n\nTITLE: HTTP Token and Special Character Rules in BNF\nDESCRIPTION: Defines word tokens and special characters used in HTTP/1.0 header fields. These rules establish how words are separated and which characters must be quoted within parameter values.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_3\n\nLANGUAGE: BNF\nCODE:\n```\nword           = token | quoted-string\ntoken          = 1*<any CHAR except CTLs or tspecials>\ntspecials      = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n               | \",\" | \";\" | \":\" | \"\\\\\" | <\">\n               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n               | \"{\" | \"}\" | SP | HT\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code in Bash\nDESCRIPTION: This command updates an existing SRS codebase by pulling the latest changes from the repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ingest.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code\nDESCRIPTION: Command to update an existing SRS codebase using Git.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-dash.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Specifying Content-Encoding HTTP Header\nDESCRIPTION: Example of using the Content-Encoding HTTP header to indicate that gzip compression has been applied to the entity body. This header informs the recipient that it must decompress the content using gzip before processing.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_59\n\nLANGUAGE: http\nCODE:\n```\nContent-Encoding: gzip\n```\n\n----------------------------------------\n\nTITLE: WebRTC SFU Server Communication Diagram\nDESCRIPTION: ASCII diagram showing WebRTC communication through an SFU (Selective Forwarding Unit) server\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +---------+\n+    Browser     +----<--Signaling----->--+   SFU   +\n+ (like Chrome)  +----<----Media----->----+  Server +\n+----------------+                        +---------+\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server\nDESCRIPTION: Configuration file for the SRS origin server, specifying listening port, connections limit, and log file location.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-rtmp-cluster.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/origin.conf\nlisten              19350;\nmax_connections     1000;\npid                 objs/origin.pid;\nsrs_log_file        ./objs/origin.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Running SRS with Console Configuration\nDESCRIPTION: Command to run the compiled SRS binary with a console configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: OSMF HDS Playback URL Example - Plaintext\nDESCRIPTION: This URL example demonstrates how to point the OSMF player at an HDS stream produced by SRS. It should be pasted into the OSMF player's input or configuration interface. The stream location is the expected output from a correctly configured SRS with HDS enabled; the output is a live manifest for compatible HDS players.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/delivery-hds.md#2025-04-23_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nhttp://ossrs.net:8081/live/livestream.f4m\n```\n\n----------------------------------------\n\nTITLE: Markdown Frontmatter Configuration\nDESCRIPTION: YAML frontmatter configuration for the documentation page, setting display options like title, sidebar label, and table of contents visibility.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/delivery-http-flv.md#2025-04-23_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: HTTP-FLV Delivery\nsidebar_label: HTTP-FLV Delivery\nhide_title: false\nhide_table_of_contents: false\n---\n```\n\n----------------------------------------\n\nTITLE: Installing ARM64 Cross-Compilation Tools\nDESCRIPTION: Command to install the necessary toolchain for cross-compiling to ARMv8/aarch64 architecture on an Ubuntu system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\napt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Linking to Static Resources in Documentation Using Markdown\nDESCRIPTION: Demonstrates how to link to static files within the documentation. The example shows linking to a PDF file from the /files directory with a description following the link.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n[amf0_spec_121207.pdf](/files/amf0_spec_121207.pdf), adobe amf0\n```\n\n----------------------------------------\n\nTITLE: Defining Content-Range Header in HTTP/1.1\nDESCRIPTION: Specifies the syntax and usage of the Content-Range entity-header in HTTP/1.1. This header is used with partial entity-bodies to indicate where in the full entity-body the partial body should be applied.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_63\n\nLANGUAGE: HTTP\nCODE:\n```\nContent-Range = \"Content-Range\" \":\" content-range-spec\n\ncontent-range-spec      = byte-content-range-spec\nbyte-content-range-spec = bytes-unit SP\n                         byte-range-resp-spec \"/\"\n                         ( instance-length | \"*\" )\n\nbyte-range-resp-spec = (first-byte-pos \"-\" last-byte-pos)\n                              | \"*\"\ninstance-length           = 1*DIGIT\n```\n\n----------------------------------------\n\nTITLE: HTTP Comment and Quoted String Rules in BNF\nDESCRIPTION: Defines rules for comments and quoted strings in HTTP/1.0 headers. Comments can only appear in fields that explicitly allow them, while quoted strings are parsed as single words.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_4\n\nLANGUAGE: BNF\nCODE:\n```\ncomment        = \"(\" *( ctext | comment ) \")\"\nctext          = <any TEXT excluding \"(\" and \")\">\nquoted-string  = ( <\"> *(qdtext) <\"> )\nqdtext         = <any CHAR except <\"> and CTLs,\n                 but including LWS>\n```\n\n----------------------------------------\n\nTITLE: Applying YouTube-Style Subtitles\nDESCRIPTION: Configures subtitles with YouTube-like styling including font, size, color, and positioning using the Roboto font.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_17\n\nLANGUAGE: text\nCODE:\n```\nFontname=Roboto,Fontsize=12,PrimaryColour=&HFFFFFF,BorderStyle=4,BackColour=&H40000000,Outline=1,OutlineColour=&HFF000000,Alignment=2,MarginV=20\n```\n\n----------------------------------------\n\nTITLE: Building SRS with FFMPEG Support\nDESCRIPTION: Command to configure and build SRS with FFMPEG transcoding support enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: Example OPTIONS Request to Server\nDESCRIPTION: Shows an example of an OPTIONS request with '*' as the Request-URI, indicating the request applies to the server itself rather than a specific resource.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_28\n\nLANGUAGE: text\nCODE:\n```\nOPTIONS * HTTP/1.1\n```\n\n----------------------------------------\n\nTITLE: Publishing Multiple Streams to HLS Origins\nDESCRIPTION: FFmpeg commands to publish multiple streams to load-balanced origin servers\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/reuse-port.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream1\n```\n\nLANGUAGE: bash\nCODE:\n```\n./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream2\n```\n\n----------------------------------------\n\nTITLE: Listing S3 Bucket Contents in Bash\nDESCRIPTION: This command lists the contents of an S3 bucket mounted to a local directory using s3fs. It's used to verify successful mounting and access to S3 storage.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nls -lh /data/srs-s3-bucket\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Force Style Example for Basic Subtitle Positioning\nDESCRIPTION: Example subtitle style configuration for FFmpeg that sets alignment to bottom center and adds a bottom margin of 20px. This can be used for AI transcript styling in Oryx.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nAlignment=2,MarginV=20\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Resent (Forwarding) Fields Structure (ABNF-like)\nDESCRIPTION: Defines the structure for 'Resent-' prefixed fields used for message forwarding in RFC 822, using an ABNF-like grammar. It includes authenticated forwarder information ('resent-authentic') and an optional 'Resent-Reply-To' field.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_23\n\nLANGUAGE: abnf\nCODE:\n```\nresent      =   resent-authentic\n               [ \"Resent-Reply-To\"  \":\" 1#address] )\n```\n\n----------------------------------------\n\nTITLE: Checking out PR branch as a TOC member\nDESCRIPTION: Command for TOC members to switch to the PR branch after fetching it. This allows them to work on and update the PR branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/how-to-file-pr-en.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout bugfix/fix-srt-url\n```\n\n----------------------------------------\n\nTITLE: Custom Named Stream Configuration\nDESCRIPTION: Example URLs demonstrating the use of a custom stream name 'the-10-years-anually-for-you'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2023-08-29-Oryx-Ensuring-Authentication-for-Live-Streaming-Publishing.md#2025-04-23_snippet_3\n\nLANGUAGE: url\nCODE:\n```\nrtmp://135.98.31.15/live/the-10-years-anually-for-you?secret=5181a08ee6eab86597e913e1f9e4c294\nhttp://135.98.31.15/live/the-10-years-anually-for-you.m3u8\n```\n\n----------------------------------------\n\nTITLE: Cloning and Navigating SRS Codebase with Git - Bash\nDESCRIPTION: This snippet obtains the latest SRS server source code using git and changes the current directory to the trunk where the main source resides. It requires Bash and Git to be installed. The output is a local 'srs' folder ready for subsequent build steps.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Updating SRS Repository\nDESCRIPTION: Command to update existing SRS codebase using git pull.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Building and Using Google CPU Profiler (GCP) with SRS\nDESCRIPTION: Commands to build SRS with Google CPU Profiler, run it, and analyze the CPU profile. GCP helps identify CPU usage patterns and performance bottlenecks.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Build SRS with GCP\n./configure --gperf=on --gcp=on && make\n\n# Start SRS with GCP\n./objs/srs -c conf/console.conf\n\n# Or CTRL+C to stop GCP\nkillall -2 srs\n\n# To analysis cpu profile\n./objs/pprof --text objs/srs gperf.srs.gcp*\n```\n\n----------------------------------------\n\nTITLE: Checking Pod Status During Rolling Update (Bash)\nDESCRIPTION: This command uses `kubectl get po` filtered by 'edge' to display the status of the SRS Edge pods during the rolling update process. The output shows the old pod (`srs-edge-deploy-58d9999b7c-z9gbm`) in the 'Terminating' state while the new pods with the updated image (`srs-edge-deploy-76fcbfb848-*`) are starting up and becoming 'Running'.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/k8s.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get po |grep edge\nNAME                                   READY   STATUS        RESTARTS   AGE\nsrs-edge-deploy-58d9999b7c-z9gbm       0/1     Terminating   0          3m52s\nsrs-edge-deploy-76fcbfb848-z5rmn       1/1     Running       0          104s\nsrs-edge-deploy-76fcbfb848-zt4wv       1/1     Running       0          106s\n```\n\n----------------------------------------\n\nTITLE: Configuring Referer Anti-Theft Link Protection in SRS\nDESCRIPTION: This configuration demonstrates how to set up Referer anti-theft link protection in SRS. It shows how to enable the feature and specify allowed referrers for both publishing and playing streams, limiting access to clients coming from specified domains like github.com and github.io.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/drm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# the vhost for anti-suck.\nvhost refer.anti_suck.com {\n    # refer hotlink-denial.\n    refer {\n        # whether enable the refer hotlink-denial.\n        # default: off.\n        enabled         on;\n        # the common refer for play and publish.\n        # if the page url of client not in the refer, access denied.\n        # if not specified this field, allow all.\n        # default: not specified.\n        all           github.com github.io;\n        # refer for publish clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        publish   github.com github.io;\n        # refer for play clients specified.\n        # the common refer is not overrided by this.\n        # if not specified this field, allow all.\n        # default: not specified.\n        play      github.com github.io;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Force Style Example for YouTube-like Subtitles\nDESCRIPTION: Complex subtitle style configuration that mimics YouTube's subtitle appearance with Roboto font, white text, outline, semi-transparent background, and bottom positioning.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-zh.md#2025-04-23_snippet_12\n\nLANGUAGE: text\nCODE:\n```\nFontname=Roboto,Fontsize=12,PrimaryColour=&HFFFFFF,BorderStyle=4,BackColour=&H40000000,Outline=1,OutlineColour=&HFF000000,Alignment=2,MarginV=20\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Header Fields Composition (ABNF-like)\nDESCRIPTION: Specifies the composition of the header fields section in an RFC 822 message using an ABNF-like grammar. It mandates date and source information, requires at least one destination field, and allows for optional fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_16\n\nLANGUAGE: abnf\nCODE:\n```\nfields      =    dates                      ; Creation time,\n                  source                     ;  author id & one\n                1*destination                ;  address required\n                 *optional-field             ;  others optional\n```\n\n----------------------------------------\n\nTITLE: Cloning the SRS Repository using Git (Bash)\nDESCRIPTION: Clones the official SRS repository from GitHub into the current directory and navigates into the `srs/trunk` subdirectory. This is the first step in obtaining the SRS source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Architecture Diagram for RTMP ATC Hot Backup System\nDESCRIPTION: ASCII diagram showing the architecture of an HLS/HDS hot backup system using ATC. The flow shows encoders sending ATC RTMP streams to servers and packagers, which then go through a reverse proxy to CDN.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/rtmp-atc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n                        +----------+        +----------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n+----------+   | RTMP   +----------+ RTMP   +----------+ |   | Reverse |    +-------+\n| encoder  +->-+                                         +->-+  Proxy  +-->-+  CDN  +\n+----------+   |        +----------+        +----------+ |   | (nginx) |    +-------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n                 RTMP   +----------+ RTMP   +----------+\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory. This is the first step in setting up the RTMP Origin Cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: This snippet shows how to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone the SRS repository from GitHub and navigate to the trunk directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-transcode-to-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Starting NGINX and SRS Origin Servers - Bash\nDESCRIPTION: This command sequence starts NGINX using a specified edge config file and then launches SRS with the origin HLS config. NGINX must already be installed; the working directory must contain the relevant configuration files. Both servers must have sufficient permissions to bind to required ports. The snippet does not require input arguments but assumes service files are present and built.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-hls-cluster.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnginx -c $(pwd)/conf/hls.edge.conf\\n./objs/srs -c conf/hls.origin.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC in SRS RTMP Server\nDESCRIPTION: This snippet shows how to configure ATC (Absolute Time Control) in the SRS RTMP server's configuration file. It enables or disables ATC for play clients, including RTMP and HTTP FLV stream clients.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp-atc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # vhost for atc for hls/hds/rtmp backup.\n        # generally, atc default to off, server delivery rtmp stream to client(flash) timestamp from 0.\n        # when atc is on, server delivery rtmp stream by absolute time.\n        # atc is used, for instance, encoder will copy stream to master and slave server,\n        # server use atc to delivery stream to edge/client, where stream time from master/slave server\n        # is always the same, client/tools can slice RTMP stream to HLS according to the same time,\n        # if the time not the same, the HLS stream cannot slice to support system backup.\n        #\n        # @see http://www.adobe.com/cn/devnet/adobe-media-server/articles/varnish-sample-for-failover.html\n        # @see http://www.baidu.com/#wd=hds%20hls%20atc\n        #\n        # default: off\n        atc             off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: RTMP ATC Architecture Diagram\nDESCRIPTION: ASCII diagram showing the architecture of an ATC-enabled streaming setup with encoder, servers, packager, reverse proxy and CDN\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-atc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n                        +----------+        +----------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n+----------+   | RTMP   +----------+ RTMP   +----------+ |   | Reverse |    +-------+\n| encoder  +->-+                                         +->-+  Proxy  +-->-+  CDN  +\n+----------+   |        +----------+        +----------+ |   | (nginx) |    +-------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n                 RTMP   +----------+ RTMP   +----------+\n```\n\n----------------------------------------\n\nTITLE: Starting Multiple SRS Slave Instances\nDESCRIPTION: Commands to start multiple SRS instances on the same server using different configuration files. This enables running multiple SRS processes to handle more connections by utilizing multiple CPU cores.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nnohup ./objs/srs -c srs.1935.conf >/dev/null 2>&1 &\nnohup ./objs/srs -c srs.1936.conf >/dev/null 2>&1 &\n```\n\n----------------------------------------\n\nTITLE: HTTP Expires Header Example\nDESCRIPTION: Example of an Expires header field in HTTP/1.1 format using RFC 1123 date format to indicate when a response should be considered stale.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_72\n\nLANGUAGE: http\nCODE:\n```\nExpires: Thu, 01 Dec 1994 16:00:00 GMT\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository from GitHub\nDESCRIPTION: Clones the main SRS source code repository directly from GitHub using the HTTPS protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/resource.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Starting Sample API Server for HttpCallback Integration (Go, Bash)\nDESCRIPTION: This Bash snippet illustrates how to start the sample API server, written in Go, listening on port 8085. The API server receives HTTP events from SRS, such as on_publish and on_unpublish, to trigger FFMPEG-based snapshotting. Requires Go installation and the api-server source code. The command should be run in the research/api-server directory. Input: none; Output: Service running on port 8085.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/snapshot.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd research/api-server && go run server.go 8085\n```\n\n----------------------------------------\n\nTITLE: Linking to External Static Files Using Markdown\nDESCRIPTION: Shows how to link to external files using absolute URLs. The example demonstrates linking to a PNG file on the ossrs.io domain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n![](https://ossrs.io/lts/en-us/files/ffmpeg-min.png)\n```\n\n----------------------------------------\n\nTITLE: Benchmarking HLS with srs-bench Using Docker - Bash\nDESCRIPTION: This Bash command launches a Docker container with the 'ossrs/srs:sb' image and runs the HLS benchmark tool, simulating 100 clients against the NGINX edge HLS URL. Dependencies: Docker installed and working, network accessibility to the server and specified port. Parameters: -c for concurrent clients, -r for HLS URL. Outputs benchmark results to console.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it --network=host --name sb ossrs/srs:sb \\\n  ./objs/sb_hls_load -c 100 -r http://192.168.1.170:8081/live/livestream.m3u8\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Origin Server B for Cluster (SRS Config)\nDESCRIPTION: This configuration file sets up the second SRS origin server (Server B). It listens on port 19351, enables the HTTP API on port 9091, and defines itself as part of an origin cluster (`origin_cluster on`). It specifies the coworker origin server (Server A) at `127.0.0.1:9090`. `daemon off` keeps the server running in the foreground.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/sample-origin-cluster.md#2025-04-23_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n# conf/origin.cluster.serverB.conf\nlisten              19351;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\npid                 ./objs/origin.cluster.serverB.pid;\nhttp_api {\n    enabled         on;\n    listen          9091;\n}\nvhost __defaultVhost__ {\n    cluster {\n        mode            local;\n        origin_cluster  on;\n        coworkers       127.0.0.1:9090;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 'Received' Header Field Syntax (ABNF-like)\nDESCRIPTION: Defines the syntax for the 'Received' header field in RFC 822 using an ABNF-like grammar. Added by each relay, it includes details like sending/receiving hosts, physical path ('via'), protocols ('with'), message ID, original recipient ('for'), and reception time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_20\n\nLANGUAGE: abnf\nCODE:\n```\nreceived    =  \"Received\"    \":\"            ; one per relay\n                   [\"from\" domain]           ; sending host\n                   [\"by\"   domain]           ; receiving host\n                   [\"via\"  atom]             ; physical path\n                  *(\"with\" atom)             ; link/mail protocol\n                   [\"id\"   msg-id]           ; receiver msg id\n                   [\"for\"  addr-spec]         ; initial form\n\n\n August 13, 1982              - 17 -                      RFC #822\n\n\n\n \n Standard for ARPA Internet Text Messages\n\n\n                    \";\"    date-time         ; time received\n```\n\n----------------------------------------\n\nTITLE: HTTP PUT Method Implementation\nDESCRIPTION: Details the PUT method for storing or updating resources at a specific URI, explaining the differences between POST and PUT semantics.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_44\n\nLANGUAGE: http\nCODE:\n```\nPUT /path HTTP/1.1\\nHost: example.com\\nContent-Type: application/json\n```\n\n----------------------------------------\n\nTITLE: Updating an Existing SRS Repository using Git\nDESCRIPTION: This command updates an existing local SRS repository by fetching the latest changes from the remote repository. This should be executed within the SRS repository directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Stopping SRS service\nDESCRIPTION: Command to stop the SRS service using the init.d script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/service.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n/etc/init.d/srs stop\n```\n\n----------------------------------------\n\nTITLE: Defining Basic HTTP/1.1 Syntax Rules in ABNF\nDESCRIPTION: Defines the foundational syntax elements used in HTTP/1.1 including octets, characters, numbers, and control characters according to the US-ASCII coded character set.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_0\n\nLANGUAGE: ABNF\nCODE:\n```\nOCTET          = <any 8-bit sequence of data>\nCHAR           = <any US-ASCII character (octets 0 - 127)>\nUPALPHA        = <any US-ASCII uppercase letter \"A\"..\"Z\">\nLOALPHA        = <any US-ASCII lowercase letter \"a\"..\"z\">\nALPHA          = UPALPHA | LOALPHA\nDIGIT          = <any US-ASCII digit \"0\"..\"9\">\nCTL            = <any US-ASCII control character\n                (octets 0 - 31) and DEL (127)>\nCR             = <US-ASCII CR, carriage return (13)>\nLF             = <US-ASCII LF, linefeed (10)>\nSP             = <US-ASCII SP, space (32)>\nHT             = <US-ASCII HT, horizontal-tab (9)>\n<\">            = <US-ASCII double-quote mark (34)>\n```\n\n----------------------------------------\n\nTITLE: Querying SRS API Authors Endpoint - Bash (curl usage)\nDESCRIPTION: This example queries information about SRS authors and contributors using curl on the /api/v1/authors HTTP API endpoint. The returned JSON includes primary_authors, contributors_link, and contributors fields. Endpoint requires HTTP API to be enabled with public accessibility (no authentication restrictions). Used for licensing or credits display.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/http-api.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n```bash\\n# curl http://192.168.1.102:1985/api/v1/authors\\n        \"primary_authors\": \"xxx\",\\n        \"contributors_link\": \"https://github.com/ossrs/srs/blob/master/AUTHORS.txt\",\\n        \"contributors\": \"xxx\"\\n```\n```\n\n----------------------------------------\n\nTITLE: Project Table - Asynchronous DNS Resolution\nDESCRIPTION: Markdown table defining the asynchronous DNS resolution project details including mentor information, skills needed, and expected outcomes\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-02-10-GSoC.md#2025-04-23_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n|Name of project|Asynchronous DNS Resolution|\n| :---- | :----- |\n|Project Description|The IO used by SRS is coroutine IO, but the current DNS resolution is still synchronous resolution. Asynchronous DNS resolution can make better use of coroutine resources and avoid affecting other IO due to DNS blocking.|\n|Mentor|Guanghua Chenjinxue.cgh@alibaba-inc.com|\n|Backup Mentor|Zhihong Xiao hondaxiao@tencent.com|\n|Skills needed|Familiar with DNS resolution process, familiar with programming in C++|\n|Expected size of project|180 hours|\n|Difficulty|Advanced|\n|Expected results|Ability to perform asynchronous DNS resolution and pass the test.|\n|Qualification Task|complete DNS asynchronous resolution and coroutine encapsulation.|\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Response Structure in BNF Notation\nDESCRIPTION: Defines the structure of an HTTP response message using Backus-Naur Form notation. A response consists of a Status-Line followed by headers and an optional message body.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_32\n\nLANGUAGE: text\nCODE:\n```\nResponse      = Status-Line               ; Section 6.1\n                       *(( general-header        ; Section 4.5\n                        | response-header        ; Section 6.2\n                        | entity-header ) CRLF)  ; Section 7.1\n                       CRLF\n                       [ message-body ]          ; Section 7.2\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Daemon and Console Logging - Bash (SRS Config Format)\nDESCRIPTION: This configuration snippet shows how to set SRS to run with or without daemon mode and choose between logging to file or console. It uses SRS's custom configuration language but is typically shown in shell script context for setup. The config file is required as a command-line argument to SRS and its parameters ('daemon', 'listen', 'srs_log_tank', 'vhost') govern operational behavior regarding output, logging, and virtual hosting. Inputs are configuration parameters and output is the SRS runtime's logging and process behavior.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\n# whether start as deamon\n# default: on\ndaemon              on;\n```\n\nLANGUAGE: bash\nCODE:\n```\n# no-daemon and write log to console config for srs.\n# @see full.conf for detail config.\n\nlisten              1935;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Example FMLE Parameters for RTMP Publishing\nDESCRIPTION: This snippet provides example values for configuring Adobe Flash Media Live Encoder (FMLE) or a similar RTMP publisher. The 'FMS URL' specifies the target SRS server address and application instance ('live'), while 'Stream' defines the name of the stream to be published ('livestream'). These are used by the encoder to push the RTMP stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/delivery-rtmp.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# RTMPrtmp://192.168.1.170/live/livestream\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Program Date Time Tag Format Example\nDESCRIPTION: Example of EXT-X-PROGRAM-DATE-TIME tag usage that associates media segment with absolute date/time using ISO 8601 format\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_7\n\nLANGUAGE: plaintext\nCODE:\n```\n#EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Content-Coding Syntax - ABNF\nDESCRIPTION: Specifies the core syntax for HTTP content-coding using ABNF, as used in headers for content negotiation. No dependencies other than compliance with ABNF grammar conventions; 'token' refers to a generic parser rule defined in RFC 2616. Used to identify supported content encodings in Accept-Encoding and Content-Encoding headers. Input is a textual value adhering to the defined pattern. This grammar is case-insensitive by HTTP specification.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_10\n\nLANGUAGE: abnf\nCODE:\n```\ncontent-coding   = token\n```\n\n----------------------------------------\n\nTITLE: Installing aaPanel on Ubuntu 20+\nDESCRIPTION: Command to install aaPanel on Ubuntu 20+ servers. This downloads the installation script from the official source and executes it with an authentication code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-04-29-BT-aaPanel.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh && sudo bash install.sh ed8484bec\n```\n\n----------------------------------------\n\nTITLE: Running SRS with WebRTC Support\nDESCRIPTION: Start SRS server with WebRTC support by setting the CANDIDATE IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-build.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Proxying SRS HTTP API via Oryx - Bash\nDESCRIPTION: Shows a simple HTTP GET request to an SRS API endpoint via Oryx's proxy path. Useful for retrieving version information or other server details. The endpoint '/api/v1/versions' is used, and the command does not require authentication by default.\n\nInput: API URL; Output: API server response displayed in console. Dependencies: curl.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/api/v1/versions\n```\n\n----------------------------------------\n\nTITLE: Endlist Tag Format\nDESCRIPTION: Format specification for EXT-X-ENDLIST tag that indicates no more media segments will be added\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_10\n\nLANGUAGE: plaintext\nCODE:\n```\n#EXT-X-ENDLIST\n```\n\n----------------------------------------\n\nTITLE: Defining EXT-X-DISCONTINUITY Tag in HLS Media Playlist\nDESCRIPTION: Specifies the format of the EXT-X-DISCONTINUITY tag used in HLS media playlists to indicate encoding discontinuities between media segments. This tag is not allowed in master playlists.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_13\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXT-X-DISCONTINUITY\n```\n\n----------------------------------------\n\nTITLE: Linking to Documents in Sample Documentation Using Markdown\nDESCRIPTION: Demonstrates how to link to another document within the sample documentation section using a relative path. The example shows linking to a getting-started.md file in the same directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/README.md#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n[Getting Started](./getting-started.md)\n```\n\n----------------------------------------\n\nTITLE: Publishing an RTMP Stream using FFmpeg\nDESCRIPTION: Uses FFmpeg to publish a local video file (`./doc/source.flv`) as an RTMP stream to an SRS server running on localhost. The `-re` flag reads the input at its native frame rate, `-c copy` avoids re-encoding (stream copy), and `-f flv` specifies the output format. The stream is published to the `live` application with the name `livestream`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/rtmp.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: SRS Configuration for Transcoder-Based Snapshots\nDESCRIPTION: Configuration for SRS that uses the transcoder feature to generate snapshots. It configures FFMPEG to capture frames at 1 FPS and outputs up to 6 PNG images from the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/snapshot.md#2025-04-23_snippet_4\n\nLANGUAGE: conf\nCODE:\n```\nlisten              1935;\nmax_connections     1000;\ndaemon              off;\nsrs_log_tank        console;\nvhost __defaultVhost__ {\n    transcode {\n        enabled on;\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine snapshot {\n            enabled on;\n            iformat flv;\n            vfilter {\n                vf fps=1;\n            }\n            vcodec png;\n            vparams {\n                vframes 6;\n            }\n            acodec an;\n            oformat image2;\n            output ./objs/nginx/html/[app]/[stream]-%03d.png;\n        }\n    }\n    ingest {\n        enabled on;\n        input {\n            type file;\n            url ./doc/source.flv;\n        }\n        ffmpeg ./objs/ffmpeg/bin/ffmpeg;\n        engine {\n            enabled off;\n            output rtmp://127.0.0.1:[port]/live?vhost=[vhost]/livestream;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring the Slave SRS Instance\nDESCRIPTION: This is an SRS configuration file snippet for the slave server. It sets the listening port to 19350 (matching the master's forward destination), specifies unique PID and log file paths, and defines a default virtual host without any special directives, simply ready to receive the forwarded stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-forward.md#2025-04-23_snippet_5\n\nLANGUAGE: SRS Config\nCODE:\n```\n# conf/forward.slave.conf\nlisten              19350;\npid                 ./objs/srs.slave.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.slave.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: Building SRS in ARM Server Docker (aarch64)\nDESCRIPTION: Commands to build SRS in an ARM server docker environment, using the aarch64 docker image to compile SRS from source.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/arm.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run -it --rm -v `pwd`:/srs -w /srs ossrs/srs:aarch64 \\\n    bash -c \"./configure && make\"\n```\n\n----------------------------------------\n\nTITLE: HTTP Host Header Example\nDESCRIPTION: Example of a Host header field in an HTTP/1.1 request specifying the host and resource path being requested.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_74\n\nLANGUAGE: http\nCODE:\n```\nGET /pub/WWW/ HTTP/1.1\nHost: www.w3.org\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Authentic Resent (Forwarder) Syntax (ABNF-like)\nDESCRIPTION: Specifies the syntax for authenticated forwarder fields ('Resent-From', 'Resent-Sender') in RFC 822 using an ABNF-like grammar. Similar to 'authentic', it handles single forwarders versus cases with a separate submitting forwarder.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_24\n\nLANGUAGE: abnf\nCODE:\n```\nresent-authentic =\n             =   \"Resent-From\"      \":\"   mailbox\n             / ( \"Resent-Sender\"    \":\"   mailbox\n                 \"Resent-From\"      \":\" 1#mailbox  )\n```\n\n----------------------------------------\n\nTITLE: Building FFmpeg 6.0 with HEVC RTMP support\nDESCRIPTION: Compiles FFmpeg from source with libx264 and libx265 support. This uses FFmpeg 6.0+ which natively supports HEVC over RTMP without requiring additional patches.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b master https://github.com/FFmpeg/FFmpeg.git ~/git/FFmpeg\ncd ~/git/FFmpeg\nenv PKG_CONFIG_PATH=~/git/x264/build/lib/pkgconfig:~/git/x265_git/build/linux/build/lib/pkgconfig \\\n./configure \\\n  --prefix=$(pwd)/build \\\n  --enable-gpl --enable-nonfree --enable-pthreads --extra-libs=-lpthread \\\n  --disable-asm --disable-x86asm --disable-inline-asm \\\n  --enable-decoder=aac --enable-decoder=aac_fixed --enable-decoder=aac_latm --enable-encoder=aac \\\n  --enable-libx264 --enable-libx265 \\\n  --pkg-config-flags='--static'\nmake -j10\n```\n\n----------------------------------------\n\nTITLE: FAQ Reference Text Block\nDESCRIPTION: Instructions for referring users to the official FAQ documentation in both Chinese and English.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/faq.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSee FAQ:\n* Chinese: https://ossrs.net/lts/zh-cn/faq\n* English: https://ossrs.io/lts/en-us/faq\n```\n\n----------------------------------------\n\nTITLE: Recording SRS CPU Usage by PID - Bash\nDESCRIPTION: This Bash snippet searches for the running SRS server process by name, extracts its PID, and invokes 'top' to monitor its CPU usage interactively. It uses core utilities: ps, grep, awk, and top. Ensure the process matches 'srs' and 'objs' in its command-line; adjust as needed for other versions or process names.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/raspberrypi.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npid=`ps aux|grep srs|grep objs|awk '{print $2}'` && top -p $pid\n\n```\n\n----------------------------------------\n\nTITLE: Creating LoadBalancer Service for SRS in Kubernetes\nDESCRIPTION: This YAML snippet creates a Kubernetes Service of type LoadBalancer to expose the SRS deployment. It automatically creates an SLB (Server Load Balancer) and EIP (Elastic IP) to provide external access to the streaming service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/k8s.md#2025-04-23_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\napiVersion: v1\nkind: Service\nmetadata:\n  name: srs-origin-service\nspec:\n  type: LoadBalancer\n  selector:\n    app: srs\n  ports:\n  - name: srs-origin-service-1935-1935\n    port: 1935\n    protocol: TCP\n    targetPort: 1935\n  - name: srs-origin-service-1985-1985\n    port: 1985\n    protocol: TCP\n    targetPort: 1985\n  - name: srs-origin-service-8080-8080\n    port: 8080\n    protocol: TCP\n    targetPort: 8080\n```\n\n----------------------------------------\n\nTITLE: Configuring and Building Nginx with RTMP Module in Bash\nDESCRIPTION: This sequence of commands configures the Nginx build process. It sets the installation prefix, adds the third-party `nginx-rtmp-module`, enables the `http_ssl_module`, and then compiles and installs Nginx. This prepares an Nginx instance capable of handling RTMP streams for benchmarking purposes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\n./configure --prefix=`pwd`/../_release \\\n--add-module=`pwd`/../nginx-rtmp-module-1.0.4 \\\n--with-http_ssl_module && make && make install\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 Source Fields (ABNF-like)\nDESCRIPTION: Defines the 'source' component of RFC 822 message headers using an ABNF-like grammar. It includes optional trace information, originator details (author identification), and optional resent (forwarding) fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_17\n\nLANGUAGE: abnf\nCODE:\n```\nsource      = [  trace ]                    ; net traversals\n                  originator                 ; original mail\n               [  resent ]                   ; forwarded\n```\n\n----------------------------------------\n\nTITLE: Publishing RTMP Stream Using OBS - Text Configuration\nDESCRIPTION: This snippet provides stream settings for use in OBS Studio to publish an RTMP stream to the SRS server. Parameters are Server URL and StreamKey, which must be entered in OBS. No code execution; just data entry guidance. Should replace IP with your server as needed.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-hls-cluster.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nServer: rtmp://192.168.1.170/live\nStreamKey: livestream\n```\n\n----------------------------------------\n\nTITLE: HLS Master Playlist with Alternative Video Tracks (M3U8)\nDESCRIPTION: Shows a master playlist offering alternative video angles or views using the #EXT-X-MEDIA tag with TYPE=VIDEO. It defines video groups (\"low\", \"mid\", \"hi\") corresponding to different bandwidths, each offering 'Main', 'Centerfield', and 'Dugout' views. The #EXT-X-STREAM-INF tags reference these video groups using the VIDEO attribute.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_27\n\nLANGUAGE: m3u8\nCODE:\n```\n#EXTM3U\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Main\", \\\n   DEFAULT=YES,URI=\"low/main/audio-video.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Centerfield\", \\\n   DEFAULT=NO,URI=\"low/centerfield/audio-video.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"low\",NAME=\"Dugout\", \\\n   DEFAULT=NO,URI=\"low/dugout/audio-video.m3u8\"\n\n#EXT-X-STREAM-INF:BANDWIDTH=1280000,CODECS=\"...\",VIDEO=\"low\"\nlow/main/audio-video.m3u8\n\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"mid\",NAME=\"Main\", \\\n   DEFAULT=YES,URI=\"mid/main/audio-video.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"mid\",NAME=\"Centerfield\", \\\n   DEFAULT=NO,URI=\"mid/centerfield/audio-video.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"mid\",NAME=\"Dugout\", \\\n   DEFAULT=NO,URI=\"mid/dugout/audio-video.m3u8\"\n\n#EXT-X-STREAM-INF:BANDWIDTH=2560000,CODECS=\"...\",VIDEO=\"mid\"\nmid/main/audio-video.m3u8\n\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hi\",NAME=\"Main\", \\\n   DEFAULT=YES,URI=\"hi/main/audio-video.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hi\",NAME=\"Centerfield\", \\\n   DEFAULT=NO,URI=\"hi/centerfield/audio-video.m3u8\"\n#EXT-X-MEDIA:TYPE=VIDEO,GROUP-ID=\"hi\",NAME=\"Dugout\", \\\n   DEFAULT=NO,URI=\"hi/dugout/audio-video.m3u8\"\n\n#EXT-X-STREAM-INF:BANDWIDTH=7680000,CODECS=\"...\",VIDEO=\"hi\"\nhi/main/audio-video.m3u8\n\n#EXT-X-STREAM-INF:BANDWIDTH=65000,CODECS=\"mp4a.40.5\"\nmain/audio-only.m3u8\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS from GitLab Mirror\nDESCRIPTION: This snippet shows how to clone the SRS repository from the GitLab mirror and then update the remote URL to the GitHub repository. This provides an alternative mirror for users who prefer GitLab.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/resource.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://gitlab.com/winlinvip/srs-gitlab.git srs &&\ncd srs && git remote set-url origin https://github.com/ossrs/srs.git && git pull\n```\n\n----------------------------------------\n\nTITLE: Configuring SRT VHost Settings in SRS\nDESCRIPTION: This configuration block defines the SRT settings for the default virtual host in SRS. It controls whether SRT is enabled for the vhost and whether SRT streams are converted to RTMP for further distribution via other protocols.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    srt {\n        # Whether enable SRT on this vhost.\n        # Overwrite by env SRS_VHOST_SRT_ENABLED for all vhosts.\n        # Default: off\n        enabled on;\n        # Whether covert SRT to RTMP stream.\n        # Overwrite by env SRS_VHOST_SRT_TO_RTMP for all vhosts.\n        # Default: on\n        srt_to_rtmp on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JSON-Based Successful HTTP Response for SRS Callback\nDESCRIPTION: This example shows an alternative valid success response format for an SRS HTTP callback server. It also uses an HTTP/1.1 200 OK status but provides a JSON body `{\"code\": 0}`. SRS accepts either this JSON format (with the 'code' field explicitly set to 0) or the plain text '0' body as indicators of a successful callback operation.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/http-callback.md#2025-04-23_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nHTTP/1.1 200 OK\nContent-Length: 11\n{\"code\": 0}\n```\n\n----------------------------------------\n\nTITLE: Starting First SRS Origin Server for HLS (Reuse Port)\nDESCRIPTION: Starts the first SRS Origin server instance configured specifically for HLS delivery, listening on standard RTMP (1935) and HTTP (8080) ports. It utilizes SO_REUSEPORT and expects configuration in `conf/origin.hls.only1.conf`. This setup is intended for HLS-only delivery when using multiple origin instances.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/reuse-port.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.hls.only1.conf\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository - Bash\nDESCRIPTION: This snippet demonstrates how to clone the SRS repository from GitHub using git, followed by changing the working directory to the main source tree. It requires git to be installed and network connectivity. The commands will retrieve the latest SRS source code needed for further installation steps.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-dash.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker with HTTPS and WebRTC over TCP on Port 8088\nDESCRIPTION: This Docker command runs SRS 5.0.60 with HTTPS and WebRTC over TCP enabled on port 8088. It includes additional configuration for HTTPS API and server settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8088:8088/tcp \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_VHOST_RTC_RTC_TO_RTMP=on \\\n  -e SRS_HTTP_API_LISTEN=8080 \\\n  -e SRS_HTTP_API_HTTPS_ENABLED=on \\\n  -e SRS_HTTP_API_HTTPS_LISTEN=8088 \\\n  -e SRS_HTTP_SERVER_HTTTPS_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8088 \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: Defining Alternatives with Slash in Augmented BNF\nDESCRIPTION: Explains the use of the slash ('/') character in the augmented BNF notation to denote alternatives between two rules. The example 'foo / bar' indicates that either the token 'foo' or the token 'bar' is acceptable according to this rule.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_0\n\nLANGUAGE: abnf\nCODE:\n```\nfoo / bar\n```\n\n----------------------------------------\n\nTITLE: Running FFMPEG Loop to Publish RTMP Stream - Bash\nDESCRIPTION: This Bash for-loop repeatedly starts an FFMPEG process to publish a local FLV file to an SRS RTMP server until interrupted. The '-re' option throttles FFMPEG to the source file rate, and the codecs are copied for minimal CPU overhead. Prerequisites are the FFMPEG binary at './objs/ffmpeg/bin/ffmpeg' and the file 'doc/source.flv'. Requires access to the RTMP endpoint on the specified IP/port.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/raspberrypi.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://192.168.1.105:1935/live/livestream; \\\n    sleep 1; \ndone\n\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS 5+ with Shared SRTP Library Linking (Bash)\nDESCRIPTION: This command configures the SRS 5+ build process to link against the shared SRTP library (`libsrtp.so`) by enabling the `--shared-srtp=on` option. This is necessary for features requiring Secure Real-time Transport Protocol, leveraging the libsrtp library which uses a 3-clause BSD license.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/license.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./configure --shared-srtp=on\n```\n\n----------------------------------------\n\nTITLE: Documenting X-TIMESTAMP-MAP Header for WebVTT Segments - Markdown - English\nDESCRIPTION: This example demonstrates the format of the X-TIMESTAMP-MAP metadata header required in WebVTT subtitle segments for synchronization. It shows how to relate local cue times to MPEG-2 transport stream timestamps. Proper usage is mandatory for segments with WebVTT headers to ensure accurate subtitle display across different renditions.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/hls-m3u8-draft-pantos-http-live-streaming-12.txt#2025-04-23_snippet_20\n\nLANGUAGE: markdown\nCODE:\n```\nX-TIMESTAMP-MAP=LOCAL:<cue time>,MPEGTS:<MPEG-2 time>\ne.g. X-TIMESTAMP-MAP=LOCAL:00:00:00.000,MPEGTS:900000\n```\n\n----------------------------------------\n\nTITLE: Checking Out Contributor's PR Branch (TOC Workflow) using Bash\nDESCRIPTION: This command switches the maintainer's (TOC) local working directory to the contributor's branch (`bugfix/fix-srt-url` in the example) that was fetched from the `tmp` remote in the previous step. This allows the maintainer to make direct changes to the PR branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout bugfix/fix-srt-url\n```\n\n----------------------------------------\n\nTITLE: Publishing FLV Stream to SRS via RTMP using FFmpeg\nDESCRIPTION: Uses FFmpeg to read a local FLV file (`./doc/source.flv`) and publish it as an RTMP stream to the SRS server running on localhost. The `-re` flag ensures native frame rate, `-c copy` avoids transcoding, and `-f flv` specifies the output format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Configuring Slave SRS Instance (SRS Conf)\nDESCRIPTION: Defines the configuration for the slave SRS instance. It listens on port 19350 and sets log file paths. This instance is intended to receive the forwarded stream from the master. This content should be saved to a file, e.g., `conf/forward.slave.conf`.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-forward.md#2025-04-23_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n# conf/forward.slave.conf\nlisten              19350;\npid                 ./objs/srs.slave.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.slave.log;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback Event Flow Diagram - Bash\nDESCRIPTION: ASCII diagram representing RTMP streaming from OBS into the Oryx Docker container and the subsequent HTTP request to an external server for event callback. Illustrates the high-level network and service architecture for understanding Oryx's event notification workflow. No dependencies; this is for documentation and conceptual reference.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/getting-started-oryx.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n                   +-----------------------+\n                   +                       +\n+-------+          +     +-----------+     +                 +--------------+\n+  OBS  +--RTMP->--+-----+ Oryx +-----+----HTTP--->-----+  Your Server +\n+-------+          +     +-----------+     +  (Target URL)   +--------------+\n                   +                       +\n                   +       Docker          +\n                   +-----------------------+\n```\n\n----------------------------------------\n\nTITLE: Restarting SRS on RaspberryPi\nDESCRIPTION: Command to restart the SRS service on RaspberryPi.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/raspberrypi.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nsudo /etc/init.d/srs restart\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic ATC Detection in SRS\nDESCRIPTION: This configuration snippet demonstrates how to disable the automatic ATC detection feature in SRS. It prevents SRS from automatically enabling ATC when the encoder includes the 'bravo_atc=true' metadata in the stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/rtmp-atc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost atc.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Content Disposition Example\nDESCRIPTION: Example showing proper formatting of a content disposition header with filename parameter.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_97\n\nLANGUAGE: text\nCODE:\n```\nContent-Disposition: attachment; filename=\"fname.ext\"\n```\n\n----------------------------------------\n\nTITLE: Configuring ATC Deployment Architecture\nDESCRIPTION: Diagram showing the architecture of ATC deployment with encoder, servers, packager, reverse proxy and CDN components. Demonstrates how RTMP streams with ATC flow through the system.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-atc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n                        +----------+        +----------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n+----------+   | RTMP   +----------+ RTMP   +----------+ |   | Reverse |    +-------+\n| encoder  +->-+                                         +->-+  Proxy  +-->-+  CDN  +\n+----------+   |        +----------+        +----------+ |   | (nginx) |    +-------+\n               +--ATC->-+  server  +--ATC->-+ packager +-+   +---------+\n                 RTMP   +----------+ RTMP   +----------+\n```\n\n----------------------------------------\n\nTITLE: System Resource Usage Stats\nDESCRIPTION: Top command output showing CPU, memory and process statistics during load test with multiple RTMP connections\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/performance.md#2025-04-23_snippet_21\n\nLANGUAGE: plaintext\nCODE:\n```\ntop - 19:52:35 up 1 day, 11:11,  8 users,  load average: 1.20, 1.05, 0.92\nTasks: 171 total,   4 running, 167 sleeping,   0 stopped,   0 zombie\nCpu0  : 26.0%us, 23.0%sy,  0.0%ni, 34.0%id,  0.3%wa,  0.0%hi, 16.7%si,  0.0%st\nCpu1  : 26.4%us, 20.4%sy,  0.0%ni, 34.1%id,  0.7%wa,  0.0%hi, 18.4%si,  0.0%st\nCpu2  : 22.5%us, 15.4%sy,  0.0%ni, 45.3%id,  1.0%wa,  0.0%hi, 15.8%si,  0.0%st\nMem:   2055440k total,  1972196k used,    83244k free,   136836k buffers\nSwap:  2064376k total,     3184k used,  2061192k free,   926124k cached\n\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                          \n17034 root      20   0  415m 151m 2040 R 94.4  7.6  14:29.33 ./objs/srs -c console.conf                                                        \n 1063 winlin    20   0  131m  68m 1336 S 17.9  3.4  54:05.77 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1011 winlin    20   0  132m  68m 1336 R 17.6  3.4  54:45.53 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18736 winlin    20   0  113m  48m 1336 S 17.6  2.4   1:37.96 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n 1051 winlin    20   0  131m  68m 1336 S 16.9  3.4  53:25.04 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream               \n18739 winlin    20   0  104m  39m 1336 R 15.6  2.0   1:25.71 ./objs/sb_rtmp_load -c 800 -r rtmp://127.0.0.1:1935/live/livestream\n```\n\n----------------------------------------\n\nTITLE: HTTP Callback JSON Request and Response for on_publish Event\nDESCRIPTION: This snippet illustrates the JSON structure for the on_publish event HTTP callback request and response. It includes details like request_id, action, stream information, and the expected response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/getting-started-oryx.md#2025-04-23_snippet_6\n\nLANGUAGE: json\nCODE:\n```\nRequest:\n{\n  \"request_id\": \"3ab26a09-59b0-42f7-98e3-a281c7d0712b\",\n  \"action\": \"on_publish\",\n  \"opaque\": \"mytoken\",\n  \"vhost\": \"__defaultVhost__\",\n  \"app\": \"live\",\n  \"stream\": \"livestream\",\n  \"param\": \"?secret=8f7605d657c74d69b6b48f532c469bc9\"\n}\n\nResponse:\n{\n  \"code\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to get the SRS source code from GitHub repository. This is the first step for deploying an HTTP-FLV cluster.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-http-flv-cluster.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Customizing Subtitle Font Color and Size\nDESCRIPTION: Sets the subtitle font color to red and font size to 20px using FFmpeg's force_style parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/for-writers/pages/faq-oryx-en.md#2025-04-23_snippet_16\n\nLANGUAGE: text\nCODE:\n```\nFontsize=20,PrimaryColour=&H000000FF\n```\n\n----------------------------------------\n\nTITLE: SRS Transcoding Configuration\nDESCRIPTION: Configuration file for SRS that sets up FFMPEG transcoding with specific video and audio encoding parameters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ffmpeg.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# conf/ffmpeg.transcode.conf\nlisten              1935;\nmax_connections     1000;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine ff {\n            enabled         on;\n            vfilter {\n            }\n            vcodec          libx264;\n            vbitrate        500;\n            vfps            25;\n            vwidth          768;\n            vheight         320;\n            vthreads        12;\n            vprofile        main;\n            vpreset         medium;\n            vparams {\n            }\n            acodec          libfdk_aac;\n            abitrate        70;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Text and Hexadecimal Character Rules in BNF\nDESCRIPTION: Defines rules for text content and hexadecimal characters in HTTP/1.0. TEXT rule is used for descriptive field contents not interpreted by the message parser, while HEX defines hexadecimal numeric characters.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_2\n\nLANGUAGE: BNF\nCODE:\n```\nTEXT           = <any OCTET except CTLs,\n                 but including LWS>\nHEX            = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\"\n               | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | DIGIT\n```\n\n----------------------------------------\n\nTITLE: Pushing New Branch to Forked Repository using Git\nDESCRIPTION: This command pushes the newly created local branch (`bugfix/bug-summary`) to the `origin` remote (the contributor's fork) and sets up upstream tracking (`-u`). This makes the branch available on GitHub for creating a Pull Request.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/src/pages/how-to-file-pr.md#2025-04-23_snippet_4\n\nLANGUAGE: git\nCODE:\n```\ngit push -u origin bugfix/bug-summary\n```\n\n----------------------------------------\n\nTITLE: Configuring DVR with HTTP Callback\nDESCRIPTION: A configuration example demonstrating how to enable DVR with HTTP callbacks for events. This allows external systems to be notified when DVR recordings start/stop and track file locations.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/dvr.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nvhost your_vhost {\n    dvr {\n        enabled             on;\n        dvr_path            ./objs/nginx/html/[app]/[stream]/[2006]/[01]/[02]/[15].[04].[05].[999].flv;\n        dvr_plan            segment;\n        dvr_duration        30;\n        dvr_wait_keyframe   on;\n    }\n    http_hooks {\n        enabled         on;\n        on_dvr          http://127.0.0.1:8085/api/v1/dvrs;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building State Threads Library on Linux\nDESCRIPTION: These bash commands clone the State Threads repository and build the library for Linux in debug mode. This is a prerequisite for compiling the example program.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-02-26-State-Threads-for-Internet-Applications.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmkdir -p ~/git && cd ~/git\ngit clone -b srs https://github.com/ossrs/state-threads.git\nmake linux-debug\n```\n\n----------------------------------------\n\nTITLE: Configuring Minimal Send Interval for SRS RTMP/HTTP-FLV Playback\nDESCRIPTION: Sets the minimal packet send interval in milliseconds for RTMP and HTTP-FLV stream clients. This controls the stream's packet delivery timing, useful for devices requiring constant interval streams. Set to 0 to disable, or >0 to send messages one by one.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/special-control.md#2025-04-23_snippet_0\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    play {\n        send_min_interval       10.0;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up HTTP Hooks for HLS Notifications in SRS\nDESCRIPTION: Configures an HTTP hook to be called when SRS reaps an HLS TS file. This can be used to push files to a CDN network. The hook uses HTTP GET with variables for app, stream, and ts_url.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/special-control.md#2025-04-23_snippet_8\n\nLANGUAGE: nginx\nCODE:\n```\nvhost __defaultVhost__ {\n    http_hooks {\n        on_hls_notify   http://127.0.0.1:8085/api/v1/hls/[app]/[stream][ts_url];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TE Header Syntax and Examples in HTTP/1.1\nDESCRIPTION: Syntax definition and examples of the TE request header in HTTP/1.1, which indicates what extension transfer-codings the client is willing to accept in the response and whether it accepts trailer fields.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_87\n\nLANGUAGE: http\nCODE:\n```\nTE        = \"TE\" \":\" #( t-codings )\nt-codings = \"trailers\" | ( transfer-extension [ accept-params ] )\n\nExamples of its use are:\n\nTE: deflate\nTE:\nTE: trailers, deflate;q=0.5\n```\n\n----------------------------------------\n\nTITLE: Setting Normal Packet Timeout for Publishers in SRS\nDESCRIPTION: Configures the normal packet timeout in milliseconds for encoders after connection is established. This setting controls how long SRS waits between packets from a publisher before considering the connection dead.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/special-control.md#2025-04-23_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nvhost __defaultVhost__ {\n    # the config for FMLE/Flash publisher, which push RTMP to SRS.\n    publish {\n        # the normal packet timeout in ms for encoder.\n        # default: 5000\n        normal_timeout      7000;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling HTTPS API for SRS\nDESCRIPTION: Configuration for enabling HTTPS API in SRS, specifying port, SSL key and certificate files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nhttp_api {\n    enabled         on;\n    listen          1985;\n    https {\n        # Whether enable HTTPS API.\n        # default: off\n        enabled on;\n        # The listen endpoint for HTTPS API.\n        # default: 1990\n        listen 1990;\n        # The SSL private key file, generated by:\n        #       openssl genrsa -out server.key 2048\n        # default: ./conf/server.key\n        key ./conf/server.key;\n        # The SSL public cert file, generated by:\n        #       openssl req -new -x509 -key server.key -out server.crt -days 3650 -subj \"/C=CN/ST=Beijing/L=Beijing/O=Me/OU=Me/CN=ossrs.net\"\n        # default: ./conf/server.crt\n        cert ./conf/server.crt;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring External Tools Log Directory in SRS\nDESCRIPTION: Configuration for managing logs from external tools used by SRS features like Transcode/Ingest (e.g., FFMPEG). Specifies the directory where tool logs should be stored, with an option to disable them by setting to /dev/null.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/log.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# the logs dir.\n# if enabled ffmpeg, each stracoding stream will create a log file.\n# \"/dev/null\" to disable the log.\n# default: ./objs\nff_log_dir          ./objs;\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source (Bash)\nDESCRIPTION: This snippet shows the commands to configure the build environment and compile the SRS source code using the standard `./configure && make` process. This step generates the executable files needed to run the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Configuring Audio-Only Output by Dropping Video\nDESCRIPTION: Configuration example showing how to drop video streams while transcoding audio to AAC format, resulting in audio-only output.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/ffmpeg.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    transcode {\n        enabled     on;\n        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;\n        engine vn {\n            enabled         on;\n            vcodec          vn;\n            acodec          libfdk_aac;\n            abitrate        45;\n            asample_rate    44100;\n            achannels       2;\n            aparams {\n            }\n            output          rtmp://127.0.0.1:[port]/[app]?vhost=[vhost]/[stream]_[engine];\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebRTC Server Settings in SRS\nDESCRIPTION: Main configuration block for WebRTC server including UDP/TCP settings, protocols, and candidate configuration. Includes vhost settings for NACK, TWCC and RTMP conversion options.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    enabled on;\n    listen 8000;\n    tcp {\n        enabled off;\n        listen 8000;\n    }\n    protocol udp;\n    candidate *;\n}\n\nvhost rtc.vhost.srs.com {\n    rtc {\n        enabled on;\n        nack on;\n        twcc on;\n        rtmp_to_rtc off;\n        rtc_to_rtmp off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: HTTP Via Header Example\nDESCRIPTION: Examples of the Via header used by proxies and gateways to indicate intermediate protocols and recipients. Shows how the header tracks message forwards and identifies protocol capabilities of senders along the request/response chain.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_92\n\nLANGUAGE: HTTP\nCODE:\n```\nVia: 1.0 fred, 1.1 nowhere.com (Apache/1.1)\n```\n\nLANGUAGE: HTTP\nCODE:\n```\nVia: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy\n```\n\nLANGUAGE: HTTP\nCODE:\n```\nVia: 1.0 ricky, 1.1 mertz, 1.0 lucy\n```\n\n----------------------------------------\n\nTITLE: Publishing HEVC Stream with FFmpeg Docker for macOS\nDESCRIPTION: Command to use SRS encoder Docker image to publish an HEVC stream on macOS. This approach allows using FFmpeg with HEVC support without compiling it from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-10-26-Unlock-the-Power-of-HEVC-via-RTMP.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \\\n  ffmpeg -stream_loop -1 -re -i doc/source.flv -acodec copy \\\n    -vcodec libx265 -f flv rtmp://host.docker.internal/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Running SRS Server with HTTP-FLV Configuration using Docker\nDESCRIPTION: Command to start an SRS server container with HTTP-FLV configuration using Docker. This runs SRS version 5 with the HTTP FLV live configuration and exposes ports 1935 (RTMP) and 8080 (HTTP).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/flv.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 8080:8080 ossrs/srs:5 \\\n  ./objs/srs -c conf/http.flv.live.conf\n```\n\n----------------------------------------\n\nTITLE: WebRTC TCP Resource Management\nDESCRIPTION: Implementation of resource management and coroutine execution for WebRTC TCP connections using shared resources and executors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2024-06-15-SRS-Smart-Pointer.md#2025-04-23_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nresource = new SrsRtcTcpConn(new SrsTcpConnection(stfd2), ip, port);\n\nSrsRtcTcpConn* raw_conn = dynamic_cast<SrsRtcTcpConn*>(resource);\nSrsSharedResource<SrsRtcTcpConn>* conn = new SrsSharedResource<SrsRtcTcpConn>(raw_conn);\nSrsExecutorCoroutine* executor = new SrsExecutorCoroutine(_srs_rtc_manager, conn, raw_conn, raw_conn);\nif ((err = executor->start()) != srs_success) {\n    srs_freep(executor);\n    return srs_error_wrap(err, \"start executor\");\n}\n```\n\n----------------------------------------\n\nTITLE: SRS ATC Auto-Detection Configuration\nDESCRIPTION: Configuration for enabling automatic ATC detection based on encoder metadata. Shows how to configure the atc_auto feature in SRS virtual host settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-atc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost atc.srs.com {\n    # for play client, both RTMP and other stream clients,\n    # for instance, the HTTP FLV stream clients.\n    play {\n        # whether enable the auto atc,\n        # if enabled, detect the bravo_atc=\"true\" in onMetaData packet,\n        # set atc to on if matched.\n        # always ignore the onMetaData if atc_auto is off.\n        # default: off\n        atc_auto        off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code using Git (Bash)\nDESCRIPTION: Fetches the latest changes from the remote repository and merges them into the current branch of an existing local SRS clone. Use this command within the `srs/trunk` directory to update the codebase.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-http-flv-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Logrotate with Copytruncate\nDESCRIPTION: Alternative logrotate configuration using copytruncate method. This approach is not recommended for SRS3 as it may lose logs, but can be used as a workaround for SRS2.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log-rotate.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncat << END > /etc/logrotate.d/srs\n/usr/local/srs/objs/srs.log {\n    daily\n    dateext\n    compress\n    rotate 7\n    size 1024M\n    copytruncate\n}\nEND\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Command for Mixing WebRTC Streams\nDESCRIPTION: FFmpeg command to mix multiple RTMP streams generated from WebRTC sources. It applies video scaling, overlay effects, and audio mixing to create a composite stream.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -f flv -i rtmp://192.168.3.6/live/alice -f flv -i rtmp://192.168.3.6/live/314d0336 \\\n     -filter_complex \"[1:v]scale=w=96:h=72[ckout];[0:v][ckout]overlay=x=W-w-10:y=H-h-10[out]\" -map \"[out]\" \\\n     -c:v libx264 -profile:v high -preset medium \\\n     -filter_complex amix -c:a aac \\\n     -f flv rtmp://192.168.3.6/live/merge\n```\n\n----------------------------------------\n\nTITLE: Example URL for HTTP HLS Player\nDESCRIPTION: URL demonstrating how to configure the SRS player to stream 'livestream.m3u8' via HLS over HTTP from the server 'r.ossrs.net' on port 80. Specifies the .m3u8 stream extension.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/tools/demo.md#2025-04-23_snippet_2\n\nLANGUAGE: url\nCODE:\n```\nhttp://ossrs.net/players/srs_player.html?app=live&stream=livestream.m3u8&server=r.ossrs.net&port=80&autostart=true&vhost=r.ossrs.net&schema=http\n```\n\n----------------------------------------\n\nTITLE: Configuring WebRTC Server Settings in SRS\nDESCRIPTION: Core configuration for enabling WebRTC server in SRS, including UDP port listening, candidate address setup, and RTC-specific settings for a virtual host.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/webrtc.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    enabled on;\n    listen 8000;\n    candidate $CANDIDATE;\n}\n\nvhost rtc.vhost.srs.com {\n    rtc {\n        enabled on;\n        rtmp_to_rtc off;\n        rtc_to_rtmp off;\n        nack on;\n        twcc on;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Streaming SRT with Authentication Token\nDESCRIPTION: This FFmpeg command shows how to include authentication information in the SRT stream. It adds a 'secret' parameter to the streamid for authentication purposes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/srt.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i doc/source.flv -c copy -f mpegts \\\n    'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,secret=xxx,m=publish'\n```\n\n----------------------------------------\n\nTITLE: SRS Edge and NGINX Edge Cluster Architecture\nDESCRIPTION: Text diagram showing an architecture combining SRS Edge Server and NGINX Edge Servers to distribute both HTTP-FLV and HLS content to visitors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n+------------+           +------------+\n| SRS Origin +--RTMP-->--+ SRS Edge   +\n+-----+------+           +----+-------+\n      |                       |               +------------+\n      |                       +---HTTP-FLV->--+   NGINX    +              +-----------+\n      |                                       +   Edge     +--HLS/FLV-->--+ Visitors  +\n      +-------HLS--->-------------------------+   Servers  +              +-----------+\n                                              +------------+\n```\n\n----------------------------------------\n\nTITLE: WebRTC TCP with Live Streaming Docker Configuration\nDESCRIPTION: Docker command to run SRS with WebRTC over TCP and HTTP live streaming support on port 8080.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 8080:8080/tcp \\\n  -e CANDIDATE=\"192.168.3.82\" \\\n  -e SRS_VHOST_RTC_RTC_TO_RTMP=on \\\n  -e SRS_HTTP_API_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_TCP_ENABLED=on \\\n  -e SRS_RTC_SERVER_TCP_LISTEN=8080 \\\n  -e SRS_RTC_SERVER_PROTOCOL=tcp \\\n  registry.cn-hangzhou.aliyuncs.com/ossrs/srs:v5.0.60\n```\n\n----------------------------------------\n\nTITLE: SRS Slave Server Configuration (Port 1936)\nDESCRIPTION: Configuration for an SRS slave server listening on port 1936. This allows running multiple SRS instances on the same physical server to handle more connections by utilizing multiple CPU cores.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1936;\npid                 ./objs/srs.1936.pid;\nmax_connections     10240;\nvhost __defaultVhost__ {\n}\n```\n\n----------------------------------------\n\nTITLE: WebRTC Server Configuration Example\nDESCRIPTION: Complete configuration example for WebRTC server settings in SRS, including UDP/TCP transport, candidate protocols, and various WebRTC-specific options\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrtc_server {\n    enabled on;\n    listen 8000;\n    tcp {\n        enabled off;\n        listen 8000;\n    }\n    protocol udp;\n    candidate *;\n}\n\nvhost rtc.vhost.srs.com {\n    rtc {\n        enabled on;\n        nack on;\n        twcc on;\n        stun_timeout 30;\n        dtls_role passive;\n        rtmp_to_rtc off;\n        rtc_to_rtmp off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS for WebRTC\nDESCRIPTION: Start SRS with WebRTC support, setting the CANDIDATE IP address.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Forward in SRS\nDESCRIPTION: SRS configuration for enabling dynamic stream forwarding that queries forwarding targets from a backend HTTP API server. This allows for runtime determination of where streams should be forwarded.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/forward.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        backend http://127.0.0.1:8085/api/v1/forward;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Cross-Compiled SRS on ARMv7 Docker\nDESCRIPTION: Docker command to run the cross-compiled SRS binary on an ARMv7 Docker container, exposing the necessary ports for RTMP and HTTP services.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/arm.md#2025-04-23_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/git/srs/trunk && docker run --rm -it -v `pwd`:/srs -w /srs \\\n    -p 1935:1935 -p 1985:1985 -p 8080:8080 armv7/armhf-ubuntu \\\n    ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS graceful quit parameters\nDESCRIPTION: This configuration snippet shows the available options for fine-tuning SRS's graceful quit behavior, including wait times and force grace quit setting.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/service.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngrace_start_wait 2300;\ngrace_final_wait 3200;\nforce_grace_quit off;\n```\n\n----------------------------------------\n\nTITLE: Visualizing WebRTC Browser-to-SFU Communication\nDESCRIPTION: ASCII diagram showing the signaling and media flow between a browser and an SFU (Selective Forwarding Unit) server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/webrtc.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n+----------------+                        +---------+\n+    Browser     +----<--Signaling----->--+   SFU   +\n+ (like Chrome)  +----<----Media----->----+  Server +\n+----------------+                        +---------+\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 3.0 Branch in Bash\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 3.0 release branch. Used when implementing or testing features specific to version 3.0.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/git.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: Complete Low Latency Configuration\nDESCRIPTION: Comprehensive configuration combining all low latency optimizations including TCP nodelay, minimum latency mode, GOP cache, and queue settings.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/low-latency.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    tcp_nodelay     on;\n    min_latency     on;\n\n    play {\n        gop_cache       off;\n        queue_length    10;\n        mw_latency      100;\n    }\n\n    publish {\n        mr off;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring External Tools Logging\nDESCRIPTION: Configuration for managing logs from external tools like FFMPEG used by SRS. Allows specification of log directory or disable logging by setting to /dev/null.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# the logs dir.\n# if enabled ffmpeg, each stracoding stream will create a log file.\n# \"/dev/null\" to disable the log.\n# default: ./objs\nff_log_dir          ./objs;\n```\n\n----------------------------------------\n\nTITLE: Installing Graphviz for Performance Visualization\nDESCRIPTION: Command to install Graphviz, a tool needed for generating visual graphs of performance data. This helps in visualizing function call relationships and hotspots.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nyum install -y graphviz\n```\n\n----------------------------------------\n\nTITLE: Playing HEVC over RTMP with FFplay\nDESCRIPTION: Uses FFplay (from FFmpeg) to play an RTMP stream containing HEVC-encoded video. This requires an FFplay build that supports HEVC over RTMP.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/hevc.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./ffplay rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server Instances\nDESCRIPTION: Commands to start all three SRS server instances (two origin servers and one edge server) using their respective configuration files.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/origin.cluster.serverA.conf &\n./objs/srs -c conf/origin.cluster.serverB.conf &\n./objs/srs -c conf/origin.cluster.edge.conf &\n```\n\n----------------------------------------\n\nTITLE: Implementing HTTP Callback Handler in PHP\nDESCRIPTION: Example PHP code for handling SRS HTTP callbacks. Processes the JSON request body and returns the required response format.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-callback.md#2025-04-23_snippet_9\n\nLANGUAGE: php\nCODE:\n```\n$body = json_decode(file_get_contents('php://input'));\nprintf($body);\n\necho json_encode(array(\"code\"=>0, \"msg\"=>\"OK\"));\n```\n\n----------------------------------------\n\nTITLE: Retrieving SRS Service External IP\nDESCRIPTION: Command to retrieve the external IP address of the SRS service, which is used for streaming and playback. This IP is automatically assigned by the LoadBalancer service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nkubectl get svc/srs-origin-service\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-realtime.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Running SRS Docker Container for Live Streaming\nDESCRIPTION: Launches an SRS Docker container exposing ports for RTMP, HTTP, and API access. This setup supports basic live streaming functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 ossrs/srs:5\n```\n\n----------------------------------------\n\nTITLE: Defining RFC 822 'Date' Field Syntax (ABNF-like)\nDESCRIPTION: Specifies the syntax for the original 'Date' header field in RFC 822 using an ABNF-like grammar, indicating the message creation time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_26\n\nLANGUAGE: abnf\nCODE:\n```\norig-date   =  \"Date\"        \":\"   date-time\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source Code on Windows with Cygwin\nDESCRIPTION: Commands for checking out the develop branch, configuring and building SRS on Windows using Cygwin. This produces an executable file at ./objs/srs.exe.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/windows.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout develop\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Server in SRS\nDESCRIPTION: Basic HTTP server configuration including port and root directory settings. Controls the embedded HTTP server functionality for serving HLS and other HTTP-based streams.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/http-server.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhttp_server {\n    enabled         on;\n    listen          8080;\n    dir             ./objs/nginx/html;\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating Live Streaming Workflow in ASCII Diagram\nDESCRIPTION: A simple ASCII diagram showing the basic workflow of live streaming, from encoder through SRS/CDN network to player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/client-sdk.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+---------+      +-----------------+       +---------+\n| Encoder +-->---+ SRS/CDN Network +--->---+ Player  |\n+---------+      +-----------------+       +---------+\n```\n\n----------------------------------------\n\nTITLE: Configuring Master SRS Server\nDESCRIPTION: Configuration file for the master SRS server, including forward settings to the slave server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-forward.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# conf/forward.master.conf\nlisten              1935;\nmax_connections     1000;\npid                 ./objs/srs.master.pid;\nsrs_log_tank        file;\nsrs_log_file        ./objs/srs.master.log;\nvhost __defaultVhost__ {\n    forward {\n        enabled on;\n        destination 127.0.0.1:19350;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Edge Server with Remote Mode\nDESCRIPTION: This configuration sets up an SRS edge server in remote mode, specifying the listening port and a vhost with its origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/rtmp-url-vhost.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost demo.srs.com {\n    mode remote;\n    origin: xxxxxxx;\n}\n```\n\n----------------------------------------\n\nTITLE: Different Performance Configuration for Vhosts\nDESCRIPTION: Configuration example showing how to set different chunk sizes for different vhosts to optimize for latency vs startup time.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/rtmp-url-vhost.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost show.cctv.cn {\n    chunk_size 128;\n}\nvhost show.wasu.cn {\n    chunk_size 4096;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring GOP Cache and Queue Length for SRS\nDESCRIPTION: This configuration disables GOP caching and sets a maximum queue length to reduce latency in SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/low-latency.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nlisten              1935;\nvhost __defaultVhost__ {\n    play {\n        gop_cache       off;\n    }\n    queue_length    10;\n}\n```\n\n----------------------------------------\n\nTITLE: Starting SRS with Default Configuration\nDESCRIPTION: This bash snippet shows how to start SRS with the default configuration file, which typically runs in daemon mode and logs to a file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srs.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS in Console Mode\nDESCRIPTION: Command to start SRS server using the console configuration, which runs in foreground mode with logs printed directly to the console rather than a file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/log.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/console.conf \n```\n\n----------------------------------------\n\nTITLE: Viewing Rollout History for SRS Edge Deployment in Kubernetes\nDESCRIPTION: This command displays the rollout history for the SRS edge deployment, showing revision numbers and change causes.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/k8s.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nkubectl rollout history deploy/srs-edge-deploy\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository in Bash\nDESCRIPTION: Commands to clone the SRS GitHub repository and navigate to the trunk directory. Also includes an alternative command to update existing code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Displaying SRS System Info and Port Listening\nDESCRIPTION: This bash snippet shows how to start SRS with a console configuration and view the system info and port listening details in the log file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/log.md#2025-04-23_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c console.conf \ncat objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: Checking SRS Server Status\nDESCRIPTION: Commands to check if SRS is running and view its logs.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/getting-started-build.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# SRS\n./etc/init.d/srs status\n\n# SRS\ntail -n 30 -f ./objs/srs.log\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing Loop\nDESCRIPTION: Continuous FFMPEG command to publish a video stream to RTMP server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/performance.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do \\\n    ./objs/ffmpeg/bin/ffmpeg \\\n        -re -i doc/source.flv \\\n        -acodec copy -vcodec copy \\\n        -f flv rtmp://127.0.0.1:1935/live/livestream; \\\n    sleep 1; \ndone\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Settings\nDESCRIPTION: Simple configuration for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-transcode-to-hls.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Stream Publishing Loop\nDESCRIPTION: Bash script to continuously publish a video file as a live stream using FFMPEG.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ffmpeg.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Visualizing SRS HTTP API Workflow\nDESCRIPTION: Illustrates the workflow of how Chrome or a custom application interacts with SRS server via HTTP API.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/http-api.md#2025-04-23_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n+-------------------------+               +-------+\n+ Chrome/Your Application +--HTTP-API-->--+  SRS  +\n+-------------------------+               +-------+\n```\n\n----------------------------------------\n\nTITLE: Authenticated HTTP API Request with Bearer Token in Bash\nDESCRIPTION: Demonstrates how to make an authenticated HTTP API request to Oryx using a Bearer token.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/terraform/v1/hooks/srs/secret/query \\\n  -X POST -H 'Authorization: Bearer xxxxxx' \\\n  -H 'Content-Type: application/json' --data '{}'\n```\n\n----------------------------------------\n\nTITLE: FMLE Stream Publishing Configuration\nDESCRIPTION: Configuration parameters for Adobe Flash Media Live Encoder (FMLE) to publish a stream to the origin server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/sample-origin-cluster.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170:19350/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: FFmpeg Streaming Command\nDESCRIPTION: FFmpeg command to push a stream to the origin server in a continuous loop.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-origin-cluster.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n    for((;;)); do \\\n        ./objs/ffmpeg/bin/ffmpeg -re -i ./doc/source.flv \\\n        -c copy \\\n        -f flv rtmp://192.168.1.170:19350/live/livestream; \\\n        sleep 1; \\\n    done\n```\n\n----------------------------------------\n\nTITLE: Starting SRS for WebRTC Live Streaming\nDESCRIPTION: Starts SRS with a configuration for converting RTMP to WebRTC, enabling live streaming over WebRTC.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nCANDIDATE=\"192.168.1.10\"\n./objs/srs -c conf/rtmp2rtc.conf\n```\n\n----------------------------------------\n\nTITLE: DVR Stream Filter Configuration\nDESCRIPTION: Example showing how to configure DVR to record specific streams using the dvr_apply filter\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/dvr.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nvhost xxx {\n    dvr {\n        dvr_apply live/stream1 live/stream2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Starting WebRTC Signaling Server\nDESCRIPTION: Docker command to run the SRS signaling server which is required for WebRTC negotiation between peers.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm -p 1989:1989 ossrs/signaling:1\n```\n\n----------------------------------------\n\nTITLE: Checking Out SRS 2.0 Release Branch (Bash)\nDESCRIPTION: Git commands to update the local repository and switch to the SRS 2.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/git.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 2.0release\n```\n\n----------------------------------------\n\nTITLE: Reloading SRS Configuration using Kill Command\nDESCRIPTION: This command sends a SIGHUP signal to all SRS processes, triggering a configuration reload without stopping the service.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/reload.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nkillall -1 srs\n```\n\n----------------------------------------\n\nTITLE: Checking out SRS 1.0 Branch using Git\nDESCRIPTION: Command to pull the latest changes and switch to the SRS 1.0 release branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/git.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit pull && git checkout 1.0release\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARMv7 (hisiv500)\nDESCRIPTION: Commands to cross-compile SRS for ARMv7 using the arm-hisiv500-linux toolchain, specifically for HiSilicon platforms.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/arm.md#2025-04-23_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build --cross-prefix=arm-hisiv500-linux-\nmake\n```\n\n----------------------------------------\n\nTITLE: Using ASAN (Address Sanitizer) with SRS\nDESCRIPTION: Instructions for building and running SRS with ASAN to detect memory issues.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/performance.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nASAN_OPTIONS=halt_on_error=1:detect_leaks=1 ./objs/srs -c conf/console.conf\n```\n\n----------------------------------------\n\nTITLE: Configuring SRS Build with HDS Support\nDESCRIPTION: This snippet shows how to enable HDS support when building SRS from source using the configure script.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/delivery-hds.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --hds=on\n```\n\n----------------------------------------\n\nTITLE: Compiling SRS with FFmpeg Support\nDESCRIPTION: Command to configure and build SRS with FFmpeg tool support enabled, which is required for Ingest functionality.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/sample-ingest.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure --ffmpeg-tool=on && make\n```\n\n----------------------------------------\n\nTITLE: FFmpeg RTMP Streaming Command\nDESCRIPTION: FFmpeg command to stream a local video file to SRS server using RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/webrtc.md#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Requesting SRS HTTP API in Bash\nDESCRIPTION: Shows how to use curl to make a request to the SRS HTTP API proxied by Oryx.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/getting-started-oryx.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://localhost/api/v1/versions\n```\n\n----------------------------------------\n\nTITLE: FFMPEG Encoder Command\nDESCRIPTION: Bash script showing FFMPEG command to publish stream to master server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-6.0/doc/forward.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nfor((;;)); do\\\n    ./objs/ffmpeg/bin/ffmpeg -re -i doc/source.flv \\\n        -c copy -f flv rtmp://192.168.1.5:1935/live/livestream; \\\ndone\n```\n\n----------------------------------------\n\nTITLE: Using FFmpeg to Push Stream to SRS\nDESCRIPTION: FFmpeg command to push a local video file to SRS using RTMP protocol.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/webrtc.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Without Internal SIP Server\nDESCRIPTION: Command to start SRS with external SIP server configuration using the provided configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/current/doc/gb28181.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/gb28181-without-sip.conf\n```\n\n----------------------------------------\n\nTITLE: FFmpeg RTMP Stream Publishing\nDESCRIPTION: FFmpeg command to publish a video stream to RTMP endpoint for HTTP-FLV distribution\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/flv.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: Publishing SRT Stream using FFmpeg\nDESCRIPTION: FFmpeg command to publish a stream using SRT protocol to an SRS server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/srt.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -pes_payload_size 0 -f mpegts \\\n  'srt://127.0.0.1:10080?streamid=#!::r=live/livestream,m=publish'\n```\n\n----------------------------------------\n\nTITLE: Updating Existing SRS Code in Bash\nDESCRIPTION: This command updates an existing SRS codebase by pulling the latest changes from the repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Publishing Live Stream with FFmpeg\nDESCRIPTION: Uses FFmpeg to publish a sample video file as a live stream to SRS.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Configuration parameters for publishing stream using Flash Media Live Encoder (FMLE).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ffmpeg.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Origin Server for HLS\nDESCRIPTION: Command to start the SRS origin server with HLS configuration for a HLS cluster example setup.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-6.0/doc/nginx-for-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/hls.origin.conf\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling SRS for ARM\nDESCRIPTION: Command to configure and build SRS with cross-compilation enabled for ARM architecture. A note indicates that direct building on ARM devices like RaspberryPi should use a different configure command.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-arm.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure --cross-build && make\n```\n\n----------------------------------------\n\nTITLE: Compiling SRS from Source\nDESCRIPTION: Configures and compiles SRS from source code. Requires changing to the srs/trunk directory first.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd srs/trunk\n./configure\nmake\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Source Code Repository\nDESCRIPTION: Downloads the SRS source code from the Git repository, using the develop branch.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-5.0/doc/getting-started-build.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone -b develop https://gitee.com/ossrs/srs.git\n```\n\n----------------------------------------\n\nTITLE: Cloning SRS Repository\nDESCRIPTION: Commands to clone or update the SRS codebase from GitHub repository.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ffmpeg.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the HTTP-FLV configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-http-flv.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/http.flv.live.conf\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the audio-only HLS transcoding configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-transcode-to-hls.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/transcode2hls.audio.only.conf\n```\n\n----------------------------------------\n\nTITLE: Building SRS with Stream Converter Support\nDESCRIPTION: Command line instruction to configure and build SRS with stream converter functionality enabled.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/streamer.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./configure --stream-caster=on\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source\nDESCRIPTION: Commands to configure and compile SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Building SRS from Source in Bash\nDESCRIPTION: Commands to configure and build SRS from source code.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-rtmp-cluster.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./configure && make\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the SRT configuration file.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-srt.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/srt.conf\n```\n\n----------------------------------------\n\nTITLE: Listing Generated Snapshot Files\nDESCRIPTION: Command to list the generated snapshot PNG files in the specified directory.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/snapshot.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nls -lh research/api-server/static-dir/live/*.png\n```\n\n----------------------------------------\n\nTITLE: Starting SRS Server\nDESCRIPTION: Command to start the SRS server with the transcoding configuration.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-docs/current/doc/sample-ffmpeg.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n./objs/srs -c conf/ffmpeg.conf\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Request Header Fields in BNF Notation\nDESCRIPTION: Lists the standard HTTP request header fields that allow clients to provide additional information about the request and themselves to the server.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc2616-1999-http1.1.txt#2025-04-23_snippet_31\n\nLANGUAGE: text\nCODE:\n```\nrequest-header = Accept                   ; Section 14.1\n                      | Accept-Charset           ; Section 14.2\n                      | Accept-Encoding          ; Section 14.3\n                      | Accept-Language          ; Section 14.4\n                      | Authorization            ; Section 14.8\n                      | Expect                   ; Section 14.20\n                      | From                     ; Section 14.22\n                      | Host                     ; Section 14.23\n                      | If-Match                 ; Section 14.24\n                      | If-Modified-Since        ; Section 14.25\n                      | If-None-Match            ; Section 14.26\n                      | If-Range                 ; Section 14.27\n                      | If-Unmodified-Since      ; Section 14.28\n                      | Max-Forwards             ; Section 14.31\n                      | Proxy-Authorization      ; Section 14.34\n                      | Range                    ; Section 14.35\n                      | Referer                  ; Section 14.36\n                      | TE                       ; Section 14.39\n                      | User-Agent               ; Section 14.43\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Request Line Format\nDESCRIPTION: Specifies the format for the request line including method, URI and version.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc1945-1996-http1.0.txt#2025-04-23_snippet_19\n\nLANGUAGE: http\nCODE:\n```\nRequest-Line = Method SP Request-URI SP HTTP-Version CRLF\n```\n\n----------------------------------------\n\nTITLE: Illustrating a Complex Folded Field Body with Comments (RFC 822)\nDESCRIPTION: Presents an example of a folded structured field body (likely part of an address field) containing various lexical symbols recognized by RFC 822 parsers. It includes quoted strings, atoms, comments (enclosed in parentheses), and a domain literal (@(the)Vegas.WBA), demonstrating how these elements interact with folding and linear white space.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/static/files/rfc822-1982-arpa-internet-text-messages.txt#2025-04-23_snippet_11\n\nLANGUAGE: text\nCODE:\n```\n\":sysmail\"@  Some-Group. Some-Org,\nMuhammed.(I am  the greatest) Ali @(the)Vegas.WBA\n```\n\n----------------------------------------\n\nTITLE: Basic WebRTC Flow Diagram\nDESCRIPTION: Illustrates the basic flow of WebRTC traffic over TCP port 80 between publisher, SRS server, and player.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/en-us/docusaurus-plugin-content-blog/2022-09-05-WebRTC-Over-TCP.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nPublisher --------RTC------> SRS --------RTC--------> Player\n            (over TCP/80)           (over TCP/80)\n```\n\n----------------------------------------\n\nTITLE: NGINX HLS System Architecture Diagram\nDESCRIPTION: ASCII diagram showing the flow of video streaming from FFmpeg/OBS through SRS Origin to NGINX Servers and finally to visitors.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/i18n/zh-cn/docusaurus-plugin-content-docs/version-4.0/doc/nginx-for-hls.md#2025-04-23_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n+------------+          +------------+          +------------+          +------------+\n+ FFmpeg/OBS +--RTMP-->-+ SRS Origin +--HLS-->--+ NGINX      +--HLS-->--+ Visitors   +\n+------------+          +------------+          + Servers    +          +------------+\n                                                +------------+          \n```\n\n----------------------------------------\n\nTITLE: Cloning the SRS Repository using Git (Bash)\nDESCRIPTION: Clones the official SRS repository from GitHub using the `git clone` command. This is the first step to get the SRS source code. Requires Git to be installed. The subsequent `cd` command changes the current directory into the `srs/trunk` subdirectory of the downloaded source tree.\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-5.0/doc/sample-transcode-to-hls.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/ossrs/srs\ncd srs/trunk\n```\n\n----------------------------------------\n\nTITLE: FMLE Publishing Configuration\nDESCRIPTION: Configuration settings for publishing stream using Flash Media Live Encoder (FMLE).\nSOURCE: https://github.com/ossrs/srs-docs/blob/main/versioned_docs/version-4.0/doc/sample-realtime.md#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nFMS URL: rtmp://192.168.1.170/live\nStream: livestream\n```"
  }
]